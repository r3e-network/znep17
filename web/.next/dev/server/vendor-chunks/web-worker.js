/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web-worker";
exports.ids = ["vendor-chunks/web-worker"];
exports.modules = {

/***/ "(rsc)/./node_modules/web-worker/cjs/node.js":
/*!*********************************************!*\
  !*** ./node_modules/web-worker/cjs/node.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst URL = __webpack_require__(/*! url */ \"url\");\n\nconst VM = __webpack_require__(/*! vm */ \"vm\");\n\nconst threads = __webpack_require__(/*! worker_threads */ \"worker_threads\");\n\nconst WORKER = Symbol.for('worker');\nconst EVENTS = Symbol.for('events');\n\nclass EventTarget {\n  constructor() {\n    Object.defineProperty(this, EVENTS, {\n      value: new Map()\n    });\n  }\n\n  dispatchEvent(event) {\n    event.target = event.currentTarget = this;\n\n    if (this['on' + event.type]) {\n      try {\n        this['on' + event.type](event);\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n    const list = this[EVENTS].get(event.type);\n    if (list == null) return;\n    list.forEach(handler => {\n      try {\n        handler.call(this, event);\n      } catch (err) {\n        console.error(err);\n      }\n    });\n  }\n\n  addEventListener(type, fn) {\n    let events = this[EVENTS].get(type);\n    if (!events) this[EVENTS].set(type, events = []);\n    events.push(fn);\n  }\n\n  removeEventListener(type, fn) {\n    let events = this[EVENTS].get(type);\n\n    if (events) {\n      const index = events.indexOf(fn);\n      if (index !== -1) events.splice(index, 1);\n    }\n  }\n\n}\n\nfunction Event(type, target) {\n  this.type = type;\n  this.timeStamp = Date.now();\n  this.target = this.currentTarget = this.data = null;\n} // this module is used self-referentially on both sides of the\n// thread boundary, but behaves differently in each context.\n\n\nmodule.exports = threads.isMainThread ? mainThread() : workerThread();\nconst baseUrl = URL.pathToFileURL(process.cwd() + '/');\n\nfunction mainThread() {\n  /**\n   * A web-compatible Worker implementation atop Node's worker_threads.\n   *  - uses DOM-style events (Event.data, Event.type, etc)\n   *  - supports event handler properties (worker.onmessage)\n   *  - Worker() constructor accepts a module URL\n   *  - accepts the {type:'module'} option\n   *  - emulates WorkerGlobalScope within the worker\n   * @param {string} url  The URL or module specifier to load\n   * @param {object} [options]  Worker construction options\n   * @param {string} [options.name]  Available as `self.name` within the Worker\n   * @param {string} [options.type=\"classic\"]  Pass \"module\" to create a Module Worker.\n   */\n  class Worker extends EventTarget {\n    constructor(url, options) {\n      super();\n      const {\n        name,\n        type\n      } = options || {};\n      url += '';\n      let mod;\n\n      if (/^data:/.test(url)) {\n        mod = url;\n      } else {\n        mod = URL.fileURLToPath(new URL.URL(url, baseUrl));\n      }\n\n      const worker = new threads.Worker(__filename, {\n        workerData: {\n          mod,\n          name,\n          type\n        }\n      });\n      Object.defineProperty(this, WORKER, {\n        value: worker\n      });\n      worker.on('message', data => {\n        const event = new Event('message');\n        event.data = data;\n        this.dispatchEvent(event);\n      });\n      worker.on('error', error => {\n        error.type = 'error';\n        this.dispatchEvent(error);\n      });\n      worker.on('exit', () => {\n        this.dispatchEvent(new Event('close'));\n      });\n    }\n\n    postMessage(data, transferList) {\n      this[WORKER].postMessage(data, transferList);\n    }\n\n    terminate() {\n      this[WORKER].terminate();\n    }\n\n  }\n\n  Worker.prototype.onmessage = Worker.prototype.onerror = Worker.prototype.onclose = null;\n  return Worker;\n}\n\nfunction workerThread() {\n  let {\n    mod,\n    name,\n    type\n  } = threads.workerData; // turn global into a mock WorkerGlobalScope\n\n  const self = global.self = global; // enqueue messages to dispatch after modules are loaded\n\n  let q = [];\n\n  function flush() {\n    const buffered = q;\n    q = null;\n    buffered.forEach(event => {\n      self.dispatchEvent(event);\n    });\n  }\n\n  threads.parentPort.on('message', data => {\n    const event = new Event('message');\n    event.data = data;\n    if (q == null) self.dispatchEvent(event);else q.push(event);\n  });\n  threads.parentPort.on('error', err => {\n    err.type = 'Error';\n    self.dispatchEvent(err);\n  });\n\n  class WorkerGlobalScope extends EventTarget {\n    postMessage(data, transferList) {\n      threads.parentPort.postMessage(data, transferList);\n    } // Emulates https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope/close\n\n\n    close() {\n      process.exit();\n    }\n\n  }\n\n  let proto = Object.getPrototypeOf(global);\n  delete proto.constructor;\n  Object.defineProperties(WorkerGlobalScope.prototype, proto);\n  proto = Object.setPrototypeOf(global, new WorkerGlobalScope());\n  ['postMessage', 'addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(fn => {\n    proto[fn] = proto[fn].bind(global);\n  });\n  global.name = name;\n  const isDataUrl = /^data:/.test(mod);\n\n  if (type === 'module') {\n    __webpack_require__(\"(rsc)/./node_modules/web-worker/cjs lazy recursive\")(mod).catch(err => {\n      if (isDataUrl && err.message === 'Not supported') {\n        console.warn('Worker(): Importing data: URLs requires Node 12.10+. Falling back to classic worker.');\n        return evaluateDataUrl(mod, name);\n      }\n\n      console.error(err);\n    }).then(flush);\n  } else {\n    try {\n      if (/^data:/.test(mod)) {\n        evaluateDataUrl(mod, name);\n      } else {\n        __webpack_require__(\"(rsc)/./node_modules/web-worker/cjs sync recursive\")(mod);\n      }\n    } catch (err) {\n      console.error(err);\n    }\n\n    Promise.resolve().then(flush);\n  }\n}\n\nfunction evaluateDataUrl(url, name) {\n  const {\n    data\n  } = parseDataUrl(url);\n  return VM.runInThisContext(data, {\n    filename: 'worker.<' + (name || 'data:') + '>'\n  });\n}\n\nfunction parseDataUrl(url) {\n  let [m, type, encoding, data] = url.match(/^data: *([^;,]*)(?: *; *([^,]*))? *,(.*)$/) || [];\n  if (!m) throw Error('Invalid Data URL.');\n  if (encoding) switch (encoding.toLowerCase()) {\n    case 'base64':\n      data = Buffer.from(data, 'base64').toString();\n      break;\n\n    default:\n      throw Error('Unknown Data URL encoding \"' + encoding + '\"');\n  }\n  return {\n    type,\n    data\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXdvcmtlci9janMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7O0FBRXpCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJOztBQUV2QixnQkFBZ0IsbUJBQU8sQ0FBQyxzQ0FBZ0I7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7O0FBRTFCLHFDQUFxQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsSUFBSSwwRUFBTyxHQUFHLENBQUM7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVEsMEVBQVEsR0FBRyxDQUFDO0FBQ3BCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3dlYi13b3JrZXIvY2pzL25vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBVUkwgPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgVk0gPSByZXF1aXJlKCd2bScpO1xuXG5jb25zdCB0aHJlYWRzID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKTtcblxuY29uc3QgV09SS0VSID0gU3ltYm9sLmZvcignd29ya2VyJyk7XG5jb25zdCBFVkVOVFMgPSBTeW1ib2wuZm9yKCdldmVudHMnKTtcblxuY2xhc3MgRXZlbnRUYXJnZXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgRVZFTlRTLCB7XG4gICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgfSk7XG4gIH1cblxuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG5cbiAgICBpZiAodGhpc1snb24nICsgZXZlbnQudHlwZV0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXNbJ29uJyArIGV2ZW50LnR5cGVdKGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdCA9IHRoaXNbRVZFTlRTXS5nZXQoZXZlbnQudHlwZSk7XG4gICAgaWYgKGxpc3QgPT0gbnVsbCkgcmV0dXJuO1xuICAgIGxpc3QuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbikge1xuICAgIGxldCBldmVudHMgPSB0aGlzW0VWRU5UU10uZ2V0KHR5cGUpO1xuICAgIGlmICghZXZlbnRzKSB0aGlzW0VWRU5UU10uc2V0KHR5cGUsIGV2ZW50cyA9IFtdKTtcbiAgICBldmVudHMucHVzaChmbik7XG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuKSB7XG4gICAgbGV0IGV2ZW50cyA9IHRoaXNbRVZFTlRTXS5nZXQodHlwZSk7XG5cbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGV2ZW50cy5pbmRleE9mKGZuKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIGV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIEV2ZW50KHR5cGUsIHRhcmdldCkge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gIHRoaXMudGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGhpcy5kYXRhID0gbnVsbDtcbn0gLy8gdGhpcyBtb2R1bGUgaXMgdXNlZCBzZWxmLXJlZmVyZW50aWFsbHkgb24gYm90aCBzaWRlcyBvZiB0aGVcbi8vIHRocmVhZCBib3VuZGFyeSwgYnV0IGJlaGF2ZXMgZGlmZmVyZW50bHkgaW4gZWFjaCBjb250ZXh0LlxuXG5cbm1vZHVsZS5leHBvcnRzID0gdGhyZWFkcy5pc01haW5UaHJlYWQgPyBtYWluVGhyZWFkKCkgOiB3b3JrZXJUaHJlYWQoKTtcbmNvbnN0IGJhc2VVcmwgPSBVUkwucGF0aFRvRmlsZVVSTChwcm9jZXNzLmN3ZCgpICsgJy8nKTtcblxuZnVuY3Rpb24gbWFpblRocmVhZCgpIHtcbiAgLyoqXG4gICAqIEEgd2ViLWNvbXBhdGlibGUgV29ya2VyIGltcGxlbWVudGF0aW9uIGF0b3AgTm9kZSdzIHdvcmtlcl90aHJlYWRzLlxuICAgKiAgLSB1c2VzIERPTS1zdHlsZSBldmVudHMgKEV2ZW50LmRhdGEsIEV2ZW50LnR5cGUsIGV0YylcbiAgICogIC0gc3VwcG9ydHMgZXZlbnQgaGFuZGxlciBwcm9wZXJ0aWVzICh3b3JrZXIub25tZXNzYWdlKVxuICAgKiAgLSBXb3JrZXIoKSBjb25zdHJ1Y3RvciBhY2NlcHRzIGEgbW9kdWxlIFVSTFxuICAgKiAgLSBhY2NlcHRzIHRoZSB7dHlwZTonbW9kdWxlJ30gb3B0aW9uXG4gICAqICAtIGVtdWxhdGVzIFdvcmtlckdsb2JhbFNjb3BlIHdpdGhpbiB0aGUgd29ya2VyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgIFRoZSBVUkwgb3IgbW9kdWxlIHNwZWNpZmllciB0byBsb2FkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gIFdvcmtlciBjb25zdHJ1Y3Rpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV0gIEF2YWlsYWJsZSBhcyBgc2VsZi5uYW1lYCB3aXRoaW4gdGhlIFdvcmtlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHlwZT1cImNsYXNzaWNcIl0gIFBhc3MgXCJtb2R1bGVcIiB0byBjcmVhdGUgYSBNb2R1bGUgV29ya2VyLlxuICAgKi9cbiAgY2xhc3MgV29ya2VyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICB1cmwgKz0gJyc7XG4gICAgICBsZXQgbW9kO1xuXG4gICAgICBpZiAoL15kYXRhOi8udGVzdCh1cmwpKSB7XG4gICAgICAgIG1vZCA9IHVybDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZCA9IFVSTC5maWxlVVJMVG9QYXRoKG5ldyBVUkwuVVJMKHVybCwgYmFzZVVybCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3b3JrZXIgPSBuZXcgdGhyZWFkcy5Xb3JrZXIoX19maWxlbmFtZSwge1xuICAgICAgICB3b3JrZXJEYXRhOiB7XG4gICAgICAgICAgbW9kLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHlwZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBXT1JLRVIsIHtcbiAgICAgICAgdmFsdWU6IHdvcmtlclxuICAgICAgfSk7XG4gICAgICB3b3JrZXIub24oJ21lc3NhZ2UnLCBkYXRhID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ21lc3NhZ2UnKTtcbiAgICAgICAgZXZlbnQuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHdvcmtlci5vbignZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgIGVycm9yLnR5cGUgPSAnZXJyb3InO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICB3b3JrZXIub24oJ2V4aXQnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Nsb3NlJykpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KSB7XG4gICAgICB0aGlzW1dPUktFUl0ucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTtcbiAgICB9XG5cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICB0aGlzW1dPUktFUl0udGVybWluYXRlKCk7XG4gICAgfVxuXG4gIH1cblxuICBXb3JrZXIucHJvdG90eXBlLm9ubWVzc2FnZSA9IFdvcmtlci5wcm90b3R5cGUub25lcnJvciA9IFdvcmtlci5wcm90b3R5cGUub25jbG9zZSA9IG51bGw7XG4gIHJldHVybiBXb3JrZXI7XG59XG5cbmZ1bmN0aW9uIHdvcmtlclRocmVhZCgpIHtcbiAgbGV0IHtcbiAgICBtb2QsXG4gICAgbmFtZSxcbiAgICB0eXBlXG4gIH0gPSB0aHJlYWRzLndvcmtlckRhdGE7IC8vIHR1cm4gZ2xvYmFsIGludG8gYSBtb2NrIFdvcmtlckdsb2JhbFNjb3BlXG5cbiAgY29uc3Qgc2VsZiA9IGdsb2JhbC5zZWxmID0gZ2xvYmFsOyAvLyBlbnF1ZXVlIG1lc3NhZ2VzIHRvIGRpc3BhdGNoIGFmdGVyIG1vZHVsZXMgYXJlIGxvYWRlZFxuXG4gIGxldCBxID0gW107XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgY29uc3QgYnVmZmVyZWQgPSBxO1xuICAgIHEgPSBudWxsO1xuICAgIGJ1ZmZlcmVkLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHRocmVhZHMucGFyZW50UG9ydC5vbignbWVzc2FnZScsIGRhdGEgPT4ge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdtZXNzYWdlJyk7XG4gICAgZXZlbnQuZGF0YSA9IGRhdGE7XG4gICAgaWYgKHEgPT0gbnVsbCkgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtlbHNlIHEucHVzaChldmVudCk7XG4gIH0pO1xuICB0aHJlYWRzLnBhcmVudFBvcnQub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICBlcnIudHlwZSA9ICdFcnJvcic7XG4gICAgc2VsZi5kaXNwYXRjaEV2ZW50KGVycik7XG4gIH0pO1xuXG4gIGNsYXNzIFdvcmtlckdsb2JhbFNjb3BlIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIHBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCkge1xuICAgICAgdGhyZWFkcy5wYXJlbnRQb3J0LnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCk7XG4gICAgfSAvLyBFbXVsYXRlcyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGUvY2xvc2VcblxuXG4gICAgY2xvc2UoKSB7XG4gICAgICBwcm9jZXNzLmV4aXQoKTtcbiAgICB9XG5cbiAgfVxuXG4gIGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICBkZWxldGUgcHJvdG8uY29uc3RydWN0b3I7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdvcmtlckdsb2JhbFNjb3BlLnByb3RvdHlwZSwgcHJvdG8pO1xuICBwcm90byA9IE9iamVjdC5zZXRQcm90b3R5cGVPZihnbG9iYWwsIG5ldyBXb3JrZXJHbG9iYWxTY29wZSgpKTtcbiAgWydwb3N0TWVzc2FnZScsICdhZGRFdmVudExpc3RlbmVyJywgJ3JlbW92ZUV2ZW50TGlzdGVuZXInLCAnZGlzcGF0Y2hFdmVudCddLmZvckVhY2goZm4gPT4ge1xuICAgIHByb3RvW2ZuXSA9IHByb3RvW2ZuXS5iaW5kKGdsb2JhbCk7XG4gIH0pO1xuICBnbG9iYWwubmFtZSA9IG5hbWU7XG4gIGNvbnN0IGlzRGF0YVVybCA9IC9eZGF0YTovLnRlc3QobW9kKTtcblxuICBpZiAodHlwZSA9PT0gJ21vZHVsZScpIHtcbiAgICBpbXBvcnQobW9kKS5jYXRjaChlcnIgPT4ge1xuICAgICAgaWYgKGlzRGF0YVVybCAmJiBlcnIubWVzc2FnZSA9PT0gJ05vdCBzdXBwb3J0ZWQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV29ya2VyKCk6IEltcG9ydGluZyBkYXRhOiBVUkxzIHJlcXVpcmVzIE5vZGUgMTIuMTArLiBGYWxsaW5nIGJhY2sgdG8gY2xhc3NpYyB3b3JrZXIuJyk7XG4gICAgICAgIHJldHVybiBldmFsdWF0ZURhdGFVcmwobW9kLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0pLnRoZW4oZmx1c2gpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoL15kYXRhOi8udGVzdChtb2QpKSB7XG4gICAgICAgIGV2YWx1YXRlRGF0YVVybChtb2QsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWlyZShtb2QpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cblxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZmx1c2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlRGF0YVVybCh1cmwsIG5hbWUpIHtcbiAgY29uc3Qge1xuICAgIGRhdGFcbiAgfSA9IHBhcnNlRGF0YVVybCh1cmwpO1xuICByZXR1cm4gVk0ucnVuSW5UaGlzQ29udGV4dChkYXRhLCB7XG4gICAgZmlsZW5hbWU6ICd3b3JrZXIuPCcgKyAobmFtZSB8fCAnZGF0YTonKSArICc+J1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRhVXJsKHVybCkge1xuICBsZXQgW20sIHR5cGUsIGVuY29kaW5nLCBkYXRhXSA9IHVybC5tYXRjaCgvXmRhdGE6ICooW147LF0qKSg/OiAqOyAqKFteLF0qKSk/ICosKC4qKSQvKSB8fCBbXTtcbiAgaWYgKCFtKSB0aHJvdyBFcnJvcignSW52YWxpZCBEYXRhIFVSTC4nKTtcbiAgaWYgKGVuY29kaW5nKSBzd2l0Y2ggKGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKS50b1N0cmluZygpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gRGF0YSBVUkwgZW5jb2RpbmcgXCInICsgZW5jb2RpbmcgKyAnXCInKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgZGF0YVxuICB9O1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-worker/cjs/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web-worker/cjs/node.js":
/*!*********************************************!*\
  !*** ./node_modules/web-worker/cjs/node.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst URL = __webpack_require__(/*! url */ \"url\");\n\nconst VM = __webpack_require__(/*! vm */ \"vm\");\n\nconst threads = __webpack_require__(/*! worker_threads */ \"worker_threads\");\n\nconst WORKER = Symbol.for('worker');\nconst EVENTS = Symbol.for('events');\n\nclass EventTarget {\n  constructor() {\n    Object.defineProperty(this, EVENTS, {\n      value: new Map()\n    });\n  }\n\n  dispatchEvent(event) {\n    event.target = event.currentTarget = this;\n\n    if (this['on' + event.type]) {\n      try {\n        this['on' + event.type](event);\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n    const list = this[EVENTS].get(event.type);\n    if (list == null) return;\n    list.forEach(handler => {\n      try {\n        handler.call(this, event);\n      } catch (err) {\n        console.error(err);\n      }\n    });\n  }\n\n  addEventListener(type, fn) {\n    let events = this[EVENTS].get(type);\n    if (!events) this[EVENTS].set(type, events = []);\n    events.push(fn);\n  }\n\n  removeEventListener(type, fn) {\n    let events = this[EVENTS].get(type);\n\n    if (events) {\n      const index = events.indexOf(fn);\n      if (index !== -1) events.splice(index, 1);\n    }\n  }\n\n}\n\nfunction Event(type, target) {\n  this.type = type;\n  this.timeStamp = Date.now();\n  this.target = this.currentTarget = this.data = null;\n} // this module is used self-referentially on both sides of the\n// thread boundary, but behaves differently in each context.\n\n\nmodule.exports = threads.isMainThread ? mainThread() : workerThread();\nconst baseUrl = URL.pathToFileURL(process.cwd() + '/');\n\nfunction mainThread() {\n  /**\n   * A web-compatible Worker implementation atop Node's worker_threads.\n   *  - uses DOM-style events (Event.data, Event.type, etc)\n   *  - supports event handler properties (worker.onmessage)\n   *  - Worker() constructor accepts a module URL\n   *  - accepts the {type:'module'} option\n   *  - emulates WorkerGlobalScope within the worker\n   * @param {string} url  The URL or module specifier to load\n   * @param {object} [options]  Worker construction options\n   * @param {string} [options.name]  Available as `self.name` within the Worker\n   * @param {string} [options.type=\"classic\"]  Pass \"module\" to create a Module Worker.\n   */\n  class Worker extends EventTarget {\n    constructor(url, options) {\n      super();\n      const {\n        name,\n        type\n      } = options || {};\n      url += '';\n      let mod;\n\n      if (/^data:/.test(url)) {\n        mod = url;\n      } else {\n        mod = URL.fileURLToPath(new URL.URL(url, baseUrl));\n      }\n\n      const worker = new threads.Worker(__filename, {\n        workerData: {\n          mod,\n          name,\n          type\n        }\n      });\n      Object.defineProperty(this, WORKER, {\n        value: worker\n      });\n      worker.on('message', data => {\n        const event = new Event('message');\n        event.data = data;\n        this.dispatchEvent(event);\n      });\n      worker.on('error', error => {\n        error.type = 'error';\n        this.dispatchEvent(error);\n      });\n      worker.on('exit', () => {\n        this.dispatchEvent(new Event('close'));\n      });\n    }\n\n    postMessage(data, transferList) {\n      this[WORKER].postMessage(data, transferList);\n    }\n\n    terminate() {\n      this[WORKER].terminate();\n    }\n\n  }\n\n  Worker.prototype.onmessage = Worker.prototype.onerror = Worker.prototype.onclose = null;\n  return Worker;\n}\n\nfunction workerThread() {\n  let {\n    mod,\n    name,\n    type\n  } = threads.workerData; // turn global into a mock WorkerGlobalScope\n\n  const self = global.self = global; // enqueue messages to dispatch after modules are loaded\n\n  let q = [];\n\n  function flush() {\n    const buffered = q;\n    q = null;\n    buffered.forEach(event => {\n      self.dispatchEvent(event);\n    });\n  }\n\n  threads.parentPort.on('message', data => {\n    const event = new Event('message');\n    event.data = data;\n    if (q == null) self.dispatchEvent(event);else q.push(event);\n  });\n  threads.parentPort.on('error', err => {\n    err.type = 'Error';\n    self.dispatchEvent(err);\n  });\n\n  class WorkerGlobalScope extends EventTarget {\n    postMessage(data, transferList) {\n      threads.parentPort.postMessage(data, transferList);\n    } // Emulates https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope/close\n\n\n    close() {\n      process.exit();\n    }\n\n  }\n\n  let proto = Object.getPrototypeOf(global);\n  delete proto.constructor;\n  Object.defineProperties(WorkerGlobalScope.prototype, proto);\n  proto = Object.setPrototypeOf(global, new WorkerGlobalScope());\n  ['postMessage', 'addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(fn => {\n    proto[fn] = proto[fn].bind(global);\n  });\n  global.name = name;\n  const isDataUrl = /^data:/.test(mod);\n\n  if (type === 'module') {\n    __webpack_require__(\"(ssr)/./node_modules/web-worker/cjs lazy recursive\")(mod).catch(err => {\n      if (isDataUrl && err.message === 'Not supported') {\n        console.warn('Worker(): Importing data: URLs requires Node 12.10+. Falling back to classic worker.');\n        return evaluateDataUrl(mod, name);\n      }\n\n      console.error(err);\n    }).then(flush);\n  } else {\n    try {\n      if (/^data:/.test(mod)) {\n        evaluateDataUrl(mod, name);\n      } else {\n        __webpack_require__(\"(ssr)/./node_modules/web-worker/cjs sync recursive\")(mod);\n      }\n    } catch (err) {\n      console.error(err);\n    }\n\n    Promise.resolve().then(flush);\n  }\n}\n\nfunction evaluateDataUrl(url, name) {\n  const {\n    data\n  } = parseDataUrl(url);\n  return VM.runInThisContext(data, {\n    filename: 'worker.<' + (name || 'data:') + '>'\n  });\n}\n\nfunction parseDataUrl(url) {\n  let [m, type, encoding, data] = url.match(/^data: *([^;,]*)(?: *; *([^,]*))? *,(.*)$/) || [];\n  if (!m) throw Error('Invalid Data URL.');\n  if (encoding) switch (encoding.toLowerCase()) {\n    case 'base64':\n      data = Buffer.from(data, 'base64').toString();\n      break;\n\n    default:\n      throw Error('Unknown Data URL encoding \"' + encoding + '\"');\n  }\n  return {\n    type,\n    data\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViLXdvcmtlci9janMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7O0FBRXpCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJOztBQUV2QixnQkFBZ0IsbUJBQU8sQ0FBQyxzQ0FBZ0I7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7O0FBRTFCLHFDQUFxQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsSUFBSSwwRUFBTyxHQUFHLENBQUM7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVEsMEVBQVEsR0FBRyxDQUFDO0FBQ3BCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3dlYi13b3JrZXIvY2pzL25vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBVUkwgPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgVk0gPSByZXF1aXJlKCd2bScpO1xuXG5jb25zdCB0aHJlYWRzID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKTtcblxuY29uc3QgV09SS0VSID0gU3ltYm9sLmZvcignd29ya2VyJyk7XG5jb25zdCBFVkVOVFMgPSBTeW1ib2wuZm9yKCdldmVudHMnKTtcblxuY2xhc3MgRXZlbnRUYXJnZXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgRVZFTlRTLCB7XG4gICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgfSk7XG4gIH1cblxuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG5cbiAgICBpZiAodGhpc1snb24nICsgZXZlbnQudHlwZV0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXNbJ29uJyArIGV2ZW50LnR5cGVdKGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdCA9IHRoaXNbRVZFTlRTXS5nZXQoZXZlbnQudHlwZSk7XG4gICAgaWYgKGxpc3QgPT0gbnVsbCkgcmV0dXJuO1xuICAgIGxpc3QuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbikge1xuICAgIGxldCBldmVudHMgPSB0aGlzW0VWRU5UU10uZ2V0KHR5cGUpO1xuICAgIGlmICghZXZlbnRzKSB0aGlzW0VWRU5UU10uc2V0KHR5cGUsIGV2ZW50cyA9IFtdKTtcbiAgICBldmVudHMucHVzaChmbik7XG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuKSB7XG4gICAgbGV0IGV2ZW50cyA9IHRoaXNbRVZFTlRTXS5nZXQodHlwZSk7XG5cbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGV2ZW50cy5pbmRleE9mKGZuKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIGV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIEV2ZW50KHR5cGUsIHRhcmdldCkge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gIHRoaXMudGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGhpcy5kYXRhID0gbnVsbDtcbn0gLy8gdGhpcyBtb2R1bGUgaXMgdXNlZCBzZWxmLXJlZmVyZW50aWFsbHkgb24gYm90aCBzaWRlcyBvZiB0aGVcbi8vIHRocmVhZCBib3VuZGFyeSwgYnV0IGJlaGF2ZXMgZGlmZmVyZW50bHkgaW4gZWFjaCBjb250ZXh0LlxuXG5cbm1vZHVsZS5leHBvcnRzID0gdGhyZWFkcy5pc01haW5UaHJlYWQgPyBtYWluVGhyZWFkKCkgOiB3b3JrZXJUaHJlYWQoKTtcbmNvbnN0IGJhc2VVcmwgPSBVUkwucGF0aFRvRmlsZVVSTChwcm9jZXNzLmN3ZCgpICsgJy8nKTtcblxuZnVuY3Rpb24gbWFpblRocmVhZCgpIHtcbiAgLyoqXG4gICAqIEEgd2ViLWNvbXBhdGlibGUgV29ya2VyIGltcGxlbWVudGF0aW9uIGF0b3AgTm9kZSdzIHdvcmtlcl90aHJlYWRzLlxuICAgKiAgLSB1c2VzIERPTS1zdHlsZSBldmVudHMgKEV2ZW50LmRhdGEsIEV2ZW50LnR5cGUsIGV0YylcbiAgICogIC0gc3VwcG9ydHMgZXZlbnQgaGFuZGxlciBwcm9wZXJ0aWVzICh3b3JrZXIub25tZXNzYWdlKVxuICAgKiAgLSBXb3JrZXIoKSBjb25zdHJ1Y3RvciBhY2NlcHRzIGEgbW9kdWxlIFVSTFxuICAgKiAgLSBhY2NlcHRzIHRoZSB7dHlwZTonbW9kdWxlJ30gb3B0aW9uXG4gICAqICAtIGVtdWxhdGVzIFdvcmtlckdsb2JhbFNjb3BlIHdpdGhpbiB0aGUgd29ya2VyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgIFRoZSBVUkwgb3IgbW9kdWxlIHNwZWNpZmllciB0byBsb2FkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gIFdvcmtlciBjb25zdHJ1Y3Rpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV0gIEF2YWlsYWJsZSBhcyBgc2VsZi5uYW1lYCB3aXRoaW4gdGhlIFdvcmtlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHlwZT1cImNsYXNzaWNcIl0gIFBhc3MgXCJtb2R1bGVcIiB0byBjcmVhdGUgYSBNb2R1bGUgV29ya2VyLlxuICAgKi9cbiAgY2xhc3MgV29ya2VyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICB1cmwgKz0gJyc7XG4gICAgICBsZXQgbW9kO1xuXG4gICAgICBpZiAoL15kYXRhOi8udGVzdCh1cmwpKSB7XG4gICAgICAgIG1vZCA9IHVybDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZCA9IFVSTC5maWxlVVJMVG9QYXRoKG5ldyBVUkwuVVJMKHVybCwgYmFzZVVybCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3b3JrZXIgPSBuZXcgdGhyZWFkcy5Xb3JrZXIoX19maWxlbmFtZSwge1xuICAgICAgICB3b3JrZXJEYXRhOiB7XG4gICAgICAgICAgbW9kLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHlwZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBXT1JLRVIsIHtcbiAgICAgICAgdmFsdWU6IHdvcmtlclxuICAgICAgfSk7XG4gICAgICB3b3JrZXIub24oJ21lc3NhZ2UnLCBkYXRhID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ21lc3NhZ2UnKTtcbiAgICAgICAgZXZlbnQuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHdvcmtlci5vbignZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgIGVycm9yLnR5cGUgPSAnZXJyb3InO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICB3b3JrZXIub24oJ2V4aXQnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Nsb3NlJykpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KSB7XG4gICAgICB0aGlzW1dPUktFUl0ucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTtcbiAgICB9XG5cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICB0aGlzW1dPUktFUl0udGVybWluYXRlKCk7XG4gICAgfVxuXG4gIH1cblxuICBXb3JrZXIucHJvdG90eXBlLm9ubWVzc2FnZSA9IFdvcmtlci5wcm90b3R5cGUub25lcnJvciA9IFdvcmtlci5wcm90b3R5cGUub25jbG9zZSA9IG51bGw7XG4gIHJldHVybiBXb3JrZXI7XG59XG5cbmZ1bmN0aW9uIHdvcmtlclRocmVhZCgpIHtcbiAgbGV0IHtcbiAgICBtb2QsXG4gICAgbmFtZSxcbiAgICB0eXBlXG4gIH0gPSB0aHJlYWRzLndvcmtlckRhdGE7IC8vIHR1cm4gZ2xvYmFsIGludG8gYSBtb2NrIFdvcmtlckdsb2JhbFNjb3BlXG5cbiAgY29uc3Qgc2VsZiA9IGdsb2JhbC5zZWxmID0gZ2xvYmFsOyAvLyBlbnF1ZXVlIG1lc3NhZ2VzIHRvIGRpc3BhdGNoIGFmdGVyIG1vZHVsZXMgYXJlIGxvYWRlZFxuXG4gIGxldCBxID0gW107XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgY29uc3QgYnVmZmVyZWQgPSBxO1xuICAgIHEgPSBudWxsO1xuICAgIGJ1ZmZlcmVkLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHRocmVhZHMucGFyZW50UG9ydC5vbignbWVzc2FnZScsIGRhdGEgPT4ge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdtZXNzYWdlJyk7XG4gICAgZXZlbnQuZGF0YSA9IGRhdGE7XG4gICAgaWYgKHEgPT0gbnVsbCkgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtlbHNlIHEucHVzaChldmVudCk7XG4gIH0pO1xuICB0aHJlYWRzLnBhcmVudFBvcnQub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICBlcnIudHlwZSA9ICdFcnJvcic7XG4gICAgc2VsZi5kaXNwYXRjaEV2ZW50KGVycik7XG4gIH0pO1xuXG4gIGNsYXNzIFdvcmtlckdsb2JhbFNjb3BlIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIHBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCkge1xuICAgICAgdGhyZWFkcy5wYXJlbnRQb3J0LnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCk7XG4gICAgfSAvLyBFbXVsYXRlcyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGUvY2xvc2VcblxuXG4gICAgY2xvc2UoKSB7XG4gICAgICBwcm9jZXNzLmV4aXQoKTtcbiAgICB9XG5cbiAgfVxuXG4gIGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICBkZWxldGUgcHJvdG8uY29uc3RydWN0b3I7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdvcmtlckdsb2JhbFNjb3BlLnByb3RvdHlwZSwgcHJvdG8pO1xuICBwcm90byA9IE9iamVjdC5zZXRQcm90b3R5cGVPZihnbG9iYWwsIG5ldyBXb3JrZXJHbG9iYWxTY29wZSgpKTtcbiAgWydwb3N0TWVzc2FnZScsICdhZGRFdmVudExpc3RlbmVyJywgJ3JlbW92ZUV2ZW50TGlzdGVuZXInLCAnZGlzcGF0Y2hFdmVudCddLmZvckVhY2goZm4gPT4ge1xuICAgIHByb3RvW2ZuXSA9IHByb3RvW2ZuXS5iaW5kKGdsb2JhbCk7XG4gIH0pO1xuICBnbG9iYWwubmFtZSA9IG5hbWU7XG4gIGNvbnN0IGlzRGF0YVVybCA9IC9eZGF0YTovLnRlc3QobW9kKTtcblxuICBpZiAodHlwZSA9PT0gJ21vZHVsZScpIHtcbiAgICBpbXBvcnQobW9kKS5jYXRjaChlcnIgPT4ge1xuICAgICAgaWYgKGlzRGF0YVVybCAmJiBlcnIubWVzc2FnZSA9PT0gJ05vdCBzdXBwb3J0ZWQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV29ya2VyKCk6IEltcG9ydGluZyBkYXRhOiBVUkxzIHJlcXVpcmVzIE5vZGUgMTIuMTArLiBGYWxsaW5nIGJhY2sgdG8gY2xhc3NpYyB3b3JrZXIuJyk7XG4gICAgICAgIHJldHVybiBldmFsdWF0ZURhdGFVcmwobW9kLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0pLnRoZW4oZmx1c2gpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBpZiAoL15kYXRhOi8udGVzdChtb2QpKSB7XG4gICAgICAgIGV2YWx1YXRlRGF0YVVybChtb2QsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWlyZShtb2QpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cblxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZmx1c2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlRGF0YVVybCh1cmwsIG5hbWUpIHtcbiAgY29uc3Qge1xuICAgIGRhdGFcbiAgfSA9IHBhcnNlRGF0YVVybCh1cmwpO1xuICByZXR1cm4gVk0ucnVuSW5UaGlzQ29udGV4dChkYXRhLCB7XG4gICAgZmlsZW5hbWU6ICd3b3JrZXIuPCcgKyAobmFtZSB8fCAnZGF0YTonKSArICc+J1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRhVXJsKHVybCkge1xuICBsZXQgW20sIHR5cGUsIGVuY29kaW5nLCBkYXRhXSA9IHVybC5tYXRjaCgvXmRhdGE6ICooW147LF0qKSg/OiAqOyAqKFteLF0qKSk/ICosKC4qKSQvKSB8fCBbXTtcbiAgaWYgKCFtKSB0aHJvdyBFcnJvcignSW52YWxpZCBEYXRhIFVSTC4nKTtcbiAgaWYgKGVuY29kaW5nKSBzd2l0Y2ggKGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKS50b1N0cmluZygpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gRGF0YSBVUkwgZW5jb2RpbmcgXCInICsgZW5jb2RpbmcgKyAnXCInKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgZGF0YVxuICB9O1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web-worker/cjs/node.js\n");

/***/ })

};
;