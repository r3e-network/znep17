"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/snarkjs";
exports.ids = ["vendor-chunks/snarkjs"];
exports.modules = {

/***/ "(rsc)/./node_modules/snarkjs/main.js":
/*!**************************************!*\
  !*** ./node_modules/snarkjs/main.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curves: () => (/* reexport module object */ _src_curves_js__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   fflonk: () => (/* reexport module object */ _src_fflonk_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   groth16: () => (/* reexport module object */ _src_groth16_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   plonk: () => (/* reexport module object */ _src_plonk_js__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   powersOfTau: () => (/* reexport module object */ _src_powersoftau_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   r1cs: () => (/* reexport module object */ _src_r1cs_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   wtns: () => (/* reexport module object */ _src_wtns_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   zKey: () => (/* reexport module object */ _src_zkey_js__WEBPACK_IMPORTED_MODULE_4__)\n/* harmony export */ });\n/* harmony import */ var _src_groth16_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/groth16.js */ \"(rsc)/./node_modules/snarkjs/src/groth16.js\");\n/* harmony import */ var _src_powersoftau_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/powersoftau.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau.js\");\n/* harmony import */ var _src_r1cs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/r1cs.js */ \"(rsc)/./node_modules/snarkjs/src/r1cs.js\");\n/* harmony import */ var _src_wtns_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/wtns.js */ \"(rsc)/./node_modules/snarkjs/src/wtns.js\");\n/* harmony import */ var _src_zkey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/zkey.js */ \"(rsc)/./node_modules/snarkjs/src/zkey.js\");\n/* harmony import */ var _src_plonk_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/plonk.js */ \"(rsc)/./node_modules/snarkjs/src/plonk.js\");\n/* harmony import */ var _src_fflonk_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/fflonk.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk.js\");\n/* harmony import */ var _src_curves_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9tYWluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEM7QUFDUTtBQUNkO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogYXMgZ3JvdGgxNiBmcm9tIFwiLi9zcmMvZ3JvdGgxNi5qc1wiO1xuZXhwb3J0ICogYXMgcG93ZXJzT2ZUYXUgZnJvbSBcIi4vc3JjL3Bvd2Vyc29mdGF1LmpzXCI7XG5leHBvcnQgKiBhcyByMWNzIGZyb20gXCIuL3NyYy9yMWNzLmpzXCI7XG5leHBvcnQgKiBhcyB3dG5zIGZyb20gXCIuL3NyYy93dG5zLmpzXCI7XG5leHBvcnQgKiBhcyB6S2V5IGZyb20gXCIuL3NyYy96a2V5LmpzXCI7XG5leHBvcnQgKiBhcyBwbG9uayBmcm9tIFwiLi9zcmMvcGxvbmsuanNcIjtcbmV4cG9ydCAqIGFzIGZmbG9uayBmcm9tIFwiLi9zcmMvZmZsb25rLmpzXCI7XG5leHBvcnQgKiBhcyBjdXJ2ZXMgZnJvbSBcIi4vc3JjL2N1cnZlcy5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/main.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js":
/*!****************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/main.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigBuffer: () => (/* reexport safe */ _src_bigbuffer_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   ChaCha: () => (/* reexport safe */ _src_chacha_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   EC: () => (/* reexport safe */ _src_ec_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   F1Field: () => (/* reexport safe */ _src_f1field_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   F2Field: () => (/* reexport safe */ _src_f2field_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   F3Field: () => (/* reexport safe */ _src_f3field_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   PolField: () => (/* reexport safe */ _src_polfield_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   Scalar: () => (/* binding */ Scalar),\n/* harmony export */   ZqField: () => (/* reexport safe */ _src_f1field_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   buildBls12381: () => (/* reexport safe */ _src_bls12381_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   buildBn128: () => (/* reexport safe */ _src_bn128_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   getCurveFromName: () => (/* reexport safe */ _src_curves_js__WEBPACK_IMPORTED_MODULE_11__.getCurveFromName),\n/* harmony export */   getCurveFromQ: () => (/* reexport safe */ _src_curves_js__WEBPACK_IMPORTED_MODULE_11__.getCurveFromQ),\n/* harmony export */   getCurveFromR: () => (/* reexport safe */ _src_curves_js__WEBPACK_IMPORTED_MODULE_11__.getCurveFromR),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/* harmony import */ var _src_scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _src_polfield_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/polfield.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/polfield.js\");\n/* harmony import */ var _src_f1field_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/f1field.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/f1field.js\");\n/* harmony import */ var _src_f2field_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/f2field.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/f2field.js\");\n/* harmony import */ var _src_f3field_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/f3field.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/f3field.js\");\n/* harmony import */ var _src_ec_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/ec.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/ec.js\");\n/* harmony import */ var _src_bn128_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/bn128.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js\");\n/* harmony import */ var _src_bls12381_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/bls12381.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js\");\n/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/utils.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js\");\n/* harmony import */ var _src_chacha_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/chacha.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js\");\n/* harmony import */ var _src_bigbuffer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/bigbuffer.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\");\n/* harmony import */ var _src_curves_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/curves.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/curves.js\");\n\n\nconst Scalar=_src_scalar_js__WEBPACK_IMPORTED_MODULE_0__;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst utils = _src_utils_js__WEBPACK_IMPORTED_MODULE_8__;\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L21haW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUM0QztBQUNyQyxhQUFhLDJDQUFPOztBQUUyQjtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFVjs7QUFFVztBQUNNOztBQUVsQjtBQUNsQyxjQUFjLDBDQUFNO0FBQ3VCOztBQUVNOztBQUV1QiIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCAqIGFzIF9TY2FsYXIgIGZyb20gXCIuL3NyYy9zY2FsYXIuanNcIjtcbmV4cG9ydCBjb25zdCBTY2FsYXI9X1NjYWxhcjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIFBvbEZpZWxkfSBmcm9tIFwiLi9zcmMvcG9sZmllbGQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBGMUZpZWxkfSBmcm9tIFwiLi9zcmMvZjFmaWVsZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEYyRmllbGR9IGZyb20gXCIuL3NyYy9mMmZpZWxkLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgRjNGaWVsZH0gZnJvbSBcIi4vc3JjL2YzZmllbGQuanNcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIFpxRmllbGR9IGZyb20gXCIuL3NyYy9mMWZpZWxkLmpzXCI7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBFQ30gZnJvbSBcIi4vc3JjL2VjLmpzXCI7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBidWlsZEJuMTI4fSBmcm9tIFwiLi9zcmMvYm4xMjguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBidWlsZEJsczEyMzgxfSBmcm9tIFwiLi9zcmMvYmxzMTIzODEuanNcIjtcblxuaW1wb3J0ICogYXMgX3V0aWxzIGZyb20gXCIuL3NyYy91dGlscy5qc1wiO1xuZXhwb3J0IGNvbnN0IHV0aWxzID0gX3V0aWxzO1xuZXhwb3J0IHtkZWZhdWx0IGFzIENoYUNoYX0gZnJvbSBcIi4vc3JjL2NoYWNoYS5qc1wiO1xuXG5leHBvcnQge2RlZmF1bHQgYXMgQmlnQnVmZmVyfSBmcm9tIFwiLi9zcmMvYmlnYnVmZmVyLmpzXCI7XG5cbmV4cG9ydCB7Z2V0Q3VydmVGcm9tUiwgZ2V0Q3VydmVGcm9tUSwgZ2V0Q3VydmVGcm9tTmFtZX0gZnJvbSBcIi4vc3JjL2N1cnZlcy5qc1wiO1xuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BigBuffer)\n/* harmony export */ });\n\nconst PAGE_SIZE = 1<<30;\n\nclass BigBuffer {\n\n    constructor(size) {\n        this.buffers = [];\n        this.byteLength = size;\n        for (let i=0; i<size; i+= PAGE_SIZE) {\n            const n = Math.min(size-i, PAGE_SIZE);\n            this.buffers.push(new Uint8Array(n));\n        }\n\n    }\n\n    slice(fr, to) {\n        if ( to === undefined ) to = this.byteLength;\n        if ( fr === undefined ) fr = 0;\n        const len = to-fr;\n\n        const firstPage = Math.floor(fr / PAGE_SIZE);\n        const lastPage = Math.floor((fr+len-1) / PAGE_SIZE);\n\n        if ((firstPage == lastPage)||(len==0))\n            return this.buffers[firstPage].slice(fr%PAGE_SIZE, fr%PAGE_SIZE + len);\n\n        let buff;\n\n        let p = firstPage;\n        let o = fr % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset+o, l);\n            if (l == len) return srcView.slice();\n            if (!buff) {\n                if (len <= PAGE_SIZE) {\n                    buff = new Uint8Array(len);\n                } else {\n                    buff = new BigBuffer(len);\n                }\n            }\n            buff.set(srcView, len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        return buff;\n    }\n\n    set(buff, offset) {\n        if (offset === undefined) offset = 0;\n\n        const len = buff.byteLength;\n\n        if (len==0) return;\n\n        const firstPage = Math.floor(offset / PAGE_SIZE);\n        const lastPage = Math.floor((offset+len-1) / PAGE_SIZE);\n\n        if (firstPage == lastPage) {\n            if ((buff instanceof BigBuffer)&&(buff.buffers.length==1)) {\n                return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);\n            } else {\n                return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);\n            }\n\n        }\n\n\n        let p = firstPage;\n        let o = offset % PAGE_SIZE;\n        let r = len;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice( len -r, len -r+l);\n            const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9iaWdidWZmZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2JpZ2J1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IFBBR0VfU0laRSA9IDE8PDMwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCaWdCdWZmZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHNpemU7IGkrPSBQQUdFX1NJWkUpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihzaXplLWksIFBBR0VfU0laRSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShuKSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHNsaWNlKGZyLCB0bykge1xuICAgICAgICBpZiAoIHRvID09PSB1bmRlZmluZWQgKSB0byA9IHRoaXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKCBmciA9PT0gdW5kZWZpbmVkICkgZnIgPSAwO1xuICAgICAgICBjb25zdCBsZW4gPSB0by1mcjtcblxuICAgICAgICBjb25zdCBmaXJzdFBhZ2UgPSBNYXRoLmZsb29yKGZyIC8gUEFHRV9TSVpFKTtcbiAgICAgICAgY29uc3QgbGFzdFBhZ2UgPSBNYXRoLmZsb29yKChmcitsZW4tMSkgLyBQQUdFX1NJWkUpO1xuXG4gICAgICAgIGlmICgoZmlyc3RQYWdlID09IGxhc3RQYWdlKXx8KGxlbj09MCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzW2ZpcnN0UGFnZV0uc2xpY2UoZnIlUEFHRV9TSVpFLCBmciVQQUdFX1NJWkUgKyBsZW4pO1xuXG4gICAgICAgIGxldCBidWZmO1xuXG4gICAgICAgIGxldCBwID0gZmlyc3RQYWdlO1xuICAgICAgICBsZXQgbyA9IGZyICUgUEFHRV9TSVpFO1xuICAgICAgICAvLyBSZW1haW5pbmcgYnl0ZXMgdG8gcmVhZFxuICAgICAgICBsZXQgciA9IGxlbjtcbiAgICAgICAgd2hpbGUgKHI+MCkge1xuICAgICAgICAgICAgLy8gYnl0ZXMgdG8gY29weSBmcm9tIHRoaXMgcGFnZVxuICAgICAgICAgICAgY29uc3QgbCA9IChvK3IgPiBQQUdFX1NJWkUpID8gKFBBR0VfU0laRSAtbykgOiByO1xuICAgICAgICAgICAgY29uc3Qgc3JjVmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyc1twXS5idWZmZXIsIHRoaXMuYnVmZmVyc1twXS5ieXRlT2Zmc2V0K28sIGwpO1xuICAgICAgICAgICAgaWYgKGwgPT0gbGVuKSByZXR1cm4gc3JjVmlldy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKCFidWZmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBQQUdFX1NJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZiA9IG5ldyBCaWdCdWZmZXIobGVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmLnNldChzcmNWaWV3LCBsZW4tcik7XG4gICAgICAgICAgICByID0gci1sO1xuICAgICAgICAgICAgcCArKztcbiAgICAgICAgICAgIG8gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfVxuXG4gICAgc2V0KGJ1ZmYsIG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIG9mZnNldCA9IDA7XG5cbiAgICAgICAgY29uc3QgbGVuID0gYnVmZi5ieXRlTGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW49PTApIHJldHVybjtcblxuICAgICAgICBjb25zdCBmaXJzdFBhZ2UgPSBNYXRoLmZsb29yKG9mZnNldCAvIFBBR0VfU0laRSk7XG4gICAgICAgIGNvbnN0IGxhc3RQYWdlID0gTWF0aC5mbG9vcigob2Zmc2V0K2xlbi0xKSAvIFBBR0VfU0laRSk7XG5cbiAgICAgICAgaWYgKGZpcnN0UGFnZSA9PSBsYXN0UGFnZSkge1xuICAgICAgICAgICAgaWYgKChidWZmIGluc3RhbmNlb2YgQmlnQnVmZmVyKSYmKGJ1ZmYuYnVmZmVycy5sZW5ndGg9PTEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyc1tmaXJzdFBhZ2VdLnNldChidWZmLmJ1ZmZlcnNbMF0sIG9mZnNldCAlIFBBR0VfU0laRSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbZmlyc3RQYWdlXS5zZXQoYnVmZiwgb2Zmc2V0ICUgUEFHRV9TSVpFKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuICAgICAgICBsZXQgcCA9IGZpcnN0UGFnZTtcbiAgICAgICAgbGV0IG8gPSBvZmZzZXQgJSBQQUdFX1NJWkU7XG4gICAgICAgIGxldCByID0gbGVuO1xuICAgICAgICB3aGlsZSAocj4wKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gKG8rciA+IFBBR0VfU0laRSkgPyAoUEFHRV9TSVpFIC1vKSA6IHI7XG4gICAgICAgICAgICBjb25zdCBzcmNWaWV3ID0gYnVmZi5zbGljZSggbGVuIC1yLCBsZW4gLXIrbCk7XG4gICAgICAgICAgICBjb25zdCBkc3RWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXJzW3BdLmJ1ZmZlciwgdGhpcy5idWZmZXJzW3BdLmJ5dGVPZmZzZXQgKyBvLCBsKTtcbiAgICAgICAgICAgIGRzdFZpZXcuc2V0KHNyY1ZpZXcpO1xuICAgICAgICAgICAgciA9IHItbDtcbiAgICAgICAgICAgIHAgKys7XG4gICAgICAgICAgICBvID0gMDtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js":
/*!************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildBls12381)\n/* harmony export */ });\n/* harmony import */ var wasmcurves__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wasmcurves */ \"(rsc)/./node_modules/wasmcurves/index.js\");\n/* harmony import */ var _engine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var wasmbuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wasmbuilder */ \"(rsc)/./node_modules/wasmbuilder/main.js\");\n\n\n\n\n\nglobalThis.curve_bls12381 = null;\n\nasync function buildBls12381(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bls12381)) return globalThis.curve_bls12381;\n\n    const moduleBuilder = new wasmbuilder__WEBPACK_IMPORTED_MODULE_3__.ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    (0,wasmcurves__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bls12381wasm = {};\n\n    bls12381wasm.code = moduleBuilder.build();\n    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;\n    bls12381wasm.pr = moduleBuilder.modules.frm.pq;\n    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;\n    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;\n    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;\n    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;\n    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;\n    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;\n    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;\n    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;\n    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;\n    bls12381wasm.n8q = 48;\n    bls12381wasm.n8r = 32;\n    bls12381wasm.q = moduleBuilder.modules.bls12381.q;\n    bls12381wasm.r = moduleBuilder.modules.bls12381.r;\n\n\n    const params = {\n        name: \"bls12381\",\n        wasm: bls12381wasm,\n        q: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16),\n        r: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16),\n        n8q: 48,\n        n8r: 32,\n        cofactorG1: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"0x396c8c005555e1568c00aaab0000aaab\", 16),\n        cofactorG2: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await (0,_engine_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bls12381 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bls12381 = curve;\n    }\n\n    return curve;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9ibHMxMjM4MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnRTtBQUMxQjtBQUNBO0FBQ007O0FBRTVDOztBQUVlO0FBQ2Y7O0FBRUEsOEJBQThCLHNEQUFhO0FBQzNDO0FBQ0EsSUFBSSx5REFBaUI7O0FBRXJCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUFRO0FBQ25CLFdBQVcseUNBQVE7QUFDbkI7QUFDQTtBQUNBLG9CQUFvQix5Q0FBUTtBQUM1QixvQkFBb0IseUNBQVE7QUFDNUI7QUFDQTs7QUFFQSx3QkFBd0Isc0RBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvYmxzMTIzODEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnVpbGRCbHMxMjM4MSBhcyBidWlsZEJsczEyMzgxd2FzbSB9IGZyb20gXCJ3YXNtY3VydmVzXCI7XG5pbXBvcnQgYnVpbGRFbmdpbmUgZnJvbSBcIi4vZW5naW5lLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5pbXBvcnQgeyBNb2R1bGVCdWlsZGVyIH0gZnJvbSBcIndhc21idWlsZGVyXCI7XG5cbmdsb2JhbFRoaXMuY3VydmVfYmxzMTIzODEgPSBudWxsO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGlmICgoIXNpbmdsZVRocmVhZCkgJiYgKGdsb2JhbFRoaXMuY3VydmVfYmxzMTIzODEpKSByZXR1cm4gZ2xvYmFsVGhpcy5jdXJ2ZV9ibHMxMjM4MTtcblxuICAgIGNvbnN0IG1vZHVsZUJ1aWxkZXIgPSBuZXcgTW9kdWxlQnVpbGRlcigpO1xuICAgIG1vZHVsZUJ1aWxkZXIuc2V0TWVtb3J5KDI1KTtcbiAgICBidWlsZEJsczEyMzgxd2FzbShtb2R1bGVCdWlsZGVyKTtcblxuICAgIGlmIChwbHVnaW5zKSBwbHVnaW5zKG1vZHVsZUJ1aWxkZXIpO1xuXG4gICAgY29uc3QgYmxzMTIzODF3YXNtID0ge307XG5cbiAgICBibHMxMjM4MXdhc20uY29kZSA9IG1vZHVsZUJ1aWxkZXIuYnVpbGQoKTtcbiAgICBibHMxMjM4MXdhc20ucHEgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuZjFtLnBxO1xuICAgIGJsczEyMzgxd2FzbS5wciA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5mcm0ucHE7XG4gICAgYmxzMTIzODF3YXNtLnBHMWdlbiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wRzFnZW47XG4gICAgYmxzMTIzODF3YXNtLnBHMXplcm8gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucEcxemVybztcbiAgICBibHMxMjM4MXdhc20ucEcxYiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wRzFiO1xuICAgIGJsczEyMzgxd2FzbS5wRzJnZW4gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucEcyZ2VuO1xuICAgIGJsczEyMzgxd2FzbS5wRzJ6ZXJvID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnBHMnplcm87XG4gICAgYmxzMTIzODF3YXNtLnBHMmIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucEcyYjtcbiAgICBibHMxMjM4MXdhc20ucE9uZVQgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucE9uZVQ7XG4gICAgYmxzMTIzODF3YXNtLnByZVBTaXplID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnByZVBTaXplO1xuICAgIGJsczEyMzgxd2FzbS5wcmVRU2l6ZSA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wcmVRU2l6ZTtcbiAgICBibHMxMjM4MXdhc20ubjhxID0gNDg7XG4gICAgYmxzMTIzODF3YXNtLm44ciA9IDMyO1xuICAgIGJsczEyMzgxd2FzbS5xID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnE7XG4gICAgYmxzMTIzODF3YXNtLnIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucjtcblxuXG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBuYW1lOiBcImJsczEyMzgxXCIsXG4gICAgICAgIHdhc206IGJsczEyMzgxd2FzbSxcbiAgICAgICAgcTogU2NhbGFyLmUoXCIxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJcIiwgMTYpLFxuICAgICAgICByOiBTY2FsYXIuZShcIjczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDFcIiwgMTYpLFxuICAgICAgICBuOHE6IDQ4LFxuICAgICAgICBuOHI6IDMyLFxuICAgICAgICBjb2ZhY3RvckcxOiBTY2FsYXIuZShcIjB4Mzk2YzhjMDA1NTU1ZTE1NjhjMDBhYWFiMDAwMGFhYWJcIiwgMTYpLFxuICAgICAgICBjb2ZhY3RvckcyOiBTY2FsYXIuZShcIjB4NWQ1NDNhOTU0MTRlN2YxMDkxZDUwNzkyODc2YTIwMmNkOTFkZTQ1NDcwODVhYmFhNjhhMjA1YjJlNWE3ZGRmYTYyOGYxY2I0ZDllODJlZjIxNTM3ZTI5M2E2NjkxYWUxNjE2ZWM2ZTc4NmYwYzcwY2YxYzM4ZTMxYzcyMzhlNVwiLCAxNiksXG4gICAgICAgIHNpbmdsZVRocmVhZDogc2luZ2xlVGhyZWFkID8gdHJ1ZSA6IGZhbHNlXG4gICAgfTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgYnVpbGRFbmdpbmUocGFyYW1zKTtcbiAgICBjdXJ2ZS50ZXJtaW5hdGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcGFyYW1zLnNpbmdsZVRocmVhZCkge1xuICAgICAgICAgICAgZ2xvYmFsVGhpcy5jdXJ2ZV9ibHMxMjM4MSA9IG51bGw7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRtLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICghc2luZ2xlVGhyZWFkKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuY3VydmVfYmxzMTIzODEgPSBjdXJ2ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildBn128)\n/* harmony export */ });\n/* harmony import */ var wasmcurves__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wasmcurves */ \"(rsc)/./node_modules/wasmcurves/index.js\");\n/* harmony import */ var _engine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var wasmbuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wasmbuilder */ \"(rsc)/./node_modules/wasmbuilder/main.js\");\n\n\n\n\n\nglobalThis.curve_bn128 = null;\n\nasync function buildBn128(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bn128)) return globalThis.curve_bn128;\n\n    const moduleBuilder = new wasmbuilder__WEBPACK_IMPORTED_MODULE_3__.ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    (0,wasmcurves__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bn128wasm = {};\n\n    bn128wasm.code = moduleBuilder.build();\n    bn128wasm.pq = moduleBuilder.modules.f1m.pq;\n    bn128wasm.pr = moduleBuilder.modules.frm.pq;\n    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;\n    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;\n    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;\n    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;\n    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;\n    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;\n    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;\n    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;\n    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;\n    bn128wasm.n8q = 32;\n    bn128wasm.n8r = 32;\n    bn128wasm.q = moduleBuilder.modules.bn128.q;\n    bn128wasm.r = moduleBuilder.modules.bn128.r;\n\n    const params = {\n        name: \"bn128\",\n        wasm: bn128wasm,\n        q: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\"),\n        r: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\"),\n        n8q: 32,\n        n8r: 32,\n        cofactorG2: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await (0,_engine_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bn128 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bn128 = curve;\n    }\n\n    return curve;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9ibjEyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwRDtBQUNwQjtBQUNBO0FBQ007O0FBRTVDOztBQUVlO0FBQ2Y7O0FBRUEsOEJBQThCLHNEQUFhO0FBQzNDO0FBQ0EsSUFBSSxzREFBYzs7QUFFbEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBUTtBQUNuQixXQUFXLHlDQUFRO0FBQ25CO0FBQ0E7QUFDQSxvQkFBb0IseUNBQVE7QUFDNUI7QUFDQTs7QUFFQSx3QkFBd0Isc0RBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvYm4xMjguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnVpbGRCbjEyOCBhcyBidWlsZEJuMTI4d2FzbSB9IGZyb20gXCJ3YXNtY3VydmVzXCI7XG5pbXBvcnQgYnVpbGRFbmdpbmUgZnJvbSBcIi4vZW5naW5lLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5pbXBvcnQgeyBNb2R1bGVCdWlsZGVyIH0gZnJvbSBcIndhc21idWlsZGVyXCI7XG5cbmdsb2JhbFRoaXMuY3VydmVfYm4xMjggPSBudWxsO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGlmICgoIXNpbmdsZVRocmVhZCkgJiYgKGdsb2JhbFRoaXMuY3VydmVfYm4xMjgpKSByZXR1cm4gZ2xvYmFsVGhpcy5jdXJ2ZV9ibjEyODtcblxuICAgIGNvbnN0IG1vZHVsZUJ1aWxkZXIgPSBuZXcgTW9kdWxlQnVpbGRlcigpO1xuICAgIG1vZHVsZUJ1aWxkZXIuc2V0TWVtb3J5KDI1KTtcbiAgICBidWlsZEJuMTI4d2FzbShtb2R1bGVCdWlsZGVyKTtcblxuICAgIGlmIChwbHVnaW5zKSBwbHVnaW5zKG1vZHVsZUJ1aWxkZXIpO1xuXG4gICAgY29uc3QgYm4xMjh3YXNtID0ge307XG5cbiAgICBibjEyOHdhc20uY29kZSA9IG1vZHVsZUJ1aWxkZXIuYnVpbGQoKTtcbiAgICBibjEyOHdhc20ucHEgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuZjFtLnBxO1xuICAgIGJuMTI4d2FzbS5wciA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5mcm0ucHE7XG4gICAgYm4xMjh3YXNtLnBHMWdlbiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5wRzFnZW47XG4gICAgYm4xMjh3YXNtLnBHMXplcm8gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucEcxemVybztcbiAgICBibjEyOHdhc20ucEcxYiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5wRzFiO1xuICAgIGJuMTI4d2FzbS5wRzJnZW4gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucEcyZ2VuO1xuICAgIGJuMTI4d2FzbS5wRzJ6ZXJvID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnBHMnplcm87XG4gICAgYm4xMjh3YXNtLnBHMmIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucEcyYjtcbiAgICBibjEyOHdhc20ucE9uZVQgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucE9uZVQ7XG4gICAgYm4xMjh3YXNtLnByZVBTaXplID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnByZVBTaXplO1xuICAgIGJuMTI4d2FzbS5wcmVRU2l6ZSA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5wcmVRU2l6ZTtcbiAgICBibjEyOHdhc20ubjhxID0gMzI7XG4gICAgYm4xMjh3YXNtLm44ciA9IDMyO1xuICAgIGJuMTI4d2FzbS5xID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnE7XG4gICAgYm4xMjh3YXNtLnIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucjtcblxuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgbmFtZTogXCJibjEyOFwiLFxuICAgICAgICB3YXNtOiBibjEyOHdhc20sXG4gICAgICAgIHE6IFNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg2OTYzMTExNTcyOTc4MjM2NjI2ODkwMzc4OTQ2NDUyMjYyMDg1ODNcIiksXG4gICAgICAgIHI6IFNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIiksXG4gICAgICAgIG44cTogMzIsXG4gICAgICAgIG44cjogMzIsXG4gICAgICAgIGNvZmFjdG9yRzI6IFNjYWxhci5lKFwiMzA2NDRlNzJlMTMxYTAyOWI4NTA0NWI2ODE4MTU4NWUwNmNlZWNkYTU3MmEyNDg5MzQ1ZjIyOTljMGY5ZmE4ZFwiLCAxNiksXG4gICAgICAgIHNpbmdsZVRocmVhZDogc2luZ2xlVGhyZWFkID8gdHJ1ZSA6IGZhbHNlXG4gICAgfTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgYnVpbGRFbmdpbmUocGFyYW1zKTtcbiAgICBjdXJ2ZS50ZXJtaW5hdGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcGFyYW1zLnNpbmdsZVRocmVhZCkge1xuICAgICAgICAgICAgZ2xvYmFsVGhpcy5jdXJ2ZV9ibjEyOCA9IG51bGw7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRtLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICghc2luZ2xlVGhyZWFkKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuY3VydmVfYm4xMjggPSBjdXJ2ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChaCha)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n\n\n\n\n\nfunction quarterRound(st, a, b, c, d) {\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 16) | ((st[d]>>>16) & 0xFFFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 12) | ((st[b]>>>20) & 0xFFF)) >>> 0;\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 8) | ((st[d]>>>24) & 0xFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 7) | ((st[b]>>>25) & 0x7F)) >>> 0;\n}\n\nfunction doubleRound(st) {\n    quarterRound(st, 0, 4, 8,12);\n    quarterRound(st, 1, 5, 9,13);\n    quarterRound(st, 2, 6,10,14);\n    quarterRound(st, 3, 7,11,15);\n\n    quarterRound(st, 0, 5,10,15);\n    quarterRound(st, 1, 6,11,12);\n    quarterRound(st, 2, 7, 8,13);\n    quarterRound(st, 3, 4, 9,14);\n}\n\nclass ChaCha {\n\n    constructor(seed) {\n        seed = seed || [0,0,0,0,0,0,0,0];\n        this.state = [\n            0x61707865,\n            0x3320646E,\n            0x79622D32,\n            0x6B206574,\n            seed[0],\n            seed[1],\n            seed[2],\n            seed[3],\n            seed[4],\n            seed[5],\n            seed[6],\n            seed[7],\n            0,\n            0,\n            0,\n            0\n        ];\n        this.idx = 16;\n        this.buff = new Array(16);\n    }\n\n    nextU32() {\n        if (this.idx == 16) this.update();\n        return this.buff[this.idx++];\n    }\n\n    nextU64() {\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.add(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mul(this.nextU32(), 0x100000000), this.nextU32());\n    }\n\n    nextBool() {\n        return (this.nextU32() & 1) == 1;\n    }\n\n    update() {\n        // Copy the state\n        for (let i=0; i<16; i++) this.buff[i] = this.state[i];\n\n        // Apply the rounds\n        for (let i=0; i<10; i++) doubleRound(this.buff);\n\n        // Add to the initial\n        for (let i=0; i<16; i++) this.buff[i] = (this.buff[i] + this.state[i]) >>> 0;\n\n        this.idx = 0;\n\n        this.state[12] = (this.state[12] + 1) >>> 0;\n        if (this.state[12] != 0) return;\n        this.state[13] = (this.state[13] + 1) >>> 0;\n        if (this.state[13] != 0) return;\n        this.state[14] = (this.state[14] + 1) >>> 0;\n        if (this.state[14] != 0) return;\n        this.state[15] = (this.state[15] + 1) >>> 0;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9jaGFjaGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVzQzs7O0FBR3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyQ0FBVSxDQUFDLDJDQUFVO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07O0FBRTVCO0FBQ0Esc0JBQXNCLE1BQU07O0FBRTVCO0FBQ0Esc0JBQXNCLE1BQU07O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2NoYWNoYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0ICogYXMgU2NhbGFyIGZyb20gXCIuL3NjYWxhci5qc1wiO1xuXG5cbmZ1bmN0aW9uIHF1YXJ0ZXJSb3VuZChzdCwgYSwgYiwgYywgZCkge1xuXG4gICAgc3RbYV0gPSAoc3RbYV0gKyBzdFtiXSkgPj4+IDA7XG4gICAgc3RbZF0gPSAoc3RbZF0gXiBzdFthXSkgPj4+IDA7XG4gICAgc3RbZF0gPSAoKHN0W2RdIDw8IDE2KSB8ICgoc3RbZF0+Pj4xNikgJiAweEZGRkYpKSA+Pj4gMDtcblxuICAgIHN0W2NdID0gKHN0W2NdICsgc3RbZF0pID4+PiAwO1xuICAgIHN0W2JdID0gKHN0W2JdIF4gc3RbY10pID4+PiAwO1xuICAgIHN0W2JdID0gKChzdFtiXSA8PCAxMikgfCAoKHN0W2JdPj4+MjApICYgMHhGRkYpKSA+Pj4gMDtcblxuICAgIHN0W2FdID0gKHN0W2FdICsgc3RbYl0pID4+PiAwO1xuICAgIHN0W2RdID0gKHN0W2RdIF4gc3RbYV0pID4+PiAwO1xuICAgIHN0W2RdID0gKChzdFtkXSA8PCA4KSB8ICgoc3RbZF0+Pj4yNCkgJiAweEZGKSkgPj4+IDA7XG5cbiAgICBzdFtjXSA9IChzdFtjXSArIHN0W2RdKSA+Pj4gMDtcbiAgICBzdFtiXSA9IChzdFtiXSBeIHN0W2NdKSA+Pj4gMDtcbiAgICBzdFtiXSA9ICgoc3RbYl0gPDwgNykgfCAoKHN0W2JdPj4+MjUpICYgMHg3RikpID4+PiAwO1xufVxuXG5mdW5jdGlvbiBkb3VibGVSb3VuZChzdCkge1xuICAgIHF1YXJ0ZXJSb3VuZChzdCwgMCwgNCwgOCwxMik7XG4gICAgcXVhcnRlclJvdW5kKHN0LCAxLCA1LCA5LDEzKTtcbiAgICBxdWFydGVyUm91bmQoc3QsIDIsIDYsMTAsMTQpO1xuICAgIHF1YXJ0ZXJSb3VuZChzdCwgMywgNywxMSwxNSk7XG5cbiAgICBxdWFydGVyUm91bmQoc3QsIDAsIDUsMTAsMTUpO1xuICAgIHF1YXJ0ZXJSb3VuZChzdCwgMSwgNiwxMSwxMik7XG4gICAgcXVhcnRlclJvdW5kKHN0LCAyLCA3LCA4LDEzKTtcbiAgICBxdWFydGVyUm91bmQoc3QsIDMsIDQsIDksMTQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFDaGEge1xuXG4gICAgY29uc3RydWN0b3Ioc2VlZCkge1xuICAgICAgICBzZWVkID0gc2VlZCB8fCBbMCwwLDAsMCwwLDAsMCwwXTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFtcbiAgICAgICAgICAgIDB4NjE3MDc4NjUsXG4gICAgICAgICAgICAweDMzMjA2NDZFLFxuICAgICAgICAgICAgMHg3OTYyMkQzMixcbiAgICAgICAgICAgIDB4NkIyMDY1NzQsXG4gICAgICAgICAgICBzZWVkWzBdLFxuICAgICAgICAgICAgc2VlZFsxXSxcbiAgICAgICAgICAgIHNlZWRbMl0sXG4gICAgICAgICAgICBzZWVkWzNdLFxuICAgICAgICAgICAgc2VlZFs0XSxcbiAgICAgICAgICAgIHNlZWRbNV0sXG4gICAgICAgICAgICBzZWVkWzZdLFxuICAgICAgICAgICAgc2VlZFs3XSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5pZHggPSAxNjtcbiAgICAgICAgdGhpcy5idWZmID0gbmV3IEFycmF5KDE2KTtcbiAgICB9XG5cbiAgICBuZXh0VTMyKCkge1xuICAgICAgICBpZiAodGhpcy5pZHggPT0gMTYpIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZbdGhpcy5pZHgrK107XG4gICAgfVxuXG4gICAgbmV4dFU2NCgpIHtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5hZGQoU2NhbGFyLm11bCh0aGlzLm5leHRVMzIoKSwgMHgxMDAwMDAwMDApLCB0aGlzLm5leHRVMzIoKSk7XG4gICAgfVxuXG4gICAgbmV4dEJvb2woKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5uZXh0VTMyKCkgJiAxKSA9PSAxO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gQ29weSB0aGUgc3RhdGVcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDE2OyBpKyspIHRoaXMuYnVmZltpXSA9IHRoaXMuc3RhdGVbaV07XG5cbiAgICAgICAgLy8gQXBwbHkgdGhlIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8MTA7IGkrKykgZG91YmxlUm91bmQodGhpcy5idWZmKTtcblxuICAgICAgICAvLyBBZGQgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDE2OyBpKyspIHRoaXMuYnVmZltpXSA9ICh0aGlzLmJ1ZmZbaV0gKyB0aGlzLnN0YXRlW2ldKSA+Pj4gMDtcblxuICAgICAgICB0aGlzLmlkeCA9IDA7XG5cbiAgICAgICAgdGhpcy5zdGF0ZVsxMl0gPSAodGhpcy5zdGF0ZVsxMl0gKyAxKSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVbMTJdICE9IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZVsxM10gPSAodGhpcy5zdGF0ZVsxM10gKyAxKSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVbMTNdICE9IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZVsxNF0gPSAodGhpcy5zdGF0ZVsxNF0gKyAxKSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVbMTRdICE9IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZVsxNV0gPSAodGhpcy5zdGF0ZVsxNV0gKyAxKSA+Pj4gMDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/curves.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/curves.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurveFromName: () => (/* binding */ getCurveFromName),\n/* harmony export */   getCurveFromQ: () => (/* binding */ getCurveFromQ),\n/* harmony export */   getCurveFromR: () => (/* binding */ getCurveFromR)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _bn128_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bn128.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js\");\n/* harmony import */ var _bls12381_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bls12381.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js\");\n\n\n\n\nconst bls12381r = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nasync function getCurveFromR(r, singleThread, plugins) {\n    let curve;\n    if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(r, bn128r)) {\n        curve = await (0,_bn128_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(singleThread, plugins);\n    } else if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(r, bls12381r)) {\n        curve = await (0,_bls12381_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${_scalar_js__WEBPACK_IMPORTED_MODULE_0__.toString(r)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromQ(q, singleThread, plugins) {\n    let curve;\n    if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(q, bn128q)) {\n        curve = await (0,_bn128_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(singleThread, plugins);\n    } else if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(q, bls12381q)) {\n        curve = await (0,_bls12381_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${_scalar_js__WEBPACK_IMPORTED_MODULE_0__.toString(q, 16)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromName(name, singleThread, plugins) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await (0,_bn128_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(singleThread, plugins);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await (0,_bls12381_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9jdXJ2ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNDO0FBQ1c7QUFDTTs7QUFFdkQsa0JBQWtCLHlDQUFRO0FBQzFCLGVBQWUseUNBQVE7O0FBRXZCLGtCQUFrQix5Q0FBUTtBQUMxQixlQUFlLHlDQUFROztBQUVoQjtBQUNQO0FBQ0EsUUFBUSwwQ0FBUztBQUNqQixzQkFBc0IscURBQVU7QUFDaEMsTUFBTSxTQUFTLDBDQUFTO0FBQ3hCLHNCQUFzQix3REFBYTtBQUNuQyxNQUFNO0FBQ04sZ0RBQWdELGdEQUFlLElBQUk7QUFDbkU7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxRQUFRLDBDQUFTO0FBQ2pCLHNCQUFzQixxREFBVTtBQUNoQyxNQUFNLFNBQVMsMENBQVM7QUFDeEIsc0JBQXNCLHdEQUFhO0FBQ25DLE1BQU07QUFDTixnREFBZ0QsZ0RBQWUsUUFBUTtBQUN2RTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEMsTUFBTTtBQUNOLHNCQUFzQix3REFBYTtBQUNuQyxNQUFNO0FBQ04sZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9jdXJ2ZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgU2NhbGFyIGZyb20gXCIuL3NjYWxhci5qc1wiO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGJ1aWxkQm4xMjh9IGZyb20gXCIuL2JuMTI4LmpzXCI7XG5pbXBvcnQge2RlZmF1bHQgYXMgYnVpbGRCbHMxMjM4MX0gZnJvbSBcIi4vYmxzMTIzODEuanNcIjtcblxuY29uc3QgYmxzMTIzODFyID0gU2NhbGFyLmUoXCI3M2VkYTc1MzI5OWQ3ZDQ4MzMzOWQ4MDgwOWExZDgwNTUzYmRhNDAyZmZmZTViZmVmZmZmZmZmZjAwMDAwMDAxXCIsIDE2KTtcbmNvbnN0IGJuMTI4ciA9IFNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIik7XG5cbmNvbnN0IGJsczEyMzgxcSA9IFNjYWxhci5lKFwiMWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiXCIsIDE2KTtcbmNvbnN0IGJuMTI4cSA9IFNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg2OTYzMTExNTcyOTc4MjM2NjI2ODkwMzc4OTQ2NDUyMjYyMDg1ODNcIik7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDdXJ2ZUZyb21SKHIsIHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGxldCBjdXJ2ZTtcbiAgICBpZiAoU2NhbGFyLmVxKHIsIGJuMTI4cikpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCwgcGx1Z2lucyk7XG4gICAgfSBlbHNlIGlmIChTY2FsYXIuZXEociwgYmxzMTIzODFyKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQmxzMTIzODEoc2luZ2xlVGhyZWFkLCBwbHVnaW5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN1cnZlIG5vdCBzdXBwb3J0ZWQ6ICR7U2NhbGFyLnRvU3RyaW5nKHIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDdXJ2ZUZyb21RKHEsIHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGxldCBjdXJ2ZTtcbiAgICBpZiAoU2NhbGFyLmVxKHEsIGJuMTI4cSkpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCwgcGx1Z2lucyk7XG4gICAgfSBlbHNlIGlmIChTY2FsYXIuZXEocSwgYmxzMTIzODFxKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQmxzMTIzODEoc2luZ2xlVGhyZWFkLCBwbHVnaW5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN1cnZlIG5vdCBzdXBwb3J0ZWQ6ICR7U2NhbGFyLnRvU3RyaW5nKHEsIDE2KX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VydmVGcm9tTmFtZShuYW1lLCBzaW5nbGVUaHJlYWQsIHBsdWdpbnMpIHtcbiAgICBsZXQgY3VydmU7XG4gICAgY29uc3Qgbm9ybU5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIGlmIChbXCJCTjEyOFwiLCBcIkJOMjU0XCIsIFwiQUxUQk4xMjhcIl0uaW5kZXhPZihub3JtTmFtZSkgPj0gMCkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQm4xMjgoc2luZ2xlVGhyZWFkLCBwbHVnaW5zKTtcbiAgICB9IGVsc2UgaWYgKFtcIkJMUzEyMzgxXCJdLmluZGV4T2Yobm9ybU5hbWUpID49IDApIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCwgcGx1Z2lucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2ZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobikge1xuICAgICAgICByZXR1cm4gbi50b1VwcGVyQ2FzZSgpLm1hdGNoKC9bQS1aYS16MC05XSsvZykuam9pbihcIlwiKTtcbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/curves.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/ec.js":
/*!******************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/ec.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EC)\n/* harmony export */ });\n/* harmony import */ var _futils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./futils.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nfunction isGreatest(F, a) {\n    if (Array.isArray(a)) {\n        for (let i=a.length-1; i>=0; i--) {\n            if (!F.F.isZero(a[i])) {\n                return isGreatest(F.F, a[i]);\n            }\n        }\n        return 0;\n    } else {\n        const na = F.neg(a);\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_1__.gt(a, na);\n    }\n}\n\n\nclass EC {\n\n    constructor(F, g) {\n        this.F = F;\n        this.g = g;\n        if (this.g.length == 2) this.g[2] = this.F.one;\n        this.zero = [this.F.zero, this.F.one, this.F.zero];\n    }\n\n    add(p1, p2) {\n\n        const F = this.F;\n\n        if (this.eq(p1, this.zero)) return p2;\n        if (this.eq(p2, this.zero)) return p1;\n\n        const res = new Array(3);\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );     // U1 = X1  * Z2Z2\n        const U2 = F.mul( p2[0] , Z1Z1 );     // U2 = X2  * Z1Z1\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);  // S1 = Y1 * Z2 * Z2Z2\n        const S2 = F.mul( p2[1] , Z1_cubed);  // S2 = Y2 * Z1 * Z1Z1\n\n        if (F.eq(U1,U2) && F.eq(S1,S2)) {\n            return this.double(p1);\n        }\n\n        const H = F.sub( U2 , U1 );                    // H = U2-U1\n\n        const S2_minus_S1 = F.sub( S2 , S1 );\n\n        const I = F.square( F.add(H,H) );         // I = (2 * H)^2\n        const J = F.mul( H , I );                      // J = H * I\n\n        const r = F.add( S2_minus_S1 , S2_minus_S1 );  // r = 2 * (S2-S1)\n        const V = F.mul( U1 , I );                     // V = U1 * I\n\n        res[0] =\n            F.sub(\n                F.sub( F.square(r) , J ),\n                F.add( V , V ));                       // X3 = r^2 - J - 2 * V\n\n        const S1_J = F.mul( S1 , J );\n\n        res[1] =\n            F.sub(\n                F.mul( r , F.sub(V,res[0])),\n                F.add( S1_J,S1_J ));                   // Y3 = r * (V-X3)-2 S1 J\n\n        res[2] =\n            F.mul(\n                H,\n                F.sub(\n                    F.square( F.add(p1[2],p2[2]) ),\n                    F.add( Z1Z1 , Z2Z2 )));            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2) * H\n\n        return res;\n    }\n\n    neg(p) {\n        return [p[0], this.F.neg(p[1]), p[2]];\n    }\n\n    sub(a, b) {\n        return this.add(a, this.neg(b));\n    }\n\n    double(p) {\n        const F = this.F;\n\n        const res = new Array(3);\n\n        if (this.eq(p, this.zero)) return p;\n\n        const A = F.square( p[0] );                    // A = X1^2\n        const B = F.square( p[1] );                    // B = Y1^2\n        const C = F.square( B );                       // C = B^2\n\n        let D =\n            F.sub(\n                F.square( F.add(p[0] , B )),\n                F.add( A , C));\n        D = F.add(D,D);                    // D = 2 * ((X1 + B)^2 - A - C)\n\n        const E = F.add( F.add(A,A), A);          // E = 3 * A\n        const FF =F.square( E );                       // F = E^2\n\n        res[0] = F.sub( FF , F.add(D,D) );         // X3 = F - 2 D\n\n        let eightC = F.add( C , C );\n        eightC = F.add( eightC , eightC );\n        eightC = F.add( eightC , eightC );\n\n        res[1] =\n            F.sub(\n                F.mul(\n                    E,\n                    F.sub( D, res[0] )),\n                eightC);                                    // Y3 = E * (D - X3) - 8 * C\n\n        const Y1Z1 = F.mul( p[1] , p[2] );\n        res[2] = F.add( Y1Z1 , Y1Z1 );                 // Z3 = 2 * Y1 * Z1\n\n        return res;\n    }\n\n    timesScalar(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.mulScalar(this, base, e);\n    }\n\n    mulScalar(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.mulScalar(this, base, e);\n    }\n\n    affine(p) {\n        const F = this.F;\n        if (this.isZero(p)) {\n            return this.zero;\n        } else if (F.eq(p[2], F.one)) {\n            return p;\n        } else {\n            const Z_inv = F.inv(p[2]);\n            const Z2_inv = F.square(Z_inv);\n            const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n            const res = new Array(3);\n            res[0] = F.mul(p[0],Z2_inv);\n            res[1] = F.mul(p[1],Z3_inv);\n            res[2] = F.one;\n\n            return res;\n        }\n    }\n\n    multiAffine(arr) {\n        const keys = Object.keys(arr);\n        const F = this.F;\n        const accMul = new Array(keys.length+1);\n        accMul[0] = F.one;\n        for (let i = 0; i< keys.length; i++) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i+1] = accMul[i];\n            } else {\n                accMul[i+1] = F.mul(accMul[i], arr[keys[i]][2]);\n            }\n        }\n\n        accMul[keys.length] = F.inv(accMul[keys.length]);\n\n        for (let i = keys.length-1; i>=0; i--) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i] = accMul[i+1];\n                arr[keys[i]] = this.zero;\n            } else {\n                const Z_inv = F.mul(accMul[i], accMul[i+1]);\n                accMul[i] = F.mul(arr[keys[i]][2], accMul[i+1]);\n\n                const Z2_inv = F.square(Z_inv);\n                const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n                arr[keys[i]][0] = F.mul(arr[keys[i]][0],Z2_inv);\n                arr[keys[i]][1] = F.mul(arr[keys[i]][1],Z3_inv);\n                arr[keys[i]][2] = F.one;\n            }\n        }\n\n    }\n\n    eq(p1, p2) {\n        const F = this.F;\n\n        if (this.F.eq(p1[2], this.F.zero)) return this.F.eq(p2[2], this.F.zero);\n        if (this.F.eq(p2[2], this.F.zero)) return false;\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );\n        const U2 = F.mul( p2[0] , Z1Z1 );\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);\n        const S2 = F.mul( p2[1] , Z1_cubed);\n\n        return (F.eq(U1,U2) && F.eq(S1,S2));\n    }\n\n    isZero(p) {\n        return this.F.isZero(p[2]);\n    }\n\n    toString(p) {\n        const cp = this.affine(p);\n        return `[ ${this.F.toString(cp[0])} , ${this.F.toString(cp[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n            P[1] = F.sqrt(x3b);\n        } while ((P[1] == null)||(F.isZero[P]));\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        if (this.cofactor) {\n            P = this.mulScalar(P, this.cofactor);\n        }\n\n        P = this.affine(P);\n\n        return P;\n\n    }\n\n    toRprLE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLE(buff, o, p[0]);\n        this.F.toRprLE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprBE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n        this.F.toRprBE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEJM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n        this.F.toRprLEM(buff, o+2*this.F.n8, p[2]);\n    }\n\n\n    toRprBEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBEM(buff, o, p[0]);\n        this.F.toRprBEM(buff, o+this.F.n8, p[1]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLE(buff, o);\n        const y = this.F.fromRprLE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBE(buff, o);\n        const y = this.F.fromRprBE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEJM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        const z = this.F.fromRprLEM(buff, o+this.F.n8*2);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, z];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBEM(buff, o);\n        const y = this.F.fromRprBEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprCompressed(buff, o) {\n        const F = this.F;\n        const v = new Uint8Array(buff.buffer, o, F.n8);\n        if (v[0] & 0x40) return this.zero;\n        const P = new Array(3);\n\n        const greatest = ((v[0] & 0x80) != 0);\n        v[0] = v[0] & 0x7F;\n        P[0] = F.fromRprBE(buff, o);\n        if (greatest) v[0] = v[0] | 0x80;  // set back again the old value\n\n        const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        P[1] = F.sqrt(x3b);\n\n        if (P[1] === null) {\n            throw new Error(\"Invalid Point!\");\n        }\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        return P;\n    }\n\n    toRprCompressed(buff, o, p) {\n        p = this.affine(p);\n        const v = new Uint8Array(buff.buffer, o, this.F.n8);\n        if (this.isZero(p)) {\n            v.fill(0);\n            v[0] = 0x40;\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n\n        if (isGreatest(this.F, p[1])) {\n            v[0] = v[0] | 0x80;\n        }\n    }\n\n\n    fromRprUncompressed(buff, o) {\n        if (buff[0] & 0x40) return this.zero;\n\n        return this.fromRprBE(buff, o);\n    }\n\n    toRprUncompressed(buff, o, p) {\n        this.toRprBE(buff, o, p);\n\n        if (this.isZero(p)) {\n            buff[o] = buff[o] | 0x40;\n        }\n    }\n\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSXNDO0FBQ0E7OztBQUd0QztBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWUsMENBQVM7QUFDeEI7QUFDQTs7O0FBR2U7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUMsOENBQThDOztBQUU5QztBQUNBOztBQUVBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7O0FBRXZEOztBQUVBLGtEQUFrRDtBQUNsRCx1REFBdUQ7O0FBRXZELHVEQUF1RDtBQUN2RCx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDLGtEQUFrRDtBQUNsRCx1REFBdUQ7O0FBRXZELG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxpREFBZ0I7QUFDL0I7O0FBRUE7QUFDQSxlQUFlLGlEQUFnQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxNQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QixJQUFJLHdCQUF3QjtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2VjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuXG5pbXBvcnQgKiBhcyBmVXRpbHMgZnJvbSBcIi4vZnV0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5cblxuZnVuY3Rpb24gaXNHcmVhdGVzdChGLCBhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgZm9yIChsZXQgaT1hLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICghRi5GLmlzWmVybyhhW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0dyZWF0ZXN0KEYuRiwgYVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmEgPSBGLm5lZyhhKTtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5ndChhLCBuYSk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVDIHtcblxuICAgIGNvbnN0cnVjdG9yKEYsIGcpIHtcbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICAgICAgaWYgKHRoaXMuZy5sZW5ndGggPT0gMikgdGhpcy5nWzJdID0gdGhpcy5GLm9uZTtcbiAgICAgICAgdGhpcy56ZXJvID0gW3RoaXMuRi56ZXJvLCB0aGlzLkYub25lLCB0aGlzLkYuemVyb107XG4gICAgfVxuXG4gICAgYWRkKHAxLCBwMikge1xuXG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG5cbiAgICAgICAgaWYgKHRoaXMuZXEocDEsIHRoaXMuemVybykpIHJldHVybiBwMjtcbiAgICAgICAgaWYgKHRoaXMuZXEocDIsIHRoaXMuemVybykpIHJldHVybiBwMTtcblxuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkoMyk7XG5cbiAgICAgICAgY29uc3QgWjFaMSA9IEYuc3F1YXJlKCBwMVsyXSApO1xuICAgICAgICBjb25zdCBaMloyID0gRi5zcXVhcmUoIHAyWzJdICk7XG5cbiAgICAgICAgY29uc3QgVTEgPSBGLm11bCggcDFbMF0gLCBaMloyICk7ICAgICAvLyBVMSA9IFgxICAqIFoyWjJcbiAgICAgICAgY29uc3QgVTIgPSBGLm11bCggcDJbMF0gLCBaMVoxICk7ICAgICAvLyBVMiA9IFgyICAqIFoxWjFcblxuICAgICAgICBjb25zdCBaMV9jdWJlZCA9IEYubXVsKCBwMVsyXSAsIFoxWjEpO1xuICAgICAgICBjb25zdCBaMl9jdWJlZCA9IEYubXVsKCBwMlsyXSAsIFoyWjIpO1xuXG4gICAgICAgIGNvbnN0IFMxID0gRi5tdWwoIHAxWzFdICwgWjJfY3ViZWQpOyAgLy8gUzEgPSBZMSAqIFoyICogWjJaMlxuICAgICAgICBjb25zdCBTMiA9IEYubXVsKCBwMlsxXSAsIFoxX2N1YmVkKTsgIC8vIFMyID0gWTIgKiBaMSAqIFoxWjFcblxuICAgICAgICBpZiAoRi5lcShVMSxVMikgJiYgRi5lcShTMSxTMikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvdWJsZShwMSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBIID0gRi5zdWIoIFUyICwgVTEgKTsgICAgICAgICAgICAgICAgICAgIC8vIEggPSBVMi1VMVxuXG4gICAgICAgIGNvbnN0IFMyX21pbnVzX1MxID0gRi5zdWIoIFMyICwgUzEgKTtcblxuICAgICAgICBjb25zdCBJID0gRi5zcXVhcmUoIEYuYWRkKEgsSCkgKTsgICAgICAgICAvLyBJID0gKDIgKiBIKV4yXG4gICAgICAgIGNvbnN0IEogPSBGLm11bCggSCAsIEkgKTsgICAgICAgICAgICAgICAgICAgICAgLy8gSiA9IEggKiBJXG5cbiAgICAgICAgY29uc3QgciA9IEYuYWRkKCBTMl9taW51c19TMSAsIFMyX21pbnVzX1MxICk7ICAvLyByID0gMiAqIChTMi1TMSlcbiAgICAgICAgY29uc3QgViA9IEYubXVsKCBVMSAsIEkgKTsgICAgICAgICAgICAgICAgICAgICAvLyBWID0gVTEgKiBJXG5cbiAgICAgICAgcmVzWzBdID1cbiAgICAgICAgICAgIEYuc3ViKFxuICAgICAgICAgICAgICAgIEYuc3ViKCBGLnNxdWFyZShyKSAsIEogKSxcbiAgICAgICAgICAgICAgICBGLmFkZCggViAsIFYgKSk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBYMyA9IHJeMiAtIEogLSAyICogVlxuXG4gICAgICAgIGNvbnN0IFMxX0ogPSBGLm11bCggUzEgLCBKICk7XG5cbiAgICAgICAgcmVzWzFdID1cbiAgICAgICAgICAgIEYuc3ViKFxuICAgICAgICAgICAgICAgIEYubXVsKCByICwgRi5zdWIoVixyZXNbMF0pKSxcbiAgICAgICAgICAgICAgICBGLmFkZCggUzFfSixTMV9KICkpOyAgICAgICAgICAgICAgICAgICAvLyBZMyA9IHIgKiAoVi1YMyktMiBTMSBKXG5cbiAgICAgICAgcmVzWzJdID1cbiAgICAgICAgICAgIEYubXVsKFxuICAgICAgICAgICAgICAgIEgsXG4gICAgICAgICAgICAgICAgRi5zdWIoXG4gICAgICAgICAgICAgICAgICAgIEYuc3F1YXJlKCBGLmFkZChwMVsyXSxwMlsyXSkgKSxcbiAgICAgICAgICAgICAgICAgICAgRi5hZGQoIFoxWjEgLCBaMloyICkpKTsgICAgICAgICAgICAvLyBaMyA9ICgoWjErWjIpXjItWjFaMS1aMloyKSAqIEhcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIG5lZyhwKSB7XG4gICAgICAgIHJldHVybiBbcFswXSwgdGhpcy5GLm5lZyhwWzFdKSwgcFsyXV07XG4gICAgfVxuXG4gICAgc3ViKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGEsIHRoaXMubmVnKGIpKTtcbiAgICB9XG5cbiAgICBkb3VibGUocCkge1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheSgzKTtcblxuICAgICAgICBpZiAodGhpcy5lcShwLCB0aGlzLnplcm8pKSByZXR1cm4gcDtcblxuICAgICAgICBjb25zdCBBID0gRi5zcXVhcmUoIHBbMF0gKTsgICAgICAgICAgICAgICAgICAgIC8vIEEgPSBYMV4yXG4gICAgICAgIGNvbnN0IEIgPSBGLnNxdWFyZSggcFsxXSApOyAgICAgICAgICAgICAgICAgICAgLy8gQiA9IFkxXjJcbiAgICAgICAgY29uc3QgQyA9IEYuc3F1YXJlKCBCICk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBDID0gQl4yXG5cbiAgICAgICAgbGV0IEQgPVxuICAgICAgICAgICAgRi5zdWIoXG4gICAgICAgICAgICAgICAgRi5zcXVhcmUoIEYuYWRkKHBbMF0gLCBCICkpLFxuICAgICAgICAgICAgICAgIEYuYWRkKCBBICwgQykpO1xuICAgICAgICBEID0gRi5hZGQoRCxEKTsgICAgICAgICAgICAgICAgICAgIC8vIEQgPSAyICogKChYMSArIEIpXjIgLSBBIC0gQylcblxuICAgICAgICBjb25zdCBFID0gRi5hZGQoIEYuYWRkKEEsQSksIEEpOyAgICAgICAgICAvLyBFID0gMyAqIEFcbiAgICAgICAgY29uc3QgRkYgPUYuc3F1YXJlKCBFICk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBGID0gRV4yXG5cbiAgICAgICAgcmVzWzBdID0gRi5zdWIoIEZGICwgRi5hZGQoRCxEKSApOyAgICAgICAgIC8vIFgzID0gRiAtIDIgRFxuXG4gICAgICAgIGxldCBlaWdodEMgPSBGLmFkZCggQyAsIEMgKTtcbiAgICAgICAgZWlnaHRDID0gRi5hZGQoIGVpZ2h0QyAsIGVpZ2h0QyApO1xuICAgICAgICBlaWdodEMgPSBGLmFkZCggZWlnaHRDICwgZWlnaHRDICk7XG5cbiAgICAgICAgcmVzWzFdID1cbiAgICAgICAgICAgIEYuc3ViKFxuICAgICAgICAgICAgICAgIEYubXVsKFxuICAgICAgICAgICAgICAgICAgICBFLFxuICAgICAgICAgICAgICAgICAgICBGLnN1YiggRCwgcmVzWzBdICkpLFxuICAgICAgICAgICAgICAgIGVpZ2h0Qyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWTMgPSBFICogKEQgLSBYMykgLSA4ICogQ1xuXG4gICAgICAgIGNvbnN0IFkxWjEgPSBGLm11bCggcFsxXSAsIHBbMl0gKTtcbiAgICAgICAgcmVzWzJdID0gRi5hZGQoIFkxWjEgLCBZMVoxICk7ICAgICAgICAgICAgICAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICB0aW1lc1NjYWxhcihiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBmVXRpbHMubXVsU2NhbGFyKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIG11bFNjYWxhcihiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBmVXRpbHMubXVsU2NhbGFyKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIGFmZmluZShwKSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfSBlbHNlIGlmIChGLmVxKHBbMl0sIEYub25lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBaX2ludiA9IEYuaW52KHBbMl0pO1xuICAgICAgICAgICAgY29uc3QgWjJfaW52ID0gRi5zcXVhcmUoWl9pbnYpO1xuICAgICAgICAgICAgY29uc3QgWjNfaW52ID0gRi5tdWwoWjJfaW52LCBaX2ludik7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheSgzKTtcbiAgICAgICAgICAgIHJlc1swXSA9IEYubXVsKHBbMF0sWjJfaW52KTtcbiAgICAgICAgICAgIHJlc1sxXSA9IEYubXVsKHBbMV0sWjNfaW52KTtcbiAgICAgICAgICAgIHJlc1syXSA9IEYub25lO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbXVsdGlBZmZpbmUoYXJyKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcnIpO1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuICAgICAgICBjb25zdCBhY2NNdWwgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgrMSk7XG4gICAgICAgIGFjY011bFswXSA9IEYub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaTwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKEYuZXEoYXJyW2tleXNbaV1dWzJdLCBGLnplcm8pKSB7XG4gICAgICAgICAgICAgICAgYWNjTXVsW2krMV0gPSBhY2NNdWxbaV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjY011bFtpKzFdID0gRi5tdWwoYWNjTXVsW2ldLCBhcnJba2V5c1tpXV1bMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWNjTXVsW2tleXMubGVuZ3RoXSA9IEYuaW52KGFjY011bFtrZXlzLmxlbmd0aF0pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBrZXlzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChGLmVxKGFycltrZXlzW2ldXVsyXSwgRi56ZXJvKSkge1xuICAgICAgICAgICAgICAgIGFjY011bFtpXSA9IGFjY011bFtpKzFdO1xuICAgICAgICAgICAgICAgIGFycltrZXlzW2ldXSA9IHRoaXMuemVybztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgWl9pbnYgPSBGLm11bChhY2NNdWxbaV0sIGFjY011bFtpKzFdKTtcbiAgICAgICAgICAgICAgICBhY2NNdWxbaV0gPSBGLm11bChhcnJba2V5c1tpXV1bMl0sIGFjY011bFtpKzFdKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IFoyX2ludiA9IEYuc3F1YXJlKFpfaW52KTtcbiAgICAgICAgICAgICAgICBjb25zdCBaM19pbnYgPSBGLm11bChaMl9pbnYsIFpfaW52KTtcblxuICAgICAgICAgICAgICAgIGFycltrZXlzW2ldXVswXSA9IEYubXVsKGFycltrZXlzW2ldXVswXSxaMl9pbnYpO1xuICAgICAgICAgICAgICAgIGFycltrZXlzW2ldXVsxXSA9IEYubXVsKGFycltrZXlzW2ldXVsxXSxaM19pbnYpO1xuICAgICAgICAgICAgICAgIGFycltrZXlzW2ldXVsyXSA9IEYub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBlcShwMSwgcDIpIHtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcblxuICAgICAgICBpZiAodGhpcy5GLmVxKHAxWzJdLCB0aGlzLkYuemVybykpIHJldHVybiB0aGlzLkYuZXEocDJbMl0sIHRoaXMuRi56ZXJvKTtcbiAgICAgICAgaWYgKHRoaXMuRi5lcShwMlsyXSwgdGhpcy5GLnplcm8pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgWjFaMSA9IEYuc3F1YXJlKCBwMVsyXSApO1xuICAgICAgICBjb25zdCBaMloyID0gRi5zcXVhcmUoIHAyWzJdICk7XG5cbiAgICAgICAgY29uc3QgVTEgPSBGLm11bCggcDFbMF0gLCBaMloyICk7XG4gICAgICAgIGNvbnN0IFUyID0gRi5tdWwoIHAyWzBdICwgWjFaMSApO1xuXG4gICAgICAgIGNvbnN0IFoxX2N1YmVkID0gRi5tdWwoIHAxWzJdICwgWjFaMSk7XG4gICAgICAgIGNvbnN0IFoyX2N1YmVkID0gRi5tdWwoIHAyWzJdICwgWjJaMik7XG5cbiAgICAgICAgY29uc3QgUzEgPSBGLm11bCggcDFbMV0gLCBaMl9jdWJlZCk7XG4gICAgICAgIGNvbnN0IFMyID0gRi5tdWwoIHAyWzFdICwgWjFfY3ViZWQpO1xuXG4gICAgICAgIHJldHVybiAoRi5lcShVMSxVMikgJiYgRi5lcShTMSxTMikpO1xuICAgIH1cblxuICAgIGlzWmVybyhwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYuaXNaZXJvKHBbMl0pO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKHApIHtcbiAgICAgICAgY29uc3QgY3AgPSB0aGlzLmFmZmluZShwKTtcbiAgICAgICAgcmV0dXJuIGBbICR7dGhpcy5GLnRvU3RyaW5nKGNwWzBdKX0gLCAke3RoaXMuRi50b1N0cmluZyhjcFsxXSl9IF1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG4gICAgICAgIGxldCBQID0gW107XG4gICAgICAgIGxldCBncmVhdGVzdDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgUFswXSA9IEYuZnJvbVJuZyhybmcpO1xuICAgICAgICAgICAgZ3JlYXRlc3QgPSBybmcubmV4dEJvb2woKTtcbiAgICAgICAgICAgIGNvbnN0IHgzYiA9IEYuYWRkKEYubXVsKEYuc3F1YXJlKFBbMF0pLCBQWzBdKSwgdGhpcy5iKTtcbiAgICAgICAgICAgIFBbMV0gPSBGLnNxcnQoeDNiKTtcbiAgICAgICAgfSB3aGlsZSAoKFBbMV0gPT0gbnVsbCl8fChGLmlzWmVyb1tQXSkpO1xuXG4gICAgICAgIGNvbnN0IHMgPSBpc0dyZWF0ZXN0KEYsIFBbMV0pO1xuICAgICAgICBpZiAoZ3JlYXRlc3QgXiBzKSBQWzFdID0gRi5uZWcoUFsxXSk7XG4gICAgICAgIFBbMl0gPSBGLm9uZTtcblxuICAgICAgICBpZiAodGhpcy5jb2ZhY3Rvcikge1xuICAgICAgICAgICAgUCA9IHRoaXMubXVsU2NhbGFyKFAsIHRoaXMuY29mYWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgUCA9IHRoaXMuYWZmaW5lKFApO1xuXG4gICAgICAgIHJldHVybiBQO1xuXG4gICAgfVxuXG4gICAgdG9ScHJMRShidWZmLCBvLCBwKSB7XG4gICAgICAgIHAgPSB0aGlzLmFmZmluZShwKTtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKHApKSB7XG4gICAgICAgICAgICBjb25zdCBCdWZmViA9IG5ldyBVaW50OEFycmF5KGJ1ZmYsIG8sIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIEJ1ZmZWLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbywgcFswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFKGJ1ZmYsIG8rdGhpcy5GLm44LCBwWzFdKTtcbiAgICB9XG5cbiAgICB0b1JwckJFKGJ1ZmYsIG8sIHApIHtcbiAgICAgICAgcCA9IHRoaXMuYWZmaW5lKHApO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIGNvbnN0IEJ1ZmZWID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiwgbywgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgQnVmZlYuZmlsbCgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvLCBwWzBdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkUoYnVmZiwgbyt0aGlzLkYubjgsIHBbMV0pO1xuICAgIH1cblxuICAgIHRvUnByTEVNKGJ1ZmYsIG8sIHApIHtcbiAgICAgICAgcCA9IHRoaXMuYWZmaW5lKHApO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIGNvbnN0IEJ1ZmZWID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiwgbywgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgQnVmZlYuZmlsbCgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbywgcFswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFTShidWZmLCBvK3RoaXMuRi5uOCwgcFsxXSk7XG4gICAgfVxuXG4gICAgdG9ScHJMRUpNKGJ1ZmYsIG8sIHApIHtcbiAgICAgICAgcCA9IHRoaXMuYWZmaW5lKHApO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIGNvbnN0IEJ1ZmZWID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiwgbywgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgQnVmZlYuZmlsbCgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbywgcFswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFTShidWZmLCBvK3RoaXMuRi5uOCwgcFsxXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFTShidWZmLCBvKzIqdGhpcy5GLm44LCBwWzJdKTtcbiAgICB9XG5cblxuICAgIHRvUnByQkVNKGJ1ZmYsIG8sIHApIHtcbiAgICAgICAgcCA9IHRoaXMuYWZmaW5lKHApO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIGNvbnN0IEJ1ZmZWID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiwgbywgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgQnVmZlYuZmlsbCgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkYudG9ScHJCRU0oYnVmZiwgbywgcFswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckJFTShidWZmLCBvK3RoaXMuRi5uOCwgcFsxXSk7XG4gICAgfVxuXG4gICAgZnJvbVJwckxFKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuRi5mcm9tUnByTEUoYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLkYuZnJvbVJwckxFKGJ1ZmYsIG8rdGhpcy5GLm44KTtcbiAgICAgICAgaWYgKHRoaXMuRi5pc1plcm8oeCkgJiYgdGhpcy5GLmlzWmVybyh5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHksIHRoaXMuRi5vbmVdO1xuICAgIH1cblxuICAgIGZyb21ScHJCRShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5GLmZyb21ScHJCRShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIGlmICh0aGlzLkYuaXNaZXJvKHgpICYmIHRoaXMuRi5pc1plcm8oeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5LCB0aGlzLkYub25lXTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuRi5mcm9tUnByTEVNKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICBpZiAodGhpcy5GLmlzWmVybyh4KSAmJiB0aGlzLkYuaXNaZXJvKHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeSwgdGhpcy5GLm9uZV07XG4gICAgfVxuXG4gICAgZnJvbVJwckxFSk0oYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIGNvbnN0IHogPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvK3RoaXMuRi5uOCoyKTtcbiAgICAgICAgaWYgKHRoaXMuRi5pc1plcm8oeCkgJiYgdGhpcy5GLmlzWmVybyh5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgIH1cblxuICAgIGZyb21ScHJCRU0oYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5GLmZyb21ScHJCRU0oYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIGlmICh0aGlzLkYuaXNaZXJvKHgpICYmIHRoaXMuRi5pc1plcm8oeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5LCB0aGlzLkYub25lXTtcbiAgICB9XG5cbiAgICBmcm9tUnByQ29tcHJlc3NlZChidWZmLCBvKSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgVWludDhBcnJheShidWZmLmJ1ZmZlciwgbywgRi5uOCk7XG4gICAgICAgIGlmICh2WzBdICYgMHg0MCkgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgY29uc3QgUCA9IG5ldyBBcnJheSgzKTtcblxuICAgICAgICBjb25zdCBncmVhdGVzdCA9ICgodlswXSAmIDB4ODApICE9IDApO1xuICAgICAgICB2WzBdID0gdlswXSAmIDB4N0Y7XG4gICAgICAgIFBbMF0gPSBGLmZyb21ScHJCRShidWZmLCBvKTtcbiAgICAgICAgaWYgKGdyZWF0ZXN0KSB2WzBdID0gdlswXSB8IDB4ODA7ICAvLyBzZXQgYmFjayBhZ2FpbiB0aGUgb2xkIHZhbHVlXG5cbiAgICAgICAgY29uc3QgeDNiID0gRi5hZGQoRi5tdWwoRi5zcXVhcmUoUFswXSksIFBbMF0pLCB0aGlzLmIpO1xuICAgICAgICBQWzFdID0gRi5zcXJ0KHgzYik7XG5cbiAgICAgICAgaWYgKFBbMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUG9pbnQhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcyA9IGlzR3JlYXRlc3QoRiwgUFsxXSk7XG4gICAgICAgIGlmIChncmVhdGVzdCBeIHMpIFBbMV0gPSBGLm5lZyhQWzFdKTtcbiAgICAgICAgUFsyXSA9IEYub25lO1xuXG4gICAgICAgIHJldHVybiBQO1xuICAgIH1cblxuICAgIHRvUnByQ29tcHJlc3NlZChidWZmLCBvLCBwKSB7XG4gICAgICAgIHAgPSB0aGlzLmFmZmluZShwKTtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBVaW50OEFycmF5KGJ1ZmYuYnVmZmVyLCBvLCB0aGlzLkYubjgpO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIHYuZmlsbCgwKTtcbiAgICAgICAgICAgIHZbMF0gPSAweDQwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8sIHBbMF0pO1xuXG4gICAgICAgIGlmIChpc0dyZWF0ZXN0KHRoaXMuRiwgcFsxXSkpIHtcbiAgICAgICAgICAgIHZbMF0gPSB2WzBdIHwgMHg4MDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCBvKSB7XG4gICAgICAgIGlmIChidWZmWzBdICYgMHg0MCkgcmV0dXJuIHRoaXMuemVybztcblxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tUnByQkUoYnVmZiwgbyk7XG4gICAgfVxuXG4gICAgdG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgbywgcCkge1xuICAgICAgICB0aGlzLnRvUnByQkUoYnVmZiwgbywgcCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKHApKSB7XG4gICAgICAgICAgICBidWZmW29dID0gYnVmZltvXSB8IDB4NDA7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/ec.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildEngine)\n/* harmony export */ });\n/* harmony import */ var _wasm_field1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wasm_field1.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field1.js\");\n/* harmony import */ var _wasm_field2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wasm_field2.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field2.js\");\n/* harmony import */ var _wasm_field3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wasm_field3.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field3.js\");\n/* harmony import */ var _wasm_curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wasm_curve.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_curve.js\");\n/* harmony import */ var _threadman_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./threadman.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _engine_applykey_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./engine_applykey.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_applykey.js\");\n/* harmony import */ var _engine_pairing_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./engine_pairing.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_pairing.js\");\n/* harmony import */ var _engine_multiexp_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./engine_multiexp.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_multiexp.js\");\n/* harmony import */ var _engine_fft_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./engine_fft.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_fft.js\");\n\n\n\n\n\n\n\n\n\n\n\nasync function buildEngine(params) {\n\n    const tm = await (0,_threadman_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(params.wasm, params.singleThread);\n\n\n    const curve = {};\n\n    curve.q = _scalar_js__WEBPACK_IMPORTED_MODULE_5__.e(params.wasm.q.toString());\n    curve.r = _scalar_js__WEBPACK_IMPORTED_MODULE_5__.e(params.wasm.r.toString());\n    curve.name = params.name;\n    curve.tm = tm;\n    curve.prePSize = params.wasm.prePSize;\n    curve.preQSize = params.wasm.preQSize;\n    curve.Fr = new _wasm_field1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](tm, \"frm\", params.n8r, params.r);\n    curve.F1 = new _wasm_field1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](tm, \"f1m\", params.n8q, params.q);\n    curve.F2 = new _wasm_field2_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](tm, \"f2m\", curve.F1);\n    curve.G1 = new _wasm_curve_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tm, \"g1m\", curve.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);\n    curve.G2 = new _wasm_curve_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tm, \"g2m\", curve.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);\n    curve.F6 = new _wasm_field3_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](tm, \"f6m\", curve.F2);\n    curve.F12 = new _wasm_field2_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](tm, \"ftm\", curve.F6);\n\n    curve.Gt = curve.F12;\n\n    (0,_engine_applykey_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(curve, \"G1\");\n    (0,_engine_applykey_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(curve, \"G2\");\n    (0,_engine_applykey_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(curve, \"Fr\");\n\n    (0,_engine_multiexp_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(curve, \"G1\");\n    (0,_engine_multiexp_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(curve, \"G2\");\n\n    (0,_engine_fft_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(curve, \"G1\");\n    (0,_engine_fft_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(curve, \"G2\");\n    (0,_engine_fft_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(curve, \"Fr\");\n\n    (0,_engine_pairing_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(curve);\n\n    curve.array2buffer = function(arr, sG) {\n        const buff = new Uint8Array(sG*arr.length);\n\n        for (let i=0; i<arr.length; i++) {\n            buff.set(arr[i], i*sG);\n        }\n\n        return buff;\n    };\n\n    curve.buffer2array = function(buff , sG) {\n        const n= buff.byteLength / sG;\n        const arr = new Array(n);\n        for (let i=0; i<n; i++) {\n            arr[i] = buff.slice(i*sG, i*sG+sG);\n        }\n        return arr;\n    };\n\n    return curve;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMEM7QUFDQTtBQUNBO0FBQ0Y7QUFDUTtBQUNWO0FBQ2dCO0FBQ1A7QUFDRTtBQUNWOztBQUV4Qjs7QUFFZixxQkFBcUIseURBQWtCOzs7QUFHdkM7O0FBRUEsY0FBYyx5Q0FBUTtBQUN0QixjQUFjLHlDQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFVO0FBQzdCLG1CQUFtQix1REFBVTtBQUM3QixtQkFBbUIsdURBQVU7QUFDN0IsbUJBQW1CLHNEQUFTO0FBQzVCLG1CQUFtQixzREFBUztBQUM1QixtQkFBbUIsdURBQVU7QUFDN0Isb0JBQW9CLHVEQUFVOztBQUU5Qjs7QUFFQSxJQUFJLCtEQUFrQjtBQUN0QixJQUFJLCtEQUFrQjtBQUN0QixJQUFJLCtEQUFrQjs7QUFFdEIsSUFBSSwrREFBYTtBQUNqQixJQUFJLCtEQUFhOztBQUVqQixJQUFJLDBEQUFRO0FBQ1osSUFBSSwwREFBUTtBQUNaLElBQUksMERBQVE7O0FBRVosSUFBSSw4REFBWTs7QUFFaEI7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2VuZ2luZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgV2FzbUZpZWxkMSBmcm9tIFwiLi93YXNtX2ZpZWxkMS5qc1wiO1xuaW1wb3J0IFdhc21GaWVsZDIgZnJvbSBcIi4vd2FzbV9maWVsZDIuanNcIjtcbmltcG9ydCBXYXNtRmllbGQzIGZyb20gXCIuL3dhc21fZmllbGQzLmpzXCI7XG5pbXBvcnQgV2FzbUN1cnZlIGZyb20gXCIuL3dhc21fY3VydmUuanNcIjtcbmltcG9ydCBidWlsZFRocmVhZE1hbmFnZXIgZnJvbSBcIi4vdGhyZWFkbWFuLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5pbXBvcnQgYnVpbGRCYXRjaEFwcGx5S2V5IGZyb20gXCIuL2VuZ2luZV9hcHBseWtleS5qc1wiO1xuaW1wb3J0IGJ1aWxkUGFpcmluZyBmcm9tIFwiLi9lbmdpbmVfcGFpcmluZy5qc1wiO1xuaW1wb3J0IGJ1aWxkTXVsdGlFeHAgZnJvbSBcIi4vZW5naW5lX211bHRpZXhwLmpzXCI7XG5pbXBvcnQgYnVpbGRGRlQgZnJvbSBcIi4vZW5naW5lX2ZmdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBidWlsZEVuZ2luZShwYXJhbXMpIHtcblxuICAgIGNvbnN0IHRtID0gYXdhaXQgYnVpbGRUaHJlYWRNYW5hZ2VyKHBhcmFtcy53YXNtLCBwYXJhbXMuc2luZ2xlVGhyZWFkKTtcblxuXG4gICAgY29uc3QgY3VydmUgPSB7fTtcblxuICAgIGN1cnZlLnEgPSBTY2FsYXIuZShwYXJhbXMud2FzbS5xLnRvU3RyaW5nKCkpO1xuICAgIGN1cnZlLnIgPSBTY2FsYXIuZShwYXJhbXMud2FzbS5yLnRvU3RyaW5nKCkpO1xuICAgIGN1cnZlLm5hbWUgPSBwYXJhbXMubmFtZTtcbiAgICBjdXJ2ZS50bSA9IHRtO1xuICAgIGN1cnZlLnByZVBTaXplID0gcGFyYW1zLndhc20ucHJlUFNpemU7XG4gICAgY3VydmUucHJlUVNpemUgPSBwYXJhbXMud2FzbS5wcmVRU2l6ZTtcbiAgICBjdXJ2ZS5GciA9IG5ldyBXYXNtRmllbGQxKHRtLCBcImZybVwiLCBwYXJhbXMubjhyLCBwYXJhbXMucik7XG4gICAgY3VydmUuRjEgPSBuZXcgV2FzbUZpZWxkMSh0bSwgXCJmMW1cIiwgcGFyYW1zLm44cSwgcGFyYW1zLnEpO1xuICAgIGN1cnZlLkYyID0gbmV3IFdhc21GaWVsZDIodG0sIFwiZjJtXCIsIGN1cnZlLkYxKTtcbiAgICBjdXJ2ZS5HMSA9IG5ldyBXYXNtQ3VydmUodG0sIFwiZzFtXCIsIGN1cnZlLkYxLCBwYXJhbXMud2FzbS5wRzFnZW4sIHBhcmFtcy53YXNtLnBHMWIsIHBhcmFtcy5jb2ZhY3RvckcxKTtcbiAgICBjdXJ2ZS5HMiA9IG5ldyBXYXNtQ3VydmUodG0sIFwiZzJtXCIsIGN1cnZlLkYyLCBwYXJhbXMud2FzbS5wRzJnZW4sIHBhcmFtcy53YXNtLnBHMmIsIHBhcmFtcy5jb2ZhY3RvckcyKTtcbiAgICBjdXJ2ZS5GNiA9IG5ldyBXYXNtRmllbGQzKHRtLCBcImY2bVwiLCBjdXJ2ZS5GMik7XG4gICAgY3VydmUuRjEyID0gbmV3IFdhc21GaWVsZDIodG0sIFwiZnRtXCIsIGN1cnZlLkY2KTtcblxuICAgIGN1cnZlLkd0ID0gY3VydmUuRjEyO1xuXG4gICAgYnVpbGRCYXRjaEFwcGx5S2V5KGN1cnZlLCBcIkcxXCIpO1xuICAgIGJ1aWxkQmF0Y2hBcHBseUtleShjdXJ2ZSwgXCJHMlwiKTtcbiAgICBidWlsZEJhdGNoQXBwbHlLZXkoY3VydmUsIFwiRnJcIik7XG5cbiAgICBidWlsZE11bHRpRXhwKGN1cnZlLCBcIkcxXCIpO1xuICAgIGJ1aWxkTXVsdGlFeHAoY3VydmUsIFwiRzJcIik7XG5cbiAgICBidWlsZEZGVChjdXJ2ZSwgXCJHMVwiKTtcbiAgICBidWlsZEZGVChjdXJ2ZSwgXCJHMlwiKTtcbiAgICBidWlsZEZGVChjdXJ2ZSwgXCJGclwiKTtcblxuICAgIGJ1aWxkUGFpcmluZyhjdXJ2ZSk7XG5cbiAgICBjdXJ2ZS5hcnJheTJidWZmZXIgPSBmdW5jdGlvbihhcnIsIHNHKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRyphcnIubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBidWZmLnNldChhcnJbaV0sIGkqc0cpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfTtcblxuICAgIGN1cnZlLmJ1ZmZlcjJhcnJheSA9IGZ1bmN0aW9uKGJ1ZmYgLCBzRykge1xuICAgICAgICBjb25zdCBuPSBidWZmLmJ5dGVMZW5ndGggLyBzRztcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBidWZmLnNsaWNlKGkqc0csIGkqc0crc0cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAgIHJldHVybiBjdXJ2ZTtcbn1cblxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_applykey.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine_applykey.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildBatchApplyKey)\n/* harmony export */ });\n/* harmony import */ var _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bigbuffer.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\");\n\n\nfunction buildBatchApplyKey(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = curve.tm;\n\n    curve[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        let fnName, fnAffine;\n        let sGin, sGmid, sGout;\n        if (groupName == \"G1\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g1m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g1m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g1m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g2m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g2m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g2m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_batchApplyKey\";\n            sGin = G.n8;\n            sGmid = G.n8;\n            sGout = G.n8;\n        } else {\n            throw new Error(\"Invalid group: \" + groupName);\n        }\n        const nPoints = Math.floor(buff.byteLength / sGin);\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        inc = Fr.e(inc);\n        let t = Fr.e(first);\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({\n                cmd: \"ALLOCSET\",\n                var: 0,\n                buff: buff.slice(i*pointsPerChunk*sGin, i*pointsPerChunk*sGin + n*sGin)\n            });\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: t});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: inc});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*Math.max(sGmid, sGout)});\n            task.push({\n                cmd: \"CALL\",\n                fnName: fnName,\n                params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1},\n                    {var: 2},\n                    {var:3}\n                ]\n            });\n            if (fnAffine) {\n                task.push({\n                    cmd: \"CALL\",\n                    fnName: fnAffine,\n                    params: [\n                        {var: 3},\n                        {val: n},\n                        {var: 3},\n                    ]\n                });\n            }\n            task.push({cmd: \"GET\", out: 0, var: 3, len: n*sGout});\n\n            opPromises.push(tm.queueAction(task));\n            t = Fr.mul(t, Fr.exp(inc, n));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let outBuff;\n        if (buff instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n            outBuff = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](nPoints*sGout);\n        } else {\n            outBuff = new Uint8Array(nPoints*sGout);\n        }\n\n        let p=0;\n        for (let i=0; i<result.length; i++) {\n            outBuff.set(result[i][0], p);\n            p += result[i][0].byteLength;\n        }\n\n        return outBuff;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfYXBwbHlrZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7O0FBRXhCO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QixpQ0FBaUM7QUFDeEQsdUJBQXVCLG1DQUFtQztBQUMxRCx1QkFBdUIsb0RBQW9EO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIscUJBQXFCLE9BQU87QUFDNUIscUJBQXFCLE9BQU87QUFDNUIscUJBQXFCLE9BQU87QUFDNUIscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHVCQUF1Qix5Q0FBeUM7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QixxREFBUztBQUNyQywwQkFBMEIscURBQVM7QUFDbkMsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfYXBwbHlrZXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJpZ0J1ZmZlciBmcm9tIFwiLi9iaWdidWZmZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRCYXRjaEFwcGx5S2V5KGN1cnZlLCBncm91cE5hbWUpIHtcbiAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHRtID0gY3VydmUudG07XG5cbiAgICBjdXJ2ZVtncm91cE5hbWVdLmJhdGNoQXBwbHlLZXkgPSBhc3luYyBmdW5jdGlvbihidWZmLCBmaXJzdCwgaW5jLCBpblR5cGUsIG91dFR5cGUpIHtcbiAgICAgICAgaW5UeXBlID0gaW5UeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIG91dFR5cGUgPSBvdXRUeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIGxldCBmbk5hbWUsIGZuQWZmaW5lO1xuICAgICAgICBsZXQgc0dpbiwgc0dtaWQsIHNHb3V0O1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImphY29iaWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzR2luID0gRy5GLm44KjM7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMW1fYmF0Y2hBcHBseUtleVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzR2luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMW1fYmF0Y2hBcHBseUtleU1peGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzR21pZCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgaWYgKG91dFR5cGUgPT0gXCJqYWNvYmlhblwiKSB7XG4gICAgICAgICAgICAgICAgc0dvdXQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm5BZmZpbmUgPSBcImcxbV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICAgICAgc0dvdXQgPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiamFjb2JpYW5cIikge1xuICAgICAgICAgICAgICAgIHNHaW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcybV9iYXRjaEFwcGx5S2V5XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNHaW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcybV9iYXRjaEFwcGx5S2V5TWl4ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNHbWlkID0gRy5GLm44KjM7XG4gICAgICAgICAgICBpZiAob3V0VHlwZSA9PSBcImphY29iaWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzR291dCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbkFmZmluZSA9IFwiZzJtX2JhdGNoVG9BZmZpbmVcIjtcbiAgICAgICAgICAgICAgICBzR291dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkZyXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZnJtX2JhdGNoQXBwbHlLZXlcIjtcbiAgICAgICAgICAgIHNHaW4gPSBHLm44O1xuICAgICAgICAgICAgc0dtaWQgPSBHLm44O1xuICAgICAgICAgICAgc0dvdXQgPSBHLm44O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cDogXCIgKyBncm91cE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmYuYnl0ZUxlbmd0aCAvIHNHaW4pO1xuICAgICAgICBjb25zdCBwb2ludHNQZXJDaHVuayA9IE1hdGguZmxvb3IoblBvaW50cy90bS5jb25jdXJyZW5jeSk7XG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaW5jID0gRnIuZShpbmMpO1xuICAgICAgICBsZXQgdCA9IEZyLmUoZmlyc3QpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dG0uY29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgdG0uY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBwb2ludHNQZXJDaHVuaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHMgLSBpKnBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG5cbiAgICAgICAgICAgIHRhc2sucHVzaCh7XG4gICAgICAgICAgICAgICAgY21kOiBcIkFMTE9DU0VUXCIsXG4gICAgICAgICAgICAgICAgdmFyOiAwLFxuICAgICAgICAgICAgICAgIGJ1ZmY6IGJ1ZmYuc2xpY2UoaSpwb2ludHNQZXJDaHVuaypzR2luLCBpKnBvaW50c1BlckNodW5rKnNHaW4gKyBuKnNHaW4pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogdH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAyLCBidWZmOiBpbmN9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMywgbGVuOiBuKk1hdGgubWF4KHNHbWlkLCBzR291dCl9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7XG4gICAgICAgICAgICAgICAgY21kOiBcIkNBTExcIixcbiAgICAgICAgICAgICAgICBmbk5hbWU6IGZuTmFtZSxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6M31cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmbkFmZmluZSkge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogXCJDQUxMXCIsXG4gICAgICAgICAgICAgICAgICAgIGZuTmFtZTogZm5BZmZpbmUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogM30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDMsIGxlbjogbipzR291dH0pO1xuXG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2godG0ucXVldWVBY3Rpb24odGFzaykpO1xuICAgICAgICAgICAgdCA9IEZyLm11bCh0LCBGci5leHAoaW5jLCBuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgb3V0QnVmZjtcbiAgICAgICAgaWYgKGJ1ZmYgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIG91dEJ1ZmYgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0dvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0QnVmZiA9IG5ldyBVaW50OEFycmF5KG5Qb2ludHMqc0dvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHA9MDtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0QnVmZi5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHAgKz0gcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0QnVmZjtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_applykey.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildBatchConvert)\n/* harmony export */ });\n/* harmony import */ var _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bigbuffer.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\");\n\n\nfunction buildBatchConvert(tm, fnName, sIn, sOut) {\n    return async function batchConvert(buffIn) {\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1}\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n            fullBuffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfYmF0Y2hjb252ZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDOztBQUV4QjtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pELGlCQUFpQixtQ0FBbUM7QUFDcEQsaUJBQWlCO0FBQ2pCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsaUJBQWlCLHlDQUF5QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLHFEQUFTO0FBQ3ZDLDhCQUE4QixxREFBUztBQUN2QyxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2VuZ2luZV9iYXRjaGNvbnZlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJpZ0J1ZmZlciBmcm9tIFwiLi9iaWdidWZmZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRCYXRjaENvbnZlcnQodG0sIGZuTmFtZSwgc0luLCBzT3V0KSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIGJhdGNoQ29udmVydChidWZmSW4pIHtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoYnVmZkluLmJ5dGVMZW5ndGggLyBzSW4pO1xuICAgICAgICBpZiAoIG5Qb2ludHMgKiBzSW4gIT09IGJ1ZmZJbi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ1ZmZlciBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50c1BlckNodW5rID0gTWF0aC5mbG9vcihuUG9pbnRzL3RtLmNvbmN1cnJlbmN5KTtcbiAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dG0uY29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgdG0uY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBwb2ludHNQZXJDaHVuaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHMgLSBpKnBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmQ2h1bmsgPSBidWZmSW4uc2xpY2UoaSpwb2ludHNQZXJDaHVuaypzSW4sIGkqcG9pbnRzUGVyQ2h1bmsqc0luICsgbipzSW4pO1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjpidWZmQ2h1bmt9LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAxLCBsZW46c091dCAqIG59LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuTmFtZSwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMX1cbiAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMSwgbGVuOnNPdXQgKiBufSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgdG0ucXVldWVBY3Rpb24odGFzaylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgZnVsbEJ1ZmZPdXQ7XG4gICAgICAgIGlmIChidWZmSW4gaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNPdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNPdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHAgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0LnNldChyZXN1bHRbaV1bMF0sIHApO1xuICAgICAgICAgICAgcCs9cmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVsbEJ1ZmZPdXQ7XG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_fft.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine_fft.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildFFT)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js\");\n/* harmony import */ var _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bigbuffer.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\");\n\n\n\n\nfunction buildFFT(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = G.tm;\n    async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {\n\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        const MAX_BITS_THREAD = 14;\n\n        let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g1m_fftFinal\";\n            }\n            fnFFTJoin = \"g1m_fftJoin\";\n            fnFFTMix = \"g1m_fftMix\";\n\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g1m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g2m_fftFinal\";\n            }\n            fnFFTJoin = \"g2m_fftJoin\";\n            fnFFTMix = \"g2m_fftMix\";\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g2m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = G.n8;\n            sMid = G.n8;\n            sOut = G.n8;\n            if (inverse) {\n                fnFFTFinal = \"frm_fftFinal\";\n            }\n            fnFFTMix = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        }\n\n\n        let returnArray = false;\n        if (Array.isArray(buff)) {\n            buff = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.array2buffer)(buff, sIn);\n            returnArray = true;\n        } else {\n            buff = buff.slice(0, buff.byteLength);\n        }\n\n        const nPoints = buff.byteLength / sIn;\n        const bits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints);\n\n        if  ((1 << bits) != nPoints) {\n            throw new Error(\"fft must be multiple of 2\" );\n        }\n\n        if (bits == Fr.s +1) {\n            let buffOut;\n\n            if (inverse) {\n                buffOut =  await _fftExtInv(buff, inType, outType, logger, loggerTxt);\n            } else {\n                buffOut =  await _fftExt(buff, inType, outType, logger, loggerTxt);\n            }\n\n            if (returnArray) {\n                return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.buffer2array)(buffOut, sOut);\n            } else {\n                return buffOut;\n            }\n        }\n\n        let inv;\n        if (inverse) {\n            inv = Fr.inv(Fr.e(nPoints));\n        }\n\n        let buffOut;\n\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.buffReverseBits)(buff, sIn);\n\n        let chunks;\n        let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);\n        let nChunks = nPoints / pointsInChunk;\n\n        while ((nChunks < tm.concurrency)&&(pointsInChunk>=16)) {\n            nChunks *= 2;\n            pointsInChunk /= 2;\n        }\n\n        const l2Chunk = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(pointsInChunk);\n\n        const promises = [];\n        for (let i = 0; i< nChunks; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix start: ${i}/${nChunks}`);\n            const task = [];\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*pointsInChunk});\n            const buffChunk = buff.slice( (pointsInChunk * i)*sIn, (pointsInChunk * (i+1))*sIn);\n            task.push({cmd: \"SET\", var: 0, buff: buffChunk});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n            }\n            for (let j=1; j<=l2Chunk;j++) {\n                task.push({cmd: \"CALL\", fnName:fnFFTMix, params: [{var:0}, {val: pointsInChunk}, {val: j}]});\n            }\n\n            if (l2Chunk==bits) {\n                if (fnFFTFinal) {\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: inv});\n                    task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                        {var: 0},\n                        {val: pointsInChunk},\n                        {var: 1},\n                    ]});\n                }\n                if (fnMid2Out) {\n                    task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                }\n                task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n            } else {\n                task.push({cmd: \"GET\", out:0, var: 0, len: sMid*pointsInChunk});\n            }\n            promises.push(tm.queueAction(task).then( (r) => {\n                if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix end: ${i}/${nChunks}`);\n                return r;\n            }));\n        }\n\n        chunks = await Promise.all(promises);\n        for (let i = 0; i< nChunks; i++) chunks[i] = chunks[i][0];\n\n        for (let i = l2Chunk+1;   i<=bits; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft  ${bits}  join: ${i}/${bits}`);\n            const nGroups = 1 << (bits - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsInChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsInChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    if (i==bits) {\n                        if (fnFFTFinal) {\n                            task.push({cmd: \"ALLOCSET\", var: 4, buff: inv});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 0},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 1},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                        }\n                        if (fnMid2Out) {\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: pointsInChunk}, {var: 1}]});\n                        }\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sOut});\n                    } else {\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sMid});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sMid});\n                    }\n                    opPromises.push(tm.queueAction(task).then( (r) => {\n                        if (logger) logger.debug(`${loggerTxt}: fft ${bits} join  ${i}/${bits}  ${j+1}/${nGroups} ${k}/${nChunksPerGroup/2}`);\n                        return r;\n                    }));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        if (buff instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n            buffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sOut);\n        } else {\n            buffOut = new Uint8Array(nPoints*sOut);\n        }\n        if (inverse) {\n            buffOut.set(chunks[0].slice((pointsInChunk-1)*sOut));\n            let p= sOut;\n            for (let i=nChunks-1; i>0; i--) {\n                buffOut.set(chunks[i], p);\n                p += pointsInChunk*sOut;\n                delete chunks[i];  // Liberate mem\n            }\n            buffOut.set(chunks[0].slice(0, (pointsInChunk-1)*sOut), p);\n            delete chunks[0];\n        } else {\n            for (let i=0; i<nChunks; i++) {\n                buffOut.set(chunks[i], pointsInChunk*sOut*i);\n                delete chunks[i];\n            }\n        }\n\n        if (returnArray) {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.buffer2array)(buffOut, sOut);\n        } else {\n            return buffOut;\n        }\n    }\n\n    async function _fftExt(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        [b1, b2] = await _fftJoinExt(b1, b2, \"fftJoinExt\", Fr.one, Fr.shift, inType, \"jacobian\", logger, loggerTxt);\n\n        promises.push( _fft(b1, false, \"jacobian\", outType, logger, loggerTxt));\n        promises.push( _fft(b2, false, \"jacobian\", outType, logger, loggerTxt));\n\n        const res1 = await Promise.all(promises);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n    async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        promises.push( _fft(b1, true, inType, \"jacobian\", logger, loggerTxt));\n        promises.push( _fft(b2, true, inType, \"jacobian\", logger, loggerTxt));\n\n        [b1, b2] = await Promise.all(promises);\n\n        const res1 = await _fftJoinExt(b1, b2, \"fftJoinExtInv\", Fr.one, Fr.shiftInv, \"jacobian\", outType, logger, loggerTxt);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n\n    async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const MIN_CHUNK_SIZE = 1<<4;\n\n        let fnName;\n        let fnIn2Mid, fnMid2Out;\n        let sOut, sIn, sMid;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            fnName = \"g1m_\"+fn;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g1m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            fnName = \"g2m_\"+fn;\n            sMid = G.F.n8*3;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g2m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n            sOut = Fr.n8;\n            sMid = Fr.n8;\n            fnName = \"frm_\" + fn;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sIn);\n        if (nPoints != 1 << (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let chunkSize = Math.floor(nPoints /tm.concurrency);\n        if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n        if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n\n        const opPromises = [];\n\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n\n            const firstChunk = Fr.mul(first, Fr.exp( inc, i));\n            const task = [];\n\n            const b1 = buff1.slice(i*sIn, (i+n)*sIn);\n            const b2 = buff2.slice(i*sIn, (i+n)*sIn);\n\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*n});\n            task.push({cmd: \"SET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOC\", var: 1, len: sMid*n});\n            task.push({cmd: \"SET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: n},\n                {var: 2},\n                {var: 3},\n                {val: Fr.s},\n            ]});\n            if (fnMid2Out) {\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sOut});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: n*sOut});\n            opPromises.push(\n                tm.queueAction(task).then( (r) => {\n                    if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);\n                    return r;\n                })\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (nPoints * sOut > 1<<28) {\n            fullBuffOut1 = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sOut);\n            fullBuffOut2 = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sOut);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sOut);\n            fullBuffOut2 = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    }\n\n\n    G.fft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, false, inType, outType, logger, loggerTxt);\n    };\n\n    G.ifft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, true, inType, outType, logger, loggerTxt);\n    };\n\n    G.lagrangeEvaluations = async function (buff, inType, outType, logger, loggerTxt) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n\n        let sIn;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = buff.byteLength /sIn;\n        const bits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints);\n\n        if ((2 ** bits)*sIn != buff.byteLength) {\n            if (logger) logger.error(\"lagrangeEvaluations iinvalid input size\");\n            throw new Error(\"lagrangeEvaluations invalid Input size\");\n        }\n\n        if (bits <= Fr.s) {\n            return await G.ifft(buff, inType, outType, logger, loggerTxt);\n        }\n\n        if (bits > Fr.s+1) {\n            if (logger) logger.error(\"lagrangeEvaluations input too big\");\n            throw new Error(\"lagrangeEvaluations input too big\");\n        }\n\n        let t0 = buff.slice(0, buff.byteLength/2);\n        let t1 = buff.slice(buff.byteLength/2, buff.byteLength);\n\n\n        const shiftToSmallM = Fr.exp(Fr.shift, nPoints/2);\n        const sConst = Fr.inv( Fr.sub(Fr.one, shiftToSmallM));\n\n        [t0, t1] = await _fftJoinExt(t0, t1, \"prepareLagrangeEvaluation\", sConst, Fr.shiftInv, inType, \"jacobian\", logger, loggerTxt + \" prep\");\n\n        const promises = [];\n\n        promises.push( _fft(t0, true, \"jacobian\", outType, logger, loggerTxt + \" t0\"));\n        promises.push( _fft(t1, true, \"jacobian\", outType, logger, loggerTxt + \" t1\"));\n\n        [t0, t1] = await Promise.all(promises);\n\n        let buffOut;\n        if (t0.byteLength > (1<<28)) {\n            buffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](t0.byteLength*2);\n        } else {\n            buffOut = new Uint8Array(t0.byteLength*2);\n        }\n\n        buffOut.set(t0);\n        buffOut.set(t1, t0.byteLength);\n\n        return buffOut;\n    };\n\n    G.fftMix = async function fftMix(buff) {\n        const sG = G.F.n8*3;\n        let fnName, fnFFTJoin;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftMix\";\n            fnFFTJoin = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftMix\";\n            fnFFTJoin = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        const power = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints);\n\n        let nChunks = 1 << (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(tm.concurrency);\n\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n        const powerChunk = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(pointsPerChunk);\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            for (let j=1; j<=powerChunk; j++) {\n                task.push({cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: pointsPerChunk},\n                    {val: j}\n                ]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        const chunks = [];\n        for (let i=0; i<result.length; i++) chunks[i] = result[i][0];\n\n\n        for (let i = powerChunk+1; i<=power; i++) {\n            const nGroups = 1 << (power - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsPerChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsPerChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n                    task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n                    opPromises.push(tm.queueAction(task));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        let fullBuffOut;\n        if (buff instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n            fullBuffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sG);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sG);\n        }\n        let p =0;\n        for (let i=0; i<nChunks; i++) {\n            fullBuffOut.set(chunks[i], p);\n            p+=chunks[i].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n\n    G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {\n        const sG = G.F.n8*3;\n        let fnName;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sG);\n        if (nPoints != 1 << (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let nChunks = 1 << (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(tm.concurrency);\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n\n            const firstChunk = Fr.mul(first, Fr.exp(inc, i*pointsPerChunk));\n            const b1 = buff1.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            const b2 = buff2.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: pointsPerChunk},\n                {var: 2},\n                {var: 3}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (buff1 instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n            fullBuffOut1 = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sG);\n            fullBuffOut2 = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sG);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sG);\n            fullBuffOut2 = new Uint8Array(nPoints*sG);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    };\n\n\n\n    G.fftFinal =  async function fftFinal(buff, factor) {\n        const sG = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnName, fnToAffine;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftFinal\";\n            fnToAffine = \"g1m_batchToAffine\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftFinal\";\n            fnToAffine = \"g2m_batchToAffine\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        if (nPoints != 1 << (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        const pointsPerChunk = Math.floor(nPoints / tm.concurrency);\n\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, (i*pointsPerChunk+n)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: factor});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {val: n},\n                {var: 1},\n            ]});\n            task.push({cmd: \"CALL\", fnName: fnToAffine, params: [\n                {var: 0},\n                {val: n},\n                {var: 0},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sGout});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buff instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n            fullBuffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sGout);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sGout);\n        }\n\n        let p =0;\n        for (let i=result.length-1; i>=0; i--) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfZmZ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2RTtBQUN0Qzs7O0FBR3hCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVk7QUFDL0I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwrQ0FBSTs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHVEQUFZO0FBQ25DLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSwwREFBZTs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwrQ0FBSTs7QUFFNUI7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyx3Q0FBd0MsVUFBVSxRQUFRLE1BQU0sYUFBYSxFQUFFLEdBQUcsUUFBUTtBQUMxRjtBQUNBLHVCQUF1Qiw4Q0FBOEM7QUFDckU7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0EsMkJBQTJCLHdDQUF3QyxNQUFNLEdBQUcsbUJBQW1CLEdBQUcsT0FBTyxFQUFFO0FBQzNHO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsMkJBQTJCLHdDQUF3QyxNQUFNLEdBQUcsbUJBQW1CLEdBQUcsT0FBTyxFQUFFO0FBQzNHOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFLCtCQUErQjtBQUMvQix5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsbUJBQW1CO0FBQzVDLHlCQUF5QixPQUFPO0FBQ2hDLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsK0JBQStCLHlDQUF5QyxNQUFNLEdBQUcsbUJBQW1CLEdBQUcsT0FBTyxFQUFFO0FBQ2hIO0FBQ0EsMkJBQTJCLG9EQUFvRDtBQUMvRSxjQUFjO0FBQ2QsMkJBQTJCLG1EQUFtRDtBQUM5RTtBQUNBO0FBQ0EsNENBQTRDLFVBQVUsUUFBUSxNQUFNLFdBQVcsRUFBRSxHQUFHLFFBQVE7QUFDNUY7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSx3QkFBd0IsWUFBWTs7QUFFcEMsa0NBQWtDLFNBQVM7QUFDM0Msd0NBQXdDLFVBQVUsU0FBUyxPQUFPLFFBQVEsRUFBRSxHQUFHLEtBQUs7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQiwwQ0FBMEM7QUFDekUsK0JBQStCLDBDQUEwQztBQUN6RSwrQkFBK0IscUNBQXFDO0FBQ3BFLCtCQUErQixtQ0FBbUM7QUFDbEUsK0JBQStCO0FBQy9CLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixtQkFBbUI7QUFDNUMseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsdUNBQXVDLG1DQUFtQztBQUMxRSx1Q0FBdUM7QUFDdkMsaUNBQWlDLE9BQU87QUFDeEMsaUNBQWlDLG1CQUFtQjtBQUNwRCxpQ0FBaUMsT0FBTztBQUN4Qyw4QkFBOEI7QUFDOUIsdUNBQXVDO0FBQ3ZDLGlDQUFpQyxPQUFPO0FBQ3hDLGlDQUFpQyxtQkFBbUI7QUFDcEQsaUNBQWlDLE9BQU87QUFDeEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSx1Q0FBdUMseUNBQXlDLE1BQU0sR0FBRyxtQkFBbUIsR0FBRyxPQUFPLEVBQUU7QUFDeEgsdUNBQXVDLHlDQUF5QyxNQUFNLEdBQUcsbUJBQW1CLEdBQUcsT0FBTyxFQUFFO0FBQ3hIO0FBQ0EsbUNBQW1DLG9EQUFvRDtBQUN2RixtQ0FBbUMsb0RBQW9EO0FBQ3ZGLHNCQUFzQjtBQUN0QixtQ0FBbUMsb0RBQW9EO0FBQ3ZGLG1DQUFtQyxvREFBb0Q7QUFDdkY7QUFDQTtBQUNBLG9EQUFvRCxVQUFVLFFBQVEsTUFBTSxRQUFRLEVBQUUsR0FBRyxPQUFPLEVBQUUsSUFBSSxHQUFHLFNBQVMsRUFBRSxFQUFFLEdBQUcsa0JBQWtCO0FBQzNJO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyw4QkFBOEIsc0JBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLHFEQUFTO0FBQ3JDLDBCQUEwQixxREFBUztBQUNuQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHVEQUFZO0FBQy9CLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFTO0FBQ25DLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIscURBQVM7QUFDbkMsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBSTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsV0FBVztBQUNqQyx3Q0FBd0MsVUFBVSxzQkFBc0IsRUFBRSxHQUFHLFFBQVE7QUFDckY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixrQ0FBa0M7QUFDekQsdUJBQXVCLDZCQUE2QjtBQUNwRCx1QkFBdUIsa0NBQWtDO0FBQ3pELHVCQUF1Qiw2QkFBNkI7QUFDcEQsdUJBQXVCLDBDQUEwQztBQUNqRSx1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0EsMkJBQTJCLHdDQUF3QyxNQUFNLEdBQUcsT0FBTyxHQUFHLE9BQU8sRUFBRTtBQUMvRiwyQkFBMkIsd0NBQXdDLE1BQU0sR0FBRyxPQUFPLEdBQUcsT0FBTyxFQUFFO0FBQy9GO0FBQ0EsdUJBQXVCO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixVQUFVO0FBQzNCLGNBQWM7QUFDZDtBQUNBLDJCQUEyQix5Q0FBeUMsTUFBTSxHQUFHLE9BQU8sR0FBRyxPQUFPLEVBQUU7QUFDaEcsMkJBQTJCLHlDQUF5QyxNQUFNLEdBQUcsT0FBTyxHQUFHLE9BQU8sRUFBRTtBQUNoRztBQUNBLHVCQUF1Qix3Q0FBd0M7QUFDL0QsdUJBQXVCLHdDQUF3QztBQUMvRDtBQUNBO0FBQ0EsZ0RBQWdELFVBQVUsb0JBQW9CLEVBQUUsR0FBRyxRQUFRO0FBQzNGO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFEQUFTO0FBQ3hDLCtCQUErQixxREFBUztBQUN4QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLCtDQUFJOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIscURBQVM7QUFDbkMsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiwrQ0FBSTs7QUFFMUIsMkJBQTJCLCtDQUFJOztBQUUvQjs7QUFFQTs7QUFFQSwyQkFBMkIsK0NBQUk7O0FBRS9CO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUM7QUFDeEQsMEJBQTBCLGVBQWU7QUFDekMsMkJBQTJCO0FBQzNCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixvQkFBb0I7QUFDekMscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBLHVCQUF1QixtREFBbUQ7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsaUJBQWlCOzs7QUFHdkMsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQiwwQ0FBMEM7QUFDekUsK0JBQStCLDBDQUEwQztBQUN6RSwrQkFBK0IscUNBQXFDO0FBQ3BFLCtCQUErQixtQ0FBbUM7QUFDbEUsK0JBQStCO0FBQy9CLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixvQkFBb0I7QUFDN0MseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QiwrQkFBK0IsbURBQW1EO0FBQ2xGLCtCQUErQixtREFBbUQ7QUFDbEY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHFEQUFTO0FBQ3JDLDhCQUE4QixxREFBUztBQUN2QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUFJO0FBQ2hDO0FBQ0E7O0FBRUEsMkJBQTJCLCtDQUFJO0FBQy9COztBQUVBOzs7QUFHQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQsdUJBQXVCLGtDQUFrQztBQUN6RCx1QkFBdUIsMENBQTBDO0FBQ2pFLHVCQUF1QixtQ0FBbUM7QUFDMUQsdUJBQXVCO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixvQkFBb0I7QUFDckMsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCx1QkFBdUIsbURBQW1EO0FBQzFFLHVCQUF1QixtREFBbUQ7QUFDMUU7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFTO0FBQ3RDLCtCQUErQixxREFBUztBQUN4QywrQkFBK0IscURBQVM7QUFDeEMsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QiwrQ0FBSTtBQUNoQztBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUM7QUFDeEQsdUJBQXVCLHNDQUFzQztBQUM3RCx1QkFBdUI7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsY0FBYztBQUNkLHVCQUF1QjtBQUN2QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixjQUFjO0FBQ2QsdUJBQXVCLHlDQUF5QztBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIscURBQVM7QUFDckMsOEJBQThCLHFEQUFTO0FBQ3ZDLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2VuZ2luZV9mZnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtsb2cyLCBidWZmUmV2ZXJzZUJpdHMsIGFycmF5MmJ1ZmZlciwgYnVmZmVyMmFycmF5fSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IEJpZ0J1ZmZlciBmcm9tIFwiLi9iaWdidWZmZXIuanNcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZGVChjdXJ2ZSwgZ3JvdXBOYW1lKSB7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCB0bSA9IEcudG07XG4gICAgYXN5bmMgZnVuY3Rpb24gX2ZmdChidWZmLCBpbnZlcnNlLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG5cbiAgICAgICAgaW5UeXBlID0gaW5UeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIG91dFR5cGUgPSBvdXRUeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIGNvbnN0IE1BWF9CSVRTX1RIUkVBRCA9IDE0O1xuXG4gICAgICAgIGxldCBzSW4sIHNNaWQsIHNPdXQsIGZuSW4yTWlkLCBmbk1pZDJPdXQsIGZuRkZUTWl4LCBmbkZGVEpvaW4sIGZuRkZURmluYWw7XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgICAgICBmbkluMk1pZCA9IFwiZzFtX2JhdGNoVG9KYWNvYmlhblwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNNaWQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICAgICAgZm5GRlRGaW5hbCA9IFwiZzFtX2ZmdEZpbmFsXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbkZGVEpvaW4gPSBcImcxbV9mZnRKb2luXCI7XG4gICAgICAgICAgICBmbkZGVE1peCA9IFwiZzFtX2ZmdE1peFwiO1xuXG4gICAgICAgICAgICBpZiAob3V0VHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgICAgIGZuTWlkMk91dCA9IFwiZzFtX2JhdGNoVG9BZmZpbmVcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5JbjJNaWQgPSBcImcybV9iYXRjaFRvSmFjb2JpYW5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzTWlkID0gRy5GLm44KjM7XG4gICAgICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgICAgIGZuRkZURmluYWwgPSBcImcybV9mZnRGaW5hbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm5GRlRKb2luID0gXCJnMm1fZmZ0Sm9pblwiO1xuICAgICAgICAgICAgZm5GRlRNaXggPSBcImcybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGlmIChvdXRUeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5NaWQyT3V0ID0gXCJnMm1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRnJcIikge1xuICAgICAgICAgICAgc0luID0gRy5uODtcbiAgICAgICAgICAgIHNNaWQgPSBHLm44O1xuICAgICAgICAgICAgc091dCA9IEcubjg7XG4gICAgICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgICAgIGZuRkZURmluYWwgPSBcImZybV9mZnRGaW5hbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm5GRlRNaXggPSBcImZybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZnJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGV0IHJldHVybkFycmF5ID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmYpKSB7XG4gICAgICAgICAgICBidWZmID0gYXJyYXkyYnVmZmVyKGJ1ZmYsIHNJbik7XG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmID0gYnVmZi5zbGljZSgwLCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYuYnl0ZUxlbmd0aCAvIHNJbjtcbiAgICAgICAgY29uc3QgYml0cyA9IGxvZzIoblBvaW50cyk7XG5cbiAgICAgICAgaWYgICgoMSA8PCBiaXRzKSAhPSBuUG9pbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmZnQgbXVzdCBiZSBtdWx0aXBsZSBvZiAyXCIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXRzID09IEZyLnMgKzEpIHtcbiAgICAgICAgICAgIGxldCBidWZmT3V0O1xuXG4gICAgICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXQgPSAgYXdhaXQgX2ZmdEV4dEludihidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZk91dCA9ICBhd2FpdCBfZmZ0RXh0KGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmV0dXJuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyMmFycmF5KGJ1ZmZPdXQsIHNPdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZk91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnY7XG4gICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICBpbnYgPSBGci5pbnYoRnIuZShuUG9pbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYnVmZk91dDtcblxuICAgICAgICBidWZmUmV2ZXJzZUJpdHMoYnVmZiwgc0luKTtcblxuICAgICAgICBsZXQgY2h1bmtzO1xuICAgICAgICBsZXQgcG9pbnRzSW5DaHVuayA9IE1hdGgubWluKDEgPDwgTUFYX0JJVFNfVEhSRUFELCBuUG9pbnRzKTtcbiAgICAgICAgbGV0IG5DaHVua3MgPSBuUG9pbnRzIC8gcG9pbnRzSW5DaHVuaztcblxuICAgICAgICB3aGlsZSAoKG5DaHVua3MgPCB0bS5jb25jdXJyZW5jeSkmJihwb2ludHNJbkNodW5rPj0xNikpIHtcbiAgICAgICAgICAgIG5DaHVua3MgKj0gMjtcbiAgICAgICAgICAgIHBvaW50c0luQ2h1bmsgLz0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGwyQ2h1bmsgPSBsb2cyKHBvaW50c0luQ2h1bmspO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPCBuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgJHtsb2dnZXJUeHR9OiBmZnQgJHtiaXRzfSBtaXggc3RhcnQ6ICR7aX0vJHtuQ2h1bmtzfWApO1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAwLCBsZW46IHNNaWQqcG9pbnRzSW5DaHVua30pO1xuICAgICAgICAgICAgY29uc3QgYnVmZkNodW5rID0gYnVmZi5zbGljZSggKHBvaW50c0luQ2h1bmsgKiBpKSpzSW4sIChwb2ludHNJbkNodW5rICogKGkrMSkpKnNJbik7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJTRVRcIiwgdmFyOiAwLCBidWZmOiBidWZmQ2h1bmt9KTtcbiAgICAgICAgICAgIGlmIChmbkluMk1pZCkge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuSW4yTWlkLCBwYXJhbXM6IFt7dmFyOjB9LCB7dmFsOiBwb2ludHNJbkNodW5rfSwge3ZhcjogMH1dfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBqPTE7IGo8PWwyQ2h1bms7aisrKSB7XG4gICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6Zm5GRlRNaXgsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFsOiBqfV19KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGwyQ2h1bms9PWJpdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm5GRlRGaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IGludn0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5GRlRGaW5hbCwgIHBhcmFtczpbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c0luQ2h1bmt9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZuTWlkMk91dCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFyOiAwfV19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAwLCBsZW46IHBvaW50c0luQ2h1bmsqc091dH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OjAsIHZhcjogMCwgbGVuOiBzTWlkKnBvaW50c0luQ2h1bmt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godG0ucXVldWVBY3Rpb24odGFzaykudGhlbiggKHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYCR7bG9nZ2VyVHh0fTogZmZ0ICR7Yml0c30gbWl4IGVuZDogJHtpfS8ke25DaHVua3N9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBjaHVua3MgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPCBuQ2h1bmtzOyBpKyspIGNodW5rc1tpXSA9IGNodW5rc1tpXVswXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbDJDaHVuaysxOyAgIGk8PWJpdHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGAke2xvZ2dlclR4dH06IGZmdCAgJHtiaXRzfSAgam9pbjogJHtpfS8ke2JpdHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuR3JvdXBzID0gMSA8PCAoYml0cyAtIGkpO1xuICAgICAgICAgICAgY29uc3QgbkNodW5rc1Blckdyb3VwID0gbkNodW5rcyAvIG5Hcm91cHM7XG4gICAgICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8bkdyb3VwczsgaisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaz0wOyBrIDxuQ2h1bmtzUGVyR3JvdXAvMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gRnIuZXhwKCBGci53W2ldLCBrKnBvaW50c0luQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmMgPSBGci53W2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvMSA9IGoqbkNodW5rc1Blckdyb3VwICsgaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzIgPSBqKm5DaHVua3NQZXJHcm91cCArIGsgKyBuQ2h1bmtzUGVyR3JvdXAvMjtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogY2h1bmtzW28xXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IGNodW5rc1tvMl19KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAyLCBidWZmOiBmaXJzdH0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDMsIGJ1ZmY6IGluY30pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5GRlRKb2luLCAgcGFyYW1zOltcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBwb2ludHNJbkNodW5rfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogM31cbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaT09Yml0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuRkZURmluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDQsIGJ1ZmY6IGludn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkZGVEZpbmFsLCAgcGFyYW1zOltcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c0luQ2h1bmt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiA0fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuRkZURmluYWwsICBwYXJhbXM6W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogcG9pbnRzSW5DaHVua30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDR9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbk1pZDJPdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFyOiAwfV19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MX0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFyOiAxfV19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBwb2ludHNJbkNodW5rKnNPdXR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDEsIHZhcjogMSwgbGVuOiBwb2ludHNJbkNodW5rKnNPdXR9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBwb2ludHNJbkNodW5rKnNNaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDEsIHZhcjogMSwgbGVuOiBwb2ludHNJbkNodW5rKnNNaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcFByb21pc2VzLnB1c2godG0ucXVldWVBY3Rpb24odGFzaykudGhlbiggKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgJHtsb2dnZXJUeHR9OiBmZnQgJHtiaXRzfSBqb2luICAke2l9LyR7Yml0c30gICR7aisxfS8ke25Hcm91cHN9ICR7a30vJHtuQ2h1bmtzUGVyR3JvdXAvMn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxuR3JvdXBzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrPTA7IGsgPG5DaHVua3NQZXJHcm91cC8yOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzEgPSBqKm5DaHVua3NQZXJHcm91cCArIGs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8yID0gaipuQ2h1bmtzUGVyR3JvdXAgKyBrICsgbkNodW5rc1Blckdyb3VwLzI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc0NodW5rID0gcmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1tvMV0gPSByZXNDaHVua1swXTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW28yXSA9IHJlc0NodW5rWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNPdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZk91dCA9IG5ldyBVaW50OEFycmF5KG5Qb2ludHMqc091dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQuc2V0KGNodW5rc1swXS5zbGljZSgocG9pbnRzSW5DaHVuay0xKSpzT3V0KSk7XG4gICAgICAgICAgICBsZXQgcD0gc091dDtcbiAgICAgICAgICAgIGZvciAobGV0IGk9bkNodW5rcy0xOyBpPjA7IGktLSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXQuc2V0KGNodW5rc1tpXSwgcCk7XG4gICAgICAgICAgICAgICAgcCArPSBwb2ludHNJbkNodW5rKnNPdXQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNodW5rc1tpXTsgIC8vIExpYmVyYXRlIG1lbVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZk91dC5zZXQoY2h1bmtzWzBdLnNsaWNlKDAsIChwb2ludHNJbkNodW5rLTEpKnNPdXQpLCBwKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjaHVua3NbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkNodW5rczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmZk91dC5zZXQoY2h1bmtzW2ldLCBwb2ludHNJbkNodW5rKnNPdXQqaSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNodW5rc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR1cm5BcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjJhcnJheShidWZmT3V0LCBzT3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmT3V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX2ZmdEV4dChidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIGxldCBiMSwgYjI7XG4gICAgICAgIGIxID0gYnVmZi5zbGljZSggMCAsIGJ1ZmYuYnl0ZUxlbmd0aC8yKTtcbiAgICAgICAgYjIgPSBidWZmLnNsaWNlKCBidWZmLmJ5dGVMZW5ndGgvMiwgYnVmZi5ieXRlTGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIFtiMSwgYjJdID0gYXdhaXQgX2ZmdEpvaW5FeHQoYjEsIGIyLCBcImZmdEpvaW5FeHRcIiwgRnIub25lLCBGci5zaGlmdCwgaW5UeXBlLCBcImphY29iaWFuXCIsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcblxuICAgICAgICBwcm9taXNlcy5wdXNoKCBfZmZ0KGIxLCBmYWxzZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCkpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKCBfZmZ0KGIyLCBmYWxzZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCkpO1xuXG4gICAgICAgIGNvbnN0IHJlczEgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgICAgbGV0IGJ1ZmZPdXQ7XG4gICAgICAgIGlmIChyZXMxWzBdLmJ5dGVMZW5ndGggPiAoMTw8MjgpKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihyZXMxWzBdLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkocmVzMVswXS5ieXRlTGVuZ3RoKjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZk91dC5zZXQocmVzMVswXSk7XG4gICAgICAgIGJ1ZmZPdXQuc2V0KHJlczFbMV0sIHJlczFbMF0uYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZPdXQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX2ZmdEV4dEludihidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIGxldCBiMSwgYjI7XG4gICAgICAgIGIxID0gYnVmZi5zbGljZSggMCAsIGJ1ZmYuYnl0ZUxlbmd0aC8yKTtcbiAgICAgICAgYjIgPSBidWZmLnNsaWNlKCBidWZmLmJ5dGVMZW5ndGgvMiwgYnVmZi5ieXRlTGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIHByb21pc2VzLnB1c2goIF9mZnQoYjEsIHRydWUsIGluVHlwZSwgXCJqYWNvYmlhblwiLCBsb2dnZXIsIGxvZ2dlclR4dCkpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKCBfZmZ0KGIyLCB0cnVlLCBpblR5cGUsIFwiamFjb2JpYW5cIiwgbG9nZ2VyLCBsb2dnZXJUeHQpKTtcblxuICAgICAgICBbYjEsIGIyXSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICBjb25zdCByZXMxID0gYXdhaXQgX2ZmdEpvaW5FeHQoYjEsIGIyLCBcImZmdEpvaW5FeHRJbnZcIiwgRnIub25lLCBGci5zaGlmdEludiwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCk7XG5cbiAgICAgICAgbGV0IGJ1ZmZPdXQ7XG4gICAgICAgIGlmIChyZXMxWzBdLmJ5dGVMZW5ndGggPiAoMTw8MjgpKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihyZXMxWzBdLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkocmVzMVswXS5ieXRlTGVuZ3RoKjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZk91dC5zZXQocmVzMVswXSk7XG4gICAgICAgIGJ1ZmZPdXQuc2V0KHJlczFbMV0sIHJlczFbMF0uYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZPdXQ7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBfZmZ0Sm9pbkV4dChidWZmMSwgYnVmZjIsIGZuLCBmaXJzdCwgaW5jLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIGNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTw8MTY7XG4gICAgICAgIGNvbnN0IE1JTl9DSFVOS19TSVpFID0gMTw8NDtcblxuICAgICAgICBsZXQgZm5OYW1lO1xuICAgICAgICBsZXQgZm5JbjJNaWQsIGZuTWlkMk91dDtcbiAgICAgICAgbGV0IHNPdXQsIHNJbiwgc01pZDtcblxuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5JbjJNaWQgPSBcImcxbV9iYXRjaFRvSmFjb2JpYW5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzTWlkID0gRy5GLm44KjM7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9cIitmbjtcbiAgICAgICAgICAgIGlmIChvdXRUeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBmbk1pZDJPdXQgPSBcImcxbV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5JbjJNaWQgPSBcImcybV9iYXRjaFRvSmFjb2JpYW5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcybV9cIitmbjtcbiAgICAgICAgICAgIHNNaWQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIGlmIChvdXRUeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBmbk1pZDJPdXQgPSBcImcybV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRnJcIikge1xuICAgICAgICAgICAgc0luID0gRnIubjg7XG4gICAgICAgICAgICBzT3V0ID0gRnIubjg7XG4gICAgICAgICAgICBzTWlkID0gRnIubjg7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImZybV9cIiArIGZuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmMS5ieXRlTGVuZ3RoICE9IGJ1ZmYyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnVmZmVyIHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoYnVmZjEuYnl0ZUxlbmd0aCAvIHNJbik7XG4gICAgICAgIGlmIChuUG9pbnRzICE9IDEgPDwgbG9nMihuUG9pbnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNodW5rU2l6ZSA9IE1hdGguZmxvb3IoblBvaW50cyAvdG0uY29uY3VycmVuY3kpO1xuICAgICAgICBpZiAoY2h1bmtTaXplIDwgTUlOX0NIVU5LX1NJWkUpIGNodW5rU2l6ZSA9IE1JTl9DSFVOS19TSVpFO1xuICAgICAgICBpZiAoY2h1bmtTaXplID4gTUFYX0NIVU5LX1NJWkUpIGNodW5rU2l6ZSA9IE1BWF9DSFVOS19TSVpFO1xuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSArPSBjaHVua1NpemUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgJHtsb2dnZXJUeHR9OiBmZnRKb2luRXh0IFN0YXJ0OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG49IE1hdGgubWluKG5Qb2ludHMgLSBpLCBjaHVua1NpemUpO1xuXG4gICAgICAgICAgICBjb25zdCBmaXJzdENodW5rID0gRnIubXVsKGZpcnN0LCBGci5leHAoIGluYywgaSkpO1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgICAgICBjb25zdCBiMSA9IGJ1ZmYxLnNsaWNlKGkqc0luLCAoaStuKSpzSW4pO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBidWZmMi5zbGljZShpKnNJbiwgKGkrbikqc0luKTtcblxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAwLCBsZW46IHNNaWQqbn0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiU0VUXCIsIHZhcjogMCwgYnVmZjogYjF9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMSwgbGVuOiBzTWlkKm59KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIlNFVFwiLCB2YXI6IDEsIGJ1ZmY6IGIyfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDIsIGJ1ZmY6IGZpcnN0Q2h1bmt9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMywgYnVmZjogaW5jfSk7XG4gICAgICAgICAgICBpZiAoZm5JbjJNaWQpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbkluMk1pZCwgcGFyYW1zOiBbe3ZhcjowfSwge3ZhbDogbn0sIHt2YXI6IDB9XX0pO1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuSW4yTWlkLCBwYXJhbXM6IFt7dmFyOjF9LCB7dmFsOiBufSwge3ZhcjogMX1dfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5OYW1lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAzfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBGci5zfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIGlmIChmbk1pZDJPdXQpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IG59LCB7dmFyOiAwfV19KTtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MX0sIHt2YWw6IG59LCB7dmFyOiAxfV19KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBuKnNPdXR9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDEsIHZhcjogMSwgbGVuOiBuKnNPdXR9KTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKS50aGVuKCAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYCR7bG9nZ2VyVHh0fTogZmZ0Sm9pbkV4dCBFbmQ6ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDE7XG4gICAgICAgIGxldCBmdWxsQnVmZk91dDI7XG4gICAgICAgIGlmIChuUG9pbnRzICogc091dCA+IDE8PDI4KSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc091dCk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc091dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNPdXQpO1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQyID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIuc2V0KHJlc3VsdFtpXVsxXSwgcCk7XG4gICAgICAgICAgICBwKz1yZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZnVsbEJ1ZmZPdXQxLCBmdWxsQnVmZk91dDJdO1xuICAgIH1cblxuXG4gICAgRy5mZnQgPSBhc3luYyBmdW5jdGlvbihidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfZmZ0KGJ1ZmYsIGZhbHNlLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcbiAgICB9O1xuXG4gICAgRy5pZmZ0ID0gYXN5bmMgZnVuY3Rpb24oYnVmZiwgaW5UeXBlLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgX2ZmdChidWZmLCB0cnVlLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcbiAgICB9O1xuXG4gICAgRy5sYWdyYW5nZUV2YWx1YXRpb25zID0gYXN5bmMgZnVuY3Rpb24gKGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpIHtcbiAgICAgICAgaW5UeXBlID0gaW5UeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIG91dFR5cGUgPSBvdXRUeXBlIHx8IFwiYWZmaW5lXCI7XG5cbiAgICAgICAgbGV0IHNJbjtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNJbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRnJcIikge1xuICAgICAgICAgICAgc0luID0gRnIubjg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYuYnl0ZUxlbmd0aCAvc0luO1xuICAgICAgICBjb25zdCBiaXRzID0gbG9nMihuUG9pbnRzKTtcblxuICAgICAgICBpZiAoKDIgKiogYml0cykqc0luICE9IGJ1ZmYuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwibGFncmFuZ2VFdmFsdWF0aW9ucyBpaW52YWxpZCBpbnB1dCBzaXplXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGFncmFuZ2VFdmFsdWF0aW9ucyBpbnZhbGlkIElucHV0IHNpemVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0cyA8PSBGci5zKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgRy5pZmZ0KGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdHMgPiBGci5zKzEpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcImxhZ3JhbmdlRXZhbHVhdGlvbnMgaW5wdXQgdG9vIGJpZ1wiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxhZ3JhbmdlRXZhbHVhdGlvbnMgaW5wdXQgdG9vIGJpZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0MCA9IGJ1ZmYuc2xpY2UoMCwgYnVmZi5ieXRlTGVuZ3RoLzIpO1xuICAgICAgICBsZXQgdDEgPSBidWZmLnNsaWNlKGJ1ZmYuYnl0ZUxlbmd0aC8yLCBidWZmLmJ5dGVMZW5ndGgpO1xuXG5cbiAgICAgICAgY29uc3Qgc2hpZnRUb1NtYWxsTSA9IEZyLmV4cChGci5zaGlmdCwgblBvaW50cy8yKTtcbiAgICAgICAgY29uc3Qgc0NvbnN0ID0gRnIuaW52KCBGci5zdWIoRnIub25lLCBzaGlmdFRvU21hbGxNKSk7XG5cbiAgICAgICAgW3QwLCB0MV0gPSBhd2FpdCBfZmZ0Sm9pbkV4dCh0MCwgdDEsIFwicHJlcGFyZUxhZ3JhbmdlRXZhbHVhdGlvblwiLCBzQ29uc3QsIEZyLnNoaWZ0SW52LCBpblR5cGUsIFwiamFjb2JpYW5cIiwgbG9nZ2VyLCBsb2dnZXJUeHQgKyBcIiBwcmVwXCIpO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICAgICAgcHJvbWlzZXMucHVzaCggX2ZmdCh0MCwgdHJ1ZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCArIFwiIHQwXCIpKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCggX2ZmdCh0MSwgdHJ1ZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCArIFwiIHQxXCIpKTtcblxuICAgICAgICBbdDAsIHQxXSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICBsZXQgYnVmZk91dDtcbiAgICAgICAgaWYgKHQwLmJ5dGVMZW5ndGggPiAoMTw8MjgpKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcih0MC5ieXRlTGVuZ3RoKjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZk91dCA9IG5ldyBVaW50OEFycmF5KHQwLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmT3V0LnNldCh0MCk7XG4gICAgICAgIGJ1ZmZPdXQuc2V0KHQxLCB0MC5ieXRlTGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gYnVmZk91dDtcbiAgICB9O1xuXG4gICAgRy5mZnRNaXggPSBhc3luYyBmdW5jdGlvbiBmZnRNaXgoYnVmZikge1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCozO1xuICAgICAgICBsZXQgZm5OYW1lLCBmbkZGVEpvaW47XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZzFtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZzJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJGclwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImZybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZnJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuUG9pbnRzID0gTWF0aC5mbG9vcihidWZmLmJ5dGVMZW5ndGggLyBzRyk7XG4gICAgICAgIGNvbnN0IHBvd2VyID0gbG9nMihuUG9pbnRzKTtcblxuICAgICAgICBsZXQgbkNodW5rcyA9IDEgPDwgbG9nMih0bS5jb25jdXJyZW5jeSk7XG5cbiAgICAgICAgaWYgKG5Qb2ludHMgPD0gbkNodW5rcyoyKSBuQ2h1bmtzID0gMTtcblxuICAgICAgICBjb25zdCBwb2ludHNQZXJDaHVuayA9IG5Qb2ludHMgLyBuQ2h1bmtzO1xuXG4gICAgICAgIGNvbnN0IHBvd2VyQ2h1bmsgPSBsb2cyKHBvaW50c1BlckNodW5rKTtcblxuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBidWZmLnNsaWNlKChpKiBwb2ludHNQZXJDaHVuaykqc0csICgoaSsxKSogcG9pbnRzUGVyQ2h1bmspKnNHKTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYn0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0xOyBqPD1wb3dlckNodW5rOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5OYW1lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c1BlckNodW5rfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhbDogan1cbiAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDAsIGxlbjogcG9pbnRzUGVyQ2h1bmsqc0d9KTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSBjaHVua3NbaV0gPSByZXN1bHRbaV1bMF07XG5cblxuICAgICAgICBmb3IgKGxldCBpID0gcG93ZXJDaHVuaysxOyBpPD1wb3dlcjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuR3JvdXBzID0gMSA8PCAocG93ZXIgLSBpKTtcbiAgICAgICAgICAgIGNvbnN0IG5DaHVua3NQZXJHcm91cCA9IG5DaHVua3MgLyBuR3JvdXBzO1xuICAgICAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5Hcm91cHM7IGorKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGs9MDsgayA8bkNodW5rc1Blckdyb3VwLzI7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IEZyLmV4cCggRnIud1tpXSwgaypwb2ludHNQZXJDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluYyA9IEZyLndbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8xID0gaipuQ2h1bmtzUGVyR3JvdXAgKyBrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvMiA9IGoqbkNodW5rc1Blckdyb3VwICsgayArIG5DaHVua3NQZXJHcm91cC8yO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBjaHVua3NbbzFdfSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogY2h1bmtzW28yXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDIsIGJ1ZmY6IGZpcnN0fSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMywgYnVmZjogaW5jfSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkZGVEpvaW4sICBwYXJhbXM6W1xuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c1BlckNodW5rfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogM31cbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDAsIGxlbjogcG9pbnRzUGVyQ2h1bmsqc0d9KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMSwgdmFyOiAxLCBsZW46IHBvaW50c1BlckNodW5rKnNHfSk7XG4gICAgICAgICAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaCh0bS5xdWV1ZUFjdGlvbih0YXNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxuR3JvdXBzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrPTA7IGsgPG5DaHVua3NQZXJHcm91cC8yOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzEgPSBqKm5DaHVua3NQZXJHcm91cCArIGs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8yID0gaipuQ2h1bmtzUGVyR3JvdXAgKyBrICsgbkNodW5rc1Blckdyb3VwLzI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc0NodW5rID0gcmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1tvMV0gPSByZXNDaHVua1swXTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW28yXSA9IHJlc0NodW5rWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDtcbiAgICAgICAgaWYgKGJ1ZmYgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNHKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzRyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHAgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0LnNldChjaHVua3NbaV0sIHApO1xuICAgICAgICAgICAgcCs9Y2h1bmtzW2ldLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVsbEJ1ZmZPdXQ7XG4gICAgfTtcblxuICAgIEcuZmZ0Sm9pbiA9IGFzeW5jIGZ1bmN0aW9uIGZmdEpvaW4oYnVmZjEsIGJ1ZmYyLCBmaXJzdCwgaW5jKSB7XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjM7XG4gICAgICAgIGxldCBmbk5hbWU7XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9mZnRKb2luXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgZm5OYW1lID0gXCJnMm1fZmZ0Sm9pblwiO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkZyXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZnJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnVmZjEuYnl0ZUxlbmd0aCAhPSBidWZmMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ1ZmZlciBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmYxLmJ5dGVMZW5ndGggLyBzRyk7XG4gICAgICAgIGlmIChuUG9pbnRzICE9IDEgPDwgbG9nMihuUG9pbnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5DaHVua3MgPSAxIDw8IGxvZzIodG0uY29uY3VycmVuY3kpO1xuICAgICAgICBpZiAoblBvaW50cyA8PSBuQ2h1bmtzKjIpIG5DaHVua3MgPSAxO1xuXG4gICAgICAgIGNvbnN0IHBvaW50c1BlckNodW5rID0gblBvaW50cyAvIG5DaHVua3M7XG5cblxuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcblxuICAgICAgICAgICAgY29uc3QgZmlyc3RDaHVuayA9IEZyLm11bChmaXJzdCwgRnIuZXhwKGluYywgaSpwb2ludHNQZXJDaHVuaykpO1xuICAgICAgICAgICAgY29uc3QgYjEgPSBidWZmMS5zbGljZSgoaSogcG9pbnRzUGVyQ2h1bmspKnNHLCAoKGkrMSkqIHBvaW50c1BlckNodW5rKSpzRyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGJ1ZmYyLnNsaWNlKChpKiBwb2ludHNQZXJDaHVuaykqc0csICgoaSsxKSogcG9pbnRzUGVyQ2h1bmspKnNHKTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYjF9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYjJ9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMiwgYnVmZjogZmlyc3RDaHVua30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAzLCBidWZmOiBpbmN9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk5hbWUsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c1BlckNodW5rfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAzfVxuICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAwLCBsZW46IHBvaW50c1BlckNodW5rKnNHfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAxLCB2YXI6IDEsIGxlbjogcG9pbnRzUGVyQ2h1bmsqc0d9KTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICB9XG5cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgZnVsbEJ1ZmZPdXQxO1xuICAgICAgICBsZXQgZnVsbEJ1ZmZPdXQyO1xuICAgICAgICBpZiAoYnVmZjEgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0MSA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzRyk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQxID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzRyk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNHKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIuc2V0KHJlc3VsdFtpXVsxXSwgcCk7XG4gICAgICAgICAgICBwKz1yZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZnVsbEJ1ZmZPdXQxLCBmdWxsQnVmZk91dDJdO1xuICAgIH07XG5cblxuXG4gICAgRy5mZnRGaW5hbCA9ICBhc3luYyBmdW5jdGlvbiBmZnRGaW5hbChidWZmLCBmYWN0b3IpIHtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMztcbiAgICAgICAgY29uc3Qgc0dvdXQgPSBHLkYubjgqMjtcbiAgICAgICAgbGV0IGZuTmFtZSwgZm5Ub0FmZmluZTtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX2ZmdEZpbmFsXCI7XG4gICAgICAgICAgICBmblRvQWZmaW5lID0gXCJnMW1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkcyXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZzJtX2ZmdEZpbmFsXCI7XG4gICAgICAgICAgICBmblRvQWZmaW5lID0gXCJnMm1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmYuYnl0ZUxlbmd0aCAvIHNHKTtcbiAgICAgICAgaWYgKG5Qb2ludHMgIT0gMSA8PCBsb2cyKG5Qb2ludHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb2ludHNQZXJDaHVuayA9IE1hdGguZmxvb3IoblBvaW50cyAvIHRtLmNvbmN1cnJlbmN5KTtcblxuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0bS5jb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGlmIChpPCB0bS5jb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IHBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqcG9pbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobj09MCkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgICAgICBjb25zdCBiID0gYnVmZi5zbGljZSgoaSogcG9pbnRzUGVyQ2h1bmspKnNHLCAoaSpwb2ludHNQZXJDaHVuaytuKSpzRyk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJ9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogZmFjdG9yfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5OYW1lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmblRvQWZmaW5lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBuKnNHb3V0fSk7XG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgdG0ucXVldWVBY3Rpb24odGFzaylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDtcbiAgICAgICAgaWYgKGJ1ZmYgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNHb3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzR291dCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcCA9MDtcbiAgICAgICAgZm9yIChsZXQgaT1yZXN1bHQubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBwKz1yZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdWxsQnVmZk91dDtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_fft.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_multiexp.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine_multiexp.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildMultiexp)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js\");\n\n\nconst pTSizes = [\n    1 ,  1,  1,  1,    2,  3,  4,  5,\n    6 ,  7,  7,  8,    9, 10, 11, 12,\n    13, 13, 14, 15,   16, 16, 17, 17,\n    17, 17, 17, 17,   17, 17, 17, 17\n];\n\nfunction buildMultiexp(curve, groupName) {\n    const G = curve[groupName];\n    const tm = G.tm;\n    async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {\n        if ( ! (buffBases instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n        }\n        if ( ! (buffScalars instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n        }\n        inType = inType || \"affine\";\n\n        let sGIn;\n        let fnName;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                fnName = \"g1m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g1m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                fnName = \"g2m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g2m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff: buffBases},\n                {cmd: \"ALLOCSET\", var: 1, buff: buffScalars},\n                {cmd: \"ALLOC\", var: 2, len: G.F.n8*3},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {var: 1},\n                    {val: sScalar},\n                    {val: nPoints},\n                    {val: i*bitChunkSize},\n                    {val: Math.min(sScalar*8 - i*bitChunkSize, bitChunkSize)},\n                    {var: 2}\n                ]},\n                {cmd: \"GET\", out: 0, var: 2, len: G.F.n8*3}\n            ];\n            opPromises.push(\n                G.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            if (!G.isZero(res)) {\n                for (let j=0; j<bitChunkSize; j++) res = G.double(res);\n            }\n            res = G.add(res, result[i][0]);\n        }\n\n        return res;\n    }\n\n    async function _multiExp(buffBases, buffScalars, inType, logger, logText) {\n        const MAX_CHUNK_SIZE = 1 << 22;\n        const MIN_CHUNK_SIZE = 1 << 10;\n        let sGIn;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        let chunkSize;\n        chunkSize = Math.floor(nPoints / (tm.concurrency /nChunks));\n        if (chunkSize>MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n        if (chunkSize<MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n\n        const opPromises = [];\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n            const buffBasesChunk = buffBases.slice(i*sGIn, (i+n)*sGIn);\n            const buffScalarsChunk = buffScalars.slice(i*sScalar, (i+n)*sScalar);\n            opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then( (r) => {\n                if (logger) logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);\n                return r;\n            }));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            res = G.add(res, result[i]);\n        }\n\n        return res;\n    }\n\n    G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"jacobian\", logger, logText);\n    };\n    G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"affine\", logger, logText);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfbXVsdGlleHAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pELCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQywrQ0FBSTtBQUN6Qzs7QUFFQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0EsaUJBQWlCLHlDQUF5QztBQUMxRCxpQkFBaUIsMkNBQTJDO0FBQzVELGlCQUFpQixvQ0FBb0M7QUFDckQsaUJBQWlCO0FBQ2pCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixhQUFhO0FBQ2xDLHFCQUFxQixhQUFhO0FBQ2xDLHFCQUFxQixvQkFBb0I7QUFDekMscUJBQXFCLHdEQUF3RDtBQUM3RSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsK0NBQUk7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsV0FBVztBQUNqQyx3REFBd0QsUUFBUSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFFBQVEsSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUNuRjtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2VuZ2luZV9tdWx0aWV4cC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsb2cyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcblxuY29uc3QgcFRTaXplcyA9IFtcbiAgICAxICwgIDEsICAxLCAgMSwgICAgMiwgIDMsICA0LCAgNSxcbiAgICA2ICwgIDcsICA3LCAgOCwgICAgOSwgMTAsIDExLCAxMixcbiAgICAxMywgMTMsIDE0LCAxNSwgICAxNiwgMTYsIDE3LCAxNyxcbiAgICAxNywgMTcsIDE3LCAxNywgICAxNywgMTcsIDE3LCAxN1xuXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRNdWx0aWV4cChjdXJ2ZSwgZ3JvdXBOYW1lKSB7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3QgdG0gPSBHLnRtO1xuICAgIGFzeW5jIGZ1bmN0aW9uIF9tdWx0aUV4cENodW5rKGJ1ZmZCYXNlcywgYnVmZlNjYWxhcnMsIGluVHlwZSwgbG9nZ2VyLCBsb2dUZXh0KSB7XG4gICAgICAgIGlmICggISAoYnVmZkJhc2VzIGluc3RhbmNlb2YgVWludDhBcnJheSkgKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYCR7bG9nVGV4dH0gX211bHRpRXhwQ2h1bmsgYnVmZkJhc2VzIGlzIG5vdCBVaW50OEFycmF5YCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bG9nVGV4dH0gX211bHRpRXhwQ2h1bmsgYnVmZkJhc2VzIGlzIG5vdCBVaW50OEFycmF5YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhIChidWZmU2NhbGFycyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGAke2xvZ1RleHR9IF9tdWx0aUV4cENodW5rIGJ1ZmZTY2FsYXJzIGlzIG5vdCBVaW50OEFycmF5YCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bG9nVGV4dH0gX211bHRpRXhwQ2h1bmsgYnVmZlNjYWxhcnMgaXMgbm90IFVpbnQ4QXJyYXlgKTtcbiAgICAgICAgfVxuICAgICAgICBpblR5cGUgPSBpblR5cGUgfHwgXCJhZmZpbmVcIjtcblxuICAgICAgICBsZXQgc0dJbjtcbiAgICAgICAgbGV0IGZuTmFtZTtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX211bHRpZXhwQWZmaW5lX2NodW5rXCI7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9tdWx0aWV4cF9jaHVua1wiO1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcybV9tdWx0aWV4cEFmZmluZV9jaHVua1wiO1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMm1fbXVsdGlleHBfY2h1bmtcIjtcbiAgICAgICAgICAgICAgICBzR0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmZCYXNlcy5ieXRlTGVuZ3RoIC8gc0dJbik7XG5cbiAgICAgICAgaWYgKG5Qb2ludHMgPT0gMCkgcmV0dXJuIEcuemVybztcbiAgICAgICAgY29uc3Qgc1NjYWxhciA9IE1hdGguZmxvb3IoYnVmZlNjYWxhcnMuYnl0ZUxlbmd0aCAvIG5Qb2ludHMpO1xuICAgICAgICBpZiggc1NjYWxhciAqIG5Qb2ludHMgIT0gYnVmZlNjYWxhcnMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NhbGFyIHNpemUgZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiaXRDaHVua1NpemUgPSBwVFNpemVzW2xvZzIoblBvaW50cyldO1xuICAgICAgICBjb25zdCBuQ2h1bmtzID0gTWF0aC5mbG9vcigoc1NjYWxhcio4IC0gMSkgLyBiaXRDaHVua1NpemUpICsxO1xuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5DaHVua3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYnVmZkJhc2VzfSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYnVmZlNjYWxhcnN9LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IEcuRi5uOCozfSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk5hbWUsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IHNTY2FsYXJ9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBuUG9pbnRzfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhbDogaSpiaXRDaHVua1NpemV9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBNYXRoLm1pbihzU2NhbGFyKjggLSBpKmJpdENodW5rU2l6ZSwgYml0Q2h1bmtTaXplKX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDJ9XG4gICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAge2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDIsIGxlbjogRy5GLm44KjN9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIEcudG0ucXVldWVBY3Rpb24odGFzaylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgcmVzID0gRy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPXJlc3VsdC5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoIUcuaXNaZXJvKHJlcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8Yml0Q2h1bmtTaXplOyBqKyspIHJlcyA9IEcuZG91YmxlKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBHLmFkZChyZXMsIHJlc3VsdFtpXVswXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9tdWx0aUV4cChidWZmQmFzZXMsIGJ1ZmZTY2FsYXJzLCBpblR5cGUsIGxvZ2dlciwgbG9nVGV4dCkge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDEgPDwgMjI7XG4gICAgICAgIGNvbnN0IE1JTl9DSFVOS19TSVpFID0gMSA8PCAxMDtcbiAgICAgICAgbGV0IHNHSW47XG5cbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkcyXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmZCYXNlcy5ieXRlTGVuZ3RoIC8gc0dJbik7XG4gICAgICAgIGlmIChuUG9pbnRzID09IDApIHJldHVybiBHLnplcm87XG4gICAgICAgIGNvbnN0IHNTY2FsYXIgPSBNYXRoLmZsb29yKGJ1ZmZTY2FsYXJzLmJ5dGVMZW5ndGggLyBuUG9pbnRzKTtcbiAgICAgICAgaWYoIHNTY2FsYXIgKiBuUG9pbnRzICE9IGJ1ZmZTY2FsYXJzLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjYWxhciBzaXplIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYml0Q2h1bmtTaXplID0gcFRTaXplc1tsb2cyKG5Qb2ludHMpXTtcbiAgICAgICAgY29uc3QgbkNodW5rcyA9IE1hdGguZmxvb3IoKHNTY2FsYXIqOCAtIDEpIC8gYml0Q2h1bmtTaXplKSArMTtcblxuICAgICAgICBsZXQgY2h1bmtTaXplO1xuICAgICAgICBjaHVua1NpemUgPSBNYXRoLmZsb29yKG5Qb2ludHMgLyAodG0uY29uY3VycmVuY3kgL25DaHVua3MpKTtcbiAgICAgICAgaWYgKGNodW5rU2l6ZT5NQVhfQ0hVTktfU0laRSkgY2h1bmtTaXplID0gTUFYX0NIVU5LX1NJWkU7XG4gICAgICAgIGlmIChjaHVua1NpemU8TUlOX0NIVU5LX1NJWkUpIGNodW5rU2l6ZSA9IE1JTl9DSFVOS19TSVpFO1xuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYE11bHRpZXhwIHN0YXJ0OiAke2xvZ1RleHR9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG49IE1hdGgubWluKG5Qb2ludHMgLSBpLCBjaHVua1NpemUpO1xuICAgICAgICAgICAgY29uc3QgYnVmZkJhc2VzQ2h1bmsgPSBidWZmQmFzZXMuc2xpY2UoaSpzR0luLCAoaStuKSpzR0luKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZTY2FsYXJzQ2h1bmsgPSBidWZmU2NhbGFycy5zbGljZShpKnNTY2FsYXIsIChpK24pKnNTY2FsYXIpO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKF9tdWx0aUV4cENodW5rKGJ1ZmZCYXNlc0NodW5rLCBidWZmU2NhbGFyc0NodW5rLCBpblR5cGUsIGxvZ2dlciwgbG9nVGV4dCkudGhlbiggKHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYE11bHRpZXhwIGVuZDogJHtsb2dUZXh0fTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgcmVzID0gRy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPXJlc3VsdC5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICByZXMgPSBHLmFkZChyZXMsIHJlc3VsdFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIEcubXVsdGlFeHAgPSBhc3luYyBmdW5jdGlvbiBtdWx0aUV4cEFmZmluZShidWZmQmFzZXMsIGJ1ZmZTY2FsYXJzLCBsb2dnZXIsIGxvZ1RleHQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9tdWx0aUV4cChidWZmQmFzZXMsIGJ1ZmZTY2FsYXJzLCBcImphY29iaWFuXCIsIGxvZ2dlciwgbG9nVGV4dCk7XG4gICAgfTtcbiAgICBHLm11bHRpRXhwQWZmaW5lID0gYXN5bmMgZnVuY3Rpb24gbXVsdGlFeHBBZmZpbmUoYnVmZkJhc2VzLCBidWZmU2NhbGFycywgbG9nZ2VyLCBsb2dUZXh0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfbXVsdGlFeHAoYnVmZkJhc2VzLCBidWZmU2NhbGFycywgXCJhZmZpbmVcIiwgbG9nZ2VyLCBsb2dUZXh0KTtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_multiexp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_pairing.js":
/*!******************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine_pairing.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildPairing)\n/* harmony export */ });\n\nfunction buildPairing(curve) {\n    const tm = curve.tm;\n    curve.pairing = function pairing(a, b) {\n\n        tm.startSyncOp();\n        const pA = tm.allocBuff(curve.G1.toJacobian(a));\n        const pB = tm.allocBuff(curve.G2.toJacobian(b));\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports[curve.name + \"_pairing\"](pA, pB, pRes);\n\n        const res = tm.getBuff(pRes, curve.Gt.n8);\n\n        tm.endSyncOp();\n        return res;\n    };\n\n    curve.pairingEq = async function pairingEq() {\n        let  buffCt;\n        let nEqs;\n        if ((arguments.length % 2) == 1) {\n            buffCt = arguments[arguments.length-1];\n            nEqs = (arguments.length -1) /2;\n        } else {\n            buffCt = curve.Gt.one;\n            nEqs = arguments.length /2;\n        }\n\n        const opPromises = [];\n        for (let i=0; i<nEqs; i++) {\n\n            const task = [];\n\n            const g1Buff = curve.G1.toJacobian(arguments[i*2]);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: g1Buff});\n            task.push({cmd: \"ALLOC\", var: 1, len: curve.prePSize});\n\n            const g2Buff = curve.G2.toJacobian(arguments[i*2 +1]);\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: g2Buff});\n            task.push({cmd: \"ALLOC\", var: 3, len: curve.preQSize});\n\n            task.push({cmd: \"ALLOC\", var: 4, len: curve.Gt.n8});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG1\", params: [\n                {var: 0},\n                {var: 1}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG2\", params: [\n                {var: 2},\n                {var: 3}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_millerLoop\", params: [\n                {var: 1},\n                {var: 3},\n                {var: 4}\n            ]});\n\n            task.push({cmd: \"GET\", out: 0, var: 4, len: curve.Gt.n8});\n\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        tm.startSyncOp();\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports.ftm_one(pRes);\n\n        for (let i=0; i<result.length; i++) {\n            const pMR = tm.allocBuff(result[i][0]);\n            tm.instance.exports.ftm_mul(pRes, pMR, pRes);\n        }\n        tm.instance.exports[curve.name + \"_finalExponentiation\"](pRes, pRes);\n\n        const pCt = tm.allocBuff(buffCt);\n\n        const r = !!tm.instance.exports.ftm_eq(pRes, pCt);\n\n        tm.endSyncOp();\n\n        return r;\n    };\n\n    curve.prepareG1 = function(p) {\n        this.tm.startSyncOp();\n        const pP = this.tm.allocBuff(p);\n        const pPrepP = this.tm.alloc(this.prePSize);\n        this.tm.instance.exports[this.name + \"_prepareG1\"](pP, pPrepP);\n        const res = this.tm.getBuff(pPrepP, this.prePSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.prepareG2 = function(q) {\n        this.tm.startSyncOp();\n        const pQ = this.tm.allocBuff(q);\n        const pPrepQ = this.tm.alloc(this.preQSize);\n        this.tm.instance.exports[this.name + \"_prepareG2\"](pQ, pPrepQ);\n        const res = this.tm.getBuff(pPrepQ, this.preQSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.millerLoop = function(preP, preQ) {\n        this.tm.startSyncOp();\n        const pPreP = this.tm.allocBuff(preP);\n        const pPreQ = this.tm.allocBuff(preQ);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_millerLoop\"](pPreP, pPreQ, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.finalExponentiation = function(a) {\n        this.tm.startSyncOp();\n        const pA = this.tm.allocBuff(a);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_finalExponentiation\"](pA, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfcGFpcmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUNlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFFBQVE7O0FBRTlCOztBQUVBO0FBQ0EsdUJBQXVCLHNDQUFzQztBQUM3RCx1QkFBdUIsMENBQTBDOztBQUVqRTtBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0QsdUJBQXVCLDBDQUEwQzs7QUFFakUsdUJBQXVCLHVDQUF1Qzs7QUFFOUQsdUJBQXVCO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQjtBQUNqQixjQUFjOztBQUVkLHVCQUF1QjtBQUN2QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUI7QUFDakIsY0FBYzs7QUFFZCx1QkFBdUI7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCO0FBQ2pCLGNBQWM7O0FBRWQsdUJBQXVCLDZDQUE2Qzs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfcGFpcmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkUGFpcmluZyhjdXJ2ZSkge1xuICAgIGNvbnN0IHRtID0gY3VydmUudG07XG4gICAgY3VydmUucGFpcmluZyA9IGZ1bmN0aW9uIHBhaXJpbmcoYSwgYikge1xuXG4gICAgICAgIHRtLnN0YXJ0U3luY09wKCk7XG4gICAgICAgIGNvbnN0IHBBID0gdG0uYWxsb2NCdWZmKGN1cnZlLkcxLnRvSmFjb2JpYW4oYSkpO1xuICAgICAgICBjb25zdCBwQiA9IHRtLmFsbG9jQnVmZihjdXJ2ZS5HMi50b0phY29iaWFuKGIpKTtcbiAgICAgICAgY29uc3QgcFJlcyA9IHRtLmFsbG9jKGN1cnZlLkd0Lm44KTtcbiAgICAgICAgdG0uaW5zdGFuY2UuZXhwb3J0c1tjdXJ2ZS5uYW1lICsgXCJfcGFpcmluZ1wiXShwQSwgcEIsIHBSZXMpO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IHRtLmdldEJ1ZmYocFJlcywgY3VydmUuR3QubjgpO1xuXG4gICAgICAgIHRtLmVuZFN5bmNPcCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICBjdXJ2ZS5wYWlyaW5nRXEgPSBhc3luYyBmdW5jdGlvbiBwYWlyaW5nRXEoKSB7XG4gICAgICAgIGxldCAgYnVmZkN0O1xuICAgICAgICBsZXQgbkVxcztcbiAgICAgICAgaWYgKChhcmd1bWVudHMubGVuZ3RoICUgMikgPT0gMSkge1xuICAgICAgICAgICAgYnVmZkN0ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV07XG4gICAgICAgICAgICBuRXFzID0gKGFyZ3VtZW50cy5sZW5ndGggLTEpIC8yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZkN0ID0gY3VydmUuR3Qub25lO1xuICAgICAgICAgICAgbkVxcyA9IGFyZ3VtZW50cy5sZW5ndGggLzI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuRXFzOyBpKyspIHtcblxuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgICAgICBjb25zdCBnMUJ1ZmYgPSBjdXJ2ZS5HMS50b0phY29iaWFuKGFyZ3VtZW50c1tpKjJdKTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogZzFCdWZmfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDEsIGxlbjogY3VydmUucHJlUFNpemV9KTtcblxuICAgICAgICAgICAgY29uc3QgZzJCdWZmID0gY3VydmUuRzIudG9KYWNvYmlhbihhcmd1bWVudHNbaSoyICsxXSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDIsIGJ1ZmY6IGcyQnVmZn0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAzLCBsZW46IGN1cnZlLnByZVFTaXplfSk7XG5cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogNCwgbGVuOiBjdXJ2ZS5HdC5uOH0pO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogY3VydmUubmFtZSArIFwiX3ByZXBhcmVHMVwiLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAxfVxuICAgICAgICAgICAgXX0pO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogY3VydmUubmFtZSArIFwiX3ByZXBhcmVHMlwiLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAzfVxuICAgICAgICAgICAgXX0pO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogY3VydmUubmFtZSArIFwiX21pbGxlckxvb3BcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAge3ZhcjogM30sXG4gICAgICAgICAgICAgICAge3ZhcjogNH1cbiAgICAgICAgICAgIF19KTtcblxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiA0LCBsZW46IGN1cnZlLkd0Lm44fSk7XG5cbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgdG0uc3RhcnRTeW5jT3AoKTtcbiAgICAgICAgY29uc3QgcFJlcyA9IHRtLmFsbG9jKGN1cnZlLkd0Lm44KTtcbiAgICAgICAgdG0uaW5zdGFuY2UuZXhwb3J0cy5mdG1fb25lKHBSZXMpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBNUiA9IHRtLmFsbG9jQnVmZihyZXN1bHRbaV1bMF0pO1xuICAgICAgICAgICAgdG0uaW5zdGFuY2UuZXhwb3J0cy5mdG1fbXVsKHBSZXMsIHBNUiwgcFJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdG0uaW5zdGFuY2UuZXhwb3J0c1tjdXJ2ZS5uYW1lICsgXCJfZmluYWxFeHBvbmVudGlhdGlvblwiXShwUmVzLCBwUmVzKTtcblxuICAgICAgICBjb25zdCBwQ3QgPSB0bS5hbGxvY0J1ZmYoYnVmZkN0KTtcblxuICAgICAgICBjb25zdCByID0gISF0bS5pbnN0YW5jZS5leHBvcnRzLmZ0bV9lcShwUmVzLCBwQ3QpO1xuXG4gICAgICAgIHRtLmVuZFN5bmNPcCgpO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBjdXJ2ZS5wcmVwYXJlRzEgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMudG0uc3RhcnRTeW5jT3AoKTtcbiAgICAgICAgY29uc3QgcFAgPSB0aGlzLnRtLmFsbG9jQnVmZihwKTtcbiAgICAgICAgY29uc3QgcFByZXBQID0gdGhpcy50bS5hbGxvYyh0aGlzLnByZVBTaXplKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMubmFtZSArIFwiX3ByZXBhcmVHMVwiXShwUCwgcFByZXBQKTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy50bS5nZXRCdWZmKHBQcmVwUCwgdGhpcy5wcmVQU2l6ZSk7XG4gICAgICAgIHRoaXMudG0uZW5kU3luY09wKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIGN1cnZlLnByZXBhcmVHMiA9IGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgdGhpcy50bS5zdGFydFN5bmNPcCgpO1xuICAgICAgICBjb25zdCBwUSA9IHRoaXMudG0uYWxsb2NCdWZmKHEpO1xuICAgICAgICBjb25zdCBwUHJlcFEgPSB0aGlzLnRtLmFsbG9jKHRoaXMucHJlUVNpemUpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5uYW1lICsgXCJfcHJlcGFyZUcyXCJdKHBRLCBwUHJlcFEpO1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnRtLmdldEJ1ZmYocFByZXBRLCB0aGlzLnByZVFTaXplKTtcbiAgICAgICAgdGhpcy50bS5lbmRTeW5jT3AoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgY3VydmUubWlsbGVyTG9vcCA9IGZ1bmN0aW9uKHByZVAsIHByZVEpIHtcbiAgICAgICAgdGhpcy50bS5zdGFydFN5bmNPcCgpO1xuICAgICAgICBjb25zdCBwUHJlUCA9IHRoaXMudG0uYWxsb2NCdWZmKHByZVApO1xuICAgICAgICBjb25zdCBwUHJlUSA9IHRoaXMudG0uYWxsb2NCdWZmKHByZVEpO1xuICAgICAgICBjb25zdCBwUmVzID0gdGhpcy50bS5hbGxvYyh0aGlzLkd0Lm44KTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMubmFtZSArIFwiX21pbGxlckxvb3BcIl0ocFByZVAsIHBQcmVRLCBwUmVzKTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy50bS5nZXRCdWZmKHBSZXMsIHRoaXMuR3QubjgpO1xuICAgICAgICB0aGlzLnRtLmVuZFN5bmNPcCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICBjdXJ2ZS5maW5hbEV4cG9uZW50aWF0aW9uID0gZnVuY3Rpb24oYSkge1xuICAgICAgICB0aGlzLnRtLnN0YXJ0U3luY09wKCk7XG4gICAgICAgIGNvbnN0IHBBID0gdGhpcy50bS5hbGxvY0J1ZmYoYSk7XG4gICAgICAgIGNvbnN0IHBSZXMgPSB0aGlzLnRtLmFsbG9jKHRoaXMuR3QubjgpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5uYW1lICsgXCJfZmluYWxFeHBvbmVudGlhdGlvblwiXShwQSwgcFJlcyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudG0uZ2V0QnVmZihwUmVzLCB0aGlzLkd0Lm44KTtcbiAgICAgICAgdGhpcy50bS5lbmRTeW5jT3AoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_pairing.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/f1field.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/f1field.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ZqField)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _futils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./futils.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js\");\n/* harmony import */ var _fsqrt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fsqrt.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/fsqrt.js\");\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./random.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js\");\n/* harmony import */ var _fft_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fft.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/fft.js\");\n/* global BigInt */\n\n\n\n\n\n\nclass ZqField {\n    constructor(p) {\n        this.type=\"F1\";\n        this.one = BigInt(1);\n        this.zero = BigInt(0);\n        this.p = BigInt(p);\n        this.m = 1;\n        this.negone = this.p-this.one;\n        this.two = BigInt(2);\n        this.half = this.p >> this.one;\n        this.bitLength = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.bitLength(this.p);\n        this.mask = (this.one << BigInt(this.bitLength)) - this.one;\n\n        this.n64 = Math.floor((this.bitLength - 1) / 64)+1;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n        this.R = this.e(this.one << BigInt(this.n64*64));\n        this.Ri = this.inv(this.R);\n\n        const e = this.negone >> this.one;\n        this.nqr = this.two;\n        let r = this.pow(this.nqr, e);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.nqr + this.one;\n            r = this.pow(this.nqr, e);\n        }\n\n\n        this.s = 0;\n        this.t = this.negone;\n\n        while ((this.t & this.one) == this.zero) {\n            this.s = this.s + 1;\n            this.t = this.t >> this.one;\n        }\n\n        this.nqr_to_t = this.pow(this.nqr, this.t);\n\n        (0,_fsqrt_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this);\n\n        this.FFT = new _fft_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this, this, this.mul.bind(this));\n\n        this.fft = this.FFT.fft.bind(this.FFT);\n        this.ifft = this.FFT.ifft.bind(this.FFT);\n        this.w = this.FFT.w;\n        this.wi = this.FFT.wi; \n    \n        this.shift = this.square(this.nqr);\n        this.k = this.exp(this.nqr, 2**this.s);\n    }\n\n    e(a,b) {\n        let res;\n        if (!b) {\n            res = BigInt(a);\n        } else if (b==16) {\n            res = BigInt(\"0x\"+a);\n        }\n        if (res < 0) {\n            let nres = -res;\n            if (nres >= this.p) nres = nres % this.p;\n            return this.p - nres;\n        } else {\n            return (res>= this.p) ? res%this.p : res;\n        }\n\n    }\n\n    add(a, b) {\n        const res = a + b;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    sub(a, b) {\n        return (a >= b) ? a-b : this.p-b+a;\n    }\n\n    neg(a) {\n        return a ? this.p-a : a;\n    }\n\n    mul(a, b) {\n        return (a*b)%this.p;\n    }\n\n    mulScalar(base, s) {\n        return (base * this.e(s)) % this.p;\n    }\n\n    square(a) {\n        return (a*a) % this.p;\n    }\n\n    eq(a, b) {\n        return a==b;\n    }\n\n    neq(a, b) {\n        return a!=b;\n    }\n\n    lt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa < bb;\n    }\n\n    gt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa > bb;\n    }\n\n    leq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa <= bb;\n    }\n\n    geq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa >= bb;\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    idiv(a, b) {\n        if (!b) throw new Error(\"Division by zero\");\n        return a / b;\n    }\n\n    inv(a) {\n        if (!a) throw new Error(\"Division by zero\");\n\n        let t = this.zero;\n        let r = this.p;\n        let newt = this.one;\n        let newr = a % this.p;\n        while (newr) {\n            let q = r/newr;\n            [t, newt] = [newt, t-q*newt];\n            [r, newr] = [newr, r-q*newr];\n        }\n        if (t<this.zero) t += this.p;\n        return t;\n    }\n\n    mod(a, b) {\n        return a % b;\n    }\n\n    pow(b, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_1__.exp(this, b, e);\n    }\n\n    exp(b, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_1__.exp(this, b, e);\n    }\n\n    band(a, b) {\n        const res =  ((a & b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bor(a, b) {\n        const res =  ((a | b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bxor(a, b) {\n        const res =  ((a ^ b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bnot(a) {\n        const res = a ^ this.mask;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    shl(a, b) {\n        if (Number(b) < this.bitLength) {\n            const res = (a << b) & this.mask;\n            return res >= this.p ? res-this.p : res;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                return a >> nb;\n            } else {\n                return this.zero;\n            }\n        }\n    }\n\n    shr(a, b) {\n        if (Number(b) < this.bitLength) {\n            return a >> b;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                const res = (a << nb) & this.mask;\n                return res >= this.p ? res-this.p : res;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    land(a, b) {\n        return (a && b) ? this.one : this.zero;\n    }\n\n    lor(a, b) {\n        return (a || b) ? this.one : this.zero;\n    }\n\n    lnot(a) {\n        return (a) ? this.zero : this.one;\n    }\n\n    sqrt_old(n) {\n\n        if (n == this.zero) return this.zero;\n\n        // Test that have solution\n        const res = this.pow(n, this.negone >> this.one);\n        if ( res != this.one ) return null;\n\n        let m = this.s;\n        let c = this.nqr_to_t;\n        let t = this.pow(n, this.t);\n        let r = this.pow(n, this.add(this.t, this.one) >> this.one );\n\n        while ( t != this.one ) {\n            let sq = this.square(t);\n            let i = 1;\n            while (sq != this.one ) {\n                i++;\n                sq = this.square(sq);\n            }\n\n            // b = c ^ m-i-1\n            let b = c;\n            for (let j=0; j< m-i-1; j ++) b = this.square(b);\n\n            m = i;\n            c = this.square(b);\n            t = this.mul(t, c);\n            r = this.mul(r, b);\n        }\n\n        if (r > (this.p >> this.one)) {\n            r = this.neg(r);\n        }\n\n        return r;\n    }\n\n    normalize(a, b) {\n        a = BigInt(a,b);\n        if (a < 0) {\n            let na = -a;\n            if (na >= this.p) na = na % this.p;\n            return this.p - na;\n        } else {\n            return (a>= this.p) ? a%this.p : a;\n        }\n    }\n\n    random() {\n        const nBytes = (this.bitLength*2 / 8);\n        let res =this.zero;\n        for (let i=0; i<nBytes; i++) {\n            res = (res << BigInt(8)) + BigInt((0,_random_js__WEBPACK_IMPORTED_MODULE_3__.getRandomBytes)(1)[0]);\n        }\n        return res % this.p;\n    }\n\n    toString(a, base) {\n        base = base || 10;\n        let vs;\n        if ((a > this.half)&&(base == 10)) {\n            const v = this.p-a;\n            vs = \"-\"+v.toString(base);\n        } else {\n            vs = a.toString(base);\n        }\n        return vs;\n    }\n\n    isZero(a) {\n        return a == this.zero;\n    }\n\n    fromRng(rng) {\n        let v;\n        do {\n            v=this.zero;\n            for (let i=0; i<this.n64; i++) {\n                v += rng.nextU64() << BigInt(64 *i);\n            }\n            v &= this.mask;\n        } while (v >= this.p);\n        v = (v * this.Ri) % this.p;   // Convert from montgomery\n        return v;\n    }\n\n    fft(a) {\n        return this.FFT.fft(a);\n    }\n\n    ifft(a) {\n        return this.FFT.ifft(a);\n    }\n\n    // Returns a buffer with Little Endian Representation\n    toRprLE(buff, o, e) {\n        _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toRprLE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Representation\n    toRprBE(buff, o, e) {\n        _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toRprBE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Montgomery Representation\n    toRprBEM(buff, o, e) {\n        return this.toRprBE(buff, o, this.mul(this.R, e));\n    }\n\n    toRprLEM(buff, o, e) {\n        return this.toRprLE(buff, o, this.mul(this.R, e));\n    }\n\n\n    // Pases a buffer with Little Endian Representation\n    fromRprLE(buff, o) {\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.fromRprLE(buff, o, this.n8);\n    }\n\n    // Pases a buffer with Big Endian Representation\n    fromRprBE(buff, o) {\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.fromRprBE(buff, o, this.n8);\n    }\n\n    fromRprLEM(buff, o) {\n        return this.mul(this.fromRprLE(buff, o), this.Ri);\n    }\n\n    fromRprBEM(buff, o) {\n        return this.mul(this.fromRprBE(buff, o), this.Ri);\n    }\n\n    toObject(a) {\n        return a;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mMWZpZWxkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ3NDO0FBQ0E7QUFDSDtBQUNRO0FBQ2Y7O0FBRWI7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxxREFBUzs7QUFFakIsdUJBQXVCLCtDQUFJOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDJDQUFVO0FBQ3pCOztBQUVBO0FBQ0EsZUFBZSwyQ0FBVTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQyw4Q0FBOEMsMERBQWM7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBYztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBYztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxlQUFlLGlEQUFnQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxpREFBZ0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2YxZmllbGQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIEJpZ0ludCAqL1xuaW1wb3J0ICogYXMgU2NhbGFyIGZyb20gXCIuL3NjYWxhci5qc1wiO1xuaW1wb3J0ICogYXMgZnV0aWxzIGZyb20gXCIuL2Z1dGlscy5qc1wiO1xuaW1wb3J0IGJ1aWxkU3FydCBmcm9tIFwiLi9mc3FydC5qc1wiO1xuaW1wb3J0IHtnZXRSYW5kb21CeXRlc30gZnJvbSBcIi4vcmFuZG9tLmpzXCI7XG5pbXBvcnQgRkZGVCBmcm9tIFwiLi9mZnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWnFGaWVsZCB7XG4gICAgY29uc3RydWN0b3IocCkge1xuICAgICAgICB0aGlzLnR5cGU9XCJGMVwiO1xuICAgICAgICB0aGlzLm9uZSA9IEJpZ0ludCgxKTtcbiAgICAgICAgdGhpcy56ZXJvID0gQmlnSW50KDApO1xuICAgICAgICB0aGlzLnAgPSBCaWdJbnQocCk7XG4gICAgICAgIHRoaXMubSA9IDE7XG4gICAgICAgIHRoaXMubmVnb25lID0gdGhpcy5wLXRoaXMub25lO1xuICAgICAgICB0aGlzLnR3byA9IEJpZ0ludCgyKTtcbiAgICAgICAgdGhpcy5oYWxmID0gdGhpcy5wID4+IHRoaXMub25lO1xuICAgICAgICB0aGlzLmJpdExlbmd0aCA9IFNjYWxhci5iaXRMZW5ndGgodGhpcy5wKTtcbiAgICAgICAgdGhpcy5tYXNrID0gKHRoaXMub25lIDw8IEJpZ0ludCh0aGlzLmJpdExlbmd0aCkpIC0gdGhpcy5vbmU7XG5cbiAgICAgICAgdGhpcy5uNjQgPSBNYXRoLmZsb29yKCh0aGlzLmJpdExlbmd0aCAtIDEpIC8gNjQpKzE7XG4gICAgICAgIHRoaXMubjMyID0gdGhpcy5uNjQqMjtcbiAgICAgICAgdGhpcy5uOCA9IHRoaXMubjY0Kjg7XG4gICAgICAgIHRoaXMuUiA9IHRoaXMuZSh0aGlzLm9uZSA8PCBCaWdJbnQodGhpcy5uNjQqNjQpKTtcbiAgICAgICAgdGhpcy5SaSA9IHRoaXMuaW52KHRoaXMuUik7XG5cbiAgICAgICAgY29uc3QgZSA9IHRoaXMubmVnb25lID4+IHRoaXMub25lO1xuICAgICAgICB0aGlzLm5xciA9IHRoaXMudHdvO1xuICAgICAgICBsZXQgciA9IHRoaXMucG93KHRoaXMubnFyLCBlKTtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmVxKHIsIHRoaXMubmVnb25lKSkge1xuICAgICAgICAgICAgdGhpcy5ucXIgPSB0aGlzLm5xciArIHRoaXMub25lO1xuICAgICAgICAgICAgciA9IHRoaXMucG93KHRoaXMubnFyLCBlKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5zID0gMDtcbiAgICAgICAgdGhpcy50ID0gdGhpcy5uZWdvbmU7XG5cbiAgICAgICAgd2hpbGUgKCh0aGlzLnQgJiB0aGlzLm9uZSkgPT0gdGhpcy56ZXJvKSB7XG4gICAgICAgICAgICB0aGlzLnMgPSB0aGlzLnMgKyAxO1xuICAgICAgICAgICAgdGhpcy50ID0gdGhpcy50ID4+IHRoaXMub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ucXJfdG9fdCA9IHRoaXMucG93KHRoaXMubnFyLCB0aGlzLnQpO1xuXG4gICAgICAgIGJ1aWxkU3FydCh0aGlzKTtcblxuICAgICAgICB0aGlzLkZGVCA9IG5ldyBGRkZUKHRoaXMsIHRoaXMsIHRoaXMubXVsLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuZmZ0ID0gdGhpcy5GRlQuZmZ0LmJpbmQodGhpcy5GRlQpO1xuICAgICAgICB0aGlzLmlmZnQgPSB0aGlzLkZGVC5pZmZ0LmJpbmQodGhpcy5GRlQpO1xuICAgICAgICB0aGlzLncgPSB0aGlzLkZGVC53O1xuICAgICAgICB0aGlzLndpID0gdGhpcy5GRlQud2k7IFxuICAgIFxuICAgICAgICB0aGlzLnNoaWZ0ID0gdGhpcy5zcXVhcmUodGhpcy5ucXIpO1xuICAgICAgICB0aGlzLmsgPSB0aGlzLmV4cCh0aGlzLm5xciwgMioqdGhpcy5zKTtcbiAgICB9XG5cbiAgICBlKGEsYikge1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgIHJlcyA9IEJpZ0ludChhKTtcbiAgICAgICAgfSBlbHNlIGlmIChiPT0xNikge1xuICAgICAgICAgICAgcmVzID0gQmlnSW50KFwiMHhcIithKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzIDwgMCkge1xuICAgICAgICAgICAgbGV0IG5yZXMgPSAtcmVzO1xuICAgICAgICAgICAgaWYgKG5yZXMgPj0gdGhpcy5wKSBucmVzID0gbnJlcyAlIHRoaXMucDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnAgLSBucmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChyZXM+PSB0aGlzLnApID8gcmVzJXRoaXMucCA6IHJlcztcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYWRkKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYSArIGI7XG4gICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5wID8gcmVzLXRoaXMucCA6IHJlcztcbiAgICB9XG5cbiAgICBzdWIoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgPj0gYikgPyBhLWIgOiB0aGlzLnAtYithO1xuICAgIH1cblxuICAgIG5lZyhhKSB7XG4gICAgICAgIHJldHVybiBhID8gdGhpcy5wLWEgOiBhO1xuICAgIH1cblxuICAgIG11bChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYSpiKSV0aGlzLnA7XG4gICAgfVxuXG4gICAgbXVsU2NhbGFyKGJhc2UsIHMpIHtcbiAgICAgICAgcmV0dXJuIChiYXNlICogdGhpcy5lKHMpKSAlIHRoaXMucDtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gKGEqYSkgJSB0aGlzLnA7XG4gICAgfVxuXG4gICAgZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gYT09YjtcbiAgICB9XG5cbiAgICBuZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gYSE9YjtcbiAgICB9XG5cbiAgICBsdChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFhID0gKGEgPiB0aGlzLmhhbGYpID8gYSAtIHRoaXMucCA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gKGIgPiB0aGlzLmhhbGYpID8gYiAtIHRoaXMucCA6IGI7XG4gICAgICAgIHJldHVybiBhYSA8IGJiO1xuICAgIH1cblxuICAgIGd0KGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWEgPSAoYSA+IHRoaXMuaGFsZikgPyBhIC0gdGhpcy5wIDogYTtcbiAgICAgICAgY29uc3QgYmIgPSAoYiA+IHRoaXMuaGFsZikgPyBiIC0gdGhpcy5wIDogYjtcbiAgICAgICAgcmV0dXJuIGFhID4gYmI7XG4gICAgfVxuXG4gICAgbGVxKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWEgPSAoYSA+IHRoaXMuaGFsZikgPyBhIC0gdGhpcy5wIDogYTtcbiAgICAgICAgY29uc3QgYmIgPSAoYiA+IHRoaXMuaGFsZikgPyBiIC0gdGhpcy5wIDogYjtcbiAgICAgICAgcmV0dXJuIGFhIDw9IGJiO1xuICAgIH1cblxuICAgIGdlcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFhID0gKGEgPiB0aGlzLmhhbGYpID8gYSAtIHRoaXMucCA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gKGIgPiB0aGlzLmhhbGYpID8gYiAtIHRoaXMucCA6IGI7XG4gICAgICAgIHJldHVybiBhYSA+PSBiYjtcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgdGhpcy5pbnYoYikpO1xuICAgIH1cblxuICAgIGlkaXYoYSwgYikge1xuICAgICAgICBpZiAoIWIpIHRocm93IG5ldyBFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm9cIik7XG4gICAgICAgIHJldHVybiBhIC8gYjtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICBpZiAoIWEpIHRocm93IG5ldyBFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm9cIik7XG5cbiAgICAgICAgbGV0IHQgPSB0aGlzLnplcm87XG4gICAgICAgIGxldCByID0gdGhpcy5wO1xuICAgICAgICBsZXQgbmV3dCA9IHRoaXMub25lO1xuICAgICAgICBsZXQgbmV3ciA9IGEgJSB0aGlzLnA7XG4gICAgICAgIHdoaWxlIChuZXdyKSB7XG4gICAgICAgICAgICBsZXQgcSA9IHIvbmV3cjtcbiAgICAgICAgICAgIFt0LCBuZXd0XSA9IFtuZXd0LCB0LXEqbmV3dF07XG4gICAgICAgICAgICBbciwgbmV3cl0gPSBbbmV3ciwgci1xKm5ld3JdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0PHRoaXMuemVybykgdCArPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIG1vZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICUgYjtcbiAgICB9XG5cbiAgICBwb3coYiwgZSkge1xuICAgICAgICByZXR1cm4gZnV0aWxzLmV4cCh0aGlzLCBiLCBlKTtcbiAgICB9XG5cbiAgICBleHAoYiwgZSkge1xuICAgICAgICByZXR1cm4gZnV0aWxzLmV4cCh0aGlzLCBiLCBlKTtcbiAgICB9XG5cbiAgICBiYW5kKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gICgoYSAmIGIpICYgdGhpcy5tYXNrKTtcbiAgICAgICAgcmV0dXJuIHJlcyA+PSB0aGlzLnAgPyByZXMtdGhpcy5wIDogcmVzO1xuICAgIH1cblxuICAgIGJvcihhLCBiKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9ICAoKGEgfCBiKSAmIHRoaXMubWFzayk7XG4gICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5wID8gcmVzLXRoaXMucCA6IHJlcztcbiAgICB9XG5cbiAgICBieG9yKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gICgoYSBeIGIpICYgdGhpcy5tYXNrKTtcbiAgICAgICAgcmV0dXJuIHJlcyA+PSB0aGlzLnAgPyByZXMtdGhpcy5wIDogcmVzO1xuICAgIH1cblxuICAgIGJub3QoYSkge1xuICAgICAgICBjb25zdCByZXMgPSBhIF4gdGhpcy5tYXNrO1xuICAgICAgICByZXR1cm4gcmVzID49IHRoaXMucCA/IHJlcy10aGlzLnAgOiByZXM7XG4gICAgfVxuXG4gICAgc2hsKGEsIGIpIHtcbiAgICAgICAgaWYgKE51bWJlcihiKSA8IHRoaXMuYml0TGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSAoYSA8PCBiKSAmIHRoaXMubWFzaztcbiAgICAgICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5wID8gcmVzLXRoaXMucCA6IHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5iID0gdGhpcy5wIC0gYjtcbiAgICAgICAgICAgIGlmIChOdW1iZXIobmIpIDwgdGhpcy5iaXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA+PiBuYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNocihhLCBiKSB7XG4gICAgICAgIGlmIChOdW1iZXIoYikgPCB0aGlzLmJpdExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGEgPj4gYjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5iID0gdGhpcy5wIC0gYjtcbiAgICAgICAgICAgIGlmIChOdW1iZXIobmIpIDwgdGhpcy5iaXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSAoYSA8PCBuYikgJiB0aGlzLm1hc2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcyA+PSB0aGlzLnAgPyByZXMtdGhpcy5wIDogcmVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxhbmQoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgJiYgYikgPyB0aGlzLm9uZSA6IHRoaXMuemVybztcbiAgICB9XG5cbiAgICBsb3IoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgfHwgYikgPyB0aGlzLm9uZSA6IHRoaXMuemVybztcbiAgICB9XG5cbiAgICBsbm90KGEpIHtcbiAgICAgICAgcmV0dXJuIChhKSA/IHRoaXMuemVybyA6IHRoaXMub25lO1xuICAgIH1cblxuICAgIHNxcnRfb2xkKG4pIHtcblxuICAgICAgICBpZiAobiA9PSB0aGlzLnplcm8pIHJldHVybiB0aGlzLnplcm87XG5cbiAgICAgICAgLy8gVGVzdCB0aGF0IGhhdmUgc29sdXRpb25cbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5wb3cobiwgdGhpcy5uZWdvbmUgPj4gdGhpcy5vbmUpO1xuICAgICAgICBpZiAoIHJlcyAhPSB0aGlzLm9uZSApIHJldHVybiBudWxsO1xuXG4gICAgICAgIGxldCBtID0gdGhpcy5zO1xuICAgICAgICBsZXQgYyA9IHRoaXMubnFyX3RvX3Q7XG4gICAgICAgIGxldCB0ID0gdGhpcy5wb3cobiwgdGhpcy50KTtcbiAgICAgICAgbGV0IHIgPSB0aGlzLnBvdyhuLCB0aGlzLmFkZCh0aGlzLnQsIHRoaXMub25lKSA+PiB0aGlzLm9uZSApO1xuXG4gICAgICAgIHdoaWxlICggdCAhPSB0aGlzLm9uZSApIHtcbiAgICAgICAgICAgIGxldCBzcSA9IHRoaXMuc3F1YXJlKHQpO1xuICAgICAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICAgICAgd2hpbGUgKHNxICE9IHRoaXMub25lICkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBzcSA9IHRoaXMuc3F1YXJlKHNxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYiA9IGMgXiBtLWktMVxuICAgICAgICAgICAgbGV0IGIgPSBjO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPCBtLWktMTsgaiArKykgYiA9IHRoaXMuc3F1YXJlKGIpO1xuXG4gICAgICAgICAgICBtID0gaTtcbiAgICAgICAgICAgIGMgPSB0aGlzLnNxdWFyZShiKTtcbiAgICAgICAgICAgIHQgPSB0aGlzLm11bCh0LCBjKTtcbiAgICAgICAgICAgIHIgPSB0aGlzLm11bChyLCBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyID4gKHRoaXMucCA+PiB0aGlzLm9uZSkpIHtcbiAgICAgICAgICAgIHIgPSB0aGlzLm5lZyhyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZShhLCBiKSB7XG4gICAgICAgIGEgPSBCaWdJbnQoYSxiKTtcbiAgICAgICAgaWYgKGEgPCAwKSB7XG4gICAgICAgICAgICBsZXQgbmEgPSAtYTtcbiAgICAgICAgICAgIGlmIChuYSA+PSB0aGlzLnApIG5hID0gbmEgJSB0aGlzLnA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wIC0gbmE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKGE+PSB0aGlzLnApID8gYSV0aGlzLnAgOiBhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmFuZG9tKCkge1xuICAgICAgICBjb25zdCBuQnl0ZXMgPSAodGhpcy5iaXRMZW5ndGgqMiAvIDgpO1xuICAgICAgICBsZXQgcmVzID10aGlzLnplcm87XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCBCaWdJbnQoOCkpICsgQmlnSW50KGdldFJhbmRvbUJ5dGVzKDEpWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzICUgdGhpcy5wO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKGEsIGJhc2UpIHtcbiAgICAgICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgICAgIGxldCB2cztcbiAgICAgICAgaWYgKChhID4gdGhpcy5oYWxmKSYmKGJhc2UgPT0gMTApKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy5wLWE7XG4gICAgICAgICAgICB2cyA9IFwiLVwiK3YudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2cyA9IGEudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZzO1xuICAgIH1cblxuICAgIGlzWmVybyhhKSB7XG4gICAgICAgIHJldHVybiBhID09IHRoaXMuemVybztcbiAgICB9XG5cbiAgICBmcm9tUm5nKHJuZykge1xuICAgICAgICBsZXQgdjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdj10aGlzLnplcm87XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5uNjQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHYgKz0gcm5nLm5leHRVNjQoKSA8PCBCaWdJbnQoNjQgKmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdiAmPSB0aGlzLm1hc2s7XG4gICAgICAgIH0gd2hpbGUgKHYgPj0gdGhpcy5wKTtcbiAgICAgICAgdiA9ICh2ICogdGhpcy5SaSkgJSB0aGlzLnA7ICAgLy8gQ29udmVydCBmcm9tIG1vbnRnb21lcnlcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgZmZ0KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRkZULmZmdChhKTtcbiAgICB9XG5cbiAgICBpZmZ0KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRkZULmlmZnQoYSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIExpdHRsZSBFbmRpYW4gUmVwcmVzZW50YXRpb25cbiAgICB0b1JwckxFKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgU2NhbGFyLnRvUnByTEUoYnVmZiwgbywgZSwgdGhpcy5uNjQqOCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gUmVwcmVzZW50YXRpb25cbiAgICB0b1JwckJFKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgU2NhbGFyLnRvUnByQkUoYnVmZiwgbywgZSwgdGhpcy5uNjQqOCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gTW9udGdvbWVyeSBSZXByZXNlbnRhdGlvblxuICAgIHRvUnByQkVNKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9ScHJCRShidWZmLCBvLCB0aGlzLm11bCh0aGlzLlIsIGUpKTtcbiAgICB9XG5cbiAgICB0b1JwckxFTShidWZmLCBvLCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUnByTEUoYnVmZiwgbywgdGhpcy5tdWwodGhpcy5SLCBlKSk7XG4gICAgfVxuXG5cbiAgICAvLyBQYXNlcyBhIGJ1ZmZlciB3aXRoIExpdHRsZSBFbmRpYW4gUmVwcmVzZW50YXRpb25cbiAgICBmcm9tUnByTEUoYnVmZiwgbykge1xuICAgICAgICByZXR1cm4gU2NhbGFyLmZyb21ScHJMRShidWZmLCBvLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICAvLyBQYXNlcyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gUmVwcmVzZW50YXRpb25cbiAgICBmcm9tUnByQkUoYnVmZiwgbykge1xuICAgICAgICByZXR1cm4gU2NhbGFyLmZyb21ScHJCRShidWZmLCBvLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKHRoaXMuZnJvbVJwckxFKGJ1ZmYsIG8pLCB0aGlzLlJpKTtcbiAgICB9XG5cbiAgICBmcm9tUnByQkVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKHRoaXMuZnJvbVJwckJFKGJ1ZmYsIG8pLCB0aGlzLlJpKTtcbiAgICB9XG5cbiAgICB0b09iamVjdChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/f1field.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/f2field.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/f2field.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ F2Field)\n/* harmony export */ });\n/* harmony import */ var _futils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./futils.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js\");\n/* harmony import */ var _fsqrt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fsqrt.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/fsqrt.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nclass F2Field {\n    constructor(F, nonResidue) {\n        this.type=\"F2\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*2;\n        this.p = F.p;\n        this.n64 = F.n64*2;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n\n        (0,_fsqrt_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this);\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    conjugate(a) {\n        return [\n            a[0],\n            this.F.neg(a[1])\n        ];\n    }\n\n    mul(a, b) {\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n\n        return [\n            this.F.add( aA , this._mulByNonResidue(bB)),\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]),\n                    this.F.add(b[0], b[1])),\n                this.F.add(aA, bB))];\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);\n        const t1 = this.F.square(a[1]);\n        const t2 = this.F.sub(t0, this._mulByNonResidue(t1));\n        const t3 = this.F.inv(t2);\n        return [\n            this.F.mul(a[0], t3),\n            this.F.neg(this.F.mul( a[1], t3)) ];\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const ab = this.F.mul(a[0] , a[1]);\n\n        /*\n        [\n            (a + b) * (a + non_residue * b) - ab - non_residue * ab,\n            ab + ab\n        ];\n        */\n\n        return [\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]) ,\n                    this.F.add(\n                        a[0] ,\n                        this._mulByNonResidue(a[1]))),\n                this.F.add(\n                    ab,\n                    this._mulByNonResidue(ab))),\n            this.F.add(ab, ab)\n        ];\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]);\n    }\n\n    mulScalar(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        return [c0, c1];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        return false;\n    }\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBE(buff, o);\n        const c0 = this.F.fromRprBE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBEM(buff, o);\n        const c0 = this.F.fromRprBEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    toObject(a) {\n        return a;\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mMmZpZWxkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXNDO0FBQ0g7O0FBRXBCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEscURBQVM7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsaURBQWdCO0FBQy9COztBQUVBO0FBQ0EsZUFBZSwyQ0FBVTtBQUN6Qjs7QUFFQTtBQUNBLGVBQWUsMkNBQVU7QUFDekI7O0FBRUE7QUFDQSxvQkFBb0IsdUJBQXVCLElBQUksdUJBQXVCO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvZjJmaWVsZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBmVXRpbHMgZnJvbSBcIi4vZnV0aWxzLmpzXCI7XG5pbXBvcnQgYnVpbGRTcXJ0IGZyb20gXCIuL2ZzcXJ0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEYyRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKEYsIG5vblJlc2lkdWUpIHtcbiAgICAgICAgdGhpcy50eXBlPVwiRjJcIjtcbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy56ZXJvID0gW3RoaXMuRi56ZXJvLCB0aGlzLkYuemVyb107XG4gICAgICAgIHRoaXMub25lID0gW3RoaXMuRi5vbmUsIHRoaXMuRi56ZXJvXTtcbiAgICAgICAgdGhpcy5uZWdvbmUgPSB0aGlzLm5lZyh0aGlzLm9uZSk7XG4gICAgICAgIHRoaXMubm9uUmVzaWR1ZSA9IG5vblJlc2lkdWU7XG4gICAgICAgIHRoaXMubSA9IEYubSoyO1xuICAgICAgICB0aGlzLnAgPSBGLnA7XG4gICAgICAgIHRoaXMubjY0ID0gRi5uNjQqMjtcbiAgICAgICAgdGhpcy5uMzIgPSB0aGlzLm42NCoyO1xuICAgICAgICB0aGlzLm44ID0gdGhpcy5uNjQqODtcblxuICAgICAgICBidWlsZFNxcnQodGhpcyk7XG4gICAgfVxuXG4gICAgX211bEJ5Tm9uUmVzaWR1ZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYubXVsKHRoaXMubm9uUmVzaWR1ZSwgYSk7XG4gICAgfVxuXG4gICAgY29weShhKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5GLmNvcHkoYVswXSksIHRoaXMuRi5jb3B5KGFbMV0pXTtcbiAgICB9XG5cbiAgICBhZGQoYSwgYikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5GLmFkZChhWzBdLCBiWzBdKSxcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoYVsxXSwgYlsxXSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBkb3VibGUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYSxhKTtcbiAgICB9XG5cbiAgICBzdWIoYSwgYikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5GLnN1YihhWzBdLCBiWzBdKSxcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoYVsxXSwgYlsxXSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBuZWcoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy56ZXJvLCBhKTtcbiAgICB9XG5cbiAgICBjb25qdWdhdGUoYSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYVswXSxcbiAgICAgICAgICAgIHRoaXMuRi5uZWcoYVsxXSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBtdWwoYSwgYikge1xuICAgICAgICBjb25zdCBhQSA9IHRoaXMuRi5tdWwoYVswXSAsIGJbMF0pO1xuICAgICAgICBjb25zdCBiQiA9IHRoaXMuRi5tdWwoYVsxXSAsIGJbMV0pO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuYWRkKCBhQSAsIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZShiQikpLFxuICAgICAgICAgICAgdGhpcy5GLnN1YihcbiAgICAgICAgICAgICAgICB0aGlzLkYubXVsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFbMF0sIGFbMV0pLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGJbMF0sIGJbMV0pKSxcbiAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFBLCBiQikpXTtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICBjb25zdCB0MCA9IHRoaXMuRi5zcXVhcmUoYVswXSk7XG4gICAgICAgIGNvbnN0IHQxID0gdGhpcy5GLnNxdWFyZShhWzFdKTtcbiAgICAgICAgY29uc3QgdDIgPSB0aGlzLkYuc3ViKHQwLCB0aGlzLl9tdWxCeU5vblJlc2lkdWUodDEpKTtcbiAgICAgICAgY29uc3QgdDMgPSB0aGlzLkYuaW52KHQyKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5tdWwoYVswXSwgdDMpLFxuICAgICAgICAgICAgdGhpcy5GLm5lZyh0aGlzLkYubXVsKCBhWzFdLCB0MykpIF07XG4gICAgfVxuXG4gICAgZGl2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKGEsIHRoaXMuaW52KGIpKTtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICBjb25zdCBhYiA9IHRoaXMuRi5tdWwoYVswXSAsIGFbMV0pO1xuXG4gICAgICAgIC8qXG4gICAgICAgIFtcbiAgICAgICAgICAgIChhICsgYikgKiAoYSArIG5vbl9yZXNpZHVlICogYikgLSBhYiAtIG5vbl9yZXNpZHVlICogYWIsXG4gICAgICAgICAgICBhYiArIGFiXG4gICAgICAgIF07XG4gICAgICAgICovXG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoXG4gICAgICAgICAgICAgICAgdGhpcy5GLm11bChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhWzBdLCBhWzFdKSAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBhWzBdICxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZShhWzFdKSkpLFxuICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgICAgIGFiLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tdWxCeU5vblJlc2lkdWUoYWIpKSksXG4gICAgICAgICAgICB0aGlzLkYuYWRkKGFiLCBhYilcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5GLmlzWmVybyhhWzBdKSAmJiB0aGlzLkYuaXNaZXJvKGFbMV0pO1xuICAgIH1cblxuICAgIGVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRi5lcShhWzBdLCBiWzBdKSAmJiB0aGlzLkYuZXEoYVsxXSwgYlsxXSk7XG4gICAgfVxuXG4gICAgbXVsU2NhbGFyKGJhc2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIGZVdGlscy5tdWxTY2FsYXIodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgcG93KGJhc2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIGZVdGlscy5leHAodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgZXhwKGJhc2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIGZVdGlscy5leHAodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoYSkge1xuICAgICAgICByZXR1cm4gYFsgJHt0aGlzLkYudG9TdHJpbmcoYVswXSl9ICwgJHt0aGlzLkYudG9TdHJpbmcoYVsxXSl9IF1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMV07XG4gICAgfVxuXG4gICAgZ3QoYSwgYikge1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMF0sIGJbMF0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChiWzBdLCBhWzBdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMV0sIGJbMV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGdlcShhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmd0KGEsIGIpIHx8IHRoaXMuZXEoYSwgYik7XG4gICAgfVxuXG4gICAgbHQoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZ2VxKGEsYik7XG4gICAgfVxuXG4gICAgbGVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmd0KGEsYik7XG4gICAgfVxuXG4gICAgbmVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVxKGEsYik7XG4gICAgfVxuXG4gICAgcmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuRi5yYW5kb20oKSwgdGhpcy5GLnJhbmRvbSgpXTtcbiAgICB9XG5cblxuICAgIHRvUnByTEUoYnVmZiwgbywgZSkge1xuICAgICAgICB0aGlzLkYudG9ScHJMRShidWZmLCBvLCBlWzBdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbyt0aGlzLkYubjgsIGVbMV0pO1xuICAgIH1cblxuICAgIHRvUnByQkUoYnVmZiwgbywgZSkge1xuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvLCBlWzFdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkUoYnVmZiwgbyt0aGlzLkYubjgsIGVbMF0pO1xuICAgIH1cblxuICAgIHRvUnByTEVNKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8sIGVbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgsIGVbMV0pO1xuICAgIH1cblxuXG4gICAgdG9ScHJCRU0oYnVmZiwgbywgZSkge1xuICAgICAgICB0aGlzLkYudG9ScHJCRU0oYnVmZiwgbywgZVsxXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckJFTShidWZmLCBvK3RoaXMuRi5uOCwgZVswXSk7XG4gICAgfVxuXG4gICAgZnJvbVJwckxFKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckxFKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5mcm9tUnByTEUoYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMV07XG4gICAgfVxuXG4gICAgZnJvbVJwckJFKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5mcm9tUnByQkUoYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMV07XG4gICAgfVxuXG4gICAgZnJvbVJwckxFTShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMV07XG4gICAgfVxuXG4gICAgZnJvbVJwckJFTShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21ScHJCRU0oYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21ScHJCRU0oYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMV07XG4gICAgfVxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/f2field.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/f3field.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/f3field.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ F3Field)\n/* harmony export */ });\n/* harmony import */ var _futils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./futils.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nclass F3Field {\n    constructor(F, nonResidue) {\n        this.type=\"F3\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*3;\n        this.p = F.p;\n        this.n64 = F.n64*3;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1]), this.F.copy(a[2])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1]),\n            this.F.add(a[2], b[2])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1]),\n            this.F.sub(a[2], b[2])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    mul(a, b) {\n\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n        const cC = this.F.mul(a[2] , b[2]);\n\n        return [\n            this.F.add(\n                aA,\n                this._mulByNonResidue(\n                    this.F.sub(\n                        this.F.mul(\n                            this.F.add(a[1], a[2]),\n                            this.F.add(b[1], b[2])),\n                        this.F.add(bB, cC)))),    // aA + non_residue*((b+c)*(B+C)-bB-cC),\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[1]),\n                        this.F.add(b[0], b[1])),\n                    this.F.add(aA, bB)),\n                this._mulByNonResidue( cC)),   // (a+b)*(A+B)-aA-bB+non_residue*cC\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[2]),\n                        this.F.add(b[0], b[2])),\n                    this.F.add(aA, cC)),\n                bB)];                           // (a+c)*(A+C)-aA+bB-cC)\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);             // t0 = a^2 ;\n        const t1 = this.F.square(a[1]);             // t1 = b^2 ;\n        const t2 = this.F.square(a[2]);             // t2 = c^2;\n        const t3 = this.F.mul(a[0],a[1]);           // t3 = ab\n        const t4 = this.F.mul(a[0],a[2]);           // t4 = ac\n        const t5 = this.F.mul(a[1],a[2]);           // t5 = bc;\n        // c0 = t0 - non_residue * t5;\n        const c0 = this.F.sub(t0, this._mulByNonResidue(t5));\n        // c1 = non_residue * t2 - t3;\n        const c1 = this.F.sub(this._mulByNonResidue(t2), t3);\n        const c2 = this.F.sub(t1, t4);              // c2 = t1-t4\n\n        // t6 = (a * c0 + non_residue * (c * c1 + b * c2)).inv();\n        const t6 =\n            this.F.inv(\n                this.F.add(\n                    this.F.mul(a[0], c0),\n                    this._mulByNonResidue(\n                        this.F.add(\n                            this.F.mul(a[2], c1),\n                            this.F.mul(a[1], c2)))));\n\n        return [\n            this.F.mul(t6, c0),         // t6*c0\n            this.F.mul(t6, c1),         // t6*c1\n            this.F.mul(t6, c2)];        // t6*c2\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const s0 = this.F.square(a[0]);                   // s0 = a^2\n        const ab = this.F.mul(a[0], a[1]);                // ab = a*b\n        const s1 = this.F.add(ab, ab);                    // s1 = 2ab;\n        const s2 = this.F.square(\n            this.F.add(this.F.sub(a[0],a[1]), a[2]));     // s2 = (a - b + c)^2;\n        const bc = this.F.mul(a[1],a[2]);                 // bc = b*c\n        const s3 = this.F.add(bc, bc);                    // s3 = 2*bc\n        const s4 = this.F.square(a[2]);                   // s4 = c^2\n\n\n        return [\n            this.F.add(\n                s0,\n                this._mulByNonResidue(s3)),           // s0 + non_residue * s3,\n            this.F.add(\n                s1,\n                this._mulByNonResidue(s4)),           // s1 + non_residue * s4,\n            this.F.sub(\n                this.F.add( this.F.add(s1, s2) , s3 ),\n                this.F.add(s0, s4))];                      // s1 + s2 + s3 - s0 - s4\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]) && this.F.isZero(a[2]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]) && this.F.eq(a[2], b[2]);\n    }\n\n    affine(a) {\n        return [this.F.affine(a[0]), this.F.affine(a[1]), this.F.affine(a[2])];\n    }\n\n    mulScalar(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])}, ${this.F.toString(a[2])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        return [c0, c1, c2];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        if (this.F.gt(b[1], a[1])) return false;\n        if (this.F.gt(a[2], b[2])) return true;\n        return false;\n    }\n\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n        this.F.toRprLE(buff, o+this.F.n8*2, e[2]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[2]);\n        this.F.toRprBE(buff, o+this.F.n8, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8*2, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprLEM(buff, o+this.F.n8*2, e[2]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[2]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8*2, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.n8);\n        const c2 = this.F.fromRprLE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBE(buff, o);\n        const c1 = this.F.fromRprBE(buff, o+this.n8);\n        const c0 = this.F.fromRprBE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.n8);\n        const c2 = this.F.fromRprLEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBEM(buff, o);\n        const c1 = this.F.fromRprBEM(buff, o+this.n8);\n        const c0 = this.F.fromRprBEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mM2ZpZWxkLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0M7O0FBRXZCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQ7QUFDQSwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7OztBQUcxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGlEQUFnQjtBQUMvQjs7QUFFQTtBQUNBLGVBQWUsMkNBQVU7QUFDekI7O0FBRUE7QUFDQSxlQUFlLDJDQUFVO0FBQ3pCOztBQUVBO0FBQ0Esb0JBQW9CLHVCQUF1QixJQUFJLHNCQUFzQixJQUFJLHVCQUF1QjtBQUNoRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mM2ZpZWxkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGZVdGlscyBmcm9tIFwiLi9mdXRpbHMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRjNGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoRiwgbm9uUmVzaWR1ZSkge1xuICAgICAgICB0aGlzLnR5cGU9XCJGM1wiO1xuICAgICAgICB0aGlzLkYgPSBGO1xuICAgICAgICB0aGlzLnplcm8gPSBbdGhpcy5GLnplcm8sIHRoaXMuRi56ZXJvLCB0aGlzLkYuemVyb107XG4gICAgICAgIHRoaXMub25lID0gW3RoaXMuRi5vbmUsIHRoaXMuRi56ZXJvLCB0aGlzLkYuemVyb107XG4gICAgICAgIHRoaXMubmVnb25lID0gdGhpcy5uZWcodGhpcy5vbmUpO1xuICAgICAgICB0aGlzLm5vblJlc2lkdWUgPSBub25SZXNpZHVlO1xuICAgICAgICB0aGlzLm0gPSBGLm0qMztcbiAgICAgICAgdGhpcy5wID0gRi5wO1xuICAgICAgICB0aGlzLm42NCA9IEYubjY0KjM7XG4gICAgICAgIHRoaXMubjMyID0gdGhpcy5uNjQqMjtcbiAgICAgICAgdGhpcy5uOCA9IHRoaXMubjY0Kjg7XG4gICAgfVxuXG4gICAgX211bEJ5Tm9uUmVzaWR1ZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYubXVsKHRoaXMubm9uUmVzaWR1ZSwgYSk7XG4gICAgfVxuXG4gICAgY29weShhKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5GLmNvcHkoYVswXSksIHRoaXMuRi5jb3B5KGFbMV0pLCB0aGlzLkYuY29weShhWzJdKV07XG4gICAgfVxuXG4gICAgYWRkKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoYVswXSwgYlswXSksXG4gICAgICAgICAgICB0aGlzLkYuYWRkKGFbMV0sIGJbMV0pLFxuICAgICAgICAgICAgdGhpcy5GLmFkZChhWzJdLCBiWzJdKVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGRvdWJsZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhLGEpO1xuICAgIH1cblxuICAgIHN1YihhLCBiKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuc3ViKGFbMF0sIGJbMF0pLFxuICAgICAgICAgICAgdGhpcy5GLnN1YihhWzFdLCBiWzFdKSxcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoYVsyXSwgYlsyXSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBuZWcoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy56ZXJvLCBhKTtcbiAgICB9XG5cbiAgICBtdWwoYSwgYikge1xuXG4gICAgICAgIGNvbnN0IGFBID0gdGhpcy5GLm11bChhWzBdICwgYlswXSk7XG4gICAgICAgIGNvbnN0IGJCID0gdGhpcy5GLm11bChhWzFdICwgYlsxXSk7XG4gICAgICAgIGNvbnN0IGNDID0gdGhpcy5GLm11bChhWzJdICwgYlsyXSk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgYUEsXG4gICAgICAgICAgICAgICAgdGhpcy5fbXVsQnlOb25SZXNpZHVlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLm11bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFbMV0sIGFbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYlsxXSwgYlsyXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChiQiwgY0MpKSkpLCAgICAvLyBhQSArIG5vbl9yZXNpZHVlKigoYitjKSooQitDKS1iQi1jQyksXG5cbiAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgdGhpcy5GLnN1YihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLm11bChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYVswXSwgYVsxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGJbMF0sIGJbMV0pKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhQSwgYkIpKSxcbiAgICAgICAgICAgICAgICB0aGlzLl9tdWxCeU5vblJlc2lkdWUoIGNDKSksICAgLy8gKGErYikqKEErQiktYUEtYkIrbm9uX3Jlc2lkdWUqY0NcblxuICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICB0aGlzLkYuc3ViKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhWzBdLCBhWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYlswXSwgYlsyXSkpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFBLCBjQykpLFxuICAgICAgICAgICAgICAgIGJCKV07ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGErYykqKEErQyktYUErYkItY0MpXG4gICAgfVxuXG4gICAgaW52KGEpIHtcbiAgICAgICAgY29uc3QgdDAgPSB0aGlzLkYuc3F1YXJlKGFbMF0pOyAgICAgICAgICAgICAvLyB0MCA9IGFeMiA7XG4gICAgICAgIGNvbnN0IHQxID0gdGhpcy5GLnNxdWFyZShhWzFdKTsgICAgICAgICAgICAgLy8gdDEgPSBiXjIgO1xuICAgICAgICBjb25zdCB0MiA9IHRoaXMuRi5zcXVhcmUoYVsyXSk7ICAgICAgICAgICAgIC8vIHQyID0gY14yO1xuICAgICAgICBjb25zdCB0MyA9IHRoaXMuRi5tdWwoYVswXSxhWzFdKTsgICAgICAgICAgIC8vIHQzID0gYWJcbiAgICAgICAgY29uc3QgdDQgPSB0aGlzLkYubXVsKGFbMF0sYVsyXSk7ICAgICAgICAgICAvLyB0NCA9IGFjXG4gICAgICAgIGNvbnN0IHQ1ID0gdGhpcy5GLm11bChhWzFdLGFbMl0pOyAgICAgICAgICAgLy8gdDUgPSBiYztcbiAgICAgICAgLy8gYzAgPSB0MCAtIG5vbl9yZXNpZHVlICogdDU7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLnN1Yih0MCwgdGhpcy5fbXVsQnlOb25SZXNpZHVlKHQ1KSk7XG4gICAgICAgIC8vIGMxID0gbm9uX3Jlc2lkdWUgKiB0MiAtIHQzO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5zdWIodGhpcy5fbXVsQnlOb25SZXNpZHVlKHQyKSwgdDMpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5zdWIodDEsIHQ0KTsgICAgICAgICAgICAgIC8vIGMyID0gdDEtdDRcblxuICAgICAgICAvLyB0NiA9IChhICogYzAgKyBub25fcmVzaWR1ZSAqIChjICogYzEgKyBiICogYzIpKS5pbnYoKTtcbiAgICAgICAgY29uc3QgdDYgPVxuICAgICAgICAgICAgdGhpcy5GLmludihcbiAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKGFbMF0sIGMwKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXVsQnlOb25SZXNpZHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKGFbMl0sIGMxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKGFbMV0sIGMyKSkpKSk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5tdWwodDYsIGMwKSwgICAgICAgICAvLyB0NipjMFxuICAgICAgICAgICAgdGhpcy5GLm11bCh0NiwgYzEpLCAgICAgICAgIC8vIHQ2KmMxXG4gICAgICAgICAgICB0aGlzLkYubXVsKHQ2LCBjMildOyAgICAgICAgLy8gdDYqYzJcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgdGhpcy5pbnYoYikpO1xuICAgIH1cblxuICAgIHNxdWFyZShhKSB7XG4gICAgICAgIGNvbnN0IHMwID0gdGhpcy5GLnNxdWFyZShhWzBdKTsgICAgICAgICAgICAgICAgICAgLy8gczAgPSBhXjJcbiAgICAgICAgY29uc3QgYWIgPSB0aGlzLkYubXVsKGFbMF0sIGFbMV0pOyAgICAgICAgICAgICAgICAvLyBhYiA9IGEqYlxuICAgICAgICBjb25zdCBzMSA9IHRoaXMuRi5hZGQoYWIsIGFiKTsgICAgICAgICAgICAgICAgICAgIC8vIHMxID0gMmFiO1xuICAgICAgICBjb25zdCBzMiA9IHRoaXMuRi5zcXVhcmUoXG4gICAgICAgICAgICB0aGlzLkYuYWRkKHRoaXMuRi5zdWIoYVswXSxhWzFdKSwgYVsyXSkpOyAgICAgLy8gczIgPSAoYSAtIGIgKyBjKV4yO1xuICAgICAgICBjb25zdCBiYyA9IHRoaXMuRi5tdWwoYVsxXSxhWzJdKTsgICAgICAgICAgICAgICAgIC8vIGJjID0gYipjXG4gICAgICAgIGNvbnN0IHMzID0gdGhpcy5GLmFkZChiYywgYmMpOyAgICAgICAgICAgICAgICAgICAgLy8gczMgPSAyKmJjXG4gICAgICAgIGNvbnN0IHM0ID0gdGhpcy5GLnNxdWFyZShhWzJdKTsgICAgICAgICAgICAgICAgICAgLy8gczQgPSBjXjJcblxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuYWRkKFxuICAgICAgICAgICAgICAgIHMwLFxuICAgICAgICAgICAgICAgIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZShzMykpLCAgICAgICAgICAgLy8gczAgKyBub25fcmVzaWR1ZSAqIHMzLFxuICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICBzMSxcbiAgICAgICAgICAgICAgICB0aGlzLl9tdWxCeU5vblJlc2lkdWUoczQpKSwgICAgICAgICAgIC8vIHMxICsgbm9uX3Jlc2lkdWUgKiBzNCxcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoXG4gICAgICAgICAgICAgICAgdGhpcy5GLmFkZCggdGhpcy5GLmFkZChzMSwgczIpICwgczMgKSxcbiAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKHMwLCBzNCkpXTsgICAgICAgICAgICAgICAgICAgICAgLy8gczEgKyBzMiArIHMzIC0gczAgLSBzNFxuICAgIH1cblxuICAgIGlzWmVybyhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYuaXNaZXJvKGFbMF0pICYmIHRoaXMuRi5pc1plcm8oYVsxXSkgJiYgdGhpcy5GLmlzWmVybyhhWzJdKTtcbiAgICB9XG5cbiAgICBlcShhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYuZXEoYVswXSwgYlswXSkgJiYgdGhpcy5GLmVxKGFbMV0sIGJbMV0pICYmIHRoaXMuRi5lcShhWzJdLCBiWzJdKTtcbiAgICB9XG5cbiAgICBhZmZpbmUoYSkge1xuICAgICAgICByZXR1cm4gW3RoaXMuRi5hZmZpbmUoYVswXSksIHRoaXMuRi5hZmZpbmUoYVsxXSksIHRoaXMuRi5hZmZpbmUoYVsyXSldO1xuICAgIH1cblxuICAgIG11bFNjYWxhcihiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBmVXRpbHMubXVsU2NhbGFyKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIHBvdyhiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBmVXRpbHMuZXhwKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIGV4cChiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBmVXRpbHMuZXhwKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKGEpIHtcbiAgICAgICAgcmV0dXJuIGBbICR7dGhpcy5GLnRvU3RyaW5nKGFbMF0pfSAsICR7dGhpcy5GLnRvU3RyaW5nKGFbMV0pfSwgJHt0aGlzLkYudG9TdHJpbmcoYVsyXSl9IF1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgIHJldHVybiBbYzAsIGMxLCBjMl07XG4gICAgfVxuXG4gICAgZ3QoYSwgYikge1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMF0sIGJbMF0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChiWzBdLCBhWzBdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMV0sIGJbMV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChiWzFdLCBhWzFdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMl0sIGJbMl0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgZ2VxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3QoYSwgYikgfHwgdGhpcy5lcShhLCBiKTtcbiAgICB9XG5cbiAgICBsdChhLCBiKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5nZXEoYSxiKTtcbiAgICB9XG5cbiAgICBsZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZ3QoYSxiKTtcbiAgICB9XG5cbiAgICBuZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXEoYSxiKTtcbiAgICB9XG5cbiAgICByYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5GLnJhbmRvbSgpLCB0aGlzLkYucmFuZG9tKCksIHRoaXMuRi5yYW5kb20oKV07XG4gICAgfVxuXG5cbiAgICB0b1JwckxFKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbywgZVswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFKGJ1ZmYsIG8rdGhpcy5GLm44LCBlWzFdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbyt0aGlzLkYubjgqMiwgZVsyXSk7XG4gICAgfVxuXG4gICAgdG9ScHJCRShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8sIGVbMl0pO1xuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvK3RoaXMuRi5uOCwgZVsxXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8rdGhpcy5GLm44KjIsIGVbMF0pO1xuICAgIH1cblxuICAgIHRvUnByTEVNKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8sIGVbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgsIGVbMV0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgqMiwgZVsyXSk7XG4gICAgfVxuXG5cbiAgICB0b1JwckJFTShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckJFTShidWZmLCBvLCBlWzJdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkVNKGJ1ZmYsIG8rdGhpcy5GLm44LCBlWzFdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkVNKGJ1ZmYsIG8rdGhpcy5GLm44KjIsIGVbMF0pO1xuICAgIH1cblxuICAgIGZyb21ScHJMRShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21ScHJMRShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckxFKGJ1ZmYsIG8rdGhpcy5uOCk7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5GLmZyb21ScHJMRShidWZmLCBvK3RoaXMubjgqMik7XG4gICAgICAgIHJldHVybiBbYzAsIGMxLCBjMl07XG4gICAgfVxuXG4gICAgZnJvbVJwckJFKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5mcm9tUnByQkUoYnVmZiwgbyt0aGlzLm44KTtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8rdGhpcy5uOCoyKTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzEsIGMyXTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvK3RoaXMubjgpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5mcm9tUnByTEVNKGJ1ZmYsIG8rdGhpcy5uOCoyKTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzEsIGMyXTtcbiAgICB9XG5cbiAgICBmcm9tUnByQkVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvK3RoaXMubjgpO1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5mcm9tUnByQkVNKGJ1ZmYsIG8rdGhpcy5uOCoyKTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzEsIGMyXTtcbiAgICB9XG5cbiAgICB0b09iamVjdChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/f3field.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/fft.js":
/*!*******************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/fft.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FFT)\n/* harmony export */ });\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nclass FFT {\n    constructor (G, F, opMulGF) {\n        this.F = F;\n        this.G = G;\n        this.opMulGF = opMulGF;\n\n        let rem = F.sqrt_t || F.t;\n        let s = F.sqrt_s || F.s;\n\n        let nqr = F.one;\n        while (F.eq(F.pow(nqr, F.half), F.one)) nqr = F.add(nqr, F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(nqr, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n        /*\n        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n        */\n        this._setRoots(Math.min(s, 15));\n    }\n\n    _setRoots(n) {\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots[i] = rootsi;\n        }\n    }\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res = __fft(this, p, bits, 0, 1);\n        return res;\n    }\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res =  __fft(this, p, bits, 0, 1);\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.opMulGF(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n    }\n\n\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.G.add(pall[offset], pall[offset + step]),\n            PF.G.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n        out[i+ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n    }\n\n    return out;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mZnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvZmZ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8qXG4gICAgVGhpcyBsaWJyYXJ5IGRvZXMgb3BlcmF0aW9ucyBvbiBwb2x5bm9taWFscyB3aXRoIGNvZWZmaWNpZW50cyBpbiBhIGZpZWxkIEYuXG5cbiAgICBBIHBvbHlub21pYWwgUCh4KSA9IHAwICsgcDEgKiB4ICsgcDIgKiB4XjIgKyAuLi4gKyBwbiAqIHhebiAgaXMgcmVwcmVzZW50ZWRcbiAgICBieSB0aGUgYXJyYXkgWyBwMCwgcDEsIHAyLCAuLi4gLCBwbiBdLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZGVCB7XG4gICAgY29uc3RydWN0b3IgKEcsIEYsIG9wTXVsR0YpIHtcbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy5HID0gRztcbiAgICAgICAgdGhpcy5vcE11bEdGID0gb3BNdWxHRjtcblxuICAgICAgICBsZXQgcmVtID0gRi5zcXJ0X3QgfHwgRi50O1xuICAgICAgICBsZXQgcyA9IEYuc3FydF9zIHx8IEYucztcblxuICAgICAgICBsZXQgbnFyID0gRi5vbmU7XG4gICAgICAgIHdoaWxlIChGLmVxKEYucG93KG5xciwgRi5oYWxmKSwgRi5vbmUpKSBucXIgPSBGLmFkZChucXIsIEYub25lKTtcblxuICAgICAgICB0aGlzLncgPSBuZXcgQXJyYXkocysxKTtcbiAgICAgICAgdGhpcy53aSA9IG5ldyBBcnJheShzKzEpO1xuICAgICAgICB0aGlzLndbc10gPSB0aGlzLkYucG93KG5xciwgcmVtKTtcbiAgICAgICAgdGhpcy53aVtzXSA9IHRoaXMuRi5pbnYodGhpcy53W3NdKTtcblxuICAgICAgICBsZXQgbj1zLTE7XG4gICAgICAgIHdoaWxlIChuPj0wKSB7XG4gICAgICAgICAgICB0aGlzLndbbl0gPSB0aGlzLkYuc3F1YXJlKHRoaXMud1tuKzFdKTtcbiAgICAgICAgICAgIHRoaXMud2lbbl0gPSB0aGlzLkYuc3F1YXJlKHRoaXMud2lbbisxXSk7XG4gICAgICAgICAgICBuLS07XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMucm9vdHMgPSBbXTtcbiAgICAgICAgLypcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDE2OyBpKyspIHtcbiAgICAgICAgICAgIGxldCByID0gdGhpcy5GLm9uZTtcbiAgICAgICAgICAgIG4gPSAxIDw8IGk7XG4gICAgICAgICAgICBjb25zdCByb290c2kgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8bjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNpW2pdID0gcjtcbiAgICAgICAgICAgICAgICByID0gdGhpcy5GLm11bChyLCB0aGlzLndbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJvb3RzLnB1c2gocm9vdHNpKTtcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZXRSb290cyhNYXRoLm1pbihzLCAxNSkpO1xuICAgIH1cblxuICAgIF9zZXRSb290cyhuKSB7XG4gICAgICAgIGZvciAobGV0IGk9bjsgKGk+PTApICYmICghdGhpcy5yb290c1tpXSk7IGktLSkge1xuICAgICAgICAgICAgbGV0IHIgPSB0aGlzLkYub25lO1xuICAgICAgICAgICAgY29uc3QgbnJvb3RzID0gMSA8PCBpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdHNpID0gbmV3IEFycmF5KG5yb290cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8bnJvb3RzOyBqKyspIHtcbiAgICAgICAgICAgICAgICByb290c2lbal0gPSByO1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzLkYubXVsKHIsIHRoaXMud1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucm9vdHNbaV0gPSByb290c2k7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmZnQocCkge1xuICAgICAgICBpZiAocC5sZW5ndGggPD0gMSkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuXG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHM7XG4gICAgICAgIGlmIChwLmxlbmd0aCAhPSBtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplIG11c3QgYmUgbXVsdGlwbGUgb2YgMlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBfX2ZmdCh0aGlzLCBwLCBiaXRzLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZmZ0KHApIHtcblxuICAgICAgICBpZiAocC5sZW5ndGggPD0gMSkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuICAgICAgICBjb25zdCBtID0gMSA8PCBiaXRzO1xuICAgICAgICBpZiAocC5sZW5ndGggIT0gbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBtdXN0IGJlIG11bHRpcGxlIG9mIDJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gIF9fZmZ0KHRoaXMsIHAsIGJpdHMsIDAsIDEpO1xuICAgICAgICBjb25zdCB0d29pbnZtID0gdGhpcy5GLmludiggdGhpcy5GLm11bFNjYWxhcih0aGlzLkYub25lLCBtKSApO1xuICAgICAgICBjb25zdCByZXNuID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bTsgaSsrKSB7XG4gICAgICAgICAgICByZXNuW2ldID0gdGhpcy5vcE11bEdGKHJlc1sobS1pKSVtXSwgdHdvaW52bSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzbjtcbiAgICB9XG5cblxufVxuXG5mdW5jdGlvbiBsb2cyKCBWIClcbntcbiAgICByZXR1cm4oICggKCBWICYgMHhGRkZGMDAwMCApICE9PSAwID8gKCBWICY9IDB4RkZGRjAwMDAsIDE2ICkgOiAwICkgfCAoICggViAmIDB4RkYwMEZGMDAgKSAhPT0gMCA/ICggViAmPSAweEZGMDBGRjAwLCA4ICkgOiAwICkgfCAoICggViAmIDB4RjBGMEYwRjAgKSAhPT0gMCA/ICggViAmPSAweEYwRjBGMEYwLCA0ICkgOiAwICkgfCAoICggViAmIDB4Q0NDQ0NDQ0MgKSAhPT0gMCA/ICggViAmPSAweENDQ0NDQ0NDLCAyICkgOiAwICkgfCAoICggViAmIDB4QUFBQUFBQUEgKSAhPT0gMCApICk7XG59XG5cblxuZnVuY3Rpb24gX19mZnQoUEYsIHBhbGwsIGJpdHMsIG9mZnNldCwgc3RlcCkge1xuXG4gICAgY29uc3QgbiA9IDEgPDwgYml0cztcbiAgICBpZiAobj09MSkge1xuICAgICAgICByZXR1cm4gWyBwYWxsW29mZnNldF0gXTtcbiAgICB9IGVsc2UgaWYgKG49PTIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFBGLkcuYWRkKHBhbGxbb2Zmc2V0XSwgcGFsbFtvZmZzZXQgKyBzdGVwXSksXG4gICAgICAgICAgICBQRi5HLnN1YihwYWxsW29mZnNldF0sIHBhbGxbb2Zmc2V0ICsgc3RlcF0pXTtcbiAgICB9XG5cbiAgICBjb25zdCBuZGl2MiA9IG4gPj4gMTtcbiAgICBjb25zdCBwMSA9IF9fZmZ0KFBGLCBwYWxsLCBiaXRzLTEsIG9mZnNldCwgc3RlcCoyKTtcbiAgICBjb25zdCBwMiA9IF9fZmZ0KFBGLCBwYWxsLCBiaXRzLTEsIG9mZnNldCtzdGVwLCBzdGVwKjIpO1xuXG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgZm9yIChsZXQgaT0wOyBpPG5kaXYyOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gUEYuRy5hZGQocDFbaV0sIFBGLm9wTXVsR0YocDJbaV0sIFBGLnJvb3RzW2JpdHNdW2ldKSk7XG4gICAgICAgIG91dFtpK25kaXYyXSA9IFBGLkcuc3ViKHAxW2ldLCBQRi5vcE11bEdGKHAyW2ldLCBQRi5yb290c1tiaXRzXVtpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/fft.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/fsqrt.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/fsqrt.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildSqrt)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n\n// Check here: https://eprint.iacr.org/2012/685.pdf\n\nfunction buildSqrt (F) {\n    if ((F.m % 2) == 1) {\n        if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 4), 1 )) {\n            if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 8), 1 )) {\n                if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 16), 1 )) {\n                    // alg7_muller(F);\n                    alg5_tonelliShanks(F);\n                } else if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 16), 9 )) {\n                    alg4_kong(F);\n                } else {\n                    throw new Error(\"Field withot sqrt\");\n                }\n            } else if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 8), 5 )) {\n                alg3_atkin(F);\n            } else {\n                throw new Error(\"Field withot sqrt\");\n            }\n        } else if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 4), 3 )) {\n            alg2_shanks(F);\n        }\n    } else {\n        const pm2mod4 = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.pow(F.p, F.m/2), 4);\n        if (pm2mod4 == 1) {\n            alg10_adj(F);\n        } else if (pm2mod4 == 3) {\n            alg9_adj(F);\n        } else {\n            alg8_complex(F);\n        }\n\n    }\n}\n\n\nfunction alg5_tonelliShanks(F) {\n    F.sqrt_q = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.pow(F.p, F.m);\n\n    F.sqrt_s = 0;\n    F.sqrt_t = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(F.sqrt_q, 1);\n\n    while (!_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isOdd(F.sqrt_t)) {\n        F.sqrt_s = F.sqrt_s + 1;\n        F.sqrt_t = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.div(F.sqrt_t, 2);\n    }\n\n    let c0 = F.one;\n\n    while (F.eq(c0, F.one)) {\n        const c = F.random();\n        F.sqrt_z = F.pow(c, F.sqrt_t);\n        c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s-1) );\n    }\n\n    F.sqrt_tm1d2 = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.div(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(F.sqrt_t, 1),2);\n\n    F.sqrt = function(a) {\n        const F=this;\n        if (F.isZero(a)) return F.zero;\n        let w = F.pow(a, F.sqrt_tm1d2);\n        const a0 = F.pow( F.mul(F.square(w), a), 2 ** (F.sqrt_s-1) );\n        if (F.eq(a0, F.negone)) return null;\n\n        let v = F.sqrt_s;\n        let x = F.mul(a, w);\n        let b = F.mul(x, w);\n        let z = F.sqrt_z;\n        while (!F.eq(b, F.one)) {\n            let b2k = F.square(b);\n            let k=1;\n            while (!F.eq(b2k, F.one)) {\n                b2k = F.square(b2k);\n                k++;\n            }\n\n            w = z;\n            for (let i=0; i<v-k-1; i++) {\n                w = F.square(w);\n            }\n            z = F.square(w);\n            b = F.mul(b, z);\n            x = F.mul(x, w);\n            v = k;\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg4_kong(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 4 not implemented\");\n    };\n}\n\nfunction alg3_atkin(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 3 not implemented\");\n    };\n}\n\nfunction alg2_shanks(F) {\n\n    F.sqrt_q = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.pow(F.p, F.m);\n    F.sqrt_e1 = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.div( _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(F.sqrt_q, 3) , 4);\n\n    F.sqrt = function(a) {\n        if (this.isZero(a)) return this.zero;\n\n        // Test that have solution\n        const a1 = this.pow(a, this.sqrt_e1);\n\n        const a0 = this.mul(this.square(a1), a);\n\n        if ( this.eq(a0, this.negone) ) return null;\n\n        const x = this.mul(a1, a);\n\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg10_adj(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 10 not implemented\");\n    };\n}\n\nfunction alg9_adj(F) {\n    F.sqrt_q = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.pow(F.p, F.m/2);\n    F.sqrt_e34 = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.div( _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(F.sqrt_q, 3) , 4);\n    F.sqrt_e12 = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.div( _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(F.sqrt_q, 1) , 2);\n\n    F.frobenius = function(n, x) {\n        if ((n%2) == 1) {\n            return F.conjugate(x);\n        } else {\n            return x;\n        }\n    };\n\n    F.sqrt = function(a) {\n        const F = this;\n        const a1 = F.pow(a, F.sqrt_e34);\n        const alfa = F.mul(F.square(a1), a);\n        const a0 = F.mul(F.frobenius(1, alfa), alfa);\n        if (F.eq(a0, F.negone)) return null;\n        const x0 = F.mul(a1, a);\n        let x;\n        if (F.eq(alfa, F.negone)) {\n            x = F.mul(x0, [F.F.zero, F.F.one]);\n        } else {\n            const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n            x = F.mul(b, x0);\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\n\nfunction alg8_complex(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 8 not implemented\");\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mc3FydC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFzQztBQUN0Qzs7QUFFZTtBQUNmO0FBQ0EsWUFBWSwwQ0FBUyxDQUFDLDJDQUFVO0FBQ2hDLGdCQUFnQiwwQ0FBUyxDQUFDLDJDQUFVO0FBQ3BDLG9CQUFvQiwwQ0FBUyxDQUFDLDJDQUFVO0FBQ3hDO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUywwQ0FBUyxDQUFDLDJDQUFVO0FBQy9DO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjLFNBQVMsMENBQVMsQ0FBQywyQ0FBVTtBQUMzQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVSxTQUFTLDBDQUFTLENBQUMsMkNBQVU7QUFDdkM7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0IsMkNBQVUsQ0FBQywyQ0FBVTtBQUM3QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSxlQUFlLDJDQUFVOztBQUV6QjtBQUNBLGVBQWUsMkNBQVU7O0FBRXpCLFlBQVksNkNBQVk7QUFDeEI7QUFDQSxtQkFBbUIsMkNBQVU7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMkNBQVUsQ0FBQywyQ0FBVTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSwyQ0FBVTtBQUN6QixnQkFBZ0IsMkNBQVUsRUFBRSwyQ0FBVTs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyQ0FBVTtBQUN6QixpQkFBaUIsMkNBQVUsRUFBRSwyQ0FBVTtBQUN2QyxpQkFBaUIsMkNBQVUsRUFBRSwyQ0FBVTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mc3FydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG4vLyBDaGVjayBoZXJlOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRTcXJ0IChGKSB7XG4gICAgaWYgKChGLm0gJSAyKSA9PSAxKSB7XG4gICAgICAgIGlmIChTY2FsYXIuZXEoU2NhbGFyLm1vZChGLnAsIDQpLCAxICkpIHtcbiAgICAgICAgICAgIGlmIChTY2FsYXIuZXEoU2NhbGFyLm1vZChGLnAsIDgpLCAxICkpIHtcbiAgICAgICAgICAgICAgICBpZiAoU2NhbGFyLmVxKFNjYWxhci5tb2QoRi5wLCAxNiksIDEgKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGc3X211bGxlcihGKTtcbiAgICAgICAgICAgICAgICAgICAgYWxnNV90b25lbGxpU2hhbmtzKEYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoU2NhbGFyLmVxKFNjYWxhci5tb2QoRi5wLCAxNiksIDkgKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGc0X2tvbmcoRik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgd2l0aG90IHNxcnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChTY2FsYXIuZXEoU2NhbGFyLm1vZChGLnAsIDgpLCA1ICkpIHtcbiAgICAgICAgICAgICAgICBhbGczX2F0a2luKEYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCB3aXRob3Qgc3FydFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChTY2FsYXIuZXEoU2NhbGFyLm1vZChGLnAsIDQpLCAzICkpIHtcbiAgICAgICAgICAgIGFsZzJfc2hhbmtzKEYpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcG0ybW9kNCA9IFNjYWxhci5tb2QoU2NhbGFyLnBvdyhGLnAsIEYubS8yKSwgNCk7XG4gICAgICAgIGlmIChwbTJtb2Q0ID09IDEpIHtcbiAgICAgICAgICAgIGFsZzEwX2FkaihGKTtcbiAgICAgICAgfSBlbHNlIGlmIChwbTJtb2Q0ID09IDMpIHtcbiAgICAgICAgICAgIGFsZzlfYWRqKEYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxnOF9jb21wbGV4KEYpO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gYWxnNV90b25lbGxpU2hhbmtzKEYpIHtcbiAgICBGLnNxcnRfcSA9IFNjYWxhci5wb3coRi5wLCBGLm0pO1xuXG4gICAgRi5zcXJ0X3MgPSAwO1xuICAgIEYuc3FydF90ID0gU2NhbGFyLnN1YihGLnNxcnRfcSwgMSk7XG5cbiAgICB3aGlsZSAoIVNjYWxhci5pc09kZChGLnNxcnRfdCkpIHtcbiAgICAgICAgRi5zcXJ0X3MgPSBGLnNxcnRfcyArIDE7XG4gICAgICAgIEYuc3FydF90ID0gU2NhbGFyLmRpdihGLnNxcnRfdCwgMik7XG4gICAgfVxuXG4gICAgbGV0IGMwID0gRi5vbmU7XG5cbiAgICB3aGlsZSAoRi5lcShjMCwgRi5vbmUpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBGLnJhbmRvbSgpO1xuICAgICAgICBGLnNxcnRfeiA9IEYucG93KGMsIEYuc3FydF90KTtcbiAgICAgICAgYzAgPSBGLnBvdyhGLnNxcnRfeiwgMiAqKiAoRi5zcXJ0X3MtMSkgKTtcbiAgICB9XG5cbiAgICBGLnNxcnRfdG0xZDIgPSBTY2FsYXIuZGl2KFNjYWxhci5zdWIoRi5zcXJ0X3QsIDEpLDIpO1xuXG4gICAgRi5zcXJ0ID0gZnVuY3Rpb24oYSkge1xuICAgICAgICBjb25zdCBGPXRoaXM7XG4gICAgICAgIGlmIChGLmlzWmVybyhhKSkgcmV0dXJuIEYuemVybztcbiAgICAgICAgbGV0IHcgPSBGLnBvdyhhLCBGLnNxcnRfdG0xZDIpO1xuICAgICAgICBjb25zdCBhMCA9IEYucG93KCBGLm11bChGLnNxdWFyZSh3KSwgYSksIDIgKiogKEYuc3FydF9zLTEpICk7XG4gICAgICAgIGlmIChGLmVxKGEwLCBGLm5lZ29uZSkpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGxldCB2ID0gRi5zcXJ0X3M7XG4gICAgICAgIGxldCB4ID0gRi5tdWwoYSwgdyk7XG4gICAgICAgIGxldCBiID0gRi5tdWwoeCwgdyk7XG4gICAgICAgIGxldCB6ID0gRi5zcXJ0X3o7XG4gICAgICAgIHdoaWxlICghRi5lcShiLCBGLm9uZSkpIHtcbiAgICAgICAgICAgIGxldCBiMmsgPSBGLnNxdWFyZShiKTtcbiAgICAgICAgICAgIGxldCBrPTE7XG4gICAgICAgICAgICB3aGlsZSAoIUYuZXEoYjJrLCBGLm9uZSkpIHtcbiAgICAgICAgICAgICAgICBiMmsgPSBGLnNxdWFyZShiMmspO1xuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdyA9IHo7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8di1rLTE7IGkrKykge1xuICAgICAgICAgICAgICAgIHcgPSBGLnNxdWFyZSh3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHogPSBGLnNxdWFyZSh3KTtcbiAgICAgICAgICAgIGIgPSBGLm11bChiLCB6KTtcbiAgICAgICAgICAgIHggPSBGLm11bCh4LCB3KTtcbiAgICAgICAgICAgIHYgPSBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGLmdlcSh4LCBGLnplcm8pID8geCA6IEYubmVnKHgpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFsZzRfa29uZyhGKSB7XG4gICAgRi5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNxcnQgYWxnIDQgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFsZzNfYXRraW4oRikge1xuICAgIEYuc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcXJ0IGFsZyAzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhbGcyX3NoYW5rcyhGKSB7XG5cbiAgICBGLnNxcnRfcSA9IFNjYWxhci5wb3coRi5wLCBGLm0pO1xuICAgIEYuc3FydF9lMSA9IFNjYWxhci5kaXYoIFNjYWxhci5zdWIoRi5zcXJ0X3EsIDMpICwgNCk7XG5cbiAgICBGLnNxcnQgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhhKSkgcmV0dXJuIHRoaXMuemVybztcblxuICAgICAgICAvLyBUZXN0IHRoYXQgaGF2ZSBzb2x1dGlvblxuICAgICAgICBjb25zdCBhMSA9IHRoaXMucG93KGEsIHRoaXMuc3FydF9lMSk7XG5cbiAgICAgICAgY29uc3QgYTAgPSB0aGlzLm11bCh0aGlzLnNxdWFyZShhMSksIGEpO1xuXG4gICAgICAgIGlmICggdGhpcy5lcShhMCwgdGhpcy5uZWdvbmUpICkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMubXVsKGExLCBhKTtcblxuICAgICAgICByZXR1cm4gRi5nZXEoeCwgRi56ZXJvKSA/IHggOiBGLm5lZyh4KTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhbGcxMF9hZGooRikge1xuICAgIEYuc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcXJ0IGFsZyAxMCBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWxnOV9hZGooRikge1xuICAgIEYuc3FydF9xID0gU2NhbGFyLnBvdyhGLnAsIEYubS8yKTtcbiAgICBGLnNxcnRfZTM0ID0gU2NhbGFyLmRpdiggU2NhbGFyLnN1YihGLnNxcnRfcSwgMykgLCA0KTtcbiAgICBGLnNxcnRfZTEyID0gU2NhbGFyLmRpdiggU2NhbGFyLnN1YihGLnNxcnRfcSwgMSkgLCAyKTtcblxuICAgIEYuZnJvYmVuaXVzID0gZnVuY3Rpb24obiwgeCkge1xuICAgICAgICBpZiAoKG4lMikgPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIEYuY29uanVnYXRlKHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRi5zcXJ0ID0gZnVuY3Rpb24oYSkge1xuICAgICAgICBjb25zdCBGID0gdGhpcztcbiAgICAgICAgY29uc3QgYTEgPSBGLnBvdyhhLCBGLnNxcnRfZTM0KTtcbiAgICAgICAgY29uc3QgYWxmYSA9IEYubXVsKEYuc3F1YXJlKGExKSwgYSk7XG4gICAgICAgIGNvbnN0IGEwID0gRi5tdWwoRi5mcm9iZW5pdXMoMSwgYWxmYSksIGFsZmEpO1xuICAgICAgICBpZiAoRi5lcShhMCwgRi5uZWdvbmUpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgeDAgPSBGLm11bChhMSwgYSk7XG4gICAgICAgIGxldCB4O1xuICAgICAgICBpZiAoRi5lcShhbGZhLCBGLm5lZ29uZSkpIHtcbiAgICAgICAgICAgIHggPSBGLm11bCh4MCwgW0YuRi56ZXJvLCBGLkYub25lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBiID0gRi5wb3coRi5hZGQoRi5vbmUsIGFsZmEpLCBGLnNxcnRfZTEyKTtcbiAgICAgICAgICAgIHggPSBGLm11bChiLCB4MCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEYuZ2VxKHgsIEYuemVybykgPyB4IDogRi5uZWcoeCk7XG4gICAgfTtcbn1cblxuXG5mdW5jdGlvbiBhbGc4X2NvbXBsZXgoRikge1xuICAgIEYuc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcXJ0IGFsZyA4IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/fsqrt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exp: () => (/* binding */ exp),\n/* harmony export */   mulScalar: () => (/* binding */ mulScalar)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nfunction mulScalar(F, base, e) {\n    let res;\n\n    if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isZero(e)) return F.zero;\n\n    const n = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.naf(e);\n\n    if (n[n.length-1] == 1) {\n        res = base;\n    } else if (n[n.length-1] == -1) {\n        res = F.neg(base);\n    } else {\n        throw new Error(\"invlaud NAF\");\n    }\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.double(res);\n\n        if (n[i] == 1) {\n            res = F.add(res, base);\n        } else if (n[i] == -1) {\n            res = F.sub(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n/*\nexports.mulScalar = (F, base, e) =>{\n    let res = F.zero;\n    let rem = bigInt(e);\n    let exp = base;\n\n    while (! rem.eq(bigInt.zero)) {\n        if (rem.and(bigInt.one).eq(bigInt.one)) {\n            res = F.add(res, exp);\n        }\n        exp = F.double(exp);\n        rem = rem.shiftRight(1);\n    }\n\n    return res;\n};\n*/\n\n\nfunction exp(F, base, e) {\n\n    if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isZero(e)) return F.one;\n\n    const n = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.bits(e);\n\n    if (n.length==0) return F.one;\n\n    let res = base;\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.square(res);\n\n        if (n[i]) {\n            res = F.mul(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0M7OztBQUcvQjtBQUNQOztBQUVBLFFBQVEsOENBQWE7O0FBRXJCLGNBQWMsMkNBQVU7O0FBRXhCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSwyQkFBMkIsTUFBTTs7QUFFakM7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdPOztBQUVQLFFBQVEsOENBQWE7O0FBRXJCLGNBQWMsNENBQVc7O0FBRXpCOztBQUVBOztBQUVBLDJCQUEyQixNQUFNOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvZnV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIFNjYWxhciBmcm9tIFwiLi9zY2FsYXIuanNcIjtcblxuXG5leHBvcnQgZnVuY3Rpb24gbXVsU2NhbGFyKEYsIGJhc2UsIGUpIHtcbiAgICBsZXQgcmVzO1xuXG4gICAgaWYgKFNjYWxhci5pc1plcm8oZSkpIHJldHVybiBGLnplcm87XG5cbiAgICBjb25zdCBuID0gU2NhbGFyLm5hZihlKTtcblxuICAgIGlmIChuW24ubGVuZ3RoLTFdID09IDEpIHtcbiAgICAgICAgcmVzID0gYmFzZTtcbiAgICB9IGVsc2UgaWYgKG5bbi5sZW5ndGgtMV0gPT0gLTEpIHtcbiAgICAgICAgcmVzID0gRi5uZWcoYmFzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52bGF1ZCBOQUZcIik7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaT1uLmxlbmd0aC0yOyBpPj0wOyBpLS0pIHtcblxuICAgICAgICByZXMgPSBGLmRvdWJsZShyZXMpO1xuXG4gICAgICAgIGlmIChuW2ldID09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9IEYuYWRkKHJlcywgYmFzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobltpXSA9PSAtMSkge1xuICAgICAgICAgICAgcmVzID0gRi5zdWIocmVzLCBiYXNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cblxuLypcbmV4cG9ydHMubXVsU2NhbGFyID0gKEYsIGJhc2UsIGUpID0+e1xuICAgIGxldCByZXMgPSBGLnplcm87XG4gICAgbGV0IHJlbSA9IGJpZ0ludChlKTtcbiAgICBsZXQgZXhwID0gYmFzZTtcblxuICAgIHdoaWxlICghIHJlbS5lcShiaWdJbnQuemVybykpIHtcbiAgICAgICAgaWYgKHJlbS5hbmQoYmlnSW50Lm9uZSkuZXEoYmlnSW50Lm9uZSkpIHtcbiAgICAgICAgICAgIHJlcyA9IEYuYWRkKHJlcywgZXhwKTtcbiAgICAgICAgfVxuICAgICAgICBleHAgPSBGLmRvdWJsZShleHApO1xuICAgICAgICByZW0gPSByZW0uc2hpZnRSaWdodCgxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufTtcbiovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cChGLCBiYXNlLCBlKSB7XG5cbiAgICBpZiAoU2NhbGFyLmlzWmVybyhlKSkgcmV0dXJuIEYub25lO1xuXG4gICAgY29uc3QgbiA9IFNjYWxhci5iaXRzKGUpO1xuXG4gICAgaWYgKG4ubGVuZ3RoPT0wKSByZXR1cm4gRi5vbmU7XG5cbiAgICBsZXQgcmVzID0gYmFzZTtcblxuICAgIGZvciAobGV0IGk9bi5sZW5ndGgtMjsgaT49MDsgaS0tKSB7XG5cbiAgICAgICAgcmVzID0gRi5zcXVhcmUocmVzKTtcblxuICAgICAgICBpZiAobltpXSkge1xuICAgICAgICAgICAgcmVzID0gRi5tdWwocmVzLCBiYXNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/polfield.js":
/*!************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/polfield.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PolField)\n/* harmony export */ });\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nclass PolField {\n    constructor (F) {\n        this.F = F;\n\n        let rem = F.sqrt_t;\n        let s = F.sqrt_s;\n\n        const five = this.F.add(this.F.add(this.F.two, this.F.two), this.F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(five, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n/*        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n    */\n        this._setRoots(15);\n    }\n\n    _setRoots(n) {\n        if (n > this.F.sqrt_s) n = this.s;\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n            this.roots[i] = rootsi;\n        }\n    }\n\n    add(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.add(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.sub(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    mulScalar(p, b) {\n        if (this.F.eq(b, this.F.zero)) return [];\n        if (this.F.eq(b, this.F.one)) return p;\n        const res = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.mul(p[i], b);\n        }\n        return res;\n    }\n\n\n\n    mul(a, b) {\n        if (a.length == 0) return [];\n        if (b.length == 0) return [];\n        if (a.length == 1) return this.mulScalar(b, a[0]);\n        if (b.length == 1) return this.mulScalar(a, b[0]);\n\n        if (b.length > a.length) {\n            [b, a] = [a, b];\n        }\n\n        if ((b.length <= 2) || (b.length < log2(a.length))) {\n            return this.mulNormal(a,b);\n        } else {\n            return this.mulFFT(a,b);\n        }\n    }\n\n    mulNormal(a, b) {\n        let res = [];\n        for (let i=0; i<b.length; i++) {\n            res = this.add(res, this.scaleX(this.mulScalar(a, b[i]), i) );\n        }\n        return res;\n    }\n\n    mulFFT(a,b) {\n        const longestN = Math.max(a.length, b.length);\n        const bitsResult = log2(longestN-1)+2;\n        this._setRoots(bitsResult);\n\n        const m = 1 << bitsResult;\n        const ea = this.extend(a,m);\n        const eb = this.extend(b,m);\n\n        const ta = __fft(this, ea, bitsResult, 0, 1, false);\n        const tb = __fft(this, eb, bitsResult, 0, 1, false);\n\n        const tres = new Array(m);\n\n        for (let i=0; i<m; i++) {\n            tres[i] = this.F.mul(ta[i], tb[i]);\n        }\n\n        const res = __fft(this, tres, bitsResult, 0, 1, true);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return this.reduce(resn);\n    }\n\n\n\n    square(a) {\n        return this.mul(a,a);\n    }\n\n    scaleX(p, n) {\n        if (n==0) {\n            return p;\n        } else if (n>0) {\n            const z = new Array(n).fill(this.F.zero);\n            return z.concat(p);\n        } else {\n            if (-n >= p.length) return [];\n            return p.slice(-n);\n        }\n    }\n\n    eval2(p, x) {\n        let v = this.F.zero;\n        let ix = this.F.one;\n        for (let i=0; i<p.length; i++) {\n            v = this.F.add(v, this.F.mul(p[i], ix));\n            ix = this.F.mul(ix, x);\n        }\n        return v;\n    }\n\n    evaluate(p,x) {\n        const F = this.F;\n        if (p.length == 0) return F.zero;\n        const m = this._next2Power(p.length);\n        const ep = this.extend(p, m);\n\n        return _eval(ep, x, 0, 1, m);\n\n        function _eval(p, x, offset, step, n) {\n            if (n==1) return p[offset];\n            const newX = F.square(x);\n            const res= F.add(\n                _eval(p, newX, offset, step << 1, n >> 1),\n                F.mul(\n                    x,\n                    _eval(p, newX, offset+step , step << 1, n >> 1)));\n            return res;\n        }\n    }\n\n    lagrange(points) {\n        let roots = [this.F.one];\n        for (let i=0; i<points.length; i++) {\n            roots = this.mul(roots, [this.F.neg(points[i][0]), this.F.one]);\n        }\n\n        let sum = [];\n        for (let i=0; i<points.length; i++) {\n            let mpol = this.ruffini(roots, points[i][0]);\n            const factor =\n                this.F.mul(\n                    this.F.inv(this.evaluate(mpol, points[i][0])),\n                    points[i][1]);\n            mpol = this.mulScalar(mpol, factor);\n            sum = this.add(sum, mpol);\n        }\n        return sum;\n    }\n\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res = __fft(this, ep, bits, 0, 1);\n        return res;\n    }\n\n    fft2(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res = __fft2(this, ep, bits);\n        return res;\n    }\n\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res =  __fft(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n\n    ifft2(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res =  __fft2(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n    _fft(pall, bits, offset, step) {\n\n        const n = 1 << bits;\n        if (n==1) {\n            return [ pall[offset] ];\n        }\n\n        const ndiv2 = n >> 1;\n        const p1 = this._fft(pall, bits-1, offset, step*2);\n        const p2 = this._fft(pall, bits-1, offset+step, step*2);\n\n        const out = new Array(n);\n\n        let m= this.F.one;\n        for (let i=0; i<ndiv2; i++) {\n            out[i] = this.F.add(p1[i], this.F.mul(m, p2[i]));\n            out[i+ndiv2] = this.F.sub(p1[i], this.F.mul(m, p2[i]));\n            m = this.F.mul(m, this.w[bits]);\n        }\n\n        return out;\n    }\n\n    extend(p, e) {\n        if (e == p.length) return p;\n        const z = new Array(e-p.length).fill(this.F.zero);\n\n        return p.concat(z);\n    }\n\n    reduce(p) {\n        if (p.length == 0) return p;\n        if (! this.F.eq(p[p.length-1], this.F.zero) ) return p;\n        let i=p.length-1;\n        while( i>0 && this.F.eq(p[i], this.F.zero) ) i--;\n        return p.slice(0, i+1);\n    }\n\n    eq(a, b) {\n        const pa = this.reduce(a);\n        const pb = this.reduce(b);\n\n        if (pa.length != pb.length) return false;\n        for (let i=0; i<pb.length; i++) {\n            if (!this.F.eq(pa[i], pb[i])) return false;\n        }\n\n        return true;\n    }\n\n    ruffini(p, r) {\n        const res = new Array(p.length-1);\n        res[res.length-1] = p[p.length-1];\n        for (let i = res.length-2; i>=0; i--) {\n            res[i] = this.F.add(this.F.mul(res[i+1], r), p[i+1]);\n        }\n        return res;\n    }\n\n    _next2Power(v) {\n        v--;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v++;\n        return v;\n    }\n\n    toString(p) {\n        const ap = this.normalize(p);\n        let S = \"\";\n        for (let i=ap.length-1; i>=0; i--) {\n            if (!this.F.eq(p[i], this.F.zero)) {\n                if (S!=\"\") S += \" + \";\n                S = S + p[i].toString(10);\n                if (i>0) {\n                    S = S + \"x\";\n                    if (i>1) {\n                        S = S + \"^\" +i;\n                    }\n                }\n            }\n        }\n        return S;\n    }\n\n    normalize(p) {\n        const res  = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.normalize(p[i]);\n        }\n        return res;\n    }\n\n\n    _reciprocal(p, bits) {\n        const k = 1 << bits;\n        if (k==1) {\n            return [ this.F.inv(p[0]) ];\n        }\n        const np = this.scaleX(p, -k/2);\n        const q = this._reciprocal(np, bits-1);\n        const a = this.scaleX(this.double(q), 3*k/2-2);\n        const b = this.mul( this.square(q), p);\n\n        return this.scaleX(this.sub(a,b),   -(k-2));\n    }\n\n    // divides x^m / v\n    _div2(m, v) {\n        const kbits = log2(v.length-1)+1;\n        const k = 1 << kbits;\n\n        const scaleV = k - v.length;\n\n        // rec = x^(k - 2) / v* x^scaleV =>\n        // rec = x^(k-2-scaleV)/ v\n        //\n        // res = x^m/v = x^(m + (2*k-2 - scaleV) - (2*k-2 - scaleV)) /v =>\n        // res = rec * x^(m - (2*k-2 - scaleV)) =>\n        // res = rec * x^(m - 2*k + 2 + scaleV)\n\n        const rec = this._reciprocal(this.scaleX(v, scaleV), kbits);\n        const res = this.scaleX(rec, m - 2*k + 2 + scaleV);\n\n        return res;\n    }\n\n    div(_u, _v) {\n        if (_u.length < _v.length) return [];\n        const kbits = log2(_v.length-1)+1;\n        const k = 1 << kbits;\n\n        const u = this.scaleX(_u, k-_v.length);\n        const v = this.scaleX(_v, k-_v.length);\n\n        const n = v.length-1;\n        let m = u.length-1;\n\n        const s = this._reciprocal(v, kbits);\n        let t;\n        if (m>2*n) {\n            t = this.sub(this.scaleX([this.F.one], 2*n), this.mul(s, v));\n        }\n\n        let q = [];\n        let rem = u;\n        let us, ut;\n        let finish = false;\n\n        while (!finish) {\n            us = this.mul(rem, s);\n            q = this.add(q, this.scaleX(us, -2*n));\n\n            if ( m > 2*n ) {\n                ut = this.mul(rem, t);\n                rem = this.scaleX(ut, -2*n);\n                m = rem.length-1;\n            } else {\n                finish = true;\n            }\n        }\n\n        return q;\n    }\n\n\n    // returns the ith nth-root of one\n    oneRoot(n, i) {\n        let nbits = log2(n-1)+1;\n        let res = this.F.one;\n        let r = i;\n\n        if(i>=n) {\n            throw new Error(\"Given 'i' should be lower than 'n'\");\n        }\n        else if (1<<nbits !== n) {\n            throw new Error(`Internal errlr: ${n} should equal ${1<<nbits}`);\n        }\n\n        while (r>0) {\n            if (r & 1 == 1) {\n                res = this.F.mul(res, this.w[nbits]);\n            }\n            r = r >> 1;\n            nbits --;\n        }\n        return res;\n    }\n\n    computeVanishingPolinomial(bits, t) {\n        const m = 1 << bits;\n        return this.F.sub(this.F.pow(t, m), this.F.one);\n    }\n\n    evaluateLagrangePolynomials(bits, t) {\n        const m= 1 << bits;\n        const tm = this.F.pow(t, m);\n        const u= new Array(m).fill(this.F.zero);\n        this._setRoots(bits);\n        const omega = this.w[bits];\n\n        if (this.F.eq(tm, this.F.one)) {\n            for (let i = 0; i < m; i++) {\n                if (this.F.eq(this.roots[bits][0],t)) { // i.e., t equals omega^i\n                    u[i] = this.F.one;\n                    return u;\n                }\n            }\n        }\n\n        const z = this.F.sub(tm, this.F.one);\n        //        let l = this.F.mul(z,  this.F.pow(this.F.twoinv, m));\n        let l = this.F.mul(z,  this.F.inv(this.F.e(m)));\n        for (let i = 0; i < m; i++) {\n            u[i] = this.F.mul(l, this.F.inv(this.F.sub(t,this.roots[bits][i])));\n            l = this.F.mul(l, omega);\n        }\n\n        return u;\n    }\n\n    log2(V) {\n        return log2(V);\n    }\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.F.add(pall[offset], pall[offset + step]),\n            PF.F.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\n\nfunction __fft2(PF, pall, bits) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[0] ];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft2(PF, pall.slice(0, ndiv2), bits-1);\n    const p2 = __fft2(PF, pall.slice(ndiv2), bits-1);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction rev(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\nfunction __bitReverse(p, bits) {\n    for (let k=0; k<p.length; k++) {\n        const r = rev(k, bits);\n        if (r>k) {\n            const tmp= p[k];\n            p[k] = p[r];\n            p[r] = tmp;\n        }\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9wb2xmaWVsZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxHQUFHLGVBQWUsU0FBUztBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkMsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9wb2xmaWVsZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKlxuICAgIFRoaXMgbGlicmFyeSBkb2VzIG9wZXJhdGlvbnMgb24gcG9seW5vbWlhbHMgd2l0aCBjb2VmZmljaWVudHMgaW4gYSBmaWVsZCBGLlxuXG4gICAgQSBwb2x5bm9taWFsIFAoeCkgPSBwMCArIHAxICogeCArIHAyICogeF4yICsgLi4uICsgcG4gKiB4Xm4gIGlzIHJlcHJlc2VudGVkXG4gICAgYnkgdGhlIGFycmF5IFsgcDAsIHAxLCBwMiwgLi4uICwgcG4gXS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2xGaWVsZCB7XG4gICAgY29uc3RydWN0b3IgKEYpIHtcbiAgICAgICAgdGhpcy5GID0gRjtcblxuICAgICAgICBsZXQgcmVtID0gRi5zcXJ0X3Q7XG4gICAgICAgIGxldCBzID0gRi5zcXJ0X3M7XG5cbiAgICAgICAgY29uc3QgZml2ZSA9IHRoaXMuRi5hZGQodGhpcy5GLmFkZCh0aGlzLkYudHdvLCB0aGlzLkYudHdvKSwgdGhpcy5GLm9uZSk7XG5cbiAgICAgICAgdGhpcy53ID0gbmV3IEFycmF5KHMrMSk7XG4gICAgICAgIHRoaXMud2kgPSBuZXcgQXJyYXkocysxKTtcbiAgICAgICAgdGhpcy53W3NdID0gdGhpcy5GLnBvdyhmaXZlLCByZW0pO1xuICAgICAgICB0aGlzLndpW3NdID0gdGhpcy5GLmludih0aGlzLndbc10pO1xuXG4gICAgICAgIGxldCBuPXMtMTtcbiAgICAgICAgd2hpbGUgKG4+PTApIHtcbiAgICAgICAgICAgIHRoaXMud1tuXSA9IHRoaXMuRi5zcXVhcmUodGhpcy53W24rMV0pO1xuICAgICAgICAgICAgdGhpcy53aVtuXSA9IHRoaXMuRi5zcXVhcmUodGhpcy53aVtuKzFdKTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5yb290cyA9IFtdO1xuLyogICAgICAgIGZvciAobGV0IGk9MDsgaTwxNjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgciA9IHRoaXMuRi5vbmU7XG4gICAgICAgICAgICBuID0gMSA8PCBpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdHNpID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG47IGorKykge1xuICAgICAgICAgICAgICAgIHJvb3RzaVtqXSA9IHI7XG4gICAgICAgICAgICAgICAgciA9IHRoaXMuRi5tdWwociwgdGhpcy53W2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yb290cy5wdXNoKHJvb3RzaSk7XG4gICAgICAgIH1cbiAgICAqL1xuICAgICAgICB0aGlzLl9zZXRSb290cygxNSk7XG4gICAgfVxuXG4gICAgX3NldFJvb3RzKG4pIHtcbiAgICAgICAgaWYgKG4gPiB0aGlzLkYuc3FydF9zKSBuID0gdGhpcy5zO1xuICAgICAgICBmb3IgKGxldCBpPW47IChpPj0wKSAmJiAoIXRoaXMucm9vdHNbaV0pOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCByID0gdGhpcy5GLm9uZTtcbiAgICAgICAgICAgIGNvbnN0IG5yb290cyA9IDEgPDwgaTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RzaSA9IG5ldyBBcnJheShucm9vdHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5yb290czsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNpW2pdID0gcjtcbiAgICAgICAgICAgICAgICByID0gdGhpcy5GLm11bChyLCB0aGlzLndbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb290c1tpXSA9IHJvb3RzaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZChhLCBiKSB7XG4gICAgICAgIGNvbnN0IG0gPSBNYXRoLm1heChhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IHRoaXMuRi5hZGQoYVtpXSB8fCB0aGlzLkYuemVybywgYltpXSB8fCB0aGlzLkYuemVybyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKHJlcyk7XG4gICAgfVxuXG4gICAgZG91YmxlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGEsYSk7XG4gICAgfVxuXG4gICAgc3ViKGEsIGIpIHtcbiAgICAgICAgY29uc3QgbSA9IE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG07IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5GLnN1YihhW2ldIHx8IHRoaXMuRi56ZXJvLCBiW2ldIHx8IHRoaXMuRi56ZXJvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UocmVzKTtcbiAgICB9XG5cbiAgICBtdWxTY2FsYXIocCwgYikge1xuICAgICAgICBpZiAodGhpcy5GLmVxKGIsIHRoaXMuRi56ZXJvKSkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAodGhpcy5GLmVxKGIsIHRoaXMuRi5vbmUpKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IHRoaXMuRi5tdWwocFtpXSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxuXG4gICAgbXVsKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoID09IDApIHJldHVybiBbXTtcbiAgICAgICAgaWYgKGIubGVuZ3RoID09IDApIHJldHVybiBbXTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLm11bFNjYWxhcihiLCBhWzBdKTtcbiAgICAgICAgaWYgKGIubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLm11bFNjYWxhcihhLCBiWzBdKTtcblxuICAgICAgICBpZiAoYi5sZW5ndGggPiBhLmxlbmd0aCkge1xuICAgICAgICAgICAgW2IsIGFdID0gW2EsIGJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChiLmxlbmd0aCA8PSAyKSB8fCAoYi5sZW5ndGggPCBsb2cyKGEubGVuZ3RoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bE5vcm1hbChhLGIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsRkZUKGEsYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtdWxOb3JtYWwoYSwgYikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXMgPSB0aGlzLmFkZChyZXMsIHRoaXMuc2NhbGVYKHRoaXMubXVsU2NhbGFyKGEsIGJbaV0pLCBpKSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgbXVsRkZUKGEsYikge1xuICAgICAgICBjb25zdCBsb25nZXN0TiA9IE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGJpdHNSZXN1bHQgPSBsb2cyKGxvbmdlc3ROLTEpKzI7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHNSZXN1bHQpO1xuXG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHNSZXN1bHQ7XG4gICAgICAgIGNvbnN0IGVhID0gdGhpcy5leHRlbmQoYSxtKTtcbiAgICAgICAgY29uc3QgZWIgPSB0aGlzLmV4dGVuZChiLG0pO1xuXG4gICAgICAgIGNvbnN0IHRhID0gX19mZnQodGhpcywgZWEsIGJpdHNSZXN1bHQsIDAsIDEsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgdGIgPSBfX2ZmdCh0aGlzLCBlYiwgYml0c1Jlc3VsdCwgMCwgMSwgZmFsc2UpO1xuXG4gICAgICAgIGNvbnN0IHRyZXMgPSBuZXcgQXJyYXkobSk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG07IGkrKykge1xuICAgICAgICAgICAgdHJlc1tpXSA9IHRoaXMuRi5tdWwodGFbaV0sIHRiW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlcyA9IF9fZmZ0KHRoaXMsIHRyZXMsIGJpdHNSZXN1bHQsIDAsIDEsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IHR3b2ludm0gPSB0aGlzLkYuaW52KCB0aGlzLkYubXVsU2NhbGFyKHRoaXMuRi5vbmUsIG0pICk7XG4gICAgICAgIGNvbnN0IHJlc24gPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgIHJlc25baV0gPSB0aGlzLkYubXVsKHJlc1sobS1pKSVtXSwgdHdvaW52bSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UocmVzbik7XG4gICAgfVxuXG5cblxuICAgIHNxdWFyZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bChhLGEpO1xuICAgIH1cblxuICAgIHNjYWxlWChwLCBuKSB7XG4gICAgICAgIGlmIChuPT0wKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSBlbHNlIGlmIChuPjApIHtcbiAgICAgICAgICAgIGNvbnN0IHogPSBuZXcgQXJyYXkobikuZmlsbCh0aGlzLkYuemVybyk7XG4gICAgICAgICAgICByZXR1cm4gei5jb25jYXQocCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoLW4gPj0gcC5sZW5ndGgpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBwLnNsaWNlKC1uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV2YWwyKHAsIHgpIHtcbiAgICAgICAgbGV0IHYgPSB0aGlzLkYuemVybztcbiAgICAgICAgbGV0IGl4ID0gdGhpcy5GLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLkYuYWRkKHYsIHRoaXMuRi5tdWwocFtpXSwgaXgpKTtcbiAgICAgICAgICAgIGl4ID0gdGhpcy5GLm11bChpeCwgeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUocCx4KSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG4gICAgICAgIGlmIChwLmxlbmd0aCA9PSAwKSByZXR1cm4gRi56ZXJvO1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fbmV4dDJQb3dlcihwLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGVwID0gdGhpcy5leHRlbmQocCwgbSk7XG5cbiAgICAgICAgcmV0dXJuIF9ldmFsKGVwLCB4LCAwLCAxLCBtKTtcblxuICAgICAgICBmdW5jdGlvbiBfZXZhbChwLCB4LCBvZmZzZXQsIHN0ZXAsIG4pIHtcbiAgICAgICAgICAgIGlmIChuPT0xKSByZXR1cm4gcFtvZmZzZXRdO1xuICAgICAgICAgICAgY29uc3QgbmV3WCA9IEYuc3F1YXJlKHgpO1xuICAgICAgICAgICAgY29uc3QgcmVzPSBGLmFkZChcbiAgICAgICAgICAgICAgICBfZXZhbChwLCBuZXdYLCBvZmZzZXQsIHN0ZXAgPDwgMSwgbiA+PiAxKSxcbiAgICAgICAgICAgICAgICBGLm11bChcbiAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgX2V2YWwocCwgbmV3WCwgb2Zmc2V0K3N0ZXAgLCBzdGVwIDw8IDEsIG4gPj4gMSkpKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsYWdyYW5nZShwb2ludHMpIHtcbiAgICAgICAgbGV0IHJvb3RzID0gW3RoaXMuRi5vbmVdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByb290cyA9IHRoaXMubXVsKHJvb3RzLCBbdGhpcy5GLm5lZyhwb2ludHNbaV1bMF0pLCB0aGlzLkYub25lXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3VtID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtcG9sID0gdGhpcy5ydWZmaW5pKHJvb3RzLCBwb2ludHNbaV1bMF0pO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yID1cbiAgICAgICAgICAgICAgICB0aGlzLkYubXVsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuaW52KHRoaXMuZXZhbHVhdGUobXBvbCwgcG9pbnRzW2ldWzBdKSksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tpXVsxXSk7XG4gICAgICAgICAgICBtcG9sID0gdGhpcy5tdWxTY2FsYXIobXBvbCwgZmFjdG9yKTtcbiAgICAgICAgICAgIHN1bSA9IHRoaXMuYWRkKHN1bSwgbXBvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cblxuICAgIGZmdChwKSB7XG4gICAgICAgIGlmIChwLmxlbmd0aCA8PSAxKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgYml0cyA9IGxvZzIocC5sZW5ndGgtMSkrMTtcbiAgICAgICAgdGhpcy5fc2V0Um9vdHMoYml0cyk7XG5cbiAgICAgICAgY29uc3QgbSA9IDEgPDwgYml0cztcbiAgICAgICAgY29uc3QgZXAgPSB0aGlzLmV4dGVuZChwLCBtKTtcbiAgICAgICAgY29uc3QgcmVzID0gX19mZnQodGhpcywgZXAsIGJpdHMsIDAsIDEpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZmdDIocCkge1xuICAgICAgICBpZiAocC5sZW5ndGggPD0gMSkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuXG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHM7XG4gICAgICAgIGNvbnN0IGVwID0gdGhpcy5leHRlbmQocCwgbSk7XG4gICAgICAgIF9fYml0UmV2ZXJzZShlcCwgYml0cyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IF9fZmZ0Mih0aGlzLCBlcCwgYml0cyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG5cbiAgICBpZmZ0KHApIHtcblxuICAgICAgICBpZiAocC5sZW5ndGggPD0gMSkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuICAgICAgICBjb25zdCBtID0gMSA8PCBiaXRzO1xuICAgICAgICBjb25zdCBlcCA9IHRoaXMuZXh0ZW5kKHAsIG0pO1xuICAgICAgICBjb25zdCByZXMgPSAgX19mZnQodGhpcywgZXAsIGJpdHMsIDAsIDEpO1xuXG4gICAgICAgIGNvbnN0IHR3b2ludm0gPSB0aGlzLkYuaW52KCB0aGlzLkYubXVsU2NhbGFyKHRoaXMuRi5vbmUsIG0pICk7XG4gICAgICAgIGNvbnN0IHJlc24gPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgIHJlc25baV0gPSB0aGlzLkYubXVsKHJlc1sobS1pKSVtXSwgdHdvaW52bSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzbjtcblxuICAgIH1cblxuXG4gICAgaWZmdDIocCkge1xuXG4gICAgICAgIGlmIChwLmxlbmd0aCA8PSAxKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgYml0cyA9IGxvZzIocC5sZW5ndGgtMSkrMTtcbiAgICAgICAgdGhpcy5fc2V0Um9vdHMoYml0cyk7XG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHM7XG4gICAgICAgIGNvbnN0IGVwID0gdGhpcy5leHRlbmQocCwgbSk7XG4gICAgICAgIF9fYml0UmV2ZXJzZShlcCwgYml0cyk7XG4gICAgICAgIGNvbnN0IHJlcyA9ICBfX2ZmdDIodGhpcywgZXAsIGJpdHMsIDAsIDEpO1xuXG4gICAgICAgIGNvbnN0IHR3b2ludm0gPSB0aGlzLkYuaW52KCB0aGlzLkYubXVsU2NhbGFyKHRoaXMuRi5vbmUsIG0pICk7XG4gICAgICAgIGNvbnN0IHJlc24gPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgIHJlc25baV0gPSB0aGlzLkYubXVsKHJlc1sobS1pKSVtXSwgdHdvaW52bSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzbjtcblxuICAgIH1cblxuICAgIF9mZnQocGFsbCwgYml0cywgb2Zmc2V0LCBzdGVwKSB7XG5cbiAgICAgICAgY29uc3QgbiA9IDEgPDwgYml0cztcbiAgICAgICAgaWYgKG49PTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbIHBhbGxbb2Zmc2V0XSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmRpdjIgPSBuID4+IDE7XG4gICAgICAgIGNvbnN0IHAxID0gdGhpcy5fZmZ0KHBhbGwsIGJpdHMtMSwgb2Zmc2V0LCBzdGVwKjIpO1xuICAgICAgICBjb25zdCBwMiA9IHRoaXMuX2ZmdChwYWxsLCBiaXRzLTEsIG9mZnNldCtzdGVwLCBzdGVwKjIpO1xuXG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBBcnJheShuKTtcblxuICAgICAgICBsZXQgbT0gdGhpcy5GLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5kaXYyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IHRoaXMuRi5hZGQocDFbaV0sIHRoaXMuRi5tdWwobSwgcDJbaV0pKTtcbiAgICAgICAgICAgIG91dFtpK25kaXYyXSA9IHRoaXMuRi5zdWIocDFbaV0sIHRoaXMuRi5tdWwobSwgcDJbaV0pKTtcbiAgICAgICAgICAgIG0gPSB0aGlzLkYubXVsKG0sIHRoaXMud1tiaXRzXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGV4dGVuZChwLCBlKSB7XG4gICAgICAgIGlmIChlID09IHAubGVuZ3RoKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgeiA9IG5ldyBBcnJheShlLXAubGVuZ3RoKS5maWxsKHRoaXMuRi56ZXJvKTtcblxuICAgICAgICByZXR1cm4gcC5jb25jYXQoeik7XG4gICAgfVxuXG4gICAgcmVkdWNlKHApIHtcbiAgICAgICAgaWYgKHAubGVuZ3RoID09IDApIHJldHVybiBwO1xuICAgICAgICBpZiAoISB0aGlzLkYuZXEocFtwLmxlbmd0aC0xXSwgdGhpcy5GLnplcm8pICkgcmV0dXJuIHA7XG4gICAgICAgIGxldCBpPXAubGVuZ3RoLTE7XG4gICAgICAgIHdoaWxlKCBpPjAgJiYgdGhpcy5GLmVxKHBbaV0sIHRoaXMuRi56ZXJvKSApIGktLTtcbiAgICAgICAgcmV0dXJuIHAuc2xpY2UoMCwgaSsxKTtcbiAgICB9XG5cbiAgICBlcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IHBhID0gdGhpcy5yZWR1Y2UoYSk7XG4gICAgICAgIGNvbnN0IHBiID0gdGhpcy5yZWR1Y2UoYik7XG5cbiAgICAgICAgaWYgKHBhLmxlbmd0aCAhPSBwYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuRi5lcShwYVtpXSwgcGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBydWZmaW5pKHAsIHIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEFycmF5KHAubGVuZ3RoLTEpO1xuICAgICAgICByZXNbcmVzLmxlbmd0aC0xXSA9IHBbcC5sZW5ndGgtMV07XG4gICAgICAgIGZvciAobGV0IGkgPSByZXMubGVuZ3RoLTI7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5GLmFkZCh0aGlzLkYubXVsKHJlc1tpKzFdLCByKSwgcFtpKzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIF9uZXh0MlBvd2VyKHYpIHtcbiAgICAgICAgdi0tO1xuICAgICAgICB2IHw9IHYgPj4gMTtcbiAgICAgICAgdiB8PSB2ID4+IDI7XG4gICAgICAgIHYgfD0gdiA+PiA0O1xuICAgICAgICB2IHw9IHYgPj4gODtcbiAgICAgICAgdiB8PSB2ID4+IDE2O1xuICAgICAgICB2Kys7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKHApIHtcbiAgICAgICAgY29uc3QgYXAgPSB0aGlzLm5vcm1hbGl6ZShwKTtcbiAgICAgICAgbGV0IFMgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpPWFwLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5GLmVxKHBbaV0sIHRoaXMuRi56ZXJvKSkge1xuICAgICAgICAgICAgICAgIGlmIChTIT1cIlwiKSBTICs9IFwiICsgXCI7XG4gICAgICAgICAgICAgICAgUyA9IFMgKyBwW2ldLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoaT4wKSB7XG4gICAgICAgICAgICAgICAgICAgIFMgPSBTICsgXCJ4XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpPjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMgPSBTICsgXCJeXCIgK2k7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFM7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplKHApIHtcbiAgICAgICAgY29uc3QgcmVzICA9IG5ldyBBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSB0aGlzLkYubm9ybWFsaXplKHBbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG5cbiAgICBfcmVjaXByb2NhbChwLCBiaXRzKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIDw8IGJpdHM7XG4gICAgICAgIGlmIChrPT0xKSB7XG4gICAgICAgICAgICByZXR1cm4gWyB0aGlzLkYuaW52KHBbMF0pIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnAgPSB0aGlzLnNjYWxlWChwLCAtay8yKTtcbiAgICAgICAgY29uc3QgcSA9IHRoaXMuX3JlY2lwcm9jYWwobnAsIGJpdHMtMSk7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLnNjYWxlWCh0aGlzLmRvdWJsZShxKSwgMyprLzItMik7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLm11bCggdGhpcy5zcXVhcmUocSksIHApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlWCh0aGlzLnN1YihhLGIpLCAgIC0oay0yKSk7XG4gICAgfVxuXG4gICAgLy8gZGl2aWRlcyB4Xm0gLyB2XG4gICAgX2RpdjIobSwgdikge1xuICAgICAgICBjb25zdCBrYml0cyA9IGxvZzIodi5sZW5ndGgtMSkrMTtcbiAgICAgICAgY29uc3QgayA9IDEgPDwga2JpdHM7XG5cbiAgICAgICAgY29uc3Qgc2NhbGVWID0gayAtIHYubGVuZ3RoO1xuXG4gICAgICAgIC8vIHJlYyA9IHheKGsgLSAyKSAvIHYqIHhec2NhbGVWID0+XG4gICAgICAgIC8vIHJlYyA9IHheKGstMi1zY2FsZVYpLyB2XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHJlcyA9IHhebS92ID0geF4obSArICgyKmstMiAtIHNjYWxlVikgLSAoMiprLTIgLSBzY2FsZVYpKSAvdiA9PlxuICAgICAgICAvLyByZXMgPSByZWMgKiB4XihtIC0gKDIqay0yIC0gc2NhbGVWKSkgPT5cbiAgICAgICAgLy8gcmVzID0gcmVjICogeF4obSAtIDIqayArIDIgKyBzY2FsZVYpXG5cbiAgICAgICAgY29uc3QgcmVjID0gdGhpcy5fcmVjaXByb2NhbCh0aGlzLnNjYWxlWCh2LCBzY2FsZVYpLCBrYml0cyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuc2NhbGVYKHJlYywgbSAtIDIqayArIDIgKyBzY2FsZVYpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZGl2KF91LCBfdikge1xuICAgICAgICBpZiAoX3UubGVuZ3RoIDwgX3YubGVuZ3RoKSByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IGtiaXRzID0gbG9nMihfdi5sZW5ndGgtMSkrMTtcbiAgICAgICAgY29uc3QgayA9IDEgPDwga2JpdHM7XG5cbiAgICAgICAgY29uc3QgdSA9IHRoaXMuc2NhbGVYKF91LCBrLV92Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLnNjYWxlWChfdiwgay1fdi5sZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IG4gPSB2Lmxlbmd0aC0xO1xuICAgICAgICBsZXQgbSA9IHUubGVuZ3RoLTE7XG5cbiAgICAgICAgY29uc3QgcyA9IHRoaXMuX3JlY2lwcm9jYWwodiwga2JpdHMpO1xuICAgICAgICBsZXQgdDtcbiAgICAgICAgaWYgKG0+MipuKSB7XG4gICAgICAgICAgICB0ID0gdGhpcy5zdWIodGhpcy5zY2FsZVgoW3RoaXMuRi5vbmVdLCAyKm4pLCB0aGlzLm11bChzLCB2KSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcSA9IFtdO1xuICAgICAgICBsZXQgcmVtID0gdTtcbiAgICAgICAgbGV0IHVzLCB1dDtcbiAgICAgICAgbGV0IGZpbmlzaCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlICghZmluaXNoKSB7XG4gICAgICAgICAgICB1cyA9IHRoaXMubXVsKHJlbSwgcyk7XG4gICAgICAgICAgICBxID0gdGhpcy5hZGQocSwgdGhpcy5zY2FsZVgodXMsIC0yKm4pKTtcblxuICAgICAgICAgICAgaWYgKCBtID4gMipuICkge1xuICAgICAgICAgICAgICAgIHV0ID0gdGhpcy5tdWwocmVtLCB0KTtcbiAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnNjYWxlWCh1dCwgLTIqbik7XG4gICAgICAgICAgICAgICAgbSA9IHJlbS5sZW5ndGgtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluaXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxO1xuICAgIH1cblxuXG4gICAgLy8gcmV0dXJucyB0aGUgaXRoIG50aC1yb290IG9mIG9uZVxuICAgIG9uZVJvb3QobiwgaSkge1xuICAgICAgICBsZXQgbmJpdHMgPSBsb2cyKG4tMSkrMTtcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuRi5vbmU7XG4gICAgICAgIGxldCByID0gaTtcblxuICAgICAgICBpZihpPj1uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiAnaScgc2hvdWxkIGJlIGxvd2VyIHRoYW4gJ24nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKDE8PG5iaXRzICE9PSBuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIGVycmxyOiAke259IHNob3VsZCBlcXVhbCAkezE8PG5iaXRzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHI+MCkge1xuICAgICAgICAgICAgaWYgKHIgJiAxID09IDEpIHtcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLkYubXVsKHJlcywgdGhpcy53W25iaXRzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByID0gciA+PiAxO1xuICAgICAgICAgICAgbmJpdHMgLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBjb21wdXRlVmFuaXNoaW5nUG9saW5vbWlhbChiaXRzLCB0KSB7XG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHM7XG4gICAgICAgIHJldHVybiB0aGlzLkYuc3ViKHRoaXMuRi5wb3codCwgbSksIHRoaXMuRi5vbmUpO1xuICAgIH1cblxuICAgIGV2YWx1YXRlTGFncmFuZ2VQb2x5bm9taWFscyhiaXRzLCB0KSB7XG4gICAgICAgIGNvbnN0IG09IDEgPDwgYml0cztcbiAgICAgICAgY29uc3QgdG0gPSB0aGlzLkYucG93KHQsIG0pO1xuICAgICAgICBjb25zdCB1PSBuZXcgQXJyYXkobSkuZmlsbCh0aGlzLkYuemVybyk7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuICAgICAgICBjb25zdCBvbWVnYSA9IHRoaXMud1tiaXRzXTtcblxuICAgICAgICBpZiAodGhpcy5GLmVxKHRtLCB0aGlzLkYub25lKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5GLmVxKHRoaXMucm9vdHNbYml0c11bMF0sdCkpIHsgLy8gaS5lLiwgdCBlcXVhbHMgb21lZ2FeaVxuICAgICAgICAgICAgICAgICAgICB1W2ldID0gdGhpcy5GLm9uZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeiA9IHRoaXMuRi5zdWIodG0sIHRoaXMuRi5vbmUpO1xuICAgICAgICAvLyAgICAgICAgbGV0IGwgPSB0aGlzLkYubXVsKHosICB0aGlzLkYucG93KHRoaXMuRi50d29pbnYsIG0pKTtcbiAgICAgICAgbGV0IGwgPSB0aGlzLkYubXVsKHosICB0aGlzLkYuaW52KHRoaXMuRi5lKG0pKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICB1W2ldID0gdGhpcy5GLm11bChsLCB0aGlzLkYuaW52KHRoaXMuRi5zdWIodCx0aGlzLnJvb3RzW2JpdHNdW2ldKSkpO1xuICAgICAgICAgICAgbCA9IHRoaXMuRi5tdWwobCwgb21lZ2EpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHU7XG4gICAgfVxuXG4gICAgbG9nMihWKSB7XG4gICAgICAgIHJldHVybiBsb2cyKFYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbG9nMiggViApXG57XG4gICAgcmV0dXJuKCAoICggViAmIDB4RkZGRjAwMDAgKSAhPT0gMCA/ICggViAmPSAweEZGRkYwMDAwLCAxNiApIDogMCApIHwgKCAoIFYgJiAweEZGMDBGRjAwICkgIT09IDAgPyAoIFYgJj0gMHhGRjAwRkYwMCwgOCApIDogMCApIHwgKCAoIFYgJiAweEYwRjBGMEYwICkgIT09IDAgPyAoIFYgJj0gMHhGMEYwRjBGMCwgNCApIDogMCApIHwgKCAoIFYgJiAweENDQ0NDQ0NDICkgIT09IDAgPyAoIFYgJj0gMHhDQ0NDQ0NDQywgMiApIDogMCApIHwgKCAoIFYgJiAweEFBQUFBQUFBICkgIT09IDAgKSApO1xufVxuXG5cbmZ1bmN0aW9uIF9fZmZ0KFBGLCBwYWxsLCBiaXRzLCBvZmZzZXQsIHN0ZXApIHtcblxuICAgIGNvbnN0IG4gPSAxIDw8IGJpdHM7XG4gICAgaWYgKG49PTEpIHtcbiAgICAgICAgcmV0dXJuIFsgcGFsbFtvZmZzZXRdIF07XG4gICAgfSBlbHNlIGlmIChuPT0yKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBQRi5GLmFkZChwYWxsW29mZnNldF0sIHBhbGxbb2Zmc2V0ICsgc3RlcF0pLFxuICAgICAgICAgICAgUEYuRi5zdWIocGFsbFtvZmZzZXRdLCBwYWxsW29mZnNldCArIHN0ZXBdKV07XG4gICAgfVxuXG4gICAgY29uc3QgbmRpdjIgPSBuID4+IDE7XG4gICAgY29uc3QgcDEgPSBfX2ZmdChQRiwgcGFsbCwgYml0cy0xLCBvZmZzZXQsIHN0ZXAqMik7XG4gICAgY29uc3QgcDIgPSBfX2ZmdChQRiwgcGFsbCwgYml0cy0xLCBvZmZzZXQrc3RlcCwgc3RlcCoyKTtcblxuICAgIGNvbnN0IG91dCA9IG5ldyBBcnJheShuKTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxuZGl2MjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IFBGLkYuYWRkKHAxW2ldLCBQRi5GLm11bChQRi5yb290c1tiaXRzXVtpXSwgcDJbaV0pKTtcbiAgICAgICAgb3V0W2krbmRpdjJdID0gUEYuRi5zdWIocDFbaV0sIFBGLkYubXVsKFBGLnJvb3RzW2JpdHNdW2ldLCBwMltpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cblxuZnVuY3Rpb24gX19mZnQyKFBGLCBwYWxsLCBiaXRzKSB7XG5cbiAgICBjb25zdCBuID0gMSA8PCBiaXRzO1xuICAgIGlmIChuPT0xKSB7XG4gICAgICAgIHJldHVybiBbIHBhbGxbMF0gXTtcbiAgICB9XG5cbiAgICBjb25zdCBuZGl2MiA9IG4gPj4gMTtcbiAgICBjb25zdCBwMSA9IF9fZmZ0MihQRiwgcGFsbC5zbGljZSgwLCBuZGl2MiksIGJpdHMtMSk7XG4gICAgY29uc3QgcDIgPSBfX2ZmdDIoUEYsIHBhbGwuc2xpY2UobmRpdjIpLCBiaXRzLTEpO1xuXG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgZm9yIChsZXQgaT0wOyBpPG5kaXYyOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gUEYuRi5hZGQocDFbaV0sIFBGLkYubXVsKFBGLnJvb3RzW2JpdHNdW2ldLCBwMltpXSkpO1xuICAgICAgICBvdXRbaStuZGl2Ml0gPSBQRi5GLnN1YihwMVtpXSwgUEYuRi5tdWwoUEYucm9vdHNbYml0c11baV0sIHAyW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuY29uc3QgX3JldlRhYmxlID0gW107XG5mb3IgKGxldCBpPTA7IGk8MjU2OyBpKyspIHtcbiAgICBfcmV2VGFibGVbaV0gPSBfcmV2U2xvdyhpLCA4KTtcbn1cblxuZnVuY3Rpb24gX3JldlNsb3coaWR4LCBiaXRzKSB7XG4gICAgbGV0IHJlcyA9MDtcbiAgICBsZXQgYSA9IGlkeDtcbiAgICBmb3IgKGxldCBpPTA7IGk8Yml0czsgaSsrKSB7XG4gICAgICAgIHJlcyA8PD0gMTtcbiAgICAgICAgcmVzID0gcmVzIHwgKGEgJjEpO1xuICAgICAgICBhID4+PTE7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHJldihpZHgsIGJpdHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBfcmV2VGFibGVbaWR4ID4+PiAyNF0gfFxuICAgICAgICAoX3JldlRhYmxlWyhpZHggPj4+IDE2KSAmIDB4RkZdIDw8IDgpIHxcbiAgICAgICAgKF9yZXZUYWJsZVsoaWR4ID4+PiA4KSAmIDB4RkZdIDw8IDE2KSB8XG4gICAgICAgIChfcmV2VGFibGVbaWR4ICYgMHhGRl0gPDwgMjQpXG4gICAgKSA+Pj4gKDMyLWJpdHMpO1xufVxuXG5mdW5jdGlvbiBfX2JpdFJldmVyc2UocCwgYml0cykge1xuICAgIGZvciAobGV0IGs9MDsgazxwLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGNvbnN0IHIgPSByZXYoaywgYml0cyk7XG4gICAgICAgIGlmIChyPmspIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcD0gcFtrXTtcbiAgICAgICAgICAgIHBba10gPSBwW3JdO1xuICAgICAgICAgICAgcFtyXSA9IHRtcDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/polfield.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/random.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getRandomBytes: () => (/* binding */ getRandomBytes),\n/* harmony export */   getRandomSeed: () => (/* binding */ getRandomSeed),\n/* harmony export */   getThreadRng: () => (/* binding */ getThreadRng)\n/* harmony export */ });\n/* harmony import */ var _chacha_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chacha.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n\n\n\nfunction getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (false) {}\n    else { // NodeJS\n        crypto__WEBPACK_IMPORTED_MODULE_1__.randomFillSync(array);\n    }\n    return array;\n}\n\nfunction getRandomSeed() {\n    const arr = getRandomBytes(32);\n    const arrV = new Uint32Array(arr.buffer);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed.push(arrV[i]);\n    }\n    return seed;\n}\n\nlet threadRng = null;\n\nfunction getThreadRng() {\n    if (threadRng) return threadRng;\n    threadRng = new _chacha_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](getRandomSeed());\n    return threadRng;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9yYW5kb20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUM7QUFDTDs7QUFFckI7QUFDUDtBQUNBLFFBQVEsS0FBZSxFQUFFLEVBUXBCO0FBQ0wsV0FBVztBQUNYLFFBQVEsa0RBQXFCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQSxvQkFBb0Isa0RBQU07QUFDMUI7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL3JhbmRvbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2hhQ2hhIGZyb20gXCIuL2NoYWNoYS5qc1wiO1xuaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhuKSB7XG4gICAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3NlcikgeyAvLyBCcm93c2VyXG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpIHsgLy8gU3VwcG9ydGVkXG4gICAgICAgICAgICBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgICAgICB9IGVsc2UgeyAvLyBmYWxsYmFja1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gKE1hdGgucmFuZG9tKCkqNDI5NDk2NzI5Nik+Pj4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgeyAvLyBOb2RlSlNcbiAgICAgICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZG9tU2VlZCgpIHtcbiAgICBjb25zdCBhcnIgPSBnZXRSYW5kb21CeXRlcygzMik7XG4gICAgY29uc3QgYXJyViA9IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyKTtcbiAgICBjb25zdCBzZWVkID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPDg7IGkrKykge1xuICAgICAgICBzZWVkLnB1c2goYXJyVltpXSk7XG4gICAgfVxuICAgIHJldHVybiBzZWVkO1xufVxuXG5sZXQgdGhyZWFkUm5nID0gbnVsbDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRocmVhZFJuZygpIHtcbiAgICBpZiAodGhyZWFkUm5nKSByZXR1cm4gdGhyZWFkUm5nO1xuICAgIHRocmVhZFJuZyA9IG5ldyBDaGFDaGEoZ2V0UmFuZG9tU2VlZCgpKTtcbiAgICByZXR1cm4gdGhyZWFkUm5nO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abs: () => (/* binding */ abs),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   band: () => (/* binding */ band),\n/* harmony export */   bitLength: () => (/* binding */ bitLength),\n/* harmony export */   bits: () => (/* binding */ bits),\n/* harmony export */   bor: () => (/* binding */ bor),\n/* harmony export */   bxor: () => (/* binding */ bxor),\n/* harmony export */   div: () => (/* binding */ div),\n/* harmony export */   e: () => (/* binding */ e),\n/* harmony export */   eq: () => (/* binding */ eq),\n/* harmony export */   exp: () => (/* binding */ exp),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromRprBE: () => (/* binding */ fromRprBE),\n/* harmony export */   fromRprLE: () => (/* binding */ fromRprLE),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   geq: () => (/* binding */ geq),\n/* harmony export */   gt: () => (/* binding */ gt),\n/* harmony export */   isNegative: () => (/* binding */ isNegative),\n/* harmony export */   isOdd: () => (/* binding */ isOdd),\n/* harmony export */   isZero: () => (/* binding */ isZero),\n/* harmony export */   land: () => (/* binding */ land),\n/* harmony export */   leq: () => (/* binding */ leq),\n/* harmony export */   lnot: () => (/* binding */ lnot),\n/* harmony export */   lor: () => (/* binding */ lor),\n/* harmony export */   lt: () => (/* binding */ lt),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   mul: () => (/* binding */ mul),\n/* harmony export */   naf: () => (/* binding */ naf),\n/* harmony export */   neg: () => (/* binding */ neg),\n/* harmony export */   neq: () => (/* binding */ neq),\n/* harmony export */   one: () => (/* binding */ one),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   shiftLeft: () => (/* binding */ shiftLeft),\n/* harmony export */   shiftRight: () => (/* binding */ shiftRight),\n/* harmony export */   shl: () => (/* binding */ shl),\n/* harmony export */   shr: () => (/* binding */ shr),\n/* harmony export */   square: () => (/* binding */ square),\n/* harmony export */   sub: () => (/* binding */ sub),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toLEBuff: () => (/* binding */ toLEBuff),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toRprBE: () => (/* binding */ toRprBE),\n/* harmony export */   toRprLE: () => (/* binding */ toRprLE),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   zero: () => (/* binding */ zero)\n/* harmony export */ });\n\n/* global BigInt */\nconst hexLen = [ 0, 1, 2, 2, 3, 3, 3, 3, 4 ,4 ,4 ,4 ,4 ,4 ,4 ,4];\n\nfunction fromString(s, radix) {\n    if ((!radix)||(radix==10)) {\n        return BigInt(s);\n    } else if (radix==16) {\n        if (s.slice(0,2) == \"0x\") {\n            return BigInt(s);\n        } else {\n            return BigInt(\"0x\"+s);\n        }\n    }\n}\n\nconst e = fromString;\n\nfunction fromArray(a, radix) {\n    let acc =BigInt(0);\n    radix = BigInt(radix);\n    for (let i=0; i<a.length; i++) {\n        acc = acc*radix + BigInt(a[i]);\n    }\n    return acc;\n}\n\nfunction bitLength(a) {\n    const aS =a.toString(16);\n    return (aS.length-1)*4 +hexLen[parseInt(aS[0], 16)];\n}\n\nfunction isNegative(a) {\n    return BigInt(a) < BigInt(0);\n}\n\nfunction isZero(a) {\n    return !a;\n}\n\nfunction shiftLeft(a, n) {\n    return BigInt(a) << BigInt(n);\n}\n\nfunction shiftRight(a, n) {\n    return BigInt(a) >> BigInt(n);\n}\n\nconst shl = shiftLeft;\nconst shr = shiftRight;\n\nfunction isOdd(a) {\n    return (BigInt(a) & BigInt(1)) == BigInt(1);\n}\n\n\nfunction naf(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            const z = 2 - Number(E % BigInt(4));\n            res.push( z );\n            E = E - BigInt(z);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\n\nfunction bits(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\nfunction toNumber(s) {\n    if (s>BigInt(Number.MAX_SAFE_INTEGER )) {\n        throw new Error(\"Number too big\");\n    }\n    return Number(s);\n}\n\nfunction toArray(s, radix) {\n    const res = [];\n    let rem = BigInt(s);\n    radix = BigInt(radix);\n    while (rem) {\n        res.unshift( Number(rem % radix));\n        rem = rem / radix;\n    }\n    return res;\n}\n\n\nfunction add(a, b) {\n    return BigInt(a) + BigInt(b);\n}\n\nfunction sub(a, b) {\n    return BigInt(a) - BigInt(b);\n}\n\nfunction neg(a) {\n    return -BigInt(a);\n}\n\nfunction mul(a, b) {\n    return BigInt(a) * BigInt(b);\n}\n\nfunction square(a) {\n    return BigInt(a) * BigInt(a);\n}\n\nfunction pow(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nfunction exp(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nfunction abs(a) {\n    return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);\n}\n\nfunction div(a, b) {\n    return BigInt(a) / BigInt(b);\n}\n\nfunction mod(a, b) {\n    return BigInt(a) % BigInt(b);\n}\n\nfunction eq(a, b) {\n    return BigInt(a) == BigInt(b);\n}\n\nfunction neq(a, b) {\n    return BigInt(a) != BigInt(b);\n}\n\nfunction lt(a, b) {\n    return BigInt(a) < BigInt(b);\n}\n\nfunction gt(a, b) {\n    return BigInt(a) > BigInt(b);\n}\n\nfunction leq(a, b) {\n    return BigInt(a) <= BigInt(b);\n}\n\nfunction geq(a, b) {\n    return BigInt(a) >= BigInt(b);\n}\n\nfunction band(a, b) {\n    return BigInt(a) & BigInt(b);\n}\n\nfunction bor(a, b) {\n    return BigInt(a) | BigInt(b);\n}\n\nfunction bxor(a, b) {\n    return BigInt(a) ^ BigInt(b);\n}\n\nfunction land(a, b) {\n    return BigInt(a) && BigInt(b);\n}\n\nfunction lor(a, b) {\n    return BigInt(a) || BigInt(b);\n}\n\nfunction lnot(a) {\n    return !BigInt(a);\n}\n\n// Returns a buffer with Little Endian Representation\nfunction toRprLE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v[i] = parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16);\n    for (let i=l; i<v.length; i++) v[i] = 0;\n    for (let i=v.length*4; i<n8; i++) buff[i] = toNumber(band(shiftRight(e, i*8), 0xFF));\n}\n\n// Returns a buffer with Big Endian Representation\nfunction toRprBE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v.setUint32(n8-i*4 -4, parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16), false);\n    for (let i=0; i<n8/4-l; i++) v[i] = 0;\n}\n\n// Pases a buffer with Little Endian Representation\nfunction fromRprLE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const a = new Array(n8/4);\n    v.forEach( (ch,i) => a[a.length-i-1] = ch.toString(16).padStart(8,\"0\") );\n    return fromString(a.join(\"\"), 16);\n}\n\n// Pases a buffer with Big Endian Representation\nfunction fromRprBE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const a = new Array(n8/4);\n    for (let i=0; i<n8/4; i++) {\n        a[i] = v.getUint32(i*4, false).toString(16).padStart(8, \"0\");\n    }\n    return fromString(a.join(\"\"), 16);\n}\n\nfunction toString(a, radix) {\n    return a.toString(radix);\n}\n\nfunction toLEBuff(a) {\n    const buff = new Uint8Array(Math.floor((bitLength(a) - 1) / 8) +1);\n    toRprLE(buff, 0, a, buff.byteLength);\n    return buff;\n}\n\nconst zero = e(0);\nconst one = e(1);\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9zY2FsYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ0E7O0FBRUE7QUFDUDtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxrQkFBa0IsS0FBSztBQUN2QixrQkFBa0IsWUFBWTtBQUM5QiwyQkFBMkIsTUFBTTtBQUNqQzs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxrQkFBa0IsS0FBSztBQUN2QixrQkFBa0IsVUFBVTtBQUM1Qjs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL3NjYWxhci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIGdsb2JhbCBCaWdJbnQgKi9cbmNvbnN0IGhleExlbiA9IFsgMCwgMSwgMiwgMiwgMywgMywgMywgMywgNCAsNCAsNCAsNCAsNCAsNCAsNCAsNF07XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHMsIHJhZGl4KSB7XG4gICAgaWYgKCghcmFkaXgpfHwocmFkaXg9PTEwKSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KHMpO1xuICAgIH0gZWxzZSBpZiAocmFkaXg9PTE2KSB7XG4gICAgICAgIGlmIChzLnNsaWNlKDAsMikgPT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludChcIjB4XCIrcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBlID0gZnJvbVN0cmluZztcblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21BcnJheShhLCByYWRpeCkge1xuICAgIGxldCBhY2MgPUJpZ0ludCgwKTtcbiAgICByYWRpeCA9IEJpZ0ludChyYWRpeCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjID0gYWNjKnJhZGl4ICsgQmlnSW50KGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuZ3RoKGEpIHtcbiAgICBjb25zdCBhUyA9YS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIChhUy5sZW5ndGgtMSkqNCAraGV4TGVuW3BhcnNlSW50KGFTWzBdLCAxNildO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOZWdhdGl2ZShhKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA8IEJpZ0ludCgwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzWmVybyhhKSB7XG4gICAgcmV0dXJuICFhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpZnRMZWZ0KGEsIG4pIHtcbiAgICByZXR1cm4gQmlnSW50KGEpIDw8IEJpZ0ludChuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaWZ0UmlnaHQoYSwgbikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPj4gQmlnSW50KG4pO1xufVxuXG5leHBvcnQgY29uc3Qgc2hsID0gc2hpZnRMZWZ0O1xuZXhwb3J0IGNvbnN0IHNociA9IHNoaWZ0UmlnaHQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09kZChhKSB7XG4gICAgcmV0dXJuIChCaWdJbnQoYSkgJiBCaWdJbnQoMSkpID09IEJpZ0ludCgxKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gbmFmKG4pIHtcbiAgICBsZXQgRSA9IEJpZ0ludChuKTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICB3aGlsZSAoRSkge1xuICAgICAgICBpZiAoRSAmIEJpZ0ludCgxKSkge1xuICAgICAgICAgICAgY29uc3QgeiA9IDIgLSBOdW1iZXIoRSAlIEJpZ0ludCg0KSk7XG4gICAgICAgICAgICByZXMucHVzaCggeiApO1xuICAgICAgICAgICAgRSA9IEUgLSBCaWdJbnQoeik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMucHVzaCggMCApO1xuICAgICAgICB9XG4gICAgICAgIEUgPSBFID4+IEJpZ0ludCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYml0cyhuKSB7XG4gICAgbGV0IEUgPSBCaWdJbnQobik7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgd2hpbGUgKEUpIHtcbiAgICAgICAgaWYgKEUgJiBCaWdJbnQoMSkpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnB1c2goIDAgKTtcbiAgICAgICAgfVxuICAgICAgICBFID0gRSA+PiBCaWdJbnQoMSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcihzKSB7XG4gICAgaWYgKHM+QmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWdcIik7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIocyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KHMsIHJhZGl4KSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgbGV0IHJlbSA9IEJpZ0ludChzKTtcbiAgICByYWRpeCA9IEJpZ0ludChyYWRpeCk7XG4gICAgd2hpbGUgKHJlbSkge1xuICAgICAgICByZXMudW5zaGlmdCggTnVtYmVyKHJlbSAlIHJhZGl4KSk7XG4gICAgICAgIHJlbSA9IHJlbSAvIHJhZGl4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgKyBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWIoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgLSBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZWcoYSkge1xuICAgIHJldHVybiAtQmlnSW50KGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICogQmlnSW50KGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlKGEpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICogQmlnSW50KGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG93KGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICoqIEJpZ0ludChiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cChhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSAqKiBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhYnMoYSkge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPj0gMCA/IEJpZ0ludChhKSA6IC1CaWdJbnQoYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXYoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgLyBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgJSBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcShhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA9PSBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXEoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgIT0gQmlnSW50KGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbHQoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPCBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBndChhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA+IEJpZ0ludChiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcShhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA8PSBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXEoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPj0gQmlnSW50KGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFuZChhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSAmIEJpZ0ludChiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJvcihhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSB8IEJpZ0ludChiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ4b3IoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgXiBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYW5kKGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICYmIEJpZ0ludChiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvcihhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSB8fCBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsbm90KGEpIHtcbiAgICByZXR1cm4gIUJpZ0ludChhKTtcbn1cblxuLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIExpdHRsZSBFbmRpYW4gUmVwcmVzZW50YXRpb25cbmV4cG9ydCBmdW5jdGlvbiB0b1JwckxFKGJ1ZmYsIG8sIGUsIG44KSB7XG4gICAgY29uc3QgcyA9IFwiMDAwMDAwMFwiICsgZS50b1N0cmluZygxNik7XG4gICAgY29uc3QgdiA9IG5ldyBVaW50MzJBcnJheShidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0ICsgbywgbjgvNCk7XG4gICAgY29uc3QgbCA9ICgoKHMubGVuZ3RoLTcpKjQgLSAxKSA+PiA1KSsxOyAgICAvLyBOdW1iZXIgb2YgMzJiaXQgd29yZHM7XG4gICAgZm9yIChsZXQgaT0wOyBpPGw7IGkrKykgdltpXSA9IHBhcnNlSW50KHMuc3Vic3RyaW5nKHMubGVuZ3RoLTgqaS04LCBzLmxlbmd0aC04KmkpLCAxNik7XG4gICAgZm9yIChsZXQgaT1sOyBpPHYubGVuZ3RoOyBpKyspIHZbaV0gPSAwO1xuICAgIGZvciAobGV0IGk9di5sZW5ndGgqNDsgaTxuODsgaSsrKSBidWZmW2ldID0gdG9OdW1iZXIoYmFuZChzaGlmdFJpZ2h0KGUsIGkqOCksIDB4RkYpKTtcbn1cblxuLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gUmVwcmVzZW50YXRpb25cbmV4cG9ydCBmdW5jdGlvbiB0b1JwckJFKGJ1ZmYsIG8sIGUsIG44KSB7XG4gICAgY29uc3QgcyA9IFwiMDAwMDAwMFwiICsgZS50b1N0cmluZygxNik7XG4gICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0ICsgbywgbjgpO1xuICAgIGNvbnN0IGwgPSAoKChzLmxlbmd0aC03KSo0IC0gMSkgPj4gNSkrMTsgICAgLy8gTnVtYmVyIG9mIDMyYml0IHdvcmRzO1xuICAgIGZvciAobGV0IGk9MDsgaTxsOyBpKyspIHYuc2V0VWludDMyKG44LWkqNCAtNCwgcGFyc2VJbnQocy5zdWJzdHJpbmcocy5sZW5ndGgtOCppLTgsIHMubGVuZ3RoLTgqaSksIDE2KSwgZmFsc2UpO1xuICAgIGZvciAobGV0IGk9MDsgaTxuOC80LWw7IGkrKykgdltpXSA9IDA7XG59XG5cbi8vIFBhc2VzIGEgYnVmZmVyIHdpdGggTGl0dGxlIEVuZGlhbiBSZXByZXNlbnRhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScHJMRShidWZmLCBvLCBuOCkge1xuICAgIG44ID0gbjggfHwgYnVmZi5ieXRlTGVuZ3RoO1xuICAgIG8gPSBvIHx8IDA7XG4gICAgY29uc3QgdiA9IG5ldyBVaW50MzJBcnJheShidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0ICsgbywgbjgvNCk7XG4gICAgY29uc3QgYSA9IG5ldyBBcnJheShuOC80KTtcbiAgICB2LmZvckVhY2goIChjaCxpKSA9PiBhW2EubGVuZ3RoLWktMV0gPSBjaC50b1N0cmluZygxNikucGFkU3RhcnQoOCxcIjBcIikgKTtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhhLmpvaW4oXCJcIiksIDE2KTtcbn1cblxuLy8gUGFzZXMgYSBidWZmZXIgd2l0aCBCaWcgRW5kaWFuIFJlcHJlc2VudGF0aW9uXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwckJFKGJ1ZmYsIG8sIG44KSB7XG4gICAgbjggPSBuOCB8fCBidWZmLmJ5dGVMZW5ndGg7XG4gICAgbyA9IG8gfHwgMDtcbiAgICBjb25zdCB2ID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQgKyBvLCBuOCk7XG4gICAgY29uc3QgYSA9IG5ldyBBcnJheShuOC80KTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bjgvNDsgaSsrKSB7XG4gICAgICAgIGFbaV0gPSB2LmdldFVpbnQzMihpKjQsIGZhbHNlKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbVN0cmluZyhhLmpvaW4oXCJcIiksIDE2KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGEsIHJhZGl4KSB7XG4gICAgcmV0dXJuIGEudG9TdHJpbmcocmFkaXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9MRUJ1ZmYoYSkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShNYXRoLmZsb29yKChiaXRMZW5ndGgoYSkgLSAxKSAvIDgpICsxKTtcbiAgICB0b1JwckxFKGJ1ZmYsIDAsIGEsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmV4cG9ydCBjb25zdCB6ZXJvID0gZSgwKTtcbmV4cG9ydCBjb25zdCBvbmUgPSBlKDEpO1xuXG5cblxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/threadman.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ThreadManager: () => (/* binding */ ThreadManager),\n/* harmony export */   \"default\": () => (/* binding */ buildThreadManager)\n/* harmony export */ });\n/* harmony import */ var _threadman_thread_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./threadman_thread.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman_thread.js\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var web_worker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! web-worker */ \"(rsc)/./node_modules/web-worker/cjs/node.js\");\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// const MEM_SIZE = 1000;  // Memory size in 64K Pakes (512Mb)\nconst MEM_SIZE = 25;  // Memory size in 64K Pakes (1600Kb)\n\n\n\n\n\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject)=> {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nlet workerSource;\n\nconst threadStr = `(${_threadman_thread_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toString()})(self)`;\nif(false) {} else {  \n    workerSource = \"data:application/javascript;base64,\" + Buffer.from(threadStr).toString(\"base64\");\n}\n\n\n\nasync function buildThreadManager(wasm, singleThread) {\n    const tm = new ThreadManager();\n\n    tm.memory = new WebAssembly.Memory({initial:MEM_SIZE});\n    tm.u8 = new Uint8Array(tm.memory.buffer);\n    tm.u32 = new Uint32Array(tm.memory.buffer);\n\n    const wasmModule = await WebAssembly.compile(wasm.code);\n\n    tm.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": tm.memory\n        }\n    });\n    \n    if(false) {}\n    \n    tm.singleThread = singleThread;\n    tm.initalPFree = tm.u32[0];   // Save the Pointer to free space.\n    tm.pq = wasm.pq;\n    tm.pr = wasm.pr;\n    tm.pG1gen = wasm.pG1gen;\n    tm.pG1zero = wasm.pG1zero;\n    tm.pG2gen = wasm.pG2gen;\n    tm.pG2zero = wasm.pG2zero;\n    tm.pOneT = wasm.pOneT;\n\n    //    tm.pTmp0 = tm.alloc(curve.G2.F.n8*3);\n    //    tm.pTmp1 = tm.alloc(curve.G2.F.n8*3);\n\n    if (singleThread) {\n        tm.code = wasm.code;\n        tm.taskManager = (0,_threadman_thread_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        await tm.taskManager([{\n            cmd: \"INIT\",\n            init: MEM_SIZE,\n            code: tm.code.slice()\n        }]);\n        tm.concurrency  = 1;\n    } else {\n        tm.workers = [];\n        tm.pendingDeferreds = [];\n        tm.working = [];\n\n        let concurrency = 2;\n        if (false) {} else {\n            concurrency = os__WEBPACK_IMPORTED_MODULE_1__.cpus().length;\n        }\n\n        if(concurrency == 0){\n            concurrency = 2;\n        }\n\n        // Limit to 64 threads for memory reasons.\n        if (concurrency>64) concurrency=64;\n        tm.concurrency = concurrency;\n\n        for (let i = 0; i<concurrency; i++) {\n\n            tm.workers[i] = new web_worker__WEBPACK_IMPORTED_MODULE_2__(workerSource);\n\n            tm.workers[i].addEventListener(\"message\", getOnMsg(i));\n\n            tm.working[i]=false;\n        }\n\n        const initPromises = [];\n        for (let i=0; i<tm.workers.length;i++) {\n            const copyCode = wasm.code.slice();\n            initPromises.push(tm.postAction(i, [{\n                cmd: \"INIT\",\n                init: MEM_SIZE,\n                code: copyCode\n            }], [copyCode.buffer]));\n        }\n\n        await Promise.all(initPromises);\n\n    }\n    return tm;\n\n    function getOnMsg(i) {\n        return function(e) {\n            let data;\n            if ((e)&&(e.data)) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            tm.working[i]=false;\n            tm.pendingDeferreds[i].resolve(data);\n            tm.processWorks();\n        };\n    }\n\n}\n\nclass ThreadManager {\n    constructor() {\n        this.actionQueue = [];\n        this.oldPFree = 0;\n    }\n\n    startSyncOp() {\n        if (this.oldPFree != 0) throw new Error(\"Sync operation in progress\");\n        this.oldPFree = this.u32[0];\n    }\n\n    endSyncOp() {\n        if (this.oldPFree == 0) throw new Error(\"No sync operation in progress\");\n        this.u32[0] = this.oldPFree;\n        this.oldPFree = 0;\n    }\n\n    postAction(workerId, e, transfers, _deferred) {\n        if (this.working[workerId]) {\n            throw new Error(\"Posting a job t a working worker\");\n        }\n        this.working[workerId] = true;\n\n        this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();\n        this.workers[workerId].postMessage(e, transfers);\n\n        return this.pendingDeferreds[workerId].promise;\n    }\n\n    processWorks() {\n        for (let i=0; (i<this.workers.length)&&(this.actionQueue.length > 0); i++) {\n            if (this.working[i] == false) {\n                const work = this.actionQueue.shift();\n                this.postAction(i, work.data, work.transfers, work.deferred);\n            }\n        }\n    }\n\n    queueAction(actionData, transfers) {\n        const d = new Deferred();\n\n        if (this.singleThread) {\n            const res = this.taskManager(actionData);\n            d.resolve(res);\n        } else {\n            this.actionQueue.push({\n                data: actionData,\n                transfers: transfers,\n                deferred: d\n            });\n            this.processWorks();\n        }\n        return d.promise;\n    }\n\n    resetMemory() {\n        this.u32[0] = this.initalPFree;\n    }\n\n    allocBuff(buff) {\n        const pointer = this.alloc(buff.byteLength);\n        this.setBuff(pointer, buff);\n        return pointer;\n    }\n\n    getBuff(pointer, length) {\n        return this.u8.slice(pointer, pointer+ length);\n    }\n\n    setBuff(pointer, buffer) {\n        this.u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    alloc(length) {\n        while (this.u32[0] & 3) this.u32[0]++;  // Return always aligned pointers\n        const res = this.u32[0];\n        this.u32[0] += length;\n        return res;\n    }\n\n    async terminate() {\n        for (let i=0; i<this.workers.length; i++) {\n            this.workers[i].postMessage([{cmd: \"TERMINATE\"}]);\n        }\n        await sleep(200);\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy90aHJlYWRtYW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQixzQkFBc0I7OztBQUdxQjtBQUN2QjtBQUNZOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQiw0REFBTSxZQUFZO0FBQ3hDLEdBQUcsS0FBZSxFQUFFLEVBUW5CLENBQUM7QUFDRixnREFBZ0Q7QUFDaEQ7Ozs7QUFJZTtBQUNmOztBQUVBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE9BQU8sS0FBc0MsRUFBRSxFQUUxQztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGdFQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksS0FBZSxFQUFFLEVBSXBCLENBQUM7QUFDViwwQkFBMEIsb0NBQU87QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZUFBZTs7QUFFdkMsZ0NBQWdDLHVDQUFNOztBQUV0Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHdEQUF3RDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0MsMENBQTBDLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy90aHJlYWRtYW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21zbmFyayAoV2ViIEFzc2VtYmx5IHprU25hcmsgUHJvdmVyKS5cblxuICAgIHdhc21zbmFyayBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21zbmFyayBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtc25hcmsuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBjb25zdCBNRU1fU0laRSA9IDEwMDA7ICAvLyBNZW1vcnkgc2l6ZSBpbiA2NEsgUGFrZXMgKDUxMk1iKVxuY29uc3QgTUVNX1NJWkUgPSAyNTsgIC8vIE1lbW9yeSBzaXplIGluIDY0SyBQYWtlcyAoMTYwMEtiKVxuXG5cbmltcG9ydCB0aHJlYWQgZnJvbSBcIi4vdGhyZWFkbWFuX3RocmVhZC5qc1wiO1xuaW1wb3J0IG9zIGZyb20gXCJvc1wiO1xuaW1wb3J0IFdvcmtlciBmcm9tIFwid2ViLXdvcmtlclwiO1xuXG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG5sZXQgd29ya2VyU291cmNlO1xuXG5jb25zdCB0aHJlYWRTdHIgPSBgKCR7dGhyZWFkLnRvU3RyaW5nKCl9KShzZWxmKWA7XG5pZihwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICBpZihnbG9iYWxUaGlzPy5CbG9iKSB7XG4gICAgICAgIGNvbnN0IHRocmVhZEJ5dGVzPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGhyZWFkU3RyKTtcbiAgICAgICAgY29uc3Qgd29ya2VyQmxvYiA9IG5ldyBCbG9iKFt0aHJlYWRCeXRlc10sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIgfSkgO1xuICAgICAgICB3b3JrZXJTb3VyY2UgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHdvcmtlckJsb2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtlclNvdXJjZSA9IFwiZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0O2Jhc2U2NCxcIiArIGdsb2JhbFRoaXMuYnRvYSh0aHJlYWRTdHIpO1xuICAgIH1cbn0gZWxzZSB7ICBcbiAgICB3b3JrZXJTb3VyY2UgPSBcImRhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdDtiYXNlNjQsXCIgKyBCdWZmZXIuZnJvbSh0aHJlYWRTdHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuXG5cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gYnVpbGRUaHJlYWRNYW5hZ2VyKHdhc20sIHNpbmdsZVRocmVhZCkge1xuICAgIGNvbnN0IHRtID0gbmV3IFRocmVhZE1hbmFnZXIoKTtcblxuICAgIHRtLm1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6TUVNX1NJWkV9KTtcbiAgICB0bS51OCA9IG5ldyBVaW50OEFycmF5KHRtLm1lbW9yeS5idWZmZXIpO1xuICAgIHRtLnUzMiA9IG5ldyBVaW50MzJBcnJheSh0bS5tZW1vcnkuYnVmZmVyKTtcblxuICAgIGNvbnN0IHdhc21Nb2R1bGUgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKHdhc20uY29kZSk7XG5cbiAgICB0bS5pbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21Nb2R1bGUsIHtcbiAgICAgICAgZW52OiB7XG4gICAgICAgICAgICBcIm1lbW9yeVwiOiB0bS5tZW1vcnlcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmKHByb2Nlc3MuYnJvd3NlciAmJiAhZ2xvYmFsVGhpcz8uV29ya2VyKSB7XG4gICAgICAgIHNpbmdsZVRocmVhZCA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIHRtLnNpbmdsZVRocmVhZCA9IHNpbmdsZVRocmVhZDtcbiAgICB0bS5pbml0YWxQRnJlZSA9IHRtLnUzMlswXTsgICAvLyBTYXZlIHRoZSBQb2ludGVyIHRvIGZyZWUgc3BhY2UuXG4gICAgdG0ucHEgPSB3YXNtLnBxO1xuICAgIHRtLnByID0gd2FzbS5wcjtcbiAgICB0bS5wRzFnZW4gPSB3YXNtLnBHMWdlbjtcbiAgICB0bS5wRzF6ZXJvID0gd2FzbS5wRzF6ZXJvO1xuICAgIHRtLnBHMmdlbiA9IHdhc20ucEcyZ2VuO1xuICAgIHRtLnBHMnplcm8gPSB3YXNtLnBHMnplcm87XG4gICAgdG0ucE9uZVQgPSB3YXNtLnBPbmVUO1xuXG4gICAgLy8gICAgdG0ucFRtcDAgPSB0bS5hbGxvYyhjdXJ2ZS5HMi5GLm44KjMpO1xuICAgIC8vICAgIHRtLnBUbXAxID0gdG0uYWxsb2MoY3VydmUuRzIuRi5uOCozKTtcblxuICAgIGlmIChzaW5nbGVUaHJlYWQpIHtcbiAgICAgICAgdG0uY29kZSA9IHdhc20uY29kZTtcbiAgICAgICAgdG0udGFza01hbmFnZXIgPSB0aHJlYWQoKTtcbiAgICAgICAgYXdhaXQgdG0udGFza01hbmFnZXIoW3tcbiAgICAgICAgICAgIGNtZDogXCJJTklUXCIsXG4gICAgICAgICAgICBpbml0OiBNRU1fU0laRSxcbiAgICAgICAgICAgIGNvZGU6IHRtLmNvZGUuc2xpY2UoKVxuICAgICAgICB9XSk7XG4gICAgICAgIHRtLmNvbmN1cnJlbmN5ICA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdG0ud29ya2VycyA9IFtdO1xuICAgICAgICB0bS5wZW5kaW5nRGVmZXJyZWRzID0gW107XG4gICAgICAgIHRtLndvcmtpbmcgPSBbXTtcblxuICAgICAgICBsZXQgY29uY3VycmVuY3kgPSAyO1xuICAgICAgICBpZiAocHJvY2Vzcy5icm93c2VyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IG9zLmNwdXMoKS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZihjb25jdXJyZW5jeSA9PSAwKXtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExpbWl0IHRvIDY0IHRocmVhZHMgZm9yIG1lbW9yeSByZWFzb25zLlxuICAgICAgICBpZiAoY29uY3VycmVuY3k+NjQpIGNvbmN1cnJlbmN5PTY0O1xuICAgICAgICB0bS5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPGNvbmN1cnJlbmN5OyBpKyspIHtcblxuICAgICAgICAgICAgdG0ud29ya2Vyc1tpXSA9IG5ldyBXb3JrZXIod29ya2VyU291cmNlKTtcblxuICAgICAgICAgICAgdG0ud29ya2Vyc1tpXS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBnZXRPbk1zZyhpKSk7XG5cbiAgICAgICAgICAgIHRtLndvcmtpbmdbaV09ZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbml0UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRtLndvcmtlcnMubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgY29uc3QgY29weUNvZGUgPSB3YXNtLmNvZGUuc2xpY2UoKTtcbiAgICAgICAgICAgIGluaXRQcm9taXNlcy5wdXNoKHRtLnBvc3RBY3Rpb24oaSwgW3tcbiAgICAgICAgICAgICAgICBjbWQ6IFwiSU5JVFwiLFxuICAgICAgICAgICAgICAgIGluaXQ6IE1FTV9TSVpFLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvcHlDb2RlXG4gICAgICAgICAgICB9XSwgW2NvcHlDb2RlLmJ1ZmZlcl0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluaXRQcm9taXNlcyk7XG5cbiAgICB9XG4gICAgcmV0dXJuIHRtO1xuXG4gICAgZnVuY3Rpb24gZ2V0T25Nc2coaSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBpZiAoKGUpJiYoZS5kYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bS53b3JraW5nW2ldPWZhbHNlO1xuICAgICAgICAgICAgdG0ucGVuZGluZ0RlZmVycmVkc1tpXS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgdG0ucHJvY2Vzc1dvcmtzKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cbmV4cG9ydCBjbGFzcyBUaHJlYWRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLm9sZFBGcmVlID0gMDtcbiAgICB9XG5cbiAgICBzdGFydFN5bmNPcCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2xkUEZyZWUgIT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiU3luYyBvcGVyYXRpb24gaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIHRoaXMub2xkUEZyZWUgPSB0aGlzLnUzMlswXTtcbiAgICB9XG5cbiAgICBlbmRTeW5jT3AoKSB7XG4gICAgICAgIGlmICh0aGlzLm9sZFBGcmVlID09IDApIHRocm93IG5ldyBFcnJvcihcIk5vIHN5bmMgb3BlcmF0aW9uIGluIHByb2dyZXNzXCIpO1xuICAgICAgICB0aGlzLnUzMlswXSA9IHRoaXMub2xkUEZyZWU7XG4gICAgICAgIHRoaXMub2xkUEZyZWUgPSAwO1xuICAgIH1cblxuICAgIHBvc3RBY3Rpb24od29ya2VySWQsIGUsIHRyYW5zZmVycywgX2RlZmVycmVkKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmdbd29ya2VySWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0aW5nIGEgam9iIHQgYSB3b3JraW5nIHdvcmtlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndvcmtpbmdbd29ya2VySWRdID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnBlbmRpbmdEZWZlcnJlZHNbd29ya2VySWRdID0gX2RlZmVycmVkID8gX2RlZmVycmVkIDogbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMud29ya2Vyc1t3b3JrZXJJZF0ucG9zdE1lc3NhZ2UoZSwgdHJhbnNmZXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nRGVmZXJyZWRzW3dvcmtlcklkXS5wcm9taXNlO1xuICAgIH1cblxuICAgIHByb2Nlc3NXb3JrcygpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyAoaTx0aGlzLndvcmtlcnMubGVuZ3RoKSYmKHRoaXMuYWN0aW9uUXVldWUubGVuZ3RoID4gMCk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMud29ya2luZ1tpXSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmsgPSB0aGlzLmFjdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0QWN0aW9uKGksIHdvcmsuZGF0YSwgd29yay50cmFuc2ZlcnMsIHdvcmsuZGVmZXJyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVldWVBY3Rpb24oYWN0aW9uRGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgICAgIGNvbnN0IGQgPSBuZXcgRGVmZXJyZWQoKTtcblxuICAgICAgICBpZiAodGhpcy5zaW5nbGVUaHJlYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudGFza01hbmFnZXIoYWN0aW9uRGF0YSk7XG4gICAgICAgICAgICBkLnJlc29sdmUocmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogYWN0aW9uRGF0YSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcnM6IHRyYW5zZmVycyxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZDogZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NXb3JrcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkLnByb21pc2U7XG4gICAgfVxuXG4gICAgcmVzZXRNZW1vcnkoKSB7XG4gICAgICAgIHRoaXMudTMyWzBdID0gdGhpcy5pbml0YWxQRnJlZTtcbiAgICB9XG5cbiAgICBhbGxvY0J1ZmYoYnVmZikge1xuICAgICAgICBjb25zdCBwb2ludGVyID0gdGhpcy5hbGxvYyhidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLnNldEJ1ZmYocG9pbnRlciwgYnVmZik7XG4gICAgICAgIHJldHVybiBwb2ludGVyO1xuICAgIH1cblxuICAgIGdldEJ1ZmYocG9pbnRlciwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnU4LnNsaWNlKHBvaW50ZXIsIHBvaW50ZXIrIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgc2V0QnVmZihwb2ludGVyLCBidWZmZXIpIHtcbiAgICAgICAgdGhpcy51OC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSwgcG9pbnRlcik7XG4gICAgfVxuXG4gICAgYWxsb2MobGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnUzMlswXSAmIDMpIHRoaXMudTMyWzBdKys7ICAvLyBSZXR1cm4gYWx3YXlzIGFsaWduZWQgcG9pbnRlcnNcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy51MzJbMF07XG4gICAgICAgIHRoaXMudTMyWzBdICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBhc3luYyB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLndvcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud29ya2Vyc1tpXS5wb3N0TWVzc2FnZShbe2NtZDogXCJURVJNSU5BVEVcIn1dKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman_thread.js":
/*!********************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/threadman_thread.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ thread)\n/* harmony export */ });\n/* global WebAssembly */\n\nfunction thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == \"INIT\") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == \"TERMINATE\") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == \"INIT\") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case \"ALLOCSET\":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case \"ALLOC\":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case \"SET\":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case \"CALL\": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== \"undefined\") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != \"undefined\") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case \"GET\":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error(\"Invalid cmd\");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy90aHJlYWRtYW5fdGhyZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQ0FBbUM7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7O0FBSUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL3RocmVhZG1hbl90aHJlYWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIFdlYkFzc2VtYmx5ICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRocmVhZChzZWxmKSB7XG4gICAgY29uc3QgTUFYTUVNID0gMzI3Njc7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGxldCBtZW1vcnk7XG5cbiAgICBpZiAoc2VsZikge1xuICAgICAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgaWYgKGUuZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YVswXS5jbWQgPT0gXCJJTklUXCIpIHtcbiAgICAgICAgICAgICAgICBpbml0KGRhdGFbMF0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhWzBdLmNtZCA9PSBcIlRFUk1JTkFURVwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBydW5UYXNrKGRhdGEpO1xuICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBpbml0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IG5ldyBVaW50OEFycmF5KGRhdGEuY29kZSk7XG4gICAgICAgIGNvbnN0IHdhc21Nb2R1bGUgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKGNvZGUpO1xuICAgICAgICBtZW1vcnkgPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOmRhdGEuaW5pdCwgbWF4aW11bTogTUFYTUVNfSk7XG5cbiAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh3YXNtTW9kdWxlLCB7XG4gICAgICAgICAgICBlbnY6IHtcbiAgICAgICAgICAgICAgICBcIm1lbW9yeVwiOiBtZW1vcnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIGFsbG9jKGxlbmd0aCkge1xuICAgICAgICBjb25zdCB1MzIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlciwgMCwgMSk7XG4gICAgICAgIHdoaWxlICh1MzJbMF0gJiAzKSB1MzJbMF0rKzsgIC8vIFJldHVybiBhbHdheXMgYWxpZ25lZCBwb2ludGVyc1xuICAgICAgICBjb25zdCByZXMgPSB1MzJbMF07XG4gICAgICAgIHUzMlswXSArPSBsZW5ndGg7XG4gICAgICAgIGlmICh1MzJbMF0gKyBsZW5ndGggPiBtZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYWdlcyA9IG1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aCAvIDB4MTAwMDA7XG4gICAgICAgICAgICBsZXQgcmVxdWlyZWRQYWdlcyA9IE1hdGguZmxvb3IoKHUzMlswXSArIGxlbmd0aCkgLyAweDEwMDAwKSsxO1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkUGFnZXM+TUFYTUVNKSByZXF1aXJlZFBhZ2VzPU1BWE1FTTtcbiAgICAgICAgICAgIG1lbW9yeS5ncm93KHJlcXVpcmVkUGFnZXMtY3VycmVudFBhZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsbG9jQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBwID0gYWxsb2MoYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICBzZXRCdWZmZXIocCwgYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QnVmZmVyKHBvaW50ZXIsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCB1OCA9IG5ldyBVaW50OEFycmF5KG1lbW9yeS5idWZmZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodTguYnVmZmVyLCB1OC5ieXRlT2Zmc2V0ICsgcG9pbnRlciwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRCdWZmZXIocG9pbnRlciwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHU4ID0gbmV3IFVpbnQ4QXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgICAgIHU4LnNldChuZXcgVWludDhBcnJheShidWZmZXIpLCBwb2ludGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5UYXNrKHRhc2spIHtcbiAgICAgICAgaWYgKHRhc2tbMF0uY21kID09IFwiSU5JVFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdCh0YXNrWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICB2YXJzOiBbXSxcbiAgICAgICAgICAgIG91dDogW11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdTMyYSA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyLCAwLCAxKTtcbiAgICAgICAgY29uc3Qgb2xkQWxsb2MgPSB1MzJhWzBdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGFzay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3dpdGNoICh0YXNrW2ldLmNtZCkge1xuICAgICAgICAgICAgY2FzZSBcIkFMTE9DU0VUXCI6XG4gICAgICAgICAgICAgICAgY3R4LnZhcnNbdGFza1tpXS52YXJdID0gYWxsb2NCdWZmZXIodGFza1tpXS5idWZmKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBTExPQ1wiOlxuICAgICAgICAgICAgICAgIGN0eC52YXJzW3Rhc2tbaV0udmFyXSA9IGFsbG9jKHRhc2tbaV0ubGVuKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTRVRcIjpcbiAgICAgICAgICAgICAgICBzZXRCdWZmZXIoY3R4LnZhcnNbdGFza1tpXS52YXJdLCB0YXNrW2ldLmJ1ZmYpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkNBTExcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajx0YXNrW2ldLnBhcmFtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gdGFza1tpXS5wYXJhbXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcC52YXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGN0eC52YXJzW3AudmFyXSArIChwLm9mZnNldCB8fCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHAudmFsICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHAudmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5leHBvcnRzW3Rhc2tbaV0uZm5OYW1lXSguLi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkdFVFwiOlxuICAgICAgICAgICAgICAgIGN0eC5vdXRbdGFza1tpXS5vdXRdID0gZ2V0QnVmZmVyKGN0eC52YXJzW3Rhc2tbaV0udmFyXSwgdGFza1tpXS5sZW4pLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY21kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHUzMmIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlciwgMCwgMSk7XG4gICAgICAgIHUzMmJbMF0gPSBvbGRBbGxvYztcbiAgICAgICAgcmV0dXJuIGN0eC5vdXQ7XG4gICAgfVxuXG5cbiAgICByZXR1cm4gcnVuVGFzaztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman_thread.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   array2buffer: () => (/* binding */ array2buffer),\n/* harmony export */   beBuff2int: () => (/* binding */ beBuff2int),\n/* harmony export */   beInt2Buff: () => (/* binding */ beInt2Buff),\n/* harmony export */   bitReverse: () => (/* binding */ bitReverse),\n/* harmony export */   buffReverseBits: () => (/* binding */ buffReverseBits),\n/* harmony export */   buffer2array: () => (/* binding */ buffer2array),\n/* harmony export */   leBuff2int: () => (/* binding */ leBuff2int),\n/* harmony export */   leInt2Buff: () => (/* binding */ leInt2Buff),\n/* harmony export */   log2: () => (/* binding */ log2),\n/* harmony export */   stringifyBigInts: () => (/* binding */ stringifyBigInts),\n/* harmony export */   stringifyFElements: () => (/* binding */ stringifyFElements),\n/* harmony export */   unstringifyBigInts: () => (/* binding */ unstringifyBigInts),\n/* harmony export */   unstringifyFElements: () => (/* binding */ unstringifyFElements)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* global BigInt */\n\n\nfunction stringifyBigInts(o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.fromRprLE(o, 0);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigInts);\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction unstringifyBigInts(o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return BigInt(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return BigInt(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyBigInts);\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction beBuff2int(buff) {\n    let res = BigInt(0);\n    let i = buff.length;\n    let offset = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i > 0) {\n        if (i >= 4) {\n            i -= 4;\n            res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);\n            offset += 4;\n        } else if (i >= 2) {\n            i -= 2;\n            res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);\n            offset += 2;\n        } else {\n            i -= 1;\n            res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);\n            offset += 1;\n        }\n    }\n    return res;\n}\n\nfunction beInt2Buff(n, len) {\n    let r = n;\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = len;\n    while (o > 0) {\n        if (o - 4 >= 0) {\n            o -= 4;\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)));\n            r = r >> BigInt(32);\n        } else if (o - 2 >= 0) {\n            o -= 2;\n            buffV.setUint16(o, Number(r & BigInt(0xffff)));\n            r = r >> BigInt(16);\n        } else {\n            o -= 1;\n            buffV.setUint8(o, Number(r & BigInt(0xff)));\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nfunction leBuff2int(buff) {\n    let res = BigInt(0);\n    let i = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i < buff.length) {\n        if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);\n            i += 4;\n        } else if (i + 2 <= buff.length) {\n            res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);\n            i += 2;\n        } else {\n            res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);\n            i += 1;\n        }\n    }\n    return res;\n}\n\nfunction leInt2Buff(n, len) {\n    let r = n;\n    if (typeof len === \"undefined\") {\n        len = Math.floor((_scalar_js__WEBPACK_IMPORTED_MODULE_0__.bitLength(n) - 1) / 8) + 1;\n        if (len == 0) len = 1;\n    }\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = 0;\n    while (o < len) {\n        if (o + 4 <= len) {\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)), true);\n            o += 4;\n            r = r >> BigInt(32);\n        } else if (o + 2 <= len) {\n            buffV.setUint16(o, Number(r & BigInt(0xffff)), true);\n            o += 2;\n            r = r >> BigInt(16);\n        } else {\n            buffV.setUint8(o, Number(r & BigInt(0xff)), true);\n            o += 1;\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nfunction stringifyFElements(F, o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return F.toString(F.e(o));\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction unstringifyFElements(F, o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return F.e(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return F.e(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nconst _revTable = [];\nfor (let i = 0; i < 256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res = 0;\n    let a = idx;\n    for (let i = 0; i < bits; i++) {\n        res <<= 1;\n        res = res | (a & 1);\n        a >>= 1;\n    }\n    return res;\n}\n\nfunction bitReverse(idx, bits) {\n    return (\n        (_revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xff] << 8) |\n        (_revTable[(idx >>> 8) & 0xff] << 16) |\n        (_revTable[idx & 0xff] << 24)) >>>\n        (32 - bits)\n    );\n}\n\nfunction log2(V) {\n    return (\n        ((V & 0xffff0000) !== 0 ? ((V &= 0xffff0000), 16) : 0) |\n        ((V & 0xff00ff00) !== 0 ? ((V &= 0xff00ff00), 8) : 0) |\n        ((V & 0xf0f0f0f0) !== 0 ? ((V &= 0xf0f0f0f0), 4) : 0) |\n        ((V & 0xcccccccc) !== 0 ? ((V &= 0xcccccccc), 2) : 0) |\n        ((V & 0xaaaaaaaa) !== 0)\n    );\n}\n\nfunction buffReverseBits(buff, eSize) {\n    const n = buff.byteLength / eSize;\n    const bits = log2(n);\n    if (n != 1 << bits) {\n        throw new Error(\"Invalid number of pointers\");\n    }\n    for (let i = 0; i < n; i++) {\n        const r = bitReverse(i, bits);\n        if (i > r) {\n            const tmp = buff.slice(i * eSize, (i + 1) * eSize);\n            buff.set(buff.slice(r * eSize, (r + 1) * eSize), i * eSize);\n            buff.set(tmp, r * eSize);\n        }\n    }\n}\n\nfunction array2buffer(arr, sG) {\n    const buff = new Uint8Array(sG * arr.length);\n\n    for (let i = 0; i < arr.length; i++) {\n        buff.set(arr[i], i * sG);\n    }\n\n    return buff;\n}\n\nfunction buffer2array(buff, sG) {\n    const n = buff.byteLength / sG;\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = buff.slice(i * sG, i * sG + sG);\n    }\n    return arr;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3NDOztBQUUvQjtBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZSxpREFBZ0I7QUFDL0IsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQixpREFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgQmlnSW50ICovXG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlCaWdJbnRzKG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJiaWdpbnRcIiB8fCBvLmVxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG8udG9TdHJpbmcoMTApO1xuICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5mcm9tUnByTEUobywgMCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgICAgIHJldHVybiBvLm1hcChzdHJpbmdpZnlCaWdJbnRzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICByZXNba10gPSBzdHJpbmdpZnlCaWdJbnRzKG9ba10pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnN0cmluZ2lmeUJpZ0ludHMobykge1xuICAgIGlmICh0eXBlb2YgbyA9PSBcInN0cmluZ1wiICYmIC9eWzAtOV0rJC8udGVzdChvKSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KG8pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAvXjB4WzAtOWEtZkEtRl0rJC8udGVzdChvKSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KG8pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgICByZXR1cm4gby5tYXAodW5zdHJpbmdpZnlCaWdJbnRzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKG8gPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG8pO1xuICAgICAgICBrZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIHJlc1trXSA9IHVuc3RyaW5naWZ5QmlnSW50cyhvW2tdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVCdWZmMmludChidWZmKSB7XG4gICAgbGV0IHJlcyA9IEJpZ0ludCgwKTtcbiAgICBsZXQgaSA9IGJ1ZmYubGVuZ3RoO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgIGlmIChpID49IDQpIHtcbiAgICAgICAgICAgIGkgLT0gNDtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDMyKGkpKSA8PCBCaWdJbnQob2Zmc2V0ICogOCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgfSBlbHNlIGlmIChpID49IDIpIHtcbiAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDE2KGkpKSA8PCBCaWdJbnQob2Zmc2V0ICogOCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDgoaSkpIDw8IEJpZ0ludChvZmZzZXQgKiA4KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZUludDJCdWZmKG4sIGxlbikge1xuICAgIGxldCByID0gbjtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcik7XG4gICAgbGV0IG8gPSBsZW47XG4gICAgd2hpbGUgKG8gPiAwKSB7XG4gICAgICAgIGlmIChvIC0gNCA+PSAwKSB7XG4gICAgICAgICAgICBvIC09IDQ7XG4gICAgICAgICAgICBidWZmVi5zZXRVaW50MzIobywgTnVtYmVyKHIgJiBCaWdJbnQoMHhmZmZmZmZmZikpKTtcbiAgICAgICAgICAgIHIgPSByID4+IEJpZ0ludCgzMik7XG4gICAgICAgIH0gZWxzZSBpZiAobyAtIDIgPj0gMCkge1xuICAgICAgICAgICAgbyAtPSAyO1xuICAgICAgICAgICAgYnVmZlYuc2V0VWludDE2KG8sIE51bWJlcihyICYgQmlnSW50KDB4ZmZmZikpKTtcbiAgICAgICAgICAgIHIgPSByID4+IEJpZ0ludCgxNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvIC09IDE7XG4gICAgICAgICAgICBidWZmVi5zZXRVaW50OChvLCBOdW1iZXIociAmIEJpZ0ludCgweGZmKSkpO1xuICAgICAgICAgICAgciA9IHIgPj4gQmlnSW50KDgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBkb2VzIG5vdCBmaXQgaW4gdGhpcyBsZW5ndGhcIik7XG4gICAgfVxuICAgIHJldHVybiBidWZmO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVCdWZmMmludChidWZmKSB7XG4gICAgbGV0IHJlcyA9IEJpZ0ludCgwKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIsIGJ1ZmYuYnl0ZU9mZnNldCwgYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICB3aGlsZSAoaSA8IGJ1ZmYubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpICsgNCA8PSBidWZmLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzICs9IEJpZ0ludChidWZmVi5nZXRVaW50MzIoaSwgdHJ1ZSkpIDw8IEJpZ0ludChpICogOCk7XG4gICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDIgPD0gYnVmZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDE2KGksIHRydWUpKSA8PCBCaWdJbnQoaSAqIDgpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IEJpZ0ludChidWZmVi5nZXRVaW50OChpLCB0cnVlKSkgPDwgQmlnSW50KGkgKiA4KTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVJbnQyQnVmZihuLCBsZW4pIHtcbiAgICBsZXQgciA9IG47XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbGVuID0gTWF0aC5mbG9vcigoU2NhbGFyLmJpdExlbmd0aChuKSAtIDEpIC8gOCkgKyAxO1xuICAgICAgICBpZiAobGVuID09IDApIGxlbiA9IDE7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKTtcbiAgICBsZXQgbyA9IDA7XG4gICAgd2hpbGUgKG8gPCBsZW4pIHtcbiAgICAgICAgaWYgKG8gKyA0IDw9IGxlbikge1xuICAgICAgICAgICAgYnVmZlYuc2V0VWludDMyKG8sIE51bWJlcihyICYgQmlnSW50KDB4ZmZmZmZmZmYpKSwgdHJ1ZSk7XG4gICAgICAgICAgICBvICs9IDQ7XG4gICAgICAgICAgICByID0gciA+PiBCaWdJbnQoMzIpO1xuICAgICAgICB9IGVsc2UgaWYgKG8gKyAyIDw9IGxlbikge1xuICAgICAgICAgICAgYnVmZlYuc2V0VWludDE2KG8sIE51bWJlcihyICYgQmlnSW50KDB4ZmZmZikpLCB0cnVlKTtcbiAgICAgICAgICAgIG8gKz0gMjtcbiAgICAgICAgICAgIHIgPSByID4+IEJpZ0ludCgxNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmVi5zZXRVaW50OChvLCBOdW1iZXIociAmIEJpZ0ludCgweGZmKSksIHRydWUpO1xuICAgICAgICAgICAgbyArPSAxO1xuICAgICAgICAgICAgciA9IHIgPj4gQmlnSW50KDgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBkb2VzIG5vdCBmaXQgaW4gdGhpcyBsZW5ndGhcIik7XG4gICAgfVxuICAgIHJldHVybiBidWZmO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5RkVsZW1lbnRzKEYsIG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJiaWdpbnRcIiB8fCBvLmVxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG8udG9TdHJpbmcoMTApO1xuICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEYudG9TdHJpbmcoRi5lKG8pKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHN0cmluZ2lmeUZFbGVtZW50cy5iaW5kKHRoaXMsIEYpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICByZXNba10gPSBzdHJpbmdpZnlGRWxlbWVudHMoRiwgb1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc3RyaW5naWZ5RkVsZW1lbnRzKEYsIG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAvXlswLTldKyQvLnRlc3QobykpIHtcbiAgICAgICAgcmV0dXJuIEYuZShvKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwic3RyaW5nXCIgJiYgL14weFswLTlhLWZBLUZdKyQvLnRlc3QobykpIHtcbiAgICAgICAgcmV0dXJuIEYuZShvKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHVuc3RyaW5naWZ5RkVsZW1lbnRzLmJpbmQodGhpcywgRikpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAobyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobyk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgcmVzW2tdID0gdW5zdHJpbmdpZnlGRWxlbWVudHMoRiwgb1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cblxuY29uc3QgX3JldlRhYmxlID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX3JldlRhYmxlW2ldID0gX3JldlNsb3coaSwgOCk7XG59XG5cbmZ1bmN0aW9uIF9yZXZTbG93KGlkeCwgYml0cykge1xuICAgIGxldCByZXMgPSAwO1xuICAgIGxldCBhID0gaWR4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYml0czsgaSsrKSB7XG4gICAgICAgIHJlcyA8PD0gMTtcbiAgICAgICAgcmVzID0gcmVzIHwgKGEgJiAxKTtcbiAgICAgICAgYSA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpdFJldmVyc2UoaWR4LCBiaXRzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgKF9yZXZUYWJsZVtpZHggPj4+IDI0XSB8XG4gICAgICAgIChfcmV2VGFibGVbKGlkeCA+Pj4gMTYpICYgMHhmZl0gPDwgOCkgfFxuICAgICAgICAoX3JldlRhYmxlWyhpZHggPj4+IDgpICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgKF9yZXZUYWJsZVtpZHggJiAweGZmXSA8PCAyNCkpID4+PlxuICAgICAgICAoMzIgLSBiaXRzKVxuICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2cyKFYpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAoKFYgJiAweGZmZmYwMDAwKSAhPT0gMCA/ICgoViAmPSAweGZmZmYwMDAwKSwgMTYpIDogMCkgfFxuICAgICAgICAoKFYgJiAweGZmMDBmZjAwKSAhPT0gMCA/ICgoViAmPSAweGZmMDBmZjAwKSwgOCkgOiAwKSB8XG4gICAgICAgICgoViAmIDB4ZjBmMGYwZjApICE9PSAwID8gKChWICY9IDB4ZjBmMGYwZjApLCA0KSA6IDApIHxcbiAgICAgICAgKChWICYgMHhjY2NjY2NjYykgIT09IDAgPyAoKFYgJj0gMHhjY2NjY2NjYyksIDIpIDogMCkgfFxuICAgICAgICAoKFYgJiAweGFhYWFhYWFhKSAhPT0gMClcbiAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVmZlJldmVyc2VCaXRzKGJ1ZmYsIGVTaXplKSB7XG4gICAgY29uc3QgbiA9IGJ1ZmYuYnl0ZUxlbmd0aCAvIGVTaXplO1xuICAgIGNvbnN0IGJpdHMgPSBsb2cyKG4pO1xuICAgIGlmIChuICE9IDEgPDwgYml0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludGVyc1wiKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgciA9IGJpdFJldmVyc2UoaSwgYml0cyk7XG4gICAgICAgIGlmIChpID4gcikge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gYnVmZi5zbGljZShpICogZVNpemUsIChpICsgMSkgKiBlU2l6ZSk7XG4gICAgICAgICAgICBidWZmLnNldChidWZmLnNsaWNlKHIgKiBlU2l6ZSwgKHIgKyAxKSAqIGVTaXplKSwgaSAqIGVTaXplKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KHRtcCwgciAqIGVTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5MmJ1ZmZlcihhcnIsIHNHKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHNHICogYXJyLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWZmLnNldChhcnJbaV0sIGkgKiBzRyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIyYXJyYXkoYnVmZiwgc0cpIHtcbiAgICBjb25zdCBuID0gYnVmZi5ieXRlTGVuZ3RoIC8gc0c7XG4gICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGJ1ZmYuc2xpY2UoaSAqIHNHLCBpICogc0cgKyBzRyk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_curve.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_curve.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WasmCurve)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine_batchconvert.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js\");\n\n\n\n\n\nclass WasmCurve {\n\n    constructor(tm, prefix, F, pGen, pGb, cofactor) {\n        this.tm = tm;\n        this.prefix = prefix;\n        this.F = F;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, F.n8*3);\n        this.tm.instance.exports[prefix + \"_zeroAffine\"](this.pOp1);\n        this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8*2);\n        this.one = this.tm.getBuff(pGen, F.n8*3);\n        this.g = this.one;\n        this.oneAffine = this.tm.getBuff(pGen, F.n8*2);\n        this.gAffine = this.oneAffine;\n        this.b = this.tm.getBuff(pGb, F.n8);\n\n        if (cofactor) {\n            this.cofactor = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toLEBuff(cofactor);\n        }\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.batchLEMtoC = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchLEMtoC\", F.n8*2, F.n8);\n        this.batchLEMtoU = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchLEMtoU\", F.n8*2, F.n8*2);\n        this.batchCtoLEM = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchCtoLEM\", F.n8, F.n8*2);\n        this.batchUtoLEM = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchUtoLEM\", F.n8*2, F.n8*2);\n        this.batchToJacobian = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchToJacobian\", F.n8*2, F.n8*3);\n        this.batchToAffine = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchToAffine\", F.n8*3, F.n8*2);\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op2bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op1Affine(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*2);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_add\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_addMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    sub(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_sub\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_subMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    neg(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_neg\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Affine(\"_negAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    double(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_double\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_doubleAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isZero(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Bool(\"_isZero\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Bool(\"_isZeroAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    timesScalar(a, s) {\n        if (!(s instanceof Uint8Array)) {\n            s = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toLEBuff(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(s));\n        }\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesScalar\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesScalarAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    timesFr(a, s) {\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesFr\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesFrAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    eq(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eq\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eqMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toAffine(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Affine(\"_toAffine\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return a;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toJacobian(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return a;\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_toJacobian\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toRprUncompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoU\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n        arr.set(res, offset);\n    }\n\n    fromRprUncompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8*2);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_UtoLEM\"](this.pOp1, this.pOp1);\n        return this.tm.getBuff(this.pOp1, this.F.n8*2);\n    }\n\n    toRprCompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoC\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8);\n        arr.set(res, offset);\n    }\n\n    fromRprCompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_CtoLEM\"](this.pOp1, this.pOp2);\n        return this.tm.getBuff(this.pOp2, this.F.n8*2);\n    }\n\n    toUncompressed(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        this.toRprUncompressed(buff, 0, a);\n        return buff;\n    }\n\n    toRprLEM(arr, offset, a) {\n        if (a.byteLength == this.F.n8*2) {\n            arr.set(a, offset);\n            return;\n        } else if (a.byteLength == this.F.n8*3) {\n            this.tm.setBuff(this.pOp1, a);\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n            const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n            arr.set(res, offset);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    fromRprLEM(arr, offset) {\n        offset = offset || 0;\n        return arr.slice(offset, offset+this.F.n8*2);\n    }\n\n    toString(a, radix) {\n        if (a.byteLength == this.F.n8*3) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n            const z = this.F.toString(a.slice(this.F.n8*2), radix);\n            return `[ ${x}, ${y}, ${z} ]`;\n        } else if (a.byteLength == this.F.n8*2) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8), radix);\n            return `[ ${x}, ${y} ]`;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isValid(a) {\n        if (this.isZero(a)) return true;\n        const F = this.F;\n        const aa = this.toAffine(a);\n        const x = aa.slice(0, this.F.n8);\n        const y = aa.slice(this.F.n8, this.F.n8*2);\n        const x3b = F.add(F.mul(F.square(x),x), this.b);\n        const y2 = F.square(y);\n        return F.eq(x3b, y2);\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        let x3b;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        } while (!F.isSquare(x3b));\n\n        P[1] = F.sqrt(x3b);\n\n        const s = F.isNegative(P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n\n        let Pbuff = new Uint8Array(this.F.n8*2);\n        Pbuff.set(P[0]);\n        Pbuff.set(P[1], this.F.n8);\n\n        if (this.cofactor) {\n            Pbuff = this.timesScalar(Pbuff, this.cofactor);\n        }\n\n        return Pbuff;\n    }\n\n\n\n    toObject(a) {\n        if (this.isZero(a)) {\n            return [\n                this.F.toObject(this.F.zero),\n                this.F.toObject(this.F.one),\n                this.F.toObject(this.F.zero),\n            ];\n        }\n        const x = this.F.toObject(a.slice(0, this.F.n8));\n        const y = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        let z;\n        if (a.byteLength == this.F.n8*3) {\n            z = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        } else {\n            z = this.F.toObject(this.F.one);\n        }\n        return [x, y, z];\n    }\n\n    fromObject(a) {\n        const x = this.F.fromObject(a[0]);\n        const y = this.F.fromObject(a[1]);\n        let z;\n        if (a.length==3) {\n            z = this.F.fromObject(a[2]);\n        } else {\n            z = this.F.one;\n        }\n        if (this.F.isZero(z, this.F.one)) {\n            return this.zeroAffine;\n        } else if (this.F.eq(z, this.F.one)) {\n            const buff = new Uint8Array(this.F.n8*2);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            return buff;\n        } else {\n            const buff = new Uint8Array(this.F.n8*3);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            buff.set(z, this.F.n8*2);\n            return buff;\n        }\n    }\n\n    e(a) {\n        if (a instanceof Uint8Array) return a;\n        return this.fromObject(a);\n    }\n\n    x(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(0, this.F.n8);\n    }\n\n    y(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(this.F.n8);\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy93YXNtX2N1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRXNDO0FBQ21COztBQUUxQzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZ0RBQWU7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsbUVBQWlCO0FBQzVDLDJCQUEyQixtRUFBaUI7QUFDNUMsMkJBQTJCLG1FQUFpQjtBQUM1QywyQkFBMkIsbUVBQWlCO0FBQzVDLCtCQUErQixtRUFBaUI7QUFDaEQsNkJBQTZCLG1FQUFpQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFlLENBQUMseUNBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFLElBQUksRUFBRSxJQUFJLEdBQUc7QUFDdkMsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxJQUFJLEdBQUc7QUFDakMsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvd2FzbV9jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0ICogYXMgU2NhbGFyIGZyb20gXCIuL3NjYWxhci5qc1wiO1xuaW1wb3J0IGJ1aWxkQmF0Y2hDb252ZXJ0IGZyb20gXCIuL2VuZ2luZV9iYXRjaGNvbnZlcnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2FzbUN1cnZlIHtcblxuICAgIGNvbnN0cnVjdG9yKHRtLCBwcmVmaXgsIEYsIHBHZW4sIHBHYiwgY29mYWN0b3IpIHtcbiAgICAgICAgdGhpcy50bSA9IHRtO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgdGhpcy5GID0gRjtcblxuICAgICAgICB0aGlzLnBPcDEgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnBPcDIgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnBPcDMgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfemVyb1wiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLnplcm8gPSB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AxLCBGLm44KjMpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfemVyb0FmZmluZVwiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLnplcm9BZmZpbmUgPSB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AxLCBGLm44KjIpO1xuICAgICAgICB0aGlzLm9uZSA9IHRoaXMudG0uZ2V0QnVmZihwR2VuLCBGLm44KjMpO1xuICAgICAgICB0aGlzLmcgPSB0aGlzLm9uZTtcbiAgICAgICAgdGhpcy5vbmVBZmZpbmUgPSB0aGlzLnRtLmdldEJ1ZmYocEdlbiwgRi5uOCoyKTtcbiAgICAgICAgdGhpcy5nQWZmaW5lID0gdGhpcy5vbmVBZmZpbmU7XG4gICAgICAgIHRoaXMuYiA9IHRoaXMudG0uZ2V0QnVmZihwR2IsIEYubjgpO1xuXG4gICAgICAgIGlmIChjb2ZhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5jb2ZhY3RvciA9IFNjYWxhci50b0xFQnVmZihjb2ZhY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5lZ29uZSA9IHRoaXMubmVnKHRoaXMub25lKTtcbiAgICAgICAgdGhpcy50d28gPSB0aGlzLmFkZCh0aGlzLm9uZSwgdGhpcy5vbmUpO1xuXG4gICAgICAgIHRoaXMuYmF0Y2hMRU10b0MgPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hMRU10b0NcIiwgRi5uOCoyLCBGLm44KTtcbiAgICAgICAgdGhpcy5iYXRjaExFTXRvVSA9IGJ1aWxkQmF0Y2hDb252ZXJ0KHRtLCBwcmVmaXggKyBcIl9iYXRjaExFTXRvVVwiLCBGLm44KjIsIEYubjgqMik7XG4gICAgICAgIHRoaXMuYmF0Y2hDdG9MRU0gPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hDdG9MRU1cIiwgRi5uOCwgRi5uOCoyKTtcbiAgICAgICAgdGhpcy5iYXRjaFV0b0xFTSA9IGJ1aWxkQmF0Y2hDb252ZXJ0KHRtLCBwcmVmaXggKyBcIl9iYXRjaFV0b0xFTVwiLCBGLm44KjIsIEYubjgqMik7XG4gICAgICAgIHRoaXMuYmF0Y2hUb0phY29iaWFuID0gYnVpbGRCYXRjaENvbnZlcnQodG0sIHByZWZpeCArIFwiX2JhdGNoVG9KYWNvYmlhblwiLCBGLm44KjIsIEYubjgqMyk7XG4gICAgICAgIHRoaXMuYmF0Y2hUb0FmZmluZSA9IGJ1aWxkQmF0Y2hDb252ZXJ0KHRtLCBwcmVmaXggKyBcIl9iYXRjaFRvQWZmaW5lXCIsIEYubjgqMywgRi5uOCoyKTtcbiAgICB9XG5cbiAgICBvcDIob3BOYW1lLCBhLCBiKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMuRi5uOCozKTtcbiAgICB9XG5cbiAgICBvcDJib29sKG9wTmFtZSwgYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHJldHVybiAhIXRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgfVxuXG4gICAgb3AxKG9wTmFtZSwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLkYubjgqMyk7XG4gICAgfVxuXG4gICAgb3AxQWZmaW5lKG9wTmFtZSwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLkYubjgqMik7XG4gICAgfVxuXG4gICAgb3AxQm9vbChvcE5hbWUsIGEpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHJldHVybiAhIXRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDMpO1xuICAgIH1cblxuICAgIGFkZChhLGIpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRcIiwgYSwgYik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRNaXhlZFwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRNaXhlZFwiLCBiLCBhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX2FkZEFmZmluZVwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3ViKGEsYikge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1YlwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1Yk1peGVkXCIsIGEsIGIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1Yk1peGVkXCIsIGIsIGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfc3ViQWZmaW5lXCIsIGEsIGIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZWcoYSkge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfbmVnXCIsIGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxQWZmaW5lKFwiX25lZ0FmZmluZVwiLCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRvdWJsZShhKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9kb3VibGVcIiwgYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfZG91YmxlQWZmaW5lXCIsIGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNaZXJvKGEpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1plcm9cIiwgYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzWmVyb0FmZmluZVwiLCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVzU2NhbGFyKGEsIHMpIHtcbiAgICAgICAgaWYgKCEocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBzID0gU2NhbGFyLnRvTEVCdWZmKFNjYWxhci5lKHMpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm5OYW1lO1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSB0aGlzLnByZWZpeCArIFwiX3RpbWVzU2NhbGFyXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSB0aGlzLnByZWZpeCArIFwiX3RpbWVzU2NhbGFyQWZmaW5lXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIHMpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbZm5OYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgcy5ieXRlTGVuZ3RoLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5GLm44KjMpO1xuICAgIH1cblxuICAgIHRpbWVzRnIoYSwgcykge1xuICAgICAgICBsZXQgZm5OYW1lO1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSB0aGlzLnByZWZpeCArIFwiX3RpbWVzRnJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IHRoaXMucHJlZml4ICsgXCJfdGltZXNGckFmZmluZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBzKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW2ZuTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLkYubjgqMyk7XG4gICAgfVxuXG4gICAgZXEoYSxiKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDJib29sKFwiX2VxXCIsIGEsIGIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDJib29sKFwiX2VxTWl4ZWRcIiwgYSwgYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDJib29sKFwiX2VxTWl4ZWRcIiwgYiwgYSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMmJvb2woXCJfZXFBZmZpbmVcIiwgYSwgYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvQWZmaW5lKGEpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxQWZmaW5lKFwiX3RvQWZmaW5lXCIsIGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b0phY29iaWFuKGEpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfdG9KYWNvYmlhblwiLCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvUnByVW5jb21wcmVzc2VkKGFyciwgb2Zmc2V0LCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl90b0FmZmluZVwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoICE9IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfTEVNdG9VXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AxKTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5GLm44KjIpO1xuICAgICAgICBhcnIuc2V0KHJlcywgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICBmcm9tUnByVW5jb21wcmVzc2VkKGFyciwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhcnIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLkYubjgqMik7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGJ1ZmYpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9VdG9MRU1cIl0odGhpcy5wT3AxLCB0aGlzLnBPcDEpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5GLm44KjIpO1xuICAgIH1cblxuICAgIHRvUnByQ29tcHJlc3NlZChhcnIsIG9mZnNldCwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfdG9BZmZpbmVcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCAhPSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX0xFTXRvQ1wiXSh0aGlzLnBPcDEsIHRoaXMucE9wMSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMuRi5uOCk7XG4gICAgICAgIGFyci5zZXQocmVzLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGZyb21ScHJDb21wcmVzc2VkKGFyciwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhcnIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLkYubjgpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBidWZmKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfQ3RvTEVNXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDIsIHRoaXMuRi5uOCoyKTtcbiAgICB9XG5cbiAgICB0b1VuY29tcHJlc3NlZChhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMik7XG4gICAgICAgIHRoaXMudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgYSk7XG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH1cblxuICAgIHRvUnByTEVNKGFyciwgb2Zmc2V0LCBhKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIGFyci5zZXQoYSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfdG9BZmZpbmVcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDEpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgYXJyLnNldChyZXMsIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmcm9tUnByTEVNKGFyciwgb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgICByZXR1cm4gYXJyLnNsaWNlKG9mZnNldCwgb2Zmc2V0K3RoaXMuRi5uOCoyKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZyhhLCByYWRpeCkge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UoMCwgdGhpcy5GLm44KSwgcmFkaXgpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpLCByYWRpeCk7XG4gICAgICAgICAgICBjb25zdCB6ID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UodGhpcy5GLm44KjIpLCByYWRpeCk7XG4gICAgICAgICAgICByZXR1cm4gYFsgJHt4fSwgJHt5fSwgJHt6fSBdYDtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSgwLCB0aGlzLkYubjgpLCByYWRpeCk7XG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UodGhpcy5GLm44KSwgcmFkaXgpO1xuICAgICAgICAgICAgcmV0dXJuIGBbICR7eH0sICR7eX0gXWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc1ZhbGlkKGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKGEpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcbiAgICAgICAgY29uc3QgYWEgPSB0aGlzLnRvQWZmaW5lKGEpO1xuICAgICAgICBjb25zdCB4ID0gYWEuc2xpY2UoMCwgdGhpcy5GLm44KTtcbiAgICAgICAgY29uc3QgeSA9IGFhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpO1xuICAgICAgICBjb25zdCB4M2IgPSBGLmFkZChGLm11bChGLnNxdWFyZSh4KSx4KSwgdGhpcy5iKTtcbiAgICAgICAgY29uc3QgeTIgPSBGLnNxdWFyZSh5KTtcbiAgICAgICAgcmV0dXJuIEYuZXEoeDNiLCB5Mik7XG4gICAgfVxuXG4gICAgZnJvbVJuZyhybmcpIHtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcbiAgICAgICAgbGV0IFAgPSBbXTtcbiAgICAgICAgbGV0IGdyZWF0ZXN0O1xuICAgICAgICBsZXQgeDNiO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBQWzBdID0gRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgICAgICBncmVhdGVzdCA9IHJuZy5uZXh0Qm9vbCgpO1xuICAgICAgICAgICAgeDNiID0gRi5hZGQoRi5tdWwoRi5zcXVhcmUoUFswXSksIFBbMF0pLCB0aGlzLmIpO1xuICAgICAgICB9IHdoaWxlICghRi5pc1NxdWFyZSh4M2IpKTtcblxuICAgICAgICBQWzFdID0gRi5zcXJ0KHgzYik7XG5cbiAgICAgICAgY29uc3QgcyA9IEYuaXNOZWdhdGl2ZShQWzFdKTtcbiAgICAgICAgaWYgKGdyZWF0ZXN0IF4gcykgUFsxXSA9IEYubmVnKFBbMV0pO1xuXG4gICAgICAgIGxldCBQYnVmZiA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCoyKTtcbiAgICAgICAgUGJ1ZmYuc2V0KFBbMF0pO1xuICAgICAgICBQYnVmZi5zZXQoUFsxXSwgdGhpcy5GLm44KTtcblxuICAgICAgICBpZiAodGhpcy5jb2ZhY3Rvcikge1xuICAgICAgICAgICAgUGJ1ZmYgPSB0aGlzLnRpbWVzU2NhbGFyKFBidWZmLCB0aGlzLmNvZmFjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQYnVmZjtcbiAgICB9XG5cblxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5GLnRvT2JqZWN0KHRoaXMuRi56ZXJvKSxcbiAgICAgICAgICAgICAgICB0aGlzLkYudG9PYmplY3QodGhpcy5GLm9uZSksXG4gICAgICAgICAgICAgICAgdGhpcy5GLnRvT2JqZWN0KHRoaXMuRi56ZXJvKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKDAsIHRoaXMuRi5uOCkpO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5GLnRvT2JqZWN0KGEuc2xpY2UodGhpcy5GLm44LCB0aGlzLkYubjgqMikpO1xuICAgICAgICBsZXQgejtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgeiA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKHRoaXMuRi5uOCoyLCB0aGlzLkYubjgqMykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeiA9IHRoaXMuRi50b09iamVjdCh0aGlzLkYub25lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgIH1cblxuICAgIGZyb21PYmplY3QoYSkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5GLmZyb21PYmplY3QoYVswXSk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLkYuZnJvbU9iamVjdChhWzFdKTtcbiAgICAgICAgbGV0IHo7XG4gICAgICAgIGlmIChhLmxlbmd0aD09Mykge1xuICAgICAgICAgICAgeiA9IHRoaXMuRi5mcm9tT2JqZWN0KGFbMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeiA9IHRoaXMuRi5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuRi5pc1plcm8oeiwgdGhpcy5GLm9uZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm9BZmZpbmU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5GLmVxKHosIHRoaXMuRi5vbmUpKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgYnVmZi5zZXQoeCk7XG4gICAgICAgICAgICBidWZmLnNldCh5LCB0aGlzLkYubjgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjMpO1xuICAgICAgICAgICAgYnVmZi5zZXQoeCk7XG4gICAgICAgICAgICBidWZmLnNldCh5LCB0aGlzLkYubjgpO1xuICAgICAgICAgICAgYnVmZi5zZXQoeiwgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlKGEpIHtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gYTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbU9iamVjdChhKTtcbiAgICB9XG5cbiAgICB4KGEpIHtcbiAgICAgICAgY29uc3QgdG1wID0gdGhpcy50b0FmZmluZShhKTtcbiAgICAgICAgcmV0dXJuIHRtcC5zbGljZSgwLCB0aGlzLkYubjgpO1xuICAgIH1cblxuICAgIHkoYSkge1xuICAgICAgICBjb25zdCB0bXAgPSB0aGlzLnRvQWZmaW5lKGEpO1xuICAgICAgICByZXR1cm4gdG1wLnNsaWNlKHRoaXMuRi5uOCk7XG4gICAgfVxuXG59XG5cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_curve.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field1.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field1.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WasmField1)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js\");\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./random.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js\");\n/* harmony import */ var _engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./engine_batchconvert.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js\");\n/* harmony import */ var _bigbuffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bigbuffer.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\");\n\n\n\n\n\n\n\nclass WasmField1 {\n\n    constructor(tm, prefix, n8, p) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.p = p;\n        this.n8 = n8;\n        this.type = \"F1\";\n        this.m = 1;\n\n        this.half = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.shiftRight(p, _scalar_js__WEBPACK_IMPORTED_MODULE_0__.one);\n        this.bitLength = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.bitLength(p);\n        this.mask = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.shiftLeft(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.one, this.bitLength), _scalar_js__WEBPACK_IMPORTED_MODULE_0__.one);\n\n        this.pOp1 = tm.alloc(n8);\n        this.pOp2 = tm.alloc(n8);\n        this.pOp3 = tm.alloc(n8);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = this.tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.n64 = Math.floor(n8/8);\n        this.n32 = Math.floor(n8/4);\n\n        if(this.n64*8 != this.n8) {\n            throw new Error(\"n8 must be a multiple of 8\");\n        }\n\n        this.half = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.shiftRight(this.p, _scalar_js__WEBPACK_IMPORTED_MODULE_0__.one);\n        this.nqr = this.two;\n        let r = this.exp(this.nqr, this.half);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.add(this.nqr, this.one);\n            r = this.exp(this.nqr, this.half);\n        }\n\n        this.shift = this.mul(this.nqr, this.nqr);\n        this.shiftInv = this.inv(this.shift);\n\n        this.s = 0;\n        let t = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(this.p, _scalar_js__WEBPACK_IMPORTED_MODULE_0__.one);\n\n        while ( !_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isOdd(t) ) {\n            this.s = this.s + 1;\n            t = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.shiftRight(t, _scalar_js__WEBPACK_IMPORTED_MODULE_0__.one);\n        }\n\n        this.w = [];\n        this.w[this.s] = this.exp(this.nqr, t);\n\n        for (let i= this.s-1; i>=0; i--) {\n            this.w[i] = this.square(this.w[i+1]);\n        }\n\n        if (!this.eq(this.w[0], this.one)) {\n            throw new Error(\"Error calculating roots of unity\");\n        }\n\n        this.batchToMontgomery = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(tm, prefix + \"_batchToMontgomery\", this.n8, this.n8);\n        this.batchFromMontgomery = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(tm, prefix + \"_batchFromMontgomery\", this.n8, this.n8);\n    }\n\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toLEBuff(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        let ra = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(a, b);\n        if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isNegative(ra)) {\n            ra = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.neg(ra);\n            if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.gt(ra, this.p)) {\n                ra = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(ra, this.p);\n            }\n            ra = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(this.p, ra);\n        } else {\n            if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.gt(ra, this.p)) {\n                ra = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(ra, this.p);\n            }\n        }\n        const buff = _utils_js__WEBPACK_IMPORTED_MODULE_1__.leInt2Buff(ra, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toString(a, radix) {\n        const an = this.fromMontgomery(a);\n        const s = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.fromRprLE(an, 0);\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toString(s, radix);\n    }\n\n    fromRng(rng) {\n        let v;\n        const buff = new Uint8Array(this.n8);\n        do {\n            v = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.zero;\n            for (let i=0; i<this.n64; i++) {\n                v = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.add(v,  _scalar_js__WEBPACK_IMPORTED_MODULE_0__.shiftLeft(rng.nextU64(), 64*i));\n            }\n            v = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.band(v, this.mask);\n        } while (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.geq(v, this.p));\n        _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toRprLE(buff, 0, v, this.n8);\n        return buff;\n    }\n\n    random() {\n        return this.fromRng((0,_random_js__WEBPACK_IMPORTED_MODULE_2__.getThreadRng)());\n    }\n\n    toObject(a) {\n        const an = this.fromMontgomery(a);\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.fromRprLE(an, 0);\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.n8);\n        _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toRprLE(buff, 0, a, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toRprLE(buff, offset, a) {\n        buff.set(this.fromMontgomery(a), offset);\n    }\n\n    toRprBE(buff, offset, a) {\n        const buff2 = this.fromMontgomery(a);\n        for (let i=0; i<this.n8/2; i++) {\n            const aux = buff2[i];\n            buff2[i] = buff2[this.n8-1-i];\n            buff2[this.n8-1-i] = aux;\n        }\n        buff.set(buff2, offset);\n    }\n\n    fromRprLE(buff, offset) {\n        offset = offset || 0;\n        const res = buff.slice(offset, offset + this.n8);\n        return this.toMontgomery(res);\n    }\n\n    async batchInverse(buffIn) {\n        let returnArray = false;\n        const sIn = this.n8;\n        const sOut = this.n8;\n\n        if (Array.isArray(buffIn)) {\n            buffIn = _utils_js__WEBPACK_IMPORTED_MODULE_1__.array2buffer(buffIn, sIn );\n            returnArray = true;\n        } else {\n            buffIn = buffIn.slice(0, buffIn.byteLength);\n        }\n\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/this.tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<this.tm.concurrency; i++) {\n            let n;\n            if (i< this.tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: this.prefix + \"_batchInverse\", params: [\n                    {var: 0},\n                    {val: sIn},\n                    {val: n},\n                    {var: 1},\n                    {val: sOut},\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                this.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]) {\n            fullBuffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        if (returnArray) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.buffer2array(fullBuffOut, sOut);\n        } else {\n            return fullBuffOut;\n        }\n\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy93YXNtX2ZpZWxkMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0M7QUFDRjtBQUNPO0FBQ2M7QUFDbEI7OztBQUd4Qjs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGtEQUFpQixJQUFJLDJDQUFVO0FBQ25ELHlCQUF5QixpREFBZ0I7QUFDekMsb0JBQW9CLDJDQUFVLENBQUMsaURBQWdCLENBQUMsMkNBQVUsbUJBQW1CLDJDQUFVOztBQUV2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrREFBaUIsU0FBUywyQ0FBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiwyQ0FBVSxTQUFTLDJDQUFVOztBQUU3QyxpQkFBaUIsNkNBQVk7QUFDN0I7QUFDQSxnQkFBZ0Isa0RBQWlCLElBQUksMkNBQVU7QUFDL0M7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsbUVBQWlCO0FBQ2xELG1DQUFtQyxtRUFBaUI7QUFDcEQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWUsQ0FBQyx5Q0FBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIseUNBQVE7QUFDekIsWUFBWSxrREFBaUI7QUFDN0IsaUJBQWlCLDJDQUFVO0FBQzNCLGdCQUFnQiwwQ0FBUztBQUN6QixxQkFBcUIsMkNBQVU7QUFDL0I7QUFDQSxpQkFBaUIsMkNBQVU7QUFDM0IsVUFBVTtBQUNWLGdCQUFnQiwwQ0FBUztBQUN6QixxQkFBcUIsMkNBQVU7QUFDL0I7QUFDQTtBQUNBLHFCQUFxQixpREFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFnQjtBQUNsQyxlQUFlLGdEQUFlO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFXO0FBQzNCLDBCQUEwQixZQUFZO0FBQ3RDLG9CQUFvQiwyQ0FBVSxLQUFLLGlEQUFnQjtBQUNuRDtBQUNBLGdCQUFnQiw0Q0FBVztBQUMzQixVQUFVLE9BQU8sMkNBQVU7QUFDM0IsUUFBUSwrQ0FBYztBQUN0QjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHdEQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGlEQUFnQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBYztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbURBQWtCO0FBQ3ZDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pELGlCQUFpQixtQ0FBbUM7QUFDcEQsaUJBQWlCO0FBQ2pCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixTQUFTO0FBQzlCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixVQUFVO0FBQy9CLGtCQUFrQjtBQUNsQixpQkFBaUIseUNBQXlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEIscURBQVM7QUFDdkMsOEJBQThCLHFEQUFTO0FBQ3ZDLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbURBQWtCO0FBQ3JDLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvd2FzbV9maWVsZDEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgU2NhbGFyIGZyb20gXCIuL3NjYWxhci5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IGdldFRocmVhZFJuZyB9IGZyb20gXCIuL3JhbmRvbS5qc1wiO1xuaW1wb3J0IGJ1aWxkQmF0Y2hDb252ZXJ0IGZyb20gXCIuL2VuZ2luZV9iYXRjaGNvbnZlcnQuanNcIjtcbmltcG9ydCBCaWdCdWZmZXIgZnJvbSBcIi4vYmlnYnVmZmVyLmpzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2FzbUZpZWxkMSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0bSwgcHJlZml4LCBuOCwgcCkge1xuICAgICAgICB0aGlzLnRtID0gdG07XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuXG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMubjggPSBuODtcbiAgICAgICAgdGhpcy50eXBlID0gXCJGMVwiO1xuICAgICAgICB0aGlzLm0gPSAxO1xuXG4gICAgICAgIHRoaXMuaGFsZiA9IFNjYWxhci5zaGlmdFJpZ2h0KHAsIFNjYWxhci5vbmUpO1xuICAgICAgICB0aGlzLmJpdExlbmd0aCA9IFNjYWxhci5iaXRMZW5ndGgocCk7XG4gICAgICAgIHRoaXMubWFzayA9IFNjYWxhci5zdWIoU2NhbGFyLnNoaWZ0TGVmdChTY2FsYXIub25lLCB0aGlzLmJpdExlbmd0aCksIFNjYWxhci5vbmUpO1xuXG4gICAgICAgIHRoaXMucE9wMSA9IHRtLmFsbG9jKG44KTtcbiAgICAgICAgdGhpcy5wT3AyID0gdG0uYWxsb2MobjgpO1xuICAgICAgICB0aGlzLnBPcDMgPSB0bS5hbGxvYyhuOCk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1twcmVmaXggKyBcIl96ZXJvXCJdKHRoaXMucE9wMSk7XG4gICAgICAgIHRoaXMuemVybyA9IHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMubjgpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfb25lXCJdKHRoaXMucE9wMSk7XG4gICAgICAgIHRoaXMub25lID0gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5uOCk7XG5cbiAgICAgICAgdGhpcy5uZWdvbmUgPSB0aGlzLm5lZyh0aGlzLm9uZSk7XG4gICAgICAgIHRoaXMudHdvID0gdGhpcy5hZGQodGhpcy5vbmUsIHRoaXMub25lKTtcblxuICAgICAgICB0aGlzLm42NCA9IE1hdGguZmxvb3IobjgvOCk7XG4gICAgICAgIHRoaXMubjMyID0gTWF0aC5mbG9vcihuOC80KTtcblxuICAgICAgICBpZih0aGlzLm42NCo4ICE9IHRoaXMubjgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm44IG11c3QgYmUgYSBtdWx0aXBsZSBvZiA4XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYWxmID0gU2NhbGFyLnNoaWZ0UmlnaHQodGhpcy5wLCBTY2FsYXIub25lKTtcbiAgICAgICAgdGhpcy5ucXIgPSB0aGlzLnR3bztcbiAgICAgICAgbGV0IHIgPSB0aGlzLmV4cCh0aGlzLm5xciwgdGhpcy5oYWxmKTtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmVxKHIsIHRoaXMubmVnb25lKSkge1xuICAgICAgICAgICAgdGhpcy5ucXIgPSB0aGlzLmFkZCh0aGlzLm5xciwgdGhpcy5vbmUpO1xuICAgICAgICAgICAgciA9IHRoaXMuZXhwKHRoaXMubnFyLCB0aGlzLmhhbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaGlmdCA9IHRoaXMubXVsKHRoaXMubnFyLCB0aGlzLm5xcik7XG4gICAgICAgIHRoaXMuc2hpZnRJbnYgPSB0aGlzLmludih0aGlzLnNoaWZ0KTtcblxuICAgICAgICB0aGlzLnMgPSAwO1xuICAgICAgICBsZXQgdCA9IFNjYWxhci5zdWIodGhpcy5wLCBTY2FsYXIub25lKTtcblxuICAgICAgICB3aGlsZSAoICFTY2FsYXIuaXNPZGQodCkgKSB7XG4gICAgICAgICAgICB0aGlzLnMgPSB0aGlzLnMgKyAxO1xuICAgICAgICAgICAgdCA9IFNjYWxhci5zaGlmdFJpZ2h0KHQsIFNjYWxhci5vbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53ID0gW107XG4gICAgICAgIHRoaXMud1t0aGlzLnNdID0gdGhpcy5leHAodGhpcy5ucXIsIHQpO1xuXG4gICAgICAgIGZvciAobGV0IGk9IHRoaXMucy0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMud1tpXSA9IHRoaXMuc3F1YXJlKHRoaXMud1tpKzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5lcSh0aGlzLndbMF0sIHRoaXMub25lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY2FsY3VsYXRpbmcgcm9vdHMgb2YgdW5pdHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJhdGNoVG9Nb250Z29tZXJ5ID0gYnVpbGRCYXRjaENvbnZlcnQodG0sIHByZWZpeCArIFwiX2JhdGNoVG9Nb250Z29tZXJ5XCIsIHRoaXMubjgsIHRoaXMubjgpO1xuICAgICAgICB0aGlzLmJhdGNoRnJvbU1vbnRnb21lcnkgPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hGcm9tTW9udGdvbWVyeVwiLCB0aGlzLm44LCB0aGlzLm44KTtcbiAgICB9XG5cblxuICAgIG9wMihvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgb3AyQm9vbChvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyKTtcbiAgICB9XG5cbiAgICBvcDEob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIG9wMUJvb2wob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICB9XG5cbiAgICBhZGQoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRcIiwgYSwgYik7XG4gICAgfVxuXG5cbiAgICBlcShhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyQm9vbChcIl9lcVwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzWmVyb1wiLCBhKTtcbiAgICB9XG5cbiAgICBzdWIoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9zdWJcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX25lZ1wiLCBhKTtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfaW52ZXJzZVwiLCBhKTtcbiAgICB9XG5cbiAgICB0b01vbnRnb21lcnkoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfdG9Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIGZyb21Nb250Z29tZXJ5KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX2Zyb21Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIG11bChhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX211bFwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2ludmVyc2VcIl0odGhpcy5wT3AyLCB0aGlzLnBPcDIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9tdWxcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfc3F1YXJlXCIsIGEpO1xuICAgIH1cblxuICAgIGlzU3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1NxdWFyZVwiLCBhKTtcbiAgICB9XG5cbiAgICBzcXJ0KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3NxcnRcIiwgYSk7XG4gICAgfVxuXG4gICAgZXhwKGEsIGIpIHtcbiAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBiID0gU2NhbGFyLnRvTEVCdWZmKFNjYWxhci5lKGIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2V4cFwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgYi5ieXRlTGVuZ3RoLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgaXNOZWdhdGl2ZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMUJvb2woXCJfaXNOZWdhdGl2ZVwiLCBhKTtcbiAgICB9XG5cbiAgICBlKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gYTtcbiAgICAgICAgbGV0IHJhID0gU2NhbGFyLmUoYSwgYik7XG4gICAgICAgIGlmIChTY2FsYXIuaXNOZWdhdGl2ZShyYSkpIHtcbiAgICAgICAgICAgIHJhID0gU2NhbGFyLm5lZyhyYSk7XG4gICAgICAgICAgICBpZiAoU2NhbGFyLmd0KHJhLCB0aGlzLnApKSB7XG4gICAgICAgICAgICAgICAgcmEgPSBTY2FsYXIubW9kKHJhLCB0aGlzLnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmEgPSBTY2FsYXIuc3ViKHRoaXMucCwgcmEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFNjYWxhci5ndChyYSwgdGhpcy5wKSkge1xuICAgICAgICAgICAgICAgIHJhID0gU2NhbGFyLm1vZChyYSwgdGhpcy5wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmID0gdXRpbHMubGVJbnQyQnVmZihyYSwgdGhpcy5uOCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvTW9udGdvbWVyeShidWZmKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZyhhLCByYWRpeCkge1xuICAgICAgICBjb25zdCBhbiA9IHRoaXMuZnJvbU1vbnRnb21lcnkoYSk7XG4gICAgICAgIGNvbnN0IHMgPSBTY2FsYXIuZnJvbVJwckxFKGFuLCAwKTtcbiAgICAgICAgcmV0dXJuIFNjYWxhci50b1N0cmluZyhzLCByYWRpeCk7XG4gICAgfVxuXG4gICAgZnJvbVJuZyhybmcpIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLm44KTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdiA9IFNjYWxhci56ZXJvO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMubjY0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2ID0gU2NhbGFyLmFkZCh2LCAgU2NhbGFyLnNoaWZ0TGVmdChybmcubmV4dFU2NCgpLCA2NCppKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ID0gU2NhbGFyLmJhbmQodiwgdGhpcy5tYXNrKTtcbiAgICAgICAgfSB3aGlsZSAoU2NhbGFyLmdlcSh2LCB0aGlzLnApKTtcbiAgICAgICAgU2NhbGFyLnRvUnByTEUoYnVmZiwgMCwgdiwgdGhpcy5uOCk7XG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH1cblxuICAgIHJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVJuZyhnZXRUaHJlYWRSbmcoKSk7XG4gICAgfVxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICBjb25zdCBhbiA9IHRoaXMuZnJvbU1vbnRnb21lcnkoYSk7XG4gICAgICAgIHJldHVybiBTY2FsYXIuZnJvbVJwckxFKGFuLCAwKTtcbiAgICB9XG5cbiAgICBmcm9tT2JqZWN0KGEpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubjgpO1xuICAgICAgICBTY2FsYXIudG9ScHJMRShidWZmLCAwLCBhLCB0aGlzLm44KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Nb250Z29tZXJ5KGJ1ZmYpO1xuICAgIH1cblxuICAgIHRvUnByTEUoYnVmZiwgb2Zmc2V0LCBhKSB7XG4gICAgICAgIGJ1ZmYuc2V0KHRoaXMuZnJvbU1vbnRnb21lcnkoYSksIG9mZnNldCk7XG4gICAgfVxuXG4gICAgdG9ScHJCRShidWZmLCBvZmZzZXQsIGEpIHtcbiAgICAgICAgY29uc3QgYnVmZjIgPSB0aGlzLmZyb21Nb250Z29tZXJ5KGEpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5uOC8yOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF1eCA9IGJ1ZmYyW2ldO1xuICAgICAgICAgICAgYnVmZjJbaV0gPSBidWZmMlt0aGlzLm44LTEtaV07XG4gICAgICAgICAgICBidWZmMlt0aGlzLm44LTEtaV0gPSBhdXg7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZi5zZXQoYnVmZjIsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgZnJvbVJwckxFKGJ1ZmYsIG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZi5zbGljZShvZmZzZXQsIG9mZnNldCArIHRoaXMubjgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b01vbnRnb21lcnkocmVzKTtcbiAgICB9XG5cbiAgICBhc3luYyBiYXRjaEludmVyc2UoYnVmZkluKSB7XG4gICAgICAgIGxldCByZXR1cm5BcnJheSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzSW4gPSB0aGlzLm44O1xuICAgICAgICBjb25zdCBzT3V0ID0gdGhpcy5uODtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmSW4pKSB7XG4gICAgICAgICAgICBidWZmSW4gPSB1dGlscy5hcnJheTJidWZmZXIoYnVmZkluLCBzSW4gKTtcbiAgICAgICAgICAgIHJldHVybkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZJbiA9IGJ1ZmZJbi5zbGljZSgwLCBidWZmSW4uYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuUG9pbnRzID0gTWF0aC5mbG9vcihidWZmSW4uYnl0ZUxlbmd0aCAvIHNJbik7XG4gICAgICAgIGlmICggblBvaW50cyAqIHNJbiAhPT0gYnVmZkluLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnVmZmVyIHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRzUGVyQ2h1bmsgPSBNYXRoLmZsb29yKG5Qb2ludHMvdGhpcy50bS5jb25jdXJyZW5jeSk7XG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMudG0uY29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgdGhpcy50bS5jb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IHBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqcG9pbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDaHVuayA9IGJ1ZmZJbi5zbGljZShpKnBvaW50c1BlckNodW5rKnNJbiwgaSpwb2ludHNQZXJDaHVuaypzSW4gKyBuKnNJbik7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW1xuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOmJ1ZmZDaHVua30sXG4gICAgICAgICAgICAgICAge2NtZDogXCJBTExPQ1wiLCB2YXI6IDEsIGxlbjpzT3V0ICogbn0sXG4gICAgICAgICAgICAgICAge2NtZDogXCJDQUxMXCIsIGZuTmFtZTogdGhpcy5wcmVmaXggKyBcIl9iYXRjaEludmVyc2VcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBzSW59LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IHNPdXR9LFxuICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAxLCBsZW46c091dCAqIG59LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0aGlzLnRtLnF1ZXVlQWN0aW9uKHRhc2spXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgbGV0IGZ1bGxCdWZmT3V0O1xuICAgICAgICBpZiAoYnVmZkluIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dCA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzT3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dC5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVybkFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuYnVmZmVyMmFycmF5KGZ1bGxCdWZmT3V0LCBzT3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdWxsQnVmZk91dDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WasmField2)\n/* harmony export */ });\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./random.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n\n\n\n\nclass WasmField2 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F2\";\n        this.m = F.m * 2;\n        this.n8 = this.F.n8*2;\n        this.n32 = this.F.n32*2;\n        this.n64 = this.F.n64*2;\n\n        this.pOp1 = tm.alloc(F.n8*2);\n        this.pOp2 = tm.alloc(F.n8*2);\n        this.pOp3 = tm.alloc(F.n8*2);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    mul1(a,b) {\n        return this.op2(\"_mul1\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = _scalar_js__WEBPACK_IMPORTED_MODULE_1__.toLEBuff(_scalar_js__WEBPACK_IMPORTED_MODULE_1__.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 2)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const res = new Uint8Array(this.F.n8*2);\n            res.set(c1);\n            res.set(c2, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F2\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8), radix);\n        return `[${s1}, ${s2}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*2);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        return res;\n    }\n\n    random() {\n        return this.fromRng((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.getThreadRng)());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        return [c1, c2];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8);\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy93YXNtX2ZpZWxkMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkM7QUFDTDs7O0FBR3ZCOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixnREFBZSxDQUFDLHlDQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHLElBQUksR0FBRztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHdEQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvd2FzbV9maWVsZDIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VGhyZWFkUm5nIH0gZnJvbSBcIi4vcmFuZG9tLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2FzbUZpZWxkMiB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0bSwgcHJlZml4LCBGKSB7XG4gICAgICAgIHRoaXMudG0gPSB0bTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG5cbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy50eXBlID0gXCJGMlwiO1xuICAgICAgICB0aGlzLm0gPSBGLm0gKiAyO1xuICAgICAgICB0aGlzLm44ID0gdGhpcy5GLm44KjI7XG4gICAgICAgIHRoaXMubjMyID0gdGhpcy5GLm4zMioyO1xuICAgICAgICB0aGlzLm42NCA9IHRoaXMuRi5uNjQqMjtcblxuICAgICAgICB0aGlzLnBPcDEgPSB0bS5hbGxvYyhGLm44KjIpO1xuICAgICAgICB0aGlzLnBPcDIgPSB0bS5hbGxvYyhGLm44KjIpO1xuICAgICAgICB0aGlzLnBPcDMgPSB0bS5hbGxvYyhGLm44KjIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfemVyb1wiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLnplcm8gPSB0bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5uOCk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1twcmVmaXggKyBcIl9vbmVcIl0odGhpcy5wT3AxKTtcbiAgICAgICAgdGhpcy5vbmUgPSB0bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5uOCk7XG5cbiAgICAgICAgdGhpcy5uZWdvbmUgPSB0aGlzLm5lZyh0aGlzLm9uZSk7XG4gICAgICAgIHRoaXMudHdvID0gdGhpcy5hZGQodGhpcy5vbmUsIHRoaXMub25lKTtcblxuICAgIH1cblxuICAgIG9wMihvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgb3AyQm9vbChvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyKTtcbiAgICB9XG5cbiAgICBvcDEob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIG9wMUJvb2wob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICB9XG5cbiAgICBhZGQoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgZXEoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMkJvb2woXCJfZXFcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgaXNaZXJvKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1plcm9cIiwgYSk7XG4gICAgfVxuXG4gICAgc3ViKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfc3ViXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIG5lZyhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9uZWdcIiwgYSk7XG4gICAgfVxuXG4gICAgaW52KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX2ludmVyc2VcIiwgYSk7XG4gICAgfVxuXG4gICAgaXNOZWdhdGl2ZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMUJvb2woXCJfaXNOZWdhdGl2ZVwiLCBhKTtcbiAgICB9XG5cbiAgICB0b01vbnRnb21lcnkoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfdG9Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIGZyb21Nb250Z29tZXJ5KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX2Zyb21Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIG11bChhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX211bFwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBtdWwxKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfbXVsMVwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2ludmVyc2VcIl0odGhpcy5wT3AyLCB0aGlzLnBPcDIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9tdWxcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfc3F1YXJlXCIsIGEpO1xuICAgIH1cblxuICAgIGlzU3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1NxdWFyZVwiLCBhKTtcbiAgICB9XG5cbiAgICBzcXJ0KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3NxcnRcIiwgYSk7XG4gICAgfVxuXG4gICAgZXhwKGEsIGIpIHtcbiAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBiID0gU2NhbGFyLnRvTEVCdWZmKFNjYWxhci5lKGIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2V4cFwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgYi5ieXRlTGVuZ3RoLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgZShhLCBiKSB7XG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkgcmV0dXJuIGE7XG4gICAgICAgIGlmICgoQXJyYXkuaXNBcnJheShhKSkgJiYgKGEubGVuZ3RoID09IDIpKSB7XG4gICAgICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5lKGFbMF0sIGIpO1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZShhWzFdLCBiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIHJlcy5zZXQoYzEpO1xuICAgICAgICAgICAgcmVzLnNldChjMiwgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgRjJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZyhhLCByYWRpeCkge1xuICAgICAgICBjb25zdCBzMSA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKDAsIHRoaXMuRi5uOCksIHJhZGl4KTtcbiAgICAgICAgY29uc3QgczIgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSh0aGlzLkYubjgpLCByYWRpeCk7XG4gICAgICAgIHJldHVybiBgWyR7czF9LCAke3MyfV1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMik7XG4gICAgICAgIHJlcy5zZXQoYzEpO1xuICAgICAgICByZXMuc2V0KGMyLCB0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVJuZyhnZXRUaHJlYWRSbmcoKSk7XG4gICAgfVxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKDAsIHRoaXMuRi5uOCkpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpKTtcbiAgICAgICAgcmV0dXJuIFtjMSwgYzJdO1xuICAgIH1cblxuICAgIGZyb21PYmplY3QoYSkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjIpO1xuICAgICAgICBjb25zdCBiMSA9IHRoaXMuRi5mcm9tT2JqZWN0KGFbMF0pO1xuICAgICAgICBjb25zdCBiMiA9IHRoaXMuRi5mcm9tT2JqZWN0KGFbMV0pO1xuICAgICAgICBidWZmLnNldChiMSk7XG4gICAgICAgIGJ1ZmYuc2V0KGIyLCB0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gYnVmZjtcbiAgICB9XG5cbiAgICBjMShhKSB7XG4gICAgICAgIHJldHVybiBhLnNsaWNlKDAsIHRoaXMuRi5uOCk7XG4gICAgfVxuXG4gICAgYzIoYSkge1xuICAgICAgICByZXR1cm4gYS5zbGljZSh0aGlzLkYubjgpO1xuICAgIH1cblxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field3.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field3.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WasmField3)\n/* harmony export */ });\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./random.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar.js */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n\n\n\n\n\n\nclass WasmField3 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F3\";\n        this.m = F.m * 3;\n        this.n8 = this.F.n8*3;\n        this.n32 = this.F.n32*3;\n        this.n64 = this.F.n64*3;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = _scalar_js__WEBPACK_IMPORTED_MODULE_1__.toLEBuff(_scalar_js__WEBPACK_IMPORTED_MODULE_1__.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 3)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const c3 = this.F.e(a[2], b);\n            const res = new Uint8Array(this.F.n8*3);\n            res.set(c1);\n            res.set(c2, this.F.n8);\n            res.set(c3, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F3\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n        const s3 = this.F.toString(a.slice(this.F.n8*2), radix);\n        return `[${s1}, ${s2}, ${s3}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const c3 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*3);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        res.set(c3, this.F.n8*2);\n        return res;\n    }\n\n    random() {\n        return this.fromRng((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.getThreadRng)());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        const c3 = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        return [c1, c2, c3];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*3);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        const b3 = this.F.fromObject(a[2]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        buff.set(b3, this.F.n8*2);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8, this.F.n8*2);\n    }\n\n    c3(a) {\n        return a.slice(this.F.n8*2);\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy93YXNtX2ZpZWxkMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUUyQztBQUNMOzs7QUFHdkI7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFlLENBQUMseUNBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qix3REFBWTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy93YXNtX2ZpZWxkMy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0IHsgZ2V0VGhyZWFkUm5nIH0gZnJvbSBcIi4vcmFuZG9tLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2FzbUZpZWxkMyB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0bSwgcHJlZml4LCBGKSB7XG4gICAgICAgIHRoaXMudG0gPSB0bTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG5cbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy50eXBlID0gXCJGM1wiO1xuICAgICAgICB0aGlzLm0gPSBGLm0gKiAzO1xuICAgICAgICB0aGlzLm44ID0gdGhpcy5GLm44KjM7XG4gICAgICAgIHRoaXMubjMyID0gdGhpcy5GLm4zMiozO1xuICAgICAgICB0aGlzLm42NCA9IHRoaXMuRi5uNjQqMztcblxuICAgICAgICB0aGlzLnBPcDEgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnBPcDIgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnBPcDMgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfemVyb1wiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLnplcm8gPSB0bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5uOCk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1twcmVmaXggKyBcIl9vbmVcIl0odGhpcy5wT3AxKTtcbiAgICAgICAgdGhpcy5vbmUgPSB0bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5uOCk7XG5cbiAgICAgICAgdGhpcy5uZWdvbmUgPSB0aGlzLm5lZyh0aGlzLm9uZSk7XG4gICAgICAgIHRoaXMudHdvID0gdGhpcy5hZGQodGhpcy5vbmUsIHRoaXMub25lKTtcblxuICAgIH1cblxuICAgIG9wMihvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgb3AyQm9vbChvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyKTtcbiAgICB9XG5cbiAgICBvcDEob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIG9wMUJvb2wob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICB9XG5cblxuICAgIGVxKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDJCb29sKFwiX2VxXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIGlzWmVybyhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMUJvb2woXCJfaXNaZXJvXCIsIGEpO1xuICAgIH1cblxuICAgIGFkZChhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX2FkZFwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBzdWIoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9zdWJcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX25lZ1wiLCBhKTtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfaW52ZXJzZVwiLCBhKTtcbiAgICB9XG5cbiAgICBpc05lZ2F0aXZlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc05lZ2F0aXZlXCIsIGEpO1xuICAgIH1cblxuICAgIHRvTW9udGdvbWVyeShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl90b01vbnRnb21lcnlcIiwgYSk7XG4gICAgfVxuXG4gICAgZnJvbU1vbnRnb21lcnkoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfZnJvbU1vbnRnb21lcnlcIiwgYSk7XG4gICAgfVxuXG4gICAgbXVsKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfbXVsXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIGRpdihhLCBiKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfaW52ZXJzZVwiXSh0aGlzLnBPcDIsIHRoaXMucE9wMik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX211bFwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIHNxdWFyZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9zcXVhcmVcIiwgYSk7XG4gICAgfVxuXG4gICAgaXNTcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzU3F1YXJlXCIsIGEpO1xuICAgIH1cblxuICAgIHNxcnQoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfc3FydFwiLCBhKTtcbiAgICB9XG5cbiAgICBleHAoYSwgYikge1xuICAgICAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgIGIgPSBTY2FsYXIudG9MRUJ1ZmYoU2NhbGFyLmUoYikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfZXhwXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCBiLmJ5dGVMZW5ndGgsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBlKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gYTtcbiAgICAgICAgaWYgKChBcnJheS5pc0FycmF5KGEpKSAmJiAoYS5sZW5ndGggPT0gMykpIHtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmUoYVswXSwgYik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5lKGFbMV0sIGIpO1xuICAgICAgICAgICAgY29uc3QgYzMgPSB0aGlzLkYuZShhWzJdLCBiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCozKTtcbiAgICAgICAgICAgIHJlcy5zZXQoYzEpO1xuICAgICAgICAgICAgcmVzLnNldChjMiwgdGhpcy5GLm44KTtcbiAgICAgICAgICAgIHJlcy5zZXQoYzMsIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEYzXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoYSwgcmFkaXgpIHtcbiAgICAgICAgY29uc3QgczEgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSgwLCB0aGlzLkYubjgpLCByYWRpeCk7XG4gICAgICAgIGNvbnN0IHMyID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UodGhpcy5GLm44LCB0aGlzLkYubjgqMiksIHJhZGl4KTtcbiAgICAgICAgY29uc3QgczMgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSh0aGlzLkYubjgqMiksIHJhZGl4KTtcbiAgICAgICAgcmV0dXJuIGBbJHtzMX0sICR7czJ9LCAke3MzfV1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCBjMyA9IHRoaXMuRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCozKTtcbiAgICAgICAgcmVzLnNldChjMSk7XG4gICAgICAgIHJlcy5zZXQoYzIsIHRoaXMuRi5uOCk7XG4gICAgICAgIHJlcy5zZXQoYzMsIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICByYW5kb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21SbmcoZ2V0VGhyZWFkUm5nKCkpO1xuICAgIH1cblxuICAgIHRvT2JqZWN0KGEpIHtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYudG9PYmplY3QoYS5zbGljZSgwLCB0aGlzLkYubjgpKTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYudG9PYmplY3QoYS5zbGljZSh0aGlzLkYubjgsIHRoaXMuRi5uOCoyKSk7XG4gICAgICAgIGNvbnN0IGMzID0gdGhpcy5GLnRvT2JqZWN0KGEuc2xpY2UodGhpcy5GLm44KjIsIHRoaXMuRi5uOCozKSk7XG4gICAgICAgIHJldHVybiBbYzEsIGMyLCBjM107XG4gICAgfVxuXG4gICAgZnJvbU9iamVjdChhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMyk7XG4gICAgICAgIGNvbnN0IGIxID0gdGhpcy5GLmZyb21PYmplY3QoYVswXSk7XG4gICAgICAgIGNvbnN0IGIyID0gdGhpcy5GLmZyb21PYmplY3QoYVsxXSk7XG4gICAgICAgIGNvbnN0IGIzID0gdGhpcy5GLmZyb21PYmplY3QoYVsyXSk7XG4gICAgICAgIGJ1ZmYuc2V0KGIxKTtcbiAgICAgICAgYnVmZi5zZXQoYjIsIHRoaXMuRi5uOCk7XG4gICAgICAgIGJ1ZmYuc2V0KGIzLCB0aGlzLkYubjgqMik7XG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH1cblxuICAgIGMxKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuc2xpY2UoMCwgdGhpcy5GLm44KTtcbiAgICB9XG5cbiAgICBjMihhKSB7XG4gICAgICAgIHJldHVybiBhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpO1xuICAgIH1cblxuICAgIGMzKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuc2xpY2UodGhpcy5GLm44KjIpO1xuICAgIH1cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/Keccak256Transcript.js":
/*!*********************************************************!*\
  !*** ./node_modules/snarkjs/src/Keccak256Transcript.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak256Transcript: () => (/* binding */ Keccak256Transcript)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(rsc)/./node_modules/@noble/hashes/esm/sha3.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst POLYNOMIAL = 0;\nconst SCALAR = 1;\n\nclass Keccak256Transcript {\n    constructor(curve) {\n        this.G1 = curve.G1;\n        this.Fr = curve.Fr;\n\n        this.reset();\n    }\n\n    reset() {\n        this.data = [];\n    }\n\n    addPolCommitment(polynomialCommitment) {\n        this.data.push({type: POLYNOMIAL, data: polynomialCommitment});\n    }\n\n    addScalar(scalar) {\n        this.data.push({type: SCALAR, data: scalar});\n    }\n\n    getChallenge() {\n        if(0 === this.data.length) {\n            throw new Error(\"Keccak256Transcript: No data to generate a transcript\");\n        }\n\n        let nPolynomials = 0;\n        let nScalars = 0;\n\n        this.data.forEach(element => POLYNOMIAL === element.type ? nPolynomials++ : nScalars++);\n\n        let buffer = new Uint8Array(nScalars * this.Fr.n8 + nPolynomials * this.G1.F.n8 * 2);\n        let offset = 0;\n\n        for (let i = 0; i < this.data.length; i++) {\n            if (POLYNOMIAL === this.data[i].type) {\n                this.G1.toRprUncompressed(buffer, offset, this.data[i].data);\n                offset += this.G1.F.n8 * 2;\n            } else {\n                this.Fr.toRprBE(buffer, offset, this.data[i].data);\n                offset += this.Fr.n8;\n            }\n        }\n\n        const value = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprBE((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_1__.keccak_256)(buffer));\n        return this.Fr.e(value);\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvS2VjY2FrMjU2VHJhbnNjcmlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvQztBQUNVOztBQUU5QztBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDZDQUE2QztBQUNyRTs7QUFFQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnREFBTSxXQUFXLDhEQUFVO0FBQ2pEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9LZWNjYWsyNTZUcmFuc2NyaXB0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7U2NhbGFyfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQge2tlY2Nha18yNTZ9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTNcIjtcblxuY29uc3QgUE9MWU5PTUlBTCA9IDA7XG5jb25zdCBTQ0FMQVIgPSAxO1xuXG5leHBvcnQgY2xhc3MgS2VjY2FrMjU2VHJhbnNjcmlwdCB7XG4gICAgY29uc3RydWN0b3IoY3VydmUpIHtcbiAgICAgICAgdGhpcy5HMSA9IGN1cnZlLkcxO1xuICAgICAgICB0aGlzLkZyID0gY3VydmUuRnI7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG5cbiAgICBhZGRQb2xDb21taXRtZW50KHBvbHlub21pYWxDb21taXRtZW50KSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKHt0eXBlOiBQT0xZTk9NSUFMLCBkYXRhOiBwb2x5bm9taWFsQ29tbWl0bWVudH0pO1xuICAgIH1cblxuICAgIGFkZFNjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2goe3R5cGU6IFNDQUxBUiwgZGF0YTogc2NhbGFyfSk7XG4gICAgfVxuXG4gICAgZ2V0Q2hhbGxlbmdlKCkge1xuICAgICAgICBpZigwID09PSB0aGlzLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZWNjYWsyNTZUcmFuc2NyaXB0OiBObyBkYXRhIHRvIGdlbmVyYXRlIGEgdHJhbnNjcmlwdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuUG9seW5vbWlhbHMgPSAwO1xuICAgICAgICBsZXQgblNjYWxhcnMgPSAwO1xuXG4gICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGVsZW1lbnQgPT4gUE9MWU5PTUlBTCA9PT0gZWxlbWVudC50eXBlID8gblBvbHlub21pYWxzKysgOiBuU2NhbGFycysrKTtcblxuICAgICAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoblNjYWxhcnMgKiB0aGlzLkZyLm44ICsgblBvbHlub21pYWxzICogdGhpcy5HMS5GLm44ICogMik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoUE9MWU5PTUlBTCA9PT0gdGhpcy5kYXRhW2ldLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkcxLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmZlciwgb2Zmc2V0LCB0aGlzLmRhdGFbaV0uZGF0YSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuRzEuRi5uOCAqIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuRnIudG9ScHJCRShidWZmZXIsIG9mZnNldCwgdGhpcy5kYXRhW2ldLmRhdGEpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLkZyLm44O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBTY2FsYXIuZnJvbVJwckJFKGtlY2Nha18yNTYoYnVmZmVyKSk7XG4gICAgICAgIHJldHVybiB0aGlzLkZyLmUodmFsdWUpO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/Keccak256Transcript.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/bigarray.js":
/*!**********************************************!*\
  !*** ./node_modules/snarkjs/src/bigarray.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BigArray);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvYmlnYXJyYXkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9iaWdhcnJheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCBTVUJBUlJBWV9TSVpFID0gMHg0MDAwMDtcblxuY29uc3QgQmlnQXJyYXlIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gICAgICAgIGlmICghaXNOYU4ocHJvcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouZ2V0RWxlbWVudChwcm9wKTtcbiAgICAgICAgfSBlbHNlIHJldHVybiBvYmpbcHJvcF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05hTihwcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5zZXRFbGVtZW50KHByb3AsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jbGFzcyBfQmlnQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yIChpbml0U2l6ZSkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGluaXRTaXplIHx8IDA7XG4gICAgICAgIHRoaXMuYXJyID0gbmV3IEFycmF5KFNVQkFSUkFZX1NJWkUpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxpbml0U2l6ZTsgaSs9U1VCQVJSQVlfU0laRSkge1xuICAgICAgICAgICAgdGhpcy5hcnJbaS9TVUJBUlJBWV9TSVpFXSA9IG5ldyBBcnJheShNYXRoLm1pbihTVUJBUlJBWV9TSVpFLCBpbml0U2l6ZSAtIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHVzaCAoKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudCAodGhpcy5sZW5ndGgsIGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzbGljZSAoZiwgdCkge1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkodC1mKTtcbiAgICAgICAgZm9yIChsZXQgaT1mOyBpPCB0OyBpKyspIGFycltpLWZdID0gdGhpcy5nZXRFbGVtZW50KGkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBnZXRFbGVtZW50KGlkeCkge1xuICAgICAgICBpZHggPSBwYXJzZUludChpZHgpO1xuICAgICAgICBjb25zdCBpZHgxID0gTWF0aC5mbG9vcihpZHggLyBTVUJBUlJBWV9TSVpFKTtcbiAgICAgICAgY29uc3QgaWR4MiA9IGlkeCAlIFNVQkFSUkFZX1NJWkU7XG4gICAgICAgIHJldHVybiB0aGlzLmFycltpZHgxXSA/IHRoaXMuYXJyW2lkeDFdW2lkeDJdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXRFbGVtZW50KGlkeCwgdmFsdWUpIHtcbiAgICAgICAgaWR4ID0gcGFyc2VJbnQoaWR4KTtcbiAgICAgICAgY29uc3QgaWR4MSA9IE1hdGguZmxvb3IoaWR4IC8gU1VCQVJSQVlfU0laRSk7XG4gICAgICAgIGlmICghdGhpcy5hcnJbaWR4MV0pIHtcbiAgICAgICAgICAgIHRoaXMuYXJyW2lkeDFdID0gbmV3IEFycmF5KFNVQkFSUkFZX1NJWkUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkeDIgPSBpZHggJSBTVUJBUlJBWV9TSVpFO1xuICAgICAgICB0aGlzLmFycltpZHgxXVtpZHgyXSA9IHZhbHVlO1xuICAgICAgICBpZiAoaWR4ID49IHRoaXMubGVuZ3RoKSB0aGlzLmxlbmd0aCA9IGlkeCsxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgY29uc3QgbmV3QSA9IG5ldyBCaWdBcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5hcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFycltpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajx0aGlzLmFycltpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuYXJyW2ldW2pdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdBLnB1c2goaSpTVUJBUlJBWV9TSVpFK2opO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdBO1xuICAgIH1cbn1cblxuY2xhc3MgQmlnQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKCBpbml0U2l6ZSApIHtcbiAgICAgICAgY29uc3Qgb2JqID0gbmV3IF9CaWdBcnJheShpbml0U2l6ZSk7XG4gICAgICAgIGNvbnN0IGV4dE9iaiA9IG5ldyBQcm94eShvYmosIEJpZ0FycmF5SGFuZGxlcik7XG4gICAgICAgIHJldHVybiBleHRPYmo7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCaWdBcnJheTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/bigarray.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/curves.js":
/*!********************************************!*\
  !*** ./node_modules/snarkjs/src/curves.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurveFromName: () => (/* binding */ getCurveFromName),\n/* harmony export */   getCurveFromQ: () => (/* binding */ getCurveFromQ),\n/* harmony export */   getCurveFromR: () => (/* binding */ getCurveFromR)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n\n\nconst bls12381r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nasync function getCurveFromR(r, options) {\n    let curve;\n    // check that options param is defined and that options.singleThread is defined\n    let singleThread = options && options.singleThread;\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(r, bn128r)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(r, bls12381r)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromQ(q, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(q, bn128q)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(q, bls12381q)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(q)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromName(name, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvY3VydmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0U7O0FBRWhFLGtCQUFrQixnREFBTTtBQUN4QixlQUFlLGdEQUFNOztBQUVyQixrQkFBa0IsZ0RBQU07QUFDeEIsZUFBZSxnREFBTTs7QUFFZDtBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQU07QUFDZCxzQkFBc0Isd0RBQVU7QUFDaEMsTUFBTSxTQUFTLGdEQUFNO0FBQ3JCLHNCQUFzQiwyREFBYTtBQUNuQyxNQUFNO0FBQ04sZ0RBQWdELGdEQUFNLGFBQWE7QUFDbkU7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLFFBQVEsZ0RBQU07QUFDZCxzQkFBc0Isd0RBQVU7QUFDaEMsTUFBTSxTQUFTLGdEQUFNO0FBQ3JCLHNCQUFzQiwyREFBYTtBQUNuQyxNQUFNO0FBQ04sZ0RBQWdELGdEQUFNLGFBQWE7QUFDbkU7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQVU7QUFDaEMsTUFBTTtBQUNOLHNCQUFzQiwyREFBYTtBQUNuQyxNQUFNO0FBQ04sZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvY3VydmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNjYWxhciwgYnVpbGRCbjEyOCwgYnVpbGRCbHMxMjM4MX0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5jb25zdCBibHMxMjM4MXIgPSBTY2FsYXIuZShcIjczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDFcIiwgMTYpO1xuY29uc3QgYm4xMjhyID0gU2NhbGFyLmUoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODU0ODM2NDQwMDQxNjAzNDM0MzY5ODIwNDE4NjU3NTgwODQ5NTYxN1wiKTtcblxuY29uc3QgYmxzMTIzODFxID0gU2NhbGFyLmUoXCIxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJcIiwgMTYpO1xuY29uc3QgYm4xMjhxID0gU2NhbGFyLmUoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODY5NjMxMTE1NzI5NzgyMzY2MjY4OTAzNzg5NDY0NTIyNjIwODU4M1wiKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnZlRnJvbVIociwgb3B0aW9ucykge1xuICAgIGxldCBjdXJ2ZTtcbiAgICAvLyBjaGVjayB0aGF0IG9wdGlvbnMgcGFyYW0gaXMgZGVmaW5lZCBhbmQgdGhhdCBvcHRpb25zLnNpbmdsZVRocmVhZCBpcyBkZWZpbmVkXG4gICAgbGV0IHNpbmdsZVRocmVhZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaW5nbGVUaHJlYWQ7XG4gICAgaWYgKFNjYWxhci5lcShyLCBibjEyOHIpKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbjEyOChzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSBpZiAoU2NhbGFyLmVxKHIsIGJsczEyMzgxcikpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke1NjYWxhci50b1N0cmluZyhyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VydmVGcm9tUShxLCBvcHRpb25zKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIGxldCBzaW5nbGVUaHJlYWQgPSBvcHRpb25zICYmIG9wdGlvbnMuc2luZ2xlVGhyZWFkO1xuICAgIGlmIChTY2FsYXIuZXEocSwgYm4xMjhxKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQm4xMjgoc2luZ2xlVGhyZWFkKTtcbiAgICB9IGVsc2UgaWYgKFNjYWxhci5lcShxLCBibHMxMjM4MXEpKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbHMxMjM4MShzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3VydmUgbm90IHN1cHBvcnRlZDogJHtTY2FsYXIudG9TdHJpbmcocSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2ZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnZlRnJvbU5hbWUobmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBjdXJ2ZTtcbiAgICBsZXQgc2luZ2xlVGhyZWFkID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpbmdsZVRocmVhZDtcbiAgICBjb25zdCBub3JtTmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgaWYgKFtcIkJOMTI4XCIsIFwiQk4yNTRcIiwgXCJBTFRCTjEyOFwiXS5pbmRleE9mKG5vcm1OYW1lKSA+PSAwKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbjEyOChzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSBpZiAoW1wiQkxTMTIzODFcIl0uaW5kZXhPZihub3JtTmFtZSkgPj0gMCkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQmxzMTIzODEoc2luZ2xlVGhyZWFkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN1cnZlIG5vdCBzdXBwb3J0ZWQ6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuKSB7XG4gICAgICAgIHJldHVybiBuLnRvVXBwZXJDYXNlKCkubWF0Y2goL1tBLVphLXowLTldKy9nKS5qb2luKFwiXCIpO1xuICAgIH1cblxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/curves.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/fflonk.js":
/*!********************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _fflonk_export_calldata_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   exportSolidityVerifier: () => (/* reexport safe */ _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _fflonk_full_prove_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   setup: () => (/* reexport safe */ _fflonk_setup_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _fflonk_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _fflonk_setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fflonk_setup.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk_setup.js\");\n/* harmony import */ var _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fflonk_prove.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk_prove.js\");\n/* harmony import */ var _fflonk_full_prove_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fflonk_full_prove.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk_full_prove.js\");\n/* harmony import */ var _fflonk_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fflonk_verify.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk_verify.js\");\n/* harmony import */ var _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fflonk_export_solidity_verifier.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\");\n/* harmony import */ var _fflonk_export_calldata_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_export_calldata.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk_export_calldata.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFEO0FBQ0E7QUFDUztBQUNQO0FBQ2tDO0FBQ1QiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgc2V0dXAgfSBmcm9tIFwiLi9mZmxvbmtfc2V0dXAuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJvdmUgfSBmcm9tIFwiLi9mZmxvbmtfcHJvdmUuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZnVsbFByb3ZlIH0gZnJvbSBcIi4vZmZsb25rX2Z1bGxfcHJvdmUuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyaWZ5IH0gZnJvbSBcIi4vZmZsb25rX3ZlcmlmeS5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBleHBvcnRTb2xpZGl0eVZlcmlmaWVyIH0gZnJvbSBcIi4vZmZsb25rX2V4cG9ydF9zb2xpZGl0eV92ZXJpZmllci5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBleHBvcnRTb2xpZGl0eUNhbGxEYXRhIH0gZnJvbSBcIi4vZmZsb25rX2V4cG9ydF9jYWxsZGF0YS5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/fflonk.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/fflonk_constants.js":
/*!******************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ A),\n/* harmony export */   FF_T_POL_DEG_MIN: () => (/* binding */ FF_T_POL_DEG_MIN),\n/* harmony export */   ZKEY_FF_ADDITIONS_SECTION: () => (/* binding */ ZKEY_FF_ADDITIONS_SECTION),\n/* harmony export */   ZKEY_FF_A_MAP_SECTION: () => (/* binding */ ZKEY_FF_A_MAP_SECTION),\n/* harmony export */   ZKEY_FF_B_MAP_SECTION: () => (/* binding */ ZKEY_FF_B_MAP_SECTION),\n/* harmony export */   ZKEY_FF_C0_SECTION: () => (/* binding */ ZKEY_FF_C0_SECTION),\n/* harmony export */   ZKEY_FF_C_MAP_SECTION: () => (/* binding */ ZKEY_FF_C_MAP_SECTION),\n/* harmony export */   ZKEY_FF_HEADER_SECTION: () => (/* binding */ ZKEY_FF_HEADER_SECTION),\n/* harmony export */   ZKEY_FF_LAGRANGE_SECTION: () => (/* binding */ ZKEY_FF_LAGRANGE_SECTION),\n/* harmony export */   ZKEY_FF_NSECTIONS: () => (/* binding */ ZKEY_FF_NSECTIONS),\n/* harmony export */   ZKEY_FF_PTAU_SECTION: () => (/* binding */ ZKEY_FF_PTAU_SECTION),\n/* harmony export */   ZKEY_FF_QC_SECTION: () => (/* binding */ ZKEY_FF_QC_SECTION),\n/* harmony export */   ZKEY_FF_QL_SECTION: () => (/* binding */ ZKEY_FF_QL_SECTION),\n/* harmony export */   ZKEY_FF_QM_SECTION: () => (/* binding */ ZKEY_FF_QM_SECTION),\n/* harmony export */   ZKEY_FF_QO_SECTION: () => (/* binding */ ZKEY_FF_QO_SECTION),\n/* harmony export */   ZKEY_FF_QR_SECTION: () => (/* binding */ ZKEY_FF_QR_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA1_SECTION: () => (/* binding */ ZKEY_FF_SIGMA1_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA2_SECTION: () => (/* binding */ ZKEY_FF_SIGMA2_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA3_SECTION: () => (/* binding */ ZKEY_FF_SIGMA3_SECTION)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// FFlonk constants\nconst FF_T_POL_DEG_MIN = 3;\n\n// FFlonk A\nconst A = 12;\n\n// ZKEY constants\nconst ZKEY_FF_NSECTIONS = 17;\n\nconst ZKEY_FF_HEADER_SECTION = 2;\nconst ZKEY_FF_ADDITIONS_SECTION = 3;\nconst ZKEY_FF_A_MAP_SECTION = 4;\nconst ZKEY_FF_B_MAP_SECTION = 5;\nconst ZKEY_FF_C_MAP_SECTION = 6;\nconst ZKEY_FF_QL_SECTION = 7;\nconst ZKEY_FF_QR_SECTION = 8;\nconst ZKEY_FF_QM_SECTION = 9;\nconst ZKEY_FF_QO_SECTION = 10;\nconst ZKEY_FF_QC_SECTION = 11;\nconst ZKEY_FF_SIGMA1_SECTION = 12;\nconst ZKEY_FF_SIGMA2_SECTION = 13;\nconst ZKEY_FF_SIGMA3_SECTION = 14;\nconst ZKEY_FF_LAGRANGE_SECTION = 15;\nconst ZKEY_FF_PTAU_SECTION = 16;\nconst ZKEY_FF_C0_SECTION = 17;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPOztBQUVQO0FBQ087O0FBRVA7QUFDTzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIEZGbG9uayBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBGRl9UX1BPTF9ERUdfTUlOID0gMztcblxuLy8gRkZsb25rIEFcbmV4cG9ydCBjb25zdCBBID0gMTI7XG5cbi8vIFpLRVkgY29uc3RhbnRzXG5leHBvcnQgY29uc3QgWktFWV9GRl9OU0VDVElPTlMgPSAxNztcblxuZXhwb3J0IGNvbnN0IFpLRVlfRkZfSEVBREVSX1NFQ1RJT04gPSAyO1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfQURESVRJT05TX1NFQ1RJT04gPSAzO1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfQV9NQVBfU0VDVElPTiA9IDQ7XG5leHBvcnQgY29uc3QgWktFWV9GRl9CX01BUF9TRUNUSU9OID0gNTtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX0NfTUFQX1NFQ1RJT04gPSA2O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfUUxfU0VDVElPTiA9IDc7XG5leHBvcnQgY29uc3QgWktFWV9GRl9RUl9TRUNUSU9OID0gODtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX1FNX1NFQ1RJT04gPSA5O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfUU9fU0VDVElPTiA9IDEwO1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfUUNfU0VDVElPTiA9IDExO1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfU0lHTUExX1NFQ1RJT04gPSAxMjtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX1NJR01BMl9TRUNUSU9OID0gMTM7XG5leHBvcnQgY29uc3QgWktFWV9GRl9TSUdNQTNfU0VDVElPTiA9IDE0O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfTEFHUkFOR0VfU0VDVElPTiA9IDE1O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfUFRBVV9TRUNUSU9OID0gMTY7XG5leHBvcnQgY29uc3QgWktFWV9GRl9DMF9TRUNUSU9OID0gMTc7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/fflonk_constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/fflonk_export_calldata.js":
/*!************************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_export_calldata.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkExportCallData)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\" + nstr;\n    nstr = `0x${nstr}`;\n    return nstr;\n}\n\nasync function fflonkExportCallData(_pub, _proof) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName)(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i = 0; i < pub.length; i++) {\n        if (inputs !== \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.polynomials.C1[0])}, ${p256(proof.polynomials.C1[1])},` +\n    `${p256(proof.polynomials.C2[0])},${p256(proof.polynomials.C2[1])},` +\n    `${p256(proof.polynomials.W1[0])},${p256(proof.polynomials.W1[1])},` +\n    `${p256(proof.polynomials.W2[0])},${p256(proof.polynomials.W2[1])},` +\n    `${p256(proof.evaluations.ql)},${p256(proof.evaluations.qr)},${p256(proof.evaluations.qm)},` +\n    `${p256(proof.evaluations.qo)},${p256(proof.evaluations.qc)},${p256(proof.evaluations.s1)},` +\n    `${p256(proof.evaluations.s2)},${p256(proof.evaluations.s3)},${p256(proof.evaluations.a)},` +\n    `${p256(proof.evaluations.b)},${p256(proof.evaluations.c)},${p256(proof.evaluations.z)},` +\n    `${p256(proof.evaluations.zw)},${p256(proof.evaluations.t1w)},${p256(proof.evaluations.t2w)},` +\n    `${p256(proof.evaluations.inv)}],` +\n    `[${inputs}]`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9jYWxsZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU2QztBQUNWOztBQUVuQyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7O0FBRUEsd0JBQXdCLDREQUFnQjtBQUN4QztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUEsZUFBZSw4QkFBOEIsSUFBSSw4QkFBOEI7QUFDL0UsT0FBTyw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDdEUsT0FBTyw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDdEUsT0FBTyw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDdEUsT0FBTywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkI7QUFDOUYsT0FBTywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkI7QUFDOUYsT0FBTywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywwQkFBMEI7QUFDN0YsT0FBTywwQkFBMEIsR0FBRywwQkFBMEIsR0FBRywwQkFBMEI7QUFDM0YsT0FBTywyQkFBMkIsR0FBRyw0QkFBNEIsR0FBRyw0QkFBNEI7QUFDaEcsT0FBTyw0QkFBNEI7QUFDbkMsUUFBUSxPQUFPO0FBQ2YiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9jYWxsZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQge2dldEN1cnZlRnJvbU5hbWV9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHt1dGlsc30gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5mdW5jdGlvbiBpMmhleChpKSB7XG4gICAgcmV0dXJuIChcIjBcIiArIGkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG59XG5cbmZ1bmN0aW9uIHAyNTYobikge1xuICAgIGxldCBuc3RyID0gbi50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKG5zdHIubGVuZ3RoIDwgNjQpIG5zdHIgPSBcIjBcIiArIG5zdHI7XG4gICAgbnN0ciA9IGAweCR7bnN0cn1gO1xuICAgIHJldHVybiBuc3RyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmZmxvbmtFeHBvcnRDYWxsRGF0YShfcHViLCBfcHJvb2YpIHtcbiAgICBjb25zdCBwcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpO1xuICAgIGNvbnN0IHB1YiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHViKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tTmFtZShwcm9vZi5jdXJ2ZSk7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IGlucHV0cyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlucHV0cyAhPT0gXCJcIikgaW5wdXRzID0gaW5wdXRzICsgXCIsXCI7XG4gICAgICAgIGlucHV0cyA9IGlucHV0cyArIHAyNTYocHViW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYFske3AyNTYocHJvb2YucG9seW5vbWlhbHMuQzFbMF0pfSwgJHtwMjU2KHByb29mLnBvbHlub21pYWxzLkMxWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5DMlswXSl9LCR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5DMlsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YucG9seW5vbWlhbHMuVzFbMF0pfSwke3AyNTYocHJvb2YucG9seW5vbWlhbHMuVzFbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLnBvbHlub21pYWxzLlcyWzBdKX0sJHtwMjU2KHByb29mLnBvbHlub21pYWxzLlcyWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5xbCl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5xcil9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5xbSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMucW8pfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMucWMpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuczEpfSxgICtcbiAgICBgJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnMyKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnMzKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLmEpfSxgICtcbiAgICBgJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLmIpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuYyl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy56KX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy56dyl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy50MXcpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMudDJ3KX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5pbnYpfV0sYCArXG4gICAgYFske2lucHV0c31dYDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/fflonk_export_calldata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/fflonk_export_solidity_verifier.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_export_solidity_verifier.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkExportSolidityVerifier)\n/* harmony export */ });\n/* harmony import */ var ejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ejs */ \"(rsc)/./node_modules/ejs/lib/ejs.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nconst {unstringifyBigInts, stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function fflonkExportSolidityVerifier(vk, templates, logger) {\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER STARTED\");\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_1__.getCurveFromName)(vk.curve);\n\n    // Precompute w3_2, w4_2 and w4_3\n    let w3 = fromVkey(vk.w3);\n    vk.w3_2 = toVkey(curve.Fr.square(w3));\n\n    let w4 = fromVkey(vk.w4);\n    vk.w4_2 = toVkey(curve.Fr.square(w4));\n    vk.w4_3 = toVkey(curve.Fr.mul(curve.Fr.square(w4), w4));\n\n    let w8 = fromVkey(vk.w8);\n    let acc = curve.Fr.one;\n\n    for (let i = 1; i < 8; i++) {\n        acc = curve.Fr.mul(acc, w8);\n        vk[\"w8_\" + i] = toVkey(acc);\n    }\n\n    let template = templates[vk.protocol];\n\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER FINISHED\");\n\n    return ejs__WEBPACK_IMPORTED_MODULE_0__.render(template, vk);\n\n    function fromVkey(str) {\n        const val = unstringifyBigInts(str);\n        return curve.Fr.fromObject(val);\n    }\n\n    function toVkey(val) {\n        const str = curve.Fr.toObject(val);\n        return stringifyBigInts(str);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9zb2xpZGl0eV92ZXJpZmllci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0I7QUFDdUI7QUFDVjs7QUFFbkMsT0FBTyxzQ0FBc0MsRUFBRSwrQ0FBSzs7QUFFckM7QUFDZjs7QUFFQSx3QkFBd0IsNERBQWdCOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsdUNBQVU7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9zb2xpZGl0eV92ZXJpZmllci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgZWpzIGZyb20gXCJlanNcIjtcbmltcG9ydCB7Z2V0Q3VydmVGcm9tTmFtZX0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmNvbnN0IHt1bnN0cmluZ2lmeUJpZ0ludHMsIHN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZmbG9ua0V4cG9ydFNvbGlkaXR5VmVyaWZpZXIodmssIHRlbXBsYXRlcywgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgRVhQT1JUIFNPTElESVRZIFZFUklGSUVSIFNUQVJURURcIik7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbU5hbWUodmsuY3VydmUpO1xuXG4gICAgLy8gUHJlY29tcHV0ZSB3M18yLCB3NF8yIGFuZCB3NF8zXG4gICAgbGV0IHczID0gZnJvbVZrZXkodmsudzMpO1xuICAgIHZrLnczXzIgPSB0b1ZrZXkoY3VydmUuRnIuc3F1YXJlKHczKSk7XG5cbiAgICBsZXQgdzQgPSBmcm9tVmtleSh2ay53NCk7XG4gICAgdmsudzRfMiA9IHRvVmtleShjdXJ2ZS5Gci5zcXVhcmUodzQpKTtcbiAgICB2ay53NF8zID0gdG9Wa2V5KGN1cnZlLkZyLm11bChjdXJ2ZS5Gci5zcXVhcmUodzQpLCB3NCkpO1xuXG4gICAgbGV0IHc4ID0gZnJvbVZrZXkodmsudzgpO1xuICAgIGxldCBhY2MgPSBjdXJ2ZS5Gci5vbmU7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICBhY2MgPSBjdXJ2ZS5Gci5tdWwoYWNjLCB3OCk7XG4gICAgICAgIHZrW1widzhfXCIgKyBpXSA9IHRvVmtleShhY2MpO1xuICAgIH1cblxuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1t2ay5wcm90b2NvbF07XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBFWFBPUlQgU09MSURJVFkgVkVSSUZJRVIgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4gZWpzLnJlbmRlcih0ZW1wbGF0ZSwgdmspO1xuXG4gICAgZnVuY3Rpb24gZnJvbVZrZXkoc3RyKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHVuc3RyaW5naWZ5QmlnSW50cyhzdHIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRnIuZnJvbU9iamVjdCh2YWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvVmtleSh2YWwpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gY3VydmUuRnIudG9PYmplY3QodmFsKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUJpZ0ludHMoc3RyKTtcbiAgICB9XG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/fflonk_full_prove.js":
/*!*******************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_full_prove.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkFullProve)\n/* harmony export */ });\n/* harmony import */ var _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fflonk_prove.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function fflonkFullProve(_input, wasmFilename, zkeyFilename, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {type: \"mem\"};\n\n    // Compute the witness\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFilename, wtns, wtnsCalcOptions);\n\n    // Compute the proof\n    return await (0,_fflonk_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFilename, wtns, logger, proverOptions);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2Z1bGxfcHJvdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRTRDO0FBQ0s7QUFDZDtBQUNuQyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOztBQUVuQjtBQUNmOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQSxVQUFVLDhEQUFjOztBQUV4QjtBQUNBLGlCQUFpQiw0REFBVztBQUM1QiIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfZnVsbF9wcm92ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IGZmbG9ua1Byb3ZlIGZyb20gXCIuL2ZmbG9ua19wcm92ZS5qc1wiO1xuaW1wb3J0IHd0bnNfY2FsY3VsYXRlIGZyb20gXCIuL3d0bnNfY2FsY3VsYXRlLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmZmxvbmtGdWxsUHJvdmUoX2lucHV0LCB3YXNtRmlsZW5hbWUsIHprZXlGaWxlbmFtZSwgbG9nZ2VyLCB3dG5zQ2FsY09wdGlvbnMsIHByb3Zlck9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyhfaW5wdXQpO1xuXG4gICAgY29uc3Qgd3Rucz0ge3R5cGU6IFwibWVtXCJ9O1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgd2l0bmVzc1xuICAgIGF3YWl0IHd0bnNfY2FsY3VsYXRlKGlucHV0LCB3YXNtRmlsZW5hbWUsIHd0bnMsIHd0bnNDYWxjT3B0aW9ucyk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBwcm9vZlxuICAgIHJldHVybiBhd2FpdCBmZmxvbmtQcm92ZSh6a2V5RmlsZW5hbWUsIHd0bnMsIGxvZ2dlciwgcHJvdmVyT3B0aW9ucyk7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/fflonk_full_prove.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/fflonk_prove.js":
/*!**************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_prove.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkProve)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk_constants.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(rsc)/./node_modules/snarkjs/src/Keccak256Transcript.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./proof.js */ \"(rsc)/./node_modules/snarkjs/src/proof.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(rsc)/./node_modules/snarkjs/src/polynomial/polynomial.js\");\n/* harmony import */ var _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./polynomial/evaluations.js */ \"(rsc)/./node_modules/snarkjs/src/polynomial/evaluations.js\");\n/* harmony import */ var _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./polynomial/cpolynomial.js */ \"(rsc)/./node_modules/snarkjs/src/polynomial/cpolynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst { stringifyBigInts } = ffjavascript__WEBPACK_IMPORTED_MODULE_3__.utils;\n\n\nasync function fflonkProve(zkeyFileName, witnessFileName, logger, options) {\n    if (logger) logger.info(\"FFLONK PROVER STARTED\");\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1 << 25, 1 << 23);\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, wtnsSections);\n\n    //Read zkey file\n    if (logger) logger.info(\"> Reading zkey file\");\n    const {\n        fd: fdZKey,\n        sections: zkeySections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1 << 25, 1 << 23);\n\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, zkeySections, undefined, options);\n\n    if (zkey.protocolId !== _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        throw new Error(\"zkey file is not fflonk\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.eq(zkey.r, wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness !== zkey.nVars - zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sDomain = zkey.domainSize * sFr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK PROVE SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${zkey.power}`);\n        logger.info(`  Domain size:   ${zkey.domainSize}`);\n        logger.info(`  Vars:          ${zkey.nVars}`);\n        logger.info(`  Public vars:   ${zkey.nPublic}`);\n        logger.info(`  Constraints:   ${zkey.nConstraints}`);\n        logger.info(`  Additions:     ${zkey.nAdditions}`);\n        logger.info(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.info(\"> Reading witness file data\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(zkey.nAdditions * sFr);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    // To divide prime fields the Extended Euclidean Algorithm for computing modular inverses is needed.\n    // NOTE: This is the equivalent of compute 1/denominator and then multiply it by the numerator.\n    // The Extended Euclidean Algorithm is expensive in terms of computation.\n    // For the special case where we need to do many modular inverses, there's a simple mathematical trick\n    // that allows us to compute many inverses, called Montgomery batch inversion.\n    // More info: https://vitalik.ca/general/2018/07/21/starks_part_3.html\n    // Montgomery batch inversion reduces the n inverse computations to a single one\n    // To save this (single) inverse computation on-chain, will compute it in proving time and send it to the verifier.\n    // The verifier will have to check:\n    // 1) the denominator is correct multiplying by himself non-inverted -> a * 1/a == 1\n    // 2) compute the rest of the denominators using the Montgomery batch inversion\n    // The inversions are:\n    //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n    //    denominator needed in step 10 and 11 of the verifier\n    //    denominator needed in the verifier when computing L_i^{S1}(X) and L_i^{S2}(X)\n    //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n    let toInverse = {};\n\n    let challenges = {};\n    let roots = {};\n\n    let proof = new _proof_js__WEBPACK_IMPORTED_MODULE_7__.Proof(curve, logger);\n\n    if (logger) logger.info(`> Reading Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.info(`> Reading Sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.info(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION][0].p);\n\n    if (logger) logger.info(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION][0].p + sDomain);\n\n    if (logger) logger.info(`> Reading Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n    const PTau = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(zkey.domainSize * 16 * sG1);\n    // domainSize * 9 + 18 = SRS length in the zkey saved in setup process.\n    // it corresponds to the maximum SRS length needed, specifically to commit C2\n    // notice that the reserved buffers size is zkey.domainSize * 16 * sG1 because a power of two buffer size is needed\n    // the remaining buffer not filled from SRS are set to 0\n    await fdZKey.readToBuffer(PTau, 0, (zkey.domainSize * 9 + 18) * sG1, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_PTAU_SECTION][0].p);\n\n    // START FFLONK PROVER PROTOCOL\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 1. Compute C1(X) polynomial\n    if (logger) logger.info(\"\");\n    if (logger) logger.info(\"> ROUND 1\");\n    await round1();\n\n    delete polynomials.T0;\n    delete evaluations.QL;\n    delete evaluations.QR;\n    delete evaluations.QM;\n    delete evaluations.QO;\n    delete evaluations.QC;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 2. Compute C2(X) polynomial\n    if (logger) logger.info(\"> ROUND 2\");\n    await round2();\n\n    delete buffers.A;\n    delete buffers.B;\n    delete buffers.C;\n    delete evaluations.A;\n    delete evaluations.B;\n    delete evaluations.C;\n    delete evaluations.Sigma1;\n    delete evaluations.Sigma2;\n    delete evaluations.Sigma3;\n    delete evaluations.lagrange1;\n    delete evaluations.Z;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 3. Compute opening evaluations\n    if (logger) logger.info(\"> ROUND 3\");\n    await round3();\n\n    delete polynomials.A;\n    delete polynomials.B;\n    delete polynomials.C;\n    delete polynomials.Z;\n    delete polynomials.T1;\n    delete polynomials.T2;\n    delete polynomials.Sigma1;\n    delete polynomials.Sigma2;\n    delete polynomials.Sigma3;\n    delete polynomials.QL;\n    delete polynomials.QR;\n    delete polynomials.QM;\n    delete polynomials.QC;\n    delete polynomials.QO;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 4. Compute W(X) polynomial\n    if (logger) logger.info(\"> ROUND 4\");\n    await round4();\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 5. Compute W'(X) polynomial\n    if (logger) logger.info(\"> ROUND 5\");\n    await round5();\n\n    delete polynomials.C0;\n    delete polynomials.C1;\n    delete polynomials.C2;\n    delete polynomials.R1;\n    delete polynomials.R2;\n    delete polynomials.F;\n    delete polynomials.L;\n    delete polynomials.ZT;\n    delete polynomials.ZTS2;\n    await fdZKey.close();\n    if (globalThis.gc) globalThis.gc();\n\n    proof.addEvaluation(\"inv\", getMontgomeryBatchedInverse());\n\n    // Prepare proof\n    let _proof = proof.toObjectProof();\n    _proof.protocol = \"fflonk\";\n    _proof.curve = curve.name;\n\n    // Prepare public inputs\n    let publicSignals = [];\n\n    for (let i = 1; i <= zkey.nPublic; i++) {\n        const i_sFr = i * sFr;\n\n        const pub = buffWitness.slice(i_sFr, i_sFr + sFr);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.info(\"FFLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.info(\" Computing additions\");\n        const additionsBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + sFr * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + sFr);\n            offset += sFr;\n            const factor2 = additionsBuff.slice(offset, offset + sFr);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, sFr * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o + 4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        let diff = zkey.nVars - zkey.nAdditions;\n        if (idx < diff) {\n            return buffWitness.slice(idx * sFr, idx * sFr + sFr);\n        } else if (idx < zkey.nVars) {\n            const offset = (idx - diff) * sFr;\n            return buffInternalWitness.slice(offset, offset + sFr);\n        }\n\n        return Fr.zero;\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b_1, ..., b9)  F\n        challenges.b = [];\n        for (let i = 1; i <= 9; i++) {\n            challenges.b[i] = Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.info(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute the quotient polynomial T0(X)\n        if (logger) logger.info(\"> Computing T0 polynomial\");\n        await computeT0();\n\n        // STEP 1.4 - Compute the FFT-style combination polynomial C1(X)\n        if (logger) logger.info(\"> Computing C1 polynomial\");\n        await computeC1();\n\n        // The first output of the prover is ([C1]_1)\n        if (logger) logger.info(\"> Computing C1 multi exponentiation\");\n        let commitC1 = await polynomials.C1.multiExponentiation(PTau, \"C1\");\n        proof.addPolynomial(\"C1\", commitC1);\n\n        return 0;\n\n        async function computeWirePolynomials() {\n            if (logger) logger.info(\" Reading data from zkey file\");\n            // Build A, B and C evaluations buffer from zkey and witness files\n            buffers.A = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            buffers.B = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            buffers.C = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n            // Read zkey sections and fill the buffers\n            const aMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_A_MAP_SECTION);\n            const bMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_B_MAP_SECTION);\n            const cMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_C_MAP_SECTION);\n\n            // Compute all witness from signal ids and set them to A,B & C buffers\n            for (let i = 0; i < zkey.nConstraints; i++) {\n                const i_sFr = i * sFr;\n                const offset = i * 4;\n\n                // Compute A value from a signal id\n                const signalIdA = readUInt32(aMapBuff, offset);\n                buffers.A.set(getWitness(signalIdA), i_sFr);\n\n                // Compute B value from a signal id\n                const signalIdB = readUInt32(bMapBuff, offset);\n                buffers.B.set(getWitness(signalIdB), i_sFr);\n\n                // Compute C value from a signal id\n                const signalIdC = readUInt32(cMapBuff, offset);\n                buffers.C.set(getWitness(signalIdC), i_sFr);\n            }\n\n            // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n            buffers.A.set(challenges.b[1], sDomain - 64);\n            buffers.A.set(challenges.b[2], sDomain - 32);\n            buffers.B.set(challenges.b[3], sDomain - 64);\n            buffers.B.set(challenges.b[4], sDomain - 32);\n            buffers.C.set(challenges.b[5], sDomain - 64);\n            buffers.C.set(challenges.b[6], sDomain - 32);\n\n            buffers.A = await Fr.batchToMontgomery(buffers.A);\n            buffers.B = await Fr.batchToMontgomery(buffers.B);\n            buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n            // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n            if (logger) logger.info(\" Computing A ifft\");\n            polynomials.A = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.A, curve, logger);\n            if (logger) logger.info(\" Computing B ifft\");\n            polynomials.B = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.B, curve, logger);\n            if (logger) logger.info(\" Computing C ifft\");\n            polynomials.C = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n            // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n            if (logger) logger.info(\" Computing A fft\");\n            evaluations.A = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n            if (logger) logger.info(\" Computing B fft\");\n            evaluations.B = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n            if (logger) logger.info(\" Computing C fft\");\n            evaluations.C = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n            // Check degrees\n            if (polynomials.A.degree() >= zkey.domainSize) {\n                throw new Error(\"A Polynomial is not well calculated\");\n            }\n            if (polynomials.B.degree() >= zkey.domainSize) {\n                throw new Error(\"B Polynomial is not well calculated\");\n            }\n            if (polynomials.C.degree() >= zkey.domainSize) {\n                throw new Error(\"C Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeT0() {\n            if (logger) logger.info(` Reading sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION}` +\n                `, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION}. Q selectors`);\n            // Reserve memory for Q's evaluations\n            evaluations.QL = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QR = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QM = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QO = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QC = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n            // Read Q's evaluations from zkey file\n            await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION][0].p + sDomain);\n\n            // Read Lagrange polynomials & evaluations from zkey file\n            const lagrangePolynomials = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_LAGRANGE_SECTION);\n            evaluations.lagrange1 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(lagrangePolynomials, curve, logger);\n\n            // Reserve memory for buffers T0\n            buffers.T0 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n\n            if (logger) logger.info(\" Computing T0 evaluations\");\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`      T0 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                // Get related evaluations to compute current T0 evaluation\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n\n                const ql = evaluations.QL.getEvaluation(i);\n                const qr = evaluations.QR.getEvaluation(i);\n                const qm = evaluations.QM.getEvaluation(i);\n                const qo = evaluations.QO.getEvaluation(i);\n                const qc = evaluations.QC.getEvaluation(i);\n\n                // Compute current public input\n                let pi = Fr.zero;\n                for (let j = 0; j < zkey.nPublic; j++) {\n                    const offset = (j * 5 * zkey.domainSize) + zkey.domainSize + i;\n\n                    const lPol = evaluations.lagrange1.getEvaluation(offset);\n                    const aVal = buffers.A.slice(j * sFr, (j + 1) * sFr);\n\n                    pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n                }\n\n                //T0(X) = [q_L(X)a(X) + q_R(X)b(X) + q_M(X)a(X)b(X) + q_O(X)c(X) + q_C(X) + PI(X)]  1/Z_H(X)\n                // Compute first T0(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                // expression 1 -> q_L(X)a(X)\n                const e1 = Fr.mul(a, ql);\n\n                // expression 2 -> q_R(X)b(X)\n                const e2 = Fr.mul(b, qr);\n\n                // expression 3 -> q_M(X)a(X)b(X)\n                const e3 = Fr.mul(Fr.mul(a, b), qm);\n\n                // expression 4 -> q_O(X)c(X)\n                const e4 = Fr.mul(c, qo);\n\n                // t0 = expressions 1 + expression 2 + expression 3 + expression 4 + qc + pi\n                const t0 = Fr.add(e1, Fr.add(e2, Fr.add(e3, Fr.add(e4, Fr.add(qc, pi)))));\n\n                buffers.T0.set(t0, i * sFr);\n            }\n\n            if (logger) logger.info(\"buffer T0: \" + buffers.T0.byteLength / sFr);\n\n            // Compute the coefficients of the polynomial T0(X) from buffers.T0\n            if (logger) logger.info(\" Computing T0 ifft\");\n            polynomials.T0 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T0, curve, logger);\n\n            if (logger) logger.info(\"T0 length: \" + polynomials.T0.length());\n            if (logger) logger.info(\"T0 degree: \" + polynomials.T0.degree());\n\n            // Divide the polynomial T0 by Z_H(X)\n            if (logger) logger.info(\" Computing T0 / ZH\");\n            polynomials.T0.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Check degree\n            if (polynomials.T0.degree() >= 2 * zkey.domainSize - 2) {\n                throw new Error(`T0 Polynomial is not well calculated (degree is ${polynomials.T0.degree()} and must be less than ${2 * zkey.domainSize + 2}`);\n            }\n\n            delete buffers.T0;\n        }\n\n        async function computeC1() {\n            let C1 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__.CPolynomial(4, curve, logger);\n            C1.addPolynomial(0, polynomials.A);\n            C1.addPolynomial(1, polynomials.B);\n            C1.addPolynomial(2, polynomials.C);\n            C1.addPolynomial(3, polynomials.T0);\n\n            polynomials.C1 = C1.getPolynomial();\n\n            // Check degree\n            if (polynomials.C1.degree() >= 8 * zkey.domainSize - 8) {\n                throw new Error(\"C1 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.info(\"> Computing challenges beta and gamma\");\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n\n        // Add C0 to the transcript\n        transcript.addPolCommitment(zkey.C0);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * sFr, i * sFr + sFr));\n        }\n\n        // Add C1 to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"C1\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.beta: \" + Fr.toString(challenges.beta));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n\n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.info(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute quotient polynomial T1(X) and T2(X)\n        if (logger) logger.info(\"> Computing T1 polynomial\");\n        await computeT1();\n        if (logger) logger.info(\"> Computing T2 polynomial\");\n        await computeT2();\n\n        // STEP 2.4 - Compute the FFT-style combination polynomial C2(X)\n        if (logger) logger.info(\"> Computing C2 polynomial\");\n        await computeC2();\n\n        // The second output of the prover is ([C2]_1)\n        if (logger) logger.info(\"> Computing C2 multi exponentiation\");\n        let commitC2 = await polynomials.C2.multiExponentiation(PTau, \"C2\");\n        proof.addPolynomial(\"C2\", commitC2);\n\n        return 0;\n\n        async function computeZ() {\n            if (logger) logger.info(\" Computing Z evaluations\");\n\n            let numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n            // Set the first values to 1\n            numArr.set(Fr.one, 0);\n            denArr.set(Fr.one, 0);\n\n            // Set initial omega\n            let w = Fr.one;\n            for (let i = 0; i < zkey.domainSize; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    Z evaluation ${i}/${zkey.domainSize}`);\n                const i_sFr = i * sFr;\n\n                // Z(X) := numArr / denArr\n                // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n                const betaw = Fr.mul(challenges.beta, w);\n\n                let num1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                num1 = Fr.add(num1, betaw);\n                num1 = Fr.add(num1, challenges.gamma);\n\n                let num2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                num2 = Fr.add(num2, Fr.mul(zkey.k1, betaw));\n                num2 = Fr.add(num2, challenges.gamma);\n\n                let num3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                num3 = Fr.add(num3, Fr.mul(zkey.k2, betaw));\n                num3 = Fr.add(num3, challenges.gamma);\n\n                let num = Fr.mul(num1, Fr.mul(num2, num3));\n\n                // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n                let den1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                den1 = Fr.add(den1, Fr.mul(challenges.beta, evaluations.Sigma1.getEvaluation(i * 4)));\n                den1 = Fr.add(den1, challenges.gamma);\n\n                let den2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                den2 = Fr.add(den2, Fr.mul(challenges.beta, evaluations.Sigma2.getEvaluation(i * 4)));\n                den2 = Fr.add(den2, challenges.gamma);\n\n                let den3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                den3 = Fr.add(den3, Fr.mul(challenges.beta, evaluations.Sigma3.getEvaluation(i * 4)));\n                den3 = Fr.add(den3, challenges.gamma);\n\n                let den = Fr.mul(den1, Fr.mul(den2, den3));\n\n                // Multiply current num value with the previous one saved in numArr\n                num = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), num);\n                numArr.set(num, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Multiply current den value with the previous one saved in denArr\n                den = Fr.mul(denArr.slice(i_sFr, i_sFr + sFr), den);\n                denArr.set(den, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Next omega\n                w = Fr.mul(w, Fr.w[zkey.power]);\n            }\n            // Compute the inverse of denArr to compute in the next command the\n            // division numArr/denArr by multiplying num  1/denArr\n            denArr = await Fr.batchInverse(denArr);\n\n            // TODO: Do it in assembly and in parallel\n            // Multiply numArr  denArr where denArr was inverted in the previous command\n            for (let i = 0; i < zkey.domainSize; i++) {\n                const i_sFr = i * sFr;\n\n                const z = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), denArr.slice(i_sFr, i_sFr + sFr));\n                numArr.set(z, i_sFr);\n            }\n            // From now on the values saved on numArr will be Z(X) buffer\n            buffers.Z = numArr;\n\n            if (!Fr.eq(numArr.slice(0, sFr), Fr.one)) {\n                throw new Error(\"Copy constraints does not match\");\n            }\n\n            // Compute polynomial coefficients z(X) from buffers.Z\n            if (logger) logger.info(\" Computing Z ifft\");\n            polynomials.Z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n            // Compute extended evaluations of z(X) polynomial\n            if (logger) logger.info(\" Computing Z fft\");\n            evaluations.Z = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n            // Blind z(X) polynomial coefficients with blinding scalars b\n            polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n            // Check degree\n            if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n                throw new Error(\"Z Polynomial is not well calculated\");\n            }\n\n            delete buffers.Z;\n        }\n\n        async function computeT1() {\n            if (logger) logger.info(\" Computing T1 evaluations\");\n\n            buffers.T1 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 2);\n            buffers.T1z = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 2);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 2; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T1 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n\n                const z = evaluations.Z.getEvaluation(i * 2);\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n\n                // T1(X) := (z(X) - 1)  L_1(X)\n                // Compute first T1(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                const lagrange1 = evaluations.lagrange1.getEvaluation(zkey.domainSize + i * 2);\n                let t1 = Fr.mul(Fr.sub(z, Fr.one), lagrange1);\n                let t1z = Fr.mul(zp, lagrange1);\n\n                buffers.T1.set(t1, i * sFr);\n                buffers.T1z.set(t1z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 1]);\n            }\n\n            // Compute the coefficients of the polynomial T1(X) from buffers.T1\n            if (logger) logger.info(\" Computing T1 ifft\");\n            polynomials.T1 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T1, curve, logger);\n\n            // Divide the polynomial T1 by Z_H(X)\n            polynomials.T1.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T1z(X) from buffers.T1z\n            if (logger) logger.info(\" Computing T1z ifft\");\n            polynomials.T1z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T1z, curve, logger);\n\n            // Add the polynomial T1z to T1 to get the final polynomial T1\n            polynomials.T1.add(polynomials.T1z);\n\n            // Check degree\n            if (polynomials.T1.degree() >= zkey.domainSize + 2) {\n                throw new Error(\"T1 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T1;\n            delete buffers.T1z;\n            delete polynomials.T1z;\n        }\n\n        async function computeT2() {\n            if (logger) logger.info(\" Computing T2 evaluations\");\n\n            buffers.T2 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n            buffers.T2z = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T2 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n                const omegaW = Fr.mul(omega, Fr.w[zkey.power]);\n                const omegaW2 = Fr.square(omegaW);\n\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n                const z = evaluations.Z.getEvaluation(i);\n                const zW = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n                const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omegaW2), Fr.mul(challenges.b[8], omegaW)), challenges.b[9]);\n\n                const sigma1 = evaluations.Sigma1.getEvaluation(i);\n                const sigma2 = evaluations.Sigma2.getEvaluation(i);\n                const sigma3 = evaluations.Sigma3.getEvaluation(i);\n\n                // T2(X) := [ (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                //           -(a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)]  1/Z_H(X)\n                // Compute first T2(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n\n                // expression 1 -> (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                const betaX = Fr.mul(challenges.beta, omega);\n\n                let e11 = Fr.add(a, betaX);\n                e11 = Fr.add(e11, challenges.gamma);\n\n                let e12 = Fr.add(b, Fr.mul(betaX, zkey.k1));\n                e12 = Fr.add(e12, challenges.gamma);\n\n                let e13 = Fr.add(c, Fr.mul(betaX, zkey.k2));\n                e13 = Fr.add(e13, challenges.gamma);\n\n                let e1 = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), z);\n                let e1z = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), zp);\n                // const [e1, e1z] = MulZ.mul4(e11, e12, e13, z, ap, bp, cp, zp, i % 4, Fr);\n\n                // expression 2 -> (a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)\n                let e21 = Fr.add(a, Fr.mul(challenges.beta, sigma1));\n                e21 = Fr.add(e21, challenges.gamma);\n\n                let e22 = Fr.add(b, Fr.mul(challenges.beta, sigma2));\n                e22 = Fr.add(e22, challenges.gamma);\n\n                let e23 = Fr.add(c, Fr.mul(challenges.beta, sigma3));\n                e23 = Fr.add(e23, challenges.gamma);\n\n                let e2 = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zW);\n                let e2z = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zWp);\n                // const [e2, e2z] = MulZ.mul4(e21, e22, e23, zW, ap, bp, cp, zWp, i % 4, Fr);\n\n                let t2 = Fr.sub(e1, e2);\n                let t2z = Fr.sub(e1z, e2z);\n\n                buffers.T2.set(t2, i * sFr);\n                buffers.T2z.set(t2z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 2]);\n            }\n\n            // Compute the coefficients of the polynomial T2(X) from buffers.T2\n            if (logger) logger.info(\" Computing T2 ifft\");\n            polynomials.T2 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T2, curve, logger);\n\n            // Divide the polynomial T2 by Z_H(X)\n            if (logger) logger.info(\" Computing T2 / ZH\");\n            polynomials.T2.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T2z(X) from buffers.T2z\n            if (logger) logger.info(\" Computing T2z ifft\");\n            polynomials.T2z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T2z, curve, logger);\n\n            // Add the polynomial T2z to T2 to get the final polynomial T2\n            polynomials.T2.add(polynomials.T2z);\n\n            // Check degree\n            if (polynomials.T2.degree() >= 3 * zkey.domainSize) {\n                throw new Error(\"T2 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T2;\n            delete buffers.T2z;\n            delete polynomials.T2z;\n        }\n\n        async function computeC2() {\n            let C2 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__.CPolynomial(3, curve, logger);\n            C2.addPolynomial(0, polynomials.Z);\n            C2.addPolynomial(1, polynomials.T1);\n            C2.addPolynomial(2, polynomials.T2);\n\n            polynomials.C2 = C2.getPolynomial();\n\n            // Check degree\n            if (polynomials.C2.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"C2 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round3() {\n        if (logger) logger.info(\"> Computing challenge xi\");\n        // STEP 3.1 - Compute evaluation challenge xi  S\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"C2\"));\n\n        // Obtain a xi_seeder from the transcript\n        // To force h1^4 = xi, h2^3 = xi and h_3^2 = xi\n        // we compute xi = xi_seeder^12, h1 = xi_seeder^3, h2 = xi_seeder^4 and h3 = xi_seeder^6\n        challenges.xiSeed = transcript.getChallenge();\n        const xiSeed2 = Fr.square(challenges.xiSeed);\n\n        // Compute omega8, omega4 and omega3\n        roots.w8 = [];\n        roots.w8[0] = Fr.one;\n        for (let i = 1; i < 8; i++) {\n            roots.w8[i] = Fr.mul(roots.w8[i - 1], zkey.w8);\n        }\n\n        roots.w4 = [];\n        roots.w4[0] = Fr.one;\n        for (let i = 1; i < 4; i++) {\n            roots.w4[i] = Fr.mul(roots.w4[i - 1], zkey.w4);\n        }\n\n        roots.w3 = [];\n        roots.w3[0] = Fr.one;\n        roots.w3[1] = zkey.w3;\n        roots.w3[2] = Fr.square(zkey.w3);\n\n        // Compute h0 = xiSeeder^3\n        roots.S0 = {};\n        roots.S0.h0w8 = [];\n        roots.S0.h0w8[0] = Fr.mul(xiSeed2, challenges.xiSeed);\n        for (let i = 1; i < 8; i++) {\n            roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], roots.w8[i]);\n        }\n\n        // Compute h1 = xi_seeder^6\n        roots.S1 = {};\n        roots.S1.h1w4 = [];\n        roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n        for (let i = 1; i < 4; i++) {\n            roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], roots.w4[i]);\n        }\n\n        // Compute h2 = xi_seeder^8\n        roots.S2 = {};\n        roots.S2.h2w3 = [];\n        roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n        roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], roots.w3[1]);\n        roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], roots.w3[2]);\n\n        roots.S2.h3w3 = [];\n        // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n        // So, h3 = xi_seeder^8 ^{1/3}\n        roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], zkey.wr);\n        roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], roots.w3[1]);\n        roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], roots.w3[2]);\n\n        // Compute xi = xi_seeder^24\n        challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n\n        if (logger) logger.info(\" challenges.xi: \" + Fr.toString(challenges.xi));\n\n        // Reserve memory for Q's polynomials\n        polynomials.QL = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION][0].p);\n\n        // STEP 3.2 - Compute opening evaluations and add them to the proof (third output of the prover)\n        if (logger) logger.info(\" Computing evaluations\");\n        proof.addEvaluation(\"ql\", polynomials.QL.evaluate(challenges.xi));\n        proof.addEvaluation(\"qr\", polynomials.QR.evaluate(challenges.xi));\n        proof.addEvaluation(\"qm\", polynomials.QM.evaluate(challenges.xi));\n        proof.addEvaluation(\"qo\", polynomials.QO.evaluate(challenges.xi));\n        proof.addEvaluation(\"qc\", polynomials.QC.evaluate(challenges.xi));\n        proof.addEvaluation(\"s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"s3\", polynomials.Sigma3.evaluate(challenges.xi));\n        proof.addEvaluation(\"a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"z\", polynomials.Z.evaluate(challenges.xi));\n\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        proof.addEvaluation(\"zw\", polynomials.Z.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t1w\", polynomials.T1.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t2w\", polynomials.T2.evaluate(challenges.xiw));\n    }\n\n    async function round4() {\n        if (logger) logger.info(\"> Computing challenge alpha\");\n        // STEP 4.1 - Compute challenge alpha  F\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.xiSeed);\n        transcript.addScalar(proof.getEvaluation(\"ql\"));\n        transcript.addScalar(proof.getEvaluation(\"qr\"));\n        transcript.addScalar(proof.getEvaluation(\"qm\"));\n        transcript.addScalar(proof.getEvaluation(\"qo\"));\n        transcript.addScalar(proof.getEvaluation(\"qc\"));\n        transcript.addScalar(proof.getEvaluation(\"s1\"));\n        transcript.addScalar(proof.getEvaluation(\"s2\"));\n        transcript.addScalar(proof.getEvaluation(\"s3\"));\n        transcript.addScalar(proof.getEvaluation(\"a\"));\n        transcript.addScalar(proof.getEvaluation(\"b\"));\n        transcript.addScalar(proof.getEvaluation(\"c\"));\n        transcript.addScalar(proof.getEvaluation(\"z\"));\n        transcript.addScalar(proof.getEvaluation(\"zw\"));\n        transcript.addScalar(proof.getEvaluation(\"t1w\"));\n        transcript.addScalar(proof.getEvaluation(\"t2w\"));\n        challenges.alpha = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n\n        // STEP 4.2 - Compute F(X)\n        if (logger) logger.info(\"> Reading C0 polynomial\");\n        polynomials.C0 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 8), curve, logger);\n        await fdZKey.readToBuffer(polynomials.C0.coef, 0, sDomain * 8, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_C0_SECTION][0].p);\n\n        if (logger) logger.info(\"> Computing R0 polynomial\");\n        computeR0();\n        if (logger) logger.info(\"> Computing R1 polynomial\");\n        computeR1();\n        if (logger) logger.info(\"> Computing R2 polynomial\");\n        computeR2();\n\n        if (logger) logger.info(\"> Computing F polynomial\");\n        await computeF();\n\n        // The fourth output of the prover is ([W1]_1), where W1:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W1 multi exponentiation\");\n        let commitW1 = await polynomials.F.multiExponentiation(PTau, \"W1\");\n        proof.addPolynomial(\"W1\", commitW1);\n\n        return 0;\n\n        function computeR0() {\n            // COMPUTE R0\n            // Compute the coefficients of R0(X) from 8 evaluations using lagrange interpolation. R0(X)  F_{<8}[X]\n            // We decide to use Lagrange interpolations because the R0 degree is very small (deg(R0)===7),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R0 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7]],\n                [polynomials.C0.evaluate(roots.S0.h0w8[0]), polynomials.C0.evaluate(roots.S0.h0w8[1]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[2]), polynomials.C0.evaluate(roots.S0.h0w8[3]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[4]), polynomials.C0.evaluate(roots.S0.h0w8[5]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[6]), polynomials.C0.evaluate(roots.S0.h0w8[7])], curve);\n\n            // Check the degree of r0(X) < 8\n            if (polynomials.R0.degree() > 7) {\n                throw new Error(\"R0 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR1() {\n            // COMPUTE R1\n            // Compute the coefficients of R1(X) from 4 evaluations using lagrange interpolation. R1(X)  F_{<4}[X]\n            // We decide to use Lagrange interpolations because the R1 degree is very small (deg(R1)===3),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R1 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3]],\n                [polynomials.C1.evaluate(roots.S1.h1w4[0]), polynomials.C1.evaluate(roots.S1.h1w4[1]),\n                    polynomials.C1.evaluate(roots.S1.h1w4[2]), polynomials.C1.evaluate(roots.S1.h1w4[3])], curve);\n\n            // Check the degree of r1(X) < 4\n            if (polynomials.R1.degree() > 3) {\n                throw new Error(\"R1 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR2() {\n            // COMPUTE R2\n            // Compute the coefficients of r2(X) from 6 evaluations using lagrange interpolation. r2(X)  F_{<6}[X]\n            // We decide to use Lagrange interpolations because the R2.degree is very small (deg(R2)===5),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]],\n                [polynomials.C2.evaluate(roots.S2.h2w3[0]), polynomials.C2.evaluate(roots.S2.h2w3[1]),\n                    polynomials.C2.evaluate(roots.S2.h2w3[2]), polynomials.C2.evaluate(roots.S2.h3w3[0]),\n                    polynomials.C2.evaluate(roots.S2.h3w3[1]), polynomials.C2.evaluate(roots.S2.h3w3[2])], curve);\n\n            // Check the degree of r2(X) < 6\n            if (polynomials.R2.degree() > 5) {\n                throw new Error(\"R2 Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeF() {\n            if (logger) logger.info(\" Computing F polynomial\");\n\n            // COMPUTE F(X)\n            polynomials.F = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.F.sub(polynomials.R0);\n            polynomials.F.divByZerofier(8, challenges.xi);\n\n            let f2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            f2.sub(polynomials.R1);\n            f2.mulScalar(challenges.alpha);\n            f2.divByZerofier(4, challenges.xi);\n\n            let f3 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            f3.sub(polynomials.R2);\n            f3.mulScalar(Fr.square(challenges.alpha));\n            f3.divByZerofier(3, challenges.xi);\n            f3.divByZerofier(3, challenges.xiw);\n\n            polynomials.F.add(f2);\n            polynomials.F.add(f3);\n\n            if (polynomials.F.degree() >= 9 * zkey.domainSize - 6) {\n                throw new Error(\"F Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round5() {\n        if (logger) logger.info(\"> Computing challenge y\");\n\n        // STEP 5.1 - Compute random evaluation point y  F\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"W1\"));\n\n        challenges.y = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.y: \" + Fr.toString(challenges.y));\n\n        // STEP 5.2 - Compute L(X)\n        if (logger) logger.info(\"> Computing L polynomial\");\n        await computeL();\n\n        if (logger) logger.info(\"> Computing ZTS2 polynomial\");\n        await computeZTS2();\n\n        let ZTS2Y = polynomials.ZTS2.evaluate(challenges.y);\n        ZTS2Y = Fr.inv(ZTS2Y);\n        polynomials.L.mulScalar(ZTS2Y);\n\n        const polDividend = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromCoefficientsArray([Fr.neg(challenges.y), Fr.one], curve);\n        if (logger) logger.info(\"> Computing W' = L / ZTS2 polynomial\");\n        const polRemainder = polynomials.L.divBy(polDividend);\n\n        //Check polReminder degree is equal to zero\n        if (polRemainder.degree() > 0) {\n            throw new Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${polRemainder.degree()} and should be 0`);\n        }\n\n        if (polynomials.L.degree() >= 9 * zkey.domainSize - 1) {\n            throw new Error(\"Degree of L(X)/(ZTS2(y)(X-y)) is not correct\");\n        }\n\n        // The fifth output of the prover is ([W2]_1), where W2:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W' multi exponentiation\");\n        let commitW2 = await polynomials.L.multiExponentiation(PTau, \"W2\");\n        proof.addPolynomial(\"W2\", commitW2);\n\n        return 0;\n\n        async function computeL() {\n            if (logger) logger.info(\" Computing L polynomial\");\n\n            const evalR0Y = polynomials.R0.evaluate(challenges.y);\n            const evalR1Y = polynomials.R1.evaluate(challenges.y);\n            const evalR2Y = polynomials.R2.evaluate(challenges.y);\n\n            let mulL0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n            for (let i = 1; i < 8; i++) {\n                mulL0 = Fr.mul(mulL0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n            }\n\n            let mulL1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n            for (let i = 1; i < 4; i++) {\n                mulL1 = Fr.mul(mulL1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n            }\n\n            let mulL2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n            for (let i = 1; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n            }\n            for (let i = 0; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n            }\n\n            let preL0 = Fr.mul(mulL1, mulL2);\n            let preL1 = Fr.mul(challenges.alpha, Fr.mul(mulL0, mulL2));\n            let preL2 = Fr.mul(Fr.square(challenges.alpha), Fr.mul(mulL0, mulL1));\n\n            toInverse[\"denH1\"] = mulL1;\n            toInverse[\"denH2\"] = mulL2;\n\n            // COMPUTE L(X)\n            polynomials.L = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.L.subScalar(evalR0Y);\n            polynomials.L.mulScalar(preL0);\n\n            let l2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            l2.subScalar(evalR1Y);\n            l2.mulScalar(preL1);\n\n            let l3 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            l3.subScalar(evalR2Y);\n            l3.mulScalar(preL2);\n\n            polynomials.L.add(l2);\n            polynomials.L.add(l3);\n\n            if (logger) logger.info(\"> Computing ZT polynomial\");\n            await computeZT();\n\n            const evalZTY = polynomials.ZT.evaluate(challenges.y);\n            polynomials.F.mulScalar(evalZTY);\n            polynomials.L.sub(polynomials.F);\n\n            // Check degree\n            if (polynomials.L.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"L Polynomial is not well calculated\");\n            }\n\n            delete buffers.L;\n        }\n\n        async function computeZT() {\n            polynomials.ZT = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.zerofierPolynomial(\n                [\n                    roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7],\n                    roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n\n        async function computeZTS2() {\n            polynomials.ZTS2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.zerofierPolynomial(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n    }\n\n    function getMontgomeryBatchedInverse() {\n        //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n        let xiN = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            xiN = Fr.square(xiN);\n        }\n        toInverse[\"zh\"] = Fr.sub(xiN, Fr.one);\n\n        //    denominator needed in step 10 and 11 of the verifier\n        //     toInverse.denH1 & toInverse.denH2  -> Computed in round5, computeL()\n\n        //    denominator needed in the verifier when computing L_i^{S0}(X), L_i^{S1}(X) and L_i^{S2}(X)\n        computeLiS0(toInverse, roots.S0.h0w8, challenges.y, curve);\n\n        computeLiS1(toInverse, roots.S1.h1w4, challenges.y, curve);\n\n        computeLiS2(toInverse, roots.S2.h2w3, roots.S2.h3w3, challenges.y, challenges.xi, challenges.xiw, curve);\n\n        //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n        const size = Math.max(1, zkey.nPublic);\n\n        let w = Fr.one;\n        for (let i = 0; i < size; i++) {\n            toInverse[\"Li_\" + (i + 1)] = Fr.mul(Fr.e(zkey.domainSize), Fr.sub(challenges.xi, w));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        let mulAccumulator = Fr.one;\n        for (const element of Object.values(toInverse)) {\n            if(Array.isArray(element)) {\n                for (const subElement of element) {\n                    mulAccumulator = Fr.mul(mulAccumulator, subElement);\n                }\n            } else {\n                mulAccumulator = Fr.mul(mulAccumulator, element);\n            }\n        }\n        return Fr.inv(mulAccumulator);\n\n        \n        function computeLiS0(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS0_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n            }\n        \n            return Li;\n        }\n\n        function computeLiS1(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS1_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n\n            }\n        \n            return Li;\n        }\n\n        function computeLiS2(toInverse, S2, S2p, value, xi, xiw, curve) {\n            const Fr = curve.Fr;\n        \n            const Li = [];\n        \n            const _3h2 = Fr.mul(Fr.e(3), S2[0]);\n            const xisubxiw = Fr.sub(xi, xiw);\n            let den1 = Fr.mul(_3h2, xisubxiw);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2[2 * i % 3];\n                const den3 = Fr.sub(value, S2[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1)]] = Fr.mul(den1,Fr.mul(den2, den3));\n                \n            }\n        \n            const _3h3 = Fr.mul(Fr.e(3), S2p[0]);\n            const xiwsubxi = Fr.sub(xiw, xi);\n            den1 = Fr.mul(_3h3, xiwsubxi);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2p[2 * i % 3];\n                const den3 = Fr.sub(value, S2p[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1 + 3)]] = Fr.mul(den1,Fr.mul(den2, den3));    \n            }\n        \n            return Li;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3Byb3ZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ1A7QUFDQTtBQUNXO0FBQ0M7QUFpQjFCO0FBQ2dDO0FBQzVCO0FBQ3FCO0FBQ0U7QUFDQTs7QUFFMUQsUUFBUSxtQkFBbUIsRUFBRSwrQ0FBSzs7O0FBR25CO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSw0REFBd0I7QUFDdEMsdUJBQXVCLHNEQUFvQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSw0REFBd0I7O0FBRXRDLHVCQUF1QixzREFBb0I7O0FBRTNDLDRCQUE0QixrRUFBa0I7QUFDOUM7QUFDQTs7QUFFQSxTQUFTLGdEQUFNO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxXQUFXLGFBQWEsY0FBYyxJQUFJLGdCQUFnQjtBQUN0SDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQsd0NBQXdDLFdBQVc7QUFDbkQsd0NBQXdDLGdCQUFnQjtBQUN4RCx3Q0FBd0MsV0FBVztBQUNuRCx3Q0FBd0MsYUFBYTtBQUNyRCx3Q0FBd0Msa0JBQWtCO0FBQzFELHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLDREQUF3QjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQVM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEdBQUcsYUFBYSxHQUFHO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsNENBQUs7O0FBRXpCLGlEQUFpRCwyRUFBeUIsQ0FBQztBQUMzRTs7QUFFQSxrREFBa0Qsd0VBQXNCLENBQUMsR0FBRyx3RUFBc0IsQ0FBQyxHQUFHLHdFQUFzQixDQUFDO0FBQzdIO0FBQ0EsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7O0FBRXJELGdGQUFnRix3RUFBc0I7QUFDdEcsZ0ZBQWdGLHdFQUFzQjtBQUN0RyxnRkFBZ0Ysd0VBQXNCOztBQUV0RztBQUNBLDZCQUE2QixtRUFBVyxLQUFLLG1EQUFTO0FBQ3RELDZCQUE2QixtRUFBVyxLQUFLLG1EQUFTO0FBQ3RELDZCQUE2QixtRUFBVyxLQUFLLG1EQUFTOztBQUV0RCxvRkFBb0Ysd0VBQXNCO0FBQzFHLG9GQUFvRix3RUFBc0I7QUFDMUcsb0ZBQW9GLHdFQUFzQjs7QUFFMUcsaURBQWlELHNFQUFvQixDQUFDO0FBQ3RFLHFCQUFxQixtREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixzRUFBb0I7O0FBRTFHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQjtBQUN2Qzs7QUFFQTtBQUNBLDJCQUEyQixnREFBTTtBQUNqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLDREQUF3Qix1QkFBdUIsMkVBQXlCOztBQUU1RztBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHFCQUFxQjtBQUM3Qyx1RkFBdUYsRUFBRSxHQUFHLGdCQUFnQjs7QUFFNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1EQUFTO0FBQ3JDLDRCQUE0QixtREFBUztBQUNyQyw0QkFBNEIsbURBQVM7O0FBRXJDO0FBQ0EsbUNBQW1DLDREQUF3Qix1QkFBdUIsdUVBQXFCO0FBQ3ZHLG1DQUFtQyw0REFBd0IsdUJBQXVCLHVFQUFxQjtBQUN2RyxtQ0FBbUMsNERBQXdCLHVCQUF1Qix1RUFBcUI7O0FBRXZHO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUVBQVU7QUFDNUM7QUFDQSxrQ0FBa0MsaUVBQVU7QUFDNUM7QUFDQSxrQ0FBa0MsaUVBQVU7O0FBRTVDO0FBQ0E7QUFDQSxrQ0FBa0MsbUVBQVc7QUFDN0M7QUFDQSxrQ0FBa0MsbUVBQVc7QUFDN0M7QUFDQSxrQ0FBa0MsbUVBQVc7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsb0VBQWtCLENBQUMsSUFBSSxvRUFBa0IsQ0FBQztBQUN0RyxxQkFBcUIsb0VBQWtCLENBQUMsSUFBSSxvRUFBa0IsQ0FBQyxJQUFJLG9FQUFrQixDQUFDO0FBQ3RGO0FBQ0EsaUNBQWlDLG1FQUFXLEtBQUssbURBQVM7QUFDMUQsaUNBQWlDLG1FQUFXLEtBQUssbURBQVM7QUFDMUQsaUNBQWlDLG1FQUFXLEtBQUssbURBQVM7QUFDMUQsaUNBQWlDLG1FQUFXLEtBQUssbURBQVM7QUFDMUQsaUNBQWlDLG1FQUFXLEtBQUssbURBQVM7O0FBRTFEO0FBQ0Esd0ZBQXdGLG9FQUFrQjtBQUMxRyx3RkFBd0Ysb0VBQWtCO0FBQzFHLHdGQUF3RixvRUFBa0I7QUFDMUcsd0ZBQXdGLG9FQUFrQjtBQUMxRyx3RkFBd0Ysb0VBQWtCOztBQUUxRztBQUNBLDhDQUE4Qyw0REFBd0IsdUJBQXVCLDBFQUF3QjtBQUNySCx3Q0FBd0MsbUVBQVc7O0FBRW5EO0FBQ0EsNkJBQTZCLG1EQUFTOztBQUV0QztBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQsa0dBQWtHLEVBQUUsR0FBRyxvQkFBb0I7O0FBRTNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFVOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUZBQW1GLHlCQUF5Qix3QkFBd0Isd0JBQXdCO0FBQzVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsb0VBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdFQUFtQjs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIsbURBQVM7QUFDdEMsNkJBQTZCLG1EQUFTOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQsK0ZBQStGLEVBQUUsR0FBRyxnQkFBZ0I7QUFDcEg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxpRUFBVTs7QUFFNUM7QUFDQTtBQUNBLGtDQUFrQyxtRUFBVzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLG1EQUFTO0FBQ3RDLDhCQUE4QixtREFBUzs7QUFFdkM7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQsZ0dBQWdHLEVBQUUsR0FBRyxvQkFBb0I7O0FBRXpIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFVOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsaUVBQVU7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIsbURBQVM7QUFDdEMsOEJBQThCLG1EQUFTOztBQUV2QztBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRCxnR0FBZ0csRUFBRSxHQUFHLG9CQUFvQjs7QUFFekg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxpRUFBVTs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsaUVBQVU7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsb0VBQVc7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0VBQW1CO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUzs7QUFFckQ7QUFDQSxnRkFBZ0Ysb0VBQWtCO0FBQ2xHLGdGQUFnRixvRUFBa0I7QUFDbEcsZ0ZBQWdGLG9FQUFrQjtBQUNsRyxnRkFBZ0Ysb0VBQWtCO0FBQ2xHLGdGQUFnRixvRUFBa0I7O0FBRWxHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0VBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsb0ZBQW9GLG9FQUFrQjs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZHQUE2RyxHQUFHO0FBQ2hIO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZHQUE2RyxHQUFHO0FBQ2hIO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQVU7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZHQUE2RyxHQUFHO0FBQ2hIO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsaUVBQVU7QUFDdEM7QUFDQTs7QUFFQSxxQkFBcUIsaUVBQVU7QUFDL0I7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixpRUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQix3RUFBbUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsaUVBQVU7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFLHVCQUF1QjtBQUNqRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlFQUFVO0FBQ3RDO0FBQ0E7O0FBRUEscUJBQXFCLGlFQUFVO0FBQy9CO0FBQ0E7O0FBRUEscUJBQXFCLGlFQUFVO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGlFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGlFQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzRUFBc0UsR0FBRyxVQUFVLEdBQUcsYUFBYSxHQUFHO0FBQ3RHOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3Byb3ZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIHd0bnNVdGlscyBmcm9tIFwiLi93dG5zX3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBCaWdCdWZmZXIsIFNjYWxhciwgdXRpbHMgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgeyBGRkxPTktfUFJPVE9DT0xfSUQgfSBmcm9tIFwiLi96a2V5X2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHtcbiAgICBaS0VZX0ZGX0FfTUFQX1NFQ1RJT04sXG4gICAgWktFWV9GRl9BRERJVElPTlNfU0VDVElPTixcbiAgICBaS0VZX0ZGX0JfTUFQX1NFQ1RJT04sXG4gICAgWktFWV9GRl9DMF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfQ19NQVBfU0VDVElPTixcbiAgICBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04sXG4gICAgWktFWV9GRl9QVEFVX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RQ19TRUNUSU9OLFxuICAgIFpLRVlfRkZfUUxfU0VDVElPTixcbiAgICBaS0VZX0ZGX1FNX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RT19TRUNUSU9OLFxuICAgIFpLRVlfRkZfUVJfU0VDVElPTixcbiAgICBaS0VZX0ZGX1NJR01BMV9TRUNUSU9OLFxuICAgIFpLRVlfRkZfU0lHTUEyX1NFQ1RJT04sXG4gICAgWktFWV9GRl9TSUdNQTNfU0VDVElPTixcbn0gZnJvbSBcIi4vZmZsb25rX2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgS2VjY2FrMjU2VHJhbnNjcmlwdCB9IGZyb20gXCIuL0tlY2NhazI1NlRyYW5zY3JpcHQuanNcIjtcbmltcG9ydCB7IFByb29mIH0gZnJvbSBcIi4vcHJvb2YuanNcIjtcbmltcG9ydCB7IFBvbHlub21pYWwgfSBmcm9tIFwiLi9wb2x5bm9taWFsL3BvbHlub21pYWwuanNcIjtcbmltcG9ydCB7IEV2YWx1YXRpb25zIH0gZnJvbSBcIi4vcG9seW5vbWlhbC9ldmFsdWF0aW9ucy5qc1wiO1xuaW1wb3J0IHsgQ1BvbHlub21pYWwgfSBmcm9tIFwiLi9wb2x5bm9taWFsL2Nwb2x5bm9taWFsLmpzXCI7XG5cbmNvbnN0IHsgc3RyaW5naWZ5QmlnSW50cyB9ID0gdXRpbHM7XG5cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmZsb25rUHJvdmUoemtleUZpbGVOYW1lLCB3aXRuZXNzRmlsZU5hbWUsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFBST1ZFUiBTVEFSVEVEXCIpO1xuXG4gICAgLy8gUmVhZCB3aXRuZXNzIGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyB3aXRuZXNzIGZpbGVcIik7XG4gICAgY29uc3Qge1xuICAgICAgICBmZDogZmRXdG5zLFxuICAgICAgICBzZWN0aW9uczogd3Ruc1NlY3Rpb25zXG4gICAgfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh3aXRuZXNzRmlsZU5hbWUsIFwid3Ruc1wiLCAyLCAxIDw8IDI1LCAxIDw8IDIzKTtcbiAgICBjb25zdCB3dG5zID0gYXdhaXQgd3Ruc1V0aWxzLnJlYWRIZWFkZXIoZmRXdG5zLCB3dG5zU2VjdGlvbnMpO1xuXG4gICAgLy9SZWFkIHprZXkgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIHprZXkgZmlsZVwiKTtcbiAgICBjb25zdCB7XG4gICAgICAgIGZkOiBmZFpLZXksXG4gICAgICAgIHNlY3Rpb25zOiB6a2V5U2VjdGlvbnNcbiAgICB9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHprZXlGaWxlTmFtZSwgXCJ6a2V5XCIsIDIsIDEgPDwgMjUsIDEgPDwgMjMpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkWktleSwgemtleVNlY3Rpb25zLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHprZXkucHJvdG9jb2xJZCAhPT0gRkZMT05LX1BST1RPQ09MX0lEKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgZmZsb25rXCIpO1xuICAgIH1cblxuICAgIGlmICghU2NhbGFyLmVxKHprZXkuciwgd3Rucy5xKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJ2ZSBvZiB0aGUgd2l0bmVzcyBkb2VzIG5vdCBtYXRjaCB0aGUgY3VydmUgb2YgdGhlIHByb3Zpbmcga2V5XCIpO1xuICAgIH1cblxuICAgIGlmICh3dG5zLm5XaXRuZXNzICE9PSB6a2V5Lm5WYXJzIC0gemtleS5uQWRkaXRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3aXRuZXNzIGxlbmd0aC4gQ2lyY3VpdDogJHt6a2V5Lm5WYXJzfSwgd2l0bmVzczogJHt3dG5zLm5XaXRuZXNzfSwgJHt6a2V5Lm5BZGRpdGlvbnN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSB6a2V5LmN1cnZlO1xuXG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IHNGciA9IGN1cnZlLkZyLm44O1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjggKiAyO1xuICAgIGNvbnN0IHNEb21haW4gPSB6a2V5LmRvbWFpblNpemUgKiBzRnI7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCIgIEZGTE9OSyBQUk9WRSBTRVRUSU5HU1wiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ3VydmU6ICAgICAgICAgJHtjdXJ2ZS5uYW1lfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDaXJjdWl0IHBvd2VyOiAke3prZXkucG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIERvbWFpbiBzaXplOiAgICR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBWYXJzOiAgICAgICAgICAke3prZXkublZhcnN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFB1YmxpYyB2YXJzOiAgICR7emtleS5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDb25zdHJhaW50czogICAke3prZXkubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBBZGRpdGlvbnM6ICAgICAke3prZXkubkFkZGl0aW9uc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgIH1cblxuICAgIC8vUmVhZCB3aXRuZXNzIGRhdGFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyB3aXRuZXNzIGZpbGUgZGF0YVwiKTtcbiAgICBjb25zdCBidWZmV2l0bmVzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFd0bnMsIHd0bnNTZWN0aW9ucywgMik7XG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG5cbiAgICAvLyBGaXJzdCBlbGVtZW50IGluIHBsb25rIGlzIG5vdCB1c2VkIGFuZCBjYW4gYmUgYW55IHZhbHVlLiAoQnV0IGFsd2F5cyB0aGUgc2FtZSkuXG4gICAgLy8gV2Ugc2V0IGl0IHRvIHplcm8gdG8gZ28gZmFzdGVyIGluIHRoZSBleHBvbmVudGlhdGlvbnMuXG4gICAgYnVmZldpdG5lc3Muc2V0KEZyLnplcm8sIDApO1xuICAgIGNvbnN0IGJ1ZmZJbnRlcm5hbFdpdG5lc3MgPSBuZXcgQmlnQnVmZmVyKHprZXkubkFkZGl0aW9ucyAqIHNGcik7XG5cbiAgICBsZXQgYnVmZmVycyA9IHt9O1xuICAgIGxldCBwb2x5bm9taWFscyA9IHt9O1xuICAgIGxldCBldmFsdWF0aW9ucyA9IHt9O1xuXG4gICAgLy8gVG8gZGl2aWRlIHByaW1lIGZpZWxkcyB0aGUgRXh0ZW5kZWQgRXVjbGlkZWFuIEFsZ29yaXRobSBmb3IgY29tcHV0aW5nIG1vZHVsYXIgaW52ZXJzZXMgaXMgbmVlZGVkLlxuICAgIC8vIE5PVEU6IFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgY29tcHV0ZSAxL2Rlbm9taW5hdG9yIGFuZCB0aGVuIG11bHRpcGx5IGl0IGJ5IHRoZSBudW1lcmF0b3IuXG4gICAgLy8gVGhlIEV4dGVuZGVkIEV1Y2xpZGVhbiBBbGdvcml0aG0gaXMgZXhwZW5zaXZlIGluIHRlcm1zIG9mIGNvbXB1dGF0aW9uLlxuICAgIC8vIEZvciB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gZG8gbWFueSBtb2R1bGFyIGludmVyc2VzLCB0aGVyZSdzIGEgc2ltcGxlIG1hdGhlbWF0aWNhbCB0cmlja1xuICAgIC8vIHRoYXQgYWxsb3dzIHVzIHRvIGNvbXB1dGUgbWFueSBpbnZlcnNlcywgY2FsbGVkIE1vbnRnb21lcnkgYmF0Y2ggaW52ZXJzaW9uLlxuICAgIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly92aXRhbGlrLmNhL2dlbmVyYWwvMjAxOC8wNy8yMS9zdGFya3NfcGFydF8zLmh0bWxcbiAgICAvLyBNb250Z29tZXJ5IGJhdGNoIGludmVyc2lvbiByZWR1Y2VzIHRoZSBuIGludmVyc2UgY29tcHV0YXRpb25zIHRvIGEgc2luZ2xlIG9uZVxuICAgIC8vIFRvIHNhdmUgdGhpcyAoc2luZ2xlKSBpbnZlcnNlIGNvbXB1dGF0aW9uIG9uLWNoYWluLCB3aWxsIGNvbXB1dGUgaXQgaW4gcHJvdmluZyB0aW1lIGFuZCBzZW5kIGl0IHRvIHRoZSB2ZXJpZmllci5cbiAgICAvLyBUaGUgdmVyaWZpZXIgd2lsbCBoYXZlIHRvIGNoZWNrOlxuICAgIC8vIDEpIHRoZSBkZW5vbWluYXRvciBpcyBjb3JyZWN0IG11bHRpcGx5aW5nIGJ5IGhpbXNlbGYgbm9uLWludmVydGVkIC0+IGEgKiAxL2EgPT0gMVxuICAgIC8vIDIpIGNvbXB1dGUgdGhlIHJlc3Qgb2YgdGhlIGRlbm9taW5hdG9ycyB1c2luZyB0aGUgTW9udGdvbWVyeSBiYXRjaCBpbnZlcnNpb25cbiAgICAvLyBUaGUgaW52ZXJzaW9ucyBhcmU6XG4gICAgLy8gICDCtyBkZW5vbWluYXRvciBuZWVkZWQgaW4gc3RlcCA4IGFuZCA5IG9mIHRoZSB2ZXJpZmllciB0byBtdWx0aXBseSBieSAxL1pfSCh4aSlcbiAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiBzdGVwIDEwIGFuZCAxMSBvZiB0aGUgdmVyaWZpZXJcbiAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiB0aGUgdmVyaWZpZXIgd2hlbiBjb21wdXRpbmcgTF9pXntTMX0oWCkgYW5kIExfaV57UzJ9KFgpXG4gICAgLy8gICDCtyBMX2kgaT0xIHRvIG51bSBwdWJsaWMgaW5wdXRzLCBuZWVkZWQgaW4gc3RlcCA2IGFuZCA3IG9mIHRoZSB2ZXJpZmllciB0byBjb21wdXRlIExfMSh4aSkgYW5kIFBJKHhpKVxuICAgIGxldCB0b0ludmVyc2UgPSB7fTtcblxuICAgIGxldCBjaGFsbGVuZ2VzID0ge307XG4gICAgbGV0IHJvb3RzID0ge307XG5cbiAgICBsZXQgcHJvb2YgPSBuZXcgUHJvb2YoY3VydmUsIGxvZ2dlcik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgPiBSZWFkaW5nIFNlY3Rpb24gJHtaS0VZX0ZGX0FERElUSU9OU19TRUNUSU9OfS4gQWRkaXRpb25zYCk7XG4gICAgYXdhaXQgY2FsY3VsYXRlQWRkaXRpb25zKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgPiBSZWFkaW5nIFNlY3Rpb25zICR7WktFWV9GRl9TSUdNQTFfU0VDVElPTn0sJHtaS0VZX0ZGX1NJR01BMl9TRUNUSU9OfSwke1pLRVlfRkZfU0lHTUEzX1NFQ1RJT059LiBTaWdtYTEsIFNpZ21hMiAmIFNpZ21hIDNgKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBSZWFkaW5nIFNpZ21hIHBvbHlub21pYWxzIFwiKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTEgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTIgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTMgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWExLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1NJR01BMV9TRUNUSU9OXVswXS5wKTtcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlNpZ21hMi5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTJfU0VDVElPTl1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5TaWdtYTMuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfU0lHTUEzX1NFQ1RJT05dWzBdLnApO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgUmVhZGluZyBTaWdtYSBldmFsdWF0aW9uc1wiKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTEgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgIGV2YWx1YXRpb25zLlNpZ21hMiA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgZXZhbHVhdGlvbnMuU2lnbWEzID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWExLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTFfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEyLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTJfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEzLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTNfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYD4gUmVhZGluZyBTZWN0aW9uICR7WktFWV9GRl9QVEFVX1NFQ1RJT059LiBQb3dlcnMgb2YgVGF1YCk7XG4gICAgY29uc3QgUFRhdSA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogMTYgKiBzRzEpO1xuICAgIC8vIGRvbWFpblNpemUgKiA5ICsgMTggPSBTUlMgbGVuZ3RoIGluIHRoZSB6a2V5IHNhdmVkIGluIHNldHVwIHByb2Nlc3MuXG4gICAgLy8gaXQgY29ycmVzcG9uZHMgdG8gdGhlIG1heGltdW0gU1JTIGxlbmd0aCBuZWVkZWQsIHNwZWNpZmljYWxseSB0byBjb21taXQgQzJcbiAgICAvLyBub3RpY2UgdGhhdCB0aGUgcmVzZXJ2ZWQgYnVmZmVycyBzaXplIGlzIHprZXkuZG9tYWluU2l6ZSAqIDE2ICogc0cxIGJlY2F1c2UgYSBwb3dlciBvZiB0d28gYnVmZmVyIHNpemUgaXMgbmVlZGVkXG4gICAgLy8gdGhlIHJlbWFpbmluZyBidWZmZXIgbm90IGZpbGxlZCBmcm9tIFNSUyBhcmUgc2V0IHRvIDBcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKFBUYXUsIDAsICh6a2V5LmRvbWFpblNpemUgKiA5ICsgMTgpICogc0cxLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9QVEFVX1NFQ1RJT05dWzBdLnApO1xuXG4gICAgLy8gU1RBUlQgRkZMT05LIFBST1ZFUiBQUk9UT0NPTFxuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCAxLiBDb21wdXRlIEMxKFgpIHBvbHlub21pYWxcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlwiKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgMVwiKTtcbiAgICBhd2FpdCByb3VuZDEoKTtcblxuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMDtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuUUw7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlFSO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5RTTtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuUU87XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlFDO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCAyLiBDb21wdXRlIEMyKFgpIHBvbHlub21pYWxcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgMlwiKTtcbiAgICBhd2FpdCByb3VuZDIoKTtcblxuICAgIGRlbGV0ZSBidWZmZXJzLkE7XG4gICAgZGVsZXRlIGJ1ZmZlcnMuQjtcbiAgICBkZWxldGUgYnVmZmVycy5DO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5BO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5CO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5DO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5TaWdtYTE7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlNpZ21hMjtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuU2lnbWEzO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5sYWdyYW5nZTE7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlo7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIC8vIFJPVU5EIDMuIENvbXB1dGUgb3BlbmluZyBldmFsdWF0aW9uc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBST1VORCAzXCIpO1xuICAgIGF3YWl0IHJvdW5kMygpO1xuXG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkE7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkM7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlo7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlQxO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuU2lnbWExO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5TaWdtYTI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlNpZ21hMztcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUUw7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlFSO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5RTTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUUM7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlFPO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCA0LiBDb21wdXRlIFcoWCkgcG9seW5vbWlhbFxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBST1VORCA0XCIpO1xuICAgIGF3YWl0IHJvdW5kNCgpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCA1LiBDb21wdXRlIFcnKFgpIHBvbHlub21pYWxcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgNVwiKTtcbiAgICBhd2FpdCByb3VuZDUoKTtcblxuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5DMDtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuQzE7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkMyO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5SMTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUjI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkY7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkw7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlpUO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5aVFMyO1xuICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiaW52XCIsIGdldE1vbnRnb21lcnlCYXRjaGVkSW52ZXJzZSgpKTtcblxuICAgIC8vIFByZXBhcmUgcHJvb2ZcbiAgICBsZXQgX3Byb29mID0gcHJvb2YudG9PYmplY3RQcm9vZigpO1xuICAgIF9wcm9vZi5wcm90b2NvbCA9IFwiZmZsb25rXCI7XG4gICAgX3Byb29mLmN1cnZlID0gY3VydmUubmFtZTtcblxuICAgIC8vIFByZXBhcmUgcHVibGljIGlucHV0c1xuICAgIGxldCBwdWJsaWNTaWduYWxzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBzRnI7XG5cbiAgICAgICAgY29uc3QgcHViID0gYnVmZldpdG5lc3Muc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgcHVibGljU2lnbmFscy5wdXNoKFNjYWxhci5mcm9tUnByTEUocHViKSk7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgUFJPVkVSIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvb2Y6IHN0cmluZ2lmeUJpZ0ludHMoX3Byb29mKSxcbiAgICAgICAgcHVibGljU2lnbmFsczogc3RyaW5naWZ5QmlnSW50cyhwdWJsaWNTaWduYWxzKVxuICAgIH07XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVBZGRpdGlvbnMoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBhZGRpdGlvbnNcIik7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uc0J1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfRkZfQURESVRJT05TX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIHNpemVzOiB3aXJlSWRfeCA9IDQgYnl0ZXMgKDMyIGJpdHMpLCBmYWN0b3JfeCA9IGZpZWxkIHNpemUgYml0c1xuICAgICAgICAvLyBBZGRpdGlvbiBmb3JtOiB3aXJlSWRfYSB3aXJlSWRfYiBmYWN0b3JfYSBmYWN0b3JfYiAoc2l6ZSBpcyA0ICsgNCArIHNGciArIHNGcilcbiAgICAgICAgY29uc3Qgc1N1bSA9IDggKyBzRnIgKiAyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uQWRkaXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICBhZGRpdGlvbiAke2l9LyR7emtleS5uQWRkaXRpb25zfWApO1xuXG4gICAgICAgICAgICAvLyBSZWFkIGFkZGl0aW9uIHZhbHVlc1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IGkgKiBzU3VtO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWQxID0gcmVhZFVJbnQzMihhZGRpdGlvbnNCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZDIgPSByZWFkVUludDMyKGFkZGl0aW9uc0J1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcjEgPSBhZGRpdGlvbnNCdWZmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc0ZyKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzRnI7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IyID0gYWRkaXRpb25zQnVmZi5zbGljZShvZmZzZXQsIG9mZnNldCArIHNGcik7XG5cbiAgICAgICAgICAgIC8vIEdldCB3aXRuZXNzIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB3aXRuZXNzMSA9IGdldFdpdG5lc3Moc2lnbmFsSWQxKTtcbiAgICAgICAgICAgIGNvbnN0IHdpdG5lc3MyID0gZ2V0V2l0bmVzcyhzaWduYWxJZDIpO1xuXG4gICAgICAgICAgICAvL0NhbGN1bGF0ZSBmaW5hbCByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEZyLmFkZChGci5tdWwoZmFjdG9yMSwgd2l0bmVzczEpLCBGci5tdWwoZmFjdG9yMiwgd2l0bmVzczIpKTtcblxuICAgICAgICAgICAgYnVmZkludGVybmFsV2l0bmVzcy5zZXQocmVzdWx0LCBzRnIgKiBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRVSW50MzIoYiwgbykge1xuICAgICAgICBjb25zdCBidWZmID0gYi5zbGljZShvLCBvICsgNCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBidWZmVi5nZXRVaW50MzIoMCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2l0bmVzcyhpZHgpIHtcbiAgICAgICAgbGV0IGRpZmYgPSB6a2V5Lm5WYXJzIC0gemtleS5uQWRkaXRpb25zO1xuICAgICAgICBpZiAoaWR4IDwgZGlmZikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZXaXRuZXNzLnNsaWNlKGlkeCAqIHNGciwgaWR4ICogc0ZyICsgc0ZyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpZHggPCB6a2V5Lm5WYXJzKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoaWR4IC0gZGlmZikgKiBzRnI7XG4gICAgICAgICAgICByZXR1cm4gYnVmZkludGVybmFsV2l0bmVzcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHNGcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRnIuemVybztcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDEoKSB7XG4gICAgICAgIC8vIFNURVAgMS4xIC0gR2VuZXJhdGUgcmFuZG9tIGJsaW5kaW5nIHNjYWxhcnMgKGJfMSwgLi4uLCBiOSkg4oiIIEZcbiAgICAgICAgY2hhbGxlbmdlcy5iID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDk7IGkrKykge1xuICAgICAgICAgICAgY2hhbGxlbmdlcy5iW2ldID0gRnIucmFuZG9tKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDEuMiAtIENvbXB1dGUgd2lyZSBwb2x5bm9taWFscyBhKFgpLCBiKFgpIGFuZCBjKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgQSwgQiwgQyB3aXJlIHBvbHlub21pYWxzXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlV2lyZVBvbHlub21pYWxzKCk7XG5cbiAgICAgICAgLy8gU1RFUCAxLjMgLSBDb21wdXRlIHRoZSBxdW90aWVudCBwb2x5bm9taWFsIFQwKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVDAgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVQwKCk7XG5cbiAgICAgICAgLy8gU1RFUCAxLjQgLSBDb21wdXRlIHRoZSBGRlQtc3R5bGUgY29tYmluYXRpb24gcG9seW5vbWlhbCBDMShYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEMxIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVDMSgpO1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW0MxXV8xKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEMxIG11bHRpIGV4cG9uZW50aWF0aW9uXCIpO1xuICAgICAgICBsZXQgY29tbWl0QzEgPSBhd2FpdCBwb2x5bm9taWFscy5DMS5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiQzFcIik7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJDMVwiLCBjb21taXRDMSk7XG5cbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVdpcmVQb2x5bm9taWFscygpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IFJlYWRpbmcgZGF0YSBmcm9tIHprZXkgZmlsZVwiKTtcbiAgICAgICAgICAgIC8vIEJ1aWxkIEEsIEIgYW5kIEMgZXZhbHVhdGlvbnMgYnVmZmVyIGZyb20gemtleSBhbmQgd2l0bmVzcyBmaWxlc1xuICAgICAgICAgICAgYnVmZmVycy5BID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQiA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgICAgICBidWZmZXJzLkMgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuXG4gICAgICAgICAgICAvLyBSZWFkIHprZXkgc2VjdGlvbnMgYW5kIGZpbGwgdGhlIGJ1ZmZlcnNcbiAgICAgICAgICAgIGNvbnN0IGFNYXBCdWZmID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX0ZGX0FfTUFQX1NFQ1RJT04pO1xuICAgICAgICAgICAgY29uc3QgYk1hcEJ1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfRkZfQl9NQVBfU0VDVElPTik7XG4gICAgICAgICAgICBjb25zdCBjTWFwQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9GRl9DX01BUF9TRUNUSU9OKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBhbGwgd2l0bmVzcyBmcm9tIHNpZ25hbCBpZHMgYW5kIHNldCB0aGVtIHRvIEEsQiAmIEMgYnVmZmVyc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5Db25zdHJhaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpICogc0ZyO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiA0O1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBBIHZhbHVlIGZyb20gYSBzaWduYWwgaWRcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduYWxJZEEgPSByZWFkVUludDMyKGFNYXBCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuQS5zZXQoZ2V0V2l0bmVzcyhzaWduYWxJZEEpLCBpX3NGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIEIgdmFsdWUgZnJvbSBhIHNpZ25hbCBpZFxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkQiA9IHJlYWRVSW50MzIoYk1hcEJ1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5CLnNldChnZXRXaXRuZXNzKHNpZ25hbElkQiksIGlfc0ZyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgQyB2YWx1ZSBmcm9tIGEgc2lnbmFsIGlkXG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWRDID0gcmVhZFVJbnQzMihjTWFwQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBidWZmZXJzLkMuc2V0KGdldFdpdG5lc3Moc2lnbmFsSWRDKSwgaV9zRnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCbGluZCBhKFgpLCBiKFgpIGFuZCBjKFgpIHBvbHlub21pYWxzIGNvZWZmaWNpZW50cyB3aXRoIGJsaW5kaW5nIHNjYWxhcnMgYlxuICAgICAgICAgICAgYnVmZmVycy5BLnNldChjaGFsbGVuZ2VzLmJbMV0sIHNEb21haW4gLSA2NCk7XG4gICAgICAgICAgICBidWZmZXJzLkEuc2V0KGNoYWxsZW5nZXMuYlsyXSwgc0RvbWFpbiAtIDMyKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQi5zZXQoY2hhbGxlbmdlcy5iWzNdLCBzRG9tYWluIC0gNjQpO1xuICAgICAgICAgICAgYnVmZmVycy5CLnNldChjaGFsbGVuZ2VzLmJbNF0sIHNEb21haW4gLSAzMik7XG4gICAgICAgICAgICBidWZmZXJzLkMuc2V0KGNoYWxsZW5nZXMuYls1XSwgc0RvbWFpbiAtIDY0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQy5zZXQoY2hhbGxlbmdlcy5iWzZdLCBzRG9tYWluIC0gMzIpO1xuXG4gICAgICAgICAgICBidWZmZXJzLkEgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkEpO1xuICAgICAgICAgICAgYnVmZmVycy5CID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZmVycy5CKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQyA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQyk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgd2lyZSBwb2x5bm9taWFscyBhKFgpLCBiKFgpIGFuZCBjKFgpIGZyb20gQSxCICYgQyBidWZmZXJzXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQSBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuQSA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuQSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQiBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuQiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuQiwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQyBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuQyA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuQywgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgZXh0ZW5kZWQgZXZhbHVhdGlvbnMgb2YgYShYKSwgYihYKSBhbmQgYyhYKSBwb2x5bm9taWFsc1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEEgZmZ0XCIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuQSA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkEsIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEIgZmZ0XCIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuQiA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkIsIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMgZmZ0XCIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuQyA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMsIDQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVzXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuQS5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5CLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkIgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkMuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQyBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlVDAoKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFJlYWRpbmcgc2VjdGlvbnMgJHtaS0VZX0ZGX1FMX1NFQ1RJT059LCAke1pLRVlfRkZfUVJfU0VDVElPTn1gICtcbiAgICAgICAgICAgICAgICBgLCAke1pLRVlfRkZfUU1fU0VDVElPTn0sICR7WktFWV9GRl9RT19TRUNUSU9OfSwgJHtaS0VZX0ZGX1FDX1NFQ1RJT059LiBRIHNlbGVjdG9yc2ApO1xuICAgICAgICAgICAgLy8gUmVzZXJ2ZSBtZW1vcnkgZm9yIFEncyBldmFsdWF0aW9uc1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuUUwgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuUVIgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuUU0gPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuUU8gPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuUUMgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBSZWFkIFEncyBldmFsdWF0aW9ucyBmcm9tIHprZXkgZmlsZVxuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTC5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUUxfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RUi5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUVJfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTS5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUU1fU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTy5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUU9fU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RQy5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUUNfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuXG4gICAgICAgICAgICAvLyBSZWFkIExhZ3JhbmdlIHBvbHlub21pYWxzICYgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgICAgIGNvbnN0IGxhZ3JhbmdlUG9seW5vbWlhbHMgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfRkZfTEFHUkFOR0VfU0VDVElPTik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5sYWdyYW5nZTEgPSBuZXcgRXZhbHVhdGlvbnMobGFncmFuZ2VQb2x5bm9taWFscywgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIFJlc2VydmUgbWVtb3J5IGZvciBidWZmZXJzIFQwXG4gICAgICAgICAgICBidWZmZXJzLlQwID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMCBldmFsdWF0aW9uc1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplICogNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgICAgVDAgZXZhbHVhdGlvbiAke2l9LyR7emtleS5kb21haW5TaXplICogNH1gKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCByZWxhdGVkIGV2YWx1YXRpb25zIHRvIGNvbXB1dGUgY3VycmVudCBUMCBldmFsdWF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGV2YWx1YXRpb25zLkEuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gZXZhbHVhdGlvbnMuQi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBldmFsdWF0aW9ucy5DLmdldEV2YWx1YXRpb24oaSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBxbCA9IGV2YWx1YXRpb25zLlFMLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcXIgPSBldmFsdWF0aW9ucy5RUi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFtID0gZXZhbHVhdGlvbnMuUU0uZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxbyA9IGV2YWx1YXRpb25zLlFPLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcWMgPSBldmFsdWF0aW9ucy5RQy5nZXRFdmFsdWF0aW9uKGkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBjdXJyZW50IHB1YmxpYyBpbnB1dFxuICAgICAgICAgICAgICAgIGxldCBwaSA9IEZyLnplcm87XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB6a2V5Lm5QdWJsaWM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoaiAqIDUgKiB6a2V5LmRvbWFpblNpemUpICsgemtleS5kb21haW5TaXplICsgaTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsUG9sID0gZXZhbHVhdGlvbnMubGFncmFuZ2UxLmdldEV2YWx1YXRpb24ob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVZhbCA9IGJ1ZmZlcnMuQS5zbGljZShqICogc0ZyLCAoaiArIDEpICogc0ZyKTtcblxuICAgICAgICAgICAgICAgICAgICBwaSA9IEZyLnN1YihwaSwgRnIubXVsKGxQb2wsIGFWYWwpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL1QwKFgpID0gW3FfTChYKcK3YShYKSArIHFfUihYKcK3YihYKSArIHFfTShYKcK3YShYKcK3YihYKSArIHFfTyhYKcK3YyhYKSArIHFfQyhYKSArIFBJKFgpXSDCtyAxL1pfSChYKVxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgZmlyc3QgVDAoWCnCt1pfSChYKSwgc28gZGl2aWRlIGxhdGVyIHRoZSByZXN1bHRpbmcgcG9seW5vbWlhbCBieSBaX0goWClcbiAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIDEgLT4gcV9MKFgpwrdhKFgpXG4gICAgICAgICAgICAgICAgY29uc3QgZTEgPSBGci5tdWwoYSwgcWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiAyIC0+IHFfUihYKcK3YihYKVxuICAgICAgICAgICAgICAgIGNvbnN0IGUyID0gRnIubXVsKGIsIHFyKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gMyAtPiBxX00oWCnCt2EoWCnCt2IoWClcbiAgICAgICAgICAgICAgICBjb25zdCBlMyA9IEZyLm11bChGci5tdWwoYSwgYiksIHFtKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gNCAtPiBxX08oWCnCt2MoWClcbiAgICAgICAgICAgICAgICBjb25zdCBlNCA9IEZyLm11bChjLCBxbyk7XG5cbiAgICAgICAgICAgICAgICAvLyB0MCA9IGV4cHJlc3Npb25zIDEgKyBleHByZXNzaW9uIDIgKyBleHByZXNzaW9uIDMgKyBleHByZXNzaW9uIDQgKyBxYyArIHBpXG4gICAgICAgICAgICAgICAgY29uc3QgdDAgPSBGci5hZGQoZTEsIEZyLmFkZChlMiwgRnIuYWRkKGUzLCBGci5hZGQoZTQsIEZyLmFkZChxYywgcGkpKSkpKTtcblxuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuVDAuc2V0KHQwLCBpICogc0ZyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJidWZmZXIgVDA6IFwiICsgYnVmZmVycy5UMC5ieXRlTGVuZ3RoIC8gc0ZyKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQwKFgpIGZyb20gYnVmZmVycy5UMFxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQwIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMCA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDAsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlQwIGxlbmd0aDogXCIgKyBwb2x5bm9taWFscy5UMC5sZW5ndGgoKSk7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlQwIGRlZ3JlZTogXCIgKyBwb2x5bm9taWFscy5UMC5kZWdyZWUoKSk7XG5cbiAgICAgICAgICAgIC8vIERpdmlkZSB0aGUgcG9seW5vbWlhbCBUMCBieSBaX0goWClcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMCAvIFpIXCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDAuZGl2QnlaZXJvZmllcih6a2V5LmRvbWFpblNpemUsIEZyLm9uZSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlQwLmRlZ3JlZSgpID49IDIgKiB6a2V5LmRvbWFpblNpemUgLSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUMCBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWQgKGRlZ3JlZSBpcyAke3BvbHlub21pYWxzLlQwLmRlZ3JlZSgpfSBhbmQgbXVzdCBiZSBsZXNzIHRoYW4gJHsyICogemtleS5kb21haW5TaXplICsgMn1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuVDA7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlQzEoKSB7XG4gICAgICAgICAgICBsZXQgQzEgPSBuZXcgQ1BvbHlub21pYWwoNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBDMS5hZGRQb2x5bm9taWFsKDAsIHBvbHlub21pYWxzLkEpO1xuICAgICAgICAgICAgQzEuYWRkUG9seW5vbWlhbCgxLCBwb2x5bm9taWFscy5CKTtcbiAgICAgICAgICAgIEMxLmFkZFBvbHlub21pYWwoMiwgcG9seW5vbWlhbHMuQyk7XG4gICAgICAgICAgICBDMS5hZGRQb2x5bm9taWFsKDMsIHBvbHlub21pYWxzLlQwKTtcblxuICAgICAgICAgICAgcG9seW5vbWlhbHMuQzEgPSBDMS5nZXRQb2x5bm9taWFsKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkMxLmRlZ3JlZSgpID49IDggKiB6a2V5LmRvbWFpblNpemUgLSA4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQzEgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQyKCkge1xuICAgICAgICAvLyBTVEVQIDIuMSAtIENvbXB1dGUgcGVybXV0YXRpb24gY2hhbGxlbmdlIGJldGEgYW5kIGdhbW1hIOKIiCBGXG4gICAgICAgIC8vIENvbXB1dGUgcGVybXV0YXRpb24gY2hhbGxlbmdlIGJldGFcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBjaGFsbGVuZ2VzIGJldGEgYW5kIGdhbW1hXCIpO1xuICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuXG4gICAgICAgIC8vIEFkZCBDMCB0byB0aGUgdHJhbnNjcmlwdFxuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5DMCk7XG5cbiAgICAgICAgLy8gQWRkIEEgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoYnVmZmVycy5BLnNsaWNlKGkgKiBzRnIsIGkgKiBzRnIgKyBzRnIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBDMSB0byB0aGUgdHJhbnNjcmlwdFxuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIkMxXCIpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLmJldGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmJldGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5iZXRhKSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBwZXJtdXRhdGlvbiBjaGFsbGVuZ2UgZ2FtbWFcbiAgICAgICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmJldGEpO1xuICAgICAgICBjaGFsbGVuZ2VzLmdhbW1hID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5nYW1tYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmdhbW1hKSk7XG5cbiAgICAgICAgLy8gU1RFUCAyLjIgLSBDb21wdXRlIHBlcm11dGF0aW9uIHBvbHlub21pYWwgeihYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFogcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVooKTtcblxuICAgICAgICAvLyBTVEVQIDIuMyAtIENvbXB1dGUgcXVvdGllbnQgcG9seW5vbWlhbCBUMShYKSBhbmQgVDIoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBUMSBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlVDEoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBUMiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlVDIoKTtcblxuICAgICAgICAvLyBTVEVQIDIuNCAtIENvbXB1dGUgdGhlIEZGVC1zdHlsZSBjb21iaW5hdGlvbiBwb2x5bm9taWFsIEMyKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgQzIgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZUMyKCk7XG5cbiAgICAgICAgLy8gVGhlIHNlY29uZCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW0MyXV8xKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEMyIG11bHRpIGV4cG9uZW50aWF0aW9uXCIpO1xuICAgICAgICBsZXQgY29tbWl0QzIgPSBhd2FpdCBwb2x5bm9taWFscy5DMi5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiQzJcIik7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJDMlwiLCBjb21taXRDMik7XG5cbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVooKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgWiBldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICAgICAgbGV0IG51bUFyciA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgICAgICBsZXQgZGVuQXJyID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBmaXJzdCB2YWx1ZXMgdG8gMVxuICAgICAgICAgICAgbnVtQXJyLnNldChGci5vbmUsIDApO1xuICAgICAgICAgICAgZGVuQXJyLnNldChGci5vbmUsIDApO1xuXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCBvbWVnYVxuICAgICAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgIFogZXZhbHVhdGlvbiAke2l9LyR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIHNGcjtcblxuICAgICAgICAgICAgICAgIC8vIFooWCkgOj0gbnVtQXJyIC8gZGVuQXJyXG4gICAgICAgICAgICAgICAgLy8gbnVtQXJyIDo9IChhICsgYmV0YcK3z4kgKyBnYW1tYSkoYiArIGJldGHCt8+JwrdrMSArIGdhbW1hKShjICsgYmV0YcK3z4nCt2syICsgZ2FtbWEpXG4gICAgICAgICAgICAgICAgY29uc3QgYmV0YXcgPSBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCB3KTtcblxuICAgICAgICAgICAgICAgIGxldCBudW0xID0gYnVmZmVycy5BLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgbnVtMSA9IEZyLmFkZChudW0xLCBiZXRhdyk7XG4gICAgICAgICAgICAgICAgbnVtMSA9IEZyLmFkZChudW0xLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBudW0yID0gYnVmZmVycy5CLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgbnVtMiA9IEZyLmFkZChudW0yLCBGci5tdWwoemtleS5rMSwgYmV0YXcpKTtcbiAgICAgICAgICAgICAgICBudW0yID0gRnIuYWRkKG51bTIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG51bTMgPSBidWZmZXJzLkMuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBudW0zID0gRnIuYWRkKG51bTMsIEZyLm11bCh6a2V5LmsyLCBiZXRhdykpO1xuICAgICAgICAgICAgICAgIG51bTMgPSBGci5hZGQobnVtMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgbnVtID0gRnIubXVsKG51bTEsIEZyLm11bChudW0yLCBudW0zKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBkZW5BcnIgOj0gKGEgKyBiZXRhwrdzaWdtYTEgKyBnYW1tYSkoYiArIGJldGHCt3NpZ21hMiArIGdhbW1hKShjICsgYmV0YcK3c2lnbWEzICsgZ2FtbWEpXG4gICAgICAgICAgICAgICAgbGV0IGRlbjEgPSBidWZmZXJzLkEuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBkZW4xID0gRnIuYWRkKGRlbjEsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGV2YWx1YXRpb25zLlNpZ21hMS5nZXRFdmFsdWF0aW9uKGkgKiA0KSkpO1xuICAgICAgICAgICAgICAgIGRlbjEgPSBGci5hZGQoZGVuMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZGVuMiA9IGJ1ZmZlcnMuQi5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIGRlbjIgPSBGci5hZGQoZGVuMiwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgZXZhbHVhdGlvbnMuU2lnbWEyLmdldEV2YWx1YXRpb24oaSAqIDQpKSk7XG4gICAgICAgICAgICAgICAgZGVuMiA9IEZyLmFkZChkZW4yLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBkZW4zID0gYnVmZmVycy5DLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgZGVuMyA9IEZyLmFkZChkZW4zLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBldmFsdWF0aW9ucy5TaWdtYTMuZ2V0RXZhbHVhdGlvbihpICogNCkpKTtcbiAgICAgICAgICAgICAgICBkZW4zID0gRnIuYWRkKGRlbjMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGRlbiA9IEZyLm11bChkZW4xLCBGci5tdWwoZGVuMiwgZGVuMykpO1xuXG4gICAgICAgICAgICAgICAgLy8gTXVsdGlwbHkgY3VycmVudCBudW0gdmFsdWUgd2l0aCB0aGUgcHJldmlvdXMgb25lIHNhdmVkIGluIG51bUFyclxuICAgICAgICAgICAgICAgIG51bSA9IEZyLm11bChudW1BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKSwgbnVtKTtcbiAgICAgICAgICAgICAgICBudW1BcnIuc2V0KG51bSwgKChpICsgMSkgJSB6a2V5LmRvbWFpblNpemUpICogc0ZyKTtcblxuICAgICAgICAgICAgICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgZGVuIHZhbHVlIHdpdGggdGhlIHByZXZpb3VzIG9uZSBzYXZlZCBpbiBkZW5BcnJcbiAgICAgICAgICAgICAgICBkZW4gPSBGci5tdWwoZGVuQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGciksIGRlbik7XG4gICAgICAgICAgICAgICAgZGVuQXJyLnNldChkZW4sICgoaSArIDEpICUgemtleS5kb21haW5TaXplKSAqIHNGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBOZXh0IG9tZWdhXG4gICAgICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGludmVyc2Ugb2YgZGVuQXJyIHRvIGNvbXB1dGUgaW4gdGhlIG5leHQgY29tbWFuZCB0aGVcbiAgICAgICAgICAgIC8vIGRpdmlzaW9uIG51bUFyci9kZW5BcnIgYnkgbXVsdGlwbHlpbmcgbnVtIMK3IDEvZGVuQXJyXG4gICAgICAgICAgICBkZW5BcnIgPSBhd2FpdCBGci5iYXRjaEludmVyc2UoZGVuQXJyKTtcblxuICAgICAgICAgICAgLy8gVE9ETzogRG8gaXQgaW4gYXNzZW1ibHkgYW5kIGluIHBhcmFsbGVsXG4gICAgICAgICAgICAvLyBNdWx0aXBseSBudW1BcnIgwrcgZGVuQXJyIHdoZXJlIGRlbkFyciB3YXMgaW52ZXJ0ZWQgaW4gdGhlIHByZXZpb3VzIGNvbW1hbmRcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBzRnI7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB6ID0gRnIubXVsKG51bUFyci5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpLCBkZW5BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKSk7XG4gICAgICAgICAgICAgICAgbnVtQXJyLnNldCh6LCBpX3NGcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGcm9tIG5vdyBvbiB0aGUgdmFsdWVzIHNhdmVkIG9uIG51bUFyciB3aWxsIGJlIFooWCkgYnVmZmVyXG4gICAgICAgICAgICBidWZmZXJzLlogPSBudW1BcnI7XG5cbiAgICAgICAgICAgIGlmICghRnIuZXEobnVtQXJyLnNsaWNlKDAsIHNGciksIEZyLm9uZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3B5IGNvbnN0cmFpbnRzIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHBvbHlub21pYWwgY29lZmZpY2llbnRzIHooWCkgZnJvbSBidWZmZXJzLlpcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBaIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5aID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5aLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBleHRlbmRlZCBldmFsdWF0aW9ucyBvZiB6KFgpIHBvbHlub21pYWxcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBaIGZmdFwiKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLlogPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5aLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQmxpbmQgeihYKSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cyB3aXRoIGJsaW5kaW5nIHNjYWxhcnMgYlxuICAgICAgICAgICAgcG9seW5vbWlhbHMuWi5ibGluZENvZWZmaWNpZW50cyhbY2hhbGxlbmdlcy5iWzldLCBjaGFsbGVuZ2VzLmJbOF0sIGNoYWxsZW5nZXMuYls3XV0pO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5aLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSArIDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJaIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuWjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVUMSgpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMSBldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICAgICAgYnVmZmVycy5UMSA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDIpO1xuICAgICAgICAgICAgYnVmZmVycy5UMXogPSBuZXcgQmlnQnVmZmVyKHNEb21haW4gKiAyKTtcblxuICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgb21lZ2FcbiAgICAgICAgICAgIGxldCBvbWVnYSA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplICogMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgIFQxIGV2YWx1YXRpb24gJHtpfS8ke3prZXkuZG9tYWluU2l6ZSAqIDR9YCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvbWVnYTIgPSBGci5zcXVhcmUob21lZ2EpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IGV2YWx1YXRpb25zLlouZ2V0RXZhbHVhdGlvbihpICogMik7XG4gICAgICAgICAgICAgICAgY29uc3QgenAgPSBGci5hZGQoRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJbN10sIG9tZWdhMiksIEZyLm11bChjaGFsbGVuZ2VzLmJbOF0sIG9tZWdhKSksIGNoYWxsZW5nZXMuYls5XSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUMShYKSA6PSAoeihYKSAtIDEpIMK3IExfMShYKVxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgZmlyc3QgVDEoWCnCt1pfSChYKSwgc28gZGl2aWRlIGxhdGVyIHRoZSByZXN1bHRpbmcgcG9seW5vbWlhbCBieSBaX0goWClcbiAgICAgICAgICAgICAgICBjb25zdCBsYWdyYW5nZTEgPSBldmFsdWF0aW9ucy5sYWdyYW5nZTEuZ2V0RXZhbHVhdGlvbih6a2V5LmRvbWFpblNpemUgKyBpICogMik7XG4gICAgICAgICAgICAgICAgbGV0IHQxID0gRnIubXVsKEZyLnN1Yih6LCBGci5vbmUpLCBsYWdyYW5nZTEpO1xuICAgICAgICAgICAgICAgIGxldCB0MXogPSBGci5tdWwoenAsIGxhZ3JhbmdlMSk7XG5cbiAgICAgICAgICAgICAgICBidWZmZXJzLlQxLnNldCh0MSwgaSAqIHNGcik7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5UMXouc2V0KHQxeiwgaSAqIHNGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgb21lZ2FcbiAgICAgICAgICAgICAgICBvbWVnYSA9IEZyLm11bChvbWVnYSwgRnIud1t6a2V5LnBvd2VyICsgMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVDEoWCkgZnJvbSBidWZmZXJzLlQxXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDEgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQxID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5UMSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIERpdmlkZSB0aGUgcG9seW5vbWlhbCBUMSBieSBaX0goWClcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQxLmRpdkJ5WmVyb2ZpZXIoemtleS5kb21haW5TaXplLCBGci5vbmUpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVDF6KFgpIGZyb20gYnVmZmVycy5UMXpcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMXogaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQxeiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDF6LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBwb2x5bm9taWFsIFQxeiB0byBUMSB0byBnZXQgdGhlIGZpbmFsIHBvbHlub21pYWwgVDFcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQxLmFkZChwb2x5bm9taWFscy5UMXopO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5UMS5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUgKyAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVDEgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5UMTtcbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlQxejtcbiAgICAgICAgICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMXo7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlVDIoKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDIgZXZhbHVhdGlvbnNcIik7XG5cbiAgICAgICAgICAgIGJ1ZmZlcnMuVDIgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuVDJ6ID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIG9tZWdhXG4gICAgICAgICAgICBsZXQgb21lZ2EgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZSAqIDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICBUMiBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemUgKiA0fWApO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb21lZ2EyID0gRnIuc3F1YXJlKG9tZWdhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbWVnYVcgPSBGci5tdWwob21lZ2EsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9tZWdhVzIgPSBGci5zcXVhcmUob21lZ2FXKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBldmFsdWF0aW9ucy5BLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGV2YWx1YXRpb25zLkIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gZXZhbHVhdGlvbnMuQy5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgelcgPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oKHprZXkuZG9tYWluU2l6ZSAqIDQgKyA0ICsgaSkgJSAoemtleS5kb21haW5TaXplICogNCkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgenAgPSBGci5hZGQoRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJbN10sIG9tZWdhMiksIEZyLm11bChjaGFsbGVuZ2VzLmJbOF0sIG9tZWdhKSksIGNoYWxsZW5nZXMuYls5XSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeldwID0gRnIuYWRkKEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iWzddLCBvbWVnYVcyKSwgRnIubXVsKGNoYWxsZW5nZXMuYls4XSwgb21lZ2FXKSksIGNoYWxsZW5nZXMuYls5XSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaWdtYTEgPSBldmFsdWF0aW9ucy5TaWdtYTEuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWdtYTIgPSBldmFsdWF0aW9ucy5TaWdtYTIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWdtYTMgPSBldmFsdWF0aW9ucy5TaWdtYTMuZ2V0RXZhbHVhdGlvbihpKTtcblxuICAgICAgICAgICAgICAgIC8vIFQyKFgpIDo9IFsgKGEoWCkgKyBiZXRhwrdYICsgZ2FtbWEpKGIoWCkgKyBiZXRhwrdrMcK3WCArIGdhbW1hKShjKFgpICsgYmV0YcK3azLCt1ggKyBnYW1tYSl6KFgpXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgIC0oYShYKSArIGJldGHCt3NpZ21hMShYKSArIGdhbW1hKShiKFgpICsgYmV0YcK3c2lnbWEyKFgpICsgZ2FtbWEpKGMoWCkgKyBiZXRhwrdzaWdtYTMoWCkgKyBnYW1tYSl6KFjPiSldIMK3IDEvWl9IKFgpXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBmaXJzdCBUMihYKcK3Wl9IKFgpLCBzbyBkaXZpZGUgbGF0ZXIgdGhlIHJlc3VsdGluZyBwb2x5bm9taWFsIGJ5IFpfSChYKVxuXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiAxIC0+IChhKFgpICsgYmV0YcK3WCArIGdhbW1hKShiKFgpICsgYmV0YcK3azHCt1ggKyBnYW1tYSkoYyhYKSArIGJldGHCt2sywrdYICsgZ2FtbWEpeihYKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJldGFYID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgb21lZ2EpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUxMSA9IEZyLmFkZChhLCBiZXRhWCk7XG4gICAgICAgICAgICAgICAgZTExID0gRnIuYWRkKGUxMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTEyID0gRnIuYWRkKGIsIEZyLm11bChiZXRhWCwgemtleS5rMSkpO1xuICAgICAgICAgICAgICAgIGUxMiA9IEZyLmFkZChlMTIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUxMyA9IEZyLmFkZChjLCBGci5tdWwoYmV0YVgsIHprZXkuazIpKTtcbiAgICAgICAgICAgICAgICBlMTMgPSBGci5hZGQoZTEzLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMSA9IEZyLm11bChGci5tdWwoRnIubXVsKGUxMSwgZTEyKSwgZTEzKSwgeik7XG4gICAgICAgICAgICAgICAgbGV0IGUxeiA9IEZyLm11bChGci5tdWwoRnIubXVsKGUxMSwgZTEyKSwgZTEzKSwgenApO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IFtlMSwgZTF6XSA9IE11bFoubXVsNChlMTEsIGUxMiwgZTEzLCB6LCBhcCwgYnAsIGNwLCB6cCwgaSAlIDQsIEZyKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gMiAtPiAoYShYKSArIGJldGHCt3NpZ21hMShYKSArIGdhbW1hKShiKFgpICsgYmV0YcK3c2lnbWEyKFgpICsgZ2FtbWEpKGMoWCkgKyBiZXRhwrdzaWdtYTMoWCkgKyBnYW1tYSl6KFjPiSlcbiAgICAgICAgICAgICAgICBsZXQgZTIxID0gRnIuYWRkKGEsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHNpZ21hMSkpO1xuICAgICAgICAgICAgICAgIGUyMSA9IEZyLmFkZChlMjEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUyMiA9IEZyLmFkZChiLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBzaWdtYTIpKTtcbiAgICAgICAgICAgICAgICBlMjIgPSBGci5hZGQoZTIyLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMjMgPSBGci5hZGQoYywgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgc2lnbWEzKSk7XG4gICAgICAgICAgICAgICAgZTIzID0gRnIuYWRkKGUyMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTIgPSBGci5tdWwoRnIubXVsKEZyLm11bChlMjEsIGUyMiksIGUyMyksIHpXKTtcbiAgICAgICAgICAgICAgICBsZXQgZTJ6ID0gRnIubXVsKEZyLm11bChGci5tdWwoZTIxLCBlMjIpLCBlMjMpLCB6V3ApO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IFtlMiwgZTJ6XSA9IE11bFoubXVsNChlMjEsIGUyMiwgZTIzLCB6VywgYXAsIGJwLCBjcCwgeldwLCBpICUgNCwgRnIpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHQyID0gRnIuc3ViKGUxLCBlMik7XG4gICAgICAgICAgICAgICAgbGV0IHQyeiA9IEZyLnN1YihlMXosIGUyeik7XG5cbiAgICAgICAgICAgICAgICBidWZmZXJzLlQyLnNldCh0MiwgaSAqIHNGcik7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5UMnouc2V0KHQyeiwgaSAqIHNGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgb21lZ2FcbiAgICAgICAgICAgICAgICBvbWVnYSA9IEZyLm11bChvbWVnYSwgRnIud1t6a2V5LnBvd2VyICsgMl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVDIoWCkgZnJvbSBidWZmZXJzLlQyXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDIgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQyID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5UMiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIERpdmlkZSB0aGUgcG9seW5vbWlhbCBUMiBieSBaX0goWClcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMiAvIFpIXCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDIuZGl2QnlaZXJvZmllcih6a2V5LmRvbWFpblNpemUsIEZyLm9uZSk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcG9seW5vbWlhbCBUMnooWCkgZnJvbSBidWZmZXJzLlQyelxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQyeiBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDJ6ID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5UMnosIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHBvbHlub21pYWwgVDJ6IHRvIFQyIHRvIGdldCB0aGUgZmluYWwgcG9seW5vbWlhbCBUMlxuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDIuYWRkKHBvbHlub21pYWxzLlQyeik7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlQyLmRlZ3JlZSgpID49IDMgKiB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUMiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlQyO1xuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuVDJ6O1xuICAgICAgICAgICAgZGVsZXRlIHBvbHlub21pYWxzLlQyejtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVDMigpIHtcbiAgICAgICAgICAgIGxldCBDMiA9IG5ldyBDUG9seW5vbWlhbCgzLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIEMyLmFkZFBvbHlub21pYWwoMCwgcG9seW5vbWlhbHMuWik7XG4gICAgICAgICAgICBDMi5hZGRQb2x5bm9taWFsKDEsIHBvbHlub21pYWxzLlQxKTtcbiAgICAgICAgICAgIEMyLmFkZFBvbHlub21pYWwoMiwgcG9seW5vbWlhbHMuVDIpO1xuXG4gICAgICAgICAgICBwb2x5bm9taWFscy5DMiA9IEMyLmdldFBvbHlub21pYWwoKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuQzIuZGVncmVlKCkgPj0gOSAqIHprZXkuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkMyIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMygpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBjaGFsbGVuZ2UgeGlcIik7XG4gICAgICAgIC8vIFNURVAgMy4xIC0gQ29tcHV0ZSBldmFsdWF0aW9uIGNoYWxsZW5nZSB4aSDiiIggU1xuICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJDMlwiKSk7XG5cbiAgICAgICAgLy8gT2J0YWluIGEgeGlfc2VlZGVyIGZyb20gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgLy8gVG8gZm9yY2UgaDFeNCA9IHhpLCBoMl4zID0geGkgYW5kIGhfM14yID0geGnPiVxuICAgICAgICAvLyB3ZSBjb21wdXRlIHhpID0geGlfc2VlZGVyXjEyLCBoMSA9IHhpX3NlZWRlcl4zLCBoMiA9IHhpX3NlZWRlcl40IGFuZCBoMyA9IHhpX3NlZWRlcl42XG4gICAgICAgIGNoYWxsZW5nZXMueGlTZWVkID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgY29uc3QgeGlTZWVkMiA9IEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpU2VlZCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBvbWVnYTgsIG9tZWdhNCBhbmQgb21lZ2EzXG4gICAgICAgIHJvb3RzLnc4ID0gW107XG4gICAgICAgIHJvb3RzLnc4WzBdID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgcm9vdHMudzhbaV0gPSBGci5tdWwocm9vdHMudzhbaSAtIDFdLCB6a2V5Lnc4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3RzLnc0ID0gW107XG4gICAgICAgIHJvb3RzLnc0WzBdID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgcm9vdHMudzRbaV0gPSBGci5tdWwocm9vdHMudzRbaSAtIDFdLCB6a2V5Lnc0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3RzLnczID0gW107XG4gICAgICAgIHJvb3RzLnczWzBdID0gRnIub25lO1xuICAgICAgICByb290cy53M1sxXSA9IHprZXkudzM7XG4gICAgICAgIHJvb3RzLnczWzJdID0gRnIuc3F1YXJlKHprZXkudzMpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgaDAgPSB4aVNlZWRlcl4zXG4gICAgICAgIHJvb3RzLlMwID0ge307XG4gICAgICAgIHJvb3RzLlMwLmgwdzggPSBbXTtcbiAgICAgICAgcm9vdHMuUzAuaDB3OFswXSA9IEZyLm11bCh4aVNlZWQyLCBjaGFsbGVuZ2VzLnhpU2VlZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICByb290cy5TMC5oMHc4W2ldID0gRnIubXVsKHJvb3RzLlMwLmgwdzhbMF0sIHJvb3RzLnc4W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgaDEgPSB4aV9zZWVkZXJeNlxuICAgICAgICByb290cy5TMSA9IHt9O1xuICAgICAgICByb290cy5TMS5oMXc0ID0gW107XG4gICAgICAgIHJvb3RzLlMxLmgxdzRbMF0gPSBGci5zcXVhcmUocm9vdHMuUzAuaDB3OFswXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICByb290cy5TMS5oMXc0W2ldID0gRnIubXVsKHJvb3RzLlMxLmgxdzRbMF0sIHJvb3RzLnc0W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgaDIgPSB4aV9zZWVkZXJeOFxuICAgICAgICByb290cy5TMiA9IHt9O1xuICAgICAgICByb290cy5TMi5oMnczID0gW107XG4gICAgICAgIHJvb3RzLlMyLmgydzNbMF0gPSBGci5tdWwocm9vdHMuUzEuaDF3NFswXSwgeGlTZWVkMik7XG4gICAgICAgIHJvb3RzLlMyLmgydzNbMV0gPSBGci5tdWwocm9vdHMuUzIuaDJ3M1swXSwgcm9vdHMudzNbMV0pO1xuICAgICAgICByb290cy5TMi5oMnczWzJdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHJvb3RzLnczWzJdKTtcblxuICAgICAgICByb290cy5TMi5oM3czID0gW107XG4gICAgICAgIC8vIE11bHRpcGx5IGgzIGJ5IHRoaXJkLXJvb3Qtb21lZ2EgdG8gb2J0YWluIGhfM14zID0geGnPiVxuICAgICAgICAvLyBTbywgaDMgPSB4aV9zZWVkZXJeOCDPiV57MS8zfVxuICAgICAgICByb290cy5TMi5oM3czWzBdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHprZXkud3IpO1xuICAgICAgICByb290cy5TMi5oM3czWzFdID0gRnIubXVsKHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLnczWzFdKTtcbiAgICAgICAgcm9vdHMuUzIuaDN3M1syXSA9IEZyLm11bChyb290cy5TMi5oM3czWzBdLCByb290cy53M1syXSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB4aSA9IHhpX3NlZWRlcl4yNFxuICAgICAgICBjaGFsbGVuZ2VzLnhpID0gRnIubXVsKEZyLnNxdWFyZShyb290cy5TMi5oMnczWzBdKSwgcm9vdHMuUzIuaDJ3M1swXSk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy54aTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnhpKSk7XG5cbiAgICAgICAgLy8gUmVzZXJ2ZSBtZW1vcnkgZm9yIFEncyBwb2x5bm9taWFsc1xuICAgICAgICBwb2x5bm9taWFscy5RTCA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RUiA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RTSA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RTyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RQyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIFJlYWQgUSdzIGV2YWx1YXRpb25zIGZyb20gemtleSBmaWxlXG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUUwuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfUUxfU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUVIuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfUVJfU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUU0uY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfUU1fU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUU8uY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfUU9fU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUUMuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfUUNfU0VDVElPTl1bMF0ucCk7XG5cbiAgICAgICAgLy8gU1RFUCAzLjIgLSBDb21wdXRlIG9wZW5pbmcgZXZhbHVhdGlvbnMgYW5kIGFkZCB0aGVtIHRvIHRoZSBwcm9vZiAodGhpcmQgb3V0cHV0IG9mIHRoZSBwcm92ZXIpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBldmFsdWF0aW9uc1wiKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInFsXCIsIHBvbHlub21pYWxzLlFMLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInFyXCIsIHBvbHlub21pYWxzLlFSLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInFtXCIsIHBvbHlub21pYWxzLlFNLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInFvXCIsIHBvbHlub21pYWxzLlFPLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInFjXCIsIHBvbHlub21pYWxzLlFDLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInMxXCIsIHBvbHlub21pYWxzLlNpZ21hMS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJzMlwiLCBwb2x5bm9taWFscy5TaWdtYTIuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiczNcIiwgcG9seW5vbWlhbHMuU2lnbWEzLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImFcIiwgcG9seW5vbWlhbHMuQS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJiXCIsIHBvbHlub21pYWxzLkIuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiY1wiLCBwb2x5bm9taWFscy5DLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInpcIiwgcG9seW5vbWlhbHMuWi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG5cbiAgICAgICAgY2hhbGxlbmdlcy54aXcgPSBGci5tdWwoY2hhbGxlbmdlcy54aSwgRnIud1t6a2V5LnBvd2VyXSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJ6d1wiLCBwb2x5bm9taWFscy5aLmV2YWx1YXRlKGNoYWxsZW5nZXMueGl3KSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJ0MXdcIiwgcG9seW5vbWlhbHMuVDEuZXZhbHVhdGUoY2hhbGxlbmdlcy54aXcpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInQyd1wiLCBwb2x5bm9taWFscy5UMi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpdykpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kNCgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBjaGFsbGVuZ2UgYWxwaGFcIik7XG4gICAgICAgIC8vIFNURVAgNC4xIC0gQ29tcHV0ZSBjaGFsbGVuZ2UgYWxwaGEg4oiIIEZcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy54aVNlZWQpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwicWxcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwicXJcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwicW1cIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwicW9cIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwicWNcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiczFcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiczJcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiczNcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiYVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJiXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImNcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwielwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJ6d1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJ0MXdcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwidDJ3XCIpKTtcbiAgICAgICAgY2hhbGxlbmdlcy5hbHBoYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuYWxwaGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5hbHBoYSkpO1xuXG4gICAgICAgIC8vIFNURVAgNC4yIC0gQ29tcHV0ZSBGKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIEMwIHBvbHlub21pYWxcIik7XG4gICAgICAgIHBvbHlub21pYWxzLkMwID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogOCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLkMwLmNvZWYsIDAsIHNEb21haW4gKiA4LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9DMF9TRUNUSU9OXVswXS5wKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFIwIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbXB1dGVSMCgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFIxIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbXB1dGVSMSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFIyIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbXB1dGVSMigpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgRiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlRigpO1xuXG4gICAgICAgIC8vIFRoZSBmb3VydGggb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtXMV1fMSksIHdoZXJlIFcxOj0oZi9aX3QpKHgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVzEgbXVsdGkgZXhwb25lbnRpYXRpb25cIik7XG4gICAgICAgIGxldCBjb21taXRXMSA9IGF3YWl0IHBvbHlub21pYWxzLkYubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlcxXCIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiVzFcIiwgY29tbWl0VzEpO1xuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSMCgpIHtcbiAgICAgICAgICAgIC8vIENPTVBVVEUgUjBcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiBSMChYKSBmcm9tIDggZXZhbHVhdGlvbnMgdXNpbmcgbGFncmFuZ2UgaW50ZXJwb2xhdGlvbi4gUjAoWCkg4oiIIEZfezw4fVtYXVxuICAgICAgICAgICAgLy8gV2UgZGVjaWRlIHRvIHVzZSBMYWdyYW5nZSBpbnRlcnBvbGF0aW9ucyBiZWNhdXNlIHRoZSBSMCBkZWdyZWUgaXMgdmVyeSBzbWFsbCAoZGVnKFIwKT09PTcpLFxuICAgICAgICAgICAgLy8gYW5kIHdlIHdlcmUgbm90IGFibGUgdG8gY29tcHV0ZSBpdCB1c2luZyBjdXJyZW50IGlmZnQgaW1wbGVtZW50YXRpb24gYmVjYXVzZSB0aGUgb21lZ2EgYXJlIGRpZmZlcmVudFxuICAgICAgICAgICAgcG9seW5vbWlhbHMuUjAgPSBQb2x5bm9taWFsLmxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oXG4gICAgICAgICAgICAgICAgW3Jvb3RzLlMwLmgwdzhbMF0sIHJvb3RzLlMwLmgwdzhbMV0sIHJvb3RzLlMwLmgwdzhbMl0sIHJvb3RzLlMwLmgwdzhbM10sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMwLmgwdzhbNF0sIHJvb3RzLlMwLmgwdzhbNV0sIHJvb3RzLlMwLmgwdzhbNl0sIHJvb3RzLlMwLmgwdzhbN11dLFxuICAgICAgICAgICAgICAgIFtwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzBdKSwgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFsxXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbMl0pLCBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzNdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFs0XSksIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbNV0pLFxuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzZdKSwgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFs3XSldLCBjdXJ2ZSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBkZWdyZWUgb2YgcjAoWCkgPCA4XG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuUjAuZGVncmVlKCkgPiA3KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUjAgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVIxKCkge1xuICAgICAgICAgICAgLy8gQ09NUFVURSBSMVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIFIxKFgpIGZyb20gNCBldmFsdWF0aW9ucyB1c2luZyBsYWdyYW5nZSBpbnRlcnBvbGF0aW9uLiBSMShYKSDiiIggRl97PDR9W1hdXG4gICAgICAgICAgICAvLyBXZSBkZWNpZGUgdG8gdXNlIExhZ3JhbmdlIGludGVycG9sYXRpb25zIGJlY2F1c2UgdGhlIFIxIGRlZ3JlZSBpcyB2ZXJ5IHNtYWxsIChkZWcoUjEpPT09MyksXG4gICAgICAgICAgICAvLyBhbmQgd2Ugd2VyZSBub3QgYWJsZSB0byBjb21wdXRlIGl0IHVzaW5nIGN1cnJlbnQgaWZmdCBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIHRoZSBvbWVnYSBhcmUgZGlmZmVyZW50XG4gICAgICAgICAgICBwb2x5bm9taWFscy5SMSA9IFBvbHlub21pYWwubGFncmFuZ2VQb2x5bm9taWFsSW50ZXJwb2xhdGlvbihcbiAgICAgICAgICAgICAgICBbcm9vdHMuUzEuaDF3NFswXSwgcm9vdHMuUzEuaDF3NFsxXSwgcm9vdHMuUzEuaDF3NFsyXSwgcm9vdHMuUzEuaDF3NFszXV0sXG4gICAgICAgICAgICAgICAgW3BvbHlub21pYWxzLkMxLmV2YWx1YXRlKHJvb3RzLlMxLmgxdzRbMF0pLCBwb2x5bm9taWFscy5DMS5ldmFsdWF0ZShyb290cy5TMS5oMXc0WzFdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzEuZXZhbHVhdGUocm9vdHMuUzEuaDF3NFsyXSksIHBvbHlub21pYWxzLkMxLmV2YWx1YXRlKHJvb3RzLlMxLmgxdzRbM10pXSwgY3VydmUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgZGVncmVlIG9mIHIxKFgpIDwgNFxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlIxLmRlZ3JlZSgpID4gMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlIxIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSMigpIHtcbiAgICAgICAgICAgIC8vIENPTVBVVEUgUjJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiByMihYKSBmcm9tIDYgZXZhbHVhdGlvbnMgdXNpbmcgbGFncmFuZ2UgaW50ZXJwb2xhdGlvbi4gcjIoWCkg4oiIIEZfezw2fVtYXVxuICAgICAgICAgICAgLy8gV2UgZGVjaWRlIHRvIHVzZSBMYWdyYW5nZSBpbnRlcnBvbGF0aW9ucyBiZWNhdXNlIHRoZSBSMi5kZWdyZWUgaXMgdmVyeSBzbWFsbCAoZGVnKFIyKT09PTUpLFxuICAgICAgICAgICAgLy8gYW5kIHdlIHdlcmUgbm90IGFibGUgdG8gY29tcHV0ZSBpdCB1c2luZyBjdXJyZW50IGlmZnQgaW1wbGVtZW50YXRpb24gYmVjYXVzZSB0aGUgb21lZ2EgYXJlIGRpZmZlcmVudFxuICAgICAgICAgICAgcG9seW5vbWlhbHMuUjIgPSBQb2x5bm9taWFsLmxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oXG4gICAgICAgICAgICAgICAgW3Jvb3RzLlMyLmgydzNbMF0sIHJvb3RzLlMyLmgydzNbMV0sIHJvb3RzLlMyLmgydzNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLlMyLmgzdzNbMV0sIHJvb3RzLlMyLmgzdzNbMl1dLFxuICAgICAgICAgICAgICAgIFtwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oMnczWzBdKSwgcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDJ3M1sxXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgydzNbMl0pLCBwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oM3czWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDN3M1sxXSksIHBvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgzdzNbMl0pXSwgY3VydmUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgZGVncmVlIG9mIHIyKFgpIDwgNlxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlIyLmRlZ3JlZSgpID4gNSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlIyIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVGKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEYgcG9seW5vbWlhbFwiKTtcblxuICAgICAgICAgICAgLy8gQ09NUFVURSBGKFgpXG4gICAgICAgICAgICBwb2x5bm9taWFscy5GID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DMCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLnN1Yihwb2x5bm9taWFscy5SMCk7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLmRpdkJ5WmVyb2ZpZXIoOCwgY2hhbGxlbmdlcy54aSk7XG5cbiAgICAgICAgICAgIGxldCBmMiA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzEsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZjIuc3ViKHBvbHlub21pYWxzLlIxKTtcbiAgICAgICAgICAgIGYyLm11bFNjYWxhcihjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICAgICAgICAgIGYyLmRpdkJ5WmVyb2ZpZXIoNCwgY2hhbGxlbmdlcy54aSk7XG5cbiAgICAgICAgICAgIGxldCBmMyA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzIsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZjMuc3ViKHBvbHlub21pYWxzLlIyKTtcbiAgICAgICAgICAgIGYzLm11bFNjYWxhcihGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSkpO1xuICAgICAgICAgICAgZjMuZGl2QnlaZXJvZmllcigzLCBjaGFsbGVuZ2VzLnhpKTtcbiAgICAgICAgICAgIGYzLmRpdkJ5WmVyb2ZpZXIoMywgY2hhbGxlbmdlcy54aXcpO1xuXG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLmFkZChmMik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLmFkZChmMyk7XG5cbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5GLmRlZ3JlZSgpID49IDkgKiB6a2V5LmRvbWFpblNpemUgLSA2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDUoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIHlcIik7XG5cbiAgICAgICAgLy8gU1RFUCA1LjEgLSBDb21wdXRlIHJhbmRvbSBldmFsdWF0aW9uIHBvaW50IHkg4oiIIEZcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5hbHBoYSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiVzFcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMueSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMueTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnkpKTtcblxuICAgICAgICAvLyBTVEVQIDUuMiAtIENvbXB1dGUgTChYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEwgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZUwoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFpUUzIgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVpUUzIoKTtcblxuICAgICAgICBsZXQgWlRTMlkgPSBwb2x5bm9taWFscy5aVFMyLmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG4gICAgICAgIFpUUzJZID0gRnIuaW52KFpUUzJZKTtcbiAgICAgICAgcG9seW5vbWlhbHMuTC5tdWxTY2FsYXIoWlRTMlkpO1xuXG4gICAgICAgIGNvbnN0IHBvbERpdmlkZW5kID0gUG9seW5vbWlhbC5mcm9tQ29lZmZpY2llbnRzQXJyYXkoW0ZyLm5lZyhjaGFsbGVuZ2VzLnkpLCBGci5vbmVdLCBjdXJ2ZSk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVycgPSBMIC8gWlRTMiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb25zdCBwb2xSZW1haW5kZXIgPSBwb2x5bm9taWFscy5MLmRpdkJ5KHBvbERpdmlkZW5kKTtcblxuICAgICAgICAvL0NoZWNrIHBvbFJlbWluZGVyIGRlZ3JlZSBpcyBlcXVhbCB0byB6ZXJvXG4gICAgICAgIGlmIChwb2xSZW1haW5kZXIuZGVncmVlKCkgPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlZ3JlZSBvZiBMKFgpLyhaVFMyKHkpKFgteSkpIHJlbWFpbmRlciBpcyAke3BvbFJlbWFpbmRlci5kZWdyZWUoKX0gYW5kIHNob3VsZCBiZSAwYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9seW5vbWlhbHMuTC5kZWdyZWUoKSA+PSA5ICogemtleS5kb21haW5TaXplIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVncmVlIG9mIEwoWCkvKFpUUzIoeSkoWC15KSkgaXMgbm90IGNvcnJlY3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZmlmdGggb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtXMl1fMSksIHdoZXJlIFcyOj0oZi9aX3QpKHgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVycgbXVsdGkgZXhwb25lbnRpYXRpb25cIik7XG4gICAgICAgIGxldCBjb21taXRXMiA9IGF3YWl0IHBvbHlub21pYWxzLkwubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlcyXCIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiVzJcIiwgY29tbWl0VzIpO1xuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVMKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEwgcG9seW5vbWlhbFwiKTtcblxuICAgICAgICAgICAgY29uc3QgZXZhbFIwWSA9IHBvbHlub21pYWxzLlIwLmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG4gICAgICAgICAgICBjb25zdCBldmFsUjFZID0gcG9seW5vbWlhbHMuUjEuZXZhbHVhdGUoY2hhbGxlbmdlcy55KTtcbiAgICAgICAgICAgIGNvbnN0IGV2YWxSMlkgPSBwb2x5bm9taWFscy5SMi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xuXG4gICAgICAgICAgICBsZXQgbXVsTDAgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMC5oMHc4WzBdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbXVsTDAgPSBGci5tdWwobXVsTDAsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMwLmgwdzhbaV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG11bEwxID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzEuaDF3NFswXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIG11bEwxID0gRnIubXVsKG11bEwxLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMS5oMXc0W2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtdWxMMiA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgydzNbMF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtdWxMMiA9IEZyLm11bChtdWxMMiwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDJ3M1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtdWxMMiA9IEZyLm11bChtdWxMMiwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDN3M1tpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcHJlTDAgPSBGci5tdWwobXVsTDEsIG11bEwyKTtcbiAgICAgICAgICAgIGxldCBwcmVMMSA9IEZyLm11bChjaGFsbGVuZ2VzLmFscGhhLCBGci5tdWwobXVsTDAsIG11bEwyKSk7XG4gICAgICAgICAgICBsZXQgcHJlTDIgPSBGci5tdWwoRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpLCBGci5tdWwobXVsTDAsIG11bEwxKSk7XG5cbiAgICAgICAgICAgIHRvSW52ZXJzZVtcImRlbkgxXCJdID0gbXVsTDE7XG4gICAgICAgICAgICB0b0ludmVyc2VbXCJkZW5IMlwiXSA9IG11bEwyO1xuXG4gICAgICAgICAgICAvLyBDT01QVVRFIEwoWClcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMwLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwuc3ViU2NhbGFyKGV2YWxSMFkpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuTC5tdWxTY2FsYXIocHJlTDApO1xuXG4gICAgICAgICAgICBsZXQgbDIgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMxLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGwyLnN1YlNjYWxhcihldmFsUjFZKTtcbiAgICAgICAgICAgIGwyLm11bFNjYWxhcihwcmVMMSk7XG5cbiAgICAgICAgICAgIGxldCBsMyA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzIsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgbDMuc3ViU2NhbGFyKGV2YWxSMlkpO1xuICAgICAgICAgICAgbDMubXVsU2NhbGFyKHByZUwyKTtcblxuICAgICAgICAgICAgcG9seW5vbWlhbHMuTC5hZGQobDIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuTC5hZGQobDMpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFpUIHBvbHlub21pYWxcIik7XG4gICAgICAgICAgICBhd2FpdCBjb21wdXRlWlQoKTtcblxuICAgICAgICAgICAgY29uc3QgZXZhbFpUWSA9IHBvbHlub21pYWxzLlpULmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLm11bFNjYWxhcihldmFsWlRZKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwuc3ViKHBvbHlub21pYWxzLkYpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5MLmRlZ3JlZSgpID49IDkgKiB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuTDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVaVCgpIHtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlpUID0gUG9seW5vbWlhbC56ZXJvZmllclBvbHlub21pYWwoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICByb290cy5TMC5oMHc4WzBdLCByb290cy5TMC5oMHc4WzFdLCByb290cy5TMC5oMHc4WzJdLCByb290cy5TMC5oMHc4WzNdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMC5oMHc4WzRdLCByb290cy5TMC5oMHc4WzVdLCByb290cy5TMC5oMHc4WzZdLCByb290cy5TMC5oMHc4WzddLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMS5oMXc0WzBdLCByb290cy5TMS5oMXc0WzFdLCByb290cy5TMS5oMXc0WzJdLCByb290cy5TMS5oMXc0WzNdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oMnczWzBdLCByb290cy5TMi5oMnczWzFdLCByb290cy5TMi5oMnczWzJdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oM3czWzBdLCByb290cy5TMi5oM3czWzFdLCByb290cy5TMi5oM3czWzJdXSwgY3VydmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVpUUzIoKSB7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5aVFMyID0gUG9seW5vbWlhbC56ZXJvZmllclBvbHlub21pYWwoXG4gICAgICAgICAgICAgICAgW3Jvb3RzLlMxLmgxdzRbMF0sIHJvb3RzLlMxLmgxdzRbMV0sIHJvb3RzLlMxLmgxdzRbMl0sIHJvb3RzLlMxLmgxdzRbM10sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMyLmgydzNbMF0sIHJvb3RzLlMyLmgydzNbMV0sIHJvb3RzLlMyLmgydzNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLlMyLmgzdzNbMV0sIHJvb3RzLlMyLmgzdzNbMl1dLCBjdXJ2ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNb250Z29tZXJ5QmF0Y2hlZEludmVyc2UoKSB7XG4gICAgICAgIC8vICAgwrcgZGVub21pbmF0b3IgbmVlZGVkIGluIHN0ZXAgOCBhbmQgOSBvZiB0aGUgdmVyaWZpZXIgdG8gbXVsdGlwbHkgYnkgMS9aX0goeGkpXG4gICAgICAgIGxldCB4aU4gPSBjaGFsbGVuZ2VzLnhpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkucG93ZXI7IGkrKykge1xuICAgICAgICAgICAgeGlOID0gRnIuc3F1YXJlKHhpTik7XG4gICAgICAgIH1cbiAgICAgICAgdG9JbnZlcnNlW1wiemhcIl0gPSBGci5zdWIoeGlOLCBGci5vbmUpO1xuXG4gICAgICAgIC8vICAgwrcgZGVub21pbmF0b3IgbmVlZGVkIGluIHN0ZXAgMTAgYW5kIDExIG9mIHRoZSB2ZXJpZmllclxuICAgICAgICAvLyAgICAgdG9JbnZlcnNlLmRlbkgxICYgdG9JbnZlcnNlLmRlbkgyICAtPiBDb21wdXRlZCBpbiByb3VuZDUsIGNvbXB1dGVMKClcblxuICAgICAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiB0aGUgdmVyaWZpZXIgd2hlbiBjb21wdXRpbmcgTF9pXntTMH0oWCksIExfaV57UzF9KFgpIGFuZCBMX2lee1MyfShYKVxuICAgICAgICBjb21wdXRlTGlTMCh0b0ludmVyc2UsIHJvb3RzLlMwLmgwdzgsIGNoYWxsZW5nZXMueSwgY3VydmUpO1xuXG4gICAgICAgIGNvbXB1dGVMaVMxKHRvSW52ZXJzZSwgcm9vdHMuUzEuaDF3NCwgY2hhbGxlbmdlcy55LCBjdXJ2ZSk7XG5cbiAgICAgICAgY29tcHV0ZUxpUzIodG9JbnZlcnNlLCByb290cy5TMi5oMnczLCByb290cy5TMi5oM3czLCBjaGFsbGVuZ2VzLnksIGNoYWxsZW5nZXMueGksIGNoYWxsZW5nZXMueGl3LCBjdXJ2ZSk7XG5cbiAgICAgICAgLy8gICDCtyBMX2kgaT0xIHRvIG51bSBwdWJsaWMgaW5wdXRzLCBuZWVkZWQgaW4gc3RlcCA2IGFuZCA3IG9mIHRoZSB2ZXJpZmllciB0byBjb21wdXRlIExfMSh4aSkgYW5kIFBJKHhpKVxuICAgICAgICBjb25zdCBzaXplID0gTWF0aC5tYXgoMSwgemtleS5uUHVibGljKTtcblxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRvSW52ZXJzZVtcIkxpX1wiICsgKGkgKyAxKV0gPSBGci5tdWwoRnIuZSh6a2V5LmRvbWFpblNpemUpLCBGci5zdWIoY2hhbGxlbmdlcy54aSwgdykpO1xuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtdWxBY2N1bXVsYXRvciA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIE9iamVjdC52YWx1ZXModG9JbnZlcnNlKSkge1xuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViRWxlbWVudCBvZiBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG11bEFjY3VtdWxhdG9yID0gRnIubXVsKG11bEFjY3VtdWxhdG9yLCBzdWJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG11bEFjY3VtdWxhdG9yID0gRnIubXVsKG11bEFjY3VtdWxhdG9yLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnIuaW52KG11bEFjY3VtdWxhdG9yKTtcblxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUxpUzAodG9JbnZlcnNlLCByb290cywgeCwgY3VydmUpIHtcbiAgICAgICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSByb290cy5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZGVuMSA9IEZyLm11bChGci5lKGxlbiksIEZyLmV4cChyb290c1swXSwgbGVuIC0gMikpO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IExpID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWygobGVuIC0gMSkgKiBpKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih4LCByb290c1tpXSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHRvSW52ZXJzZVtbXCJMaVMwX1wiICsgKGkgKyAxKV1dID0gRnIubXVsKEZyLm11bChkZW4xLCBkZW4yKSwgZGVuMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIExpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUxpUzEodG9JbnZlcnNlLCByb290cywgeCwgY3VydmUpIHtcbiAgICAgICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSByb290cy5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZGVuMSA9IEZyLm11bChGci5lKGxlbiksIEZyLmV4cChyb290c1swXSwgbGVuIC0gMikpO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IExpID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWygobGVuIC0gMSkgKiBpKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih4LCByb290c1tpXSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHRvSW52ZXJzZVtbXCJMaVMxX1wiICsgKGkgKyAxKV1dID0gRnIubXVsKEZyLm11bChkZW4xLCBkZW4yKSwgZGVuMyk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gTGk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTGlTMih0b0ludmVyc2UsIFMyLCBTMnAsIHZhbHVlLCB4aSwgeGl3LCBjdXJ2ZSkge1xuICAgICAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBMaSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IF8zaDIgPSBGci5tdWwoRnIuZSgzKSwgUzJbMF0pO1xuICAgICAgICAgICAgY29uc3QgeGlzdWJ4aXcgPSBGci5zdWIoeGksIHhpdyk7XG4gICAgICAgICAgICBsZXQgZGVuMSA9IEZyLm11bChfM2gyLCB4aXN1Ynhpdyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjIgPSBTMlsyICogaSAlIDNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjMgPSBGci5zdWIodmFsdWUsIFMyW2ldKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgdG9JbnZlcnNlW1tcIkxpUzJfXCIgKyAoaSArIDEpXV0gPSBGci5tdWwoZGVuMSxGci5tdWwoZGVuMiwgZGVuMykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IF8zaDMgPSBGci5tdWwoRnIuZSgzKSwgUzJwWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHhpd3N1YnhpID0gRnIuc3ViKHhpdywgeGkpO1xuICAgICAgICAgICAgZGVuMSA9IEZyLm11bChfM2gzLCB4aXdzdWJ4aSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjIgPSBTMnBbMiAqIGkgJSAzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHZhbHVlLCBTMnBbaV0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICB0b0ludmVyc2VbW1wiTGlTMl9cIiArIChpICsgMSArIDMpXV0gPSBGci5tdWwoZGVuMSxGci5tdWwoZGVuMiwgZGVuMykpOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gTGk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/fflonk_prove.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/fflonk_setup.js":
/*!**************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_setup.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkSetup)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(rsc)/./node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bigarray.js */ \"(rsc)/./node_modules/snarkjs/src/bigarray.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk_constants.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zkey_constants.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plonk_equation.js */ \"(rsc)/./node_modules/snarkjs/src/plonk_equation.js\");\n/* harmony import */ var _r1cs_constraint_processor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./r1cs_constraint_processor.js */ \"(rsc)/./node_modules/snarkjs/src/r1cs_constraint_processor.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(rsc)/./node_modules/snarkjs/src/polynomial/polynomial.js\");\n/* harmony import */ var _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./polynomial/evaluations.js */ \"(rsc)/./node_modules/snarkjs/src/polynomial/evaluations.js\");\n/* harmony import */ var _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./polynomial/cpolynomial.js */ \"(rsc)/./node_modules/snarkjs/src/polynomial/cpolynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nasync function fflonkSetup(r1csFilename, ptauFilename, zkeyFilename, logger) {\n    if (logger) logger.info(\"FFLONK SETUP STARTED\");\n\n    if (globalThis.gc) globalThis.gc();\n\n    // Read PTau file\n    if (logger) logger.info(\"> Reading PTau file\");\n    const {fd: fdPTau, sections: pTauSections} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauFilename, \"ptau\", 1, 1 << 22, 1 << 24);\n    if (!pTauSections[12]) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 12 missing.\");\n    }\n\n    // Get curve defined in PTau\n    if (logger) logger.info(\"> Getting curve from PTau settings\");\n    const {curve} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, pTauSections);\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csFd)(fdR1cs, sectionsR1cs, {loadConstraints: false, loadCustomGates: true});\n\n    // Potential error checks\n    if (r1cs.prime !== curve.r) {\n        throw new Error(\"r1cs curve does not match powers of tau ceremony curve\");\n    }\n\n    // Initializations\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sG2 = curve.G2.F.n8 * 2;\n\n    let polynomials = {};\n    let evaluations = {};\n    let PTau;\n\n    let settings = {\n        nVars: r1cs.nVars,\n        nPublic: r1cs.nOutputs + r1cs.nPubInputs\n    };\n\n    const plonkConstraints = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n    let plonkAdditions = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n\n    // Process constraints inside r1cs\n    if (logger) logger.info(\"> Processing FFlonk constraints\");\n    await computeFFConstraints(curve.Fr, r1cs, logger);\n    if (globalThis.gc) globalThis.gc();\n\n    // As the t polynomial is n+5 we need at least a power of 4\n    //TODO check!!!!\n    // NOTE : plonkConstraints + 2 = #constraints + blinding coefficients for each wire polynomial\n    settings.cirPower = Math.max(_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.FF_T_POL_DEG_MIN, (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)((plonkConstraints.length + 2) - 1) + 1);\n    settings.domainSize = 2 ** settings.cirPower;\n\n    if (pTauSections[2][0].size < (settings.domainSize * 9 + 18) * sG1) {\n        throw new Error(\"Powers of Tau is not big enough for this circuit size. Section 2 too small.\");\n    }\n    if (pTauSections[3][0].size < sG2) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 3 too small.\");\n    }\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK SETUP SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${settings.cirPower}`);\n        logger.info(`  Domain size:   ${settings.domainSize}`);\n        logger.info(`  Vars:          ${settings.nVars}`);\n        logger.info(`  Public vars:   ${settings.nPublic}`);\n        logger.info(`  Constraints:   ${plonkConstraints.length}`);\n        logger.info(`  Additions:     ${plonkAdditions.length}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // Compute k1 and k2 to be used in the permutation checks\n    if (logger) logger.info(\"> computing k1 and k2\");\n    const [k1, k2] = computeK1K2();\n\n    // Compute omega 3 (w3) and omega 4 (w4) to be used in the prover and the verifier\n    // w3^3 = 1 and  w4^4 = 1\n    if (logger) logger.info(\"> computing w3\");\n    const w3 = computeW3();\n    if (logger) logger.info(\"> computing w4\");\n    const w4 = computeW4();\n    if (logger) logger.info(\"> computing w8\");\n    const w8 = computeW8();\n    if (logger) logger.info(\"> computing wr\");\n    const wr = getOmegaCubicRoot(settings.cirPower, curve.Fr);\n\n    // Write output zkey file\n    await writeZkeyFile();\n\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"FFLONK SETUP FINISHED\");\n\n    return 0;\n\n    async function computeFFConstraints(Fr, r1cs, logger) {\n        // Add public inputs and outputs\n        for (let i = 0; i < settings.nPublic; i++) {\n            plonkConstraints.push((0,_plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkConstantConstraint)(i + 1, Fr));\n        }\n\n        // Add all constraints from r1cs file\n        const r1csProcessor = new _r1cs_constraint_processor_js__WEBPACK_IMPORTED_MODULE_9__.r1csConstraintProcessor(Fr, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkConstantConstraint, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkAdditionConstraint, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkMultiplicationConstraint, logger);\n\n        const bR1cs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection(fdR1cs, sectionsR1cs, 2);\n        let bR1csPos = 0;\n        for (let i = 0; i < r1cs.nConstraints; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`    processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n            }\n            const [constraints, additions] = r1csProcessor.processR1csConstraint(settings, ...readConstraint());\n\n            plonkConstraints.push(...constraints);\n            plonkAdditions.push(...additions);\n        }\n\n        function readConstraint() {\n            const c = [];\n            c[0] = readLC();\n            c[1] = readLC();\n            c[2] = readLC();\n            return c;\n        }\n\n        function readLC() {\n            const lc = {};\n\n            const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n            bR1csPos += 4;\n            const buffUL32V = new DataView(buffUL32.buffer);\n            const nIdx = buffUL32V.getUint32(0, true);\n\n            const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n            bR1csPos += (4 + r1cs.n8) * nIdx;\n            const buffV = new DataView(buff.buffer);\n            for (let i = 0; i < nIdx; i++) {\n                const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n                const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n                lc[idx] = val;\n            }\n            return lc;\n        }\n\n        return 0;\n    }\n\n    async function writeZkeyFile() {\n        if (logger) logger.info(\"> Writing the zkey file\");\n        const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyFilename, \"zkey\", 1, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_NSECTIONS, 1 << 22, 1 << 24);\n\n        if (logger) logger.info(` Writing Section ${_zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.HEADER_ZKEY_SECTION}. Zkey Header`);\n        await writeZkeyHeader(fdZKey);\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n        await writeAdditions(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_A_MAP_SECTION}. A Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_A_MAP_SECTION, 0, \"A map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_B_MAP_SECTION}. B Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_B_MAP_SECTION, 1, \"B map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C_MAP_SECTION}. C Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C_MAP_SECTION, 2, \"C map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QL_SECTION}. QL`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QL_SECTION, 3, \"QL\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QR_SECTION}. QR`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QR_SECTION, 4, \"QR\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QM_SECTION}. QM`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QM_SECTION, 5, \"QM\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QO_SECTION}. QO`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QO_SECTION, 6, \"QO\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QC_SECTION}. QC`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QC_SECTION, 7, \"QC\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA1_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA2_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n        await writeSigma(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_LAGRANGE_SECTION}. Lagrange Polynomials`);\n        await writeLagrangePolynomials(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n        await writePtau(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C0_SECTION}. C0`);\n        await writeC0(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_HEADER_SECTION}. FFlonk Header`);\n        await writeFFlonkHeader(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(\"> Writing the zkey file finished\");\n\n        await fdZKey.close();\n    }\n\n    async function writeZkeyHeader(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.HEADER_ZKEY_SECTION);\n        await fdZKey.writeULE32(_zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.FFLONK_PROTOCOL_ID);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeAdditions(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_ADDITIONS_SECTION);\n\n        // Written values are 2 * 32 bit integers (2 * 4 bytes) + 2 field size values ( 2 * sFr bytes)\n        const buffOut = new Uint8Array(8 + 2 * sFr);\n        const buffOutV = new DataView(buffOut.buffer);\n\n        for (let i = 0; i < plonkAdditions.length; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing Additions: ${i}/${plonkAdditions.length}`);\n\n            const addition = plonkAdditions[i];\n\n            buffOutV.setUint32(0, addition[0], true);\n            buffOutV.setUint32(4, addition[1], true);\n            buffOut.set(addition[2], 8);\n            buffOut.set(addition[3], 8 + sFr);\n\n            await fdZKey.write(buffOut);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeWitnessMap(fdZKey, sectionNum, posConstraint, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            if (logger && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing witness ${name}: ${i}/${plonkConstraints.length}`);\n            }\n\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeQMap(fdZKey, sectionNum, posConstraint, name) {\n        // Compute Q from q evaluations\n        let Q = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(settings.domainSize * sFr);\n\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i * sFr);\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing ${name}: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        polynomials[name] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.fromEvaluations(Q, curve, logger);\n        evaluations[name] = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__.Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n\n        // Write Q coefficients and evaluations\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        await fdZKey.write(polynomials[name].coef);\n        await fdZKey.write(evaluations[name].eval);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeSigma(fdZKey) {\n        // Compute sigma\n        const sigma = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(sFr * settings.domainSize * 3);\n        const lastSeen = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](settings.nVars);\n        const firstPos = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](settings.nVars);\n\n        let w = Fr.one;\n        for (let i = 0; i < settings.domainSize; i++) {\n            if (i < plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], settings.domainSize + i);\n                buildSigma(plonkConstraints[i][2], settings.domainSize * 2 + i);\n            } else if (i < settings.domainSize - 2) {\n                buildSigma(0, i);\n                buildSigma(0, settings.domainSize + i);\n                buildSigma(0, settings.domainSize * 2 + i);\n            } else {\n                sigma.set(w, i * sFr);\n                sigma.set(Fr.mul(w, k1), (settings.domainSize + i) * sFr);\n                sigma.set(Fr.mul(w, k2), (settings.domainSize * 2 + i) * sFr);\n            }\n\n            w = Fr.mul(w, Fr.w[settings.cirPower]);\n\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing sigma phase1: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        for (let i = 0; i < settings.nVars; i++) {\n            if (typeof firstPos[i] !== \"undefined\") {\n                sigma.set(lastSeen[i], firstPos[i] * sFr);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing sigma phase2: ${i}/${settings.nVars}`);\n        }\n\n        if (globalThis.gc) globalThis.gc();\n\n        // Write sigma coefficients and evaluations\n        for (let i = 0; i < 3; i++) {\n            const sectionId = 0 === i ? _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA1_SECTION : 1 === i ? _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA2_SECTION : _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA3_SECTION;\n\n            let name = \"S\" + (i + 1);\n            polynomials[name] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.fromEvaluations(sigma.slice(settings.domainSize * sFr * i, settings.domainSize * sFr * (i + 1)), curve, logger);\n            evaluations[name] = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__.Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n            await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionId);\n            await fdZKey.write(polynomials[name].coef);\n            await fdZKey.write(evaluations[name].eval);\n            await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n            if (globalThis.gc) globalThis.gc();\n        }\n\n        return 0;\n\n        function buildSigma(signalId, idx) {\n            if (typeof lastSeen[signalId] === \"undefined\") {\n                firstPos[signalId] = idx;\n            } else {\n                sigma.set(lastSeen[signalId], idx * sFr);\n            }\n            let v;\n            if (idx < settings.domainSize) {\n                v = w;\n            } else if (idx < 2 * settings.domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n\n            lastSeen[signalId] = v;\n        }\n    }\n\n    async function writeLagrangePolynomials(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_LAGRANGE_SECTION);\n\n        const l = Math.max(settings.nPublic, 1);\n        for (let i = 0; i < l; i++) {\n            let buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(settings.domainSize * sFr);\n            buff.set(Fr.one, i * sFr);\n\n            await writeP4(fdZKey, buff);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writePtau(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_PTAU_SECTION);\n\n        // domainSize * 9 + 18 = maximum SRS length needed, specifically to commit C2\n        PTau = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((settings.domainSize * 9 + 18) * sG1);\n        await fdPTau.readToBuffer(PTau, 0, (settings.domainSize * 9 + 18) * sG1, pTauSections[2][0].p);\n\n        await fdZKey.write(PTau);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeC0(fdZKey) {\n        // C0(X) := QL(X^8) + X  QR(X^8) + X^2  QO(X^8) + X^3  QM(X^8) + X^4  QC(X^8)\n        //            + X^5  SIGMA1(X^8) + X^6  SIGMA2(X^8) + X^7  SIGMA3(X^8)\n        let C0 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_12__.CPolynomial(8, curve, logger);\n        C0.addPolynomial(0, polynomials.QL);\n        C0.addPolynomial(1, polynomials.QR);\n        C0.addPolynomial(2, polynomials.QO);\n        C0.addPolynomial(3, polynomials.QM);\n        C0.addPolynomial(4, polynomials.QC);\n        C0.addPolynomial(5, polynomials.S1);\n        C0.addPolynomial(6, polynomials.S2);\n        C0.addPolynomial(7, polynomials.S3);\n\n        polynomials.C0 = C0.getPolynomial();\n\n        // Check degree\n        if (polynomials.C0.degree() >= 8 * settings.domainSize) {\n            throw new Error(\"C0 Polynomial is not well calculated\");\n        }\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C0_SECTION);\n        await fdZKey.write(polynomials.C0.coef);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeFFlonkHeader(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_HEADER_SECTION);\n\n        const primeQ = curve.q;\n        const n8q = (Math.floor((ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n\n        const primeR = curve.r;\n        const n8r = (Math.floor((ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8r);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n\n        // Total number of r1cs vars\n        await fdZKey.writeULE32(settings.nVars);\n        // Total number of r1cs public vars = outputs + public inputs\n        await fdZKey.writeULE32(settings.nPublic);\n        await fdZKey.writeULE32(settings.domainSize);\n        await fdZKey.writeULE32(plonkAdditions.length);\n        await fdZKey.writeULE32(plonkConstraints.length);\n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(w3);\n        await fdZKey.write(w4);\n        await fdZKey.write(w8);\n        await fdZKey.write(wr);\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, pTauSections[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        let commitC0 = await polynomials.C0.multiExponentiation(PTau, \"C0\");\n        await fdZKey.write(commitC0);\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeP4(fdZKey, buff) {\n        const [coefficients, evaluations4] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.to4T(buff, settings.domainSize, [], Fr);\n        await fdZKey.write(coefficients);\n        await fdZKey.write(evaluations4);\n\n        return [coefficients, evaluations4];\n    }\n\n    function computeK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], settings.cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], settings.cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize = 2 ** pow;\n            let w = Fr.one;\n            for (let i = 0; i < domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j = 0; j < kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n\n    function computeW3() {\n        let generator = Fr.e(31624);\n\n        // Exponent is order(r - 1) / 3\n        let orderRsub1 = 3648040478639879203707734290876212514758060733402672390616367364429301415936n;\n        let exponent = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.div(orderRsub1, ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.e(3));\n\n        return Fr.exp(generator, exponent);\n    }\n\n    function computeW4() {\n        return Fr.w[2];\n    }\n\n    function computeW8() {\n        return Fr.w[3];\n    }\n\n    function getOmegaCubicRoot(power, Fr) {\n        // Hardcorded 3th-root of Fr.w[28]\n        const firstRoot = Fr.e(467799165886069610036046866799264026481344299079011762026774533774345988080n);\n\n        return Fr.exp(firstRoot, 2 ** (28 - power));\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3NldHVwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDWTtBQUNpRTtBQUNsRjtBQUNnQjtBQUNWO0FBb0JOO0FBQzZDO0FBSy9DO0FBQzBDO0FBQ2pCO0FBQ0Y7QUFDSTtBQUNBOzs7QUFHekM7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvQ0FBb0MsUUFBUSxnRUFBVztBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTyxRQUFRLGlFQUFvQjs7QUFFOUM7QUFDQTtBQUNBLFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7QUFDbEUsdUJBQXVCLG9EQUFVLHdCQUF3Qiw4Q0FBOEM7O0FBRXZHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsb0RBQVE7QUFDekMsNkJBQTZCLG9EQUFROztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0VBQWdCLEVBQUUsOENBQUk7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25ELHdDQUF3QyxrQkFBa0I7QUFDMUQsd0NBQXdDLG9CQUFvQjtBQUM1RCx3Q0FBd0MsZUFBZTtBQUN2RCx3Q0FBd0MsaUJBQWlCO0FBQ3pELHdDQUF3Qyx3QkFBd0I7QUFDaEUsd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUMsa0NBQWtDLCtFQUEyQjtBQUM3RDs7QUFFQTtBQUNBLGtDQUFrQyxrRkFBdUIsS0FBSywyRUFBMkIsRUFBRSwyRUFBMkIsRUFBRSxpRkFBaUM7O0FBRXpKLDRCQUE0Qiw0REFBd0I7QUFDcEQ7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0EsK0RBQStELEVBQUUsR0FBRyxrQkFBa0I7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGtFQUFhLDBCQUEwQixtRUFBaUI7O0FBRXJGLHVEQUF1RCxtRUFBbUIsQ0FBQztBQUMzRTs7QUFFQSx1REFBdUQsMkVBQXlCLENBQUM7QUFDakY7QUFDQTs7QUFFQSx1REFBdUQsdUVBQXFCLENBQUM7QUFDN0Usc0NBQXNDLHVFQUFxQjtBQUMzRDs7QUFFQSx1REFBdUQsdUVBQXFCLENBQUM7QUFDN0Usc0NBQXNDLHVFQUFxQjtBQUMzRDs7QUFFQSx1REFBdUQsdUVBQXFCLENBQUM7QUFDN0Usc0NBQXNDLHVFQUFxQjtBQUMzRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx3REFBd0Qsd0VBQXNCLENBQUMsR0FBRyx3RUFBc0IsQ0FBQyxHQUFHLHdFQUFzQixDQUFDO0FBQ25JO0FBQ0E7O0FBRUEsdURBQXVELDBFQUF3QixDQUFDO0FBQ2hGO0FBQ0E7O0FBRUEsdURBQXVELHNFQUFvQixDQUFDO0FBQzVFO0FBQ0E7O0FBRUEsdURBQXVELG9FQUFrQixDQUFDO0FBQzFFO0FBQ0E7O0FBRUEsdURBQXVELHdFQUFzQixDQUFDO0FBQzlFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsbUVBQW1CO0FBQzNELGdDQUFnQyxrRUFBa0I7QUFDbEQsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsMkVBQXlCOztBQUVqRTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDJCQUEyQjtBQUNuRCxxR0FBcUcsRUFBRSxHQUFHLHNCQUFzQjs7QUFFaEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQix3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0EscURBQXFELEtBQUssSUFBSSxFQUFFLEdBQUcsd0JBQXdCO0FBQzNGOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVM7O0FBRTdCLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBLDZDQUE2QyxLQUFLLElBQUksRUFBRSxHQUFHLHdCQUF3QjtBQUNuRjtBQUNBOztBQUVBLGtDQUFrQyxrRUFBVTtBQUM1QyxrQ0FBa0Msb0VBQVc7O0FBRTdDO0FBQ0EsY0FBYyxzRUFBaUI7QUFDL0I7QUFDQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixtREFBUztBQUNuQyw2QkFBNkIsb0RBQVE7QUFDckMsNkJBQTZCLG9EQUFROztBQUVyQztBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkRBQTJELEVBQUUsR0FBRyx3QkFBd0I7QUFDeEY7QUFDQTs7QUFFQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLEVBQUUsR0FBRyxlQUFlO0FBQzVIOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0Isd0NBQXdDLHdFQUFzQixhQUFhLHdFQUFzQixHQUFHLHdFQUFzQjs7QUFFMUg7QUFDQSxzQ0FBc0Msa0VBQVU7QUFDaEQsc0NBQXNDLG9FQUFXO0FBQ2pELGtCQUFrQixzRUFBaUI7QUFDbkM7QUFDQTtBQUNBLGtCQUFrQixvRUFBZTs7QUFFakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsMEVBQXdCOztBQUVoRTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLDJCQUEyQixtREFBUztBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsc0VBQW9COztBQUU1RDtBQUNBLG1CQUFtQixtREFBUztBQUM1Qjs7QUFFQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxzRUFBaUIsU0FBUyxvRUFBa0I7QUFDMUQ7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0EsY0FBYyxzRUFBaUIsU0FBUyx3RUFBc0I7O0FBRTlEO0FBQ0EsaUNBQWlDLGdEQUFNO0FBQ3ZDO0FBQ0EsY0FBYyxnRUFBVzs7QUFFekI7QUFDQSxpQ0FBaUMsZ0RBQU07QUFDdkM7QUFDQSxjQUFjLGdFQUFXOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQSxtREFBbUQsa0VBQVU7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQU0saUJBQWlCLGdEQUFNOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfc2V0dXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHtyZWFkUjFjc0ZkfSBmcm9tIFwicjFjc2ZpbGVcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQge2NyZWF0ZUJpbkZpbGUsIGVuZFdyaXRlU2VjdGlvbiwgcmVhZEJpbkZpbGUsIHN0YXJ0V3JpdGVTZWN0aW9uLCB3cml0ZUJpZ0ludCx9IGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQge2xvZzJ9IGZyb20gXCIuL21pc2MuanNcIjtcbmltcG9ydCB7QmlnQnVmZmVyLCBTY2FsYXJ9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCBCaWdBcnJheSBmcm9tIFwiLi9iaWdhcnJheS5qc1wiO1xuaW1wb3J0IHtcbiAgICBaS0VZX0ZGX0hFQURFUl9TRUNUSU9OLFxuICAgIFpLRVlfRkZfQURESVRJT05TX1NFQ1RJT04sXG4gICAgWktFWV9GRl9BX01BUF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfQl9NQVBfU0VDVElPTixcbiAgICBaS0VZX0ZGX0NfTUFQX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RTF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfUVJfU0VDVElPTixcbiAgICBaS0VZX0ZGX1FNX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RT19TRUNUSU9OLFxuICAgIFpLRVlfRkZfUUNfU0VDVElPTixcbiAgICBaS0VZX0ZGX1NJR01BMV9TRUNUSU9OLFxuICAgIFpLRVlfRkZfU0lHTUEyX1NFQ1RJT04sXG4gICAgWktFWV9GRl9TSUdNQTNfU0VDVElPTixcbiAgICBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04sXG4gICAgWktFWV9GRl9QVEFVX1NFQ1RJT04sXG4gICAgRkZfVF9QT0xfREVHX01JTixcbiAgICBaS0VZX0ZGX05TRUNUSU9OUyxcbiAgICBaS0VZX0ZGX0MwX1NFQ1RJT04sXG59IGZyb20gXCIuL2ZmbG9ua19jb25zdGFudHMuanNcIjtcbmltcG9ydCB7RkZMT05LX1BST1RPQ09MX0lELCBIRUFERVJfWktFWV9TRUNUSU9OfSBmcm9tIFwiLi96a2V5X2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHtcbiAgICBnZXRGRmxvbmtBZGRpdGlvbkNvbnN0cmFpbnQsXG4gICAgZ2V0RkZsb25rQ29uc3RhbnRDb25zdHJhaW50LFxuICAgIGdldEZGbG9ua011bHRpcGxpY2F0aW9uQ29uc3RyYWludFxufSBmcm9tIFwiLi9wbG9ua19lcXVhdGlvbi5qc1wiO1xuaW1wb3J0IHtyMWNzQ29uc3RyYWludFByb2Nlc3Nvcn0gZnJvbSBcIi4vcjFjc19jb25zdHJhaW50X3Byb2Nlc3Nvci5qc1wiO1xuaW1wb3J0IHtQb2x5bm9taWFsfSBmcm9tIFwiLi9wb2x5bm9taWFsL3BvbHlub21pYWwuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0IHtFdmFsdWF0aW9uc30gZnJvbSBcIi4vcG9seW5vbWlhbC9ldmFsdWF0aW9ucy5qc1wiO1xuaW1wb3J0IHtDUG9seW5vbWlhbH0gZnJvbSBcIi4vcG9seW5vbWlhbC9jcG9seW5vbWlhbC5qc1wiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZmbG9ua1NldHVwKHIxY3NGaWxlbmFtZSwgcHRhdUZpbGVuYW1lLCB6a2V5RmlsZW5hbWUsIGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFNFVFVQIFNUQVJURURcIik7XG5cbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUmVhZCBQVGF1IGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyBQVGF1IGZpbGVcIik7XG4gICAgY29uc3Qge2ZkOiBmZFBUYXUsIHNlY3Rpb25zOiBwVGF1U2VjdGlvbnN9ID0gYXdhaXQgcmVhZEJpbkZpbGUocHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSwgMSA8PCAyMiwgMSA8PCAyNCk7XG4gICAgaWYgKCFwVGF1U2VjdGlvbnNbMTJdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VycyBvZiBUYXUgaXMgbm90IHdlbGwgcHJlcGFyZWQuIFNlY3Rpb24gMTIgbWlzc2luZy5cIik7XG4gICAgfVxuXG4gICAgLy8gR2V0IGN1cnZlIGRlZmluZWQgaW4gUFRhdVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBHZXR0aW5nIGN1cnZlIGZyb20gUFRhdSBzZXR0aW5nc1wiKTtcbiAgICBjb25zdCB7Y3VydmV9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRQVGF1LCBwVGF1U2VjdGlvbnMpO1xuXG4gICAgLy8gUmVhZCByMWNzIGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyByMWNzIGZpbGVcIik7XG4gICAgY29uc3Qge2ZkOiBmZFIxY3MsIHNlY3Rpb25zOiBzZWN0aW9uc1IxY3N9ID0gYXdhaXQgcmVhZEJpbkZpbGUocjFjc0ZpbGVuYW1lLCBcInIxY3NcIiwgMSwgMSA8PCAyMiwgMSA8PCAyNCk7XG4gICAgY29uc3QgcjFjcyA9IGF3YWl0IHJlYWRSMWNzRmQoZmRSMWNzLCBzZWN0aW9uc1IxY3MsIHtsb2FkQ29uc3RyYWludHM6IGZhbHNlLCBsb2FkQ3VzdG9tR2F0ZXM6IHRydWV9KTtcblxuICAgIC8vIFBvdGVudGlhbCBlcnJvciBjaGVja3NcbiAgICBpZiAocjFjcy5wcmltZSAhPT0gY3VydmUucikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyMWNzIGN1cnZlIGRvZXMgbm90IG1hdGNoIHBvd2VycyBvZiB0YXUgY2VyZW1vbnkgY3VydmVcIik7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6YXRpb25zXG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IHNGciA9IGN1cnZlLkZyLm44O1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjggKiAyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjggKiAyO1xuXG4gICAgbGV0IHBvbHlub21pYWxzID0ge307XG4gICAgbGV0IGV2YWx1YXRpb25zID0ge307XG4gICAgbGV0IFBUYXU7XG5cbiAgICBsZXQgc2V0dGluZ3MgPSB7XG4gICAgICAgIG5WYXJzOiByMWNzLm5WYXJzLFxuICAgICAgICBuUHVibGljOiByMWNzLm5PdXRwdXRzICsgcjFjcy5uUHViSW5wdXRzXG4gICAgfTtcblxuICAgIGNvbnN0IHBsb25rQ29uc3RyYWludHMgPSBuZXcgQmlnQXJyYXkoKTtcbiAgICBsZXQgcGxvbmtBZGRpdGlvbnMgPSBuZXcgQmlnQXJyYXkoKTtcblxuICAgIC8vIFByb2Nlc3MgY29uc3RyYWludHMgaW5zaWRlIHIxY3NcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUHJvY2Vzc2luZyBGRmxvbmsgY29uc3RyYWludHNcIik7XG4gICAgYXdhaXQgY29tcHV0ZUZGQ29uc3RyYWludHMoY3VydmUuRnIsIHIxY3MsIGxvZ2dlcik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIC8vIEFzIHRoZSB0IHBvbHlub21pYWwgaXMgbis1IHdlIG5lZWQgYXQgbGVhc3QgYSBwb3dlciBvZiA0XG4gICAgLy9UT0RPIGNoZWNrISEhIVxuICAgIC8vIE5PVEUgOiBwbG9ua0NvbnN0cmFpbnRzICsgMiA9ICNjb25zdHJhaW50cyArIGJsaW5kaW5nIGNvZWZmaWNpZW50cyBmb3IgZWFjaCB3aXJlIHBvbHlub21pYWxcbiAgICBzZXR0aW5ncy5jaXJQb3dlciA9IE1hdGgubWF4KEZGX1RfUE9MX0RFR19NSU4sIGxvZzIoKHBsb25rQ29uc3RyYWludHMubGVuZ3RoICsgMikgLSAxKSArIDEpO1xuICAgIHNldHRpbmdzLmRvbWFpblNpemUgPSAyICoqIHNldHRpbmdzLmNpclBvd2VyO1xuXG4gICAgaWYgKHBUYXVTZWN0aW9uc1syXVswXS5zaXplIDwgKHNldHRpbmdzLmRvbWFpblNpemUgKiA5ICsgMTgpICogc0cxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VycyBvZiBUYXUgaXMgbm90IGJpZyBlbm91Z2ggZm9yIHRoaXMgY2lyY3VpdCBzaXplLiBTZWN0aW9uIDIgdG9vIHNtYWxsLlwiKTtcbiAgICB9XG4gICAgaWYgKHBUYXVTZWN0aW9uc1szXVswXS5zaXplIDwgc0cyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VycyBvZiBUYXUgaXMgbm90IHdlbGwgcHJlcGFyZWQuIFNlY3Rpb24gMyB0b28gc21hbGwuXCIpO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIiAgRkZMT05LIFNFVFVQIFNFVFRJTkdTXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXJ2ZTogICAgICAgICAke2N1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENpcmN1aXQgcG93ZXI6ICR7c2V0dGluZ3MuY2lyUG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIERvbWFpbiBzaXplOiAgICR7c2V0dGluZ3MuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgVmFyczogICAgICAgICAgJHtzZXR0aW5ncy5uVmFyc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHVibGljIHZhcnM6ICAgJHtzZXR0aW5ncy5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDb25zdHJhaW50czogICAke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBBZGRpdGlvbnM6ICAgICAke3Bsb25rQWRkaXRpb25zLmxlbmd0aH1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgazEgYW5kIGsyIHRvIGJlIHVzZWQgaW4gdGhlIHBlcm11dGF0aW9uIGNoZWNrc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBjb21wdXRpbmcgazEgYW5kIGsyXCIpO1xuICAgIGNvbnN0IFtrMSwgazJdID0gY29tcHV0ZUsxSzIoKTtcblxuICAgIC8vIENvbXB1dGUgb21lZ2EgMyAodzMpIGFuZCBvbWVnYSA0ICh3NCkgdG8gYmUgdXNlZCBpbiB0aGUgcHJvdmVyIGFuZCB0aGUgdmVyaWZpZXJcbiAgICAvLyB3M14zID0gMSBhbmQgIHc0XjQgPSAxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyB3M1wiKTtcbiAgICBjb25zdCB3MyA9IGNvbXB1dGVXMygpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBjb21wdXRpbmcgdzRcIik7XG4gICAgY29uc3QgdzQgPSBjb21wdXRlVzQoKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gY29tcHV0aW5nIHc4XCIpO1xuICAgIGNvbnN0IHc4ID0gY29tcHV0ZVc4KCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyB3clwiKTtcbiAgICBjb25zdCB3ciA9IGdldE9tZWdhQ3ViaWNSb290KHNldHRpbmdzLmNpclBvd2VyLCBjdXJ2ZS5Gcik7XG5cbiAgICAvLyBXcml0ZSBvdXRwdXQgemtleSBmaWxlXG4gICAgYXdhaXQgd3JpdGVaa2V5RmlsZSgpO1xuXG4gICAgYXdhaXQgZmRSMWNzLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRQVGF1LmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBTRVRVUCBGSU5JU0hFRFwiKTtcblxuICAgIHJldHVybiAwO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUZGQ29uc3RyYWludHMoRnIsIHIxY3MsIGxvZ2dlcikge1xuICAgICAgICAvLyBBZGQgcHVibGljIGlucHV0cyBhbmQgb3V0cHV0c1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLm5QdWJsaWM7IGkrKykge1xuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKGdldEZGbG9ua0NvbnN0YW50Q29uc3RyYWludChpICsgMSwgRnIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBhbGwgY29uc3RyYWludHMgZnJvbSByMWNzIGZpbGVcbiAgICAgICAgY29uc3QgcjFjc1Byb2Nlc3NvciA9IG5ldyByMWNzQ29uc3RyYWludFByb2Nlc3NvcihGciwgZ2V0RkZsb25rQ29uc3RhbnRDb25zdHJhaW50LCBnZXRGRmxvbmtBZGRpdGlvbkNvbnN0cmFpbnQsIGdldEZGbG9ua011bHRpcGxpY2F0aW9uQ29uc3RyYWludCwgbG9nZ2VyKTtcblxuICAgICAgICBjb25zdCBiUjFjcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFIxY3MsIHNlY3Rpb25zUjFjcywgMik7XG4gICAgICAgIGxldCBiUjFjc1BvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjFjcy5uQ29uc3RyYWludHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhgICAgIHByb2Nlc3NpbmcgcjFjcyBjb25zdHJhaW50cyAke2l9LyR7cjFjcy5uQ29uc3RyYWludHN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbY29uc3RyYWludHMsIGFkZGl0aW9uc10gPSByMWNzUHJvY2Vzc29yLnByb2Nlc3NSMWNzQ29uc3RyYWludChzZXR0aW5ncywgLi4ucmVhZENvbnN0cmFpbnQoKSk7XG5cbiAgICAgICAgICAgIHBsb25rQ29uc3RyYWludHMucHVzaCguLi5jb25zdHJhaW50cyk7XG4gICAgICAgICAgICBwbG9ua0FkZGl0aW9ucy5wdXNoKC4uLmFkZGl0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkQ29uc3RyYWludCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBbXTtcbiAgICAgICAgICAgIGNbMF0gPSByZWFkTEMoKTtcbiAgICAgICAgICAgIGNbMV0gPSByZWFkTEMoKTtcbiAgICAgICAgICAgIGNbMl0gPSByZWFkTEMoKTtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZExDKCkge1xuICAgICAgICAgICAgY29uc3QgbGMgPSB7fTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZlVMMzIgPSBiUjFjcy5zbGljZShiUjFjc1BvcywgYlIxY3NQb3MgKyA0KTtcbiAgICAgICAgICAgIGJSMWNzUG9zICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBidWZmVUwzMlYgPSBuZXcgRGF0YVZpZXcoYnVmZlVMMzIuYnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IG5JZHggPSBidWZmVUwzMlYuZ2V0VWludDMyKDAsIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmID0gYlIxY3Muc2xpY2UoYlIxY3NQb3MsIGJSMWNzUG9zICsgKDQgKyByMWNzLm44KSAqIG5JZHgpO1xuICAgICAgICAgICAgYlIxY3NQb3MgKz0gKDQgKyByMWNzLm44KSAqIG5JZHg7XG4gICAgICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5JZHg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGJ1ZmZWLmdldFVpbnQzMihpICogKDQgKyByMWNzLm44KSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gcjFjcy5GLmZyb21ScHJMRShidWZmLCBpICogKDQgKyByMWNzLm44KSArIDQpO1xuICAgICAgICAgICAgICAgIGxjW2lkeF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVprZXlGaWxlKCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gV3JpdGluZyB0aGUgemtleSBmaWxlXCIpO1xuICAgICAgICBjb25zdCBmZFpLZXkgPSBhd2FpdCBjcmVhdGVCaW5GaWxlKHprZXlGaWxlbmFtZSwgXCJ6a2V5XCIsIDEsIFpLRVlfRkZfTlNFQ1RJT05TLCAxIDw8IDIyLCAxIDw8IDI0KTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke0hFQURFUl9aS0VZX1NFQ1RJT059LiBaa2V5IEhlYWRlcmApO1xuICAgICAgICBhd2FpdCB3cml0ZVprZXlIZWFkZXIoZmRaS2V5KTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfQURESVRJT05TX1NFQ1RJT059LiBBZGRpdGlvbnNgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVBZGRpdGlvbnMoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfQV9NQVBfU0VDVElPTn0uIEEgTWFwYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcChmZFpLZXksIFpLRVlfRkZfQV9NQVBfU0VDVElPTiwgMCwgXCJBIG1hcFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfQl9NQVBfU0VDVElPTn0uIEIgTWFwYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcChmZFpLZXksIFpLRVlfRkZfQl9NQVBfU0VDVElPTiwgMSwgXCJCIG1hcFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfQ19NQVBfU0VDVElPTn0uIEMgTWFwYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcChmZFpLZXksIFpLRVlfRkZfQ19NQVBfU0VDVElPTiwgMiwgXCJDIG1hcFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUUxfU0VDVElPTn0uIFFMYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUU1hcChmZFpLZXksIFpLRVlfRkZfUUxfU0VDVElPTiwgMywgXCJRTFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUVJfU0VDVElPTn0uIFFSYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUU1hcChmZFpLZXksIFpLRVlfRkZfUVJfU0VDVElPTiwgNCwgXCJRUlwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUU1fU0VDVElPTn0uIFFNYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUU1hcChmZFpLZXksIFpLRVlfRkZfUU1fU0VDVElPTiwgNSwgXCJRTVwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUU9fU0VDVElPTn0uIFFPYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUU1hcChmZFpLZXksIFpLRVlfRkZfUU9fU0VDVElPTiwgNiwgXCJRT1wiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUUNfU0VDVElPTn0uIFFDYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUU1hcChmZFpLZXksIFpLRVlfRkZfUUNfU0VDVElPTiwgNywgXCJRQ1wiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbnMgJHtaS0VZX0ZGX1NJR01BMV9TRUNUSU9OfSwke1pLRVlfRkZfU0lHTUEyX1NFQ1RJT059LCR7WktFWV9GRl9TSUdNQTNfU0VDVElPTn0uIFNpZ21hMSwgU2lnbWEyICYgU2lnbWEgM2ApO1xuICAgICAgICBhd2FpdCB3cml0ZVNpZ21hKGZkWktleSk7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYMK3wrfCtyBXcml0aW5nIFNlY3Rpb24gJHtaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT059LiBMYWdyYW5nZSBQb2x5bm9taWFsc2ApO1xuICAgICAgICBhd2FpdCB3cml0ZUxhZ3JhbmdlUG9seW5vbWlhbHMoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUFRBVV9TRUNUSU9OfS4gUG93ZXJzIG9mIFRhdWApO1xuICAgICAgICBhd2FpdCB3cml0ZVB0YXUoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfQzBfU0VDVElPTn0uIEMwYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlQzAoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfSEVBREVSX1NFQ1RJT059LiBGRmxvbmsgSGVhZGVyYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlRkZsb25rSGVhZGVyKGZkWktleSk7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFdyaXRpbmcgdGhlIHprZXkgZmlsZSBmaW5pc2hlZFwiKTtcblxuICAgICAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVprZXlIZWFkZXIoZmRaS2V5KSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgSEVBREVSX1pLRVlfU0VDVElPTik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKEZGTE9OS19QUk9UT0NPTF9JRCk7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlQWRkaXRpb25zKGZkWktleSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIFpLRVlfRkZfQURESVRJT05TX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIFdyaXR0ZW4gdmFsdWVzIGFyZSAyICogMzIgYml0IGludGVnZXJzICgyICogNCBieXRlcykgKyAyIGZpZWxkIHNpemUgdmFsdWVzICggMiAqIHNGciBieXRlcylcbiAgICAgICAgY29uc3QgYnVmZk91dCA9IG5ldyBVaW50OEFycmF5KDggKyAyICogc0ZyKTtcbiAgICAgICAgY29uc3QgYnVmZk91dFYgPSBuZXcgRGF0YVZpZXcoYnVmZk91dC5idWZmZXIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxvbmtBZGRpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgICAgd3JpdGluZyBBZGRpdGlvbnM6ICR7aX0vJHtwbG9ua0FkZGl0aW9ucy5sZW5ndGh9YCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uID0gcGxvbmtBZGRpdGlvbnNbaV07XG5cbiAgICAgICAgICAgIGJ1ZmZPdXRWLnNldFVpbnQzMigwLCBhZGRpdGlvblswXSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmT3V0Vi5zZXRVaW50MzIoNCwgYWRkaXRpb25bMV0sIHRydWUpO1xuICAgICAgICAgICAgYnVmZk91dC5zZXQoYWRkaXRpb25bMl0sIDgpO1xuICAgICAgICAgICAgYnVmZk91dC5zZXQoYWRkaXRpb25bM10sIDggKyBzRnIpO1xuXG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYnVmZk91dCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgc2VjdGlvbk51bSwgcG9zQ29uc3RyYWludCwgbmFtZSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsb25rQ29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKGkgIT09IDApICYmIChpICUgNTAwMDAwID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGAgICAgICB3cml0aW5nIHdpdG5lc3MgJHtuYW1lfTogJHtpfS8ke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihwbG9ua0NvbnN0cmFpbnRzW2ldW3Bvc0NvbnN0cmFpbnRdKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVFNYXAoZmRaS2V5LCBzZWN0aW9uTnVtLCBwb3NDb25zdHJhaW50LCBuYW1lKSB7XG4gICAgICAgIC8vIENvbXB1dGUgUSBmcm9tIHEgZXZhbHVhdGlvbnNcbiAgICAgICAgbGV0IFEgPSBuZXcgQmlnQnVmZmVyKHNldHRpbmdzLmRvbWFpblNpemUgKiBzRnIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgUS5zZXQocGxvbmtDb25zdHJhaW50c1tpXVtwb3NDb25zdHJhaW50XSwgaSAqIHNGcik7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGkgIT09IDApICYmIChpICUgNTAwMDAwID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGAgICAgICB3cml0aW5nICR7bmFtZX06ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvbHlub21pYWxzW25hbWVdID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoUSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zW25hbWVdID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHNbbmFtZV0sIDQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIFdyaXRlIFEgY29lZmZpY2llbnRzIGFuZCBldmFsdWF0aW9uc1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUocG9seW5vbWlhbHNbbmFtZV0uY29lZik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShldmFsdWF0aW9uc1tuYW1lXS5ldmFsKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVTaWdtYShmZFpLZXkpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBzaWdtYVxuICAgICAgICBjb25zdCBzaWdtYSA9IG5ldyBCaWdCdWZmZXIoc0ZyICogc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDMpO1xuICAgICAgICBjb25zdCBsYXN0U2VlbiA9IG5ldyBCaWdBcnJheShzZXR0aW5ncy5uVmFycyk7XG4gICAgICAgIGNvbnN0IGZpcnN0UG9zID0gbmV3IEJpZ0FycmF5KHNldHRpbmdzLm5WYXJzKTtcblxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgcGxvbmtDb25zdHJhaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKHBsb25rQ29uc3RyYWludHNbaV1bMF0sIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsxXSwgc2V0dGluZ3MuZG9tYWluU2l6ZSArIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsyXSwgc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDIgKyBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IHNldHRpbmdzLmRvbWFpblNpemUgLSAyKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIHNldHRpbmdzLmRvbWFpblNpemUgKyBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIHNldHRpbmdzLmRvbWFpblNpemUgKiAyICsgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldCh3LCBpICogc0ZyKTtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQoRnIubXVsKHcsIGsxKSwgKHNldHRpbmdzLmRvbWFpblNpemUgKyBpKSAqIHNGcik7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KEZyLm11bCh3LCBrMiksIChzZXR0aW5ncy5kb21haW5TaXplICogMiArIGkpICogc0ZyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3NldHRpbmdzLmNpclBvd2VyXSk7XG5cbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCAgICAgIHdyaXRpbmcgc2lnbWEgcGhhc2UxOiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLm5WYXJzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlyc3RQb3NbaV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQobGFzdFNlZW5baV0sIGZpcnN0UG9zW2ldICogc0ZyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgbm90IHVzZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWYXJpYWJsZSBub3QgdXNlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgICAgd3JpdGluZyBzaWdtYSBwaGFzZTI6ICR7aX0vJHtzZXR0aW5ncy5uVmFyc31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAgICAgLy8gV3JpdGUgc2lnbWEgY29lZmZpY2llbnRzIGFuZCBldmFsdWF0aW9uc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvbklkID0gMCA9PT0gaSA/IFpLRVlfRkZfU0lHTUExX1NFQ1RJT04gOiAxID09PSBpID8gWktFWV9GRl9TSUdNQTJfU0VDVElPTiA6IFpLRVlfRkZfU0lHTUEzX1NFQ1RJT047XG5cbiAgICAgICAgICAgIGxldCBuYW1lID0gXCJTXCIgKyAoaSArIDEpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHNbbmFtZV0gPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhzaWdtYS5zbGljZShzZXR0aW5ncy5kb21haW5TaXplICogc0ZyICogaSwgc2V0dGluZ3MuZG9tYWluU2l6ZSAqIHNGciAqIChpICsgMSkpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zW25hbWVdID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHNbbmFtZV0sIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uSWQpO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHBvbHlub21pYWxzW25hbWVdLmNvZWYpO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGV2YWx1YXRpb25zW25hbWVdLmV2YWwpO1xuICAgICAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAgICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBmdW5jdGlvbiBidWlsZFNpZ21hKHNpZ25hbElkLCBpZHgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdFNlZW5bc2lnbmFsSWRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RQb3Nbc2lnbmFsSWRdID0gaWR4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQobGFzdFNlZW5bc2lnbmFsSWRdLCBpZHggKiBzRnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHY7XG4gICAgICAgICAgICBpZiAoaWR4IDwgc2V0dGluZ3MuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHYgPSB3O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZHggPCAyICogc2V0dGluZ3MuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHYgPSBGci5tdWwodywgazEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ID0gRnIubXVsKHcsIGsyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdFNlZW5bc2lnbmFsSWRdID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlTGFncmFuZ2VQb2x5bm9taWFscyhmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04pO1xuXG4gICAgICAgIGNvbnN0IGwgPSBNYXRoLm1heChzZXR0aW5ncy5uUHVibGljLCAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBidWZmID0gbmV3IEJpZ0J1ZmZlcihzZXR0aW5ncy5kb21haW5TaXplICogc0ZyKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KEZyLm9uZSwgaSAqIHNGcik7XG5cbiAgICAgICAgICAgIGF3YWl0IHdyaXRlUDQoZmRaS2V5LCBidWZmKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVB0YXUoZmRaS2V5KSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgWktFWV9GRl9QVEFVX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIGRvbWFpblNpemUgKiA5ICsgMTggPSBtYXhpbXVtIFNSUyBsZW5ndGggbmVlZGVkLCBzcGVjaWZpY2FsbHkgdG8gY29tbWl0IEMyXG4gICAgICAgIFBUYXUgPSBuZXcgQmlnQnVmZmVyKChzZXR0aW5ncy5kb21haW5TaXplICogOSArIDE4KSAqIHNHMSk7XG4gICAgICAgIGF3YWl0IGZkUFRhdS5yZWFkVG9CdWZmZXIoUFRhdSwgMCwgKHNldHRpbmdzLmRvbWFpblNpemUgKiA5ICsgMTgpICogc0cxLCBwVGF1U2VjdGlvbnNbMl1bMF0ucCk7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKFBUYXUpO1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUMwKGZkWktleSkge1xuICAgICAgICAvLyBDMChYKSA6PSBRTChYXjgpICsgWCDCtyBRUihYXjgpICsgWF4yIMK3IFFPKFheOCkgKyBYXjMgwrcgUU0oWF44KSArIFheNCDCtyBRQyhYXjgpXG4gICAgICAgIC8vICAgICAgICAgICAgKyBYXjUgwrcgU0lHTUExKFheOCkgKyBYXjYgwrcgU0lHTUEyKFheOCkgKyBYXjcgwrcgU0lHTUEzKFheOClcbiAgICAgICAgbGV0IEMwID0gbmV3IENQb2x5bm9taWFsKDgsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDAsIHBvbHlub21pYWxzLlFMKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCgxLCBwb2x5bm9taWFscy5RUik7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoMiwgcG9seW5vbWlhbHMuUU8pO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDMsIHBvbHlub21pYWxzLlFNKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCg0LCBwb2x5bm9taWFscy5RQyk7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoNSwgcG9seW5vbWlhbHMuUzEpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDYsIHBvbHlub21pYWxzLlMyKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCg3LCBwb2x5bm9taWFscy5TMyk7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuQzAgPSBDMC5nZXRQb2x5bm9taWFsKCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgIGlmIChwb2x5bm9taWFscy5DMC5kZWdyZWUoKSA+PSA4ICogc2V0dGluZ3MuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQzAgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBaS0VZX0ZGX0MwX1NFQ1RJT04pO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUocG9seW5vbWlhbHMuQzAuY29lZik7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRkZsb25rSGVhZGVyKGZkWktleSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIFpLRVlfRkZfSEVBREVSX1NFQ1RJT04pO1xuXG4gICAgICAgIGNvbnN0IHByaW1lUSA9IGN1cnZlLnE7XG4gICAgICAgIGNvbnN0IG44cSA9IChNYXRoLmZsb29yKChTY2FsYXIuYml0TGVuZ3RoKHByaW1lUSkgLSAxKSAvIDY0KSArIDEpICogODtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhxKTtcbiAgICAgICAgYXdhaXQgd3JpdGVCaWdJbnQoZmRaS2V5LCBwcmltZVEsIG44cSk7XG5cbiAgICAgICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICAgICAgY29uc3QgbjhyID0gKE1hdGguZmxvb3IoKFNjYWxhci5iaXRMZW5ndGgocHJpbWVSKSAtIDEpIC8gNjQpICsgMSkgKiA4O1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHIpO1xuICAgICAgICBhd2FpdCB3cml0ZUJpZ0ludChmZFpLZXksIHByaW1lUiwgbjhyKTtcblxuICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcjFjcyB2YXJzXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHNldHRpbmdzLm5WYXJzKTtcbiAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIHIxY3MgcHVibGljIHZhcnMgPSBvdXRwdXRzICsgcHVibGljIGlucHV0c1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihzZXR0aW5ncy5uUHVibGljKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoc2V0dGluZ3MuZG9tYWluU2l6ZSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQWRkaXRpb25zLmxlbmd0aCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQ29uc3RyYWludHMubGVuZ3RoKTtcblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoazEpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoazIpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3Myk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3NCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3OCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3cik7XG5cbiAgICAgICAgbGV0IGJYXzI7XG4gICAgICAgIGJYXzIgPSBhd2FpdCBmZFBUYXUucmVhZChzRzIsIHBUYXVTZWN0aW9uc1szXVswXS5wICsgc0cyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJYXzIpO1xuXG4gICAgICAgIGxldCBjb21taXRDMCA9IGF3YWl0IHBvbHlub21pYWxzLkMwLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJDMFwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGNvbW1pdEMwKTtcblxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVA0KGZkWktleSwgYnVmZikge1xuICAgICAgICBjb25zdCBbY29lZmZpY2llbnRzLCBldmFsdWF0aW9uczRdID0gYXdhaXQgUG9seW5vbWlhbC50bzRUKGJ1ZmYsIHNldHRpbmdzLmRvbWFpblNpemUsIFtdLCBGcik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShjb2VmZmljaWVudHMpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoZXZhbHVhdGlvbnM0KTtcblxuICAgICAgICByZXR1cm4gW2NvZWZmaWNpZW50cywgZXZhbHVhdGlvbnM0XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlSzFLMigpIHtcbiAgICAgICAgbGV0IGsxID0gRnIudHdvO1xuICAgICAgICB3aGlsZSAoaXNJbmNsdWRlZChrMSwgW10sIHNldHRpbmdzLmNpclBvd2VyKSkgRnIuYWRkKGsxLCBGci5vbmUpO1xuICAgICAgICBsZXQgazIgPSBGci5hZGQoazEsIEZyLm9uZSk7XG4gICAgICAgIHdoaWxlIChpc0luY2x1ZGVkKGsyLCBbazFdLCBzZXR0aW5ncy5jaXJQb3dlcikpIEZyLmFkZChrMiwgRnIub25lKTtcbiAgICAgICAgcmV0dXJuIFtrMSwgazJdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzSW5jbHVkZWQoaywga0FyciwgcG93KSB7XG4gICAgICAgICAgICBjb25zdCBkb21haW5TaXplID0gMiAqKiBwb3c7XG4gICAgICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZyLmVxKGssIHcpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtBcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEZyLmVxKGssIEZyLm11bChrQXJyW2pdLCB3KSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbcG93XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlVzMoKSB7XG4gICAgICAgIGxldCBnZW5lcmF0b3IgPSBGci5lKDMxNjI0KTtcblxuICAgICAgICAvLyBFeHBvbmVudCBpcyBvcmRlcihyIC0gMSkgLyAzXG4gICAgICAgIGxldCBvcmRlclJzdWIxID0gMzY0ODA0MDQ3ODYzOTg3OTIwMzcwNzczNDI5MDg3NjIxMjUxNDc1ODA2MDczMzQwMjY3MjM5MDYxNjM2NzM2NDQyOTMwMTQxNTkzNm47XG4gICAgICAgIGxldCBleHBvbmVudCA9IFNjYWxhci5kaXYob3JkZXJSc3ViMSwgU2NhbGFyLmUoMykpO1xuXG4gICAgICAgIHJldHVybiBGci5leHAoZ2VuZXJhdG9yLCBleHBvbmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVc0KCkge1xuICAgICAgICByZXR1cm4gRnIud1syXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlVzgoKSB7XG4gICAgICAgIHJldHVybiBGci53WzNdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE9tZWdhQ3ViaWNSb290KHBvd2VyLCBGcikge1xuICAgICAgICAvLyBIYXJkY29yZGVkIDN0aC1yb290IG9mIEZyLndbMjhdXG4gICAgICAgIGNvbnN0IGZpcnN0Um9vdCA9IEZyLmUoNDY3Nzk5MTY1ODg2MDY5NjEwMDM2MDQ2ODY2Nzk5MjY0MDI2NDgxMzQ0Mjk5MDc5MDExNzYyMDI2Nzc0NTMzNzc0MzQ1OTg4MDgwbik7XG5cbiAgICAgICAgcmV0dXJuIEZyLmV4cChmaXJzdFJvb3QsIDIgKiogKDI4IC0gcG93ZXIpKTtcbiAgICB9XG59XG5cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/fflonk_setup.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/fflonk_verify.js":
/*!***************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_verify.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeLagrangeLiS2: () => (/* binding */ computeLagrangeLiS2),\n/* harmony export */   computeLagrangeLiSi: () => (/* binding */ computeLagrangeLiSi),\n/* harmony export */   \"default\": () => (/* binding */ fflonkVerify)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proof.js */ \"(rsc)/./node_modules/snarkjs/src/proof.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(rsc)/./node_modules/snarkjs/src/Keccak256Transcript.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst { unstringifyBigInts } = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nasync function fflonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    if (logger) logger.info(\"FFLONK VERIFIER STARTED\");\n\n    _vk_verifier = unstringifyBigInts(_vk_verifier);\n    _proof = unstringifyBigInts(_proof);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName(_vk_verifier.curve);\n\n    const vk = fromObjectVk(curve, _vk_verifier);\n\n    // TODO ??? Compute wr^3 and check if it matches with w\n\n    const proof = new _proof_js__WEBPACK_IMPORTED_MODULE_2__.Proof(curve, logger);\n    proof.fromObjectProof(_proof);\n\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    if (publicSignals.length !== vk.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const Fr = curve.Fr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK VERIFY SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${vk.power}`);\n        logger.info(`  Domain size:   ${2 ** vk.power}`);\n        logger.info(`  Public vars:   ${vk.nPublic}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // STEP 1 - Validate that all polynomial commitments  G_1\n    if (logger) logger.info(\"> Checking commitments belong to G1\");\n    if (!commitmentsBelongToG1(curve, proof, vk)) {\n        if (logger) logger.error(\"Proof commitments are not valid\");\n        return false;\n    }\n\n    // STEP 2 - Validate that all evaluations  F\n    if (logger) logger.info(\"> Checking evaluations belong to F\");\n    if (!evaluationsAreValid(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid.\");\n        return false;\n    }\n\n    // STEP 3 - Validate that w_i  F for i  [l]\n    if (logger) logger.info(\"> Checking public inputs belong to F\");\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    // STEP 4 - Compute the challenges: beta, gamma, xi, alpha and y  F\n    // as in prover description, from the common preprocessed inputs, public inputs and elements of _SNARK\n    if (logger) logger.info(\"> Computing challenges\");\n    const { challenges, roots } = computeChallenges(curve, proof, vk, publicSignals, logger);\n\n    // STEP 5 - Compute the zero polynomial evaluation Z_H(xi) = xi^n - 1\n    if (logger) logger.info(\"> Computing Zero polynomial evaluation Z_H(xi)\");\n    challenges.zh = Fr.sub(challenges.xiN, Fr.one);\n    challenges.invzh = Fr.inv(challenges.zh);\n\n    // STEP 6 - Compute the lagrange polynomial evaluation L_1(xi)\n    if (logger) logger.info(\"> Computing Lagrange evaluations\");\n    const lagrangeEvals = await computeLagrangeEvaluations(curve, challenges, vk);\n\n    // STEP 7 - Compute public input evaluation PI(xi)\n    if (logger) logger.info(\"> Computing polynomial identities PI(X)\");\n    const pi = calculatePI(curve, publicSignals, lagrangeEvals);\n\n    // STEP 8 - Compute polynomial r0  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r0(y)\");\n    const r0 = computeR0(proof, challenges, roots, curve, logger);\n\n    // STEP 9 - Compute polynomial r1  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r1(y)\");\n    const r1 = computeR1(proof, challenges, roots, pi, curve, logger);\n\n    // STEP 9 - Compute polynomial r2  F_{<6}[X]\n    if (logger) logger.info(\"> Computing r2(y)\");\n    const r2 = computeR2(proof, challenges, roots, lagrangeEvals[1], vk, curve, logger);\n\n    if (logger) logger.info(\"> Computing F\");\n    const F = computeF(curve, proof, vk, challenges, roots);\n\n    if (logger) logger.info(\"> Computing E\");\n    const E = computeE(curve, proof, challenges, vk, r0, r1, r2);\n\n    if (logger) logger.info(\"> Computing J\");\n    const J = computeJ(curve, proof, challenges);\n\n    if (logger) logger.info(\"> Validate all evaluations with a pairing\");\n    const res = await isValidPairing(curve, proof, challenges, vk, F, E, J);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"PROOF VERIFIED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    if (logger) logger.info(\"FFLONK VERIFIER FINISHED\");\n\n    return res;\n\n}\n\nfunction fromObjectVk(curve, vk) {\n    const res = vk;\n    res.k1 = curve.Fr.fromObject(vk.k1);\n    res.k2 = curve.Fr.fromObject(vk.k2);\n    res.w = curve.Fr.fromObject(vk.w);\n    // res.wW = curve.Fr.fromObject(vk.wW);\n    res.w3 = curve.Fr.fromObject(vk.w3);\n    res.w4 = curve.Fr.fromObject(vk.w4);\n    res.w8 = curve.Fr.fromObject(vk.w8);\n    res.wr = curve.Fr.fromObject(vk.wr);\n    res.X_2 = curve.G2.fromObject(vk.X_2);\n    res.C0 = curve.G1.fromObject(vk.C0);\n    return res;\n}\n\nfunction commitmentsBelongToG1(curve, proof, vk) {\n    const G1 = curve.G1;\n    return G1.isValid(proof.polynomials.C1)\n        && G1.isValid(proof.polynomials.C2)\n        && G1.isValid(proof.polynomials.W1)\n        && G1.isValid(proof.polynomials.W2)\n        && G1.isValid(vk.C0);\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.geq(value, 0) && ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid(curve, evaluation) {\n    return checkValueBelongToField(curve, ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid(curve, proof) {\n    return checkEvaluationIsValid(curve, proof.evaluations.ql)\n        && checkEvaluationIsValid(curve, proof.evaluations.qr)\n        && checkEvaluationIsValid(curve, proof.evaluations.qm)\n        && checkEvaluationIsValid(curve, proof.evaluations.qo)\n        && checkEvaluationIsValid(curve, proof.evaluations.qc)\n        && checkEvaluationIsValid(curve, proof.evaluations.s1)\n        && checkEvaluationIsValid(curve, proof.evaluations.s2)\n        && checkEvaluationIsValid(curve, proof.evaluations.s3)\n        && checkEvaluationIsValid(curve, proof.evaluations.a)\n        && checkEvaluationIsValid(curve, proof.evaluations.b)\n        && checkEvaluationIsValid(curve, proof.evaluations.c)\n        && checkEvaluationIsValid(curve, proof.evaluations.z)\n        && checkEvaluationIsValid(curve, proof.evaluations.zw)\n        && checkEvaluationIsValid(curve, proof.evaluations.t1w)\n        && checkEvaluationIsValid(curve, proof.evaluations.t2w);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction computeChallenges(curve, proof, vk, publicSignals, logger) {\n    const Fr = curve.Fr;\n\n    const challenges = {};\n    const roots = {};\n    const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_3__.Keccak256Transcript(curve);\n\n    // Add C0 to the transcript\n    transcript.addPolCommitment(vk.C0);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.polynomials.C1);\n    challenges.beta = transcript.getChallenge();\n    transcript.reset();\n\n    transcript.addScalar(challenges.beta);\n    challenges.gamma = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.gamma);\n    transcript.addPolCommitment(proof.polynomials.C2);\n    const xiSeed = transcript.getChallenge();\n    const xiSeed2 = Fr.square(xiSeed);\n\n    let w8 = [];\n    w8[1] = vk.w8;\n    w8[2] = Fr.square(vk.w8);\n    w8[3] = Fr.mul(w8[2], vk.w8);\n    w8[4] = Fr.mul(w8[3], vk.w8);\n    w8[5] = Fr.mul(w8[4], vk.w8);\n    w8[6] = Fr.mul(w8[5], vk.w8);\n    w8[7] = Fr.mul(w8[6], vk.w8);\n    let w4 = [];\n    w4[1] = vk.w4;\n    w4[2] = Fr.square(vk.w4);\n    w4[3] = Fr.mul(w4[2], vk.w4);\n    let w3 = [];\n    w3[1] = vk.w3;\n    w3[2] = Fr.square(vk.w3);\n\n    // const w4_2 = Fr.square(vk.w4);\n    // const w4_3 = Fr.mul(w4_2, vk.w4);\n    // const w3_2 = Fr.square(vk.w3);\n\n    // Compute h0 = xiSeeder^3\n    roots.S0 = {};\n    roots.S0.h0w8 = [];\n    roots.S0.h0w8[0] = Fr.mul(xiSeed2, xiSeed);\n    for (let i = 1; i < 8; i++) {\n        roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], w8[i]);\n    }\n\n    // Compute h1 = xi_seeder^6\n    roots.S1 = {};\n    roots.S1.h1w4 = [];\n    roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n    for (let i = 1; i < 4; i++) {\n        roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], w4[i]);\n    }\n\n    // Compute h2 = xi_seeder^8\n    roots.S2 = {};\n    roots.S2.h2w3 = [];\n    roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n    roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], w3[1]);\n    roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], w3[2]);\n\n    roots.S2.h3w3 = [];\n    // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n    // So, h3 = xi_seeder^8 ^{1/3}\n    roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], vk.wr);\n    roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], w3[1]);\n    roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], w3[2]);\n\n    // Compute xi = xi_seeder^12\n    challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n    challenges.xiw = Fr.mul(challenges.xi, Fr.w[vk.power]);\n\n    challenges.xiN = challenges.xi;\n    vk.domainSize = 1;\n    for (let i = 0; i < vk.power; i++) {\n        challenges.xiN = Fr.square(challenges.xiN);\n        vk.domainSize *= 2;\n    }\n\n    transcript.reset();\n    transcript.addScalar(xiSeed);\n    transcript.addScalar(proof.evaluations.ql);\n    transcript.addScalar(proof.evaluations.qr);\n    transcript.addScalar(proof.evaluations.qm);\n    transcript.addScalar(proof.evaluations.qo);\n    transcript.addScalar(proof.evaluations.qc);\n    transcript.addScalar(proof.evaluations.s1);\n    transcript.addScalar(proof.evaluations.s2);\n    transcript.addScalar(proof.evaluations.s3);\n    transcript.addScalar(proof.evaluations.a);\n    transcript.addScalar(proof.evaluations.b);\n    transcript.addScalar(proof.evaluations.c);\n    transcript.addScalar(proof.evaluations.z);\n    transcript.addScalar(proof.evaluations.zw);\n    transcript.addScalar(proof.evaluations.t1w);\n    transcript.addScalar(proof.evaluations.t2w);\n    challenges.alpha = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.alpha);\n    transcript.addPolCommitment(proof.polynomials.W1);\n    challenges.y = transcript.getChallenge();\n\n    if (logger) {\n        logger.info(\" challenges.beta:  \" + Fr.toString(challenges.beta));\n        logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n        logger.info(\" challenges.xi:    \" + Fr.toString(challenges.xi));\n        logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n        logger.info(\" challenges.y:     \" + Fr.toString(challenges.y));\n    }\n\n    return { challenges: challenges, roots: roots };\n}\n\nasync function computeLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    const size = Math.max(1, vk.nPublic);\n    const numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.BigBuffer(size * Fr.n8);\n    let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.BigBuffer(size * Fr.n8);\n\n    let w = Fr.one;\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        numArr.set(Fr.mul(w, challenges.zh), i_sFr);\n        denArr.set(Fr.mul(Fr.e(vk.domainSize), Fr.sub(challenges.xi, w)), i_sFr);\n        w = Fr.mul(w, vk.w);\n    }\n\n    denArr = await Fr.batchInverse(denArr);\n\n    let L = [];\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        L[i + 1] = Fr.mul(numArr.slice(i_sFr, i_sFr + Fr.n8), denArr.slice(i_sFr, i_sFr + Fr.n8));\n    }\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, lagrangeEvals) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i = 0; i < publicSignals.length; i++) {\n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, lagrangeEvals[i + 1]));\n    }\n    return pi;\n}\n\nfunction computeR0(proof, challenges, roots, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S0.h0w8, challenges.y, challenges.xi, curve);\n\n    // r0(y) = _1^8 C_0(h_0 _8^{i-1}) L_i(y). To this end we need to compute\n\n    // Compute the 8 C0 values\n    if (logger) logger.info(\" Computing r0(y)\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 8; i++) {\n        let coefValues = [];\n        coefValues[1] = roots.S0.h0w8[i];\n        for (let j = 2; j < 8; j++) {\n            coefValues[j] = Fr.mul(coefValues[j - 1], roots.S0.h0w8[i]);\n        }\n\n        let c0 = Fr.add(proof.evaluations.ql, Fr.mul(proof.evaluations.qr, coefValues[1]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qo, coefValues[2]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qm, coefValues[3]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qc, coefValues[4]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s1, coefValues[5]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s2, coefValues[6]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s3, coefValues[7]));\n\n        res = Fr.add(res, Fr.mul(c0, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR1(proof, challenges, roots, pi, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S1.h1w4, challenges.y, challenges.xi, curve);\n\n    // r1(y) = _1^4 C_1(h_1 _4^{i-1}) L_i(y). To this end we need to compute\n    // Z1 = {C1(h_1}, C1(h_1 _4), C1(h_1 _4^2), C1(h_1 _4^3)}\n    // where C_1(h_1 _4^{i-1}) = eval.a + h_1 _4^i eval.b + (h_1 _4^i)^2 eval.c + (h_1 _4^i)^3 T0(xi),\n    // where T0(xi) = [ qLa + qRb + qMab + qOc + qC + PI(xi) ] / Z_H(xi)\n\n    // Compute T0(xi)\n    if (logger) logger.info(\" Computing T0(xi)\");\n    let t0 = Fr.mul(proof.evaluations.ql, proof.evaluations.a);\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qr, proof.evaluations.b));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qm, Fr.mul(proof.evaluations.a, proof.evaluations.b)));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qo, proof.evaluations.c));\n    t0 = Fr.add(t0, proof.evaluations.qc);\n    t0 = Fr.add(t0, pi);\n    t0 = Fr.mul(t0, challenges.invzh);\n\n    // Compute the 4 C1 values\n    if (logger) logger.info(\" Computing C1(h_1_4^i) values\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 4; i++) {\n        let c1 = proof.evaluations.a;\n        c1 = Fr.add(c1, Fr.mul(roots.S1.h1w4[i], proof.evaluations.b));\n        const h1w4Squared = Fr.square(roots.S1.h1w4[i]);\n        c1 = Fr.add(c1, Fr.mul(h1w4Squared, proof.evaluations.c));\n        c1 = Fr.add(c1, Fr.mul(Fr.mul(h1w4Squared, roots.S1.h1w4[i]), t0));\n\n        res = Fr.add(res, Fr.mul(c1, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR2(proof, challenges, roots, lagrange1, vk, curve, logger) {\n    const Fr = curve.Fr;\n\n    const LiS2 = computeLagrangeLiS2([roots.S2.h2w3, roots.S2.h3w3], challenges.y, challenges.xi, challenges.xiw, curve);\n\n    // r2(y) = _1^3 C_2(h_2 _3^{i-1}) L_i(y) + _1^3 C_2(h_3 _3^{i-1}) L_{i+3}(y). To this end we need to compute\n    // Z2 = {[C2(h_2}, C2(h_2 _3), C2(h_2 _3^2)], [C2(h_3}, C2(h_3 _3), C2(h_3 _3^2)]}\n    // where C_2(h_2 _3^{i-1}) = eval.z + h_2 _2^i T1(xi) + (h_2 _3^i)^2 T2(xi),\n    // where C_2(h_3 _3^{i-1}) = eval.z + h_3 _2^i T1(xi) + (h_3 _3^i)^2 T2(xi),\n    // where T1(xi) = [ L_1(xi)(z-1)] / Z_H(xi)\n    // and T2(xi) = [  (a + betaxi + gamma)(b + betaxik1 + gamma)(c + betaxik2 + gamma)z\n    //               - (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)z  ] / Z_H(xi)\n\n    // Compute T1(xi)\n    if (logger) logger.info(\" Computing T1(xi)\");\n    let t1 = Fr.sub(proof.evaluations.z, Fr.one);\n    t1 = Fr.mul(t1, lagrange1);\n    t1 = Fr.mul(t1, challenges.invzh);\n\n    // Compute T2(xi)\n    if (logger) logger.info(\" Computing T2(xi)\");\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n    const t211 = Fr.add(proof.evaluations.a, Fr.add(betaxi, challenges.gamma));\n    const t212 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(betaxi, vk.k1), challenges.gamma));\n    const t213 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(betaxi, vk.k2), challenges.gamma));\n    const t21 = Fr.mul(t211, Fr.mul(t212, Fr.mul(t213, proof.evaluations.z)));\n\n    const t221 = Fr.add(proof.evaluations.a, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s1), challenges.gamma));\n    const t222 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s2), challenges.gamma));\n    const t223 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s3), challenges.gamma));\n    const t22 = Fr.mul(t221, Fr.mul(t222, Fr.mul(t223, proof.evaluations.zw)));\n\n    let t2 = Fr.sub(t21, t22);\n    t2 = Fr.mul(t2, challenges.invzh);\n\n    // Compute the 6 C2 values\n    if (logger) logger.info(\" Computing C2(h_2_3^i) values\");\n    let res = Fr.zero;\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.z, Fr.mul(roots.S2.h2w3[i], t1));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h2w3[i]), t2));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i]));\n    }\n\n    if (logger) logger.info(\" Computing C2(h_3_3^i) values\");\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.zw, Fr.mul(roots.S2.h3w3[i], proof.evaluations.t1w));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h3w3[i]), proof.evaluations.t2w));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i + 3]));\n    }\n\n    return res;\n}\n\nfunction computeF(curve, proof, vk, challenges, roots) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let mulH0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n    for (let i = 1; i < 8; i++) {\n        mulH0 = Fr.mul(mulH0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n    }\n\n    challenges.temp = mulH0;\n\n    let mulH1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n    for (let i = 1; i < 4; i++) {\n        mulH1 = Fr.mul(mulH1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n    }\n\n    let mulH2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n    for (let i = 1; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n    }\n    for (let i = 0; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n    }\n\n    challenges.quotient1 = Fr.mul(challenges.alpha, Fr.div(mulH0, mulH1));\n    challenges.quotient2 = Fr.mul(Fr.square(challenges.alpha), Fr.div(mulH0, mulH2));\n\n    let F2 = G1.timesFr(proof.polynomials.C1, challenges.quotient1);\n    let F3 = G1.timesFr(proof.polynomials.C2, challenges.quotient2);\n\n    return G1.add(vk.C0, G1.add(F2, F3));\n}\n\nfunction computeE(curve, proof, challenges, vk, r0, r1, r2) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let E2 = Fr.mul(r1, challenges.quotient1);\n    let E3 = Fr.mul(r2, challenges.quotient2);\n\n    return G1.timesFr(G1.one, Fr.add(r0, Fr.add(E2, E3)));\n}\n\nfunction computeJ(curve, proof, challenges) {\n    const G1 = curve.G1;\n\n    return G1.timesFr(proof.polynomials.W1, challenges.temp);\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, F, E, J) {\n    const G1 = curve.G1;\n\n    let A1 = G1.timesFr(proof.polynomials.W2, challenges.y);\n    A1 = G1.add(G1.sub(G1.sub(F, E), J), A1);\n    const A2 = curve.G2.one;\n\n    const B1 = proof.polynomials.W2;\n    const B2 = vk.X_2;\n\n    return await curve.pairingEq(G1.neg(A1), A2, B1, B2);\n}\n\n\nfunction computeLagrangeLiSi(roots, x, xi, curve) {\n    const Fr = curve.Fr;\n    const len = roots.length;\n\n    const num = Fr.sub(Fr.exp(x, len), xi);\n    const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n\n    const Li = [];\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[((len - 1) * i) % len];\n        const den3 = Fr.sub(x, roots[i]);\n\n        Li[i] = Fr.div(num, Fr.mul(Fr.mul(den1, den2), den3));\n    }\n\n    return Li;\n}\n\nfunction computeLagrangeLiS2(roots, value, xi0, xi1, curve) {\n    const Fr = curve.Fr;\n\n    const Li = [];\n\n    const len = roots[0].length;\n    const n = len * roots.length;\n\n    const num1 = Fr.exp(value, n);\n    const num2 = Fr.mul(Fr.add(xi0, xi1), Fr.exp(value, len));\n    const num3 = Fr.mul(xi0, xi1);\n    const num = Fr.add(Fr.sub(num1, num2), num3);\n\n    let den1 = Fr.mul(Fr.mul(Fr.e(len), roots[0][0]), Fr.sub(xi0, xi1));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[0][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[0][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i] = Fr.div(num, den);\n    }\n\n    den1 = Fr.mul(Fr.mul(Fr.e(len), roots[1][0]), Fr.sub(xi1, xi0));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[1][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[1][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i + len] = Fr.div(num, den);\n    }\n\n    return Li;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3ZlcmlmeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0M7QUFDVTtBQUNiO0FBQzRCO0FBQ3pCOztBQUV0QyxRQUFRLHFCQUFxQixFQUFFLCtDQUFLOztBQUVyQjtBQUNmOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLHdEQUF1Qjs7QUFFL0M7O0FBRUE7O0FBRUEsc0JBQXNCLDRDQUFLO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25ELHdDQUF3QyxTQUFTO0FBQ2pELHdDQUF3QyxjQUFjO0FBQ3RELHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTs7QUFFQSwyQ0FBMkMsR0FBRztBQUM5QztBQUNBOztBQUVBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0RBQU0sa0JBQWtCLGdEQUFNO0FBQ3pDOztBQUVBO0FBQ0EsMENBQTBDLGdEQUFNO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsd0VBQW1COztBQUU5QztBQUNBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1EQUFTO0FBQ2hDLHFCQUFxQixtREFBUzs7QUFFOUI7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLElBQUk7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsSUFBSTtBQUN0QyxhQUFhLE9BQU87QUFDcEIsMEJBQTBCLElBQUk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtDQUFrQyxJQUFJLDhCQUE4QixJQUFJLEtBQUssSUFBSTtBQUNqRixhQUFhLFFBQVEsdUNBQXVDO0FBQzVELDBCQUEwQixJQUFJO0FBQzlCLDBCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3ZlcmlmeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBjdXJ2ZXMgZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgeyBCaWdCdWZmZXIsIHV0aWxzIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0IHsgUHJvb2YgfSBmcm9tIFwiLi9wcm9vZi5qc1wiO1xuaW1wb3J0IHsgS2VjY2FrMjU2VHJhbnNjcmlwdCB9IGZyb20gXCIuL0tlY2NhazI1NlRyYW5zY3JpcHQuanNcIjtcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuY29uc3QgeyB1bnN0cmluZ2lmeUJpZ0ludHMgfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmZmxvbmtWZXJpZnkoX3ZrX3ZlcmlmaWVyLCBfcHVibGljU2lnbmFscywgX3Byb29mLCBsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBWRVJJRklFUiBTVEFSVEVEXCIpO1xuXG4gICAgX3ZrX3ZlcmlmaWVyID0gdW5zdHJpbmdpZnlCaWdJbnRzKF92a192ZXJpZmllcik7XG4gICAgX3Byb29mID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wcm9vZik7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGN1cnZlcy5nZXRDdXJ2ZUZyb21OYW1lKF92a192ZXJpZmllci5jdXJ2ZSk7XG5cbiAgICBjb25zdCB2ayA9IGZyb21PYmplY3RWayhjdXJ2ZSwgX3ZrX3ZlcmlmaWVyKTtcblxuICAgIC8vIFRPRE8gPz8/IENvbXB1dGUgd3JeMyBhbmQgY2hlY2sgaWYgaXQgbWF0Y2hlcyB3aXRoIHdcblxuICAgIGNvbnN0IHByb29mID0gbmV3IFByb29mKGN1cnZlLCBsb2dnZXIpO1xuICAgIHByb29mLmZyb21PYmplY3RQcm9vZihfcHJvb2YpO1xuXG4gICAgY29uc3QgcHVibGljU2lnbmFscyA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHVibGljU2lnbmFscyk7XG5cbiAgICBpZiAocHVibGljU2lnbmFscy5sZW5ndGggIT09IHZrLm5QdWJsaWMpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTnVtYmVyIG9mIHB1YmxpYyBzaWduYWxzIGRvZXMgbm90IG1hdGNoIHdpdGggdmtcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiICBGRkxPTksgVkVSSUZZIFNFVFRJTkdTXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXJ2ZTogICAgICAgICAke2N1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENpcmN1aXQgcG93ZXI6ICR7dmsucG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIERvbWFpbiBzaXplOiAgICR7MiAqKiB2ay5wb3dlcn1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHVibGljIHZhcnM6ICAgJHt2ay5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgLy8gU1RFUCAxIC0gVmFsaWRhdGUgdGhhdCBhbGwgcG9seW5vbWlhbCBjb21taXRtZW50cyDiiIggR18xXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENoZWNraW5nIGNvbW1pdG1lbnRzIGJlbG9uZyB0byBHMVwiKTtcbiAgICBpZiAoIWNvbW1pdG1lbnRzQmVsb25nVG9HMShjdXJ2ZSwgcHJvb2YsIHZrKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQcm9vZiBjb21taXRtZW50cyBhcmUgbm90IHZhbGlkXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU1RFUCAyIC0gVmFsaWRhdGUgdGhhdCBhbGwgZXZhbHVhdGlvbnMg4oiIIEZcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ2hlY2tpbmcgZXZhbHVhdGlvbnMgYmVsb25nIHRvIEZcIik7XG4gICAgaWYgKCFldmFsdWF0aW9uc0FyZVZhbGlkKGN1cnZlLCBwcm9vZikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUHJvb2YgZXZhbHVhdGlvbnMgYXJlIG5vdCB2YWxpZC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTVEVQIDMgLSBWYWxpZGF0ZSB0aGF0IHdfaSDiiIggRiBmb3IgaSDiiIggW2xdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENoZWNraW5nIHB1YmxpYyBpbnB1dHMgYmVsb25nIHRvIEZcIik7XG4gICAgaWYgKCFwdWJsaWNJbnB1dHNBcmVWYWxpZChjdXJ2ZSwgcHVibGljU2lnbmFscykpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUHVibGljIGlucHV0cyBhcmUgbm90IHZhbGlkLlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNURVAgNCAtIENvbXB1dGUgdGhlIGNoYWxsZW5nZXM6IGJldGEsIGdhbW1hLCB4aSwgYWxwaGEgYW5kIHkg4oiIIEZcbiAgICAvLyBhcyBpbiBwcm92ZXIgZGVzY3JpcHRpb24sIGZyb20gdGhlIGNvbW1vbiBwcmVwcm9jZXNzZWQgaW5wdXRzLCBwdWJsaWMgaW5wdXRzIGFuZCBlbGVtZW50cyBvZiDPgF9TTkFSS1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlc1wiKTtcbiAgICBjb25zdCB7IGNoYWxsZW5nZXMsIHJvb3RzIH0gPSBjb21wdXRlQ2hhbGxlbmdlcyhjdXJ2ZSwgcHJvb2YsIHZrLCBwdWJsaWNTaWduYWxzLCBsb2dnZXIpO1xuXG4gICAgLy8gU1RFUCA1IC0gQ29tcHV0ZSB0aGUgemVybyBwb2x5bm9taWFsIGV2YWx1YXRpb24gWl9IKHhpKSA9IHhpXm4gLSAxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBaZXJvIHBvbHlub21pYWwgZXZhbHVhdGlvbiBaX0goeGkpXCIpO1xuICAgIGNoYWxsZW5nZXMuemggPSBGci5zdWIoY2hhbGxlbmdlcy54aU4sIEZyLm9uZSk7XG4gICAgY2hhbGxlbmdlcy5pbnZ6aCA9IEZyLmludihjaGFsbGVuZ2VzLnpoKTtcblxuICAgIC8vIFNURVAgNiAtIENvbXB1dGUgdGhlIGxhZ3JhbmdlIHBvbHlub21pYWwgZXZhbHVhdGlvbiBMXzEoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBMYWdyYW5nZSBldmFsdWF0aW9uc1wiKTtcbiAgICBjb25zdCBsYWdyYW5nZUV2YWxzID0gYXdhaXQgY29tcHV0ZUxhZ3JhbmdlRXZhbHVhdGlvbnMoY3VydmUsIGNoYWxsZW5nZXMsIHZrKTtcblxuICAgIC8vIFNURVAgNyAtIENvbXB1dGUgcHVibGljIGlucHV0IGV2YWx1YXRpb24gUEkoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBwb2x5bm9taWFsIGlkZW50aXRpZXMgUEkoWClcIik7XG4gICAgY29uc3QgcGkgPSBjYWxjdWxhdGVQSShjdXJ2ZSwgcHVibGljU2lnbmFscywgbGFncmFuZ2VFdmFscyk7XG5cbiAgICAvLyBTVEVQIDggLSBDb21wdXRlIHBvbHlub21pYWwgcjAg4oiIIEZfezw0fVtYXVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgcjAoeSlcIik7XG4gICAgY29uc3QgcjAgPSBjb21wdXRlUjAocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIC8vIFNURVAgOSAtIENvbXB1dGUgcG9seW5vbWlhbCByMSDiiIggRl97PDR9W1hdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyByMSh5KVwiKTtcbiAgICBjb25zdCByMSA9IGNvbXB1dGVSMShwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIHBpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIC8vIFNURVAgOSAtIENvbXB1dGUgcG9seW5vbWlhbCByMiDiiIggRl97PDZ9W1hdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyByMih5KVwiKTtcbiAgICBjb25zdCByMiA9IGNvbXB1dGVSMihwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIGxhZ3JhbmdlRXZhbHNbMV0sIHZrLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgRlwiKTtcbiAgICBjb25zdCBGID0gY29tcHV0ZUYoY3VydmUsIHByb29mLCB2aywgY2hhbGxlbmdlcywgcm9vdHMpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBFXCIpO1xuICAgIGNvbnN0IEUgPSBjb21wdXRlRShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrLCByMCwgcjEsIHIyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgSlwiKTtcbiAgICBjb25zdCBKID0gY29tcHV0ZUooY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBWYWxpZGF0ZSBhbGwgZXZhbHVhdGlvbnMgd2l0aCBhIHBhaXJpbmdcIik7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaXNWYWxpZFBhaXJpbmcoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRiwgRSwgSik7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiUFJPT0YgVkVSSUZJRUQgU1VDQ0VTU0ZVTExZXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJJbnZhbGlkIFByb29mXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgVkVSSUZJRVIgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4gcmVzO1xuXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3RWayhjdXJ2ZSwgdmspIHtcbiAgICBjb25zdCByZXMgPSB2aztcbiAgICByZXMuazEgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLmsxKTtcbiAgICByZXMuazIgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLmsyKTtcbiAgICByZXMudyA9IGN1cnZlLkZyLmZyb21PYmplY3Qodmsudyk7XG4gICAgLy8gcmVzLndXID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53Vyk7XG4gICAgcmVzLnczID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53Myk7XG4gICAgcmVzLnc0ID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53NCk7XG4gICAgcmVzLnc4ID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53OCk7XG4gICAgcmVzLndyID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53cik7XG4gICAgcmVzLlhfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmsuWF8yKTtcbiAgICByZXMuQzAgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrLkMwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb21taXRtZW50c0JlbG9uZ1RvRzEoY3VydmUsIHByb29mLCB2aykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgcmV0dXJuIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuQzEpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuQzIpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuVzEpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuVzIpXG4gICAgICAgICYmIEcxLmlzVmFsaWQodmsuQzApO1xufVxuXG5mdW5jdGlvbiBjaGVja1ZhbHVlQmVsb25nVG9GaWVsZChjdXJ2ZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gU2NhbGFyLmdlcSh2YWx1ZSwgMCkgJiYgU2NhbGFyLmx0KHZhbHVlLCBjdXJ2ZS5yKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgZXZhbHVhdGlvbikge1xuICAgIHJldHVybiBjaGVja1ZhbHVlQmVsb25nVG9GaWVsZChjdXJ2ZSwgU2NhbGFyLmZyb21ScHJMRShldmFsdWF0aW9uKSk7XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRpb25zQXJlVmFsaWQoY3VydmUsIHByb29mKSB7XG4gICAgcmV0dXJuIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnFsKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5xcilcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMucW0pXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnFvKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5xYylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuczEpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnMyKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5zMylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuYSlcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuYilcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuYylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMueilcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuencpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnQxdylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMudDJ3KTtcbn1cblxuZnVuY3Rpb24gcHVibGljSW5wdXRzQXJlVmFsaWQoY3VydmUsIHB1YmxpY0lucHV0cykge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwdWJsaWNJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoIWNoZWNrVmFsdWVCZWxvbmdUb0ZpZWxkKGN1cnZlLCBwdWJsaWNJbnB1dHNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaGFsbGVuZ2VzKGN1cnZlLCBwcm9vZiwgdmssIHB1YmxpY1NpZ25hbHMsIGxvZ2dlcikge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBjaGFsbGVuZ2VzID0ge307XG4gICAgY29uc3Qgcm9vdHMgPSB7fTtcbiAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuXG4gICAgLy8gQWRkIEMwIHRvIHRoZSB0cmFuc2NyaXB0XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLkMwKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVibGljU2lnbmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihGci5lKHB1YmxpY1NpZ25hbHNbaV0pKTtcbiAgICB9XG5cbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YucG9seW5vbWlhbHMuQzEpO1xuICAgIGNoYWxsZW5nZXMuYmV0YSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuXG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5iZXRhKTtcbiAgICBjaGFsbGVuZ2VzLmdhbW1hID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YucG9seW5vbWlhbHMuQzIpO1xuICAgIGNvbnN0IHhpU2VlZCA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgY29uc3QgeGlTZWVkMiA9IEZyLnNxdWFyZSh4aVNlZWQpO1xuXG4gICAgbGV0IHc4ID0gW107XG4gICAgdzhbMV0gPSB2ay53ODtcbiAgICB3OFsyXSA9IEZyLnNxdWFyZSh2ay53OCk7XG4gICAgdzhbM10gPSBGci5tdWwodzhbMl0sIHZrLnc4KTtcbiAgICB3OFs0XSA9IEZyLm11bCh3OFszXSwgdmsudzgpO1xuICAgIHc4WzVdID0gRnIubXVsKHc4WzRdLCB2ay53OCk7XG4gICAgdzhbNl0gPSBGci5tdWwodzhbNV0sIHZrLnc4KTtcbiAgICB3OFs3XSA9IEZyLm11bCh3OFs2XSwgdmsudzgpO1xuICAgIGxldCB3NCA9IFtdO1xuICAgIHc0WzFdID0gdmsudzQ7XG4gICAgdzRbMl0gPSBGci5zcXVhcmUodmsudzQpO1xuICAgIHc0WzNdID0gRnIubXVsKHc0WzJdLCB2ay53NCk7XG4gICAgbGV0IHczID0gW107XG4gICAgdzNbMV0gPSB2ay53MztcbiAgICB3M1syXSA9IEZyLnNxdWFyZSh2ay53Myk7XG5cbiAgICAvLyBjb25zdCB3NF8yID0gRnIuc3F1YXJlKHZrLnc0KTtcbiAgICAvLyBjb25zdCB3NF8zID0gRnIubXVsKHc0XzIsIHZrLnc0KTtcbiAgICAvLyBjb25zdCB3M18yID0gRnIuc3F1YXJlKHZrLnczKTtcblxuICAgIC8vIENvbXB1dGUgaDAgPSB4aVNlZWRlcl4zXG4gICAgcm9vdHMuUzAgPSB7fTtcbiAgICByb290cy5TMC5oMHc4ID0gW107XG4gICAgcm9vdHMuUzAuaDB3OFswXSA9IEZyLm11bCh4aVNlZWQyLCB4aVNlZWQpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIHJvb3RzLlMwLmgwdzhbaV0gPSBGci5tdWwocm9vdHMuUzAuaDB3OFswXSwgdzhbaV0pO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgaDEgPSB4aV9zZWVkZXJeNlxuICAgIHJvb3RzLlMxID0ge307XG4gICAgcm9vdHMuUzEuaDF3NCA9IFtdO1xuICAgIHJvb3RzLlMxLmgxdzRbMF0gPSBGci5zcXVhcmUocm9vdHMuUzAuaDB3OFswXSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgcm9vdHMuUzEuaDF3NFtpXSA9IEZyLm11bChyb290cy5TMS5oMXc0WzBdLCB3NFtpXSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBoMiA9IHhpX3NlZWRlcl44XG4gICAgcm9vdHMuUzIgPSB7fTtcbiAgICByb290cy5TMi5oMnczID0gW107XG4gICAgcm9vdHMuUzIuaDJ3M1swXSA9IEZyLm11bChyb290cy5TMS5oMXc0WzBdLCB4aVNlZWQyKTtcbiAgICByb290cy5TMi5oMnczWzFdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHczWzFdKTtcbiAgICByb290cy5TMi5oMnczWzJdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHczWzJdKTtcblxuICAgIHJvb3RzLlMyLmgzdzMgPSBbXTtcbiAgICAvLyBNdWx0aXBseSBoMyBieSB0aGlyZC1yb290LW9tZWdhIHRvIG9idGFpbiBoXzNeMyA9IHhpz4lcbiAgICAvLyBTbywgaDMgPSB4aV9zZWVkZXJeOCDPiV57MS8zfVxuICAgIHJvb3RzLlMyLmgzdzNbMF0gPSBGci5tdWwocm9vdHMuUzIuaDJ3M1swXSwgdmsud3IpO1xuICAgIHJvb3RzLlMyLmgzdzNbMV0gPSBGci5tdWwocm9vdHMuUzIuaDN3M1swXSwgdzNbMV0pO1xuICAgIHJvb3RzLlMyLmgzdzNbMl0gPSBGci5tdWwocm9vdHMuUzIuaDN3M1swXSwgdzNbMl0pO1xuXG4gICAgLy8gQ29tcHV0ZSB4aSA9IHhpX3NlZWRlcl4xMlxuICAgIGNoYWxsZW5nZXMueGkgPSBGci5tdWwoRnIuc3F1YXJlKHJvb3RzLlMyLmgydzNbMF0pLCByb290cy5TMi5oMnczWzBdKTtcbiAgICBjaGFsbGVuZ2VzLnhpdyA9IEZyLm11bChjaGFsbGVuZ2VzLnhpLCBGci53W3ZrLnBvd2VyXSk7XG5cbiAgICBjaGFsbGVuZ2VzLnhpTiA9IGNoYWxsZW5nZXMueGk7XG4gICAgdmsuZG9tYWluU2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ay5wb3dlcjsgaSsrKSB7XG4gICAgICAgIGNoYWxsZW5nZXMueGlOID0gRnIuc3F1YXJlKGNoYWxsZW5nZXMueGlOKTtcbiAgICAgICAgdmsuZG9tYWluU2l6ZSAqPSAyO1xuICAgIH1cblxuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcih4aVNlZWQpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnFsKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5xcik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMucW0pO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnFvKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5xYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuczEpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnMyKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5zMyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuYSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuYik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMueik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuencpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnQxdyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMudDJ3KTtcbiAgICBjaGFsbGVuZ2VzLmFscGhhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YucG9seW5vbWlhbHMuVzEpO1xuICAgIGNoYWxsZW5nZXMueSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuYmV0YTogIFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5iZXRhKSk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuZ2FtbWE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLnhpOiAgICBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5hbHBoYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmFscGhhKSk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMueTogICAgIFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy55KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY2hhbGxlbmdlczogY2hhbGxlbmdlcywgcm9vdHM6IHJvb3RzIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2aykge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgoMSwgdmsublB1YmxpYyk7XG4gICAgY29uc3QgbnVtQXJyID0gbmV3IEJpZ0J1ZmZlcihzaXplICogRnIubjgpO1xuICAgIGxldCBkZW5BcnIgPSBuZXcgQmlnQnVmZmVyKHNpemUgKiBGci5uOCk7XG5cbiAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBGci5uODtcbiAgICAgICAgbnVtQXJyLnNldChGci5tdWwodywgY2hhbGxlbmdlcy56aCksIGlfc0ZyKTtcbiAgICAgICAgZGVuQXJyLnNldChGci5tdWwoRnIuZSh2ay5kb21haW5TaXplKSwgRnIuc3ViKGNoYWxsZW5nZXMueGksIHcpKSwgaV9zRnIpO1xuICAgICAgICB3ID0gRnIubXVsKHcsIHZrLncpO1xuICAgIH1cblxuICAgIGRlbkFyciA9IGF3YWl0IEZyLmJhdGNoSW52ZXJzZShkZW5BcnIpO1xuXG4gICAgbGV0IEwgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBGci5uODtcbiAgICAgICAgTFtpICsgMV0gPSBGci5tdWwobnVtQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIEZyLm44KSwgZGVuQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIEZyLm44KSk7XG4gICAgfVxuICAgIHJldHVybiBMO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQSShjdXJ2ZSwgcHVibGljU2lnbmFscywgbGFncmFuZ2VFdmFscykge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgcGkgPSBGci56ZXJvO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVibGljU2lnbmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB3ID0gRnIuZShwdWJsaWNTaWduYWxzW2ldKTtcbiAgICAgICAgcGkgPSBGci5zdWIocGksIEZyLm11bCh3LCBsYWdyYW5nZUV2YWxzW2kgKyAxXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVSMChwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIGN1cnZlLCBsb2dnZXIpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3QgTGkgPSBjb21wdXRlTGFncmFuZ2VMaVNpKHJvb3RzLlMwLmgwdzgsIGNoYWxsZW5nZXMueSwgY2hhbGxlbmdlcy54aSwgY3VydmUpO1xuXG4gICAgLy8gcjAoeSkgPSDiiJFfMV44IENfMChoXzAgz4lfOF57aS0xfSkgTF9pKHkpLiBUbyB0aGlzIGVuZCB3ZSBuZWVkIHRvIGNvbXB1dGVcblxuICAgIC8vIENvbXB1dGUgdGhlIDggQzAgdmFsdWVzXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIHIwKHkpXCIpO1xuXG4gICAgbGV0IHJlcyA9IEZyLnplcm87XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgbGV0IGNvZWZWYWx1ZXMgPSBbXTtcbiAgICAgICAgY29lZlZhbHVlc1sxXSA9IHJvb3RzLlMwLmgwdzhbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAyOyBqIDwgODsgaisrKSB7XG4gICAgICAgICAgICBjb2VmVmFsdWVzW2pdID0gRnIubXVsKGNvZWZWYWx1ZXNbaiAtIDFdLCByb290cy5TMC5oMHc4W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjMCA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5xbCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFyLCBjb2VmVmFsdWVzWzFdKSk7XG4gICAgICAgIGMwID0gRnIuYWRkKGMwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucW8sIGNvZWZWYWx1ZXNbMl0pKTtcbiAgICAgICAgYzAgPSBGci5hZGQoYzAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xbSwgY29lZlZhbHVlc1szXSkpO1xuICAgICAgICBjMCA9IEZyLmFkZChjMCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFjLCBjb2VmVmFsdWVzWzRdKSk7XG4gICAgICAgIGMwID0gRnIuYWRkKGMwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMuczEsIGNvZWZWYWx1ZXNbNV0pKTtcbiAgICAgICAgYzAgPSBGci5hZGQoYzAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5zMiwgY29lZlZhbHVlc1s2XSkpO1xuICAgICAgICBjMCA9IEZyLmFkZChjMCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnMzLCBjb2VmVmFsdWVzWzddKSk7XG5cbiAgICAgICAgcmVzID0gRnIuYWRkKHJlcywgRnIubXVsKGMwLCBMaVtpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVSMShwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIHBpLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IExpID0gY29tcHV0ZUxhZ3JhbmdlTGlTaShyb290cy5TMS5oMXc0LCBjaGFsbGVuZ2VzLnksIGNoYWxsZW5nZXMueGksIGN1cnZlKTtcblxuICAgIC8vIHIxKHkpID0g4oiRXzFeNCBDXzEoaF8xIM+JXzRee2ktMX0pIExfaSh5KS4gVG8gdGhpcyBlbmQgd2UgbmVlZCB0byBjb21wdXRlXG4gICAgLy8gWjEgPSB7QzEoaF8xfSwgQzEoaF8xIM+JXzQpLCBDMShoXzEgz4lfNF4yKSwgQzEoaF8xIM+JXzReMyl9XG4gICAgLy8gd2hlcmUgQ18xKGhfMSDPiV80XntpLTF9KSA9IGV2YWwuYSArIGhfMSDPiV80XmkgZXZhbC5iICsgKGhfMSDPiV80XmkpXjIgZXZhbC5jICsgKGhfMSDPiV80XmkpXjMgVDAoeGkpLFxuICAgIC8vIHdoZXJlIFQwKHhpKSA9IFsgcUzCt2EgKyBxUsK3YiArIHFNwrdhwrdiICsgcU/Ct2MgKyBxQyArIFBJKHhpKSBdIC8gWl9IKHhpKVxuXG4gICAgLy8gQ29tcHV0ZSBUMCh4aSlcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDAoeGkpXCIpO1xuICAgIGxldCB0MCA9IEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xbCwgcHJvb2YuZXZhbHVhdGlvbnMuYSk7XG4gICAgdDAgPSBGci5hZGQodDAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xciwgcHJvb2YuZXZhbHVhdGlvbnMuYikpO1xuICAgIHQwID0gRnIuYWRkKHQwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucW0sIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5hLCBwcm9vZi5ldmFsdWF0aW9ucy5iKSkpO1xuICAgIHQwID0gRnIuYWRkKHQwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucW8sIHByb29mLmV2YWx1YXRpb25zLmMpKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgcHJvb2YuZXZhbHVhdGlvbnMucWMpO1xuICAgIHQwID0gRnIuYWRkKHQwLCBwaSk7XG4gICAgdDAgPSBGci5tdWwodDAsIGNoYWxsZW5nZXMuaW52emgpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgNCBDMSB2YWx1ZXNcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQzEoaF8xz4lfNF5pKSB2YWx1ZXNcIik7XG5cbiAgICBsZXQgcmVzID0gRnIuemVybztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBsZXQgYzEgPSBwcm9vZi5ldmFsdWF0aW9ucy5hO1xuICAgICAgICBjMSA9IEZyLmFkZChjMSwgRnIubXVsKHJvb3RzLlMxLmgxdzRbaV0sIHByb29mLmV2YWx1YXRpb25zLmIpKTtcbiAgICAgICAgY29uc3QgaDF3NFNxdWFyZWQgPSBGci5zcXVhcmUocm9vdHMuUzEuaDF3NFtpXSk7XG4gICAgICAgIGMxID0gRnIuYWRkKGMxLCBGci5tdWwoaDF3NFNxdWFyZWQsIHByb29mLmV2YWx1YXRpb25zLmMpKTtcbiAgICAgICAgYzEgPSBGci5hZGQoYzEsIEZyLm11bChGci5tdWwoaDF3NFNxdWFyZWQsIHJvb3RzLlMxLmgxdzRbaV0pLCB0MCkpO1xuXG4gICAgICAgIHJlcyA9IEZyLmFkZChyZXMsIEZyLm11bChjMSwgTGlbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlUjIocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBsYWdyYW5nZTEsIHZrLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IExpUzIgPSBjb21wdXRlTGFncmFuZ2VMaVMyKFtyb290cy5TMi5oMnczLCByb290cy5TMi5oM3czXSwgY2hhbGxlbmdlcy55LCBjaGFsbGVuZ2VzLnhpLCBjaGFsbGVuZ2VzLnhpdywgY3VydmUpO1xuXG4gICAgLy8gcjIoeSkgPSDiiJFfMV4zIENfMihoXzIgz4lfM157aS0xfSkgTF9pKHkpICsg4oiRXzFeMyBDXzIoaF8zIM+JXzNee2ktMX0pIExfe2krM30oeSkuIFRvIHRoaXMgZW5kIHdlIG5lZWQgdG8gY29tcHV0ZVxuICAgIC8vIFoyID0ge1tDMihoXzJ9LCBDMihoXzIgz4lfMyksIEMyKGhfMiDPiV8zXjIpXSwgW0MyKGhfM30sIEMyKGhfMyDPiV8zKSwgQzIoaF8zIM+JXzNeMildfVxuICAgIC8vIHdoZXJlIENfMihoXzIgz4lfM157aS0xfSkgPSBldmFsLnogKyBoXzIgz4lfMl5pIFQxKHhpKSArIChoXzIgz4lfM15pKV4yIFQyKHhpKSxcbiAgICAvLyB3aGVyZSBDXzIoaF8zIM+JXzNee2ktMX0pID0gZXZhbC56ICsgaF8zIM+JXzJeaSBUMSh4aSkgKyAoaF8zIM+JXzNeaSleMiBUMih4aSksXG4gICAgLy8gd2hlcmUgVDEoeGkpID0gWyBMXzEoeGkpKHotMSldIC8gWl9IKHhpKVxuICAgIC8vIGFuZCBUMih4aSkgPSBbICAoYSArIGJldGHCt3hpICsgZ2FtbWEpKGIgKyBiZXRhwrd4acK3azEgKyBnYW1tYSkoYyArIGJldGHCt3hpwrdrMiArIGdhbW1hKXpcbiAgICAvLyAgICAgICAgICAgICAgIC0gKGEgKyBiZXRhwrdzaWdtYTEgKyBnYW1tYSkoYiArIGJldGHCt3NpZ21hMiArIGdhbW1hKShjICsgYmV0YcK3c2lnbWEzICsgZ2FtbWEpes+JICBdIC8gWl9IKHhpKVxuXG4gICAgLy8gQ29tcHV0ZSBUMSh4aSlcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDEoeGkpXCIpO1xuICAgIGxldCB0MSA9IEZyLnN1Yihwcm9vZi5ldmFsdWF0aW9ucy56LCBGci5vbmUpO1xuICAgIHQxID0gRnIubXVsKHQxLCBsYWdyYW5nZTEpO1xuICAgIHQxID0gRnIubXVsKHQxLCBjaGFsbGVuZ2VzLmludnpoKTtcblxuICAgIC8vIENvbXB1dGUgVDIoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQyKHhpKVwiKTtcbiAgICBjb25zdCBiZXRheGkgPSBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBjaGFsbGVuZ2VzLnhpKTtcbiAgICBjb25zdCB0MjExID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmEsIEZyLmFkZChiZXRheGksIGNoYWxsZW5nZXMuZ2FtbWEpKTtcbiAgICBjb25zdCB0MjEyID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmIsIEZyLmFkZChGci5tdWwoYmV0YXhpLCB2ay5rMSksIGNoYWxsZW5nZXMuZ2FtbWEpKTtcbiAgICBjb25zdCB0MjEzID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmMsIEZyLmFkZChGci5tdWwoYmV0YXhpLCB2ay5rMiksIGNoYWxsZW5nZXMuZ2FtbWEpKTtcbiAgICBjb25zdCB0MjEgPSBGci5tdWwodDIxMSwgRnIubXVsKHQyMTIsIEZyLm11bCh0MjEzLCBwcm9vZi5ldmFsdWF0aW9ucy56KSkpO1xuXG4gICAgY29uc3QgdDIyMSA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5hLCBGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbHVhdGlvbnMuczEpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIyMiA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5iLCBGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbHVhdGlvbnMuczIpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIyMyA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5jLCBGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbHVhdGlvbnMuczMpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIyID0gRnIubXVsKHQyMjEsIEZyLm11bCh0MjIyLCBGci5tdWwodDIyMywgcHJvb2YuZXZhbHVhdGlvbnMuencpKSk7XG5cbiAgICBsZXQgdDIgPSBGci5zdWIodDIxLCB0MjIpO1xuICAgIHQyID0gRnIubXVsKHQyLCBjaGFsbGVuZ2VzLmludnpoKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIDYgQzIgdmFsdWVzXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMyKGhfMs+JXzNeaSkgdmFsdWVzXCIpO1xuICAgIGxldCByZXMgPSBGci56ZXJvO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGxldCBjMiA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy56LCBGci5tdWwocm9vdHMuUzIuaDJ3M1tpXSwgdDEpKTtcbiAgICAgICAgYzIgPSBGci5hZGQoYzIsIEZyLm11bChGci5zcXVhcmUocm9vdHMuUzIuaDJ3M1tpXSksIHQyKSk7XG5cbiAgICAgICAgcmVzID0gRnIuYWRkKHJlcywgRnIubXVsKGMyLCBMaVMyW2ldKSk7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMyKGhfM8+JXzNeaSkgdmFsdWVzXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGxldCBjMiA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy56dywgRnIubXVsKHJvb3RzLlMyLmgzdzNbaV0sIHByb29mLmV2YWx1YXRpb25zLnQxdykpO1xuICAgICAgICBjMiA9IEZyLmFkZChjMiwgRnIubXVsKEZyLnNxdWFyZShyb290cy5TMi5oM3czW2ldKSwgcHJvb2YuZXZhbHVhdGlvbnMudDJ3KSk7XG5cbiAgICAgICAgcmVzID0gRnIuYWRkKHJlcywgRnIubXVsKGMyLCBMaVMyW2kgKyAzXSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVGKGN1cnZlLCBwcm9vZiwgdmssIGNoYWxsZW5nZXMsIHJvb3RzKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IG11bEgwID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzAuaDB3OFswXSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgbXVsSDAgPSBGci5tdWwobXVsSDAsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMwLmgwdzhbaV0pKTtcbiAgICB9XG5cbiAgICBjaGFsbGVuZ2VzLnRlbXAgPSBtdWxIMDtcblxuICAgIGxldCBtdWxIMSA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMxLmgxdzRbMF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIG11bEgxID0gRnIubXVsKG11bEgxLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMS5oMXc0W2ldKSk7XG4gICAgfVxuXG4gICAgbGV0IG11bEgyID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDJ3M1swXSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgbXVsSDIgPSBGci5tdWwobXVsSDIsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgydzNbaV0pKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgbXVsSDIgPSBGci5tdWwobXVsSDIsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgzdzNbaV0pKTtcbiAgICB9XG5cbiAgICBjaGFsbGVuZ2VzLnF1b3RpZW50MSA9IEZyLm11bChjaGFsbGVuZ2VzLmFscGhhLCBGci5kaXYobXVsSDAsIG11bEgxKSk7XG4gICAgY2hhbGxlbmdlcy5xdW90aWVudDIgPSBGci5tdWwoRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpLCBGci5kaXYobXVsSDAsIG11bEgyKSk7XG5cbiAgICBsZXQgRjIgPSBHMS50aW1lc0ZyKHByb29mLnBvbHlub21pYWxzLkMxLCBjaGFsbGVuZ2VzLnF1b3RpZW50MSk7XG4gICAgbGV0IEYzID0gRzEudGltZXNGcihwcm9vZi5wb2x5bm9taWFscy5DMiwgY2hhbGxlbmdlcy5xdW90aWVudDIpO1xuXG4gICAgcmV0dXJuIEcxLmFkZCh2ay5DMCwgRzEuYWRkKEYyLCBGMykpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrLCByMCwgcjEsIHIyKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IEUyID0gRnIubXVsKHIxLCBjaGFsbGVuZ2VzLnF1b3RpZW50MSk7XG4gICAgbGV0IEUzID0gRnIubXVsKHIyLCBjaGFsbGVuZ2VzLnF1b3RpZW50Mik7XG5cbiAgICByZXR1cm4gRzEudGltZXNGcihHMS5vbmUsIEZyLmFkZChyMCwgRnIuYWRkKEUyLCBFMykpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUooY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcblxuICAgIHJldHVybiBHMS50aW1lc0ZyKHByb29mLnBvbHlub21pYWxzLlcxLCBjaGFsbGVuZ2VzLnRlbXApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpc1ZhbGlkUGFpcmluZyhjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrLCBGLCBFLCBKKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcblxuICAgIGxldCBBMSA9IEcxLnRpbWVzRnIocHJvb2YucG9seW5vbWlhbHMuVzIsIGNoYWxsZW5nZXMueSk7XG4gICAgQTEgPSBHMS5hZGQoRzEuc3ViKEcxLnN1YihGLCBFKSwgSiksIEExKTtcbiAgICBjb25zdCBBMiA9IGN1cnZlLkcyLm9uZTtcblxuICAgIGNvbnN0IEIxID0gcHJvb2YucG9seW5vbWlhbHMuVzI7XG4gICAgY29uc3QgQjIgPSB2ay5YXzI7XG5cbiAgICByZXR1cm4gYXdhaXQgY3VydmUucGFpcmluZ0VxKEcxLm5lZyhBMSksIEEyLCBCMSwgQjIpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlTGFncmFuZ2VMaVNpKHJvb3RzLCB4LCB4aSwgY3VydmUpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IGxlbiA9IHJvb3RzLmxlbmd0aDtcblxuICAgIGNvbnN0IG51bSA9IEZyLnN1YihGci5leHAoeCwgbGVuKSwgeGkpO1xuICAgIGNvbnN0IGRlbjEgPSBGci5tdWwoRnIuZShsZW4pLCBGci5leHAocm9vdHNbMF0sIGxlbiAtIDIpKTtcblxuICAgIGNvbnN0IExpID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBkZW4yID0gcm9vdHNbKChsZW4gLSAxKSAqIGkpICUgbGVuXTtcbiAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih4LCByb290c1tpXSk7XG5cbiAgICAgICAgTGlbaV0gPSBGci5kaXYobnVtLCBGci5tdWwoRnIubXVsKGRlbjEsIGRlbjIpLCBkZW4zKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIExpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUxhZ3JhbmdlTGlTMihyb290cywgdmFsdWUsIHhpMCwgeGkxLCBjdXJ2ZSkge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBMaSA9IFtdO1xuXG4gICAgY29uc3QgbGVuID0gcm9vdHNbMF0ubGVuZ3RoO1xuICAgIGNvbnN0IG4gPSBsZW4gKiByb290cy5sZW5ndGg7XG5cbiAgICBjb25zdCBudW0xID0gRnIuZXhwKHZhbHVlLCBuKTtcbiAgICBjb25zdCBudW0yID0gRnIubXVsKEZyLmFkZCh4aTAsIHhpMSksIEZyLmV4cCh2YWx1ZSwgbGVuKSk7XG4gICAgY29uc3QgbnVtMyA9IEZyLm11bCh4aTAsIHhpMSk7XG4gICAgY29uc3QgbnVtID0gRnIuYWRkKEZyLnN1YihudW0xLCBudW0yKSwgbnVtMyk7XG5cbiAgICBsZXQgZGVuMSA9IEZyLm11bChGci5tdWwoRnIuZShsZW4pLCByb290c1swXVswXSksIEZyLnN1Yih4aTAsIHhpMSkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWzBdWyhsZW4gLSAxKSAqIGkgJSBsZW5dO1xuICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHZhbHVlLCByb290c1swXVtpXSk7XG5cbiAgICAgICAgY29uc3QgZGVuID0gRnIubXVsKGRlbjEsRnIubXVsKGRlbjIsIGRlbjMpKTtcblxuICAgICAgICBMaVtpXSA9IEZyLmRpdihudW0sIGRlbik7XG4gICAgfVxuXG4gICAgZGVuMSA9IEZyLm11bChGci5tdWwoRnIuZShsZW4pLCByb290c1sxXVswXSksIEZyLnN1Yih4aTEsIHhpMCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWzFdWyhsZW4gLSAxKSAqIGkgJSBsZW5dO1xuICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHZhbHVlLCByb290c1sxXVtpXSk7XG5cbiAgICAgICAgY29uc3QgZGVuID0gRnIubXVsKGRlbjEsRnIubXVsKGRlbjIsIGRlbjMpKTtcblxuICAgICAgICBMaVtpICsgbGVuXSA9IEZyLmRpdihudW0sIGRlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIExpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/fflonk_verify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/groth16.js":
/*!*********************************************!*\
  !*** ./node_modules/snarkjs/src/groth16.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _groth16_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _groth16_fullprove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _groth16_prove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _groth16_verify_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _groth16_fullprove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./groth16_fullprove.js */ \"(rsc)/./node_modules/snarkjs/src/groth16_fullprove.js\");\n/* harmony import */ var _groth16_prove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./groth16_prove.js */ \"(rsc)/./node_modules/snarkjs/src/groth16_prove.js\");\n/* harmony import */ var _groth16_verify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./groth16_verify.js */ \"(rsc)/./node_modules/snarkjs/src/groth16_verify.js\");\n/* harmony import */ var _groth16_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./groth16_exportsoliditycalldata.js */ \"(rsc)/./node_modules/snarkjs/src/groth16_exportsoliditycalldata.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRTREO0FBQ1I7QUFDRTtBQUNnQyIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9ncm90aDE2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBmdWxsUHJvdmV9IGZyb20gXCIuL2dyb3RoMTZfZnVsbHByb3ZlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcHJvdmV9IGZyb20gXCIuL2dyb3RoMTZfcHJvdmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB2ZXJpZnl9IGZyb20gXCIuL2dyb3RoMTZfdmVyaWZ5LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0U29saWRpdHlDYWxsRGF0YX0gZnJvbSBcIi4vZ3JvdGgxNl9leHBvcnRzb2xpZGl0eWNhbGxkYXRhLmpzXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/groth16.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/groth16_exportsoliditycalldata.js":
/*!********************************************************************!*\
  !*** ./node_modules/snarkjs/src/groth16_exportsoliditycalldata.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16ExportSolidityCallData)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function groth16ExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    let S;\n    S=`[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` +\n        `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` +\n        `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9leHBvcnRzb2xpZGl0eWNhbGxkYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUN3QztBQUN4QyxRQUFRLG9CQUFvQixFQUFFLCtDQUFLOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBOztBQUVlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsb0JBQW9CLElBQUksb0JBQW9CO0FBQ3RELGFBQWEsdUJBQXVCLElBQUksdUJBQXVCLEtBQUssdUJBQXVCLElBQUksdUJBQXVCO0FBQ3RILFlBQVksb0JBQW9CLElBQUksb0JBQW9CO0FBQ3hELFlBQVksT0FBTzs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9ncm90aDE2X2V4cG9ydHNvbGlkaXR5Y2FsbGRhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3QgeyB1bnN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmZ1bmN0aW9uIHAyNTYobikge1xuICAgIGxldCBuc3RyID0gbi50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKG5zdHIubGVuZ3RoIDwgNjQpIG5zdHIgPSBcIjBcIituc3RyO1xuICAgIG5zdHIgPSBgXCIweCR7bnN0cn1cImA7XG4gICAgcmV0dXJuIG5zdHI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGdyb3RoMTZFeHBvcnRTb2xpZGl0eUNhbGxEYXRhKF9wcm9vZiwgX3B1Yikge1xuICAgIGNvbnN0IHByb29mID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wcm9vZik7XG4gICAgY29uc3QgcHViID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wdWIpO1xuXG4gICAgbGV0IGlucHV0cyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaT0wOyBpPHB1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRzICE9IFwiXCIpIGlucHV0cyA9IGlucHV0cyArIFwiLFwiO1xuICAgICAgICBpbnB1dHMgPSBpbnB1dHMgKyBwMjU2KHB1YltpXSk7XG4gICAgfVxuXG4gICAgbGV0IFM7XG4gICAgUz1gWyR7cDI1Nihwcm9vZi5waV9hWzBdKX0sICR7cDI1Nihwcm9vZi5waV9hWzFdKX1dLGAgK1xuICAgICAgICBgW1ske3AyNTYocHJvb2YucGlfYlswXVsxXSl9LCAke3AyNTYocHJvb2YucGlfYlswXVswXSl9XSxbJHtwMjU2KHByb29mLnBpX2JbMV1bMV0pfSwgJHtwMjU2KHByb29mLnBpX2JbMV1bMF0pfV1dLGAgK1xuICAgICAgICBgWyR7cDI1Nihwcm9vZi5waV9jWzBdKX0sICR7cDI1Nihwcm9vZi5waV9jWzFdKX1dLGAgK1xuICAgICAgICBgWyR7aW5wdXRzfV1gO1xuXG4gICAgcmV0dXJuIFM7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/groth16_exportsoliditycalldata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/groth16_fullprove.js":
/*!*******************************************************!*\
  !*** ./node_modules/snarkjs/src/groth16_fullprove.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16FullProve)\n/* harmony export */ });\n/* harmony import */ var _groth16_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./groth16_prove.js */ \"(rsc)/./node_modules/snarkjs/src/groth16_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function groth16FullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFile, wtns, wtnsCalcOptions);\n    return await (0,_groth16_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFileName, wtns, logger, proverOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9mdWxscHJvdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRStDO0FBQ0U7QUFDZDtBQUNuQyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOztBQUVuQjtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOERBQWM7QUFDeEIsaUJBQWlCLDZEQUFhO0FBQzlCIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2dyb3RoMTZfZnVsbHByb3ZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBncm90aDE2X3Byb3ZlIGZyb20gXCIuL2dyb3RoMTZfcHJvdmUuanNcIjtcbmltcG9ydCB3dG5zX2NhbGN1bGF0ZSBmcm9tIFwiLi93dG5zX2NhbGN1bGF0ZS5qc1wiO1xuaW1wb3J0IHt1dGlsc30gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ3JvdGgxNkZ1bGxQcm92ZShfaW5wdXQsIHdhc21GaWxlLCB6a2V5RmlsZU5hbWUsIGxvZ2dlciwgd3Ruc0NhbGNPcHRpb25zLCBwcm92ZXJPcHRpb25zKSB7XG4gICAgY29uc3QgaW5wdXQgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX2lucHV0KTtcblxuICAgIGNvbnN0IHd0bnM9IHtcbiAgICAgICAgdHlwZTogXCJtZW1cIlxuICAgIH07XG4gICAgYXdhaXQgd3Ruc19jYWxjdWxhdGUoaW5wdXQsIHdhc21GaWxlLCB3dG5zLCB3dG5zQ2FsY09wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCBncm90aDE2X3Byb3ZlKHprZXlGaWxlTmFtZSwgd3RucywgbG9nZ2VyLCBwcm92ZXJPcHRpb25zKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/groth16_fullprove.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/groth16_prove.js":
/*!***************************************************!*\
  !*** ./node_modules/snarkjs/src/groth16_prove.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16Prove)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_5__.utils;\n\nasync function groth16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, sectionsWtns);\n\n    const {fd: fdZKey, sections: sectionsZKey} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, sectionsZKey, undefined, options);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);\n    }\n\n    const curve = zkey.curve;\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    const power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_4__.log2)(zkey.domainSize);\n\n    if (logger) logger.debug(\"Reading Wtns\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, sectionsWtns, 2);\n    if (logger) logger.debug(\"Reading Coeffs\");\n    const buffCoeffs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 4);\n\n    if (logger) logger.debug(\"Building ABC\");\n    const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve, zkey, buffWitness, buffCoeffs, logger);\n\n    const inc = power == Fr.s ? curve.Fr.shift : curve.Fr.w[power+1];\n\n    const buffA = await Fr.ifft(buffA_T, \"\", \"\", logger, \"IFFT_A\");\n    const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);\n    const buffAodd_T = await Fr.fft(buffAodd, \"\", \"\", logger, \"FFT_A\");\n\n    const buffB = await Fr.ifft(buffB_T, \"\", \"\", logger, \"IFFT_B\");\n    const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);\n    const buffBodd_T = await Fr.fft(buffBodd, \"\", \"\", logger, \"FFT_B\");\n\n    const buffC = await Fr.ifft(buffC_T, \"\", \"\", logger, \"IFFT_C\");\n    const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);\n    const buffCodd_T = await Fr.fft(buffCodd, \"\", \"\", logger, \"FFT_C\");\n\n    if (logger) logger.debug(\"Join ABC\");\n    const buffPodd_T = await joinABC(curve, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);\n\n    let proof = {};\n\n    if (logger) logger.debug(\"Reading A Points\");\n    const buffBasesA = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 5);\n    proof.pi_a = await curve.G1.multiExpAffine(buffBasesA, buffWitness, logger, \"multiexp A\");\n\n    if (logger) logger.debug(\"Reading B1 Points\");\n    const buffBasesB1 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 6);\n    let pib1 = await curve.G1.multiExpAffine(buffBasesB1, buffWitness, logger, \"multiexp B1\");\n\n    if (logger) logger.debug(\"Reading B2 Points\");\n    const buffBasesB2 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 7);\n    proof.pi_b = await curve.G2.multiExpAffine(buffBasesB2, buffWitness, logger, \"multiexp B2\");\n\n    if (logger) logger.debug(\"Reading C Points\");\n    const buffBasesC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 8);\n    proof.pi_c = await curve.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic+1)*curve.Fr.n8), logger, \"multiexp C\");\n\n    if (logger) logger.debug(\"Reading H Points\");\n    const buffBasesH = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 9);\n    const resH = await curve.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, \"multiexp H\");\n\n    const r = curve.Fr.random();\n    const s = curve.Fr.random();\n\n    proof.pi_a  = G1.add( proof.pi_a, zkey.vk_alpha_1 );\n    proof.pi_a  = G1.add( proof.pi_a, G1.timesFr( zkey.vk_delta_1, r ));\n\n    proof.pi_b  = G2.add( proof.pi_b, zkey.vk_beta_2 );\n    proof.pi_b  = G2.add( proof.pi_b, G2.timesFr( zkey.vk_delta_2, s ));\n\n    pib1 = G1.add( pib1, zkey.vk_beta_1 );\n    pib1 = G1.add( pib1, G1.timesFr( zkey.vk_delta_1, s ));\n\n    proof.pi_c = G1.add(proof.pi_c, resH);\n\n\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( proof.pi_a, s ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( pib1, r ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( zkey.vk_delta_1, Fr.neg(Fr.mul(r,s) )));\n\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const b = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.fromRprLE(b));\n    }\n\n    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));\n    proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));\n    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));\n\n    proof.protocol = \"groth16\";\n    proof.curve = curve.name;\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    proof = stringifyBigInts(proof);\n    publicSignals = stringifyBigInts(publicSignals);\n\n    return {proof, publicSignals};\n}\n\n\nasync function buildABC1(curve, zkey, witness, coeffs, logger) {\n    const n8 = curve.Fr.n8;\n    const sCoef = 4*3 + zkey.n8r;\n    const nCoef = (coeffs.byteLength-4) / sCoef;\n\n    const outBuffA = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n    const outBuffB = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n    const outBuffC = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n\n    const outBuf = [ outBuffA, outBuffB ];\n    for (let i=0; i<nCoef; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP AB: ${i}/${nCoef}`);\n        const buffCoef = coeffs.slice(4+i*sCoef, 4+i*sCoef+sCoef);\n        const buffCoefV = new DataView(buffCoef.buffer);\n        const m= buffCoefV.getUint32(0, true);\n        const c= buffCoefV.getUint32(4, true);\n        const s= buffCoefV.getUint32(8, true);\n        const coef = buffCoef.slice(12, 12+n8);\n        outBuf[m].set(\n            curve.Fr.add(\n                outBuf[m].slice(c*n8, c*n8+n8),\n                curve.Fr.mul(coef, witness.slice(s*n8, s*n8+n8))\n            ),\n            c*n8\n        );\n    }\n\n    for (let i=0; i<zkey.domainSize; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP C: ${i}/${zkey.domainSize}`);\n        outBuffC.set(\n            curve.Fr.mul(\n                outBuffA.slice(i*n8, i*n8+n8),\n                outBuffB.slice(i*n8, i*n8+n8),\n            ),\n            i*n8\n        );\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n}\n\n/*\nasync function buildABC(curve, zkey, witness, coeffs, logger) {\n    const concurrency = curve.tm.concurrency;\n    const sCoef = 4*3 + zkey.n8r;\n\n    let getUint32;\n\n    if (coeffs instanceof BigBuffer) {\n        const coeffsDV = [];\n        const PAGE_LEN = coeffs.buffers[0].length;\n        for (let i=0; i< coeffs.buffers.length; i++) {\n            coeffsDV.push(new DataView(coeffs.buffers[i].buffer));\n        }\n        getUint32 = function (pos) {\n            return coeffsDV[Math.floor(pos/PAGE_LEN)].getUint32(pos % PAGE_LEN, true);\n        };\n    } else {\n        const coeffsDV = new DataView(coeffs.buffer, coeffs.byteOffset, coeffs.byteLength);\n        getUint32 = function (pos) {\n            return coeffsDV.getUint32(pos, true);\n        };\n    }\n\n    const elementsPerChunk = Math.floor(zkey.domainSize/concurrency);\n    const promises = [];\n\n    const cutPoints = [];\n    for (let i=0; i<concurrency; i++) {\n        cutPoints.push( getCutPoint( Math.floor(i*elementsPerChunk) ));\n    }\n    cutPoints.push(coeffs.byteLength);\n\n    const chunkSize = 2**26;\n    for (let s=0 ; s<zkey.nVars ; s+= chunkSize) {\n        if (logger) logger.debug(`QAP ${s}: ${s}/${zkey.nVars}`);\n        const ns= Math.min(zkey.nVars-s, chunkSize );\n\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = elementsPerChunk;\n            } else {\n                n = zkey.domainSize - i*elementsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: coeffs.slice(cutPoints[i], cutPoints[i+1])});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: witness.slice(s*curve.Fr.n8, (s+ns)*curve.Fr.n8)});\n            task.push({cmd: \"ALLOC\", var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 4, len: n*curve.Fr.n8});\n            task.push({cmd: \"CALL\", fnName: \"qap_buildABC\", params:[\n                {var: 0},\n                {val: (cutPoints[i+1] - cutPoints[i])/sCoef},\n                {var: 1},\n                {var: 2},\n                {var: 3},\n                {var: 4},\n                {val: i*elementsPerChunk},\n                {val: n},\n                {val: s},\n                {val: ns}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 1, var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 2, var: 4, len: n*curve.Fr.n8});\n            promises.push(curve.tm.queueAction(task));\n        }\n    }\n\n    let result = await Promise.all(promises);\n\n    const nGroups = result.length / concurrency;\n    if (nGroups>1) {\n        const promises2 = [];\n        for (let i=0; i<concurrency; i++) {\n            const task=[];\n            task.push({cmd: \"ALLOC\", var: 0, len: result[i][0].byteLength});\n            task.push({cmd: \"ALLOC\", var: 1, len: result[i][0].byteLength});\n            for (let m=0; m<3; m++) {\n                task.push({cmd: \"SET\", var: 0, buff: result[i][m]});\n                for (let s=1; s<nGroups; s++) {\n                    task.push({cmd: \"SET\", var: 1, buff: result[s*concurrency + i][m]});\n                    task.push({cmd: \"CALL\", fnName: \"qap_batchAdd\", params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: result[i][m].length/curve.Fr.n8},\n                        {var: 0}\n                    ]});\n                }\n                task.push({cmd: \"GET\", out: m, var: 0, len: result[i][m].length});\n            }\n            promises2.push(curve.tm.queueAction(task));\n        }\n        result = await Promise.all(promises2);\n    }\n\n    const outBuffA = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuffA.set(result[i][0], p);\n        outBuffB.set(result[i][1], p);\n        outBuffC.set(result[i][2], p);\n        p += result[i][0].byteLength;\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n    function getCutPoint(v) {\n        let m = 0;\n        let n = getUint32(0);\n        while (m < n) {\n            var k = Math.floor((n + m) / 2);\n            const va = getUint32(4 + k*sCoef + 4);\n            if (va > v) {\n                n = k - 1;\n            } else if (va < v) {\n                m = k + 1;\n            } else {\n                n = k;\n            }\n        }\n        return 4 + m*sCoef;\n    }\n}\n*/\n\nasync function joinABC(curve, zkey, a, b, c, logger) {\n    const MAX_CHUNK_SIZE = 1 << 22;\n\n    const n8 = curve.Fr.n8;\n    const nElements = Math.floor(a.byteLength / curve.Fr.n8);\n\n    const promises = [];\n\n    for (let i=0; i<nElements; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`JoinABC: ${i}/${nElements}`);\n        const n= Math.min(nElements - i, MAX_CHUNK_SIZE);\n\n        const task = [];\n\n        const aChunk = a.slice(i*n8, (i + n)*n8 );\n        const bChunk = b.slice(i*n8, (i + n)*n8 );\n        const cChunk = c.slice(i*n8, (i + n)*n8 );\n\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: aChunk});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: bChunk});\n        task.push({cmd: \"ALLOCSET\", var: 2, buff: cChunk});\n        task.push({cmd: \"ALLOC\", var: 3, len: n*n8});\n        task.push({cmd: \"CALL\", fnName: \"qap_joinABC\", params:[\n            {var: 0},\n            {var: 1},\n            {var: 2},\n            {val: n},\n            {var: 3},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"frm_batchFromMontgomery\", params:[\n            {var: 3},\n            {val: n},\n            {var: 3}\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 3, len: n*n8});\n        promises.push(curve.tm.queueAction(task));\n    }\n\n    const result = await Promise.all(promises);\n\n    let outBuff;\n    if (a instanceof ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer) {\n        outBuff = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(a.byteLength);\n    } else {\n        outBuff = new Uint8Array(a.byteLength);\n    }\n\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuff.set(result[i][0], p);\n        p += result[i][0].byteLength;\n    }\n\n    return outBuff;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9wcm92ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDUDtBQUNBO0FBQ1c7QUFDdkI7QUFDdUI7QUFDeEQsT0FBTyxrQkFBa0IsRUFBRSwrQ0FBSzs7QUFFakI7QUFDZixXQUFXLG9DQUFvQyxRQUFRLDREQUF3Qjs7QUFFL0UsdUJBQXVCLHNEQUFvQjs7QUFFM0MsV0FBVyxvQ0FBb0MsUUFBUSw0REFBd0I7O0FBRS9FLHVCQUF1QixzREFBb0I7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGdEQUFNO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxXQUFXLGFBQWEsY0FBYztBQUNsRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsOENBQUk7O0FBRXRCO0FBQ0EsOEJBQThCLDREQUF3QjtBQUN0RDtBQUNBLDZCQUE2Qiw0REFBd0I7O0FBRXJEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2Qiw0REFBd0I7QUFDckQ7O0FBRUE7QUFDQSw4QkFBOEIsNERBQXdCO0FBQ3REOztBQUVBO0FBQ0EsOEJBQThCLDREQUF3QjtBQUN0RDs7QUFFQTtBQUNBLDZCQUE2Qiw0REFBd0I7QUFDckQ7O0FBRUE7QUFDQSw2QkFBNkIsNERBQXdCO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLDJCQUEyQixnREFBTTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsbURBQVM7QUFDbEMseUJBQXlCLG1EQUFTO0FBQ2xDLHlCQUF5QixtREFBUzs7QUFFbEM7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixnRUFBZ0UsRUFBRSxHQUFHLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDLCtEQUErRCxFQUFFLEdBQUcsZ0JBQWdCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLHdDQUF3QyxFQUFFLElBQUksRUFBRSxHQUFHLFdBQVc7QUFDOUQ7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsMEVBQTBFO0FBQ2pHLHVCQUF1QixnRkFBZ0Y7QUFDdkcsdUJBQXVCLHlDQUF5QztBQUNoRSx1QkFBdUIseUNBQXlDO0FBQ2hFLHVCQUF1Qix5Q0FBeUM7QUFDaEUsdUJBQXVCO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQiwyQ0FBMkM7QUFDNUQsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLHdCQUF3QjtBQUN6QyxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUI7QUFDakIsY0FBYztBQUNkLHVCQUF1QiwrQ0FBK0M7QUFDdEUsdUJBQXVCLCtDQUErQztBQUN0RSx1QkFBdUIsK0NBQStDO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBLHVCQUF1QixtREFBbUQ7QUFDMUUsdUJBQXVCLG1EQUFtRDtBQUMxRSwwQkFBMEIsS0FBSztBQUMvQiwyQkFBMkIsdUNBQXVDO0FBQ2xFLDhCQUE4QixXQUFXO0FBQ3pDLCtCQUErQix1REFBdUQ7QUFDdEYsK0JBQStCO0FBQy9CLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixxQ0FBcUM7QUFDOUQseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBLDJCQUEyQixxREFBcUQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQiw2Q0FBNkMsRUFBRSxHQUFHLFVBQVU7QUFDNUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQ0FBc0M7QUFDekQsbUJBQW1CLHNDQUFzQztBQUN6RCxtQkFBbUIsc0NBQXNDO0FBQ3pELG1CQUFtQixnQ0FBZ0M7QUFDbkQsbUJBQW1CO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsVUFBVTtBQUNWLG1CQUFtQjtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWE7QUFDYixVQUFVO0FBQ1YsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLG1EQUFTO0FBQzlCLHNCQUFzQixtREFBUztBQUMvQixNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9wcm92ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHprZXlVdGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyB3dG5zVXRpbHMgZnJvbSBcIi4vd3Ruc191dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSBhcyBnZXRDdXJ2ZSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHsgbG9nMiB9IGZyb20gXCIuL21pc2MuanNcIjtcbmltcG9ydCB7IFNjYWxhciwgdXRpbHMsIEJpZ0J1ZmZlciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHtzdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBncm90aDE2UHJvdmUoemtleUZpbGVOYW1lLCB3aXRuZXNzRmlsZU5hbWUsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtmZDogZmRXdG5zLCBzZWN0aW9uczogc2VjdGlvbnNXdG5zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh3aXRuZXNzRmlsZU5hbWUsIFwid3Ruc1wiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgY29uc3Qgd3RucyA9IGF3YWl0IHd0bnNVdGlscy5yZWFkSGVhZGVyKGZkV3Rucywgc2VjdGlvbnNXdG5zKTtcblxuICAgIGNvbnN0IHtmZDogZmRaS2V5LCBzZWN0aW9uczogc2VjdGlvbnNaS2V5fSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkWktleSwgc2VjdGlvbnNaS2V5LCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHprZXkucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGlmICghU2NhbGFyLmVxKHprZXkuciwgIHd0bnMucSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VydmUgb2YgdGhlIHdpdG5lc3MgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnZlIG9mIHRoZSBwcm92aW5nIGtleVwiKTtcbiAgICB9XG5cbiAgICBpZiAod3Rucy5uV2l0bmVzcyAhPSB6a2V5Lm5WYXJzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3aXRuZXNzIGxlbmd0aC4gQ2lyY3VpdDogJHt6a2V5Lm5WYXJzfSwgd2l0bmVzczogJHt3dG5zLm5XaXRuZXNzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gemtleS5jdXJ2ZTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRzIgPSBjdXJ2ZS5HMjtcblxuICAgIGNvbnN0IHBvd2VyID0gbG9nMih6a2V5LmRvbWFpblNpemUpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiUmVhZGluZyBXdG5zXCIpO1xuICAgIGNvbnN0IGJ1ZmZXaXRuZXNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkV3Rucywgc2VjdGlvbnNXdG5zLCAyKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIENvZWZmc1wiKTtcbiAgICBjb25zdCBidWZmQ29lZmZzID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA0KTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkJ1aWxkaW5nIEFCQ1wiKTtcbiAgICBjb25zdCBbYnVmZkFfVCwgYnVmZkJfVCwgYnVmZkNfVF0gPSBhd2FpdCBidWlsZEFCQzEoY3VydmUsIHprZXksIGJ1ZmZXaXRuZXNzLCBidWZmQ29lZmZzLCBsb2dnZXIpO1xuXG4gICAgY29uc3QgaW5jID0gcG93ZXIgPT0gRnIucyA/IGN1cnZlLkZyLnNoaWZ0IDogY3VydmUuRnIud1twb3dlcisxXTtcblxuICAgIGNvbnN0IGJ1ZmZBID0gYXdhaXQgRnIuaWZmdChidWZmQV9ULCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiSUZGVF9BXCIpO1xuICAgIGNvbnN0IGJ1ZmZBb2RkID0gYXdhaXQgRnIuYmF0Y2hBcHBseUtleShidWZmQSwgRnIuZSgxKSwgaW5jKTtcbiAgICBjb25zdCBidWZmQW9kZF9UID0gYXdhaXQgRnIuZmZ0KGJ1ZmZBb2RkLCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiRkZUX0FcIik7XG5cbiAgICBjb25zdCBidWZmQiA9IGF3YWl0IEZyLmlmZnQoYnVmZkJfVCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIklGRlRfQlwiKTtcbiAgICBjb25zdCBidWZmQm9kZCA9IGF3YWl0IEZyLmJhdGNoQXBwbHlLZXkoYnVmZkIsIEZyLmUoMSksIGluYyk7XG4gICAgY29uc3QgYnVmZkJvZGRfVCA9IGF3YWl0IEZyLmZmdChidWZmQm9kZCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIkZGVF9CXCIpO1xuXG4gICAgY29uc3QgYnVmZkMgPSBhd2FpdCBGci5pZmZ0KGJ1ZmZDX1QsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJJRkZUX0NcIik7XG4gICAgY29uc3QgYnVmZkNvZGQgPSBhd2FpdCBGci5iYXRjaEFwcGx5S2V5KGJ1ZmZDLCBGci5lKDEpLCBpbmMpO1xuICAgIGNvbnN0IGJ1ZmZDb2RkX1QgPSBhd2FpdCBGci5mZnQoYnVmZkNvZGQsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJGRlRfQ1wiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkpvaW4gQUJDXCIpO1xuICAgIGNvbnN0IGJ1ZmZQb2RkX1QgPSBhd2FpdCBqb2luQUJDKGN1cnZlLCB6a2V5LCBidWZmQW9kZF9ULCBidWZmQm9kZF9ULCBidWZmQ29kZF9ULCBsb2dnZXIpO1xuXG4gICAgbGV0IHByb29mID0ge307XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEEgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0EgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDUpO1xuICAgIHByb29mLnBpX2EgPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShidWZmQmFzZXNBLCBidWZmV2l0bmVzcywgbG9nZ2VyLCBcIm11bHRpZXhwIEFcIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEIxIFBvaW50c1wiKTtcbiAgICBjb25zdCBidWZmQmFzZXNCMSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNik7XG4gICAgbGV0IHBpYjEgPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShidWZmQmFzZXNCMSwgYnVmZldpdG5lc3MsIGxvZ2dlciwgXCJtdWx0aWV4cCBCMVwiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQjIgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0IyID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA3KTtcbiAgICBwcm9vZi5waV9iID0gYXdhaXQgY3VydmUuRzIubXVsdGlFeHBBZmZpbmUoYnVmZkJhc2VzQjIsIGJ1ZmZXaXRuZXNzLCBsb2dnZXIsIFwibXVsdGlleHAgQjJcIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEMgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDgpO1xuICAgIHByb29mLnBpX2MgPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShidWZmQmFzZXNDLCBidWZmV2l0bmVzcy5zbGljZSgoemtleS5uUHVibGljKzEpKmN1cnZlLkZyLm44KSwgbG9nZ2VyLCBcIm11bHRpZXhwIENcIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEggUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0ggPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDkpO1xuICAgIGNvbnN0IHJlc0ggPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShidWZmQmFzZXNILCBidWZmUG9kZF9ULCBsb2dnZXIsIFwibXVsdGlleHAgSFwiKTtcblxuICAgIGNvbnN0IHIgPSBjdXJ2ZS5Gci5yYW5kb20oKTtcbiAgICBjb25zdCBzID0gY3VydmUuRnIucmFuZG9tKCk7XG5cbiAgICBwcm9vZi5waV9hICA9IEcxLmFkZCggcHJvb2YucGlfYSwgemtleS52a19hbHBoYV8xICk7XG4gICAgcHJvb2YucGlfYSAgPSBHMS5hZGQoIHByb29mLnBpX2EsIEcxLnRpbWVzRnIoIHprZXkudmtfZGVsdGFfMSwgciApKTtcblxuICAgIHByb29mLnBpX2IgID0gRzIuYWRkKCBwcm9vZi5waV9iLCB6a2V5LnZrX2JldGFfMiApO1xuICAgIHByb29mLnBpX2IgID0gRzIuYWRkKCBwcm9vZi5waV9iLCBHMi50aW1lc0ZyKCB6a2V5LnZrX2RlbHRhXzIsIHMgKSk7XG5cbiAgICBwaWIxID0gRzEuYWRkKCBwaWIxLCB6a2V5LnZrX2JldGFfMSApO1xuICAgIHBpYjEgPSBHMS5hZGQoIHBpYjEsIEcxLnRpbWVzRnIoIHprZXkudmtfZGVsdGFfMSwgcyApKTtcblxuICAgIHByb29mLnBpX2MgPSBHMS5hZGQocHJvb2YucGlfYywgcmVzSCk7XG5cblxuICAgIHByb29mLnBpX2MgID0gRzEuYWRkKCBwcm9vZi5waV9jLCBHMS50aW1lc0ZyKCBwcm9vZi5waV9hLCBzICkpO1xuICAgIHByb29mLnBpX2MgID0gRzEuYWRkKCBwcm9vZi5waV9jLCBHMS50aW1lc0ZyKCBwaWIxLCByICkpO1xuICAgIHByb29mLnBpX2MgID0gRzEuYWRkKCBwcm9vZi5waV9jLCBHMS50aW1lc0ZyKCB6a2V5LnZrX2RlbHRhXzEsIEZyLm5lZyhGci5tdWwocixzKSApKSk7XG5cblxuICAgIGxldCBwdWJsaWNTaWduYWxzID0gW107XG5cbiAgICBmb3IgKGxldCBpPTE7IGk8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBiID0gYnVmZldpdG5lc3Muc2xpY2UoaSpGci5uOCwgaSpGci5uOCtGci5uOCk7XG4gICAgICAgIHB1YmxpY1NpZ25hbHMucHVzaChTY2FsYXIuZnJvbVJwckxFKGIpKTtcbiAgICB9XG5cbiAgICBwcm9vZi5waV9hID0gRzEudG9PYmplY3QoRzEudG9BZmZpbmUocHJvb2YucGlfYSkpO1xuICAgIHByb29mLnBpX2IgPSBHMi50b09iamVjdChHMi50b0FmZmluZShwcm9vZi5waV9iKSk7XG4gICAgcHJvb2YucGlfYyA9IEcxLnRvT2JqZWN0KEcxLnRvQWZmaW5lKHByb29mLnBpX2MpKTtcblxuICAgIHByb29mLnByb3RvY29sID0gXCJncm90aDE2XCI7XG4gICAgcHJvb2YuY3VydmUgPSBjdXJ2ZS5uYW1lO1xuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG5cbiAgICBwcm9vZiA9IHN0cmluZ2lmeUJpZ0ludHMocHJvb2YpO1xuICAgIHB1YmxpY1NpZ25hbHMgPSBzdHJpbmdpZnlCaWdJbnRzKHB1YmxpY1NpZ25hbHMpO1xuXG4gICAgcmV0dXJuIHtwcm9vZiwgcHVibGljU2lnbmFsc307XG59XG5cblxuYXN5bmMgZnVuY3Rpb24gYnVpbGRBQkMxKGN1cnZlLCB6a2V5LCB3aXRuZXNzLCBjb2VmZnMsIGxvZ2dlcikge1xuICAgIGNvbnN0IG44ID0gY3VydmUuRnIubjg7XG4gICAgY29uc3Qgc0NvZWYgPSA0KjMgKyB6a2V5Lm44cjtcbiAgICBjb25zdCBuQ29lZiA9IChjb2VmZnMuYnl0ZUxlbmd0aC00KSAvIHNDb2VmO1xuXG4gICAgY29uc3Qgb3V0QnVmZkEgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIG44KTtcbiAgICBjb25zdCBvdXRCdWZmQiA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogbjgpO1xuICAgIGNvbnN0IG91dEJ1ZmZDID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBuOCk7XG5cbiAgICBjb25zdCBvdXRCdWYgPSBbIG91dEJ1ZmZBLCBvdXRCdWZmQiBdO1xuICAgIGZvciAobGV0IGk9MDsgaTxuQ29lZjsgaSsrKSB7XG4gICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGBRQVAgQUI6ICR7aX0vJHtuQ29lZn1gKTtcbiAgICAgICAgY29uc3QgYnVmZkNvZWYgPSBjb2VmZnMuc2xpY2UoNCtpKnNDb2VmLCA0K2kqc0NvZWYrc0NvZWYpO1xuICAgICAgICBjb25zdCBidWZmQ29lZlYgPSBuZXcgRGF0YVZpZXcoYnVmZkNvZWYuYnVmZmVyKTtcbiAgICAgICAgY29uc3QgbT0gYnVmZkNvZWZWLmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICAgICAgY29uc3QgYz0gYnVmZkNvZWZWLmdldFVpbnQzMig0LCB0cnVlKTtcbiAgICAgICAgY29uc3Qgcz0gYnVmZkNvZWZWLmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgICAgY29uc3QgY29lZiA9IGJ1ZmZDb2VmLnNsaWNlKDEyLCAxMituOCk7XG4gICAgICAgIG91dEJ1ZlttXS5zZXQoXG4gICAgICAgICAgICBjdXJ2ZS5Gci5hZGQoXG4gICAgICAgICAgICAgICAgb3V0QnVmW21dLnNsaWNlKGMqbjgsIGMqbjgrbjgpLFxuICAgICAgICAgICAgICAgIGN1cnZlLkZyLm11bChjb2VmLCB3aXRuZXNzLnNsaWNlKHMqbjgsIHMqbjgrbjgpKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMqbjhcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYFFBUCBDOiAke2l9LyR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICBvdXRCdWZmQy5zZXQoXG4gICAgICAgICAgICBjdXJ2ZS5Gci5tdWwoXG4gICAgICAgICAgICAgICAgb3V0QnVmZkEuc2xpY2UoaSpuOCwgaSpuOCtuOCksXG4gICAgICAgICAgICAgICAgb3V0QnVmZkIuc2xpY2UoaSpuOCwgaSpuOCtuOCksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgaSpuOFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBbb3V0QnVmZkEsIG91dEJ1ZmZCLCBvdXRCdWZmQ107XG5cbn1cblxuLypcbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkQUJDKGN1cnZlLCB6a2V5LCB3aXRuZXNzLCBjb2VmZnMsIGxvZ2dlcikge1xuICAgIGNvbnN0IGNvbmN1cnJlbmN5ID0gY3VydmUudG0uY29uY3VycmVuY3k7XG4gICAgY29uc3Qgc0NvZWYgPSA0KjMgKyB6a2V5Lm44cjtcblxuICAgIGxldCBnZXRVaW50MzI7XG5cbiAgICBpZiAoY29lZmZzIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGNvZWZmc0RWID0gW107XG4gICAgICAgIGNvbnN0IFBBR0VfTEVOID0gY29lZmZzLmJ1ZmZlcnNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IGNvZWZmcy5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2VmZnNEVi5wdXNoKG5ldyBEYXRhVmlldyhjb2VmZnMuYnVmZmVyc1tpXS5idWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRVaW50MzIgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gY29lZmZzRFZbTWF0aC5mbG9vcihwb3MvUEFHRV9MRU4pXS5nZXRVaW50MzIocG9zICUgUEFHRV9MRU4sIHRydWUpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvZWZmc0RWID0gbmV3IERhdGFWaWV3KGNvZWZmcy5idWZmZXIsIGNvZWZmcy5ieXRlT2Zmc2V0LCBjb2VmZnMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGdldFVpbnQzMiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2VmZnNEVi5nZXRVaW50MzIocG9zLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50c1BlckNodW5rID0gTWF0aC5mbG9vcih6a2V5LmRvbWFpblNpemUvY29uY3VycmVuY3kpO1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICBjb25zdCBjdXRQb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICBjdXRQb2ludHMucHVzaCggZ2V0Q3V0UG9pbnQoIE1hdGguZmxvb3IoaSplbGVtZW50c1BlckNodW5rKSApKTtcbiAgICB9XG4gICAgY3V0UG9pbnRzLnB1c2goY29lZmZzLmJ5dGVMZW5ndGgpO1xuXG4gICAgY29uc3QgY2h1bmtTaXplID0gMioqMjY7XG4gICAgZm9yIChsZXQgcz0wIDsgczx6a2V5Lm5WYXJzIDsgcys9IGNodW5rU2l6ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYFFBUCAke3N9OiAke3N9LyR7emtleS5uVmFyc31gKTtcbiAgICAgICAgY29uc3QgbnM9IE1hdGgubWluKHprZXkublZhcnMtcywgY2h1bmtTaXplICk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGk8IGNvbmN1cnJlbmN5LTEpIHtcbiAgICAgICAgICAgICAgICBuID0gZWxlbWVudHNQZXJDaHVuaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IHprZXkuZG9tYWluU2l6ZSAtIGkqZWxlbWVudHNQZXJDaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuPT0wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGNvZWZmcy5zbGljZShjdXRQb2ludHNbaV0sIGN1dFBvaW50c1tpKzFdKX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiB3aXRuZXNzLnNsaWNlKHMqY3VydmUuRnIubjgsIChzK25zKSpjdXJ2ZS5Gci5uOCl9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMiwgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDMsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiA0LCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcInFhcF9idWlsZEFCQ1wiLCBwYXJhbXM6W1xuICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgIHt2YWw6IChjdXRQb2ludHNbaSsxXSAtIGN1dFBvaW50c1tpXSkvc0NvZWZ9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDR9LFxuICAgICAgICAgICAgICAgIHt2YWw6IGkqZWxlbWVudHNQZXJDaHVua30sXG4gICAgICAgICAgICAgICAge3ZhbDogbn0sXG4gICAgICAgICAgICAgICAge3ZhbDogc30sXG4gICAgICAgICAgICAgICAge3ZhbDogbnN9XG4gICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDIsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMSwgdmFyOiAzLCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDIsIHZhcjogNCwgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICBjb25zdCBuR3JvdXBzID0gcmVzdWx0Lmxlbmd0aCAvIGNvbmN1cnJlbmN5O1xuICAgIGlmIChuR3JvdXBzPjEpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMyID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrPVtdO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAwLCBsZW46IHJlc3VsdFtpXVswXS5ieXRlTGVuZ3RofSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDEsIGxlbjogcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGh9KTtcbiAgICAgICAgICAgIGZvciAobGV0IG09MDsgbTwzOyBtKyspIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJTRVRcIiwgdmFyOiAwLCBidWZmOiByZXN1bHRbaV1bbV19KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzPTE7IHM8bkdyb3VwczsgcysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIlNFVFwiLCB2YXI6IDEsIGJ1ZmY6IHJlc3VsdFtzKmNvbmN1cnJlbmN5ICsgaV1bbV19KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwicWFwX2JhdGNoQWRkXCIsIHBhcmFtczpbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogcmVzdWx0W2ldW21dLmxlbmd0aC9jdXJ2ZS5Gci5uOH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfVxuICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IG0sIHZhcjogMCwgbGVuOiByZXN1bHRbaV1bbV0ubGVuZ3RofSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlczIucHVzaChjdXJ2ZS50bS5xdWV1ZUFjdGlvbih0YXNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMyKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRCdWZmQSA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogY3VydmUuRnIubjgpO1xuICAgIGNvbnN0IG91dEJ1ZmZCID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBjdXJ2ZS5Gci5uOCk7XG4gICAgY29uc3Qgb3V0QnVmZkMgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIGN1cnZlLkZyLm44KTtcbiAgICBsZXQgcD0wO1xuICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0QnVmZkEuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgIG91dEJ1ZmZCLnNldChyZXN1bHRbaV1bMV0sIHApO1xuICAgICAgICBvdXRCdWZmQy5zZXQocmVzdWx0W2ldWzJdLCBwKTtcbiAgICAgICAgcCArPSByZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gW291dEJ1ZmZBLCBvdXRCdWZmQiwgb3V0QnVmZkNdO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q3V0UG9pbnQodikge1xuICAgICAgICBsZXQgbSA9IDA7XG4gICAgICAgIGxldCBuID0gZ2V0VWludDMyKDApO1xuICAgICAgICB3aGlsZSAobSA8IG4pIHtcbiAgICAgICAgICAgIHZhciBrID0gTWF0aC5mbG9vcigobiArIG0pIC8gMik7XG4gICAgICAgICAgICBjb25zdCB2YSA9IGdldFVpbnQzMig0ICsgaypzQ29lZiArIDQpO1xuICAgICAgICAgICAgaWYgKHZhID4gdikge1xuICAgICAgICAgICAgICAgIG4gPSBrIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmEgPCB2KSB7XG4gICAgICAgICAgICAgICAgbSA9IGsgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gNCArIG0qc0NvZWY7XG4gICAgfVxufVxuKi9cblxuYXN5bmMgZnVuY3Rpb24gam9pbkFCQyhjdXJ2ZSwgemtleSwgYSwgYiwgYywgbG9nZ2VyKSB7XG4gICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxIDw8IDIyO1xuXG4gICAgY29uc3QgbjggPSBjdXJ2ZS5Gci5uODtcbiAgICBjb25zdCBuRWxlbWVudHMgPSBNYXRoLmZsb29yKGEuYnl0ZUxlbmd0aCAvIGN1cnZlLkZyLm44KTtcblxuICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8bkVsZW1lbnRzOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSm9pbkFCQzogJHtpfS8ke25FbGVtZW50c31gKTtcbiAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4obkVsZW1lbnRzIC0gaSwgTUFYX0NIVU5LX1NJWkUpO1xuXG4gICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcblxuICAgICAgICBjb25zdCBhQ2h1bmsgPSBhLnNsaWNlKGkqbjgsIChpICsgbikqbjggKTtcbiAgICAgICAgY29uc3QgYkNodW5rID0gYi5zbGljZShpKm44LCAoaSArIG4pKm44ICk7XG4gICAgICAgIGNvbnN0IGNDaHVuayA9IGMuc2xpY2UoaSpuOCwgKGkgKyBuKSpuOCApO1xuXG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYUNodW5rfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYkNodW5rfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMiwgYnVmZjogY0NodW5rfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMywgbGVuOiBuKm44fSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcInFhcF9qb2luQUJDXCIsIHBhcmFtczpbXG4gICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcImZybV9iYXRjaEZyb21Nb250Z29tZXJ5XCIsIHBhcmFtczpbXG4gICAgICAgICAgICB7dmFyOiAzfSxcbiAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAge3ZhcjogM31cbiAgICAgICAgXX0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDMsIGxlbjogbipuOH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICBsZXQgb3V0QnVmZjtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIEJpZ0J1ZmZlcikge1xuICAgICAgICBvdXRCdWZmID0gbmV3IEJpZ0J1ZmZlcihhLmJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dEJ1ZmYgPSBuZXcgVWludDhBcnJheShhLmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIGxldCBwPTA7XG4gICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRCdWZmLnNldChyZXN1bHRbaV1bMF0sIHApO1xuICAgICAgICBwICs9IHJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRCdWZmO1xufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/groth16_prove.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/groth16_verify.js":
/*!****************************************************!*\
  !*** ./node_modules/snarkjs/src/groth16_verify.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16Verify)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2016/260.pdf */\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {\n/*\n    let cpub = vk_verifier.IC[0];\n    for (let s= 0; s< vk_verifier.nPublic; s++) {\n        cpub  = G1.add( cpub, G1.timesScalar( vk_verifier.IC[s+1], publicSignals[s]));\n    }\n*/\n\n    const vk_verifier = unstringifyBigInts(_vk_verifier);\n    const proof = unstringifyBigInts(_proof);\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_1__.getCurveFromName(vk_verifier.curve);\n\n    const IC0 = curve.G1.fromObject(vk_verifier.IC[0]);\n    const IC = new Uint8Array(curve.G1.F.n8*2 * publicSignals.length);\n    const w = new Uint8Array(curve.Fr.n8 * publicSignals.length);\n\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    for (let i=0; i<publicSignals.length; i++) {\n        const buffP = curve.G1.fromObject(vk_verifier.IC[i+1]);\n        IC.set(buffP, i*curve.G1.F.n8*2);\n        ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(w, curve.Fr.n8*i, publicSignals[i], curve.Fr.n8);\n    }\n\n    let cpub = await curve.G1.multiExpAffine(IC, w);\n    cpub = curve.G1.add(cpub, IC0);\n\n    const pi_a = curve.G1.fromObject(proof.pi_a);\n    const pi_b = curve.G2.fromObject(proof.pi_b);\n    const pi_c = curve.G1.fromObject(proof.pi_c);\n\n    if (!isWellConstructed(curve, {pi_a, pi_b, pi_c})) {\n        if(logger) logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    const vk_gamma_2 = curve.G2.fromObject(vk_verifier.vk_gamma_2);\n    const vk_delta_2 = curve.G2.fromObject(vk_verifier.vk_delta_2);\n    const vk_alpha_1 = curve.G1.fromObject(vk_verifier.vk_alpha_1);\n    const vk_beta_2 = curve.G2.fromObject(vk_verifier.vk_beta_2);\n\n    const res = await curve.pairingEq(\n        curve.G1.neg(pi_a) , pi_b,\n        cpub , vk_gamma_2,\n        pi_c , vk_delta_2,\n\n        vk_alpha_1, vk_beta_2\n    );\n\n    if (! res) {\n        if (logger) logger.error(\"Invalid proof\");\n        return false;\n    }\n\n    if (logger) logger.info(\"OK!\");\n    return true;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    return G1.isValid(proof.pi_a)\n        && G2.isValid(proof.pi_b)\n        && G1.isValid(proof.pi_c);\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.geq(value, 0) && ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.lt(value, curve.r);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl92ZXJpZnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzQztBQUNBO0FBQ0U7QUFDeEMsT0FBTyxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFbkI7QUFDZjtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix3REFBdUI7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQSxRQUFRLGdEQUFNO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnREFBTSxrQkFBa0IsZ0RBQU07QUFDekM7O0FBRUE7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9ncm90aDE2X3ZlcmlmeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGlzIHBhcGVyOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE2LzI2MC5wZGYgKi9cbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCAqIGFzIGN1cnZlcyBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ3JvdGgxNlZlcmlmeShfdmtfdmVyaWZpZXIsIF9wdWJsaWNTaWduYWxzLCBfcHJvb2YsIGxvZ2dlcikge1xuLypcbiAgICBsZXQgY3B1YiA9IHZrX3ZlcmlmaWVyLklDWzBdO1xuICAgIGZvciAobGV0IHM9IDA7IHM8IHZrX3ZlcmlmaWVyLm5QdWJsaWM7IHMrKykge1xuICAgICAgICBjcHViICA9IEcxLmFkZCggY3B1YiwgRzEudGltZXNTY2FsYXIoIHZrX3ZlcmlmaWVyLklDW3MrMV0sIHB1YmxpY1NpZ25hbHNbc10pKTtcbiAgICB9XG4qL1xuXG4gICAgY29uc3QgdmtfdmVyaWZpZXIgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3ZrX3ZlcmlmaWVyKTtcbiAgICBjb25zdCBwcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpO1xuICAgIGNvbnN0IHB1YmxpY1NpZ25hbHMgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3B1YmxpY1NpZ25hbHMpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBjdXJ2ZXMuZ2V0Q3VydmVGcm9tTmFtZSh2a192ZXJpZmllci5jdXJ2ZSk7XG5cbiAgICBjb25zdCBJQzAgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrX3ZlcmlmaWVyLklDWzBdKTtcbiAgICBjb25zdCBJQyA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcxLkYubjgqMiAqIHB1YmxpY1NpZ25hbHMubGVuZ3RoKTtcbiAgICBjb25zdCB3ID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRnIubjggKiBwdWJsaWNTaWduYWxzLmxlbmd0aCk7XG5cbiAgICBpZiAoIXB1YmxpY0lucHV0c0FyZVZhbGlkKGN1cnZlLCBwdWJsaWNTaWduYWxzKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQdWJsaWMgaW5wdXRzIGFyZSBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaT0wOyBpPHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmZlAgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrX3ZlcmlmaWVyLklDW2krMV0pO1xuICAgICAgICBJQy5zZXQoYnVmZlAsIGkqY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgU2NhbGFyLnRvUnByTEUodywgY3VydmUuRnIubjgqaSwgcHVibGljU2lnbmFsc1tpXSwgY3VydmUuRnIubjgpO1xuICAgIH1cblxuICAgIGxldCBjcHViID0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoSUMsIHcpO1xuICAgIGNwdWIgPSBjdXJ2ZS5HMS5hZGQoY3B1YiwgSUMwKTtcblxuICAgIGNvbnN0IHBpX2EgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHByb29mLnBpX2EpO1xuICAgIGNvbnN0IHBpX2IgPSBjdXJ2ZS5HMi5mcm9tT2JqZWN0KHByb29mLnBpX2IpO1xuICAgIGNvbnN0IHBpX2MgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHByb29mLnBpX2MpO1xuXG4gICAgaWYgKCFpc1dlbGxDb25zdHJ1Y3RlZChjdXJ2ZSwge3BpX2EsIHBpX2IsIHBpX2N9KSkge1xuICAgICAgICBpZihsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlByb29mIGNvbW1pdG1lbnRzIGFyZSBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmtfZ2FtbWFfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfZ2FtbWFfMik7XG4gICAgY29uc3QgdmtfZGVsdGFfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfZGVsdGFfMik7XG4gICAgY29uc3QgdmtfYWxwaGFfMSA9IGN1cnZlLkcxLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfYWxwaGFfMSk7XG4gICAgY29uc3QgdmtfYmV0YV8yID0gY3VydmUuRzIuZnJvbU9iamVjdCh2a192ZXJpZmllci52a19iZXRhXzIpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUucGFpcmluZ0VxKFxuICAgICAgICBjdXJ2ZS5HMS5uZWcocGlfYSkgLCBwaV9iLFxuICAgICAgICBjcHViICwgdmtfZ2FtbWFfMixcbiAgICAgICAgcGlfYyAsIHZrX2RlbHRhXzIsXG5cbiAgICAgICAgdmtfYWxwaGFfMSwgdmtfYmV0YV8yXG4gICAgKTtcblxuICAgIGlmICghIHJlcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHByb29mXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJPSyFcIik7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzV2VsbENvbnN0cnVjdGVkKGN1cnZlLCBwcm9vZikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRzIgPSBjdXJ2ZS5HMjtcblxuICAgIHJldHVybiBHMS5pc1ZhbGlkKHByb29mLnBpX2EpXG4gICAgICAgICYmIEcyLmlzVmFsaWQocHJvb2YucGlfYilcbiAgICAgICAgJiYgRzEuaXNWYWxpZChwcm9vZi5waV9jKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tWYWx1ZUJlbG9uZ1RvRmllbGQoY3VydmUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFNjYWxhci5nZXEodmFsdWUsIDApICYmIFNjYWxhci5sdCh2YWx1ZSwgY3VydmUucik7XG59XG5cbmZ1bmN0aW9uIHB1YmxpY0lucHV0c0FyZVZhbGlkKGN1cnZlLCBwdWJsaWNJbnB1dHMpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHVibGljSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKCFjaGVja1ZhbHVlQmVsb25nVG9GaWVsZChjdXJ2ZSwgcHVibGljSW5wdXRzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/groth16_verify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/keypair.js":
/*!*********************************************!*\
  !*** ./node_modules/snarkjs/src/keypair.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeltaKey: () => (/* binding */ createDeltaKey),\n/* harmony export */   createPTauKey: () => (/* binding */ createPTauKey),\n/* harmony export */   getG2sp: () => (/* binding */ getG2sp),\n/* harmony export */   hashToG2: () => (/* binding */ hashToG2)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nfunction hashToG2(curve, hash) {\n    const hashV = new DataView(hash.buffer, hash.byteOffset, hash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = hashV.getUint32(i*4);\n    }\n\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.ChaCha(seed);\n\n    const g2_sp = curve.G2.fromRng(rng);\n\n    return g2_sp;\n}\n\nfunction getG2sp(curve, persinalization, challenge, g1s, g1sx) {\n\n    const h = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_1__.blake2b.create({ dkLen: 64 });\n    const b1 = new Uint8Array([persinalization]);\n    h.update(b1);\n    h.update(challenge);\n    const b3 = curve.G1.toUncompressed(g1s);\n    h.update( b3);\n    const b4 = curve.G1.toUncompressed(g1sx);\n    h.update( b4);\n    const hash =h.digest();\n\n    return hashToG2(curve, hash);\n}\n\nfunction calculatePubKey(k, curve, personalization, challengeHash, rng ) {\n    k.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    k.g1_sx = curve.G1.toAffine(curve.G1.timesFr(k.g1_s, k.prvKey));\n    k.g2_sp = curve.G2.toAffine(getG2sp(curve, personalization, challengeHash, k.g1_s, k.g1_sx));\n    k.g2_spx = curve.G2.toAffine(curve.G2.timesFr(k.g2_sp, k.prvKey));\n    return k;\n}\n\nfunction createPTauKey(curve, challengeHash, rng) {\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n    key.tau.prvKey = curve.Fr.fromRng(rng);\n    key.alpha.prvKey = curve.Fr.fromRng(rng);\n    key.beta.prvKey = curve.Fr.fromRng(rng);\n    calculatePubKey(key.tau, curve, 0, challengeHash, rng);\n    calculatePubKey(key.alpha, curve, 1, challengeHash, rng);\n    calculatePubKey(key.beta, curve, 2, challengeHash, rng);\n    return key;\n}\n\nfunction createDeltaKey(curve, transcript, rng) {\n    const delta = {};\n    delta.prvKey = curve.Fr.fromRng(rng);\n    delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    delta.g1_sx = curve.G1.toAffine(curve.G1.timesScalar(delta.g1_s, delta.prvKey));\n    delta.g2_sp = hashToG2(curve, transcript);\n    delta.g2_spx = curve.G2.toAffine(curve.G2.timesScalar(delta.g2_sp, delta.prvKey));\n    return delta;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMva2V5cGFpci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVnRDs7QUFFVjs7QUFFL0I7QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTs7QUFFQSxvQkFBb0IsZ0RBQU07O0FBRTFCOztBQUVBO0FBQ0E7O0FBRU87O0FBRVAsY0FBYywwREFBTyxVQUFVLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9rZXlwYWlyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5cbmltcG9ydCB7IENoYUNoYSB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb0cyKGN1cnZlLCBoYXNoKSB7XG4gICAgY29uc3QgaGFzaFYgPSBuZXcgRGF0YVZpZXcoaGFzaC5idWZmZXIsIGhhc2guYnl0ZU9mZnNldCwgaGFzaC5ieXRlTGVuZ3RoKTtcbiAgICBjb25zdCBzZWVkID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPDg7IGkrKykge1xuICAgICAgICBzZWVkW2ldID0gaGFzaFYuZ2V0VWludDMyKGkqNCk7XG4gICAgfVxuXG4gICAgY29uc3Qgcm5nID0gbmV3IENoYUNoYShzZWVkKTtcblxuICAgIGNvbnN0IGcyX3NwID0gY3VydmUuRzIuZnJvbVJuZyhybmcpO1xuXG4gICAgcmV0dXJuIGcyX3NwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RzJzcChjdXJ2ZSwgcGVyc2luYWxpemF0aW9uLCBjaGFsbGVuZ2UsIGcxcywgZzFzeCkge1xuXG4gICAgY29uc3QgaCA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIGNvbnN0IGIxID0gbmV3IFVpbnQ4QXJyYXkoW3BlcnNpbmFsaXphdGlvbl0pO1xuICAgIGgudXBkYXRlKGIxKTtcbiAgICBoLnVwZGF0ZShjaGFsbGVuZ2UpO1xuICAgIGNvbnN0IGIzID0gY3VydmUuRzEudG9VbmNvbXByZXNzZWQoZzFzKTtcbiAgICBoLnVwZGF0ZSggYjMpO1xuICAgIGNvbnN0IGI0ID0gY3VydmUuRzEudG9VbmNvbXByZXNzZWQoZzFzeCk7XG4gICAgaC51cGRhdGUoIGI0KTtcbiAgICBjb25zdCBoYXNoID1oLmRpZ2VzdCgpO1xuXG4gICAgcmV0dXJuIGhhc2hUb0cyKGN1cnZlLCBoYXNoKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUHViS2V5KGssIGN1cnZlLCBwZXJzb25hbGl6YXRpb24sIGNoYWxsZW5nZUhhc2gsIHJuZyApIHtcbiAgICBrLmcxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgIGsuZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGsuZzFfcywgay5wcnZLZXkpKTtcbiAgICBrLmcyX3NwID0gY3VydmUuRzIudG9BZmZpbmUoZ2V0RzJzcChjdXJ2ZSwgcGVyc29uYWxpemF0aW9uLCBjaGFsbGVuZ2VIYXNoLCBrLmcxX3MsIGsuZzFfc3gpKTtcbiAgICBrLmcyX3NweCA9IGN1cnZlLkcyLnRvQWZmaW5lKGN1cnZlLkcyLnRpbWVzRnIoay5nMl9zcCwgay5wcnZLZXkpKTtcbiAgICByZXR1cm4gaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBUYXVLZXkoY3VydmUsIGNoYWxsZW5nZUhhc2gsIHJuZykge1xuICAgIGNvbnN0IGtleSA9IHtcbiAgICAgICAgdGF1OiB7fSxcbiAgICAgICAgYWxwaGE6IHt9LFxuICAgICAgICBiZXRhOiB7fVxuICAgIH07XG4gICAga2V5LnRhdS5wcnZLZXkgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAga2V5LmFscGhhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBrZXkuYmV0YS5wcnZLZXkgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAgY2FsY3VsYXRlUHViS2V5KGtleS50YXUsIGN1cnZlLCAwLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuICAgIGNhbGN1bGF0ZVB1YktleShrZXkuYWxwaGEsIGN1cnZlLCAxLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuICAgIGNhbGN1bGF0ZVB1YktleShrZXkuYmV0YSwgY3VydmUsIDIsIGNoYWxsZW5nZUhhc2gsIHJuZyk7XG4gICAgcmV0dXJuIGtleTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlbHRhS2V5KGN1cnZlLCB0cmFuc2NyaXB0LCBybmcpIHtcbiAgICBjb25zdCBkZWx0YSA9IHt9O1xuICAgIGRlbHRhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBkZWx0YS5nMV9zID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEuZnJvbVJuZyhybmcpKTtcbiAgICBkZWx0YS5nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzU2NhbGFyKGRlbHRhLmcxX3MsIGRlbHRhLnBydktleSkpO1xuICAgIGRlbHRhLmcyX3NwID0gaGFzaFRvRzIoY3VydmUsIHRyYW5zY3JpcHQpO1xuICAgIGRlbHRhLmcyX3NweCA9IGN1cnZlLkcyLnRvQWZmaW5lKGN1cnZlLkcyLnRpbWVzU2NhbGFyKGRlbHRhLmcyX3NwLCBkZWx0YS5wcnZLZXkpKTtcbiAgICByZXR1cm4gZGVsdGE7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/keypair.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/loadsyms.js":
/*!**********************************************!*\
  !*** ./node_modules/snarkjs/src/loadsyms.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loadSymbols)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/./node_modules/fastfile/src/fastfile.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nasync function loadSymbols(symFileName) {\n    const sym = {\n        labelIdx2Name: [ \"one\" ],\n        varIdx2Name: [ \"one\" ],\n        componentIdx2Name: []\n    };\n    const fd = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(symFileName);\n    const buff = await fd.read(fd.totalSize);\n    const symsStr = new TextDecoder(\"utf-8\").decode(buff);\n    const lines = symsStr.split(\"\\n\");\n    for (let i=0; i<lines.length; i++) {\n        const arr = lines[i].split(\",\");\n        if (arr.length!=4) continue;\n        if (sym.varIdx2Name[arr[1]]) {\n            sym.varIdx2Name[arr[1]] += \"|\" + arr[3];\n        } else {\n            sym.varIdx2Name[arr[1]] = arr[3];\n        }\n        sym.labelIdx2Name[arr[0]] = arr[3];\n        if (!sym.componentIdx2Name[arr[2]]) {\n            sym.componentIdx2Name[arr[2]] = extractComponent(arr[3]);\n        }\n    }\n\n    await fd.close();\n\n    return sym;\n\n    function extractComponent(name) {\n        const arr = name.split(\".\");\n        arr.pop(); // Remove the lasr element\n        return arr.join(\".\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbG9hZHN5bXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVxQzs7QUFFdEI7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtEQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2xvYWRzeW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBsb2FkU3ltYm9scyhzeW1GaWxlTmFtZSkge1xuICAgIGNvbnN0IHN5bSA9IHtcbiAgICAgICAgbGFiZWxJZHgyTmFtZTogWyBcIm9uZVwiIF0sXG4gICAgICAgIHZhcklkeDJOYW1lOiBbIFwib25lXCIgXSxcbiAgICAgICAgY29tcG9uZW50SWR4Mk5hbWU6IFtdXG4gICAgfTtcbiAgICBjb25zdCBmZCA9IGF3YWl0IGZhc3RGaWxlLnJlYWRFeGlzdGluZyhzeW1GaWxlTmFtZSk7XG4gICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoZmQudG90YWxTaXplKTtcbiAgICBjb25zdCBzeW1zU3RyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIikuZGVjb2RlKGJ1ZmYpO1xuICAgIGNvbnN0IGxpbmVzID0gc3ltc1N0ci5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gbGluZXNbaV0uc3BsaXQoXCIsXCIpO1xuICAgICAgICBpZiAoYXJyLmxlbmd0aCE9NCkgY29udGludWU7XG4gICAgICAgIGlmIChzeW0udmFySWR4Mk5hbWVbYXJyWzFdXSkge1xuICAgICAgICAgICAgc3ltLnZhcklkeDJOYW1lW2FyclsxXV0gKz0gXCJ8XCIgKyBhcnJbM107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzeW0udmFySWR4Mk5hbWVbYXJyWzFdXSA9IGFyclszXTtcbiAgICAgICAgfVxuICAgICAgICBzeW0ubGFiZWxJZHgyTmFtZVthcnJbMF1dID0gYXJyWzNdO1xuICAgICAgICBpZiAoIXN5bS5jb21wb25lbnRJZHgyTmFtZVthcnJbMl1dKSB7XG4gICAgICAgICAgICBzeW0uY29tcG9uZW50SWR4Mk5hbWVbYXJyWzJdXSA9IGV4dHJhY3RDb21wb25lbnQoYXJyWzNdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gc3ltO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdENvbXBvbmVudChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICAgICAgICBhcnIucG9wKCk7IC8vIFJlbW92ZSB0aGUgbGFzciBlbGVtZW50XG4gICAgICAgIHJldHVybiBhcnIuam9pbihcIi5cIik7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/loadsyms.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/misc.js":
/*!******************************************!*\
  !*** ./node_modules/snarkjs/src/misc.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   askEntropy: () => (/* binding */ askEntropy),\n/* harmony export */   bitReverse: () => (/* binding */ bitReverse),\n/* harmony export */   byteArray2hex: () => (/* binding */ byteArray2hex),\n/* harmony export */   cloneHasher: () => (/* binding */ cloneHasher),\n/* harmony export */   formatHash: () => (/* binding */ formatHash),\n/* harmony export */   fromPartialHash: () => (/* binding */ fromPartialHash),\n/* harmony export */   getRandomBytes: () => (/* binding */ getRandomBytes),\n/* harmony export */   getRandomRng: () => (/* binding */ getRandomRng),\n/* harmony export */   hashIsEqual: () => (/* binding */ hashIsEqual),\n/* harmony export */   hex2ByteArray: () => (/* binding */ hex2ByteArray),\n/* harmony export */   log2: () => (/* binding */ log2),\n/* harmony export */   readUInt32BE: () => (/* binding */ readUInt32BE),\n/* harmony export */   rngFromBeaconParams: () => (/* binding */ rngFromBeaconParams),\n/* harmony export */   sameRatio: () => (/* binding */ sameRatio),\n/* harmony export */   sha256digest: () => (/* binding */ sha256digest),\n/* harmony export */   stringifyBigIntsWithField: () => (/* binding */ stringifyBigIntsWithField),\n/* harmony export */   toPartialHash: () => (/* binding */ toPartialHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! readline */ \"readline\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* global window */\n\n\n\n\n\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction bitReverse(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction formatHash(b, title) {\n    const a = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    let S = \"\";\n    for (let i=0; i<4; i++) {\n        if (i>0) S += \"\\n\";\n        S += \"\\t\\t\";\n        for (let j=0; j<4; j++) {\n            if (j>0) S += \" \";\n            S += a.getUint32(i*16+j*4).toString(16).padStart(8, \"0\");\n        }\n    }\n    if (title) S = title + \"\\n\" + S;\n    return S;\n}\n\nfunction hashIsEqual(h1, h2) {\n    if (h1.byteLength != h2.byteLength) return false;\n    var dv1 = new Int8Array(h1);\n    var dv2 = new Int8Array(h2);\n    for (var i = 0 ; i != h1.byteLength ; i++)\n    {\n        if (dv1[i] != dv2[i]) return false;\n    }\n    return true;\n}\n\nfunction cloneHasher(h) {\n    return h.clone();\n}\n\nfunction fromPartialHash(partial) {\n    // NOTE: this is unsafe and uses internal API\n    const buf = partial.subarray(0, 128);\n    const rest = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.u32)(partial.subarray(128));\n    const res = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n    res.buffer.set(buf);\n    (res.v0l = rest[0] | 0), (res.v0h = rest[1] | 0);\n    (res.v1l = rest[2] | 0), (res.v1h = rest[3] | 0);\n    (res.v2l = rest[4] | 0), (res.v2h = rest[5] | 0);\n    (res.v3l = rest[6] | 0), (res.v3h = rest[7] | 0);\n    (res.v4l = rest[8] | 0), (res.v4h = rest[9] | 0);\n    (res.v5l = rest[10] | 0), (res.v5h = rest[11] | 0);\n    (res.v6l = rest[12] | 0), (res.v6h = rest[13] | 0);\n    (res.v7l = rest[14] | 0), (res.v7h = rest[15] | 0);\n    const shift = 2 ** 32;\n    const len = rest[16] + rest[17] * shift;\n    const pos = rest[18] + rest[19] * shift;\n    res.length = len + pos;\n    res.pos = pos;\n    return res;\n}\n\nfunction toPartialHash(hash){\n    // NOTE: this is unsafe and uses internal API\n    const res = new Uint8Array(216);\n    const res32 = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.u32)(res.subarray(128));\n    res.set(hash.buffer);\n    (res32[0] = hash.v0l), (res32[1] = hash.v0h);\n    (res32[2] = hash.v1l), (res32[3] = hash.v1h);\n    (res32[4] = hash.v2l), (res32[5] = hash.v2h);\n    (res32[6] = hash.v3l), (res32[7] = hash.v3h);\n    (res32[8] = hash.v4l), (res32[9] = hash.v4h);\n    (res32[10] = hash.v5l), (res32[11] = hash.v5h);\n    (res32[12] = hash.v6l), (res32[13] = hash.v6h);\n    (res32[14] = hash.v7l), (res32[15] = hash.v7h);\n    res32[18] = hash.pos;\n    res32[16] = hash.length-hash.pos;\n    return res;\n}\n\nasync function sameRatio(curve, g1s, g1sx, g2s, g2sx) {\n    if (curve.G1.isZero(g1s)) return false;\n    if (curve.G1.isZero(g1sx)) return false;\n    if (curve.G2.isZero(g2s)) return false;\n    if (curve.G2.isZero(g2sx)) return false;\n    // return curve.F12.eq(curve.pairing(g1s, g2sx), curve.pairing(g1sx, g2s));\n    const res = await curve.pairingEq(g1s, g2sx, curve.G1.neg(g1sx), g2s);\n    return res;\n}\n\n\nfunction askEntropy() {\n    if (false) {} else {\n        const rl = readline__WEBPACK_IMPORTED_MODULE_0__.createInterface({\n            input: process.stdin,\n            output: process.stdout\n        });\n\n        return new Promise((resolve) => {\n            rl.question(\"Enter a random text. (Entropy): \", (input) => resolve(input) );\n        });\n    }\n}\n\nfunction getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (false) {} else { // NodeJS\n        crypto__WEBPACK_IMPORTED_MODULE_2__.randomFillSync(array);\n    }\n    return array;\n}\n\nasync function sha256digest(data) {\n    if (false) {} else { // NodeJS\n        return crypto__WEBPACK_IMPORTED_MODULE_2__.createHash(\"sha256\").update(data).digest();\n    }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n */\nfunction readUInt32BE(data, offset) {\n    return new DataView(data.buffer).getUint32(offset, false);\n}\n\nasync function getRandomRng(entropy) {\n    // Generate a random Rng\n    while (!entropy) {\n        entropy = await askEntropy();\n    }\n    const hasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create(64);\n    hasher.update(getRandomBytes(64));\n    const enc = new TextEncoder(); // always utf-8\n    hasher.update(enc.encode(entropy));\n    const hash = hasher.digest();\n\n    const seed = [];\n    for (let i=0;i<8;i++) {\n        seed[i] = readUInt32BE(hash, i*4);\n    }\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.ChaCha(seed);\n    return rng;\n}\n\nasync function rngFromBeaconParams(beaconHash, numIterationsExp) {\n    let nIterationsInner;\n    let nIterationsOuter;\n    if (numIterationsExp<32) {\n        nIterationsInner = (1 << numIterationsExp) >>> 0;\n        nIterationsOuter = 1;\n    } else {\n        nIterationsInner = 0x100000000;\n        nIterationsOuter = (1 << (numIterationsExp-32)) >>> 0;\n    }\n\n    let curHash = beaconHash;\n    for (let i=0; i<nIterationsOuter; i++) {\n        for (let j=0; j<nIterationsInner; j++) {\n            curHash = await sha256digest(curHash);\n        }\n    }\n\n    const curHashV = new DataView(curHash.buffer, curHash.byteOffset, curHash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = curHashV.getUint32(i*4, false);\n    }\n\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.ChaCha(seed);\n\n    return rng;\n}\n\nfunction hex2ByteArray(s) {\n    if (s instanceof Uint8Array) return s;\n    if (s.slice(0,2) == \"0x\") s= s.slice(2);\n    return new Uint8Array(s.match(/[\\da-f]{2}/gi).map(function (h) {\n        return parseInt(h, 16);\n    }));\n}\n\nfunction byteArray2hex(byteArray) {\n    return Array.prototype.map.call(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nfunction stringifyBigIntsWithField(Fr, o) {\n    if (o instanceof Uint8Array)  {\n        return Fr.toString(o);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigIntsWithField.bind(null, Fr));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach( (k) => {\n            res[k] = stringifyBigIntsWithField(Fr, o[k]);\n        });\n        return res;\n    } else if ((typeof(o) == \"bigint\") || o.eq !== undefined)  {\n        return o.toString(10);\n    } else {\n        return o;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbWlzYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnRDtBQUNOO0FBQ1Y7QUFDTTtBQUNWOztBQUU1QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQUc7QUFDcEIsZ0JBQWdCLDBEQUFPLFVBQVUsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQLFFBQVEsS0FBZSxFQUFFLEVBRXBCLENBQUM7QUFDTixtQkFBbUIscURBQXdCO0FBQzNDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsUUFBUSxLQUFlLEVBQUUsRUFFcEIsQ0FBQyxPQUFPO0FBQ2IsUUFBUSxrREFBcUI7QUFDN0I7QUFDQTtBQUNBOztBQUVPO0FBQ1AsUUFBUSxLQUFlLEVBQUUsRUFHcEIsQ0FBQyxPQUFPO0FBQ2IsZUFBZSw4Q0FBaUI7QUFDaEM7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBTztBQUMxQjtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBLG9CQUFvQixnREFBTTtBQUMxQjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBOztBQUVBLG9CQUFvQixnREFBTTs7QUFFMUI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBLEtBQUs7QUFDTDs7QUFFTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9taXNjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgeyB1MzIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHJlYWRsaW5lIGZyb20gXCJyZWFkbGluZVwiO1xuaW1wb3J0IHsgQ2hhQ2hhIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5cbmNvbnN0IF9yZXZUYWJsZSA9IFtdO1xuZm9yIChsZXQgaT0wOyBpPDI1NjsgaSsrKSB7XG4gICAgX3JldlRhYmxlW2ldID0gX3JldlNsb3coaSwgOCk7XG59XG5cbmZ1bmN0aW9uIF9yZXZTbG93KGlkeCwgYml0cykge1xuICAgIGxldCByZXMgPTA7XG4gICAgbGV0IGEgPSBpZHg7XG4gICAgZm9yIChsZXQgaT0wOyBpPGJpdHM7IGkrKykge1xuICAgICAgICByZXMgPDw9IDE7XG4gICAgICAgIHJlcyA9IHJlcyB8IChhICYxKTtcbiAgICAgICAgYSA+Pj0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0UmV2ZXJzZShpZHgsIGJpdHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBfcmV2VGFibGVbaWR4ID4+PiAyNF0gfFxuICAgICAgICAoX3JldlRhYmxlWyhpZHggPj4+IDE2KSAmIDB4RkZdIDw8IDgpIHxcbiAgICAgICAgKF9yZXZUYWJsZVsoaWR4ID4+PiA4KSAmIDB4RkZdIDw8IDE2KSB8XG4gICAgICAgIChfcmV2VGFibGVbaWR4ICYgMHhGRl0gPDwgMjQpXG4gICAgKSA+Pj4gKDMyLWJpdHMpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBsb2cyKCBWIClcbntcbiAgICByZXR1cm4oICggKCBWICYgMHhGRkZGMDAwMCApICE9PSAwID8gKCBWICY9IDB4RkZGRjAwMDAsIDE2ICkgOiAwICkgfCAoICggViAmIDB4RkYwMEZGMDAgKSAhPT0gMCA/ICggViAmPSAweEZGMDBGRjAwLCA4ICkgOiAwICkgfCAoICggViAmIDB4RjBGMEYwRjAgKSAhPT0gMCA/ICggViAmPSAweEYwRjBGMEYwLCA0ICkgOiAwICkgfCAoICggViAmIDB4Q0NDQ0NDQ0MgKSAhPT0gMCA/ICggViAmPSAweENDQ0NDQ0NDLCAyICkgOiAwICkgfCAoICggViAmIDB4QUFBQUFBQUEgKSAhPT0gMCApICk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEhhc2goYiwgdGl0bGUpIHtcbiAgICBjb25zdCBhID0gbmV3IERhdGFWaWV3KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgbGV0IFMgPSBcIlwiO1xuICAgIGZvciAobGV0IGk9MDsgaTw0OyBpKyspIHtcbiAgICAgICAgaWYgKGk+MCkgUyArPSBcIlxcblwiO1xuICAgICAgICBTICs9IFwiXFx0XFx0XCI7XG4gICAgICAgIGZvciAobGV0IGo9MDsgajw0OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqPjApIFMgKz0gXCIgXCI7XG4gICAgICAgICAgICBTICs9IGEuZ2V0VWludDMyKGkqMTYraio0KS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aXRsZSkgUyA9IHRpdGxlICsgXCJcXG5cIiArIFM7XG4gICAgcmV0dXJuIFM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNoSXNFcXVhbChoMSwgaDIpIHtcbiAgICBpZiAoaDEuYnl0ZUxlbmd0aCAhPSBoMi5ieXRlTGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGR2MSA9IG5ldyBJbnQ4QXJyYXkoaDEpO1xuICAgIHZhciBkdjIgPSBuZXcgSW50OEFycmF5KGgyKTtcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgIT0gaDEuYnl0ZUxlbmd0aCA7IGkrKylcbiAgICB7XG4gICAgICAgIGlmIChkdjFbaV0gIT0gZHYyW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVIYXNoZXIoaCkge1xuICAgIHJldHVybiBoLmNsb25lKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUGFydGlhbEhhc2gocGFydGlhbCkge1xuICAgIC8vIE5PVEU6IHRoaXMgaXMgdW5zYWZlIGFuZCB1c2VzIGludGVybmFsIEFQSVxuICAgIGNvbnN0IGJ1ZiA9IHBhcnRpYWwuc3ViYXJyYXkoMCwgMTI4KTtcbiAgICBjb25zdCByZXN0ID0gdTMyKHBhcnRpYWwuc3ViYXJyYXkoMTI4KSk7XG4gICAgY29uc3QgcmVzID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgcmVzLmJ1ZmZlci5zZXQoYnVmKTtcbiAgICAocmVzLnYwbCA9IHJlc3RbMF0gfCAwKSwgKHJlcy52MGggPSByZXN0WzFdIHwgMCk7XG4gICAgKHJlcy52MWwgPSByZXN0WzJdIHwgMCksIChyZXMudjFoID0gcmVzdFszXSB8IDApO1xuICAgIChyZXMudjJsID0gcmVzdFs0XSB8IDApLCAocmVzLnYyaCA9IHJlc3RbNV0gfCAwKTtcbiAgICAocmVzLnYzbCA9IHJlc3RbNl0gfCAwKSwgKHJlcy52M2ggPSByZXN0WzddIHwgMCk7XG4gICAgKHJlcy52NGwgPSByZXN0WzhdIHwgMCksIChyZXMudjRoID0gcmVzdFs5XSB8IDApO1xuICAgIChyZXMudjVsID0gcmVzdFsxMF0gfCAwKSwgKHJlcy52NWggPSByZXN0WzExXSB8IDApO1xuICAgIChyZXMudjZsID0gcmVzdFsxMl0gfCAwKSwgKHJlcy52NmggPSByZXN0WzEzXSB8IDApO1xuICAgIChyZXMudjdsID0gcmVzdFsxNF0gfCAwKSwgKHJlcy52N2ggPSByZXN0WzE1XSB8IDApO1xuICAgIGNvbnN0IHNoaWZ0ID0gMiAqKiAzMjtcbiAgICBjb25zdCBsZW4gPSByZXN0WzE2XSArIHJlc3RbMTddICogc2hpZnQ7XG4gICAgY29uc3QgcG9zID0gcmVzdFsxOF0gKyByZXN0WzE5XSAqIHNoaWZ0O1xuICAgIHJlcy5sZW5ndGggPSBsZW4gKyBwb3M7XG4gICAgcmVzLnBvcyA9IHBvcztcbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9QYXJ0aWFsSGFzaChoYXNoKXtcbiAgICAvLyBOT1RFOiB0aGlzIGlzIHVuc2FmZSBhbmQgdXNlcyBpbnRlcm5hbCBBUElcbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheSgyMTYpO1xuICAgIGNvbnN0IHJlczMyID0gdTMyKHJlcy5zdWJhcnJheSgxMjgpKTtcbiAgICByZXMuc2V0KGhhc2guYnVmZmVyKTtcbiAgICAocmVzMzJbMF0gPSBoYXNoLnYwbCksIChyZXMzMlsxXSA9IGhhc2gudjBoKTtcbiAgICAocmVzMzJbMl0gPSBoYXNoLnYxbCksIChyZXMzMlszXSA9IGhhc2gudjFoKTtcbiAgICAocmVzMzJbNF0gPSBoYXNoLnYybCksIChyZXMzMls1XSA9IGhhc2gudjJoKTtcbiAgICAocmVzMzJbNl0gPSBoYXNoLnYzbCksIChyZXMzMls3XSA9IGhhc2gudjNoKTtcbiAgICAocmVzMzJbOF0gPSBoYXNoLnY0bCksIChyZXMzMls5XSA9IGhhc2gudjRoKTtcbiAgICAocmVzMzJbMTBdID0gaGFzaC52NWwpLCAocmVzMzJbMTFdID0gaGFzaC52NWgpO1xuICAgIChyZXMzMlsxMl0gPSBoYXNoLnY2bCksIChyZXMzMlsxM10gPSBoYXNoLnY2aCk7XG4gICAgKHJlczMyWzE0XSA9IGhhc2gudjdsKSwgKHJlczMyWzE1XSA9IGhhc2gudjdoKTtcbiAgICByZXMzMlsxOF0gPSBoYXNoLnBvcztcbiAgICByZXMzMlsxNl0gPSBoYXNoLmxlbmd0aC1oYXNoLnBvcztcbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2FtZVJhdGlvKGN1cnZlLCBnMXMsIGcxc3gsIGcycywgZzJzeCkge1xuICAgIGlmIChjdXJ2ZS5HMS5pc1plcm8oZzFzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjdXJ2ZS5HMS5pc1plcm8oZzFzeCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY3VydmUuRzIuaXNaZXJvKGcycykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY3VydmUuRzIuaXNaZXJvKGcyc3gpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGN1cnZlLkYxMi5lcShjdXJ2ZS5wYWlyaW5nKGcxcywgZzJzeCksIGN1cnZlLnBhaXJpbmcoZzFzeCwgZzJzKSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUucGFpcmluZ0VxKGcxcywgZzJzeCwgY3VydmUuRzEubmVnKGcxc3gpLCBnMnMpO1xuICAgIHJldHVybiByZXM7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFza0VudHJvcHkoKSB7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICAgICAgICByZXR1cm4gd2luZG93LnByb21wdChcIkVudGVyIGEgcmFuZG9tIHRleHQuIChFbnRyb3B5KTogXCIsIFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJsID0gcmVhZGxpbmUuY3JlYXRlSW50ZXJmYWNlKHtcbiAgICAgICAgICAgIGlucHV0OiBwcm9jZXNzLnN0ZGluLFxuICAgICAgICAgICAgb3V0cHV0OiBwcm9jZXNzLnN0ZG91dFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJsLnF1ZXN0aW9uKFwiRW50ZXIgYSByYW5kb20gdGV4dC4gKEVudHJvcHkpOiBcIiwgKGlucHV0KSA9PiByZXNvbHZlKGlucHV0KSApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhuKSB7XG4gICAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3NlcikgeyAvLyBTdXBwb3J0ZWRcbiAgICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICB9IGVsc2UgeyAvLyBOb2RlSlNcbiAgICAgICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2hhMjU2ZGlnZXN0KGRhdGEpIHtcbiAgICBpZiAocHJvY2Vzcy5icm93c2VyKSB7IC8vIFN1cHBvcnRlZFxuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTI1NlwiLCBkYXRhLmJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIH0gZWxzZSB7IC8vIE5vZGVKU1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVSW50MzJCRShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyKS5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSYW5kb21SbmcoZW50cm9weSkge1xuICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIFJuZ1xuICAgIHdoaWxlICghZW50cm9weSkge1xuICAgICAgICBlbnRyb3B5ID0gYXdhaXQgYXNrRW50cm9weSgpO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSg2NCk7XG4gICAgaGFzaGVyLnVwZGF0ZShnZXRSYW5kb21CeXRlcyg2NCkpO1xuICAgIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpOyAvLyBhbHdheXMgdXRmLThcbiAgICBoYXNoZXIudXBkYXRlKGVuYy5lbmNvZGUoZW50cm9weSkpO1xuICAgIGNvbnN0IGhhc2ggPSBoYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBjb25zdCBzZWVkID0gW107XG4gICAgZm9yIChsZXQgaT0wO2k8ODtpKyspIHtcbiAgICAgICAgc2VlZFtpXSA9IHJlYWRVSW50MzJCRShoYXNoLCBpKjQpO1xuICAgIH1cbiAgICBjb25zdCBybmcgPSBuZXcgQ2hhQ2hhKHNlZWQpO1xuICAgIHJldHVybiBybmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBybmdGcm9tQmVhY29uUGFyYW1zKGJlYWNvbkhhc2gsIG51bUl0ZXJhdGlvbnNFeHApIHtcbiAgICBsZXQgbkl0ZXJhdGlvbnNJbm5lcjtcbiAgICBsZXQgbkl0ZXJhdGlvbnNPdXRlcjtcbiAgICBpZiAobnVtSXRlcmF0aW9uc0V4cDwzMikge1xuICAgICAgICBuSXRlcmF0aW9uc0lubmVyID0gKDEgPDwgbnVtSXRlcmF0aW9uc0V4cCkgPj4+IDA7XG4gICAgICAgIG5JdGVyYXRpb25zT3V0ZXIgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5JdGVyYXRpb25zSW5uZXIgPSAweDEwMDAwMDAwMDtcbiAgICAgICAgbkl0ZXJhdGlvbnNPdXRlciA9ICgxIDw8IChudW1JdGVyYXRpb25zRXhwLTMyKSkgPj4+IDA7XG4gICAgfVxuXG4gICAgbGV0IGN1ckhhc2ggPSBiZWFjb25IYXNoO1xuICAgIGZvciAobGV0IGk9MDsgaTxuSXRlcmF0aW9uc091dGVyOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5JdGVyYXRpb25zSW5uZXI7IGorKykge1xuICAgICAgICAgICAgY3VySGFzaCA9IGF3YWl0IHNoYTI1NmRpZ2VzdChjdXJIYXNoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGN1ckhhc2hWID0gbmV3IERhdGFWaWV3KGN1ckhhc2guYnVmZmVyLCBjdXJIYXNoLmJ5dGVPZmZzZXQsIGN1ckhhc2guYnl0ZUxlbmd0aCk7XG4gICAgY29uc3Qgc2VlZCA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTw4OyBpKyspIHtcbiAgICAgICAgc2VlZFtpXSA9IGN1ckhhc2hWLmdldFVpbnQzMihpKjQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBybmcgPSBuZXcgQ2hhQ2hhKHNlZWQpO1xuXG4gICAgcmV0dXJuIHJuZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhleDJCeXRlQXJyYXkocykge1xuICAgIGlmIChzIGluc3RhbmNlb2YgVWludDhBcnJheSkgcmV0dXJuIHM7XG4gICAgaWYgKHMuc2xpY2UoMCwyKSA9PSBcIjB4XCIpIHM9IHMuc2xpY2UoMik7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHMubWF0Y2goL1tcXGRhLWZdezJ9L2dpKS5tYXAoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGgsIDE2KTtcbiAgICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBieXRlQXJyYXkyaGV4KGJ5dGVBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYnl0ZUFycmF5LCBmdW5jdGlvbihieXRlKSB7XG4gICAgICAgIHJldHVybiAoXCIwXCIgKyAoYnl0ZSAmIDB4RkYpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkKEZyLCBvKSB7XG4gICAgaWYgKG8gaW5zdGFuY2VvZiBVaW50OEFycmF5KSAge1xuICAgICAgICByZXR1cm4gRnIudG9TdHJpbmcobyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgICAgIHJldHVybiBvLm1hcChzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkLmJpbmQobnVsbCwgRnIpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKCAoaykgPT4ge1xuICAgICAgICAgICAgcmVzW2tdID0gc3RyaW5naWZ5QmlnSW50c1dpdGhGaWVsZChGciwgb1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZihvKSA9PSBcImJpZ2ludFwiKSB8fCBvLmVxICE9PSB1bmRlZmluZWQpICB7XG4gICAgICAgIHJldHVybiBvLnRvU3RyaW5nKDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/misc.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/mpc_applykey.js":
/*!**************************************************!*\
  !*** ./node_modules/snarkjs/src/mpc_applykey.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyKeyToChallengeSection: () => (/* binding */ applyKeyToChallengeSection),\n/* harmony export */   applyKeyToSection: () => (/* binding */ applyKeyToSection)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n/*\n    This function creates a new section in the fdTo file with id idSection.\n    It multiplies the points in fdFrom by first, first*inc, first*inc^2, ....\n    nPoint Times.\n    It also updates the newChallengeHasher with the new points\n*/\n\nasync function applyKeyToSection(fdOld, sections, fdNew, idSection, curve, groupName, first, inc, sectionName, logger) {\n    const MAX_CHUNK_SIZE = 1 << 16;\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const nPoints = sections[idSection][0].size / sG;\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections,idSection );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, idSection);\n\n    let t = first;\n    for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`Applying key: ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints - i, MAX_CHUNK_SIZE);\n        let buff;\n        buff = await fdOld.read(n*sG);\n        buff = await G.batchApplyKey(buff, t, inc);\n        await fdNew.write(buff);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld);\n}\n\n\n\nasync function applyKeyToChallengeSection(fdOld, fdNew, responseHasher, curve, groupName, nPoints, first, inc, formatOut, sectionName, logger) {\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n    let t = first;\n    for (let i=0 ; i<nPoints ; i+= chunkSize) {\n        if (logger) logger.debug(`Applying key ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints-i, chunkSize );\n        const buffInU = await fdOld.read(n * sG);\n        const buffInLEM = await G.batchUtoLEM(buffInU);\n        const buffOutLEM = await G.batchApplyKey(buffInLEM, t, inc);\n        let buffOut;\n        if (formatOut == \"COMPRESSED\") {\n            buffOut = await G.batchLEMtoC(buffOutLEM);\n        } else {\n            buffOut = await G.batchLEMtoU(buffOutLEM);\n        }\n\n        if (responseHasher) responseHasher.update(buffOut);\n        await fdNew.write(buffOut);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbXBjX2FwcGx5a2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHVFQUFtQztBQUM3QyxVQUFVLGtFQUE4Qjs7QUFFeEM7QUFDQSxrQkFBa0IsV0FBVztBQUM3QixrREFBa0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0VBQTRCO0FBQ3RDLFVBQVUsK0RBQTJCO0FBQ3JDOzs7O0FBSU87QUFDUDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0IsaURBQWlELFlBQVksSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbXBjX2FwcGx5a2V5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuXG4vKlxuICAgIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIG5ldyBzZWN0aW9uIGluIHRoZSBmZFRvIGZpbGUgd2l0aCBpZCBpZFNlY3Rpb24uXG4gICAgSXQgbXVsdGlwbGllcyB0aGUgcG9pbnRzIGluIGZkRnJvbSBieSBmaXJzdCwgZmlyc3QqaW5jLCBmaXJzdCppbmNeMiwgLi4uLlxuICAgIG5Qb2ludCBUaW1lcy5cbiAgICBJdCBhbHNvIHVwZGF0ZXMgdGhlIG5ld0NoYWxsZW5nZUhhc2hlciB3aXRoIHRoZSBuZXcgcG9pbnRzXG4qL1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgaWRTZWN0aW9uLCBjdXJ2ZSwgZ3JvdXBOYW1lLCBmaXJzdCwgaW5jLCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxIDw8IDE2O1xuICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgY29uc3QgblBvaW50cyA9IHNlY3Rpb25zW2lkU2VjdGlvbl1bMF0uc2l6ZSAvIHNHO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLGlkU2VjdGlvbiApO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgaWRTZWN0aW9uKTtcblxuICAgIGxldCB0ID0gZmlyc3Q7XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBBcHBseWluZyBrZXk6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4oblBvaW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgIGJ1ZmYgPSBhd2FpdCBmZE9sZC5yZWFkKG4qc0cpO1xuICAgICAgICBidWZmID0gYXdhaXQgRy5iYXRjaEFwcGx5S2V5KGJ1ZmYsIHQsIGluYyk7XG4gICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuICAgICAgICB0ID0gY3VydmUuRnIubXVsKHQsIGN1cnZlLkZyLmV4cChpbmMsIG4pKTtcbiAgICB9XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmRPbGQpO1xufVxuXG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkT2xkLCBmZE5ldywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBncm91cE5hbWUsIG5Qb2ludHMsIGZpcnN0LCBpbmMsIGZvcm1hdE91dCwgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5mbG9vcigoMTw8MjApIC8gc0cpOyAgIC8vIDEyOE1iIGNodW5rc1xuICAgIGxldCB0ID0gZmlyc3Q7XG4gICAgZm9yIChsZXQgaT0wIDsgaTxuUG9pbnRzIDsgaSs9IGNodW5rU2l6ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEFwcGx5aW5nIGtleSAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgIGNvbnN0IG49IE1hdGgubWluKG5Qb2ludHMtaSwgY2h1bmtTaXplICk7XG4gICAgICAgIGNvbnN0IGJ1ZmZJblUgPSBhd2FpdCBmZE9sZC5yZWFkKG4gKiBzRyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZJbkxFTSA9IGF3YWl0IEcuYmF0Y2hVdG9MRU0oYnVmZkluVSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZPdXRMRU0gPSBhd2FpdCBHLmJhdGNoQXBwbHlLZXkoYnVmZkluTEVNLCB0LCBpbmMpO1xuICAgICAgICBsZXQgYnVmZk91dDtcbiAgICAgICAgaWYgKGZvcm1hdE91dCA9PSBcIkNPTVBSRVNTRURcIikge1xuICAgICAgICAgICAgYnVmZk91dCA9IGF3YWl0IEcuYmF0Y2hMRU10b0MoYnVmZk91dExFTSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gYXdhaXQgRy5iYXRjaExFTXRvVShidWZmT3V0TEVNKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwb25zZUhhc2hlcikgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGJ1ZmZPdXQpO1xuICAgICAgICBhd2FpdCBmZE5ldy53cml0ZShidWZmT3V0KTtcbiAgICAgICAgdCA9IGN1cnZlLkZyLm11bCh0LCBjdXJ2ZS5Gci5leHAoaW5jLCBuKSk7XG4gICAgfVxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/mpc_applykey.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/mul_z.js":
/*!*******************************************!*\
  !*** ./node_modules/snarkjs/src/mul_z.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MulZ: () => (/* binding */ MulZ)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass MulZ {\n    static getZ1(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(-1), Fr.w[2]),\n            Fr.e(-2),\n            Fr.sub(Fr.e(-1), Fr.w[2]),\n        ];\n    }\n\n    static getZ2(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n            Fr.e(4),\n            Fr.sub(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n        ];\n    }\n\n    static getZ3(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n            Fr.e(-8),\n            Fr.sub(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n        ];\n\n    }\n\n    static mul2(a, b, ap, bp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = a_b;\n\n        let a0 = Fr.add(a_bp, ap_b);\n\n        let a1 = ap_bp;\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n        }\n\n        return [r, rz];\n    }\n\n    static mul3(a, b, c, ap, bp, cp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = Fr.mul(a_b, c);\n\n        let a0 = Fr.mul(ap_b, c);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp));\n\n        let a1 = Fr.mul(ap_bp, c);\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp));\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp));\n\n        rz = a0;\n        if (p) {\n            const a2 = Fr.mul(ap_bp, cp);\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n        }\n\n        return [r, rz];\n    }\n\n    static mul4(a, b, c, d, ap, bp, cp, dp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        const Z3 = this.getZ3(Fr);\n\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        const c_d = Fr.mul(c, d);\n        const c_dp = Fr.mul(c, dp);\n        const cp_d = Fr.mul(cp, d);\n        const cp_dp = Fr.mul(cp, dp);\n\n        r = Fr.mul(a_b, c_d);\n\n        let a0 = Fr.mul(ap_b, c_d);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, c_dp));\n\n        let a1 = Fr.mul(ap_bp, c_d);\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp_d));\n        a1 = Fr.add(a1, Fr.mul(ap_b, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp_d));\n        a1 = Fr.add(a1, Fr.mul(a_bp, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_b, cp_dp));\n\n        let a2 = Fr.mul(a_bp, cp_dp);\n        a2 = Fr.add(a2, Fr.mul(ap_b, cp_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, c_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, cp_d));\n\n        let a3 = Fr.mul(ap_bp, cp_dp);\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n            rz = Fr.add(rz, Fr.mul(Z3[p], a3));\n        }\n\n        return [r, rz];\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbXVsX3ouanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9tdWxfei5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgY2xhc3MgTXVsWiB7XG4gICAgc3RhdGljIGdldFoxKEZyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBGci56ZXJvLFxuICAgICAgICAgICAgRnIuYWRkKEZyLmUoLTEpLCBGci53WzJdKSxcbiAgICAgICAgICAgIEZyLmUoLTIpLFxuICAgICAgICAgICAgRnIuc3ViKEZyLmUoLTEpLCBGci53WzJdKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0WjIoRnIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEZyLnplcm8sXG4gICAgICAgICAgICBGci5hZGQoRnIuemVybywgRnIubXVsKEZyLmUoLTIpLCBGci53WzJdKSksXG4gICAgICAgICAgICBGci5lKDQpLFxuICAgICAgICAgICAgRnIuc3ViKEZyLnplcm8sIEZyLm11bChGci5lKC0yKSwgRnIud1syXSkpLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRaMyhGcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgRnIuemVybyxcbiAgICAgICAgICAgIEZyLmFkZChGci5lKDIpLCBGci5tdWwoRnIuZSgyKSwgRnIud1syXSkpLFxuICAgICAgICAgICAgRnIuZSgtOCksXG4gICAgICAgICAgICBGci5zdWIoRnIuZSgyKSwgRnIubXVsKEZyLmUoMiksIEZyLndbMl0pKSxcbiAgICAgICAgXTtcblxuICAgIH1cblxuICAgIHN0YXRpYyBtdWwyKGEsIGIsIGFwLCBicCwgcCwgRnIpIHtcbiAgICAgICAgY29uc3QgWjEgPSB0aGlzLmdldFoxKEZyKTtcbiAgICAgICAgbGV0IHIsIHJ6O1xuXG4gICAgICAgIGNvbnN0IGFfYiA9IEZyLm11bChhLCBiKTtcbiAgICAgICAgY29uc3QgYV9icCA9IEZyLm11bChhLCBicCk7XG4gICAgICAgIGNvbnN0IGFwX2IgPSBGci5tdWwoYXAsIGIpO1xuICAgICAgICBjb25zdCBhcF9icCA9IEZyLm11bChhcCwgYnApO1xuXG4gICAgICAgIHIgPSBhX2I7XG5cbiAgICAgICAgbGV0IGEwID0gRnIuYWRkKGFfYnAsIGFwX2IpO1xuXG4gICAgICAgIGxldCBhMSA9IGFwX2JwO1xuXG4gICAgICAgIHJ6ID0gYTA7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICByeiA9IEZyLmFkZChyeiwgRnIubXVsKFoxW3BdLCBhMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtyLCByel07XG4gICAgfVxuXG4gICAgc3RhdGljIG11bDMoYSwgYiwgYywgYXAsIGJwLCBjcCwgcCwgRnIpIHtcbiAgICAgICAgY29uc3QgWjEgPSB0aGlzLmdldFoxKEZyKTtcbiAgICAgICAgY29uc3QgWjIgPSB0aGlzLmdldFoyKEZyKTtcbiAgICAgICAgbGV0IHIsIHJ6O1xuXG4gICAgICAgIGNvbnN0IGFfYiA9IEZyLm11bChhLCBiKTtcbiAgICAgICAgY29uc3QgYV9icCA9IEZyLm11bChhLCBicCk7XG4gICAgICAgIGNvbnN0IGFwX2IgPSBGci5tdWwoYXAsIGIpO1xuICAgICAgICBjb25zdCBhcF9icCA9IEZyLm11bChhcCwgYnApO1xuXG4gICAgICAgIHIgPSBGci5tdWwoYV9iLCBjKTtcblxuICAgICAgICBsZXQgYTAgPSBGci5tdWwoYXBfYiwgYyk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9icCwgYykpO1xuICAgICAgICBhMCA9IEZyLmFkZChhMCwgRnIubXVsKGFfYiwgY3ApKTtcblxuICAgICAgICBsZXQgYTEgPSBGci5tdWwoYXBfYnAsIGMpO1xuICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFfYnAsIGNwKSk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYXBfYiwgY3ApKTtcblxuICAgICAgICByeiA9IGEwO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgY29uc3QgYTIgPSBGci5tdWwoYXBfYnAsIGNwKTtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjFbcF0sIGExKSk7XG4gICAgICAgICAgICByeiA9IEZyLmFkZChyeiwgRnIubXVsKFoyW3BdLCBhMikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtyLCByel07XG4gICAgfVxuXG4gICAgc3RhdGljIG11bDQoYSwgYiwgYywgZCwgYXAsIGJwLCBjcCwgZHAsIHAsIEZyKSB7XG4gICAgICAgIGNvbnN0IFoxID0gdGhpcy5nZXRaMShGcik7XG4gICAgICAgIGNvbnN0IFoyID0gdGhpcy5nZXRaMihGcik7XG4gICAgICAgIGNvbnN0IFozID0gdGhpcy5nZXRaMyhGcik7XG5cbiAgICAgICAgbGV0IHIsIHJ6O1xuXG4gICAgICAgIGNvbnN0IGFfYiA9IEZyLm11bChhLCBiKTtcbiAgICAgICAgY29uc3QgYV9icCA9IEZyLm11bChhLCBicCk7XG4gICAgICAgIGNvbnN0IGFwX2IgPSBGci5tdWwoYXAsIGIpO1xuICAgICAgICBjb25zdCBhcF9icCA9IEZyLm11bChhcCwgYnApO1xuXG4gICAgICAgIGNvbnN0IGNfZCA9IEZyLm11bChjLCBkKTtcbiAgICAgICAgY29uc3QgY19kcCA9IEZyLm11bChjLCBkcCk7XG4gICAgICAgIGNvbnN0IGNwX2QgPSBGci5tdWwoY3AsIGQpO1xuICAgICAgICBjb25zdCBjcF9kcCA9IEZyLm11bChjcCwgZHApO1xuXG4gICAgICAgIHIgPSBGci5tdWwoYV9iLCBjX2QpO1xuXG4gICAgICAgIGxldCBhMCA9IEZyLm11bChhcF9iLCBjX2QpO1xuICAgICAgICBhMCA9IEZyLmFkZChhMCwgRnIubXVsKGFfYnAsIGNfZCkpO1xuICAgICAgICBhMCA9IEZyLmFkZChhMCwgRnIubXVsKGFfYiwgY3BfZCkpO1xuICAgICAgICBhMCA9IEZyLmFkZChhMCwgRnIubXVsKGFfYiwgY19kcCkpO1xuXG4gICAgICAgIGxldCBhMSA9IEZyLm11bChhcF9icCwgY19kKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhcF9iLCBjcF9kKSk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYXBfYiwgY19kcCkpO1xuICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFfYnAsIGNwX2QpKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhX2JwLCBjX2RwKSk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYV9iLCBjcF9kcCkpO1xuXG4gICAgICAgIGxldCBhMiA9IEZyLm11bChhX2JwLCBjcF9kcCk7XG4gICAgICAgIGEyID0gRnIuYWRkKGEyLCBGci5tdWwoYXBfYiwgY3BfZHApKTtcbiAgICAgICAgYTIgPSBGci5hZGQoYTIsIEZyLm11bChhcF9icCwgY19kcCkpO1xuICAgICAgICBhMiA9IEZyLmFkZChhMiwgRnIubXVsKGFwX2JwLCBjcF9kKSk7XG5cbiAgICAgICAgbGV0IGEzID0gRnIubXVsKGFwX2JwLCBjcF9kcCk7XG5cbiAgICAgICAgcnogPSBhMDtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjFbcF0sIGExKSk7XG4gICAgICAgICAgICByeiA9IEZyLmFkZChyeiwgRnIubXVsKFoyW3BdLCBhMikpO1xuICAgICAgICAgICAgcnogPSBGci5hZGQocnosIEZyLm11bChaM1twXSwgYTMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbciwgcnpdO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/mul_z.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/plonk.js":
/*!*******************************************!*\
  !*** ./node_modules/snarkjs/src/plonk.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _plonk_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _plonk_fullprove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _plonk_prove_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   setup: () => (/* reexport safe */ _plonk_setup_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _plonk_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _plonk_setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plonk_setup.js */ \"(rsc)/./node_modules/snarkjs/src/plonk_setup.js\");\n/* harmony import */ var _plonk_fullprove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plonk_fullprove.js */ \"(rsc)/./node_modules/snarkjs/src/plonk_fullprove.js\");\n/* harmony import */ var _plonk_prove_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plonk_prove.js */ \"(rsc)/./node_modules/snarkjs/src/plonk_prove.js\");\n/* harmony import */ var _plonk_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plonk_verify.js */ \"(rsc)/./node_modules/snarkjs/src/plonk_verify.js\");\n/* harmony import */ var _plonk_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plonk_exportsoliditycalldata.js */ \"(rsc)/./node_modules/snarkjs/src/plonk_exportsoliditycalldata.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// ZKEY constants\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDa0Q7QUFDUTtBQUNSO0FBQ0U7QUFDZ0MiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLy8gWktFWSBjb25zdGFudHNcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZXR1cH0gZnJvbSBcIi4vcGxvbmtfc2V0dXAuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBmdWxsUHJvdmV9IGZyb20gXCIuL3Bsb25rX2Z1bGxwcm92ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHByb3ZlfSBmcm9tIFwiLi9wbG9ua19wcm92ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZlcmlmeX0gZnJvbSBcIi4vcGxvbmtfdmVyaWZ5LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0U29saWRpdHlDYWxsRGF0YX0gZnJvbSBcIi4vcGxvbmtfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/plonk.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/plonk_constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZKEY_PL_ADDITIONS_SECTION: () => (/* binding */ ZKEY_PL_ADDITIONS_SECTION),\n/* harmony export */   ZKEY_PL_A_MAP_SECTION: () => (/* binding */ ZKEY_PL_A_MAP_SECTION),\n/* harmony export */   ZKEY_PL_B_MAP_SECTION: () => (/* binding */ ZKEY_PL_B_MAP_SECTION),\n/* harmony export */   ZKEY_PL_C_MAP_SECTION: () => (/* binding */ ZKEY_PL_C_MAP_SECTION),\n/* harmony export */   ZKEY_PL_HEADER_SECTION: () => (/* binding */ ZKEY_PL_HEADER_SECTION),\n/* harmony export */   ZKEY_PL_LAGRANGE_SECTION: () => (/* binding */ ZKEY_PL_LAGRANGE_SECTION),\n/* harmony export */   ZKEY_PL_NSECTIONS: () => (/* binding */ ZKEY_PL_NSECTIONS),\n/* harmony export */   ZKEY_PL_PTAU_SECTION: () => (/* binding */ ZKEY_PL_PTAU_SECTION),\n/* harmony export */   ZKEY_PL_QC_SECTION: () => (/* binding */ ZKEY_PL_QC_SECTION),\n/* harmony export */   ZKEY_PL_QL_SECTION: () => (/* binding */ ZKEY_PL_QL_SECTION),\n/* harmony export */   ZKEY_PL_QM_SECTION: () => (/* binding */ ZKEY_PL_QM_SECTION),\n/* harmony export */   ZKEY_PL_QO_SECTION: () => (/* binding */ ZKEY_PL_QO_SECTION),\n/* harmony export */   ZKEY_PL_QR_SECTION: () => (/* binding */ ZKEY_PL_QR_SECTION),\n/* harmony export */   ZKEY_PL_SIGMA_SECTION: () => (/* binding */ ZKEY_PL_SIGMA_SECTION)\n/* harmony export */ });\nconst ZKEY_PL_NSECTIONS = 13;\n\nconst ZKEY_PL_HEADER_SECTION = 2;\nconst ZKEY_PL_ADDITIONS_SECTION = 3;\nconst ZKEY_PL_A_MAP_SECTION = 4;\nconst ZKEY_PL_B_MAP_SECTION = 5;\nconst ZKEY_PL_C_MAP_SECTION = 6;\nconst ZKEY_PL_QM_SECTION = 7;\nconst ZKEY_PL_QL_SECTION = 8;\nconst ZKEY_PL_QR_SECTION = 9;\nconst ZKEY_PL_QO_SECTION = 10;\nconst ZKEY_PL_QC_SECTION = 11;\nconst ZKEY_PL_SIGMA_SECTION = 12;\nconst ZKEY_PL_LAGRANGE_SECTION = 13;\nconst ZKEY_PL_PTAU_SECTION = 14;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU87O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBaS0VZX1BMX05TRUNUSU9OUyA9IDEzO1xuXG5leHBvcnQgY29uc3QgWktFWV9QTF9IRUFERVJfU0VDVElPTiA9IDI7XG5leHBvcnQgY29uc3QgWktFWV9QTF9BRERJVElPTlNfU0VDVElPTiA9IDM7XG5leHBvcnQgY29uc3QgWktFWV9QTF9BX01BUF9TRUNUSU9OID0gNDtcbmV4cG9ydCBjb25zdCBaS0VZX1BMX0JfTUFQX1NFQ1RJT04gPSA1O1xuZXhwb3J0IGNvbnN0IFpLRVlfUExfQ19NQVBfU0VDVElPTiA9IDY7XG5leHBvcnQgY29uc3QgWktFWV9QTF9RTV9TRUNUSU9OID0gNztcbmV4cG9ydCBjb25zdCBaS0VZX1BMX1FMX1NFQ1RJT04gPSA4O1xuZXhwb3J0IGNvbnN0IFpLRVlfUExfUVJfU0VDVElPTiA9IDk7XG5leHBvcnQgY29uc3QgWktFWV9QTF9RT19TRUNUSU9OID0gMTA7XG5leHBvcnQgY29uc3QgWktFWV9QTF9RQ19TRUNUSU9OID0gMTE7XG5leHBvcnQgY29uc3QgWktFWV9QTF9TSUdNQV9TRUNUSU9OID0gMTI7XG5leHBvcnQgY29uc3QgWktFWV9QTF9MQUdSQU5HRV9TRUNUSU9OID0gMTM7XG5leHBvcnQgY29uc3QgWktFWV9QTF9QVEFVX1NFQ1RJT04gPSAxNDtcblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/plonk_constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/plonk_equation.js":
/*!****************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_equation.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFFlonkAdditionConstraint: () => (/* binding */ getFFlonkAdditionConstraint),\n/* harmony export */   getFFlonkConstantConstraint: () => (/* binding */ getFFlonkConstantConstraint),\n/* harmony export */   getFFlonkMultiplicationConstraint: () => (/* binding */ getFFlonkMultiplicationConstraint)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// We export to zkey the signals and values of the a, b, c, ql, qr, qm, qo and qc\n\n// a, b and c are signals id (32-bit integers)\n// ql, qr, qm, qo and qc are field values\n\nfunction getFFlonkConstantConstraint(signal1, Fr) {\n    return [signal1, 0, 0, Fr.one, Fr.zero, Fr.zero, Fr.zero, Fr.zero];\n}\n\nfunction getFFlonkAdditionConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n\nfunction getFFlonkMultiplicationConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc, Fr) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZXF1YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX2VxdWF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIFdlIGV4cG9ydCB0byB6a2V5IHRoZSBzaWduYWxzIGFuZCB2YWx1ZXMgb2YgdGhlIGEsIGIsIGMsIHFsLCBxciwgcW0sIHFvIGFuZCBxY1xuXG4vLyBhLCBiIGFuZCBjIGFyZSBzaWduYWxzIGlkICgzMi1iaXQgaW50ZWdlcnMpXG4vLyBxbCwgcXIsIHFtLCBxbyBhbmQgcWMgYXJlIGZpZWxkIHZhbHVlc1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RkZsb25rQ29uc3RhbnRDb25zdHJhaW50KHNpZ25hbDEsIEZyKSB7XG4gICAgcmV0dXJuIFtzaWduYWwxLCAwLCAwLCBGci5vbmUsIEZyLnplcm8sIEZyLnplcm8sIEZyLnplcm8sIEZyLnplcm9dO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RkZsb25rQWRkaXRpb25Db25zdHJhaW50KHNpZ25hbDEsIHNpZ25hbDIsIHNpZ25hbE91dCwgcWwsIHFyLCBxbSwgcW8sIHFjKSB7XG4gICAgcmV0dXJuIFtzaWduYWwxLCBzaWduYWwyLCBzaWduYWxPdXQsIHFsLCBxciwgcW0sIHFvLCBxY107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGRmxvbmtNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoc2lnbmFsMSwgc2lnbmFsMiwgc2lnbmFsT3V0LCBxbCwgcXIsIHFtLCBxbywgcWMsIEZyKSB7XG4gICAgcmV0dXJuIFtzaWduYWwxLCBzaWduYWwyLCBzaWduYWxPdXQsIHFsLCBxciwgcW0sIHFvLCBxY107XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/plonk_equation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/plonk_exportsoliditycalldata.js":
/*!******************************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_exportsoliditycalldata.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkExportSolidityCallData)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function plonkExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName)(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.A[0])}, ${p256(proof.A[1])},` +\n    `${p256(proof.B[0])},${p256(proof.B[1])},` +\n    `${p256(proof.C[0])},${p256(proof.C[1])},` +\n    `${p256(proof.Z[0])},${p256(proof.Z[1])},` +\n    `${p256(proof.T1[0])},${p256(proof.T1[1])},` +\n    `${p256(proof.T2[0])},${p256(proof.T2[1])},` +\n    `${p256(proof.T3[0])},${p256(proof.T3[1])},` +\n    `${p256(proof.Wxi[0])},${p256(proof.Wxi[1])},` +\n    `${p256(proof.Wxiw[0])},${p256(proof.Wxiw[1])},` +\n    `${p256(proof.eval_a)},` + \n    `${p256(proof.eval_b)},` + \n    `${p256(proof.eval_c)},` + \n    `${p256(proof.eval_s1)},` + \n    `${p256(proof.eval_s2)},` + \n    `${p256(proof.eval_zw)}]` + \n    `[${inputs}]`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUrQztBQUNQO0FBQ3hDLFFBQVEsb0JBQW9CLEVBQUUsK0NBQUs7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBOztBQUVlO0FBQ2Y7QUFDQTs7QUFFQSx3QkFBd0IsNERBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7O0FBRUEsZUFBZSxpQkFBaUIsSUFBSSxpQkFBaUI7QUFDckQsT0FBTyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDNUMsT0FBTyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDNUMsT0FBTyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDNUMsT0FBTyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDOUMsT0FBTyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDOUMsT0FBTyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDOUMsT0FBTyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDaEQsT0FBTyxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDbEQsT0FBTyxtQkFBbUI7QUFDMUIsT0FBTyxtQkFBbUI7QUFDMUIsT0FBTyxtQkFBbUI7QUFDMUIsT0FBTyxvQkFBb0I7QUFDM0IsT0FBTyxvQkFBb0I7QUFDM0IsT0FBTyxvQkFBb0I7QUFDM0IsUUFBUSxPQUFPO0FBQ2YiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21OYW1lIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgeyAgdXRpbHMgfSAgIGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHsgdW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5mdW5jdGlvbiBpMmhleChpKSB7XG4gICAgcmV0dXJuIChcIjBcIiArIGkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG59XG5cbmZ1bmN0aW9uIHAyNTYobikge1xuICAgIGxldCBuc3RyID0gbi50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKG5zdHIubGVuZ3RoIDwgNjQpIG5zdHIgPSBcIjBcIituc3RyO1xuICAgIG5zdHIgPSBgXCIweCR7bnN0cn1cImA7XG4gICAgcmV0dXJuIG5zdHI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBsb25rRXhwb3J0U29saWRpdHlDYWxsRGF0YShfcHJvb2YsIF9wdWIpIHtcbiAgICBjb25zdCBwcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpO1xuICAgIGNvbnN0IHB1YiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHViKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tTmFtZShwcm9vZi5jdXJ2ZSk7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IGlucHV0cyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaT0wOyBpPHB1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRzICE9IFwiXCIpIGlucHV0cyA9IGlucHV0cyArIFwiLFwiO1xuICAgICAgICBpbnB1dHMgPSBpbnB1dHMgKyBwMjU2KHB1YltpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBbJHtwMjU2KHByb29mLkFbMF0pfSwgJHtwMjU2KHByb29mLkFbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLkJbMF0pfSwke3AyNTYocHJvb2YuQlsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuQ1swXSl9LCR7cDI1Nihwcm9vZi5DWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5aWzBdKX0sJHtwMjU2KHByb29mLlpbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLlQxWzBdKX0sJHtwMjU2KHByb29mLlQxWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5UMlswXSl9LCR7cDI1Nihwcm9vZi5UMlsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuVDNbMF0pfSwke3AyNTYocHJvb2YuVDNbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLld4aVswXSl9LCR7cDI1Nihwcm9vZi5XeGlbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLld4aXdbMF0pfSwke3AyNTYocHJvb2YuV3hpd1sxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuZXZhbF9hKX0sYCArIFxuICAgIGAke3AyNTYocHJvb2YuZXZhbF9iKX0sYCArIFxuICAgIGAke3AyNTYocHJvb2YuZXZhbF9jKX0sYCArIFxuICAgIGAke3AyNTYocHJvb2YuZXZhbF9zMSl9LGAgKyBcbiAgICBgJHtwMjU2KHByb29mLmV2YWxfczIpfSxgICsgXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsX3p3KX1dYCArIFxuICAgIGBbJHtpbnB1dHN9XWA7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/plonk_exportsoliditycalldata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/plonk_fullprove.js":
/*!*****************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_fullprove.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkFullProve)\n/* harmony export */ });\n/* harmony import */ var _plonk_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plonk_prove.js */ \"(rsc)/./node_modules/snarkjs/src/plonk_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function plonkFullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFile, wtns, wtnsCalcOptions);\n    return await (0,_plonk_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFileName, wtns, logger, proverOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZnVsbHByb3ZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUyQztBQUNNO0FBQ2Q7QUFDbkMsT0FBTyxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFbkI7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhEQUFjO0FBQ3hCLGlCQUFpQiwyREFBVztBQUM1QiIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wbG9ua19mdWxscHJvdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHBsb25rX3Byb3ZlIGZyb20gXCIuL3Bsb25rX3Byb3ZlLmpzXCI7XG5pbXBvcnQgd3Ruc19jYWxjdWxhdGUgZnJvbSBcIi4vd3Ruc19jYWxjdWxhdGUuanNcIjtcbmltcG9ydCB7dXRpbHN9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHt1bnN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBsb25rRnVsbFByb3ZlKF9pbnB1dCwgd2FzbUZpbGUsIHprZXlGaWxlTmFtZSwgbG9nZ2VyLCB3dG5zQ2FsY09wdGlvbnMsIHByb3Zlck9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyhfaW5wdXQpO1xuXG4gICAgY29uc3Qgd3Rucz0ge1xuICAgICAgICB0eXBlOiBcIm1lbVwiXG4gICAgfTtcbiAgICBhd2FpdCB3dG5zX2NhbGN1bGF0ZShpbnB1dCwgd2FzbUZpbGUsIHd0bnMsIHd0bnNDYWxjT3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHBsb25rX3Byb3ZlKHprZXlGaWxlTmFtZSwgd3RucywgbG9nZ2VyLCBwcm92ZXJPcHRpb25zKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/plonk_fullprove.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/plonk_prove.js":
/*!*************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_prove.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonk16Prove)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proof.js */ \"(rsc)/./node_modules/snarkjs/src/proof.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(rsc)/./node_modules/snarkjs/src/Keccak256Transcript.js\");\n/* harmony import */ var _mul_z_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mul_z.js */ \"(rsc)/./node_modules/snarkjs/src/mul_z.js\");\n/* harmony import */ var _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plonk_constants.js */ \"(rsc)/./node_modules/snarkjs/src/plonk_constants.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(rsc)/./node_modules/snarkjs/src/polynomial/polynomial.js\");\n/* harmony import */ var _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./polynomial/evaluations.js */ \"(rsc)/./node_modules/snarkjs/src/polynomial/evaluations.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf section 8.4 */\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_3__.utils;\n\n\n\n\n\n\n    \nasync function plonk16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    // Read witness file\n    if (logger) logger.debug(\"> Reading witness file\");\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, sectionsWtns);\n\n    // Read zkey file\n    if (logger) logger.debug(\"> Reading zkey file\");\n    const {fd: fdZKey, sections: zkeySections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, zkeySections, undefined, options);\n    if (zkey.protocol != \"plonk\") {\n        throw new Error(\"zkey file is not plonk\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars -zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n    const sDomain = zkey.domainSize * n8r;\n\n    if (logger) {\n        logger.debug(\"----------------------------\");\n        logger.debug(\"  PLONK PROVE SETTINGS\");\n        logger.debug(`  Curve:         ${curve.name}`);\n        logger.debug(`  Circuit power: ${zkey.power}`);\n        logger.debug(`  Domain size:   ${zkey.domainSize}`);\n        logger.debug(`  Vars:          ${zkey.nVars}`);\n        logger.debug(`  Public vars:   ${zkey.nPublic}`);\n        logger.debug(`  Constraints:   ${zkey.nConstraints}`);\n        logger.debug(`  Additions:     ${zkey.nAdditions}`);\n        logger.debug(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.debug(\"> Reading witness file data\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, sectionsWtns, 2);\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(n8r*zkey.nAdditions);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    let challenges = {};\n    let proof = new _proof_js__WEBPACK_IMPORTED_MODULE_4__.Proof(curve, logger);\n    const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_5__.Keccak256Transcript(curve);\n\n    if (logger) logger.debug(`> Reading Section ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.debug(`> Reading Section ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.debug(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 5 * sDomain);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 10 * sDomain);\n\n    if (logger) logger.debug(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 6 * sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 11 * sDomain);\n\n    if (logger) logger.debug(`> Reading Section ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_PTAU_SECTION}. Powers of Tau`);\n    const PTau = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_PTAU_SECTION);\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const pub = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.debug(\"\");\n    if (logger) logger.debug(\"> ROUND 1\");\n    await round1();\n\n    if (logger) logger.debug(\"> ROUND 2\");\n    await round2();\n\n    if (logger) logger.debug(\"> ROUND 3\");\n    await round3();\n\n    if (logger) logger.debug(\"> ROUND 4\");\n    await round4();\n\n    if (logger) logger.debug(\"> ROUND 5\");\n    await round5();\n\n    ///////////////////////\n    // Final adjustments //\n    ///////////////////////\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    // Prepare proof\n    let _proof = proof.toObjectProof(false);\n    _proof.protocol = \"plonk\";\n    _proof.curve = curve.name;\n    \n    if (logger) logger.debug(\"PLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.debug(\" Computing additions\");\n        const additionsBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + n8r * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.debug(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + n8r);\n            offset += n8r;\n            const factor2 = additionsBuff.slice(offset, offset + n8r);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, n8r * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o+4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        if (idx < zkey.nVars-zkey.nAdditions) {\n            return buffWitness.slice(idx*n8r, idx*n8r+n8r);\n        } else if (idx < zkey.nVars) {\n            return buffInternalWitness.slice((idx - (zkey.nVars-zkey.nAdditions))*n8r, (idx-(zkey.nVars-zkey.nAdditions))*n8r + n8r);\n        } else {\n            return curve.Fr.zero;\n        }\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b1, ..., b11)  F\n        challenges.b = [];\n        for (let i=1; i<=11; i++) {\n            challenges.b[i] = curve.Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.debug(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute [a]_1, [b]_1, [c]_1\n        if (logger) logger.debug(\"> Computing A, B, C MSM\");\n        let commitA = await polynomials.A.multiExponentiation(PTau, \"A\");\n        let commitB = await polynomials.B.multiExponentiation(PTau, \"B\");\n        let commitC = await polynomials.C.multiExponentiation(PTau, \"C\");\n\n        // First output of the prover is ([A]_1, [B]_1, [C]_1)\n        proof.addPolynomial(\"A\", commitA);\n        proof.addPolynomial(\"B\", commitB);\n        proof.addPolynomial(\"C\", commitC);\n\n        return 0;\n    }\n\n    async function computeWirePolynomials() {\n        if (logger) logger.debug(\" Reading data from zkey file\");\n\n        // Build A, B and C evaluations buffer from zkey and witness files\n        buffers.A = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n        buffers.B = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n        buffers.C = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n        // Read zkey file to the buffers\n        const aMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_A_MAP_SECTION);\n        const bMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_B_MAP_SECTION);\n        const cMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_C_MAP_SECTION);\n\n        // Compute all witness from signal ids and set them to A,B & C buffers\n        for (let i = 0; i < zkey.nConstraints; i++) {\n            const i_sFr = i * n8r;\n            const offset = i * 4;\n\n            // Compute A value from a signal id\n            const signalIdA = readUInt32(aMapBuff, offset);\n            buffers.A.set(getWitness(signalIdA), i_sFr);\n\n            // Compute B value from a signal id\n            const signalIdB = readUInt32(bMapBuff, offset);\n            buffers.B.set(getWitness(signalIdB), i_sFr);\n\n            // Compute C value from a signal id\n            const signalIdC = readUInt32(cMapBuff, offset);\n            buffers.C.set(getWitness(signalIdC), i_sFr);\n        }\n\n        buffers.A = await Fr.batchToMontgomery(buffers.A);\n        buffers.B = await Fr.batchToMontgomery(buffers.B);\n        buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n        // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n        if (logger) logger.debug(\" Computing A ifft\");\n        polynomials.A = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.A, curve, logger);\n        if (logger) logger.debug(\" Computing B ifft\");\n        polynomials.B = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.B, curve, logger);\n        if (logger) logger.debug(\" Computing C ifft\");\n        polynomials.C = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n        // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n        if (logger) logger.debug(\" Computing A fft\");\n        evaluations.A = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n        if (logger) logger.debug(\" Computing B fft\");\n        evaluations.B = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n        if (logger) logger.debug(\" Computing C fft\");\n        evaluations.C = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n        // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n        polynomials.A.blindCoefficients([challenges.b[2], challenges.b[1]]);\n        polynomials.B.blindCoefficients([challenges.b[4], challenges.b[3]]);\n        polynomials.C.blindCoefficients([challenges.b[6], challenges.b[5]]);\n\n        // Check degrees\n        if (polynomials.A.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"A Polynomial is not well calculated\");\n        }\n        if (polynomials.B.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"B Polynomial is not well calculated\");\n        }\n        if (polynomials.C.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"C Polynomial is not well calculated\");\n        }        \n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.debug(\"> Computing challenges beta and gamma\");\n        transcript.reset();\n\n        transcript.addPolCommitment(zkey.Qm);\n        transcript.addPolCommitment(zkey.Ql);\n        transcript.addPolCommitment(zkey.Qr);\n        transcript.addPolCommitment(zkey.Qo);\n        transcript.addPolCommitment(zkey.Qc);\n        transcript.addPolCommitment(zkey.S1);\n        transcript.addPolCommitment(zkey.S2);\n        transcript.addPolCommitment(zkey.S3);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * n8r, i * n8r + n8r));\n        }\n\n        // Add A, B, C to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"A\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"B\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"C\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.beta: \" + Fr.toString(challenges.beta, 16));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.gamma: \" + Fr.toString(challenges.gamma, 16));\n    \n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.debug(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute permutation [z]_1\n        if (logger) logger.debug(\"> Computing Z MSM\");\n        let commitZ = await polynomials.Z.multiExponentiation(PTau, \"Z\");\n\n        // Second output of the prover is ([Z]_1)\n        proof.addPolynomial(\"Z\", commitZ);\n    }\n\n    async function computeZ() {\n        if (logger) logger.debug(\" Computing Z evaluations\");\n\n        let numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n        let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n        // Set the first values to 1\n        numArr.set(Fr.one, 0);\n        denArr.set(Fr.one, 0);\n\n        // Set initial omega\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_n8r = i * n8r;\n            \n            const a = buffers.A.slice(i_n8r, i_n8r + n8r);\n            const b = buffers.B.slice(i_n8r, i_n8r + n8r);\n            const c = buffers.C.slice(i_n8r, i_n8r + n8r);\n\n            // Z(X) := numArr / denArr\n            // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n            const betaw = Fr.mul(challenges.beta, w);\n\n            let n1 = Fr.add(a, betaw);\n            n1 = Fr.add(n1, challenges.gamma);\n\n            let n2 = Fr.add(b, Fr.mul(zkey.k1, betaw));\n            n2 = Fr.add(n2, challenges.gamma);\n\n            let n3 = Fr.add(c, Fr.mul(zkey.k2, betaw));\n            n3 = Fr.add(n3, challenges.gamma);\n\n            let num = Fr.mul(n1, Fr.mul(n2, n3));\n\n            // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n            let d1 = Fr.add(a, Fr.mul(evaluations.Sigma1.getEvaluation(i * 4), challenges.beta));\n            d1 = Fr.add(d1, challenges.gamma);\n\n            let d2 = Fr.add(b, Fr.mul(evaluations.Sigma2.getEvaluation(i * 4), challenges.beta));\n            d2 = Fr.add(d2, challenges.gamma);\n\n            let d3 = Fr.add(c, Fr.mul(evaluations.Sigma3.getEvaluation(i * 4), challenges.beta));\n            d3 = Fr.add(d3, challenges.gamma);\n\n            let den = Fr.mul(d1, Fr.mul(d2, d3));\n\n            // Multiply current num value with the previous one saved in numArr\n            num = Fr.mul(numArr.slice(i_n8r, i_n8r + n8r), num);\n            numArr.set(num, ((i + 1) % zkey.domainSize) * n8r);\n\n            // Multiply current den value with the previous one saved in denArr\n            den = Fr.mul(denArr.slice(i_n8r, i_n8r + n8r), den);\n            denArr.set(den, ((i + 1) % zkey.domainSize) * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        // Compute the inverse of denArr to compute in the next command the\n        // division numArr/denArr by multiplying num  1/denArr\n        denArr = await Fr.batchInverse(denArr);\n\n        // TODO: Do it in assembly and in parallel\n        // Multiply numArr  denArr where denArr was inverted in the previous command\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_sFr = i * n8r;\n\n            const z = Fr.mul(numArr.slice(i_sFr, i_sFr + n8r), denArr.slice(i_sFr, i_sFr + n8r));\n            numArr.set(z, i_sFr);\n        }\n\n        // From now on the values saved on numArr will be Z(X) buffer\n        buffers.Z = numArr;\n\n        if (!Fr.eq(numArr.slice(0, n8r), Fr.one)) {\n            throw new Error(\"Copy constraints does not match\");\n        }\n\n        // Compute polynomial coefficients z(X) from buffers.Z\n        if (logger) logger.debug(\" Computing Z ifft\");\n        polynomials.Z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n        // Compute extended evaluations of z(X) polynomial\n        if (logger) logger.debug(\" Computing Z fft\");\n        evaluations.Z = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n        // Blind z(X) polynomial coefficients with blinding scalars b\n        polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n        // Check degree\n        if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n            throw new Error(\"Z Polynomial is not well calculated\");\n        }\n\n        delete buffers.Z;\n    }\n\n    async function round3() {\n        if (logger) logger.debug(\"> Computing challenge alpha\");\n\n        // STEP 3.1 - Compute evaluation challenge alpha  F\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"Z\"));\n\n        challenges.alpha = transcript.getChallenge();\n        challenges.alpha2 = Fr.square(challenges.alpha);\n        if (logger) logger.debug(\" challenges.alpha: \" + Fr.toString(challenges.alpha, 16));\n\n        // Compute quotient polynomial T(X)\n        if (logger) logger.debug(\"> Computing T polynomial\");\n        await computeT();\n\n        // Compute [T1]_1, [T2]_1, [T3]_1\n        if (logger) logger.debug(\"> Computing T MSM\");\n        let commitT1 = await polynomials.T1.multiExponentiation(PTau, \"T1\");\n        let commitT2 = await polynomials.T2.multiExponentiation(PTau, \"T2\");\n        let commitT3 = await polynomials.T3.multiExponentiation(PTau, \"T3\");\n\n        // Third output of the prover is ([T1]_1, [T2]_1, [T3]_1)\n        proof.addPolynomial(\"T1\", commitT1);\n        proof.addPolynomial(\"T2\", commitT2);\n        proof.addPolynomial(\"T3\", commitT3);        \n    }\n\n    async function computeT() {\n        if (logger)\n            logger.debug(` Reading sections ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QL_SECTION}, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QR_SECTION}` +\n                `, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QM_SECTION}, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QO_SECTION}, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QC_SECTION}. Q selectors`);\n        // Reserve memory for Q's evaluations\n        evaluations.QL = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QR = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QM = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QO = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QC = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QL_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QR_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QM_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QO_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QC_SECTION][0].p + sDomain);\n\n        // Read Lagrange polynomials & evaluations from zkey file\n        evaluations.Lagrange = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4 * zkey.nPublic), curve, logger);\n\n        for (let i = 0; i < zkey.nPublic; i++) {\n            await fdZKey.readToBuffer(evaluations.Lagrange.eval, i * sDomain * 4, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_LAGRANGE_SECTION][0].p + i * 5 * sDomain + sDomain);\n        }\n\n        buffers.T = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n        buffers.Tz = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n\n        if (logger) logger.debug(\" Computing T evaluations\");\n\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize * 4; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0))\n                logger.debug(`      T evaluation ${i}/${zkey.domainSize * 4}`);\n\n            const a = evaluations.A.getEvaluation(i);\n            const b = evaluations.B.getEvaluation(i);\n            const c = evaluations.C.getEvaluation(i);\n            const z = evaluations.Z.getEvaluation(i);\n            const zw = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n            const qm = evaluations.QM.getEvaluation(i);\n            const ql = evaluations.QL.getEvaluation(i);\n            const qr = evaluations.QR.getEvaluation(i);\n            const qo = evaluations.QO.getEvaluation(i);\n            const qc = evaluations.QC.getEvaluation(i);\n            const s1 = evaluations.Sigma1.getEvaluation(i);\n            const s2 = evaluations.Sigma2.getEvaluation(i);\n            const s3 = evaluations.Sigma3.getEvaluation(i);\n\n            const ap = Fr.add(challenges.b[2], Fr.mul(challenges.b[1], w));\n            const bp = Fr.add(challenges.b[4], Fr.mul(challenges.b[3], w));\n            const cp = Fr.add(challenges.b[6], Fr.mul(challenges.b[5], w));\n\n            const w2 = Fr.square(w);\n            const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], w2), Fr.mul(challenges.b[8], w)), challenges.b[9]);\n            const wW = Fr.mul(w, Fr.w[zkey.power]);\n            const wW2 = Fr.square(wW);\n            const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], wW2), Fr.mul(challenges.b[8], wW)), challenges.b[9]);\n\n            let pi = Fr.zero;\n            for (let j = 0; j < zkey.nPublic; j++) {\n                const offset = (j * 4 * zkey.domainSize) + i;\n\n                const lPol = evaluations.Lagrange.getEvaluation(offset);\n                const aVal = buffers.A.slice(j * n8r, (j + 1) * n8r);\n\n                pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n            }\n\n            // e1 := a(X)b(X)qM(X) + a(X)qL(X) + b(X)qR(X) + c(X)qO(X) + PI(X) + qC(X)\n            let [e1, e1z] = _mul_z_js__WEBPACK_IMPORTED_MODULE_6__.MulZ.mul2(a, b, ap, bp, i % 4, Fr);\n            e1 = Fr.mul(e1, qm);\n            e1z = Fr.mul(e1z, qm);\n\n            e1 = Fr.add(e1, Fr.mul(a, ql));\n            e1z = Fr.add(e1z, Fr.mul(ap, ql));\n\n            e1 = Fr.add(e1, Fr.mul(b, qr));\n            e1z = Fr.add(e1z, Fr.mul(bp, qr));\n\n            e1 = Fr.add(e1, Fr.mul(c, qo));\n            e1z = Fr.add(e1z, Fr.mul(cp, qo));\n\n            e1 = Fr.add(e1, pi);\n            e1 = Fr.add(e1, qc);\n\n            // e2 := [(a(X) + X + )(b(X) + k1X + )(c(X) + k2X + )z(X)]\n            const betaw = Fr.mul(challenges.beta, w);\n            let e2a = a;\n            e2a = Fr.add(e2a, betaw);\n            e2a = Fr.add(e2a, challenges.gamma);\n\n            let e2b = b;\n            e2b = Fr.add(e2b, Fr.mul(betaw, zkey.k1));\n            e2b = Fr.add(e2b, challenges.gamma);\n\n            let e2c = c;\n            e2c = Fr.add(e2c, Fr.mul(betaw, zkey.k2));\n            e2c = Fr.add(e2c, challenges.gamma);\n\n            let e2d = z;\n\n            let [e2, e2z] = _mul_z_js__WEBPACK_IMPORTED_MODULE_6__.MulZ.mul4(e2a, e2b, e2c, e2d, ap, bp, cp, zp, i % 4, Fr);\n            e2 = Fr.mul(e2, challenges.alpha);\n            e2z = Fr.mul(e2z, challenges.alpha);\n\n            // e3 := [(a(X) + S1(X) + )(b(X) + S2(X) + )(c(X) + S3(X) + )z(X)]\n            let e3a = a;\n            e3a = Fr.add(e3a, Fr.mul(challenges.beta, s1));\n            e3a = Fr.add(e3a, challenges.gamma);\n\n            let e3b = b;\n            e3b = Fr.add(e3b, Fr.mul(challenges.beta, s2));\n            e3b = Fr.add(e3b, challenges.gamma);\n\n            let e3c = c;\n            e3c = Fr.add(e3c, Fr.mul(challenges.beta, s3));\n            e3c = Fr.add(e3c, challenges.gamma);\n\n            let e3d = zw;\n            let [e3, e3z] = _mul_z_js__WEBPACK_IMPORTED_MODULE_6__.MulZ.mul4(e3a, e3b, e3c, e3d, ap, bp, cp, zWp, i % 4, Fr);\n\n            e3 = Fr.mul(e3, challenges.alpha);\n            e3z = Fr.mul(e3z, challenges.alpha);\n\n            // e4 := ^2(z(X)1)L1(X)\n            let e4 = Fr.sub(z, Fr.one);\n            e4 = Fr.mul(e4, evaluations.Lagrange.getEvaluation(i));\n            e4 = Fr.mul(e4, challenges.alpha2);\n\n            let e4z = Fr.mul(zp, evaluations.Lagrange.getEvaluation(i));\n            e4z = Fr.mul(e4z, challenges.alpha2);\n\n\n            let t = Fr.add(Fr.sub(Fr.add(e1, e2), e3), e4);\n            let tz = Fr.add(Fr.sub(Fr.add(e1z, e2z), e3z), e4z);\n\n            buffers.T.set(t, i * n8r);\n            buffers.Tz.set(tz, i * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power + 2]);\n        }\n\n        // Compute the coefficients of the polynomial T0(X) from buffers.T0\n        if (logger)\n            logger.debug(\" Computing T ifft\");\n        polynomials.T = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T, curve, logger);\n\n        // Divide the polynomial T0 by Z_H(X)\n        if (logger)\n            logger.debug(\" Computing T / ZH\");\n        polynomials.T.divZh(zkey.domainSize, 4);\n\n        // Compute the coefficients of the polynomial Tz(X) from buffers.Tz\n        if (logger)\n            logger.debug(\" Computing Tz ifft\");\n        polynomials.Tz = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.Tz, curve, logger);\n\n        // Add the polynomial T1z to T1 to get the final polynomial T1\n        polynomials.T.add(polynomials.Tz);\n\n        // Check degree\n        if (polynomials.T.degree() >= zkey.domainSize * 3 + 6) {\n            throw new Error(\"T Polynomial is not well calculated\");\n        }\n\n        // t(x) has degree 3n + 5, we are going to split t(x) into three smaller polynomials:\n        // T1' and T2'  with a degree < n and T3' with a degree n+5\n        // such that t(x) = T1'(X) + X^n T2'(X) + X^{2n} T3'(X)\n        // To randomize the parts we use blinding scalars b_10 and b_11 in a way that doesn't change t(X):\n        // T1(X) = T1'(X) + b_10 X^n\n        // T2(X) = T2'(X) - b_10 + b_11 X^n\n        // T3(X) = T3'(X) - b_11\n        // such that\n        // t(X) = T1(X) + X^n T2(X) + X^2n T3(X)\n        if (logger) logger.debug(\" Computing T1, T2, T3 polynomials\");\n        polynomials.T1 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T2 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T3 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.T1.coef.set(polynomials.T.coef.slice(0, sDomain), 0);\n        polynomials.T2.coef.set(polynomials.T.coef.slice(sDomain, sDomain * 2), 0);\n        polynomials.T3.coef.set(polynomials.T.coef.slice(sDomain * 2, sDomain * 3 + 6 * n8r), 0);\n\n        // Add blinding scalar b_10 as a new coefficient n\n        polynomials.T1.setCoef(zkey.domainSize, challenges.b[10]);\n\n        // compute t_mid(X)\n        // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        const lowestMid = Fr.sub(polynomials.T2.getCoef(0), challenges.b[10]);\n        polynomials.T2.setCoef(0, lowestMid);\n        polynomials.T2.setCoef(zkey.domainSize, challenges.b[11]);\n\n        // compute t_high(X)\n        //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        const lowestHigh = Fr.sub(polynomials.T3.getCoef(0), challenges.b[11]);\n        polynomials.T3.setCoef(0, lowestHigh);\n    }\n\n    async function round4() {\n        if (logger) logger.debug(\"> Computing challenge xi\");\n\n        // STEP 4.1 - Compute evaluation challenge xi  F\n        transcript.reset();\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"T1\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T2\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T3\"));\n\n        challenges.xi = transcript.getChallenge();\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        \n        if (logger) logger.debug(\" challenges.xi: \" + Fr.toString(challenges.xi, 16));  \n\n        // Fourth output of the prover is ( a(xi), b(xi), c(xi), s1(xi), s2(xi), z(xiw) )\n        proof.addEvaluation(\"eval_a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_zw\", polynomials.Z.evaluate(challenges.xiw));\n    }\n\n    async function round5() {\n        if (logger) logger.debug(\"> Computing challenge v\");\n        \n        // STEP 5.1 - Compute evaluation challenge v  F\n        transcript.reset();\n        transcript.addScalar(challenges.xi);\n        transcript.addScalar(proof.getEvaluation(\"eval_a\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_b\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_c\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s1\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s2\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_zw\"));\n\n        challenges.v = [];\n        challenges.v[1] = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.v: \" + Fr.toString(challenges.v[1], 16));\n\n        for (let i = 2; i < 6; i++) {\n            challenges.v[i] = Fr.mul(challenges.v[i - 1], challenges.v[1]);\n        }\n\n        // STEP 5.2 Compute linearisation polynomial r(X)\n        if (logger) logger.debug(\"> Computing linearisation polynomial R(X)\");\n        await computeR();\n\n        //STEP 5.3 Compute opening proof polynomial Wxi(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxi(X) polynomial\");\n        computeWxi();\n\n        //STEP 5.4 Compute opening proof polynomial Wxiw(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxiw(X) polynomial\");\n        computeWxiw();\n\n        if (logger) logger.debug(\"> Computing Wxi, Wxiw MSM\");\n        let commitWxi = await polynomials.Wxi.multiExponentiation(PTau, \"Wxi\");\n        let commitWxiw = await polynomials.Wxiw.multiExponentiation(PTau, \"Wxiw\");\n\n        // Fifth output of the prover is ([Wxi]_1, [Wxiw]_1)\n        proof.addPolynomial(\"Wxi\", commitWxi);\n        proof.addPolynomial(\"Wxiw\", commitWxiw);\n    }\n\n    async function computeR() {\n        const Fr = curve.Fr;\n    \n        // Reserve memory for Q's polynomials\n        polynomials.QL = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QC_SECTION][0].p);   \n        \n        challenges.xin = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            challenges.xin = Fr.square(challenges.xin);\n        }\n\n        challenges.zh = Fr.sub(challenges.xin, Fr.one);\n\n        const L = [];\n\n        const n = Fr.e(zkey.domainSize);\n        let w = Fr.one;\n        for (let i = 1; i <= Math.max(1, zkey.nPublic); i++) {\n            L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        const eval_l1 = Fr.div(\n            Fr.sub(challenges.xin, Fr.one),\n            Fr.mul(n, Fr.sub(challenges.xi, Fr.one))\n        );\n\n        if (logger) {\n            logger.debug(\"Lagrange Evaluations: \");\n            for (let i=1; i<L.length; i++) {\n                logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));    \n            }\n        }\n\n        let eval_pi = Fr.zero;\n        for (let i=0; i<publicSignals.length; i++) {\n            const w = Fr.e(publicSignals[i]);\n            eval_pi = Fr.sub(eval_pi, Fr.mul(w, L[i+1]));\n        }\n\n        if (logger) logger.debug(\"PI: \" + Fr.toString(eval_pi, 16));\n\n        // Compute constant parts of R(X)\n        const coef_ab = Fr.mul(proof.evaluations.eval_a, proof.evaluations.eval_b);\n\n        let e2a = proof.evaluations.eval_a;\n        const betaxi = Fr.mul(challenges.beta, challenges.xi);\n        e2a = Fr.add(e2a, betaxi);\n        e2a = Fr.add(e2a, challenges.gamma);\n\n        let e2b = proof.evaluations.eval_b;\n        e2b = Fr.add(e2b, Fr.mul(betaxi, zkey.k1));\n        e2b = Fr.add(e2b, challenges.gamma);\n\n        let e2c = proof.evaluations.eval_c;\n        e2c = Fr.add(e2c, Fr.mul(betaxi, zkey.k2));\n        e2c = Fr.add(e2c, challenges.gamma);\n\n        const e2 = Fr.mul(Fr.mul(Fr.mul(e2a, e2b), e2c), challenges.alpha);\n\n        let e3a = proof.evaluations.eval_a;\n        e3a = Fr.add(e3a, Fr.mul(challenges.beta, proof.evaluations.eval_s1));\n        e3a = Fr.add(e3a, challenges.gamma);\n\n        let e3b = proof.evaluations.eval_b;\n        e3b = Fr.add(e3b, Fr.mul(challenges.beta, proof.evaluations.eval_s2));\n        e3b = Fr.add(e3b, challenges.gamma);\n\n        let e3 = Fr.mul(e3a, e3b);\n        e3 = Fr.mul(e3, proof.evaluations.eval_zw);\n        e3 = Fr.mul(e3, challenges.alpha);\n\n        const e4 = Fr.mul(eval_l1, challenges.alpha2);\n\n        polynomials.R = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.R.add(polynomials.QM, coef_ab);\n        polynomials.R.add(polynomials.QL, proof.evaluations.eval_a);\n        polynomials.R.add(polynomials.QR, proof.evaluations.eval_b);\n        polynomials.R.add(polynomials.QO, proof.evaluations.eval_c);\n        polynomials.R.add(polynomials.QC);\n        polynomials.R.add(polynomials.Z, e2);\n        polynomials.R.sub(polynomials.Sigma3, Fr.mul(e3, challenges.beta));\n        polynomials.R.add(polynomials.Z, e4);\n\n        let tmp = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.T3, curve, logger);\n        tmp.mulScalar(Fr.square(challenges.xin));\n        tmp.add(polynomials.T2, challenges.xin);\n        tmp.add(polynomials.T1);\n        tmp.mulScalar(challenges.zh);\n\n        polynomials.R.sub(tmp);\n\n        let r0 = Fr.sub(eval_pi, Fr.mul(e3, Fr.add(proof.evaluations.eval_c, challenges.gamma)));\n        r0 = Fr.sub(r0, e4);\n\n        if (logger) logger.debug(\"r0: \" + Fr.toString(r0, 16));\n\n        polynomials.R.addScalar(r0);\n    }\n\n    function computeWxi() {\n        polynomials.Wxi = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain + 6 * n8r), curve, logger);\n\n        polynomials.Wxi.add(polynomials.R);\n        polynomials.Wxi.add(polynomials.A, challenges.v[1]);\n        polynomials.Wxi.add(polynomials.B, challenges.v[2]);\n        polynomials.Wxi.add(polynomials.C, challenges.v[3]);\n        polynomials.Wxi.add(polynomials.Sigma1, challenges.v[4]);\n        polynomials.Wxi.add(polynomials.Sigma2, challenges.v[5]);\n\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[1], proof.evaluations.eval_a));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[2], proof.evaluations.eval_b));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[3], proof.evaluations.eval_c));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[4], proof.evaluations.eval_s1));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[5], proof.evaluations.eval_s2));\n\n        polynomials.Wxi.divByZerofier(1, challenges.xi);\n    }\n\n    async function computeWxiw() {\n        polynomials.Wxiw = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.Z, curve, logger);\n        polynomials.Wxiw.subScalar(proof.evaluations.eval_zw);\n\n        polynomials.Wxiw.divByZerofier(1, challenges.xiw);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfcHJvdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVvRDtBQUNQO0FBQ0E7QUFDVztBQUN4RCxPQUFPLGtCQUFrQixFQUFFLCtDQUFLO0FBQ0c7QUFDNEI7QUFDN0I7QUFjSjtBQUMwQjtBQUNFO0FBQzFEO0FBQ2U7QUFDZixXQUFXLG9DQUFvQyxRQUFRLDREQUF3Qjs7QUFFL0U7QUFDQTtBQUNBLHVCQUF1QixzREFBb0I7O0FBRTNDO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQyxRQUFRLDREQUF3Qjs7QUFFL0UsdUJBQXVCLHNEQUFvQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUEsU0FBUyxnREFBTTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsV0FBVyxhQUFhLGNBQWMsSUFBSSxnQkFBZ0I7QUFDdEg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BELHlDQUF5QyxXQUFXO0FBQ3BELHlDQUF5QyxnQkFBZ0I7QUFDekQseUNBQXlDLFdBQVc7QUFDcEQseUNBQXlDLGFBQWE7QUFDdEQseUNBQXlDLGtCQUFrQjtBQUMzRCx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qiw0REFBd0I7O0FBRXREO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBUzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDRDQUFLO0FBQ3pCLDJCQUEyQix3RUFBbUI7O0FBRTlDLGtEQUFrRCwwRUFBeUIsQ0FBQztBQUM1RTs7QUFFQSxrREFBa0Qsc0VBQXFCLENBQUM7QUFDeEU7QUFDQSw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUzs7QUFFckQsZ0ZBQWdGLHNFQUFxQjtBQUNyRyxnRkFBZ0Ysc0VBQXFCO0FBQ3JHLGdGQUFnRixzRUFBcUI7O0FBRXJHO0FBQ0EsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7QUFDdEQsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7QUFDdEQsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7O0FBRXRELG9GQUFvRixzRUFBcUI7QUFDekcsb0ZBQW9GLHNFQUFxQjtBQUN6RyxvRkFBb0Ysc0VBQXFCOztBQUV6RyxrREFBa0QscUVBQW9CLENBQUM7QUFDdkUsdUJBQXVCLDREQUF3Qix1QkFBdUIscUVBQW9COztBQUUxRjs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0EsMkJBQTJCLGdEQUFNO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLDREQUF3Qix1QkFBdUIsMEVBQXlCOztBQUU1RztBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHFCQUFxQjtBQUM3Qyx3RkFBd0YsRUFBRSxHQUFHLGdCQUFnQjs7QUFFN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsbURBQVM7QUFDakMsd0JBQXdCLG1EQUFTO0FBQ2pDLHdCQUF3QixtREFBUzs7QUFFakM7QUFDQSwrQkFBK0IsNERBQXdCLHVCQUF1QixzRUFBcUI7QUFDbkcsK0JBQStCLDREQUF3Qix1QkFBdUIsc0VBQXFCO0FBQ25HLCtCQUErQiw0REFBd0IsdUJBQXVCLHNFQUFxQjs7QUFFbkc7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixpRUFBVTtBQUN4QztBQUNBLDhCQUE4QixpRUFBVTtBQUN4QztBQUNBLDhCQUE4QixpRUFBVTs7QUFFeEM7QUFDQTtBQUNBLDhCQUE4QixtRUFBVztBQUN6QztBQUNBLDhCQUE4QixtRUFBVztBQUN6QztBQUNBLDhCQUE4QixtRUFBVzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixtREFBUztBQUNsQyx5QkFBeUIsbURBQVM7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsaUVBQVU7O0FBRXhDO0FBQ0E7QUFDQSw4QkFBOEIsbUVBQVc7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxtRUFBa0IsQ0FBQyxJQUFJLG1FQUFrQixDQUFDO0FBQzNGLHFCQUFxQixtRUFBa0IsQ0FBQyxJQUFJLG1FQUFrQixDQUFDLElBQUksbUVBQWtCLENBQUM7QUFDdEY7QUFDQSw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUztBQUN0RCw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUztBQUN0RCw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUztBQUN0RCw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUztBQUN0RCw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUzs7QUFFdEQ7QUFDQSxvRkFBb0YsbUVBQWtCO0FBQ3RHLG9GQUFvRixtRUFBa0I7QUFDdEcsb0ZBQW9GLG1FQUFrQjtBQUN0RyxvRkFBb0YsbUVBQWtCO0FBQ3RHLG9GQUFvRixtRUFBa0I7O0FBRXRHO0FBQ0EsbUNBQW1DLG1FQUFXLEtBQUssbURBQVM7O0FBRTVELHdCQUF3QixrQkFBa0I7QUFDMUMsNEdBQTRHLHlFQUF3QjtBQUNwSTs7QUFFQSx3QkFBd0IsbURBQVM7QUFDakMseUJBQXlCLG1EQUFTOztBQUVsQzs7QUFFQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQSxtREFBbUQsRUFBRSxHQUFHLG9CQUFvQjs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsMkNBQUk7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsMkNBQUk7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDJDQUFJOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpRUFBVTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFVOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7O0FBRXJEO0FBQ0EsZ0ZBQWdGLG1FQUFrQjtBQUNsRyxnRkFBZ0YsbUVBQWtCO0FBQ2xHLGdGQUFnRixtRUFBa0I7QUFDbEcsZ0ZBQWdGLG1FQUFrQjtBQUNsRyxnRkFBZ0YsbUVBQWtCO0FBQ2xHO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QyxpQ0FBaUMsRUFBRTtBQUNuQztBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixpRUFBVSxLQUFLLG1EQUFTOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpRUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsaUVBQVUsS0FBSyxtREFBUzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixpRUFBVTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfcHJvdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMSAwa2ltcyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLyogSW1wbGVtZW50YXRpb24gb2YgdGhpcyBwYXBlcjogaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxOS85NTMucGRmIHNlY3Rpb24gOC40ICovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIHd0bnNVdGlscyBmcm9tIFwiLi93dG5zX3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBTY2FsYXIsIHV0aWxzLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5jb25zdCB7c3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcbmltcG9ydCB7IFByb29mIH0gZnJvbSBcIi4vcHJvb2YuanNcIjtcbmltcG9ydCB7IEtlY2NhazI1NlRyYW5zY3JpcHQgfSBmcm9tIFwiLi9LZWNjYWsyNTZUcmFuc2NyaXB0LmpzXCI7XG5pbXBvcnQgeyBNdWxaIH0gZnJvbSBcIi4vbXVsX3ouanNcIjtcbmltcG9ydCB7ICBaS0VZX1BMX0hFQURFUl9TRUNUSU9OLFxuICAgIFpLRVlfUExfQURESVRJT05TX1NFQ1RJT04sXG4gICAgWktFWV9QTF9BX01BUF9TRUNUSU9OLFxuICAgIFpLRVlfUExfQl9NQVBfU0VDVElPTixcbiAgICBaS0VZX1BMX0NfTUFQX1NFQ1RJT04sXG4gICAgWktFWV9QTF9RTV9TRUNUSU9OLFxuICAgIFpLRVlfUExfUUxfU0VDVElPTixcbiAgICBaS0VZX1BMX1FSX1NFQ1RJT04sXG4gICAgWktFWV9QTF9RT19TRUNUSU9OLFxuICAgIFpLRVlfUExfUUNfU0VDVElPTixcbiAgICBaS0VZX1BMX1NJR01BX1NFQ1RJT04sXG4gICAgWktFWV9QTF9MQUdSQU5HRV9TRUNUSU9OLFxuICAgIFpLRVlfUExfUFRBVV9TRUNUSU9OLFxufSBmcm9tIFwiLi9wbG9ua19jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IFBvbHlub21pYWwgfSBmcm9tIFwiLi9wb2x5bm9taWFsL3BvbHlub21pYWwuanNcIjtcbmltcG9ydCB7IEV2YWx1YXRpb25zIH0gZnJvbSBcIi4vcG9seW5vbWlhbC9ldmFsdWF0aW9ucy5qc1wiO1xuICAgIFxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGxvbmsxNlByb3ZlKHprZXlGaWxlTmFtZSwgd2l0bmVzc0ZpbGVOYW1lLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7ZmQ6IGZkV3Rucywgc2VjdGlvbnM6IHNlY3Rpb25zV3Ruc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUod2l0bmVzc0ZpbGVOYW1lLCBcInd0bnNcIiwgMiwgMTw8MjUsIDE8PDIzKTtcblxuICAgIC8vIFJlYWQgd2l0bmVzcyBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBSZWFkaW5nIHdpdG5lc3MgZmlsZVwiKTtcbiAgICBjb25zdCB3dG5zID0gYXdhaXQgd3Ruc1V0aWxzLnJlYWRIZWFkZXIoZmRXdG5zLCBzZWN0aW9uc1d0bnMpO1xuXG4gICAgLy8gUmVhZCB6a2V5IGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJlYWRpbmcgemtleSBmaWxlXCIpO1xuICAgIGNvbnN0IHtmZDogZmRaS2V5LCBzZWN0aW9uczogemtleVNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkWktleSwgemtleVNlY3Rpb25zLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIGlmICh6a2V5LnByb3RvY29sICE9IFwicGxvbmtcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IHBsb25rXCIpO1xuICAgIH1cblxuICAgIGlmICghU2NhbGFyLmVxKHprZXkuciwgIHd0bnMucSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VydmUgb2YgdGhlIHdpdG5lc3MgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnZlIG9mIHRoZSBwcm92aW5nIGtleVwiKTtcbiAgICB9XG5cbiAgICBpZiAod3Rucy5uV2l0bmVzcyAhPSB6a2V5Lm5WYXJzIC16a2V5Lm5BZGRpdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHdpdG5lc3MgbGVuZ3RoLiBDaXJjdWl0OiAke3prZXkublZhcnN9LCB3aXRuZXNzOiAke3d0bnMubldpdG5lc3N9LCAke3prZXkubkFkZGl0aW9uc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJ2ZSA9IHprZXkuY3VydmU7XG5cbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IG44ciA9IGN1cnZlLkZyLm44O1xuICAgIGNvbnN0IHNEb21haW4gPSB6a2V5LmRvbWFpblNpemUgKiBuOHI7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIiAgUExPTksgUFJPVkUgU0VUVElOR1NcIik7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgICBDdXJ2ZTogICAgICAgICAke2N1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgICBDaXJjdWl0IHBvd2VyOiAke3prZXkucG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgICBEb21haW4gc2l6ZTogICAke3prZXkuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIFZhcnM6ICAgICAgICAgICR7emtleS5uVmFyc31gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIFB1YmxpYyB2YXJzOiAgICR7emtleS5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoYCAgQ29uc3RyYWludHM6ICAgJHt6a2V5Lm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIEFkZGl0aW9uczogICAgICR7emtleS5uQWRkaXRpb25zfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgIH1cblxuICAgIC8vUmVhZCB3aXRuZXNzIGRhdGFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJlYWRpbmcgd2l0bmVzcyBmaWxlIGRhdGFcIik7XG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRXdG5zLCBzZWN0aW9uc1d0bnMsIDIpO1xuXG4gICAgLy8gRmlyc3QgZWxlbWVudCBpbiBwbG9uayBpcyBub3QgdXNlZCBhbmQgY2FuIGJlIGFueSB2YWx1ZS4gKEJ1dCBhbHdheXMgdGhlIHNhbWUpLlxuICAgIC8vIFdlIHNldCBpdCB0byB6ZXJvIHRvIGdvIGZhc3RlciBpbiB0aGUgZXhwb25lbnRpYXRpb25zLlxuICAgIGJ1ZmZXaXRuZXNzLnNldChGci56ZXJvLCAwKTtcbiAgICBjb25zdCBidWZmSW50ZXJuYWxXaXRuZXNzID0gbmV3IEJpZ0J1ZmZlcihuOHIqemtleS5uQWRkaXRpb25zKTtcblxuICAgIGxldCBidWZmZXJzID0ge307XG4gICAgbGV0IHBvbHlub21pYWxzID0ge307XG4gICAgbGV0IGV2YWx1YXRpb25zID0ge307XG5cbiAgICBsZXQgY2hhbGxlbmdlcyA9IHt9O1xuICAgIGxldCBwcm9vZiA9IG5ldyBQcm9vZihjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGA+IFJlYWRpbmcgU2VjdGlvbiAke1pLRVlfUExfQURESVRJT05TX1NFQ1RJT059LiBBZGRpdGlvbnNgKTtcbiAgICBhd2FpdCBjYWxjdWxhdGVBZGRpdGlvbnMoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgPiBSZWFkaW5nIFNlY3Rpb24gJHtaS0VZX1BMX1NJR01BX1NFQ1RJT059LiBTaWdtYTEsIFNpZ21hMiAmIFNpZ21hIDNgKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgUmVhZGluZyBTaWdtYSBwb2x5bm9taWFscyBcIik7XG4gICAgcG9seW5vbWlhbHMuU2lnbWExID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgcG9seW5vbWlhbHMuU2lnbWEyID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgcG9seW5vbWlhbHMuU2lnbWEzID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlNpZ21hMS5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9TSUdNQV9TRUNUSU9OXVswXS5wKTtcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlNpZ21hMi5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9TSUdNQV9TRUNUSU9OXVswXS5wICsgNSAqIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWEzLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnAgKyAxMCAqIHNEb21haW4pO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IFJlYWRpbmcgU2lnbWEgZXZhbHVhdGlvbnNcIik7XG4gICAgZXZhbHVhdGlvbnMuU2lnbWExID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTIgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgIGV2YWx1YXRpb25zLlNpZ21hMyA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlNpZ21hMS5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfU0lHTUFfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEyLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9TSUdNQV9TRUNUSU9OXVswXS5wICsgNiAqIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEzLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9TSUdNQV9TRUNUSU9OXVswXS5wICsgMTEgKiBzRG9tYWluKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgPiBSZWFkaW5nIFNlY3Rpb24gJHtaS0VZX1BMX1BUQVVfU0VDVElPTn0uIFBvd2VycyBvZiBUYXVgKTtcbiAgICBjb25zdCBQVGF1ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX1BMX1BUQVVfU0VDVElPTik7XG5cbiAgICBsZXQgcHVibGljU2lnbmFscyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaT0xOyBpPD0gemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHViID0gYnVmZldpdG5lc3Muc2xpY2UoaSpGci5uOCwgaSpGci5uOCtGci5uOCk7XG4gICAgICAgIHB1YmxpY1NpZ25hbHMucHVzaChTY2FsYXIuZnJvbVJwckxFKHB1YikpO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlwiKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJPVU5EIDFcIik7XG4gICAgYXdhaXQgcm91bmQxKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJPVU5EIDJcIik7XG4gICAgYXdhaXQgcm91bmQyKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJPVU5EIDNcIik7XG4gICAgYXdhaXQgcm91bmQzKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJPVU5EIDRcIik7XG4gICAgYXdhaXQgcm91bmQ0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJPVU5EIDVcIik7XG4gICAgYXdhaXQgcm91bmQ1KCk7XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEZpbmFsIGFkanVzdG1lbnRzIC8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIGF3YWl0IGZkV3Rucy5jbG9zZSgpO1xuXG4gICAgLy8gUHJlcGFyZSBwcm9vZlxuICAgIGxldCBfcHJvb2YgPSBwcm9vZi50b09iamVjdFByb29mKGZhbHNlKTtcbiAgICBfcHJvb2YucHJvdG9jb2wgPSBcInBsb25rXCI7XG4gICAgX3Byb29mLmN1cnZlID0gY3VydmUubmFtZTtcbiAgICBcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJQTE9OSyBQUk9WRVIgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9vZjogc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpLFxuICAgICAgICBwdWJsaWNTaWduYWxzOiBzdHJpbmdpZnlCaWdJbnRzKHB1YmxpY1NpZ25hbHMpXG4gICAgfTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZUFkZGl0aW9ucygpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBhZGRpdGlvbnNcIik7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uc0J1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfUExfQURESVRJT05TX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIHNpemVzOiB3aXJlSWRfeCA9IDQgYnl0ZXMgKDMyIGJpdHMpLCBmYWN0b3JfeCA9IGZpZWxkIHNpemUgYml0c1xuICAgICAgICAvLyBBZGRpdGlvbiBmb3JtOiB3aXJlSWRfYSB3aXJlSWRfYiBmYWN0b3JfYSBmYWN0b3JfYiAoc2l6ZSBpcyA0ICsgNCArIHNGciArIHNGcilcbiAgICAgICAgY29uc3Qgc1N1bSA9IDggKyBuOHIgKiAyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uQWRkaXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmRlYnVnKGAgICAgYWRkaXRpb24gJHtpfS8ke3prZXkubkFkZGl0aW9uc31gKTtcblxuICAgICAgICAgICAgLy8gUmVhZCBhZGRpdGlvbiB2YWx1ZXNcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpICogc1N1bTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkMSA9IHJlYWRVSW50MzIoYWRkaXRpb25zQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWQyID0gcmVhZFVJbnQzMihhZGRpdGlvbnNCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IxID0gYWRkaXRpb25zQnVmZi5zbGljZShvZmZzZXQsIG9mZnNldCArIG44cik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbjhyO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yMiA9IGFkZGl0aW9uc0J1ZmYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBuOHIpO1xuXG4gICAgICAgICAgICAvLyBHZXQgd2l0bmVzcyB2YWx1ZVxuICAgICAgICAgICAgY29uc3Qgd2l0bmVzczEgPSBnZXRXaXRuZXNzKHNpZ25hbElkMSk7XG4gICAgICAgICAgICBjb25zdCB3aXRuZXNzMiA9IGdldFdpdG5lc3Moc2lnbmFsSWQyKTtcblxuICAgICAgICAgICAgLy9DYWxjdWxhdGUgZmluYWwgcmVzdWx0XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBGci5hZGQoRnIubXVsKGZhY3RvcjEsIHdpdG5lc3MxKSwgRnIubXVsKGZhY3RvcjIsIHdpdG5lc3MyKSk7XG5cbiAgICAgICAgICAgIGJ1ZmZJbnRlcm5hbFdpdG5lc3Muc2V0KHJlc3VsdCwgbjhyICogaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkVUludDMyKGIsIG8pIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGIuc2xpY2Uobywgbys0KTtcbiAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIsIGJ1ZmYuYnl0ZU9mZnNldCwgYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZWLmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaXRuZXNzKGlkeCkge1xuICAgICAgICBpZiAoaWR4IDwgemtleS5uVmFycy16a2V5Lm5BZGRpdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmV2l0bmVzcy5zbGljZShpZHgqbjhyLCBpZHgqbjhyK244cik7XG4gICAgICAgIH0gZWxzZSBpZiAoaWR4IDwgemtleS5uVmFycykge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZJbnRlcm5hbFdpdG5lc3Muc2xpY2UoKGlkeCAtICh6a2V5Lm5WYXJzLXprZXkubkFkZGl0aW9ucykpKm44ciwgKGlkeC0oemtleS5uVmFycy16a2V5Lm5BZGRpdGlvbnMpKSpuOHIgKyBuOHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnZlLkZyLnplcm87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDEoKSB7XG4gICAgICAgIC8vIFNURVAgMS4xIC0gR2VuZXJhdGUgcmFuZG9tIGJsaW5kaW5nIHNjYWxhcnMgKGIxLCAuLi4sIGIxMSkg4oiIIEZcbiAgICAgICAgY2hhbGxlbmdlcy5iID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MTsgaTw9MTE7IGkrKykge1xuICAgICAgICAgICAgY2hhbGxlbmdlcy5iW2ldID0gY3VydmUuRnIucmFuZG9tKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDEuMiAtIENvbXB1dGUgd2lyZSBwb2x5bm9taWFscyBhKFgpLCBiKFgpIGFuZCBjKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIEEsIEIsIEMgd2lyZSBwb2x5bm9taWFsc1wiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVdpcmVQb2x5bm9taWFscygpO1xuXG4gICAgICAgIC8vIFNURVAgMS4zIC0gQ29tcHV0ZSBbYV1fMSwgW2JdXzEsIFtjXV8xXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIEEsIEIsIEMgTVNNXCIpO1xuICAgICAgICBsZXQgY29tbWl0QSA9IGF3YWl0IHBvbHlub21pYWxzLkEubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIkFcIik7XG4gICAgICAgIGxldCBjb21taXRCID0gYXdhaXQgcG9seW5vbWlhbHMuQi5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiQlwiKTtcbiAgICAgICAgbGV0IGNvbW1pdEMgPSBhd2FpdCBwb2x5bm9taWFscy5DLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJDXCIpO1xuXG4gICAgICAgIC8vIEZpcnN0IG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbQV1fMSwgW0JdXzEsIFtDXV8xKVxuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiQVwiLCBjb21taXRBKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIkJcIiwgY29tbWl0Qik7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJDXCIsIGNvbW1pdEMpO1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVXaXJlUG9seW5vbWlhbHMoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBSZWFkaW5nIGRhdGEgZnJvbSB6a2V5IGZpbGVcIik7XG5cbiAgICAgICAgLy8gQnVpbGQgQSwgQiBhbmQgQyBldmFsdWF0aW9ucyBidWZmZXIgZnJvbSB6a2V5IGFuZCB3aXRuZXNzIGZpbGVzXG4gICAgICAgIGJ1ZmZlcnMuQSA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgIGJ1ZmZlcnMuQiA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgIGJ1ZmZlcnMuQyA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG5cbiAgICAgICAgLy8gUmVhZCB6a2V5IGZpbGUgdG8gdGhlIGJ1ZmZlcnNcbiAgICAgICAgY29uc3QgYU1hcEJ1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfUExfQV9NQVBfU0VDVElPTik7XG4gICAgICAgIGNvbnN0IGJNYXBCdWZmID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX1BMX0JfTUFQX1NFQ1RJT04pO1xuICAgICAgICBjb25zdCBjTWFwQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9QTF9DX01BUF9TRUNUSU9OKTtcblxuICAgICAgICAvLyBDb21wdXRlIGFsbCB3aXRuZXNzIGZyb20gc2lnbmFsIGlkcyBhbmQgc2V0IHRoZW0gdG8gQSxCICYgQyBidWZmZXJzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uQ29uc3RyYWludHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpICogbjhyO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDQ7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgQSB2YWx1ZSBmcm9tIGEgc2lnbmFsIGlkXG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZEEgPSByZWFkVUludDMyKGFNYXBCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgYnVmZmVycy5BLnNldChnZXRXaXRuZXNzKHNpZ25hbElkQSksIGlfc0ZyKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBCIHZhbHVlIGZyb20gYSBzaWduYWwgaWRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkQiA9IHJlYWRVSW50MzIoYk1hcEJ1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBidWZmZXJzLkIuc2V0KGdldFdpdG5lc3Moc2lnbmFsSWRCKSwgaV9zRnIpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIEMgdmFsdWUgZnJvbSBhIHNpZ25hbCBpZFxuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWRDID0gcmVhZFVJbnQzMihjTWFwQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQy5zZXQoZ2V0V2l0bmVzcyhzaWduYWxJZEMpLCBpX3NGcik7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXJzLkEgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkEpO1xuICAgICAgICBidWZmZXJzLkIgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkIpO1xuICAgICAgICBidWZmZXJzLkMgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkMpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgd2lyZSBwb2x5bm9taWFscyBhKFgpLCBiKFgpIGFuZCBjKFgpIGZyb20gQSxCICYgQyBidWZmZXJzXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgQSBpZmZ0XCIpO1xuICAgICAgICBwb2x5bm9taWFscy5BID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5BLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBCIGlmZnRcIik7XG4gICAgICAgIHBvbHlub21pYWxzLkIgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLkIsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIEMgaWZmdFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuQyA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuQywgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBleHRlbmRlZCBldmFsdWF0aW9ucyBvZiBhKFgpLCBiKFgpIGFuZCBjKFgpIHBvbHlub21pYWxzXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgQSBmZnRcIik7XG4gICAgICAgIGV2YWx1YXRpb25zLkEgPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5BLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBCIGZmdFwiKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuQiA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkIsIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIEMgZmZ0XCIpO1xuICAgICAgICBldmFsdWF0aW9ucy5DID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQywgNCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gQmxpbmQgYShYKSwgYihYKSBhbmQgYyhYKSBwb2x5bm9taWFscyBjb2VmZmljaWVudHMgd2l0aCBibGluZGluZyBzY2FsYXJzIGJcbiAgICAgICAgcG9seW5vbWlhbHMuQS5ibGluZENvZWZmaWNpZW50cyhbY2hhbGxlbmdlcy5iWzJdLCBjaGFsbGVuZ2VzLmJbMV1dKTtcbiAgICAgICAgcG9seW5vbWlhbHMuQi5ibGluZENvZWZmaWNpZW50cyhbY2hhbGxlbmdlcy5iWzRdLCBjaGFsbGVuZ2VzLmJbM11dKTtcbiAgICAgICAgcG9seW5vbWlhbHMuQy5ibGluZENvZWZmaWNpZW50cyhbY2hhbGxlbmdlcy5iWzZdLCBjaGFsbGVuZ2VzLmJbNV1dKTtcblxuICAgICAgICAvLyBDaGVjayBkZWdyZWVzXG4gICAgICAgIGlmIChwb2x5bm9taWFscy5BLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSArIDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2x5bm9taWFscy5CLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSArIDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkIgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2x5bm9taWFscy5DLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSArIDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkMgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9ICAgICAgICBcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDIoKSB7XG4gICAgICAgIC8vIFNURVAgMi4xIC0gQ29tcHV0ZSBwZXJtdXRhdGlvbiBjaGFsbGVuZ2UgYmV0YSBhbmQgZ2FtbWEg4oiIIEZcbiAgICAgICAgLy8gQ29tcHV0ZSBwZXJtdXRhdGlvbiBjaGFsbGVuZ2UgYmV0YVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBjaGFsbGVuZ2VzIGJldGEgYW5kIGdhbW1hXCIpO1xuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG5cbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUW0pO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5RbCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlFyKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUW8pO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5RYyk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlMxKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUzIpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5TMyk7XG5cbiAgICAgICAgLy8gQWRkIEEgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoYnVmZmVycy5BLnNsaWNlKGkgKiBuOHIsIGkgKiBuOHIgKyBuOHIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBBLCBCLCBDIHRvIHRoZSB0cmFuc2NyaXB0XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiQVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiQlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiQ1wiKSk7XG5cbiAgICAgICAgY2hhbGxlbmdlcy5iZXRhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IGNoYWxsZW5nZXMuYmV0YTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmJldGEsIDE2KSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBwZXJtdXRhdGlvbiBjaGFsbGVuZ2UgZ2FtbWFcbiAgICAgICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmJldGEpO1xuICAgICAgICBjaGFsbGVuZ2VzLmdhbW1hID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IGNoYWxsZW5nZXMuZ2FtbWE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5nYW1tYSwgMTYpKTtcbiAgICBcbiAgICAgICAgLy8gU1RFUCAyLjIgLSBDb21wdXRlIHBlcm11dGF0aW9uIHBvbHlub21pYWwgeihYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBaIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVaKCk7XG5cbiAgICAgICAgLy8gU1RFUCAyLjMgLSBDb21wdXRlIHBlcm11dGF0aW9uIFt6XV8xXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIFogTVNNXCIpO1xuICAgICAgICBsZXQgY29tbWl0WiA9IGF3YWl0IHBvbHlub21pYWxzLloubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlpcIik7XG5cbiAgICAgICAgLy8gU2Vjb25kIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbWl1fMSlcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlpcIiwgY29tbWl0Wik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVooKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgWiBldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICBsZXQgbnVtQXJyID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcbiAgICAgICAgbGV0IGRlbkFyciA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBmaXJzdCB2YWx1ZXMgdG8gMVxuICAgICAgICBudW1BcnIuc2V0KEZyLm9uZSwgMCk7XG4gICAgICAgIGRlbkFyci5zZXQoRnIub25lLCAwKTtcblxuICAgICAgICAvLyBTZXQgaW5pdGlhbCBvbWVnYVxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9uOHIgPSBpICogbjhyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBhID0gYnVmZmVycy5BLnNsaWNlKGlfbjhyLCBpX244ciArIG44cik7XG4gICAgICAgICAgICBjb25zdCBiID0gYnVmZmVycy5CLnNsaWNlKGlfbjhyLCBpX244ciArIG44cik7XG4gICAgICAgICAgICBjb25zdCBjID0gYnVmZmVycy5DLnNsaWNlKGlfbjhyLCBpX244ciArIG44cik7XG5cbiAgICAgICAgICAgIC8vIFooWCkgOj0gbnVtQXJyIC8gZGVuQXJyXG4gICAgICAgICAgICAvLyBudW1BcnIgOj0gKGEgKyBiZXRhwrfPiSArIGdhbW1hKShiICsgYmV0YcK3z4nCt2sxICsgZ2FtbWEpKGMgKyBiZXRhwrfPicK3azIgKyBnYW1tYSlcbiAgICAgICAgICAgIGNvbnN0IGJldGF3ID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgdyk7XG5cbiAgICAgICAgICAgIGxldCBuMSA9IEZyLmFkZChhLCBiZXRhdyk7XG4gICAgICAgICAgICBuMSA9IEZyLmFkZChuMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBuMiA9IEZyLmFkZChiLCBGci5tdWwoemtleS5rMSwgYmV0YXcpKTtcbiAgICAgICAgICAgIG4yID0gRnIuYWRkKG4yLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IG4zID0gRnIuYWRkKGMsIEZyLm11bCh6a2V5LmsyLCBiZXRhdykpO1xuICAgICAgICAgICAgbjMgPSBGci5hZGQobjMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgbnVtID0gRnIubXVsKG4xLCBGci5tdWwobjIsIG4zKSk7XG5cbiAgICAgICAgICAgIC8vIGRlbkFyciA6PSAoYSArIGJldGHCt3NpZ21hMSArIGdhbW1hKShiICsgYmV0YcK3c2lnbWEyICsgZ2FtbWEpKGMgKyBiZXRhwrdzaWdtYTMgKyBnYW1tYSlcbiAgICAgICAgICAgIGxldCBkMSA9IEZyLmFkZChhLCBGci5tdWwoZXZhbHVhdGlvbnMuU2lnbWExLmdldEV2YWx1YXRpb24oaSAqIDQpLCBjaGFsbGVuZ2VzLmJldGEpKTtcbiAgICAgICAgICAgIGQxID0gRnIuYWRkKGQxLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGQyID0gRnIuYWRkKGIsIEZyLm11bChldmFsdWF0aW9ucy5TaWdtYTIuZ2V0RXZhbHVhdGlvbihpICogNCksIGNoYWxsZW5nZXMuYmV0YSkpO1xuICAgICAgICAgICAgZDIgPSBGci5hZGQoZDIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZDMgPSBGci5hZGQoYywgRnIubXVsKGV2YWx1YXRpb25zLlNpZ21hMy5nZXRFdmFsdWF0aW9uKGkgKiA0KSwgY2hhbGxlbmdlcy5iZXRhKSk7XG4gICAgICAgICAgICBkMyA9IEZyLmFkZChkMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBkZW4gPSBGci5tdWwoZDEsIEZyLm11bChkMiwgZDMpKTtcblxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgY3VycmVudCBudW0gdmFsdWUgd2l0aCB0aGUgcHJldmlvdXMgb25lIHNhdmVkIGluIG51bUFyclxuICAgICAgICAgICAgbnVtID0gRnIubXVsKG51bUFyci5zbGljZShpX244ciwgaV9uOHIgKyBuOHIpLCBudW0pO1xuICAgICAgICAgICAgbnVtQXJyLnNldChudW0sICgoaSArIDEpICUgemtleS5kb21haW5TaXplKSAqIG44cik7XG5cbiAgICAgICAgICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgZGVuIHZhbHVlIHdpdGggdGhlIHByZXZpb3VzIG9uZSBzYXZlZCBpbiBkZW5BcnJcbiAgICAgICAgICAgIGRlbiA9IEZyLm11bChkZW5BcnIuc2xpY2UoaV9uOHIsIGlfbjhyICsgbjhyKSwgZGVuKTtcbiAgICAgICAgICAgIGRlbkFyci5zZXQoZGVuLCAoKGkgKyAxKSAlIHprZXkuZG9tYWluU2l6ZSkgKiBuOHIpO1xuXG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBkZW5BcnIgdG8gY29tcHV0ZSBpbiB0aGUgbmV4dCBjb21tYW5kIHRoZVxuICAgICAgICAvLyBkaXZpc2lvbiBudW1BcnIvZGVuQXJyIGJ5IG11bHRpcGx5aW5nIG51bSDCtyAxL2RlbkFyclxuICAgICAgICBkZW5BcnIgPSBhd2FpdCBGci5iYXRjaEludmVyc2UoZGVuQXJyKTtcblxuICAgICAgICAvLyBUT0RPOiBEbyBpdCBpbiBhc3NlbWJseSBhbmQgaW4gcGFyYWxsZWxcbiAgICAgICAgLy8gTXVsdGlwbHkgbnVtQXJyIMK3IGRlbkFyciB3aGVyZSBkZW5BcnIgd2FzIGludmVydGVkIGluIHRoZSBwcmV2aW91cyBjb21tYW5kXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIG44cjtcblxuICAgICAgICAgICAgY29uc3QgeiA9IEZyLm11bChudW1BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgbjhyKSwgZGVuQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIG44cikpO1xuICAgICAgICAgICAgbnVtQXJyLnNldCh6LCBpX3NGcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGcm9tIG5vdyBvbiB0aGUgdmFsdWVzIHNhdmVkIG9uIG51bUFyciB3aWxsIGJlIFooWCkgYnVmZmVyXG4gICAgICAgIGJ1ZmZlcnMuWiA9IG51bUFycjtcblxuICAgICAgICBpZiAoIUZyLmVxKG51bUFyci5zbGljZSgwLCBuOHIpLCBGci5vbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3B5IGNvbnN0cmFpbnRzIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cyB6KFgpIGZyb20gYnVmZmVycy5aXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgWiBpZmZ0XCIpO1xuICAgICAgICBwb2x5bm9taWFscy5aID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5aLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBDb21wdXRlIGV4dGVuZGVkIGV2YWx1YXRpb25zIG9mIHooWCkgcG9seW5vbWlhbFxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIFogZmZ0XCIpO1xuICAgICAgICBldmFsdWF0aW9ucy5aID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuWiwgNCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gQmxpbmQgeihYKSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cyB3aXRoIGJsaW5kaW5nIHNjYWxhcnMgYlxuICAgICAgICBwb2x5bm9taWFscy5aLmJsaW5kQ29lZmZpY2llbnRzKFtjaGFsbGVuZ2VzLmJbOV0sIGNoYWxsZW5nZXMuYls4XSwgY2hhbGxlbmdlcy5iWzddXSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgIGlmIChwb2x5bm9taWFscy5aLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSArIDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlogUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuWjtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDMoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZSBhbHBoYVwiKTtcblxuICAgICAgICAvLyBTVEVQIDMuMSAtIENvbXB1dGUgZXZhbHVhdGlvbiBjaGFsbGVuZ2UgYWxwaGEg4oiIIEZcbiAgICAgICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmJldGEpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJaXCIpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLmFscGhhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgY2hhbGxlbmdlcy5hbHBoYTIgPSBGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmFscGhhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYWxwaGEsIDE2KSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBxdW90aWVudCBwb2x5bm9taWFsIFQoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgVCBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlVCgpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgW1QxXV8xLCBbVDJdXzEsIFtUM11fMVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBUIE1TTVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFQxID0gYXdhaXQgcG9seW5vbWlhbHMuVDEubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlQxXCIpO1xuICAgICAgICBsZXQgY29tbWl0VDIgPSBhd2FpdCBwb2x5bm9taWFscy5UMi5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiVDJcIik7XG4gICAgICAgIGxldCBjb21taXRUMyA9IGF3YWl0IHBvbHlub21pYWxzLlQzLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJUM1wiKTtcblxuICAgICAgICAvLyBUaGlyZCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW1QxXV8xLCBbVDJdXzEsIFtUM11fMSlcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlQxXCIsIGNvbW1pdFQxKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlQyXCIsIGNvbW1pdFQyKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlQzXCIsIGNvbW1pdFQzKTsgICAgICAgIFxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVUKCkge1xuICAgICAgICBpZiAobG9nZ2VyKVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGDCt8K3wrcgUmVhZGluZyBzZWN0aW9ucyAke1pLRVlfUExfUUxfU0VDVElPTn0sICR7WktFWV9QTF9RUl9TRUNUSU9OfWAgK1xuICAgICAgICAgICAgICAgIGAsICR7WktFWV9QTF9RTV9TRUNUSU9OfSwgJHtaS0VZX1BMX1FPX1NFQ1RJT059LCAke1pLRVlfUExfUUNfU0VDVElPTn0uIFEgc2VsZWN0b3JzYCk7XG4gICAgICAgIC8vIFJlc2VydmUgbWVtb3J5IGZvciBRJ3MgZXZhbHVhdGlvbnNcbiAgICAgICAgZXZhbHVhdGlvbnMuUUwgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBldmFsdWF0aW9ucy5RUiA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zLlFNID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuUU8gPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBldmFsdWF0aW9ucy5RQyA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gUmVhZCBRJ3MgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTC5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfUUxfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFSLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RUl9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUU0uZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1FNX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTy5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfUU9fU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFDLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RQ19TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG5cbiAgICAgICAgLy8gUmVhZCBMYWdyYW5nZSBwb2x5bm9taWFscyAmIGV2YWx1YXRpb25zIGZyb20gemtleSBmaWxlXG4gICAgICAgIGV2YWx1YXRpb25zLkxhZ3JhbmdlID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQgKiB6a2V5Lm5QdWJsaWMpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLkxhZ3JhbmdlLmV2YWwsIGkgKiBzRG9tYWluICogNCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX0xBR1JBTkdFX1NFQ1RJT05dWzBdLnAgKyBpICogNSAqIHNEb21haW4gKyBzRG9tYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlcnMuVCA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpO1xuICAgICAgICBidWZmZXJzLlR6ID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBUIGV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZSAqIDQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKVxuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgICAgICAgVCBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemUgKiA0fWApO1xuXG4gICAgICAgICAgICBjb25zdCBhID0gZXZhbHVhdGlvbnMuQS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgYiA9IGV2YWx1YXRpb25zLkIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBldmFsdWF0aW9ucy5DLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCB6ID0gZXZhbHVhdGlvbnMuWi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgencgPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oKHprZXkuZG9tYWluU2l6ZSAqIDQgKyA0ICsgaSkgJSAoemtleS5kb21haW5TaXplICogNCkpO1xuXG4gICAgICAgICAgICBjb25zdCBxbSA9IGV2YWx1YXRpb25zLlFNLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxbCA9IGV2YWx1YXRpb25zLlFMLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxciA9IGV2YWx1YXRpb25zLlFSLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxbyA9IGV2YWx1YXRpb25zLlFPLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxYyA9IGV2YWx1YXRpb25zLlFDLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IGV2YWx1YXRpb25zLlNpZ21hMS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgczIgPSBldmFsdWF0aW9ucy5TaWdtYTIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IHMzID0gZXZhbHVhdGlvbnMuU2lnbWEzLmdldEV2YWx1YXRpb24oaSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFwID0gRnIuYWRkKGNoYWxsZW5nZXMuYlsyXSwgRnIubXVsKGNoYWxsZW5nZXMuYlsxXSwgdykpO1xuICAgICAgICAgICAgY29uc3QgYnAgPSBGci5hZGQoY2hhbGxlbmdlcy5iWzRdLCBGci5tdWwoY2hhbGxlbmdlcy5iWzNdLCB3KSk7XG4gICAgICAgICAgICBjb25zdCBjcCA9IEZyLmFkZChjaGFsbGVuZ2VzLmJbNl0sIEZyLm11bChjaGFsbGVuZ2VzLmJbNV0sIHcpKTtcblxuICAgICAgICAgICAgY29uc3QgdzIgPSBGci5zcXVhcmUodyk7XG4gICAgICAgICAgICBjb25zdCB6cCA9IEZyLmFkZChGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYls3XSwgdzIpLCBGci5tdWwoY2hhbGxlbmdlcy5iWzhdLCB3KSksIGNoYWxsZW5nZXMuYls5XSk7XG4gICAgICAgICAgICBjb25zdCB3VyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgICAgIGNvbnN0IHdXMiA9IEZyLnNxdWFyZSh3Vyk7XG4gICAgICAgICAgICBjb25zdCB6V3AgPSBGci5hZGQoRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJbN10sIHdXMiksIEZyLm11bChjaGFsbGVuZ2VzLmJbOF0sIHdXKSksIGNoYWxsZW5nZXMuYls5XSk7XG5cbiAgICAgICAgICAgIGxldCBwaSA9IEZyLnplcm87XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHprZXkublB1YmxpYzsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKGogKiA0ICogemtleS5kb21haW5TaXplKSArIGk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsUG9sID0gZXZhbHVhdGlvbnMuTGFncmFuZ2UuZ2V0RXZhbHVhdGlvbihvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFWYWwgPSBidWZmZXJzLkEuc2xpY2UoaiAqIG44ciwgKGogKyAxKSAqIG44cik7XG5cbiAgICAgICAgICAgICAgICBwaSA9IEZyLnN1YihwaSwgRnIubXVsKGxQb2wsIGFWYWwpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZTEgOj0gYShYKWIoWClxTShYKSArIGEoWClxTChYKSArIGIoWClxUihYKSArIGMoWClxTyhYKSArIFBJKFgpICsgcUMoWClcbiAgICAgICAgICAgIGxldCBbZTEsIGUxel0gPSBNdWxaLm11bDIoYSwgYiwgYXAsIGJwLCBpICUgNCwgRnIpO1xuICAgICAgICAgICAgZTEgPSBGci5tdWwoZTEsIHFtKTtcbiAgICAgICAgICAgIGUxeiA9IEZyLm11bChlMXosIHFtKTtcblxuICAgICAgICAgICAgZTEgPSBGci5hZGQoZTEsIEZyLm11bChhLCBxbCkpO1xuICAgICAgICAgICAgZTF6ID0gRnIuYWRkKGUxeiwgRnIubXVsKGFwLCBxbCkpO1xuXG4gICAgICAgICAgICBlMSA9IEZyLmFkZChlMSwgRnIubXVsKGIsIHFyKSk7XG4gICAgICAgICAgICBlMXogPSBGci5hZGQoZTF6LCBGci5tdWwoYnAsIHFyKSk7XG5cbiAgICAgICAgICAgIGUxID0gRnIuYWRkKGUxLCBGci5tdWwoYywgcW8pKTtcbiAgICAgICAgICAgIGUxeiA9IEZyLmFkZChlMXosIEZyLm11bChjcCwgcW8pKTtcblxuICAgICAgICAgICAgZTEgPSBGci5hZGQoZTEsIHBpKTtcbiAgICAgICAgICAgIGUxID0gRnIuYWRkKGUxLCBxYyk7XG5cbiAgICAgICAgICAgIC8vIGUyIDo9IM6xWyhhKFgpICsgzrJYICsgzrMpKGIoWCkgKyDOsmsxWCArIM6zKShjKFgpICsgzrJrMlggKyDOsyl6KFgpXVxuICAgICAgICAgICAgY29uc3QgYmV0YXcgPSBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCB3KTtcbiAgICAgICAgICAgIGxldCBlMmEgPSBhO1xuICAgICAgICAgICAgZTJhID0gRnIuYWRkKGUyYSwgYmV0YXcpO1xuICAgICAgICAgICAgZTJhID0gRnIuYWRkKGUyYSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlMmIgPSBiO1xuICAgICAgICAgICAgZTJiID0gRnIuYWRkKGUyYiwgRnIubXVsKGJldGF3LCB6a2V5LmsxKSk7XG4gICAgICAgICAgICBlMmIgPSBGci5hZGQoZTJiLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUyYyA9IGM7XG4gICAgICAgICAgICBlMmMgPSBGci5hZGQoZTJjLCBGci5tdWwoYmV0YXcsIHprZXkuazIpKTtcbiAgICAgICAgICAgIGUyYyA9IEZyLmFkZChlMmMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTJkID0gejtcblxuICAgICAgICAgICAgbGV0IFtlMiwgZTJ6XSA9IE11bFoubXVsNChlMmEsIGUyYiwgZTJjLCBlMmQsIGFwLCBicCwgY3AsIHpwLCBpICUgNCwgRnIpO1xuICAgICAgICAgICAgZTIgPSBGci5tdWwoZTIsIGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICAgICAgZTJ6ID0gRnIubXVsKGUyeiwgY2hhbGxlbmdlcy5hbHBoYSk7XG5cbiAgICAgICAgICAgIC8vIGUzIDo9IM6xWyhhKFgpICsgzrJTz4MxKFgpICsgzrMpKGIoWCkgKyDOslPPgzIoWCkgKyDOsykoYyhYKSArIM6yU8+DMyhYKSArIM6zKXooWM+JKV1cbiAgICAgICAgICAgIGxldCBlM2EgPSBhO1xuICAgICAgICAgICAgZTNhID0gRnIuYWRkKGUzYSwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgczEpKTtcbiAgICAgICAgICAgIGUzYSA9IEZyLmFkZChlM2EsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTNiID0gYjtcbiAgICAgICAgICAgIGUzYiA9IEZyLmFkZChlM2IsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHMyKSk7XG4gICAgICAgICAgICBlM2IgPSBGci5hZGQoZTNiLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUzYyA9IGM7XG4gICAgICAgICAgICBlM2MgPSBGci5hZGQoZTNjLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBzMykpO1xuICAgICAgICAgICAgZTNjID0gRnIuYWRkKGUzYywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlM2QgPSB6dztcbiAgICAgICAgICAgIGxldCBbZTMsIGUzel0gPSBNdWxaLm11bDQoZTNhLCBlM2IsIGUzYywgZTNkLCBhcCwgYnAsIGNwLCB6V3AsIGkgJSA0LCBGcik7XG5cbiAgICAgICAgICAgIGUzID0gRnIubXVsKGUzLCBjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICAgICAgICAgIGUzeiA9IEZyLm11bChlM3osIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgICAgICAgICAvLyBlNCA6PSDOsV4yKHooWCniiJIxKUwxKFgpXG4gICAgICAgICAgICBsZXQgZTQgPSBGci5zdWIoeiwgRnIub25lKTtcbiAgICAgICAgICAgIGU0ID0gRnIubXVsKGU0LCBldmFsdWF0aW9ucy5MYWdyYW5nZS5nZXRFdmFsdWF0aW9uKGkpKTtcbiAgICAgICAgICAgIGU0ID0gRnIubXVsKGU0LCBjaGFsbGVuZ2VzLmFscGhhMik7XG5cbiAgICAgICAgICAgIGxldCBlNHogPSBGci5tdWwoenAsIGV2YWx1YXRpb25zLkxhZ3JhbmdlLmdldEV2YWx1YXRpb24oaSkpO1xuICAgICAgICAgICAgZTR6ID0gRnIubXVsKGU0eiwgY2hhbGxlbmdlcy5hbHBoYTIpO1xuXG5cbiAgICAgICAgICAgIGxldCB0ID0gRnIuYWRkKEZyLnN1YihGci5hZGQoZTEsIGUyKSwgZTMpLCBlNCk7XG4gICAgICAgICAgICBsZXQgdHogPSBGci5hZGQoRnIuc3ViKEZyLmFkZChlMXosIGUyeiksIGUzeiksIGU0eik7XG5cbiAgICAgICAgICAgIGJ1ZmZlcnMuVC5zZXQodCwgaSAqIG44cik7XG4gICAgICAgICAgICBidWZmZXJzLlR6LnNldCh0eiwgaSAqIG44cik7XG5cbiAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1t6a2V5LnBvd2VyICsgMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQwKFgpIGZyb20gYnVmZmVycy5UMFxuICAgICAgICBpZiAobG9nZ2VyKVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBUIGlmZnRcIik7XG4gICAgICAgIHBvbHlub21pYWxzLlQgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIERpdmlkZSB0aGUgcG9seW5vbWlhbCBUMCBieSBaX0goWClcbiAgICAgICAgaWYgKGxvZ2dlcilcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgVCAvIFpIXCIpO1xuICAgICAgICBwb2x5bm9taWFscy5ULmRpdlpoKHprZXkuZG9tYWluU2l6ZSwgNCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFR6KFgpIGZyb20gYnVmZmVycy5UelxuICAgICAgICBpZiAobG9nZ2VyKVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBUeiBpZmZ0XCIpO1xuICAgICAgICBwb2x5bm9taWFscy5UeiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVHosIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgcG9seW5vbWlhbCBUMXogdG8gVDEgdG8gZ2V0IHRoZSBmaW5hbCBwb2x5bm9taWFsIFQxXG4gICAgICAgIHBvbHlub21pYWxzLlQuYWRkKHBvbHlub21pYWxzLlR6KTtcblxuICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgaWYgKHBvbHlub21pYWxzLlQuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICogMyArIDYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlQgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdCh4KSBoYXMgZGVncmVlIDNuICsgNSwgd2UgYXJlIGdvaW5nIHRvIHNwbGl0IHQoeCkgaW50byB0aHJlZSBzbWFsbGVyIHBvbHlub21pYWxzOlxuICAgICAgICAvLyBUMScgYW5kIFQyJyAgd2l0aCBhIGRlZ3JlZSA8IG4gYW5kIFQzJyB3aXRoIGEgZGVncmVlIG4rNVxuICAgICAgICAvLyBzdWNoIHRoYXQgdCh4KSA9IFQxJyhYKSArIFhebiBUMicoWCkgKyBYXnsybn0gVDMnKFgpXG4gICAgICAgIC8vIFRvIHJhbmRvbWl6ZSB0aGUgcGFydHMgd2UgdXNlIGJsaW5kaW5nIHNjYWxhcnMgYl8xMCBhbmQgYl8xMSBpbiBhIHdheSB0aGF0IGRvZXNuJ3QgY2hhbmdlIHQoWCk6XG4gICAgICAgIC8vIFQxKFgpID0gVDEnKFgpICsgYl8xMCBYXm5cbiAgICAgICAgLy8gVDIoWCkgPSBUMicoWCkgLSBiXzEwICsgYl8xMSBYXm5cbiAgICAgICAgLy8gVDMoWCkgPSBUMycoWCkgLSBiXzExXG4gICAgICAgIC8vIHN1Y2ggdGhhdFxuICAgICAgICAvLyB0KFgpID0gVDEoWCkgKyBYXm4gVDIoWCkgKyBYXjJuIFQzKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgVDEsIFQyLCBUMyBwb2x5bm9taWFsc1wiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDEgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKCh6a2V5LmRvbWFpblNpemUgKyAxKSAqIG44ciksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5UMiA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDEpICogbjhyKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlQzID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgNikgKiBuOHIpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICBwb2x5bm9taWFscy5UMS5jb2VmLnNldChwb2x5bm9taWFscy5ULmNvZWYuc2xpY2UoMCwgc0RvbWFpbiksIDApO1xuICAgICAgICBwb2x5bm9taWFscy5UMi5jb2VmLnNldChwb2x5bm9taWFscy5ULmNvZWYuc2xpY2Uoc0RvbWFpbiwgc0RvbWFpbiAqIDIpLCAwKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDMuY29lZi5zZXQocG9seW5vbWlhbHMuVC5jb2VmLnNsaWNlKHNEb21haW4gKiAyLCBzRG9tYWluICogMyArIDYgKiBuOHIpLCAwKTtcblxuICAgICAgICAvLyBBZGQgYmxpbmRpbmcgc2NhbGFyIGJfMTAgYXMgYSBuZXcgY29lZmZpY2llbnQgblxuICAgICAgICBwb2x5bm9taWFscy5UMS5zZXRDb2VmKHprZXkuZG9tYWluU2l6ZSwgY2hhbGxlbmdlcy5iWzEwXSk7XG5cbiAgICAgICAgLy8gY29tcHV0ZSB0X21pZChYKVxuICAgICAgICAvLyBTdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMCB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfbWlkXG4gICAgICAgIGNvbnN0IGxvd2VzdE1pZCA9IEZyLnN1Yihwb2x5bm9taWFscy5UMi5nZXRDb2VmKDApLCBjaGFsbGVuZ2VzLmJbMTBdKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDIuc2V0Q29lZigwLCBsb3dlc3RNaWQpO1xuICAgICAgICBwb2x5bm9taWFscy5UMi5zZXRDb2VmKHprZXkuZG9tYWluU2l6ZSwgY2hhbGxlbmdlcy5iWzExXSk7XG5cbiAgICAgICAgLy8gY29tcHV0ZSB0X2hpZ2goWClcbiAgICAgICAgLy9TdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMSB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfaGlnaFxuICAgICAgICBjb25zdCBsb3dlc3RIaWdoID0gRnIuc3ViKHBvbHlub21pYWxzLlQzLmdldENvZWYoMCksIGNoYWxsZW5nZXMuYlsxMV0pO1xuICAgICAgICBwb2x5bm9taWFscy5UMy5zZXRDb2VmKDAsIGxvd2VzdEhpZ2gpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kNCgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIHhpXCIpO1xuXG4gICAgICAgIC8vIFNURVAgNC4xIC0gQ29tcHV0ZSBldmFsdWF0aW9uIGNoYWxsZW5nZSB4aSDiiIggRlxuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIlQxXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJUMlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiVDNcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMueGkgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBjaGFsbGVuZ2VzLnhpdyA9IEZyLm11bChjaGFsbGVuZ2VzLnhpLCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBjaGFsbGVuZ2VzLnhpOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMueGksIDE2KSk7ICBcblxuICAgICAgICAvLyBGb3VydGggb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKCBhKHhpKSwgYih4aSksIGMoeGkpLCBzMSh4aSksIHMyKHhpKSwgeih4aXcpIClcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfYVwiLCBwb2x5bm9taWFscy5BLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfYlwiLCBwb2x5bm9taWFscy5CLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfY1wiLCBwb2x5bm9taWFscy5DLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfczFcIiwgcG9seW5vbWlhbHMuU2lnbWExLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfczJcIiwgcG9seW5vbWlhbHMuU2lnbWEyLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfendcIiwgcG9seW5vbWlhbHMuWi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpdykpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kNSgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIHZcIik7XG4gICAgICAgIFxuICAgICAgICAvLyBTVEVQIDUuMSAtIENvbXB1dGUgZXZhbHVhdGlvbiBjaGFsbGVuZ2UgdiDiiIggRlxuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMueGkpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiZXZhbF9hXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImV2YWxfYlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJldmFsX2NcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiZXZhbF9zMVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJldmFsX3MyXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImV2YWxfendcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMudiA9IFtdO1xuICAgICAgICBjaGFsbGVuZ2VzLnZbMV0gPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgY2hhbGxlbmdlcy52OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMudlsxXSwgMTYpKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgY2hhbGxlbmdlcy52W2ldID0gRnIubXVsKGNoYWxsZW5nZXMudltpIC0gMV0sIGNoYWxsZW5nZXMudlsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDUuMiBDb21wdXRlIGxpbmVhcmlzYXRpb24gcG9seW5vbWlhbCByKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIGxpbmVhcmlzYXRpb24gcG9seW5vbWlhbCBSKFgpXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlUigpO1xuXG4gICAgICAgIC8vU1RFUCA1LjMgQ29tcHV0ZSBvcGVuaW5nIHByb29mIHBvbHlub21pYWwgV3hpKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIG9wZW5pbmcgcHJvb2YgcG9seW5vbWlhbCBXeGkoWCkgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgY29tcHV0ZVd4aSgpO1xuXG4gICAgICAgIC8vU1RFUCA1LjQgQ29tcHV0ZSBvcGVuaW5nIHByb29mIHBvbHlub21pYWwgV3hpdyhYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBvcGVuaW5nIHByb29mIHBvbHlub21pYWwgV3hpdyhYKSBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb21wdXRlV3hpdygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIFd4aSwgV3hpdyBNU01cIik7XG4gICAgICAgIGxldCBjb21taXRXeGkgPSBhd2FpdCBwb2x5bm9taWFscy5XeGkubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIld4aVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFd4aXcgPSBhd2FpdCBwb2x5bm9taWFscy5XeGl3Lm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJXeGl3XCIpO1xuXG4gICAgICAgIC8vIEZpZnRoIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbV3hpXV8xLCBbV3hpd11fMSlcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIld4aVwiLCBjb21taXRXeGkpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiV3hpd1wiLCBjb21taXRXeGl3KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlUigpIHtcbiAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBcbiAgICAgICAgLy8gUmVzZXJ2ZSBtZW1vcnkgZm9yIFEncyBwb2x5bm9taWFsc1xuICAgICAgICBwb2x5bm9taWFscy5RTCA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RUiA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RTSA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RTyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RQyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIFJlYWQgUSdzIGV2YWx1YXRpb25zIGZyb20gemtleSBmaWxlXG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUUwuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfUUxfU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUVIuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfUVJfU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUU0uY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfUU1fU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUU8uY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfUU9fU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUUMuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfUUNfU0VDVElPTl1bMF0ucCk7ICAgXG4gICAgICAgIFxuICAgICAgICBjaGFsbGVuZ2VzLnhpbiA9IGNoYWxsZW5nZXMueGk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5wb3dlcjsgaSsrKSB7XG4gICAgICAgICAgICBjaGFsbGVuZ2VzLnhpbiA9IEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpbik7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFsbGVuZ2VzLnpoID0gRnIuc3ViKGNoYWxsZW5nZXMueGluLCBGci5vbmUpO1xuXG4gICAgICAgIGNvbnN0IEwgPSBbXTtcblxuICAgICAgICBjb25zdCBuID0gRnIuZSh6a2V5LmRvbWFpblNpemUpO1xuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gTWF0aC5tYXgoMSwgemtleS5uUHVibGljKTsgaSsrKSB7XG4gICAgICAgICAgICBMW2ldID0gRnIuZGl2KEZyLm11bCh3LCBjaGFsbGVuZ2VzLnpoKSwgRnIubXVsKG4sIEZyLnN1YihjaGFsbGVuZ2VzLnhpLCB3KSkpO1xuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV2YWxfbDEgPSBGci5kaXYoXG4gICAgICAgICAgICBGci5zdWIoY2hhbGxlbmdlcy54aW4sIEZyLm9uZSksXG4gICAgICAgICAgICBGci5tdWwobiwgRnIuc3ViKGNoYWxsZW5nZXMueGksIEZyLm9uZSkpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiTGFncmFuZ2UgRXZhbHVhdGlvbnM6IFwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MTsgaTxMLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBMJHtpfSh4aSk9YCArIEZyLnRvU3RyaW5nKExbaV0sIDE2KSk7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGV2YWxfcGkgPSBGci56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cHVibGljU2lnbmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdyA9IEZyLmUocHVibGljU2lnbmFsc1tpXSk7XG4gICAgICAgICAgICBldmFsX3BpID0gRnIuc3ViKGV2YWxfcGksIEZyLm11bCh3LCBMW2krMV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlBJOiBcIiArIEZyLnRvU3RyaW5nKGV2YWxfcGksIDE2KSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBjb25zdGFudCBwYXJ0cyBvZiBSKFgpXG4gICAgICAgIGNvbnN0IGNvZWZfYWIgPSBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9hLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2IpO1xuXG4gICAgICAgIGxldCBlMmEgPSBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2E7XG4gICAgICAgIGNvbnN0IGJldGF4aSA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGNoYWxsZW5nZXMueGkpO1xuICAgICAgICBlMmEgPSBGci5hZGQoZTJhLCBiZXRheGkpO1xuICAgICAgICBlMmEgPSBGci5hZGQoZTJhLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICBsZXQgZTJiID0gcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9iO1xuICAgICAgICBlMmIgPSBGci5hZGQoZTJiLCBGci5tdWwoYmV0YXhpLCB6a2V5LmsxKSk7XG4gICAgICAgIGUyYiA9IEZyLmFkZChlMmIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgIGxldCBlMmMgPSBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2M7XG4gICAgICAgIGUyYyA9IEZyLmFkZChlMmMsIEZyLm11bChiZXRheGksIHprZXkuazIpKTtcbiAgICAgICAgZTJjID0gRnIuYWRkKGUyYywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgY29uc3QgZTIgPSBGci5tdWwoRnIubXVsKEZyLm11bChlMmEsIGUyYiksIGUyYyksIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgICAgIGxldCBlM2EgPSBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2E7XG4gICAgICAgIGUzYSA9IEZyLmFkZChlM2EsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLmV2YWxfczEpKTtcbiAgICAgICAgZTNhID0gRnIuYWRkKGUzYSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgbGV0IGUzYiA9IHByb29mLmV2YWx1YXRpb25zLmV2YWxfYjtcbiAgICAgICAgZTNiID0gRnIuYWRkKGUzYiwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9zMikpO1xuICAgICAgICBlM2IgPSBGci5hZGQoZTNiLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICBsZXQgZTMgPSBGci5tdWwoZTNhLCBlM2IpO1xuICAgICAgICBlMyA9IEZyLm11bChlMywgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF96dyk7XG4gICAgICAgIGUzID0gRnIubXVsKGUzLCBjaGFsbGVuZ2VzLmFscGhhKTtcblxuICAgICAgICBjb25zdCBlNCA9IEZyLm11bChldmFsX2wxLCBjaGFsbGVuZ2VzLmFscGhhMik7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuUiA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDYpICogbjhyKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGQocG9seW5vbWlhbHMuUU0sIGNvZWZfYWIpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5RTCwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9hKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGQocG9seW5vbWlhbHMuUVIsIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYik7XG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkKHBvbHlub21pYWxzLlFPLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2MpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5RQyk7XG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkKHBvbHlub21pYWxzLlosIGUyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUi5zdWIocG9seW5vbWlhbHMuU2lnbWEzLCBGci5tdWwoZTMsIGNoYWxsZW5nZXMuYmV0YSkpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5aLCBlNCk7XG5cbiAgICAgICAgbGV0IHRtcCA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuVDMsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICB0bXAubXVsU2NhbGFyKEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpbikpO1xuICAgICAgICB0bXAuYWRkKHBvbHlub21pYWxzLlQyLCBjaGFsbGVuZ2VzLnhpbik7XG4gICAgICAgIHRtcC5hZGQocG9seW5vbWlhbHMuVDEpO1xuICAgICAgICB0bXAubXVsU2NhbGFyKGNoYWxsZW5nZXMuemgpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLlIuc3ViKHRtcCk7XG5cbiAgICAgICAgbGV0IHIwID0gRnIuc3ViKGV2YWxfcGksIEZyLm11bChlMywgRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmV2YWxfYywgY2hhbGxlbmdlcy5nYW1tYSkpKTtcbiAgICAgICAgcjAgPSBGci5zdWIocjAsIGU0KTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJyMDogXCIgKyBGci50b1N0cmluZyhyMCwgMTYpKTtcblxuICAgICAgICBwb2x5bm9taWFscy5SLmFkZFNjYWxhcihyMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVd4aSgpIHtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluICsgNiAqIG44ciksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLld4aS5hZGQocG9seW5vbWlhbHMuUik7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5hZGQocG9seW5vbWlhbHMuQSwgY2hhbGxlbmdlcy52WzFdKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLmFkZChwb2x5bm9taWFscy5CLCBjaGFsbGVuZ2VzLnZbMl0pO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuYWRkKHBvbHlub21pYWxzLkMsIGNoYWxsZW5nZXMudlszXSk7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5hZGQocG9seW5vbWlhbHMuU2lnbWExLCBjaGFsbGVuZ2VzLnZbNF0pO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuYWRkKHBvbHlub21pYWxzLlNpZ21hMiwgY2hhbGxlbmdlcy52WzVdKTtcblxuICAgICAgICBwb2x5bm9taWFscy5XeGkuc3ViU2NhbGFyKEZyLm11bChjaGFsbGVuZ2VzLnZbMV0sIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYSkpO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuc3ViU2NhbGFyKEZyLm11bChjaGFsbGVuZ2VzLnZbMl0sIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYikpO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuc3ViU2NhbGFyKEZyLm11bChjaGFsbGVuZ2VzLnZbM10sIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYykpO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuc3ViU2NhbGFyKEZyLm11bChjaGFsbGVuZ2VzLnZbNF0sIHByb29mLmV2YWx1YXRpb25zLmV2YWxfczEpKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLnN1YlNjYWxhcihGci5tdWwoY2hhbGxlbmdlcy52WzVdLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX3MyKSk7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLmRpdkJ5WmVyb2ZpZXIoMSwgY2hhbGxlbmdlcy54aSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVd4aXcoKSB7XG4gICAgICAgIHBvbHlub21pYWxzLld4aXcgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLlosIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5XeGl3LnN1YlNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX3p3KTtcblxuICAgICAgICBwb2x5bm9taWFscy5XeGl3LmRpdkJ5WmVyb2ZpZXIoMSwgY2hhbGxlbmdlcy54aXcpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/plonk_prove.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/plonk_setup.js":
/*!*************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_setup.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkSetup)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(rsc)/./node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bigarray.js */ \"(rsc)/./node_modules/snarkjs/src/bigarray.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\n\n\n\n\n\n\n\n\nasync function plonkSetup(r1csName, ptauName, zkeyName, logger) {\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const {fd: fdPTau, sections: sectionsPTau} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csFd)(fdR1cs, sectionsR1cs, {loadConstraints: true, loadCustomGates: true});\n\n    const sG1 = curve.G1.F.n8*2;\n    const G1 = curve.G1;\n    const sG2 = curve.G2.F.n8*2;\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdR1cs, sectionsR1cs, 2);\n\n    const plonkConstraints = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n    const plonkAdditions = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n    let plonkNVars = r1cs.nVars;\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n\n    await processConstraints(curve.Fr, r1cs, logger);\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyName, \"zkey\", 1, 14, 1<<22, 1<<24);\n\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    let cirPower = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(plonkConstraints.length -1) +1;\n    if (cirPower < 3) cirPower = 3;   // As the t polynomial is n+5 we need at least a power of 4\n    const domainSize = 2 ** cirPower;\n\n    if (logger) logger.info(\"Plonk constraints: \" + plonkConstraints.length);\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${plonkConstraints.length} > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n\n    const LPoints = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*sG1);\n    const o = sectionsPTau[12][0].p + ((2 ** (cirPower)) -1)*sG1;\n    await fdPTau.readToBuffer(LPoints, 0, domainSize*sG1, o);\n\n    const [k1, k2] = getK1K2();\n\n    const vk = {};\n\n\n    await writeAdditions(3, \"Additions\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(4, 0, \"Amap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(5, 1, \"Bmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(6, 2, \"Cmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(7, 3, \"Qm\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(8, 4, \"Ql\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(9, 5, \"Qr\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(10, 6, \"Qo\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(11, 7, \"Qc\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeSigma(12, \"sigma\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeLs(13, \"lagrange polynomials\");\n    if (globalThis.gc) {globalThis.gc();}\n\n    // Write PTau points\n    ////////////\n\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 14);\n    const buffOut = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((domainSize+6)*sG1);\n    await fdPTau.readToBuffer(buffOut, 0, (domainSize+6)*sG1, sectionsPTau[2][0].p);\n    await fdZKey.write(buffOut);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    if (globalThis.gc) {globalThis.gc();}\n\n\n    await writeHeaders();\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"Setup Finished\");\n\n    return ;\n\n    async function processConstraints(Fr, r1cs, logger) {\n\n        function normalize(linearComb) {\n            const ss = Object.keys(linearComb);\n            for (let i = 0; i < ss.length; i++) {\n                if (linearComb[ss[i]] == 0n) delete linearComb[ss[i]];\n            }\n        }\n\n        function join(linearComb1, k, linearComb2) {\n            const res = {};\n\n            for (let s in linearComb1) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = Fr.mul(k, linearComb1[s]);\n                } else {\n                    res[s] = Fr.add(res[s], Fr.mul(k, linearComb1[s]));\n                }\n            }\n\n            for (let s in linearComb2) {\n                const val = Fr.neg(linearComb2[s]);\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = val;\n                } else {\n                    res[s] = Fr.add(res[s], val);\n                }\n            }\n            normalize(res);\n            return res;\n        }\n\n        function reduceCoefs(linearComb, maxC) {\n            const res = {\n                k: Fr.zero,\n                s: [],\n                coefs: []\n            };\n            const cs = [];\n\n            for (let s in linearComb) {\n                if (s == 0) {\n                    res.k = Fr.add(res.k, linearComb[s]);\n                } else if (linearComb[s] != 0n) {\n                    cs.push([Number(s), linearComb[s]])\n                }\n            }\n            while (cs.length > maxC) {\n                const c1 = cs.shift();\n                const c2 = cs.shift();\n\n                const sl = c1[0];\n                const sr = c2[0];\n                const so = plonkNVars++;\n                const qm = Fr.zero;\n                const ql = Fr.neg(c1[1]);\n                const qr = Fr.neg(c2[1]);\n                const qo = Fr.one;\n                const qc = Fr.zero;\n\n                plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n\n                plonkAdditions.push([sl, sr, c1[1], c2[1]]);\n\n                cs.push([so, Fr.one]);\n            }\n            for (let i = 0; i < cs.length; i++) {\n                res.s[i] = cs[i][0];\n                res.coefs[i] = cs[i][1];\n            }\n            while (res.coefs.length < maxC) {\n                res.s.push(0);\n                res.coefs.push(Fr.zero);\n            }\n            return res;\n        }\n\n        function addConstraintSum(lc) {\n            const C = reduceCoefs(lc, 3);\n            const sl = C.s[0];\n            const sr = C.s[1];\n            const so = C.s[2];\n            const qm = Fr.zero;\n            const ql = C.coefs[0];\n            const qr = C.coefs[1];\n            const qo = C.coefs[2];\n            const qc = C.k;\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function addConstraintMul(lcA, lcB, lcC) {\n            const A = reduceCoefs(lcA, 1);\n            const B = reduceCoefs(lcB, 1);\n            const C = reduceCoefs(lcC, 1);\n\n\n            const sl = A.s[0];\n            const sr = B.s[0];\n            const so = C.s[0];\n            const qm = Fr.mul(A.coefs[0], B.coefs[0]);\n            const ql = Fr.mul(A.coefs[0], B.k);\n            const qr = Fr.mul(A.k, B.coefs[0]);\n            const qo = Fr.neg(C.coefs[0]);\n            const qc = Fr.sub(Fr.mul(A.k, B.k), C.k);\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function getLinearCombinationType(lc) {\n            let k = Fr.zero;\n            let n = 0;\n            const ss = Object.keys(lc);\n            for (let i = 0; i < ss.length; i++) {\n                if (lc[ss[i]] == 0n) {\n                    delete lc[ss[i]];\n                } else if (ss[i] == 0) {\n                    k = Fr.add(k, lc[ss[i]]);\n                } else {\n                    n++;\n                }\n            }\n            if (n > 0) return n.toString();\n            if (k != Fr.zero) return \"k\";\n            return \"0\";\n        }\n\n        function process(lcA, lcB, lcC) {\n            const lctA = getLinearCombinationType(lcA);\n            const lctB = getLinearCombinationType(lcB);\n            if ((lctA === \"0\") || (lctB === \"0\")) {\n                normalize(lcC);\n                addConstraintSum(lcC);\n            } else if (lctA === \"k\") {\n                const lcCC = join(lcB, lcA[0], lcC);\n                addConstraintSum(lcCC);\n            } else if (lctB === \"k\") {\n                const lcCC = join(lcA, lcB[0], lcC);\n                addConstraintSum(lcCC);\n            } else {\n                addConstraintMul(lcA, lcB, lcC);\n            }\n        }\n\n        for (let s = 1; s <= nPublic; s++) {\n            const sl = s;\n            const sr = 0;\n            const so = 0;\n            const qm = Fr.zero;\n            const ql = Fr.one;\n            const qr = Fr.zero;\n            const qo = Fr.zero;\n            const qc = Fr.zero;\n\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        for (let c = 0; c < r1cs.constraints.length; c++) {\n            if ((logger) && (c % 10000 === 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            process(...r1cs.constraints[c]);\n        }\n    }\n\n    async function writeWitnessMap(sectionNum, posConstraint, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeQMap(sectionNum, posConstraint, name) {\n        let Q = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i*n8r);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        await writeP4(Q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n        Q = await Fr.batchFromMontgomery(Q);\n        vk[name]= await curve.G1.multiExpAffine(LPoints, Q, logger, \"multiexp \"+name);\n    }\n\n    async function writeP4(buff) {\n        const q = await Fr.ifft(buff);\n        const q4 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r*4);\n        q4.set(q, 0);\n        const Q4 = await Fr.fft(q4);\n        await fdZKey.write(q);\n        await fdZKey.write(Q4);\n    }\n\n    async function writeAdditions(sectionNum, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        const buffOut = new Uint8Array((2*4+2*n8r));\n        const buffOutV = new DataView(buffOut.buffer);\n        for (let i=0; i<plonkAdditions.length; i++) {\n            const addition=plonkAdditions[i];\n            let o=0;\n            buffOutV.setUint32(o, addition[0], true); o+=4;\n            buffOutV.setUint32(o, addition[1], true); o+=4;\n            // The value is stored in Montgomery. stored = v*R\n            // so when montgomery multiplied by the witness, it's result = v*R*w/R = v*w\n            buffOut.set(addition[2], o); o+= n8r;\n            buffOut.set(addition[3], o); o+= n8r;\n            await fdZKey.write(buffOut);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkAdditions.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeSigma(sectionNum, name) {\n        const sigma = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(n8r*domainSize*3);\n        const lastAparence =  new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](plonkNVars);\n        const firstPos = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](plonkNVars);\n        let w = Fr.one;\n        for (let i=0; i<domainSize;i++) {\n            if (i<plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], domainSize + i);\n                buildSigma(plonkConstraints[i][2], domainSize*2 + i);\n            } else {\n                buildSigma(0, i);\n                buildSigma(0, domainSize + i);\n                buildSigma(0, domainSize*2 + i);\n            }\n            w = Fr.mul(w, Fr.w[cirPower]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name} phase1: ${i}/${plonkConstraints.length}`);\n        }\n        for (let s=0; s<plonkNVars; s++) {\n            if (typeof firstPos[s] !== \"undefined\") {\n                sigma.set(lastAparence[s], firstPos[s]*n8r);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger)&&(s%1000000 == 0)) logger.debug(`writing ${name} phase2: ${s}/${plonkNVars}`);\n        }\n\n        if (globalThis.gc) {globalThis.gc();}\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        let S1 = sigma.slice(0, domainSize*n8r);\n        await writeP4(S1);\n        if (globalThis.gc) {globalThis.gc();}\n        let S2 = sigma.slice(domainSize*n8r, domainSize*n8r*2);\n        await writeP4(S2);\n        if (globalThis.gc) {globalThis.gc();}\n        let S3 = sigma.slice(domainSize*n8r*2, domainSize*n8r*3);\n        await writeP4(S3);\n        if (globalThis.gc) {globalThis.gc();}\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        S1 = await Fr.batchFromMontgomery(S1);\n        S2 = await Fr.batchFromMontgomery(S2);\n        S3 = await Fr.batchFromMontgomery(S3);\n\n        vk.S1= await curve.G1.multiExpAffine(LPoints, S1, logger, \"multiexp S1\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S2= await curve.G1.multiExpAffine(LPoints, S2, logger, \"multiexp S2\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S3= await curve.G1.multiExpAffine(LPoints, S3, logger, \"multiexp S3\");\n        if (globalThis.gc) {globalThis.gc();}\n\n        function buildSigma(s, p) {\n            if (typeof lastAparence[s] === \"undefined\") {\n                firstPos[s] = p;\n            } else {\n                sigma.set(lastAparence[s], p*n8r);\n            }\n            let v;\n            if (p<domainSize) {\n                v = w;\n            } else if (p<2*domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n            lastAparence[s]=v;\n        }\n    }\n\n    async function writeLs(sectionNum, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        const l=Math.max(nPublic, 1);\n        for (let i=0; i<l; i++) {\n            let buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r);\n            buff.set(Fr.one, i*n8r);\n            await writeP4(buff);\n            if (logger) logger.debug(`writing ${name} ${i}/${l}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeHeaders() {\n\n        // Write the header\n        ///////////\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 1);\n        await fdZKey.writeULE32(2); // Plonk\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        // Write the Plonk header section\n        ///////////\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 2);\n        const primeQ = curve.q;\n        const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n        const primeR = curve.r;\n        const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n        await fdZKey.writeULE32(n8q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n        await fdZKey.writeULE32(n8r);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n        await fdZKey.writeULE32(plonkNVars);                         // Total number of bars\n        await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n        await fdZKey.writeULE32(domainSize);                  // domainSize\n        await fdZKey.writeULE32(plonkAdditions.length);                  // domainSize\n        await fdZKey.writeULE32(plonkConstraints.length); \n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(G1.toAffine(vk.Qm));\n        await fdZKey.write(G1.toAffine(vk.Ql));\n        await fdZKey.write(G1.toAffine(vk.Qr));\n        await fdZKey.write(G1.toAffine(vk.Qo));\n        await fdZKey.write(G1.toAffine(vk.Qc));\n\n        await fdZKey.write(G1.toAffine(vk.S1));\n        await fdZKey.write(G1.toAffine(vk.S2));\n        await fdZKey.write(G1.toAffine(vk.S3));\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, sectionsPTau[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    function getK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize= 2**pow;\n            let w = Fr.one;\n            for (let i=0; i<domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j=0; j<kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfc2V0dXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRW9DO0FBQ1k7QUFRbkI7QUFDSztBQUNlO0FBQ1o7OztBQUd0Qjs7QUFFZix3QkFBd0I7O0FBRXhCLFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7QUFDbEUsV0FBVyxjQUFjLFFBQVEsaUVBQW9CO0FBQ3JELFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7O0FBRWxFLHVCQUF1QixvREFBVSx3QkFBd0IsNkNBQTZDOztBQUV0RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdFQUFXOztBQUVqQyxpQ0FBaUMsb0RBQVE7QUFDekMsK0JBQStCLG9EQUFRO0FBQ3ZDOztBQUVBOztBQUVBOztBQUVBLHdCQUF3Qjs7QUFFeEIseUJBQXlCLGtFQUFhOzs7QUFHdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDhDQUFJO0FBQ3ZCLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0Esb0ZBQW9GLHlCQUF5QixPQUFPLE1BQU07QUFDMUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esd0JBQXdCLG1EQUFTO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBLFVBQVUsc0VBQWlCO0FBQzNCLHdCQUF3QixtREFBUztBQUNqQztBQUNBO0FBQ0EsVUFBVSxvRUFBZTtBQUN6Qix3QkFBd0I7OztBQUd4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsNkJBQTZCO0FBQ3JELHVGQUF1RixFQUFFLEdBQUcsa0JBQWtCO0FBQzlHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCO0FBQy9CLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQSxvRUFBb0UsS0FBSyxJQUFJLEVBQUUsR0FBRyx3QkFBd0I7QUFDMUc7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0Esb0JBQW9CLG1EQUFTO0FBQzdCLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQSxvRUFBb0UsS0FBSyxJQUFJLEVBQUUsR0FBRyx3QkFBd0I7QUFDMUc7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQjtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsbURBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDO0FBQ0Esb0VBQW9FLEtBQUssSUFBSSxFQUFFLEdBQUcsc0JBQXNCO0FBQ3hHO0FBQ0EsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBLDBCQUEwQixtREFBUztBQUNuQyxrQ0FBa0Msb0RBQVE7QUFDMUMsNkJBQTZCLG9EQUFRO0FBQ3JDO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxNQUFNLFVBQVUsRUFBRSxHQUFHLHdCQUF3QjtBQUNqSDtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLE1BQU0sVUFBVSxFQUFFLEdBQUcsV0FBVztBQUNwRzs7QUFFQSw0QkFBNEI7QUFDNUIsY0FBYyxzRUFBaUI7QUFDL0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsY0FBYyxvRUFBZTs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxzRUFBaUI7QUFDL0I7QUFDQSxzQkFBc0IsS0FBSztBQUMzQiwyQkFBMkIsbURBQVM7QUFDcEM7QUFDQTtBQUNBLGdEQUFnRCxNQUFNLEVBQUUsRUFBRSxHQUFHLEVBQUU7QUFDL0Q7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQixvQ0FBb0M7QUFDcEMsY0FBYyxvRUFBZTs7QUFFN0I7QUFDQTs7QUFFQSxjQUFjLHNFQUFpQjtBQUMvQjtBQUNBLGtDQUFrQyxnREFBTTs7QUFFeEM7QUFDQSxrQ0FBa0MsZ0RBQU07O0FBRXhDO0FBQ0EsY0FBYyxnRUFBVztBQUN6QjtBQUNBLGNBQWMsZ0VBQVc7QUFDekIscUVBQXFFO0FBQ3JFLGdFQUFnRTtBQUNoRSw4REFBOEQ7QUFDOUQseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfc2V0dXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMSAwa2ltcyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLyogSW1wbGVtZW50YXRpb24gb2YgdGhpcyBwYXBlcjogaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxOS85NTMucGRmICovXG5cbmltcG9ydCB7cmVhZFIxY3NGZH0gZnJvbSBcInIxY3NmaWxlXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0IHtcbiAgICByZWFkQmluRmlsZSxcbiAgICBjcmVhdGVCaW5GaWxlLFxuICAgIHJlYWRTZWN0aW9uLFxuICAgIHdyaXRlQmlnSW50LFxuICAgIHN0YXJ0V3JpdGVTZWN0aW9uLFxuICAgIGVuZFdyaXRlU2VjdGlvbixcbn0gZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7IGxvZzIgIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgU2NhbGFyLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgQmlnQXJyYXkgZnJvbSBcIi4vYmlnYXJyYXkuanNcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwbG9ua1NldHVwKHIxY3NOYW1lLCBwdGF1TmFtZSwgemtleU5hbWUsIGxvZ2dlcikge1xuXG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuXG4gICAgY29uc3Qge2ZkOiBmZFBUYXUsIHNlY3Rpb25zOiBzZWN0aW9uc1BUYXV9ID0gYXdhaXQgcmVhZEJpbkZpbGUocHRhdU5hbWUsIFwicHRhdVwiLCAxLCAxPDwyMiwgMTw8MjQpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRQVGF1LCBzZWN0aW9uc1BUYXUpO1xuICAgIGNvbnN0IHtmZDogZmRSMWNzLCBzZWN0aW9uczogc2VjdGlvbnNSMWNzfSA9IGF3YWl0IHJlYWRCaW5GaWxlKHIxY3NOYW1lLCBcInIxY3NcIiwgMSwgMTw8MjIsIDE8PDI0KTtcblxuICAgIGNvbnN0IHIxY3MgPSBhd2FpdCByZWFkUjFjc0ZkKGZkUjFjcywgc2VjdGlvbnNSMWNzLCB7bG9hZENvbnN0cmFpbnRzOiB0cnVlLCBsb2FkQ3VzdG9tR2F0ZXM6IHRydWV9KTtcblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IG44ciA9IGN1cnZlLkZyLm44O1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIHIxY3NcIik7XG4gICAgbGV0IHNSMWNzID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRSMWNzLCBzZWN0aW9uc1IxY3MsIDIpO1xuXG4gICAgY29uc3QgcGxvbmtDb25zdHJhaW50cyA9IG5ldyBCaWdBcnJheSgpO1xuICAgIGNvbnN0IHBsb25rQWRkaXRpb25zID0gbmV3IEJpZ0FycmF5KCk7XG4gICAgbGV0IHBsb25rTlZhcnMgPSByMWNzLm5WYXJzO1xuXG4gICAgY29uc3QgblB1YmxpYyA9IHIxY3Mubk91dHB1dHMgKyByMWNzLm5QdWJJbnB1dHM7XG5cbiAgICBhd2FpdCBwcm9jZXNzQ29uc3RyYWludHMoY3VydmUuRnIsIHIxY3MsIGxvZ2dlcik7XG5cbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICBjb25zdCBmZFpLZXkgPSBhd2FpdCBjcmVhdGVCaW5GaWxlKHprZXlOYW1lLCBcInprZXlcIiwgMSwgMTQsIDE8PDIyLCAxPDwyNCk7XG5cblxuICAgIGlmIChyMWNzLnByaW1lICE9IGN1cnZlLnIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwicjFjcyBjdXJ2ZSBkb2VzIG5vdCBtYXRjaCBwb3dlcnMgb2YgdGF1IGNlcmVtb255IGN1cnZlXCIpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgbGV0IGNpclBvd2VyID0gbG9nMihwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCAtMSkgKzE7XG4gICAgaWYgKGNpclBvd2VyIDwgMykgY2lyUG93ZXIgPSAzOyAgIC8vIEFzIHRoZSB0IHBvbHlub21pYWwgaXMgbis1IHdlIG5lZWQgYXQgbGVhc3QgYSBwb3dlciBvZiA0XG4gICAgY29uc3QgZG9tYWluU2l6ZSA9IDIgKiogY2lyUG93ZXI7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlBsb25rIGNvbnN0cmFpbnRzOiBcIiArIHBsb25rQ29uc3RyYWludHMubGVuZ3RoKTtcbiAgICBpZiAoY2lyUG93ZXIgPiBwb3dlcikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYGNpcmN1aXQgdG9vIGJpZyBmb3IgdGhpcyBwb3dlciBvZiB0YXUgY2VyZW1vbnkuICR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9ID4gMioqJHtwb3dlcn1gKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmICghc2VjdGlvbnNQVGF1WzEyXSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQb3dlcnMgb2YgdGF1IGlzIG5vdCBwcmVwYXJlZC5cIik7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cblxuICAgIGNvbnN0IExQb2ludHMgPSBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUqc0cxKTtcbiAgICBjb25zdCBvID0gc2VjdGlvbnNQVGF1WzEyXVswXS5wICsgKCgyICoqIChjaXJQb3dlcikpIC0xKSpzRzE7XG4gICAgYXdhaXQgZmRQVGF1LnJlYWRUb0J1ZmZlcihMUG9pbnRzLCAwLCBkb21haW5TaXplKnNHMSwgbyk7XG5cbiAgICBjb25zdCBbazEsIGsyXSA9IGdldEsxSzIoKTtcblxuICAgIGNvbnN0IHZrID0ge307XG5cblxuICAgIGF3YWl0IHdyaXRlQWRkaXRpb25zKDMsIFwiQWRkaXRpb25zXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVdpdG5lc3NNYXAoNCwgMCwgXCJBbWFwXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVdpdG5lc3NNYXAoNSwgMSwgXCJCbWFwXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVdpdG5lc3NNYXAoNiwgMiwgXCJDbWFwXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVFNYXAoNywgMywgXCJRbVwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVRTWFwKDgsIDQsIFwiUWxcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlUU1hcCg5LCA1LCBcIlFyXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVFNYXAoMTAsIDYsIFwiUW9cIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlUU1hcCgxMSwgNywgXCJRY1wiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVTaWdtYSgxMiwgXCJzaWdtYVwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVMcygxMywgXCJsYWdyYW5nZSBwb2x5bm9taWFsc1wiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICAvLyBXcml0ZSBQVGF1IHBvaW50c1xuICAgIC8vLy8vLy8vLy8vL1xuXG4gICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAxNCk7XG4gICAgY29uc3QgYnVmZk91dCA9IG5ldyBCaWdCdWZmZXIoKGRvbWFpblNpemUrNikqc0cxKTtcbiAgICBhd2FpdCBmZFBUYXUucmVhZFRvQnVmZmVyKGJ1ZmZPdXQsIDAsIChkb21haW5TaXplKzYpKnNHMSwgc2VjdGlvbnNQVGF1WzJdWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShidWZmT3V0KTtcbiAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cblxuICAgIGF3YWl0IHdyaXRlSGVhZGVycygpO1xuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRSMWNzLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRQVGF1LmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlNldHVwIEZpbmlzaGVkXCIpO1xuXG4gICAgcmV0dXJuIDtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDb25zdHJhaW50cyhGciwgcjFjcywgbG9nZ2VyKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKGxpbmVhckNvbWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNzID0gT2JqZWN0LmtleXMobGluZWFyQ29tYik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVhckNvbWJbc3NbaV1dID09IDBuKSBkZWxldGUgbGluZWFyQ29tYltzc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBqb2luKGxpbmVhckNvbWIxLCBrLCBsaW5lYXJDb21iMikge1xuICAgICAgICAgICAgY29uc3QgcmVzID0ge307XG5cbiAgICAgICAgICAgIGZvciAobGV0IHMgaW4gbGluZWFyQ29tYjEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc1tzXSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tzXSA9IEZyLm11bChrLCBsaW5lYXJDb21iMVtzXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3NdID0gRnIuYWRkKHJlc1tzXSwgRnIubXVsKGssIGxpbmVhckNvbWIxW3NdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIGxpbmVhckNvbWIyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gRnIubmVnKGxpbmVhckNvbWIyW3NdKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc1tzXSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tzXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNbc10gPSBGci5hZGQocmVzW3NdLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1hbGl6ZShyZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlZHVjZUNvZWZzKGxpbmVhckNvbWIsIG1heEMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgICAgICBrOiBGci56ZXJvLFxuICAgICAgICAgICAgICAgIHM6IFtdLFxuICAgICAgICAgICAgICAgIGNvZWZzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNzID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IHMgaW4gbGluZWFyQ29tYikge1xuICAgICAgICAgICAgICAgIGlmIChzID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmsgPSBGci5hZGQocmVzLmssIGxpbmVhckNvbWJbc10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZWFyQ29tYltzXSAhPSAwbikge1xuICAgICAgICAgICAgICAgICAgICBjcy5wdXNoKFtOdW1iZXIocyksIGxpbmVhckNvbWJbc11dKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjcy5sZW5ndGggPiBtYXhDKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYzEgPSBjcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMyID0gY3Muc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNsID0gYzFbMF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3IgPSBjMlswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbyA9IHBsb25rTlZhcnMrKztcbiAgICAgICAgICAgICAgICBjb25zdCBxbSA9IEZyLnplcm87XG4gICAgICAgICAgICAgICAgY29uc3QgcWwgPSBGci5uZWcoYzFbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFyID0gRnIubmVnKGMyWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxbyA9IEZyLm9uZTtcbiAgICAgICAgICAgICAgICBjb25zdCBxYyA9IEZyLnplcm87XG5cbiAgICAgICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goW3NsLCBzciwgc28sIHFtLCBxbCwgcXIsIHFvLCBxY10pO1xuXG4gICAgICAgICAgICAgICAgcGxvbmtBZGRpdGlvbnMucHVzaChbc2wsIHNyLCBjMVsxXSwgYzJbMV1dKTtcblxuICAgICAgICAgICAgICAgIGNzLnB1c2goW3NvLCBGci5vbmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMuc1tpXSA9IGNzW2ldWzBdO1xuICAgICAgICAgICAgICAgIHJlcy5jb2Vmc1tpXSA9IGNzW2ldWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHJlcy5jb2Vmcy5sZW5ndGggPCBtYXhDKSB7XG4gICAgICAgICAgICAgICAgcmVzLnMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICByZXMuY29lZnMucHVzaChGci56ZXJvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDb25zdHJhaW50U3VtKGxjKSB7XG4gICAgICAgICAgICBjb25zdCBDID0gcmVkdWNlQ29lZnMobGMsIDMpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSBDLnNbMF07XG4gICAgICAgICAgICBjb25zdCBzciA9IEMuc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IHNvID0gQy5zWzJdO1xuICAgICAgICAgICAgY29uc3QgcW0gPSBGci56ZXJvO1xuICAgICAgICAgICAgY29uc3QgcWwgPSBDLmNvZWZzWzBdO1xuICAgICAgICAgICAgY29uc3QgcXIgPSBDLmNvZWZzWzFdO1xuICAgICAgICAgICAgY29uc3QgcW8gPSBDLmNvZWZzWzJdO1xuICAgICAgICAgICAgY29uc3QgcWMgPSBDLms7XG4gICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goW3NsLCBzciwgc28sIHFtLCBxbCwgcXIsIHFvLCBxY10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkQ29uc3RyYWludE11bChsY0EsIGxjQiwgbGNDKSB7XG4gICAgICAgICAgICBjb25zdCBBID0gcmVkdWNlQ29lZnMobGNBLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IEIgPSByZWR1Y2VDb2VmcyhsY0IsIDEpO1xuICAgICAgICAgICAgY29uc3QgQyA9IHJlZHVjZUNvZWZzKGxjQywgMSk7XG5cblxuICAgICAgICAgICAgY29uc3Qgc2wgPSBBLnNbMF07XG4gICAgICAgICAgICBjb25zdCBzciA9IEIuc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNvID0gQy5zWzBdO1xuICAgICAgICAgICAgY29uc3QgcW0gPSBGci5tdWwoQS5jb2Vmc1swXSwgQi5jb2Vmc1swXSk7XG4gICAgICAgICAgICBjb25zdCBxbCA9IEZyLm11bChBLmNvZWZzWzBdLCBCLmspO1xuICAgICAgICAgICAgY29uc3QgcXIgPSBGci5tdWwoQS5rLCBCLmNvZWZzWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHFvID0gRnIubmVnKEMuY29lZnNbMF0pO1xuICAgICAgICAgICAgY29uc3QgcWMgPSBGci5zdWIoRnIubXVsKEEuaywgQi5rKSwgQy5rKTtcbiAgICAgICAgICAgIHBsb25rQ29uc3RyYWludHMucHVzaChbc2wsIHNyLCBzbywgcW0sIHFsLCBxciwgcW8sIHFjXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGMpIHtcbiAgICAgICAgICAgIGxldCBrID0gRnIuemVybztcbiAgICAgICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNzID0gT2JqZWN0LmtleXMobGMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsY1tzc1tpXV0gPT0gMG4pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxjW3NzW2ldXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNzW2ldID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IEZyLmFkZChrLCBsY1tzc1tpXV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA+IDApIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoayAhPSBGci56ZXJvKSByZXR1cm4gXCJrXCI7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzKGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgICAgIGNvbnN0IGxjdEEgPSBnZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGNBKTtcbiAgICAgICAgICAgIGNvbnN0IGxjdEIgPSBnZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGNCKTtcbiAgICAgICAgICAgIGlmICgobGN0QSA9PT0gXCIwXCIpIHx8IChsY3RCID09PSBcIjBcIikpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemUobGNDKTtcbiAgICAgICAgICAgICAgICBhZGRDb25zdHJhaW50U3VtKGxjQyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxjdEEgPT09IFwia1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGNDQyA9IGpvaW4obGNCLCBsY0FbMF0sIGxjQyk7XG4gICAgICAgICAgICAgICAgYWRkQ29uc3RyYWludFN1bShsY0NDKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGN0QiA9PT0gXCJrXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsY0NDID0gam9pbihsY0EsIGxjQlswXSwgbGNDKTtcbiAgICAgICAgICAgICAgICBhZGRDb25zdHJhaW50U3VtKGxjQ0MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRDb25zdHJhaW50TXVsKGxjQSwgbGNCLCBsY0MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcyA9IDE7IHMgPD0gblB1YmxpYzsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHM7XG4gICAgICAgICAgICBjb25zdCBzciA9IDA7XG4gICAgICAgICAgICBjb25zdCBzbyA9IDA7XG4gICAgICAgICAgICBjb25zdCBxbSA9IEZyLnplcm87XG4gICAgICAgICAgICBjb25zdCBxbCA9IEZyLm9uZTtcbiAgICAgICAgICAgIGNvbnN0IHFyID0gRnIuemVybztcbiAgICAgICAgICAgIGNvbnN0IHFvID0gRnIuemVybztcbiAgICAgICAgICAgIGNvbnN0IHFjID0gRnIuemVybztcblxuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKFtzbCwgc3IsIHNvLCBxbSwgcWwsIHFyLCBxbywgcWNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcjFjcy5jb25zdHJhaW50cy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChjICUgMTAwMDAgPT09IDApKSBsb2dnZXIuZGVidWcoYHByb2Nlc3NpbmcgY29uc3RyYWludHM6ICR7Y30vJHtyMWNzLm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgICAgIHByb2Nlc3MoLi4ucjFjcy5jb25zdHJhaW50c1tjXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVdpdG5lc3NNYXAoc2VjdGlvbk51bSwgcG9zQ29uc3RyYWludCwgbmFtZSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtDb25zdHJhaW50c1tpXVtwb3NDb25zdHJhaW50XSk7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9OiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVRTWFwKHNlY3Rpb25OdW0sIHBvc0NvbnN0cmFpbnQsIG5hbWUpIHtcbiAgICAgICAgbGV0IFEgPSBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUqbjhyKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBsb25rQ29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIFEuc2V0KHBsb25rQ29uc3RyYWludHNbaV1bcG9zQ29uc3RyYWludF0sIGkqbjhyKTtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGB3cml0aW5nICR7bmFtZX06ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFEpO1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICAgICAgUSA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoUSk7XG4gICAgICAgIHZrW25hbWVdPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShMUG9pbnRzLCBRLCBsb2dnZXIsIFwibXVsdGlleHAgXCIrbmFtZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVQNChidWZmKSB7XG4gICAgICAgIGNvbnN0IHEgPSBhd2FpdCBGci5pZmZ0KGJ1ZmYpO1xuICAgICAgICBjb25zdCBxNCA9IG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSpuOHIqNCk7XG4gICAgICAgIHE0LnNldChxLCAwKTtcbiAgICAgICAgY29uc3QgUTQgPSBhd2FpdCBGci5mZnQocTQpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUocSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShRNCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVBZGRpdGlvbnMoc2VjdGlvbk51bSwgbmFtZSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBjb25zdCBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoKDIqNCsyKm44cikpO1xuICAgICAgICBjb25zdCBidWZmT3V0ViA9IG5ldyBEYXRhVmlldyhidWZmT3V0LmJ1ZmZlcik7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwbG9ua0FkZGl0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWRkaXRpb249cGxvbmtBZGRpdGlvbnNbaV07XG4gICAgICAgICAgICBsZXQgbz0wO1xuICAgICAgICAgICAgYnVmZk91dFYuc2V0VWludDMyKG8sIGFkZGl0aW9uWzBdLCB0cnVlKTsgbys9NDtcbiAgICAgICAgICAgIGJ1ZmZPdXRWLnNldFVpbnQzMihvLCBhZGRpdGlvblsxXSwgdHJ1ZSk7IG8rPTQ7XG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIE1vbnRnb21lcnkuIHN0b3JlZCA9IHYqUlxuICAgICAgICAgICAgLy8gc28gd2hlbiBtb250Z29tZXJ5IG11bHRpcGxpZWQgYnkgdGhlIHdpdG5lc3MsIGl0J3MgcmVzdWx0ID0gdipSKncvUiA9IHYqd1xuICAgICAgICAgICAgYnVmZk91dC5zZXQoYWRkaXRpb25bMl0sIG8pOyBvKz0gbjhyO1xuICAgICAgICAgICAgYnVmZk91dC5zZXQoYWRkaXRpb25bM10sIG8pOyBvKz0gbjhyO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJ1ZmZPdXQpO1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfTogJHtpfS8ke3Bsb25rQWRkaXRpb25zLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVNpZ21hKHNlY3Rpb25OdW0sIG5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2lnbWEgPSBuZXcgQmlnQnVmZmVyKG44cipkb21haW5TaXplKjMpO1xuICAgICAgICBjb25zdCBsYXN0QXBhcmVuY2UgPSAgbmV3IEJpZ0FycmF5KHBsb25rTlZhcnMpO1xuICAgICAgICBjb25zdCBmaXJzdFBvcyA9IG5ldyBCaWdBcnJheShwbG9ua05WYXJzKTtcbiAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxkb21haW5TaXplO2krKykge1xuICAgICAgICAgICAgaWYgKGk8cGxvbmtDb25zdHJhaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKHBsb25rQ29uc3RyYWludHNbaV1bMF0sIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsxXSwgZG9tYWluU2l6ZSArIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsyXSwgZG9tYWluU2l6ZSoyICsgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBkb21haW5TaXplICsgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBkb21haW5TaXplKjIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1tjaXJQb3dlcl0pO1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfSBwaGFzZTE6ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzPTA7IHM8cGxvbmtOVmFyczsgcysrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpcnN0UG9zW3NdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KGxhc3RBcGFyZW5jZVtzXSwgZmlyc3RQb3Nbc10qbjhyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgbm90IHVzZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWYXJpYWJsZSBub3QgdXNlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKHMlMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGB3cml0aW5nICR7bmFtZX0gcGhhc2UyOiAke3N9LyR7cGxvbmtOVmFyc31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgbGV0IFMxID0gc2lnbWEuc2xpY2UoMCwgZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFMxKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICBsZXQgUzIgPSBzaWdtYS5zbGljZShkb21haW5TaXplKm44ciwgZG9tYWluU2l6ZSpuOHIqMik7XG4gICAgICAgIGF3YWl0IHdyaXRlUDQoUzIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIGxldCBTMyA9IHNpZ21hLnNsaWNlKGRvbWFpblNpemUqbjhyKjIsIGRvbWFpblNpemUqbjhyKjMpO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFMzKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgICAgICBTMSA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoUzEpO1xuICAgICAgICBTMiA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoUzIpO1xuICAgICAgICBTMyA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoUzMpO1xuXG4gICAgICAgIHZrLlMxPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShMUG9pbnRzLCBTMSwgbG9nZ2VyLCBcIm11bHRpZXhwIFMxXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIHZrLlMyPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShMUG9pbnRzLCBTMiwgbG9nZ2VyLCBcIm11bHRpZXhwIFMyXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIHZrLlMzPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShMUG9pbnRzLCBTMywgbG9nZ2VyLCBcIm11bHRpZXhwIFMzXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRTaWdtYShzLCBwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RBcGFyZW5jZVtzXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGZpcnN0UG9zW3NdID0gcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KGxhc3RBcGFyZW5jZVtzXSwgcCpuOHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHY7XG4gICAgICAgICAgICBpZiAocDxkb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IHc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHA8Mipkb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IEZyLm11bCh3LCBrMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHYgPSBGci5tdWwodywgazIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEFwYXJlbmNlW3NdPXY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUxzKHNlY3Rpb25OdW0sIG5hbWUpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgY29uc3QgbD1NYXRoLm1heChuUHVibGljLCAxKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJ1ZmYgPSBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUqbjhyKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KEZyLm9uZSwgaSpuOHIpO1xuICAgICAgICAgICAgYXdhaXQgd3JpdGVQNChidWZmKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9ICR7aX0vJHtsfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhZGVycygpIHtcblxuICAgICAgICAvLyBXcml0ZSB0aGUgaGVhZGVyXG4gICAgICAgIC8vLy8vLy8vLy8vXG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKDIpOyAvLyBQbG9ua1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgICAgICAvLyBXcml0ZSB0aGUgUGxvbmsgaGVhZGVyIHNlY3Rpb25cbiAgICAgICAgLy8vLy8vLy8vLy9cblxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDIpO1xuICAgICAgICBjb25zdCBwcmltZVEgPSBjdXJ2ZS5xO1xuICAgICAgICBjb25zdCBuOHEgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgICAgIGNvbnN0IHByaW1lUiA9IGN1cnZlLnI7XG4gICAgICAgIGNvbnN0IG44ciA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZVIpIC0gMSkgLyA2NCkgKzEpKjg7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhxKTtcbiAgICAgICAgYXdhaXQgd3JpdGVCaWdJbnQoZmRaS2V5LCBwcmltZVEsIG44cSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG44cik7XG4gICAgICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkWktleSwgcHJpbWVSLCBuOHIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihwbG9ua05WYXJzKTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIGJhcnNcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoblB1YmxpYyk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcHVibGljIHZhcnMgKG5vdCBpbmNsdWRpbmcgT05FKVxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihkb21haW5TaXplKTsgICAgICAgICAgICAgICAgICAvLyBkb21haW5TaXplXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQWRkaXRpb25zLmxlbmd0aCk7ICAgICAgICAgICAgICAgICAgLy8gZG9tYWluU2l6ZVxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCk7IFxuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShrMSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShrMik7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlFtKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5RbCkpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUXIpKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlFvKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5RYykpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5TMSkpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUzIpKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlMzKSk7XG5cbiAgICAgICAgbGV0IGJYXzI7XG4gICAgICAgIGJYXzIgPSBhd2FpdCBmZFBUYXUucmVhZChzRzIsIHNlY3Rpb25zUFRhdVszXVswXS5wICsgc0cyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJYXzIpO1xuXG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEsxSzIoKSB7XG4gICAgICAgIGxldCBrMSA9IEZyLnR3bztcbiAgICAgICAgd2hpbGUgKGlzSW5jbHVkZWQoazEsIFtdLCBjaXJQb3dlcikpIEZyLmFkZChrMSwgRnIub25lKTtcbiAgICAgICAgbGV0IGsyID0gRnIuYWRkKGsxLCBGci5vbmUpO1xuICAgICAgICB3aGlsZSAoaXNJbmNsdWRlZChrMiwgW2sxXSwgY2lyUG93ZXIpKSBGci5hZGQoazIsIEZyLm9uZSk7XG4gICAgICAgIHJldHVybiBbazEsIGsyXTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIGlzSW5jbHVkZWQoaywga0FyciwgcG93KSB7XG4gICAgICAgICAgICBjb25zdCBkb21haW5TaXplPSAyKipwb3c7XG4gICAgICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxkb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnIuZXEoaywgdykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxrQXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChGci5lcShrLCBGci5tdWwoa0FycltqXSwgdykpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3Bvd10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/plonk_setup.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/plonk_verify.js":
/*!**************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_verify.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkVerify)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(rsc)/./node_modules/snarkjs/src/Keccak256Transcript.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\n\n\n\n\n\nconst { unstringifyBigInts } = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nasync function plonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    let vk_verifier = unstringifyBigInts(_vk_verifier);\n    _proof = unstringifyBigInts(_proof);\n    let publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName(vk_verifier.curve);\n\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n\n    if (logger) logger.info(\"PLONK VERIFIER STARTED\");\n\n    let proof = fromObjectProof(curve,_proof);\n    vk_verifier = fromObjectVk(curve, vk_verifier);\n\n    if (!isWellConstructed(curve, proof)) {\n        logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    if (publicSignals.length != vk_verifier.nPublic) {\n        if (logger) logger.error(\"Invalid number of public inputs\");\n        return false;\n    }\n\n    if (!evaluationsAreValid(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid\");\n        return false;\n    }\n\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    const challenges = calculatechallenges(curve, proof, publicSignals, vk_verifier);\n    if (logger) {\n        logger.debug(\"beta: \" + Fr.toString(challenges.beta, 16));    \n        logger.debug(\"gamma: \" + Fr.toString(challenges.gamma, 16));    \n        logger.debug(\"alpha: \" + Fr.toString(challenges.alpha, 16));    \n        logger.debug(\"xi: \" + Fr.toString(challenges.xi, 16));\n        for(let i=1;i<6;i++) {\n            if (logger) logger.debug(\"v: \" + Fr.toString(challenges.v[i], 16));\n        }\n        logger.debug(\"u: \" + Fr.toString(challenges.u, 16));    \n    }\n    const L = calculateLagrangeEvaluations(curve, challenges, vk_verifier);\n    if (logger) {\n        for (let i=1; i<L.length; i++) {\n            logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));\n        }\n    }\n    \n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const pi = calculatePI(curve, publicSignals, L);\n    if (logger) {\n        logger.debug(\"PI(xi): \" + Fr.toString(pi, 16));\n    }\n    \n    const r0 = calculateR0(curve, proof, challenges, pi, L[1]);\n    if (logger) {\n        logger.debug(\"r0: \" + Fr.toString(r0, 16));\n    }\n\n    const D = calculateD(curve, proof, challenges, vk_verifier, L[1]);\n    if (logger) {\n        logger.debug(\"D: \" + G1.toString(G1.toAffine(D), 16));\n    }\n\n    const F = calculateF(curve, proof, challenges, vk_verifier, D);\n    if (logger) {\n        logger.debug(\"F: \" + G1.toString(G1.toAffine(F), 16));\n    }\n\n    const E = calculateE(curve, proof, challenges, r0);\n    if (logger) {\n        logger.debug(\"E: \" + G1.toString(G1.toAffine(E), 16));\n    }\n\n    const res = await isValidPairing(curve, proof, challenges, vk_verifier, E, F);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"OK!\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    return res;\n}\n\n\nfunction fromObjectProof(curve, proof) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    const res = {};\n    res.A = G1.fromObject(proof.A);\n    res.B = G1.fromObject(proof.B);\n    res.C = G1.fromObject(proof.C);\n    res.Z = G1.fromObject(proof.Z);\n    res.T1 = G1.fromObject(proof.T1);\n    res.T2 = G1.fromObject(proof.T2);\n    res.T3 = G1.fromObject(proof.T3);\n    res.eval_a = Fr.fromObject(proof.eval_a);\n    res.eval_b = Fr.fromObject(proof.eval_b);\n    res.eval_c = Fr.fromObject(proof.eval_c);\n    res.eval_zw = Fr.fromObject(proof.eval_zw);\n    res.eval_s1 = Fr.fromObject(proof.eval_s1);\n    res.eval_s2 = Fr.fromObject(proof.eval_s2);\n    res.Wxi = G1.fromObject(proof.Wxi);\n    res.Wxiw = G1.fromObject(proof.Wxiw);\n    return res;\n}\n\nfunction fromObjectVk(curve, vk) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n    const Fr = curve.Fr;\n    const res = vk;\n    res.Qm = G1.fromObject(vk.Qm);\n    res.Ql = G1.fromObject(vk.Ql);\n    res.Qr = G1.fromObject(vk.Qr);\n    res.Qo = G1.fromObject(vk.Qo);\n    res.Qc = G1.fromObject(vk.Qc);\n    res.S1 = G1.fromObject(vk.S1);\n    res.S2 = G1.fromObject(vk.S2);\n    res.S3 = G1.fromObject(vk.S3);\n    res.k1 = Fr.fromObject(vk.k1);\n    res.k2 = Fr.fromObject(vk.k2);\n    res.X_2 = G2.fromObject(vk.X_2);\n\n    return res;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    if (!G1.isValid(proof.A)) return false;\n    if (!G1.isValid(proof.B)) return false;\n    if (!G1.isValid(proof.C)) return false;\n    if (!G1.isValid(proof.Z)) return false;\n    if (!G1.isValid(proof.T1)) return false;\n    if (!G1.isValid(proof.T2)) return false;\n    if (!G1.isValid(proof.T3)) return false;\n    if (!G1.isValid(proof.Wxi)) return false;\n    if (!G1.isValid(proof.Wxiw)) return false;\n    return true;\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.geq(value, 0) && ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid(curve, evaluation) {\n    return checkValueBelongToField(curve, ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid(curve, proof) {\n    return checkEvaluationIsValid(curve, proof.eval_a)\n        && checkEvaluationIsValid(curve, proof.eval_b)\n        && checkEvaluationIsValid(curve, proof.eval_c)\n        && checkEvaluationIsValid(curve, proof.eval_s1)\n        && checkEvaluationIsValid(curve, proof.eval_s2)\n        && checkEvaluationIsValid(curve, proof.eval_zw);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction calculatechallenges(curve, proof, publicSignals, vk) {\n    const Fr = curve.Fr;\n    const res = {};\n    const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_2__.Keccak256Transcript(curve);\n\n    // Challenge round 2: beta and gamma\n    transcript.addPolCommitment(vk.Qm);\n    transcript.addPolCommitment(vk.Ql);\n    transcript.addPolCommitment(vk.Qr);\n    transcript.addPolCommitment(vk.Qo);\n    transcript.addPolCommitment(vk.Qc);\n    transcript.addPolCommitment(vk.S1);\n    transcript.addPolCommitment(vk.S2);\n    transcript.addPolCommitment(vk.S3);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.A);\n    transcript.addPolCommitment(proof.B);\n    transcript.addPolCommitment(proof.C);\n\n    res.beta = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    res.gamma = transcript.getChallenge();\n\n    // Challenge round 3: alpha\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    transcript.addScalar(res.gamma);\n    transcript.addPolCommitment(proof.Z);\n    res.alpha = transcript.getChallenge();\n\n    // Challenge round 4: xi\n    transcript.reset();\n    transcript.addScalar(res.alpha);\n    transcript.addPolCommitment(proof.T1);\n    transcript.addPolCommitment(proof.T2);\n    transcript.addPolCommitment(proof.T3);\n    res.xi = transcript.getChallenge();\n    \n    // Challenge round 5: v\n    transcript.reset();\n    transcript.addScalar(res.xi);\n    transcript.addScalar(proof.eval_a);\n    transcript.addScalar(proof.eval_b);\n    transcript.addScalar(proof.eval_c);\n    transcript.addScalar(proof.eval_s1);\n    transcript.addScalar(proof.eval_s2);\n    transcript.addScalar(proof.eval_zw);\n    res.v = [];\n    res.v[1] = transcript.getChallenge();\n\n    for (let i=2; i<6; i++ ) res.v[i] = Fr.mul(res.v[i-1], res.v[1]);\n\n    // Challenge: u\n    transcript.reset();\n    transcript.addPolCommitment(proof.Wxi);\n    transcript.addPolCommitment(proof.Wxiw);\n    res.u = transcript.getChallenge();\n\n    return res;\n}\n\nfunction calculateLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    let xin = challenges.xi;\n    let domainSize = 1;\n    for (let i=0; i<vk.power; i++) {\n        xin = Fr.square(xin);\n        domainSize *= 2;\n    }\n    challenges.xin = xin;\n\n    challenges.zh = Fr.sub(xin, Fr.one);\n\n    const L = [];\n\n    const n = Fr.e(domainSize);\n    let w = Fr.one;\n    for (let i=1; i<=Math.max(1, vk.nPublic); i++) {\n        L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n        w = Fr.mul(w, Fr.w[vk.power]);\n    }\n\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, L) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i=0; i<publicSignals.length; i++) {        \n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, L[i+1]));\n    }\n    return pi;\n}\n\nfunction calculateR0(curve, proof, challenges, pi, l1) {\n    const Fr = curve.Fr;\n\n    const e1 = pi;\n\n    const e2 = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    let e3a = Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1));\n    e3a = Fr.add(e3a, challenges.gamma);\n\n    let e3b = Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2));\n    e3b = Fr.add(e3b, challenges.gamma);\n\n    let e3c = Fr.add(proof.eval_c, challenges.gamma);\n\n    let e3 = Fr.mul(Fr.mul(e3a, e3b), e3c);\n    e3 = Fr.mul(e3, proof.eval_zw);\n    e3 = Fr.mul(e3, challenges.alpha);\n\n    const r0 = Fr.sub(Fr.sub(e1, e2), e3);\n\n    return r0;\n}\n\nfunction calculateD(curve, proof, challenges, vk, l1) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    \n    let d1 = G1.timesFr(vk.Qm, Fr.mul(proof.eval_a, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Ql, proof.eval_a));\n    d1 = G1.add(d1, G1.timesFr(vk.Qr, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Qo, proof.eval_c));\n    d1 = G1.add(d1, vk.Qc);\n\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n\n    const d2a1 = Fr.add(Fr.add(proof.eval_a, betaxi), challenges.gamma);\n    const d2a2 = Fr.add(Fr.add(proof.eval_b, Fr.mul(betaxi, vk.k1)), challenges.gamma);\n    const d2a3 = Fr.add(Fr.add(proof.eval_c, Fr.mul(betaxi, vk.k2)), challenges.gamma);\n\n    const d2a = Fr.mul(Fr.mul(Fr.mul(d2a1, d2a2), d2a3), challenges.alpha);\n\n    const d2b = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    const d2 = G1.timesFr(proof.Z, Fr.add(Fr.add(d2a, d2b), challenges.u));\n\n    const d3a = Fr.add(Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1)), challenges.gamma);\n    const d3b = Fr.add(Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2)), challenges.gamma);\n    const d3c = Fr.mul(Fr.mul(challenges.alpha, challenges.beta), proof.eval_zw);\n\n    const d3 = G1.timesFr(vk.S3, Fr.mul(Fr.mul(d3a, d3b), d3c));\n    \n    const d4low = proof.T1;\n    const d4mid = G1.timesFr(proof.T2, challenges.xin);\n    const d4high = G1.timesFr(proof.T3, Fr.square(challenges.xin));\n    let d4 = G1.add(d4low, G1.add(d4mid, d4high));\n    d4 = G1.timesFr(d4, challenges.zh);\n\n    const d = G1.sub(G1.sub(G1.add(d1, d2), d3), d4);\n\n    return d;\n}\n\nfunction calculateF(curve, proof, challenges, vk, D) {\n    const G1 = curve.G1;\n\n    let res = G1.add(D, G1.timesFr(proof.A, challenges.v[1]));\n    res = G1.add(res, G1.timesFr(proof.B, challenges.v[2]));\n    res = G1.add(res, G1.timesFr(proof.C, challenges.v[3]));\n    res = G1.add(res, G1.timesFr(vk.S1, challenges.v[4]));\n    res = G1.add(res, G1.timesFr(vk.S2, challenges.v[5]));\n\n    return res;\n}\n\nfunction calculateE(curve, proof, challenges, r0) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let e = Fr.add(Fr.neg(r0), Fr.mul(challenges.v[1], proof.eval_a));\n    e = Fr.add(e, Fr.mul(challenges.v[2], proof.eval_b));\n    e = Fr.add(e, Fr.mul(challenges.v[3], proof.eval_c));\n    e = Fr.add(e, Fr.mul(challenges.v[4], proof.eval_s1));\n    e = Fr.add(e, Fr.mul(challenges.v[5], proof.eval_s2));\n    e = Fr.add(e, Fr.mul(challenges.u, proof.eval_zw));\n\n    const res = G1.timesFr(G1.one, e);\n\n    return res;\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, E, F) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let A1 = proof.Wxi;\n    A1 = G1.add(A1, G1.timesFr(proof.Wxiw, challenges.u));\n\n    let B1 = G1.timesFr(proof.Wxi, challenges.xi);\n    const s = Fr.mul(Fr.mul(challenges.u, challenges.xi), Fr.w[vk.power]);\n    B1 = G1.add(B1, G1.timesFr(proof.Wxiw, s));\n    B1 = G1.add(B1, F);\n    B1 = G1.sub(B1, E);\n\n    const res = await curve.pairingEq(\n        G1.neg(A1) , vk.X_2,\n        B1 , curve.G2.one\n    );\n\n    return res;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfdmVyaWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVzQztBQUNDO0FBQ3dCO0FBQ3pCOztBQUV0QyxRQUFRLHFCQUFxQixFQUFFLCtDQUFLOztBQUVyQjtBQUNmO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isd0RBQXVCOztBQUUvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsNkJBQTZCLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdEQUFNLGtCQUFrQixnREFBTTtBQUN6Qzs7QUFFQTtBQUNBLDBDQUEwQyxnREFBTTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdFQUFtQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsS0FBSzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX3ZlcmlmeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGlzIHBhcGVyOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE5Lzk1My5wZGYgKi9cblxuaW1wb3J0ICogYXMgY3VydmVzIGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHsgdXRpbHMgfSAgIGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCB7IEtlY2NhazI1NlRyYW5zY3JpcHQgfSBmcm9tIFwiLi9LZWNjYWsyNTZUcmFuc2NyaXB0LmpzXCI7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmNvbnN0IHsgdW5zdHJpbmdpZnlCaWdJbnRzIH0gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGxvbmtWZXJpZnkoX3ZrX3ZlcmlmaWVyLCBfcHVibGljU2lnbmFscywgX3Byb29mLCBsb2dnZXIpIHtcbiAgICBsZXQgdmtfdmVyaWZpZXIgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3ZrX3ZlcmlmaWVyKTtcbiAgICBfcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3Byb29mKTtcbiAgICBsZXQgcHVibGljU2lnbmFscyA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHVibGljU2lnbmFscyk7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGN1cnZlcy5nZXRDdXJ2ZUZyb21OYW1lKHZrX3ZlcmlmaWVyLmN1cnZlKTtcblxuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUExPTksgVkVSSUZJRVIgU1RBUlRFRFwiKTtcblxuICAgIGxldCBwcm9vZiA9IGZyb21PYmplY3RQcm9vZihjdXJ2ZSxfcHJvb2YpO1xuICAgIHZrX3ZlcmlmaWVyID0gZnJvbU9iamVjdFZrKGN1cnZlLCB2a192ZXJpZmllcik7XG5cbiAgICBpZiAoIWlzV2VsbENvbnN0cnVjdGVkKGN1cnZlLCBwcm9vZikpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiUHJvb2YgY29tbWl0bWVudHMgYXJlIG5vdCB2YWxpZC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocHVibGljU2lnbmFscy5sZW5ndGggIT0gdmtfdmVyaWZpZXIublB1YmxpYykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwdWJsaWMgaW5wdXRzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFldmFsdWF0aW9uc0FyZVZhbGlkKGN1cnZlLCBwcm9vZikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUHJvb2YgZXZhbHVhdGlvbnMgYXJlIG5vdCB2YWxpZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghcHVibGljSW5wdXRzQXJlVmFsaWQoY3VydmUsIHB1YmxpY1NpZ25hbHMpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlB1YmxpYyBpbnB1dHMgYXJlIG5vdCB2YWxpZC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFsbGVuZ2VzID0gY2FsY3VsYXRlY2hhbGxlbmdlcyhjdXJ2ZSwgcHJvb2YsIHB1YmxpY1NpZ25hbHMsIHZrX3ZlcmlmaWVyKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcImJldGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5iZXRhLCAxNikpOyAgICBcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZ2FtbWE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5nYW1tYSwgMTYpKTsgICAgXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcImFscGhhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYWxwaGEsIDE2KSk7ICAgIFxuICAgICAgICBsb2dnZXIuZGVidWcoXCJ4aTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnhpLCAxNikpO1xuICAgICAgICBmb3IobGV0IGk9MTtpPDY7aSsrKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJ2OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMudltpXSwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoXCJ1OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMudSwgMTYpKTsgICAgXG4gICAgfVxuICAgIGNvbnN0IEwgPSBjYWxjdWxhdGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2a192ZXJpZmllcik7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBmb3IgKGxldCBpPTE7IGk8TC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBMJHtpfSh4aSk9YCArIEZyLnRvU3RyaW5nKExbaV0sIDE2KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHB1YmxpY1NpZ25hbHMubGVuZ3RoICE9IHZrX3ZlcmlmaWVyLm5QdWJsaWMpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTnVtYmVyIG9mIHB1YmxpYyBzaWduYWxzIGRvZXMgbm90IG1hdGNoIHdpdGggdmtcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwaSA9IGNhbGN1bGF0ZVBJKGN1cnZlLCBwdWJsaWNTaWduYWxzLCBMKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlBJKHhpKTogXCIgKyBGci50b1N0cmluZyhwaSwgMTYpKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcjAgPSBjYWxjdWxhdGVSMChjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHBpLCBMWzFdKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcInIwOiBcIiArIEZyLnRvU3RyaW5nKHIwLCAxNikpO1xuICAgIH1cblxuICAgIGNvbnN0IEQgPSBjYWxjdWxhdGVEKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmtfdmVyaWZpZXIsIExbMV0pO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRDogXCIgKyBHMS50b1N0cmluZyhHMS50b0FmZmluZShEKSwgMTYpKTtcbiAgICB9XG5cbiAgICBjb25zdCBGID0gY2FsY3VsYXRlRihjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrX3ZlcmlmaWVyLCBEKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkY6IFwiICsgRzEudG9TdHJpbmcoRzEudG9BZmZpbmUoRiksIDE2KSk7XG4gICAgfVxuXG4gICAgY29uc3QgRSA9IGNhbGN1bGF0ZUUoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCByMCk7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJFOiBcIiArIEcxLnRvU3RyaW5nKEcxLnRvQWZmaW5lKEUpLCAxNikpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGlzVmFsaWRQYWlyaW5nKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmtfdmVyaWZpZXIsIEUsIEYpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIk9LIVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiSW52YWxpZCBQcm9vZlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cblxuZnVuY3Rpb24gZnJvbU9iamVjdFByb29mKGN1cnZlLCBwcm9vZikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICByZXMuQSA9IEcxLmZyb21PYmplY3QocHJvb2YuQSk7XG4gICAgcmVzLkIgPSBHMS5mcm9tT2JqZWN0KHByb29mLkIpO1xuICAgIHJlcy5DID0gRzEuZnJvbU9iamVjdChwcm9vZi5DKTtcbiAgICByZXMuWiA9IEcxLmZyb21PYmplY3QocHJvb2YuWik7XG4gICAgcmVzLlQxID0gRzEuZnJvbU9iamVjdChwcm9vZi5UMSk7XG4gICAgcmVzLlQyID0gRzEuZnJvbU9iamVjdChwcm9vZi5UMik7XG4gICAgcmVzLlQzID0gRzEuZnJvbU9iamVjdChwcm9vZi5UMyk7XG4gICAgcmVzLmV2YWxfYSA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF9hKTtcbiAgICByZXMuZXZhbF9iID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX2IpO1xuICAgIHJlcy5ldmFsX2MgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfYyk7XG4gICAgcmVzLmV2YWxfencgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfencpO1xuICAgIHJlcy5ldmFsX3MxID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX3MxKTtcbiAgICByZXMuZXZhbF9zMiA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF9zMik7XG4gICAgcmVzLld4aSA9IEcxLmZyb21PYmplY3QocHJvb2YuV3hpKTtcbiAgICByZXMuV3hpdyA9IEcxLmZyb21PYmplY3QocHJvb2YuV3hpdyk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdFZrKGN1cnZlLCB2aykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRzIgPSBjdXJ2ZS5HMjtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHJlcyA9IHZrO1xuICAgIHJlcy5RbSA9IEcxLmZyb21PYmplY3QodmsuUW0pO1xuICAgIHJlcy5RbCA9IEcxLmZyb21PYmplY3QodmsuUWwpO1xuICAgIHJlcy5RciA9IEcxLmZyb21PYmplY3QodmsuUXIpO1xuICAgIHJlcy5RbyA9IEcxLmZyb21PYmplY3QodmsuUW8pO1xuICAgIHJlcy5RYyA9IEcxLmZyb21PYmplY3QodmsuUWMpO1xuICAgIHJlcy5TMSA9IEcxLmZyb21PYmplY3QodmsuUzEpO1xuICAgIHJlcy5TMiA9IEcxLmZyb21PYmplY3QodmsuUzIpO1xuICAgIHJlcy5TMyA9IEcxLmZyb21PYmplY3QodmsuUzMpO1xuICAgIHJlcy5rMSA9IEZyLmZyb21PYmplY3QodmsuazEpO1xuICAgIHJlcy5rMiA9IEZyLmZyb21PYmplY3QodmsuazIpO1xuICAgIHJlcy5YXzIgPSBHMi5mcm9tT2JqZWN0KHZrLlhfMik7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBpc1dlbGxDb25zdHJ1Y3RlZChjdXJ2ZSwgcHJvb2YpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5BKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5CKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5DKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5aKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5UMSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuVDIpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFHMS5pc1ZhbGlkKHByb29mLlQzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5XeGkpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFHMS5pc1ZhbGlkKHByb29mLld4aXcpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsdWVCZWxvbmdUb0ZpZWxkKGN1cnZlLCB2YWx1ZSkge1xuICAgIHJldHVybiBTY2FsYXIuZ2VxKHZhbHVlLCAwKSAmJiBTY2FsYXIubHQodmFsdWUsIGN1cnZlLnIpO1xufVxuXG5mdW5jdGlvbiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBldmFsdWF0aW9uKSB7XG4gICAgcmV0dXJuIGNoZWNrVmFsdWVCZWxvbmdUb0ZpZWxkKGN1cnZlLCBTY2FsYXIuZnJvbVJwckxFKGV2YWx1YXRpb24pKTtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGlvbnNBcmVWYWxpZChjdXJ2ZSwgcHJvb2YpIHtcbiAgICByZXR1cm4gY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbF9hKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsX2IpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWxfYylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbF9zMSlcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbF9zMilcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbF96dyk7XG59XG5cbmZ1bmN0aW9uIHB1YmxpY0lucHV0c0FyZVZhbGlkKGN1cnZlLCBwdWJsaWNJbnB1dHMpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHVibGljSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKCFjaGVja1ZhbHVlQmVsb25nVG9GaWVsZChjdXJ2ZSwgcHVibGljSW5wdXRzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVjaGFsbGVuZ2VzKGN1cnZlLCBwcm9vZiwgcHVibGljU2lnbmFscywgdmspIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgMjogYmV0YSBhbmQgZ2FtbWFcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUW0pO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5RbCk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLlFyKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUW8pO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5RYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLlMxKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUzIpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5TMyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoRnIuZShwdWJsaWNTaWduYWxzW2ldKSk7XG4gICAgfVxuXG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLkEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5CKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuQyk7XG5cbiAgICByZXMuYmV0YSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmJldGEpO1xuICAgIHJlcy5nYW1tYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgMzogYWxwaGFcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmJldGEpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHJlcy5nYW1tYSk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLlopO1xuICAgIHJlcy5hbHBoYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgNDogeGlcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmFscGhhKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuVDEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5UMik7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLlQzKTtcbiAgICByZXMueGkgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgIFxuICAgIC8vIENoYWxsZW5nZSByb3VuZCA1OiB2XG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHJlcy54aSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9hKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsX2IpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWxfYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9zMSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9zMik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF96dyk7XG4gICAgcmVzLnYgPSBbXTtcbiAgICByZXMudlsxXSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICBmb3IgKGxldCBpPTI7IGk8NjsgaSsrICkgcmVzLnZbaV0gPSBGci5tdWwocmVzLnZbaS0xXSwgcmVzLnZbMV0pO1xuXG4gICAgLy8gQ2hhbGxlbmdlOiB1XG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5XeGkpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5XeGl3KTtcbiAgICByZXMudSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2aykge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgeGluID0gY2hhbGxlbmdlcy54aTtcbiAgICBsZXQgZG9tYWluU2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaT0wOyBpPHZrLnBvd2VyOyBpKyspIHtcbiAgICAgICAgeGluID0gRnIuc3F1YXJlKHhpbik7XG4gICAgICAgIGRvbWFpblNpemUgKj0gMjtcbiAgICB9XG4gICAgY2hhbGxlbmdlcy54aW4gPSB4aW47XG5cbiAgICBjaGFsbGVuZ2VzLnpoID0gRnIuc3ViKHhpbiwgRnIub25lKTtcblxuICAgIGNvbnN0IEwgPSBbXTtcblxuICAgIGNvbnN0IG4gPSBGci5lKGRvbWFpblNpemUpO1xuICAgIGxldCB3ID0gRnIub25lO1xuICAgIGZvciAobGV0IGk9MTsgaTw9TWF0aC5tYXgoMSwgdmsublB1YmxpYyk7IGkrKykge1xuICAgICAgICBMW2ldID0gRnIuZGl2KEZyLm11bCh3LCBjaGFsbGVuZ2VzLnpoKSwgRnIubXVsKG4sIEZyLnN1YihjaGFsbGVuZ2VzLnhpLCB3KSkpO1xuICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbdmsucG93ZXJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUEkoY3VydmUsIHB1YmxpY1NpZ25hbHMsIEwpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IHBpID0gRnIuemVybztcbiAgICBmb3IgKGxldCBpPTA7IGk8cHVibGljU2lnbmFscy5sZW5ndGg7IGkrKykgeyAgICAgICAgXG4gICAgICAgIGNvbnN0IHcgPSBGci5lKHB1YmxpY1NpZ25hbHNbaV0pO1xuICAgICAgICBwaSA9IEZyLnN1YihwaSwgRnIubXVsKHcsIExbaSsxXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVIwKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgcGksIGwxKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IGUxID0gcGk7XG5cbiAgICBjb25zdCBlMiA9IEZyLm11bChsMSwgRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpKTtcblxuICAgIGxldCBlM2EgPSBGci5hZGQocHJvb2YuZXZhbF9hLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MxKSk7XG4gICAgZTNhID0gRnIuYWRkKGUzYSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICBsZXQgZTNiID0gRnIuYWRkKHByb29mLmV2YWxfYiwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbF9zMikpO1xuICAgIGUzYiA9IEZyLmFkZChlM2IsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgbGV0IGUzYyA9IEZyLmFkZChwcm9vZi5ldmFsX2MsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgbGV0IGUzID0gRnIubXVsKEZyLm11bChlM2EsIGUzYiksIGUzYyk7XG4gICAgZTMgPSBGci5tdWwoZTMsIHByb29mLmV2YWxfencpO1xuICAgIGUzID0gRnIubXVsKGUzLCBjaGFsbGVuZ2VzLmFscGhhKTtcblxuICAgIGNvbnN0IHIwID0gRnIuc3ViKEZyLnN1YihlMSwgZTIpLCBlMyk7XG5cbiAgICByZXR1cm4gcjA7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUQoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgbDEpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgXG4gICAgbGV0IGQxID0gRzEudGltZXNGcih2ay5RbSwgRnIubXVsKHByb29mLmV2YWxfYSwgcHJvb2YuZXZhbF9iKSk7XG4gICAgZDEgPSBHMS5hZGQoZDEsIEcxLnRpbWVzRnIodmsuUWwsIHByb29mLmV2YWxfYSkpO1xuICAgIGQxID0gRzEuYWRkKGQxLCBHMS50aW1lc0ZyKHZrLlFyLCBwcm9vZi5ldmFsX2IpKTtcbiAgICBkMSA9IEcxLmFkZChkMSwgRzEudGltZXNGcih2ay5RbywgcHJvb2YuZXZhbF9jKSk7XG4gICAgZDEgPSBHMS5hZGQoZDEsIHZrLlFjKTtcblxuICAgIGNvbnN0IGJldGF4aSA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGNoYWxsZW5nZXMueGkpO1xuXG4gICAgY29uc3QgZDJhMSA9IEZyLmFkZChGci5hZGQocHJvb2YuZXZhbF9hLCBiZXRheGkpLCBjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICBjb25zdCBkMmEyID0gRnIuYWRkKEZyLmFkZChwcm9vZi5ldmFsX2IsIEZyLm11bChiZXRheGksIHZrLmsxKSksIGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIGNvbnN0IGQyYTMgPSBGci5hZGQoRnIuYWRkKHByb29mLmV2YWxfYywgRnIubXVsKGJldGF4aSwgdmsuazIpKSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICBjb25zdCBkMmEgPSBGci5tdWwoRnIubXVsKEZyLm11bChkMmExLCBkMmEyKSwgZDJhMyksIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgY29uc3QgZDJiID0gRnIubXVsKGwxLCBGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSkpO1xuXG4gICAgY29uc3QgZDIgPSBHMS50aW1lc0ZyKHByb29mLlosIEZyLmFkZChGci5hZGQoZDJhLCBkMmIpLCBjaGFsbGVuZ2VzLnUpKTtcblxuICAgIGNvbnN0IGQzYSA9IEZyLmFkZChGci5hZGQocHJvb2YuZXZhbF9hLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MxKSksIGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIGNvbnN0IGQzYiA9IEZyLmFkZChGci5hZGQocHJvb2YuZXZhbF9iLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MyKSksIGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIGNvbnN0IGQzYyA9IEZyLm11bChGci5tdWwoY2hhbGxlbmdlcy5hbHBoYSwgY2hhbGxlbmdlcy5iZXRhKSwgcHJvb2YuZXZhbF96dyk7XG5cbiAgICBjb25zdCBkMyA9IEcxLnRpbWVzRnIodmsuUzMsIEZyLm11bChGci5tdWwoZDNhLCBkM2IpLCBkM2MpKTtcbiAgICBcbiAgICBjb25zdCBkNGxvdyA9IHByb29mLlQxO1xuICAgIGNvbnN0IGQ0bWlkID0gRzEudGltZXNGcihwcm9vZi5UMiwgY2hhbGxlbmdlcy54aW4pO1xuICAgIGNvbnN0IGQ0aGlnaCA9IEcxLnRpbWVzRnIocHJvb2YuVDMsIEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpbikpO1xuICAgIGxldCBkNCA9IEcxLmFkZChkNGxvdywgRzEuYWRkKGQ0bWlkLCBkNGhpZ2gpKTtcbiAgICBkNCA9IEcxLnRpbWVzRnIoZDQsIGNoYWxsZW5nZXMuemgpO1xuXG4gICAgY29uc3QgZCA9IEcxLnN1YihHMS5zdWIoRzEuYWRkKGQxLCBkMiksIGQzKSwgZDQpO1xuXG4gICAgcmV0dXJuIGQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUYoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRCkge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG5cbiAgICBsZXQgcmVzID0gRzEuYWRkKEQsIEcxLnRpbWVzRnIocHJvb2YuQSwgY2hhbGxlbmdlcy52WzFdKSk7XG4gICAgcmVzID0gRzEuYWRkKHJlcywgRzEudGltZXNGcihwcm9vZi5CLCBjaGFsbGVuZ2VzLnZbMl0pKTtcbiAgICByZXMgPSBHMS5hZGQocmVzLCBHMS50aW1lc0ZyKHByb29mLkMsIGNoYWxsZW5nZXMudlszXSkpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIodmsuUzEsIGNoYWxsZW5nZXMudls0XSkpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIodmsuUzIsIGNoYWxsZW5nZXMudls1XSkpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHIwKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IGUgPSBGci5hZGQoRnIubmVnKHIwKSwgRnIubXVsKGNoYWxsZW5nZXMudlsxXSwgcHJvb2YuZXZhbF9hKSk7XG4gICAgZSA9IEZyLmFkZChlLCBGci5tdWwoY2hhbGxlbmdlcy52WzJdLCBwcm9vZi5ldmFsX2IpKTtcbiAgICBlID0gRnIuYWRkKGUsIEZyLm11bChjaGFsbGVuZ2VzLnZbM10sIHByb29mLmV2YWxfYykpO1xuICAgIGUgPSBGci5hZGQoZSwgRnIubXVsKGNoYWxsZW5nZXMudls0XSwgcHJvb2YuZXZhbF9zMSkpO1xuICAgIGUgPSBGci5hZGQoZSwgRnIubXVsKGNoYWxsZW5nZXMudls1XSwgcHJvb2YuZXZhbF9zMikpO1xuICAgIGUgPSBGci5hZGQoZSwgRnIubXVsKGNoYWxsZW5nZXMudSwgcHJvb2YuZXZhbF96dykpO1xuXG4gICAgY29uc3QgcmVzID0gRzEudGltZXNGcihHMS5vbmUsIGUpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gaXNWYWxpZFBhaXJpbmcoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRSwgRikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBBMSA9IHByb29mLld4aTtcbiAgICBBMSA9IEcxLmFkZChBMSwgRzEudGltZXNGcihwcm9vZi5XeGl3LCBjaGFsbGVuZ2VzLnUpKTtcblxuICAgIGxldCBCMSA9IEcxLnRpbWVzRnIocHJvb2YuV3hpLCBjaGFsbGVuZ2VzLnhpKTtcbiAgICBjb25zdCBzID0gRnIubXVsKEZyLm11bChjaGFsbGVuZ2VzLnUsIGNoYWxsZW5nZXMueGkpLCBGci53W3ZrLnBvd2VyXSk7XG4gICAgQjEgPSBHMS5hZGQoQjEsIEcxLnRpbWVzRnIocHJvb2YuV3hpdywgcykpO1xuICAgIEIxID0gRzEuYWRkKEIxLCBGKTtcbiAgICBCMSA9IEcxLnN1YihCMSwgRSk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBjdXJ2ZS5wYWlyaW5nRXEoXG4gICAgICAgIEcxLm5lZyhBMSkgLCB2ay5YXzIsXG4gICAgICAgIEIxICwgY3VydmUuRzIub25lXG4gICAgKTtcblxuICAgIHJldHVybiByZXM7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/plonk_verify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/polynomial/cpolynomial.js":
/*!************************************************************!*\
  !*** ./node_modules/snarkjs/src/polynomial/cpolynomial.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CPolynomial: () => (/* binding */ CPolynomial)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _polynomial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polynomial.js */ \"(rsc)/./node_modules/snarkjs/src/polynomial/polynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// CPolynomial is a Combined Polynomial of the type :\n// CPolynomial(X) := P_0(X^n) + XP_1(X^n) + ... + X^{n-1}P_{n-1}(X^n)\n// We can use this class to avoid the allocation of a big memory buffer\n// for the coefficients because in some cases a big number of the coefficients are zero\n\n\n\n\n\nclass CPolynomial {\n    constructor(n, curve, logger) {\n        this.n = n;\n        this.polynomials = Array(n).fill(undefined);\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    addPolynomial(position, polynomial) {\n        if (position > this.n - 1) {\n            throw new Error(\"CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1\");\n        }\n\n        this.polynomials[position] = polynomial;\n    }\n\n    degree() {\n        let degrees = this.polynomials.map(\n            (polynomial, index) => polynomial === undefined ? 0 : polynomial.degree() * this.n + index);\n        return Math.max(...degrees);\n    }\n\n    getPolynomial() {\n        let degrees = this.polynomials.map(polynomial => polynomial === undefined ? 0 : polynomial.degree());\n        const maxDegree = this.degree();\n        const lengthBuffer = 2 ** ((0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.log2)(maxDegree - 1) + 1);\n        const sFr = this.Fr.n8;\n\n        let polynomial = new _polynomial_js__WEBPACK_IMPORTED_MODULE_2__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(lengthBuffer * sFr), this.curve, this.logger);\n\n        for (let i = 0; i < maxDegree; i++) {\n            const i_n8 = i * sFr;\n            const i_sFr = i_n8 * this.n;\n\n            for (let j = 0; j < this.n; j++) {\n                if (this.polynomials[j] !== undefined) {\n                    if (i <= degrees[j]) polynomial.coef.set(this.polynomials[j].coef.slice(i_n8, i_n8 + sFr), i_sFr + j * sFr);\n                }\n            }\n        }\n\n        return polynomial;\n    }\n\n    async multiExponentiation(PTau, name) {\n        let polynomial = this.getPolynomial();\n        const n = polynomial.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(polynomial.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG9seW5vbWlhbC9jcG9seW5vbWlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxJQUFJLElBQUksSUFBSTtBQUNsRTtBQUNBOztBQUV1QztBQUNQO0FBQ1c7O0FBRXBDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhDQUFJO0FBQ3ZDOztBQUVBLDZCQUE2QixzREFBVSxLQUFLLG1EQUFTOztBQUVyRCx3QkFBd0IsZUFBZTtBQUN2QztBQUNBOztBQUVBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb2x5bm9taWFsL2Nwb2x5bm9taWFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIENQb2x5bm9taWFsIGlzIGEgQ29tYmluZWQgUG9seW5vbWlhbCBvZiB0aGUgdHlwZSA6XG4vLyBDUG9seW5vbWlhbChYKSA6PSBQXzAoWF5uKSArIFjCt1BfMShYXm4pICsgLi4uICsgWF57bi0xfcK3UF97bi0xfShYXm4pXG4vLyBXZSBjYW4gdXNlIHRoaXMgY2xhc3MgdG8gYXZvaWQgdGhlIGFsbG9jYXRpb24gb2YgYSBiaWcgbWVtb3J5IGJ1ZmZlclxuLy8gZm9yIHRoZSBjb2VmZmljaWVudHMgYmVjYXVzZSBpbiBzb21lIGNhc2VzIGEgYmlnIG51bWJlciBvZiB0aGUgY29lZmZpY2llbnRzIGFyZSB6ZXJvXG5cbmltcG9ydCB7QmlnQnVmZmVyfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQge2xvZzJ9IGZyb20gXCIuLi9taXNjLmpzXCI7XG5pbXBvcnQge1BvbHlub21pYWx9IGZyb20gXCIuL3BvbHlub21pYWwuanNcIjtcblxuZXhwb3J0IGNsYXNzIENQb2x5bm9taWFsIHtcbiAgICBjb25zdHJ1Y3RvcihuLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMubiA9IG47XG4gICAgICAgIHRoaXMucG9seW5vbWlhbHMgPSBBcnJheShuKS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgdGhpcy5GciA9IGN1cnZlLkZyO1xuICAgICAgICB0aGlzLkcxID0gY3VydmUuRzE7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cblxuICAgIGFkZFBvbHlub21pYWwocG9zaXRpb24sIHBvbHlub21pYWwpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID4gdGhpcy5uIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ1BvbHlub21pYWw6YWRkUG9seW5vbWlhbCwgY2Fubm90IGFkZCBhIHBvbHlub21pYWwgdG8gYSBwb3NpdGlvbiBncmVhdGVyIHRoYW4gbi0xXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb2x5bm9taWFsc1twb3NpdGlvbl0gPSBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIGRlZ3JlZSgpIHtcbiAgICAgICAgbGV0IGRlZ3JlZXMgPSB0aGlzLnBvbHlub21pYWxzLm1hcChcbiAgICAgICAgICAgIChwb2x5bm9taWFsLCBpbmRleCkgPT4gcG9seW5vbWlhbCA9PT0gdW5kZWZpbmVkID8gMCA6IHBvbHlub21pYWwuZGVncmVlKCkgKiB0aGlzLm4gKyBpbmRleCk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCguLi5kZWdyZWVzKTtcbiAgICB9XG5cbiAgICBnZXRQb2x5bm9taWFsKCkge1xuICAgICAgICBsZXQgZGVncmVlcyA9IHRoaXMucG9seW5vbWlhbHMubWFwKHBvbHlub21pYWwgPT4gcG9seW5vbWlhbCA9PT0gdW5kZWZpbmVkID8gMCA6IHBvbHlub21pYWwuZGVncmVlKCkpO1xuICAgICAgICBjb25zdCBtYXhEZWdyZWUgPSB0aGlzLmRlZ3JlZSgpO1xuICAgICAgICBjb25zdCBsZW5ndGhCdWZmZXIgPSAyICoqIChsb2cyKG1heERlZ3JlZSAtIDEpICsgMSk7XG4gICAgICAgIGNvbnN0IHNGciA9IHRoaXMuRnIubjg7XG5cbiAgICAgICAgbGV0IHBvbHlub21pYWwgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKGxlbmd0aEJ1ZmZlciAqIHNGciksIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heERlZ3JlZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHNGcjtcbiAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaV9uOCAqIHRoaXMubjtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLm47IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvbHlub21pYWxzW2pdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPD0gZGVncmVlc1tqXSkgcG9seW5vbWlhbC5jb2VmLnNldCh0aGlzLnBvbHlub21pYWxzW2pdLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHNGciksIGlfc0ZyICsgaiAqIHNGcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlub21pYWw7XG4gICAgfVxuXG4gICAgYXN5bmMgbXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBuYW1lKSB7XG4gICAgICAgIGxldCBwb2x5bm9taWFsID0gdGhpcy5nZXRQb2x5bm9taWFsKCk7XG4gICAgICAgIGNvbnN0IG4gPSBwb2x5bm9taWFsLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjg7XG4gICAgICAgIGNvbnN0IFBUYXVOID0gUFRhdS5zbGljZSgwLCBuICogdGhpcy5HMS5GLm44ICogMik7XG4gICAgICAgIGNvbnN0IGJtID0gYXdhaXQgdGhpcy5Gci5iYXRjaEZyb21Nb250Z29tZXJ5KHBvbHlub21pYWwuY29lZik7XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLkcxLm11bHRpRXhwQWZmaW5lKFBUYXVOLCBibSwgdGhpcy5sb2dnZXIsIG5hbWUpO1xuICAgICAgICByZXMgPSB0aGlzLkcxLnRvQWZmaW5lKHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/polynomial/cpolynomial.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/polynomial/evaluations.js":
/*!************************************************************!*\
  !*** ./node_modules/snarkjs/src/polynomial/evaluations.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Evaluations: () => (/* binding */ Evaluations)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nclass Evaluations {\n    constructor(evaluations, curve, logger) {\n        this.eval = evaluations;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.logger = logger;\n    }\n\n    static async fromPolynomial(polynomial, extension, curve, logger) {\n        const coefficientsN = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(polynomial.length() * extension * curve.Fr.n8);\n        coefficientsN.set(polynomial.coef, 0);\n\n        const evaluations = await curve.Fr.fft(coefficientsN);\n\n        return new Evaluations(evaluations, curve, logger);\n    }\n\n    getEvaluation(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.eval.byteLength) {\n            throw new Error(\"Evaluations.getEvaluation() out of bounds\");\n        }\n\n        return this.eval.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    length() {\n        let length = this.eval.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.eval.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial evaluations buffer has incorrect size\");\n        }\n        if (0 === length) {\n            this.logger.warn(\"Polynomial has length zero\");\n        }\n        return length;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG9seW5vbWlhbC9ldmFsdWF0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXVDOztBQUVoQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxtREFBUztBQUMzQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb2x5bm9taWFsL2V2YWx1YXRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7QmlnQnVmZmVyfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmV4cG9ydCBjbGFzcyBFdmFsdWF0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoZXZhbHVhdGlvbnMsIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5ldmFsID0gZXZhbHVhdGlvbnM7XG4gICAgICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgdGhpcy5GciA9IGN1cnZlLkZyO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgZnJvbVBvbHlub21pYWwocG9seW5vbWlhbCwgZXh0ZW5zaW9uLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IGNvZWZmaWNpZW50c04gPSBuZXcgQmlnQnVmZmVyKHBvbHlub21pYWwubGVuZ3RoKCkgKiBleHRlbnNpb24gKiBjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGNvZWZmaWNpZW50c04uc2V0KHBvbHlub21pYWwuY29lZiwgMCk7XG5cbiAgICAgICAgY29uc3QgZXZhbHVhdGlvbnMgPSBhd2FpdCBjdXJ2ZS5Gci5mZnQoY29lZmZpY2llbnRzTik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBFdmFsdWF0aW9ucyhldmFsdWF0aW9ucywgY3VydmUsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgZ2V0RXZhbHVhdGlvbihpbmRleCkge1xuICAgICAgICBjb25zdCBpX244ID0gaW5kZXggKiB0aGlzLkZyLm44O1xuXG4gICAgICAgIGlmIChpX244ICsgdGhpcy5Gci5uOCA+IHRoaXMuZXZhbC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmFsdWF0aW9ucy5nZXRFdmFsdWF0aW9uKCkgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmV2YWwuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpO1xuICAgIH1cblxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMuZXZhbC5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uODtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gTWF0aC5mbG9vcih0aGlzLmV2YWwuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5bm9taWFsIGV2YWx1YXRpb25zIGJ1ZmZlciBoYXMgaW5jb3JyZWN0IHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlBvbHlub21pYWwgaGFzIGxlbmd0aCB6ZXJvXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/polynomial/evaluations.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/polynomial/polynomial.js":
/*!***********************************************************!*\
  !*** ./node_modules/snarkjs/src/polynomial/polynomial.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polynomial: () => (/* binding */ Polynomial)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nclass Polynomial {\n    constructor(coefficients, curve, logger) {\n        this.coef = coefficients;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    static async fromEvaluations(buffer, curve, logger) {\n        let coefficients = await curve.Fr.ifft(buffer);\n\n        return new Polynomial(coefficients, curve, logger);\n    }\n\n    static fromCoefficientsArray(array, curve, logger) {\n        const Fr = curve.Fr;\n        let buff = array.length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(array.length * Fr.n8) : new Uint8Array(array.length * Fr.n8);\n        for (let i = 0; i < array.length; i++) buff.set(array[i], i * Fr.n8);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    static fromPolynomial(polynomial, curve, logger) {\n        let length = polynomial.length();\n        let Fr = curve.Fr;\n\n        let buff = length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        buff.set(polynomial.coef.slice(), 0);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    isEqual(polynomial) {\n        const degree = this.degree();\n        if (degree !== polynomial.degree()) return false;\n\n        for (let i = 0; i < degree + 1; i++) {\n            if (!this.Fr.eq(this.getCoef(i), polynomial.getCoef(i))) return false;\n        }\n\n        return true;\n    }\n\n    blindCoefficients(blindingFactors) {\n        blindingFactors = blindingFactors || [];\n\n        const blindedCoefficients = (this.length() + blindingFactors.length) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((this.length() + blindingFactors.length) * this.Fr.n8) :\n            new Uint8Array((this.length() + blindingFactors.length) * this.Fr.n8);\n\n        blindedCoefficients.set(this.coef, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            blindedCoefficients.set(\n                this.Fr.add(\n                    blindedCoefficients.slice((this.length() + i) * this.Fr.n8, (this.length() + i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                (this.length() + i) * this.Fr.n8\n            );\n            blindedCoefficients.set(\n                this.Fr.sub(\n                    blindedCoefficients.slice(i * this.Fr.n8, (i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * this.Fr.n8\n            );\n        }\n        this.coef = blindedCoefficients;\n    }\n\n    getCoef(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.coef.byteLength) return this.Fr.zero;\n\n        return this.coef.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    setCoef(index, value) {\n        if (index > (this.length() - 1)) {\n            throw new Error(\"Coef index is not available\");\n        }\n\n        this.coef.set(value, index * this.Fr.n8);\n    }\n\n    static async to4T(buffer, domainSize, blindingFactors, Fr) {\n        blindingFactors = blindingFactors || [];\n        let a = await Fr.ifft(buffer);\n\n        const a4 = (domainSize * 4) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(domainSize * 4 * Fr.n8) : new Uint8Array(domainSize * 4 * Fr.n8);\n        a4.set(a, 0);\n\n        const A4 = await Fr.fft(a4);\n\n        if (blindingFactors.length === 0) {\n            return [a, A4];\n        }\n\n        const a1 = domainSize + blindingFactors.length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((domainSize + blindingFactors.length) * Fr.n8) :\n            new Uint8Array((domainSize + blindingFactors.length) * Fr.n8);\n\n        a1.set(a, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            a1.set(\n                Fr.add(\n                    a1.slice((domainSize + i) * Fr.n8, (domainSize + i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                (domainSize + i) * Fr.n8\n            );\n            a1.set(\n                Fr.sub(\n                    a1.slice(i * Fr.n8, (i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * Fr.n8\n            );\n        }\n\n        return [a1, A4];\n    }\n\n    length() {\n        let length = this.coef.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.coef.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial coefficients buffer has incorrect size\");\n        }\n        if (0 === length) {\n            if (this.logger) {\n                this.logger.warn(\"Polynomial has length zero\");\n            }\n        }\n        return length;\n    }\n\n    degree() {\n        for (let i = this.length() - 1; i > 0; i--) {\n            const i_n8 = i * this.Fr.n8;\n            if (!this.Fr.eq(this.Fr.zero, this.coef.slice(i_n8, i_n8 + this.Fr.n8))) {\n                return i;\n            }\n        }\n\n        return 0;\n    }\n\n    evaluate(point) {\n        let res = this.Fr.zero;\n\n        for (let i = this.degree() + 1; i > 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            const currentCoefficient = this.coef.slice(i_n8 - this.Fr.n8, i_n8);\n            res = this.Fr.add(currentCoefficient, this.Fr.mul(res, point));\n        }\n\n        return res;\n    }\n\n    fastEvaluate(point) {\n        const Fr = this.Fr;\n        let nThreads = 3;\n\n        let nCoefs = this.degree() + 1;\n        let coefsThread = parseInt(nCoefs / nThreads);\n        let residualCoefs = nCoefs - coefsThread * nThreads;\n\n        let res = [];\n        let xN = [];\n\n        xN[0] = Fr.one;\n\n        for (let i = 0; i < nThreads; i++) {\n            res[i] = Fr.zero;\n\n            let nCoefs = i === (nThreads - 1) ? coefsThread + residualCoefs : coefsThread;\n            for (let j = nCoefs; j > 0; j--) {\n                res[i] = Fr.add(this.getCoef((i * coefsThread) + j - 1), Fr.mul(res[i], point));\n\n                if (i === 0) xN[0] = Fr.mul(xN[0], point);\n            }\n        }\n\n        for (let i = 1; i < nThreads; i++) {\n            res[0] = Fr.add(res[0], Fr.mul(xN[i - 1], res[i]));\n            xN[i] = Fr.mul(xN[i - 1], xN[0]);\n        }\n\n        return res[0];\n    }\n\n    add(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.add(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.add(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    sub(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.sub(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.sub(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    mulScalar(value) {\n        for (let i = 0; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            this.coef.set(this.Fr.mul(this.coef.slice(i_n8, i_n8 + this.Fr.n8), value), i_n8);\n        }\n    }\n\n    addScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.add(currentValue, value), 0);\n    }\n\n    subScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.sub(currentValue, value), 0);\n    }\n\n    // Multiply current polynomial by the polynomial (X - value)\n    byXSubValue(value) {\n        const Fr = this.Fr;\n        const resize = !Fr.eq(Fr.zero, this.getCoef(this.length() - 1));\n\n        const length = resize ? this.length() + 1 : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (length - 1) * Fr.n8), 32);\n\n        // Step 1: multiply each coefficient by (-value)\n        this.mulScalar(Fr.neg(value));\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Multiply current polynomial by the polynomial (X^n + value)\n    byXNSubValue(n, value) {\n        const Fr = this.Fr;\n        const resize = !(this.length() - n - 1 >= this.degree());\n\n        const length = resize ? this.length() + n : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (this.degree() + 1) * 32, ), n * 32);\n\n        // Step 1: multiply each coefficient by (- value)\n        this.mulScalar(value);\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Euclidean division\n    divBy(polynomial) {\n        const Fr = this.Fr;\n        const degreeA = this.degree();\n        const degreeB = polynomial.degree();\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = degreeA - degreeB; i >= 0; i--) {\n            this.setCoef(i, Fr.div(polR.getCoef(i + degreeB), polynomial.getCoef(degreeB)));\n            for (let j = 0; j <= degreeB; j++) {\n                polR.setCoef(i + j, Fr.sub(polR.getCoef(i + j), Fr.mul(this.getCoef(i), polynomial.getCoef(j))));\n            }\n        }\n\n        return polR;\n    }\n\n    // Division by a Polynomial of the form (x^m - beta)\n    divByMonic(m, beta) {\n        const Fr = this.Fr;\n\n        let d = this.degree();\n\n        let buffer = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n        let quotient = new Polynomial(buffer, this.curve, this.logger);\n\n        let bArr = [];\n\n        // Add the m leading coefficients of this to quotient\n        for (let i = 0; i < m; i++) {\n            quotient.setCoef((d - i) - m, this.getCoef(d - i));\n            bArr[i] = this.getCoef(d - i);\n        }\n\n        let nThreads = m;\n\n        let j = 0;\n        for (let k = 0; k < nThreads; k++) {\n            for (let i = d - 2 * m - k; i >= 0; i = i - nThreads) {\n                if (i < 0) break;\n                let idx = k;\n                bArr[idx] = Fr.add(this.getCoef(i + m), Fr.mul(bArr[idx], beta));\n\n                quotient.setCoef(i, bArr[idx]);\n                j = (j + 1) % m;\n            }\n        }\n\n        this.coef = quotient.coef;\n    }\n\n    divByVanishing(n, beta) {\n        if (this.degree() < n) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = this.length() - 1; i >= n; i--) {\n            let leadingCoef = polR.getCoef(i);\n            if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n            polR.setCoef(i, Fr.zero);\n            polR.setCoef(i - n, Fr.add(polR.getCoef(i - n), Fr.mul(beta, leadingCoef)));\n            this.setCoef(i - n, Fr.add(this.getCoef(i - n), leadingCoef));\n        }\n\n        return polR;\n    }\n\n    divByVanishing2(m, beta) {\n        if (this.degree() < m) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        let nThreads = 3;\n        let nTotal = this.length() - m;\n        let nElementsChunk = Math.floor(nTotal / nThreads);\n        let nElementsLast = nTotal - (nThreads - 1) * nElementsChunk;\n\n        console.log(nTotal);\n        console.log(nElementsChunk + \"  \" + nElementsLast);\n        for (let k = 0; k < nThreads; k++) {\n            console.log(\"> Thread \" + k);\n            for (let i = (k === 0 ? nElementsLast : nElementsChunk); i > 0; i--) {\n                let idxDst = i - 1;\n                if (k !== 0) idxDst += (k - 1) * nElementsChunk + nElementsLast;\n                let idxSrc = idxDst + m;\n\n                let leadingCoef = polR.getCoef(idxSrc);\n                if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n                polR.setCoef(idxSrc, Fr.zero);\n                polR.setCoef(idxDst, Fr.add(polR.getCoef(idxDst), Fr.mul(beta, leadingCoef)));\n                this.setCoef(idxDst, Fr.add(this.getCoef(idxDst), leadingCoef));\n                console.log(idxDst + \" <-- \" + idxSrc);\n            }\n        }\n\n        this.print();\n        return polR;\n    }\n\n    fastDivByVanishing(data) {\n        const Fr = this.Fr;\n\n        for (let i = 0; i < data.length; i++) {\n\n            let m = data[i][0];\n            let beta = data[i][1];\n\n            if (this.degree() < m) {\n                throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n            }\n\n            let nThreads = 5;\n            let nElements = this.length() - m;\n            let nElementsBucket = Math.floor(nElements / nThreads / m);\n            let nElementsChunk = nElementsBucket * m;\n            let nElementsLast = nElements - nThreads * nElementsChunk;\n\n            //In C++ implementation this buffer will be allocated only once outside the loop\n            let polTmp = new Polynomial(this.length() > 2 << 14 ?\n                new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8), this.curve, this.logger);\n\n            let ptr = this.coef;\n            this.coef = polTmp.coef;\n            polTmp.coef = ptr;\n\n            // STEP 1: Setejar els m valors del segent bucket al chunk actual, PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n                let idx0 = (k + 1) * nElementsChunk + nElementsLast;\n                for (let i = 0; i < m; i++) {\n                    this.setCoef(idx0 + i - m, polTmp.getCoef(idx0 + i));\n                }\n\n                for (let i = 0; i < nElementsChunk - m; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                    this.setCoef(offset - m, val);\n                }\n            }\n\n            //STEP 2: Setejar els valors del elements last NO PARALLELITZAR\n            let idx0 = nElementsLast;\n            let pending = nElementsLast;\n            for (let i = 0; i < m && pending; i++) {\n                this.setCoef(idx0 - i - 1, polTmp.getCoef(idx0 + m - i - 1));\n                pending--;\n            }\n\n            for (let i = 0; i < pending; i++) {\n                let offset = idx0 - i - 1;\n                let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                this.setCoef(offset - m, val);\n            }\n\n            //Step 3: calcular acumulats NO  PARALELLITZAR\n\n            let acc = [];\n            let betaPow = Fr.one;\n            for (let i = 0; i < nElementsBucket; i++) {\n                betaPow = Fr.mul(betaPow, beta);\n            }\n            let currentBeta = Fr.one;\n\n            for (let k = nThreads; k > 0; k--) {\n                let idThread = k - 1;\n                let idx0 = idThread * nElementsChunk + nElementsLast;\n                acc[idThread] = [];\n\n                for (let i = 0; i < m; i++) {\n                    acc[idThread][i] = this.getCoef(idx0 + i);\n\n                    if (k !== nThreads) {\n                        acc[idThread][i] = Fr.add(acc[idThread][i], Fr.mul(betaPow, acc[idThread + 1][i]));\n                    }\n                }\n                currentBeta = Fr.mul(currentBeta, betaPow);\n            }\n\n            //STEP 4 recalcular  PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n\n                let idx0 = k * nElementsChunk + nElementsLast;\n                let currentBeta = beta; //Quan hopassem a C++ i ho paralelitzem aquesta variable ha de ser privada\n                let currentM = m - 1;\n\n                let limit = k === 0 ? nElementsLast : nElementsChunk;\n                for (let i = 0; i < limit; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(this.getCoef(offset), Fr.mul(currentBeta, acc[k][currentM]));\n\n                    this.setCoef(offset, val);\n\n                    // To avoid modular operations in each loop...\n                    if (currentM === 0) {\n                        currentM = m - 1;\n                        currentBeta = Fr.mul(currentBeta, beta);\n                    } else {\n                        currentM--;\n                    }\n                }\n            }\n        }\n    }\n\n\n    // Divide polynomial by X - value\n    divByXSubValue(value) {\n        const coefs = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * this.Fr.n8) : new Uint8Array(this.length() * this.Fr.n8);\n\n        coefs.set(this.Fr.zero, (this.length() - 1) * this.Fr.n8);\n        coefs.set(this.coef.slice((this.length() - 1) * this.Fr.n8, this.length() * this.Fr.n8), (this.length() - 2) * this.Fr.n8);\n        for (let i = this.length() - 3; i >= 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            coefs.set(\n                this.Fr.add(\n                    this.coef.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8),\n                    this.Fr.mul(value, coefs.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8))\n                ),\n                i * this.Fr.n8\n            );\n        }\n        if (!this.Fr.eq(\n            this.coef.slice(0, this.Fr.n8),\n            this.Fr.mul(this.Fr.neg(value), coefs.slice(0, this.Fr.n8))\n        )) {\n            throw new Error(\"Polynomial does not divide\");\n        }\n\n        this.coef = coefs;\n    }\n\n    divZh(domainSize, extensions = 4) {\n        for (let i = 0; i < domainSize; i++) {\n            const i_n8 = i * this.Fr.n8;\n            this.coef.set(this.Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8)), i_n8);\n        }\n\n        const upperBound = this.coef.byteLength / this.Fr.n8;\n        for (let i = domainSize; i < upperBound; i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = this.Fr.sub(\n                this.coef.slice((i - domainSize) * this.Fr.n8, (i - domainSize) * this.Fr.n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n            this.coef.set(a, i_n8);\n            if (i > (domainSize * (extensions-1) - extensions)) {\n                if (!this.Fr.isZero(a)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n    divByZerofier(n, beta) {\n        let Fr = this.Fr;\n        const invBeta = Fr.inv(beta);\n        const invBetaNeg = Fr.neg(invBeta);\n\n        let isOne = Fr.eq(Fr.one, invBetaNeg);\n        let isNegOne = Fr.eq(Fr.negone, invBetaNeg);\n\n        if (!isOne) {\n            for (let i = 0; i < n; i++) {\n                const i_n8 = i * this.Fr.n8;\n                let element;\n\n                // If invBetaNeg === -1 we'll save a multiplication changing it by a neg function call\n                if (isNegOne) {\n                    element = Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                } else {\n                    element = Fr.mul(invBetaNeg, this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                }\n\n                this.coef.set(element, i_n8);\n            }\n        }\n\n        isOne = Fr.eq(Fr.one, invBeta);\n        isNegOne = Fr.eq(Fr.negone, invBeta);\n\n        for (let i = n; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n            const i_prev_n8 = (i - n) * this.Fr.n8;\n\n            let element = this.Fr.sub(\n                this.coef.slice(i_prev_n8, i_prev_n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n\n            // If invBeta === 1 we'll not do anything\n            if(!isOne) {\n                // If invBeta === -1 we'll save a multiplication changing it by a neg function call\n                if(isNegOne) {\n                    element = Fr.neg(element);\n                } else {\n                    element = Fr.mul(invBeta, element);\n                }\n            }\n\n            this.coef.set(element, i_n8);\n\n            // Check if polynomial is divisible by checking if n high coefficients are zero\n            if (i > this.length() - n - 1) {\n                if (!this.Fr.isZero(element)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n// function divideByVanishing(f, n, p) {\n//     // polynomial division f(X) / (X^n - 1) with remainder\n//     // very cheap, 0 multiplications\n//     // strategy:\n//     // start with q(X) = 0, r(X) = f(X)\n//     // then start changing q, r while preserving the identity:\n//     // f(X) = q(X) * (X^n - 1) + r(X)\n//     // in every step, move highest-degree term of r into the product\n//     // => r eventually has degree < n and we're done\n//     let q = Array(f.length).fill(0n);\n//     let r = [...f];\n//     for (let i = f.length - 1; i >= n; i--) {\n//         let leadingCoeff = r[i];\n//         if (leadingCoeff === 0n) continue;\n//         r[i] = 0n;\n//         r[i - n] = mod(r[i - n] + leadingCoeff, p);\n//         q[i - n] = mod(q[i - n] + leadingCoeff, p);\n//     }\n//     return [q, r];\n// }\n\n    byX() {\n        const coefs = (this.length() + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.coef.byteLength + this.Fr.n8) : new Uint8Array(this.coef.byteLength + this.Fr.n8);\n        coefs.set(this.Fr.zero, 0);\n        coefs.set(this.coef, this.Fr.n8);\n\n        this.coef = coefs;\n    }\n\n// Compute a new polynomial f(x^n) from f(x)\n// f(x)   = a_0 + a_1x + a_2x^2 + ... + a_jx^j\n// f(x^n) = a_0 + a_1x^n + a_2x^2n + ... + a_jx^jn\n    static\n    async expX(polynomial, n, truncate = false) {\n        const Fr = polynomial.Fr;\n\n        if (n < 1) {\n            // n == 0 not allowed because it has no sense, but if it's necessary we have to return\n            // a zero degree polynomial with a constant coefficient equals to the sum of all the original coefficients\n            throw new Error(\"Compute a new polynomial to a zero or negative number is not allowed\");\n        } else if (1 === n) {\n            return await Polynomial.fromEvaluations(polynomial.coef, curve, polynomial.logger);\n        }\n\n        // length is the length of non-constant coefficients\n        // if truncate === true, the highest zero coefficients (if exist) will be removed\n        const length = truncate ? polynomial.degree() : (polynomial.length() - 1);\n        const bufferDst = (length * n + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((length * n + 1) * Fr.n8) : new Uint8Array((length * n + 1) * Fr.n8);\n\n        // Copy constant coefficient as is because is not related to x\n        bufferDst.set(polynomial.getCoef(0), 0);\n\n        for (let i = 1; i <= length; i++) {\n            const i_sFr = i * Fr.n8;\n\n            const coef = polynomial.getCoef(i);\n            bufferDst.set(coef, i_sFr * n);\n        }\n\n        return new Polynomial(bufferDst, polynomial.curve, polynomial.logger);\n    }\n\n    split(numPols, degPols, blindingFactors) {\n        if (numPols < 1) {\n            throw new Error(`Polynomials can't be split in ${numPols} parts`);\n        } else if (1 === numPols) {\n            return [this];\n        }\n\n        //blinding factors can be void or must have a length of numPols - 1\n        if (0 !== blindingFactors.length && blindingFactors.length < numPols - 1) {\n            throw new Error(`Blinding factors length must be ${numPols - 1}`);\n        }\n\n        const chunkByteLength = (degPols + 1) * this.Fr.n8;\n        let res = [];\n\n        // Check polynomial can be split in numChunks parts of chunkSize bytes...\n        const numRealPols = Math.ceil((this.degree() + 1) * this.Fr.n8 / chunkByteLength);\n        if (numRealPols < numPols) {\n            //throw new Error(`Polynomial is short to be split in ${numPols} parts of ${degPols} coefficients each.`);\n            for (let i = numRealPols; i < numPols; i++) {\n                res[i] = new Polynomial(new Uint8Array(this.Fr.n8), this.curve, this.logger);\n            }\n        }\n\n        numPols = Math.min(numPols, numRealPols);\n        for (let i = 0; i < numPols; i++) {\n            const isLast = (numPols - 1) === i;\n            const byteLength = isLast ? this.coef.byteLength - ((numPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n\n            let buff = (byteLength / this.Fr.n8) > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(byteLength) : new Uint8Array(byteLength);\n            res[i] = new Polynomial(buff, this.curve, this.logger);\n\n            const fr = i * chunkByteLength;\n            const to = isLast ? this.coef.byteLength : (i + 1) * chunkByteLength;\n            res[i].coef.set(this.coef.slice(fr, to), 0);\n\n            // Add a blinding factor as higher degree\n            if (!isLast) {\n                res[i].coef.set(blindingFactors[i], chunkByteLength);\n            }\n\n            // Sub blinding factor to the lowest degree\n            if (0 !== i) {\n                const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n                res[i].coef.set(lowestDegree, 0);\n            }\n\n            if (isLast) {\n                res[i].truncate();\n            }\n        }\n\n        return res;\n\n        // // compute t_low(X)\n        // let polTLow = new BigBuffer((chunkSize + 1) * n8r);\n        // polTLow.set(t.slice(0, zkey.domainSize * n8r), 0);\n        // // Add blinding scalar b_10 as a new coefficient n\n        // polTLow.set(ch.b[10], zkey.domainSize * n8r);\n        //\n        // // compute t_mid(X)\n        // let polTMid = new BigBuffer((zkey.domainSize + 1) * n8r);\n        // polTMid.set(t.slice(zkey.domainSize * n8r, zkey.domainSize * 2 * n8r), 0);\n        // // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        // const lowestMid = Fr.sub(polTMid.slice(0, n8r), ch.b[10]);\n        // polTMid.set(lowestMid, 0);\n        // // Add blinding scalar b_11 as a new coefficient n\n        // polTMid.set(ch.b[11], zkey.domainSize * n8r);\n        //\n        // // compute t_high(X)\n        // let polTHigh = new BigBuffer((zkey.domainSize + 6) * n8r);\n        // polTHigh.set(t.slice(zkey.domainSize * 2 * n8r, (zkey.domainSize * 3 + 6) * n8r), 0);\n        // //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        // const lowestHigh = Fr.sub(polTHigh.slice(0, n8r), ch.b[11]);\n        // polTHigh.set(lowestHigh, 0);\n        //\n        // proof.T1 = await expTau(polTLow, \"multiexp T1\");\n        // proof.T2 = await expTau(polTMid, \"multiexp T2\");\n        // proof.T3 = await expTau(polTHigh, \"multiexp T3\");\n    }\n\n// split2(degPols, blindingFactors) {\n//     let currentDegree = this.degree();\n//     const numFilledPols = Math.ceil((currentDegree + 1) / (degPols + 1));\n//\n//     //blinding factors can be void or must have a length of numPols - 1\n//     if (0 !== blindingFactors.length && blindingFactors.length < numFilledPols - 1) {\n//         throw new Error(`Blinding factors length must be ${numFilledPols - 1}`);\n//     }\n//\n//     const chunkByteLength = (degPols + 1) * this.Fr.n8;\n//\n//     // Check polynomial can be split in numChunks parts of chunkSize bytes...\n//     if (this.coef.byteLength / chunkByteLength <= numFilledPols - 1) {\n//         throw new Error(`Polynomial is short to be split in ${numFilledPols} parts of ${degPols} coefficients each.`);\n//     }\n//\n//     let res = [];\n//     for (let i = 0; i < numFilledPols; i++) {\n//         const isLast = (numFilledPols - 1) === i;\n//         const byteLength = isLast ? (currentDegree + 1) * this.Fr.n8 - ((numFilledPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n//\n//         res[i] = new Polynomial(new BigBuffer(byteLength), this.Fr, this.logger);\n//         const fr = i * chunkByteLength;\n//         const to = isLast ? (currentDegree + 1) * this.Fr.n8 : (i + 1) * chunkByteLength;\n//         res[i].coef.set(this.coef.slice(fr, to), 0);\n//\n//         // Add a blinding factor as higher degree\n//         if (!isLast) {\n//             res[i].coef.set(blindingFactors[i], chunkByteLength);\n//         }\n//\n//         // Sub blinding factor to the lowest degree\n//         if (0 !== i) {\n//             const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n//             res[i].coef.set(lowestDegree, 0);\n//         }\n//     }\n//\n//     return res;\n// }\n\n// merge(pols, overlap = true) {\n//     let length = 0;\n//     for (let i = 0; i < pols.length; i++) {\n//         length += pols[i].length();\n//     }\n//\n//     if (overlap) {\n//         length -= pols.length - 1;\n//     }\n//\n//     let res = new Polynomial(new BigBuffer(length * this.Fr.n8));\n//     for (let i = 0; i < pols.length; i++) {\n//         const byteLength = pols[i].coef.byteLength;\n//         if (0 === i) {\n//             res.coef.set(pols[i].coef, 0);\n//         } else {\n//\n//         }\n//     }\n//\n//     return res;\n// }\n\n    truncate() {\n        const deg = this.degree();\n        if (deg + 1 < this.coef.byteLength / this.Fr.n8) {\n            const newCoefs = (deg + 1) > 2 << 14 ?\n                new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((deg + 1) * this.Fr.n8) : new Uint8Array((deg + 1) * this.Fr.n8);\n\n            newCoefs.set(this.coef.slice(0, (deg + 1) * this.Fr.n8), 0);\n            this.coef = newCoefs;\n        }\n    }\n\n    static lagrangePolynomialInterpolation(xArr, yArr, curve) {\n        const Fr = curve.Fr;\n        let polynomial = computeLagrangePolynomial(0);\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.add(computeLagrangePolynomial(i));\n        }\n\n        return polynomial;\n\n        function computeLagrangePolynomial(i) {\n            let polynomial;\n\n            for (let j = 0; j < xArr.length; j++) {\n                if (j === i) continue;\n\n                if (polynomial === undefined) {\n                    let buff = (xArr.length) > 2 << 14 ?\n                        new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((xArr.length) * Fr.n8) : new Uint8Array((xArr.length) * Fr.n8);\n                    polynomial = new Polynomial(buff, curve);\n                    polynomial.setCoef(0, Fr.neg(xArr[j]));\n                    polynomial.setCoef(1, Fr.one);\n                } else {\n                    polynomial.byXSubValue(xArr[j]);\n                }\n            }\n\n            let denominator = polynomial.evaluate(xArr[i]);\n            denominator = Fr.inv(denominator);\n            const mulFactor = Fr.mul(yArr[i], denominator);\n\n            polynomial.mulScalar(mulFactor);\n\n            return polynomial;\n        }\n    }\n\n    static zerofierPolynomial(xArr, curve) {\n        const Fr = curve.Fr;\n        let buff = (xArr.length + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((xArr.length + 1) * Fr.n8) : new Uint8Array((xArr.length + 1) * Fr.n8);\n        let polynomial = new Polynomial(buff, curve);\n\n        // Build a zerofier polynomial with the following form:\n        // zerofier(X) = (X-xArr[0])(X-xArr[1])...(X-xArr[n])\n        polynomial.setCoef(0, Fr.neg(xArr[0]));\n        polynomial.setCoef(1, Fr.one);\n\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.byXSubValue(xArr[i]);\n        }\n\n        return polynomial;\n    }\n\n    print() {\n        const Fr = this.Fr;\n        let res = \"\";\n        for (let i = this.degree(); i >= 0; i--) {\n            const coef = this.getCoef(i);\n            if (!Fr.eq(Fr.zero, coef)) {\n                if (Fr.isNegative(coef)) {\n                    res += \" - \";\n                } else if (i !== this.degree()) {\n                    res += \" + \";\n                }\n                res += Fr.toString(coef);\n                if (i > 0) {\n                    res += i > 1 ? \"x^\" + i : \"x\";\n                }\n            }\n        }\n        console.log(res);\n    }\n\n    async multiExponentiation(PTau, name) {\n        const n = this.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(this.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG9seW5vbWlhbC9wb2x5bm9taWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFdUM7O0FBRWhDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qix3QkFBd0Isa0JBQWtCOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1EQUFTO0FBQ3pCOztBQUVBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbURBQVM7QUFDekI7O0FBRUE7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixjQUFjO0FBQ3RDOztBQUVBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQXNDO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQXNDO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsbURBQVM7QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLG1EQUFTO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6Qix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6Qix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsbURBQVM7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBLHFFQUFxRSxPQUFPO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVM7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTs7QUFFQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsT0FBTztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsY0FBYzs7QUFFMUM7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6QjtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6QjtBQUNBOztBQUVBLHdCQUF3QixhQUFhO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsU0FBUyxXQUFXLFNBQVM7QUFDakcsc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTs7QUFFQSxpRUFBaUUsbURBQVM7QUFDMUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0JBQWtCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxlQUFlLFdBQVcsU0FBUztBQUNwRztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVM7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixpQkFBaUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtREFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb2x5bm9taWFsL3BvbHlub21pYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHtCaWdCdWZmZXJ9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuZXhwb3J0IGNsYXNzIFBvbHlub21pYWwge1xuICAgIGNvbnN0cnVjdG9yKGNvZWZmaWNpZW50cywgY3VydmUsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmNvZWYgPSBjb2VmZmljaWVudHM7XG4gICAgICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgdGhpcy5GciA9IGN1cnZlLkZyO1xuICAgICAgICB0aGlzLkcxID0gY3VydmUuRzE7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBmcm9tRXZhbHVhdGlvbnMoYnVmZmVyLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGxldCBjb2VmZmljaWVudHMgPSBhd2FpdCBjdXJ2ZS5Gci5pZmZ0KGJ1ZmZlcik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGNvZWZmaWNpZW50cywgY3VydmUsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21Db2VmZmljaWVudHNBcnJheShhcnJheSwgY3VydmUsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBsZXQgYnVmZiA9IGFycmF5Lmxlbmd0aCA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcihhcnJheS5sZW5ndGggKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShhcnJheS5sZW5ndGggKiBGci5uOCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIGJ1ZmYuc2V0KGFycmF5W2ldLCBpICogRnIubjgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9seW5vbWlhbChidWZmLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVBvbHlub21pYWwocG9seW5vbWlhbCwgY3VydmUsIGxvZ2dlcikge1xuICAgICAgICBsZXQgbGVuZ3RoID0gcG9seW5vbWlhbC5sZW5ndGgoKTtcbiAgICAgICAgbGV0IEZyID0gY3VydmUuRnI7XG5cbiAgICAgICAgbGV0IGJ1ZmYgPSBsZW5ndGggPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIobGVuZ3RoICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkobGVuZ3RoICogRnIubjgpO1xuICAgICAgICBidWZmLnNldChwb2x5bm9taWFsLmNvZWYuc2xpY2UoKSwgMCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGJ1ZmYsIGN1cnZlLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIGlzRXF1YWwocG9seW5vbWlhbCkge1xuICAgICAgICBjb25zdCBkZWdyZWUgPSB0aGlzLmRlZ3JlZSgpO1xuICAgICAgICBpZiAoZGVncmVlICE9PSBwb2x5bm9taWFsLmRlZ3JlZSgpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWdyZWUgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5Gci5lcSh0aGlzLmdldENvZWYoaSksIHBvbHlub21pYWwuZ2V0Q29lZihpKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGJsaW5kQ29lZmZpY2llbnRzKGJsaW5kaW5nRmFjdG9ycykge1xuICAgICAgICBibGluZGluZ0ZhY3RvcnMgPSBibGluZGluZ0ZhY3RvcnMgfHwgW107XG5cbiAgICAgICAgY29uc3QgYmxpbmRlZENvZWZmaWNpZW50cyA9ICh0aGlzLmxlbmd0aCgpICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIoKHRoaXMubGVuZ3RoKCkgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSAqIHRoaXMuRnIubjgpIDpcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KCh0aGlzLmxlbmd0aCgpICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCkgKiB0aGlzLkZyLm44KTtcblxuICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNldCh0aGlzLmNvZWYsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsaW5kaW5nRmFjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYmxpbmRlZENvZWZmaWNpZW50cy5zZXQoXG4gICAgICAgICAgICAgICAgdGhpcy5Gci5hZGQoXG4gICAgICAgICAgICAgICAgICAgIGJsaW5kZWRDb2VmZmljaWVudHMuc2xpY2UoKHRoaXMubGVuZ3RoKCkgKyBpKSAqIHRoaXMuRnIubjgsICh0aGlzLmxlbmd0aCgpICsgaSArIDEpICogdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgICAgIGJsaW5kaW5nRmFjdG9yc1tpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKHRoaXMubGVuZ3RoKCkgKyBpKSAqIHRoaXMuRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNldChcbiAgICAgICAgICAgICAgICB0aGlzLkZyLnN1YihcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRlZENvZWZmaWNpZW50cy5zbGljZShpICogdGhpcy5Gci5uOCwgKGkgKyAxKSAqIHRoaXMuRnIubjgpLFxuICAgICAgICAgICAgICAgICAgICBibGluZGluZ0ZhY3RvcnNbaV1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGkgKiB0aGlzLkZyLm44XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29lZiA9IGJsaW5kZWRDb2VmZmljaWVudHM7XG4gICAgfVxuXG4gICAgZ2V0Q29lZihpbmRleCkge1xuICAgICAgICBjb25zdCBpX244ID0gaW5kZXggKiB0aGlzLkZyLm44O1xuXG4gICAgICAgIGlmIChpX244ICsgdGhpcy5Gci5uOCA+IHRoaXMuY29lZi5ieXRlTGVuZ3RoKSByZXR1cm4gdGhpcy5Gci56ZXJvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpO1xuICAgIH1cblxuICAgIHNldENvZWYoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmRleCA+ICh0aGlzLmxlbmd0aCgpIC0gMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZWYgaW5kZXggaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29lZi5zZXQodmFsdWUsIGluZGV4ICogdGhpcy5Gci5uOCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIHRvNFQoYnVmZmVyLCBkb21haW5TaXplLCBibGluZGluZ0ZhY3RvcnMsIEZyKSB7XG4gICAgICAgIGJsaW5kaW5nRmFjdG9ycyA9IGJsaW5kaW5nRmFjdG9ycyB8fCBbXTtcbiAgICAgICAgbGV0IGEgPSBhd2FpdCBGci5pZmZ0KGJ1ZmZlcik7XG5cbiAgICAgICAgY29uc3QgYTQgPSAoZG9tYWluU2l6ZSAqIDQpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUgKiA0ICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoZG9tYWluU2l6ZSAqIDQgKiBGci5uOCk7XG4gICAgICAgIGE0LnNldChhLCAwKTtcblxuICAgICAgICBjb25zdCBBNCA9IGF3YWl0IEZyLmZmdChhNCk7XG5cbiAgICAgICAgaWYgKGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbYSwgQTRdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYTEgPSBkb21haW5TaXplICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigoZG9tYWluU2l6ZSArIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGgpICogRnIubjgpIDpcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KChkb21haW5TaXplICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCkgKiBGci5uOCk7XG5cbiAgICAgICAgYTEuc2V0KGEsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsaW5kaW5nRmFjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYTEuc2V0KFxuICAgICAgICAgICAgICAgIEZyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgYTEuc2xpY2UoKGRvbWFpblNpemUgKyBpKSAqIEZyLm44LCAoZG9tYWluU2l6ZSArIGkgKyAxKSAqIEZyLm44KSxcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRpbmdGYWN0b3JzW2ldXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZG9tYWluU2l6ZSArIGkpICogRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhMS5zZXQoXG4gICAgICAgICAgICAgICAgRnIuc3ViKFxuICAgICAgICAgICAgICAgICAgICBhMS5zbGljZShpICogRnIubjgsIChpICsgMSkgKiBGci5uOCksXG4gICAgICAgICAgICAgICAgICAgIGJsaW5kaW5nRmFjdG9yc1tpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaSAqIEZyLm44XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFthMSwgQTRdO1xuICAgIH1cblxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uODtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gTWF0aC5mbG9vcih0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5bm9taWFsIGNvZWZmaWNpZW50cyBidWZmZXIgaGFzIGluY29ycmVjdCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvZ2dlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJQb2x5bm9taWFsIGhhcyBsZW5ndGggemVyb1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cblxuICAgIGRlZ3JlZSgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoKCkgLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICBpZiAoIXRoaXMuRnIuZXEodGhpcy5Gci56ZXJvLCB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUocG9pbnQpIHtcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuRnIuemVybztcblxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5kZWdyZWUoKSArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29lZmZpY2llbnQgPSB0aGlzLmNvZWYuc2xpY2UoaV9uOCAtIHRoaXMuRnIubjgsIGlfbjgpO1xuICAgICAgICAgICAgcmVzID0gdGhpcy5Gci5hZGQoY3VycmVudENvZWZmaWNpZW50LCB0aGlzLkZyLm11bChyZXMsIHBvaW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZhc3RFdmFsdWF0ZShwb2ludCkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGxldCBuVGhyZWFkcyA9IDM7XG5cbiAgICAgICAgbGV0IG5Db2VmcyA9IHRoaXMuZGVncmVlKCkgKyAxO1xuICAgICAgICBsZXQgY29lZnNUaHJlYWQgPSBwYXJzZUludChuQ29lZnMgLyBuVGhyZWFkcyk7XG4gICAgICAgIGxldCByZXNpZHVhbENvZWZzID0gbkNvZWZzIC0gY29lZnNUaHJlYWQgKiBuVGhyZWFkcztcblxuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGxldCB4TiA9IFtdO1xuXG4gICAgICAgIHhOWzBdID0gRnIub25lO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgblRocmVhZHM7IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gRnIuemVybztcblxuICAgICAgICAgICAgbGV0IG5Db2VmcyA9IGkgPT09IChuVGhyZWFkcyAtIDEpID8gY29lZnNUaHJlYWQgKyByZXNpZHVhbENvZWZzIDogY29lZnNUaHJlYWQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gbkNvZWZzOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gRnIuYWRkKHRoaXMuZ2V0Q29lZigoaSAqIGNvZWZzVGhyZWFkKSArIGogLSAxKSwgRnIubXVsKHJlc1tpXSwgcG9pbnQpKTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB4TlswXSA9IEZyLm11bCh4TlswXSwgcG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuVGhyZWFkczsgaSsrKSB7XG4gICAgICAgICAgICByZXNbMF0gPSBGci5hZGQocmVzWzBdLCBGci5tdWwoeE5baSAtIDFdLCByZXNbaV0pKTtcbiAgICAgICAgICAgIHhOW2ldID0gRnIubXVsKHhOW2kgLSAxXSwgeE5bMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc1swXTtcbiAgICB9XG5cbiAgICBhZGQocG9seW5vbWlhbCwgYmxpbmRpbmdWYWx1ZSkge1xuICAgICAgICBsZXQgb3RoZXIgPSBmYWxzZTtcblxuICAgICAgICBpZiAocG9seW5vbWlhbC5sZW5ndGgoKSA+IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIG90aGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBjb25zdCBwb2x5TGVuZ3RoID0gcG9seW5vbWlhbC5sZW5ndGgoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heCh0aGlzTGVuZ3RoLCBwb2x5TGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgICAgIGNvbnN0IGEgPSBpIDwgdGhpc0xlbmd0aCA/IHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkgOiB0aGlzLkZyLnplcm87XG4gICAgICAgICAgICBsZXQgYiA9IGkgPCBwb2x5TGVuZ3RoID8gcG9seW5vbWlhbC5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSA6IHRoaXMuRnIuemVybztcblxuICAgICAgICAgICAgaWYgKGJsaW5kaW5nVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGIgPSB0aGlzLkZyLm11bChiLCBibGluZGluZ1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgICAgIHBvbHlub21pYWwuY29lZi5zZXQodGhpcy5Gci5hZGQoYSwgYiksIGlfbjgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIuYWRkKGEsIGIpLCBpX244KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvZWY7XG4gICAgICAgICAgICB0aGlzLmNvZWYgPSBwb2x5bm9taWFsLmNvZWY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdWIocG9seW5vbWlhbCwgYmxpbmRpbmdWYWx1ZSkge1xuICAgICAgICBsZXQgb3RoZXIgPSBmYWxzZTtcblxuICAgICAgICBpZiAocG9seW5vbWlhbC5sZW5ndGgoKSA+IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIG90aGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBjb25zdCBwb2x5TGVuZ3RoID0gcG9seW5vbWlhbC5sZW5ndGgoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heCh0aGlzTGVuZ3RoLCBwb2x5TGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgICAgIGNvbnN0IGEgPSBpIDwgdGhpc0xlbmd0aCA/IHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkgOiB0aGlzLkZyLnplcm87XG4gICAgICAgICAgICBsZXQgYiA9IGkgPCBwb2x5TGVuZ3RoID8gcG9seW5vbWlhbC5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSA6IHRoaXMuRnIuemVybztcblxuICAgICAgICAgICAgaWYgKGJsaW5kaW5nVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGIgPSB0aGlzLkZyLm11bChiLCBibGluZGluZ1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgICAgIHBvbHlub21pYWwuY29lZi5zZXQodGhpcy5Gci5zdWIoYSwgYiksIGlfbjgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIuc3ViKGEsIGIpLCBpX244KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvZWY7XG4gICAgICAgICAgICB0aGlzLmNvZWYgPSBwb2x5bm9taWFsLmNvZWY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtdWxTY2FsYXIodmFsdWUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgdGhpcy5jb2VmLnNldCh0aGlzLkZyLm11bCh0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpLCB2YWx1ZSksIGlfbjgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkU2NhbGFyKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IDAgPT09IHRoaXMubGVuZ3RoKCkgPyB0aGlzLkZyLnplcm8gOiB0aGlzLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCk7XG4gICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5hZGQoY3VycmVudFZhbHVlLCB2YWx1ZSksIDApO1xuICAgIH1cblxuICAgIHN1YlNjYWxhcih2YWx1ZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSAwID09PSB0aGlzLmxlbmd0aCgpID8gdGhpcy5Gci56ZXJvIDogdGhpcy5jb2VmLnNsaWNlKDAsIHRoaXMuRnIubjgpO1xuICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIuc3ViKGN1cnJlbnRWYWx1ZSwgdmFsdWUpLCAwKTtcbiAgICB9XG5cbiAgICAvLyBNdWx0aXBseSBjdXJyZW50IHBvbHlub21pYWwgYnkgdGhlIHBvbHlub21pYWwgKFggLSB2YWx1ZSlcbiAgICBieVhTdWJWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9ICFGci5lcShGci56ZXJvLCB0aGlzLmdldENvZWYodGhpcy5sZW5ndGgoKSAtIDEpKTtcblxuICAgICAgICBjb25zdCBsZW5ndGggPSByZXNpemUgPyB0aGlzLmxlbmd0aCgpICsgMSA6IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBsZW5ndGggPiAyIDw8IDE0ID8gbmV3IEJpZ0J1ZmZlcihsZW5ndGggKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShsZW5ndGggKiBGci5uOCk7XG4gICAgICAgIGxldCBwb2wgPSBuZXcgUG9seW5vbWlhbChidWZmLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgLy8gU3RlcCAwOiBTZXQgY3VycmVudCBjb2VmZmljaWVudHMgdG8gdGhlIG5ldyBidWZmZXIgc2hpZnRlZCBvbmUgcG9zaXRpb25cbiAgICAgICAgcG9sLmNvZWYuc2V0KHRoaXMuY29lZi5zbGljZSgwLCAobGVuZ3RoIC0gMSkgKiBGci5uOCksIDMyKTtcblxuICAgICAgICAvLyBTdGVwIDE6IG11bHRpcGx5IGVhY2ggY29lZmZpY2llbnQgYnkgKC12YWx1ZSlcbiAgICAgICAgdGhpcy5tdWxTY2FsYXIoRnIubmVnKHZhbHVlKSk7XG5cbiAgICAgICAgLy8gU3RlcCAyOiBBZGQgY3VycmVudCBwb2x5bm9taWFsIHRvIGRlc3RpbmF0aW9uIHBvbHlub21pYWxcbiAgICAgICAgcG9sLmFkZCh0aGlzKTtcblxuICAgICAgICAvLyBTd2FwIGJ1ZmZlcnNcbiAgICAgICAgdGhpcy5jb2VmID0gcG9sLmNvZWY7XG4gICAgfVxuXG4gICAgLy8gTXVsdGlwbHkgY3VycmVudCBwb2x5bm9taWFsIGJ5IHRoZSBwb2x5bm9taWFsIChYXm4gKyB2YWx1ZSlcbiAgICBieVhOU3ViVmFsdWUobiwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgRnIgPSB0aGlzLkZyO1xuICAgICAgICBjb25zdCByZXNpemUgPSAhKHRoaXMubGVuZ3RoKCkgLSBuIC0gMSA+PSB0aGlzLmRlZ3JlZSgpKTtcblxuICAgICAgICBjb25zdCBsZW5ndGggPSByZXNpemUgPyB0aGlzLmxlbmd0aCgpICsgbiA6IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBsZW5ndGggPiAyIDw8IDE0ID8gbmV3IEJpZ0J1ZmZlcihsZW5ndGggKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShsZW5ndGggKiBGci5uOCk7XG4gICAgICAgIGxldCBwb2wgPSBuZXcgUG9seW5vbWlhbChidWZmLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgLy8gU3RlcCAwOiBTZXQgY3VycmVudCBjb2VmZmljaWVudHMgdG8gdGhlIG5ldyBidWZmZXIgc2hpZnRlZCBvbmUgcG9zaXRpb25cbiAgICAgICAgcG9sLmNvZWYuc2V0KHRoaXMuY29lZi5zbGljZSgwLCAodGhpcy5kZWdyZWUoKSArIDEpICogMzIsICksIG4gKiAzMik7XG5cbiAgICAgICAgLy8gU3RlcCAxOiBtdWx0aXBseSBlYWNoIGNvZWZmaWNpZW50IGJ5ICgtIHZhbHVlKVxuICAgICAgICB0aGlzLm11bFNjYWxhcih2YWx1ZSk7XG5cbiAgICAgICAgLy8gU3RlcCAyOiBBZGQgY3VycmVudCBwb2x5bm9taWFsIHRvIGRlc3RpbmF0aW9uIHBvbHlub21pYWxcbiAgICAgICAgcG9sLmFkZCh0aGlzKTtcblxuICAgICAgICAvLyBTd2FwIGJ1ZmZlcnNcbiAgICAgICAgdGhpcy5jb2VmID0gcG9sLmNvZWY7XG4gICAgfVxuXG4gICAgLy8gRXVjbGlkZWFuIGRpdmlzaW9uXG4gICAgZGl2QnkocG9seW5vbWlhbCkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGNvbnN0IGRlZ3JlZUEgPSB0aGlzLmRlZ3JlZSgpO1xuICAgICAgICBjb25zdCBkZWdyZWVCID0gcG9seW5vbWlhbC5kZWdyZWUoKTtcblxuICAgICAgICBsZXQgcG9sUiA9IG5ldyBQb2x5bm9taWFsKHRoaXMuY29lZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIodGhpcy5sZW5ndGgoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKiBGci5uOCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlZ3JlZUEgLSBkZWdyZWVCOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb2VmKGksIEZyLmRpdihwb2xSLmdldENvZWYoaSArIGRlZ3JlZUIpLCBwb2x5bm9taWFsLmdldENvZWYoZGVncmVlQikpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGRlZ3JlZUI7IGorKykge1xuICAgICAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpICsgaiwgRnIuc3ViKHBvbFIuZ2V0Q29lZihpICsgaiksIEZyLm11bCh0aGlzLmdldENvZWYoaSksIHBvbHlub21pYWwuZ2V0Q29lZihqKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2xSO1xuICAgIH1cblxuICAgIC8vIERpdmlzaW9uIGJ5IGEgUG9seW5vbWlhbCBvZiB0aGUgZm9ybSAoeF5tIC0gYmV0YSlcbiAgICBkaXZCeU1vbmljKG0sIGJldGEpIHtcbiAgICAgICAgY29uc3QgRnIgPSB0aGlzLkZyO1xuXG4gICAgICAgIGxldCBkID0gdGhpcy5kZWdyZWUoKTtcblxuICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy5sZW5ndGgoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KTtcbiAgICAgICAgbGV0IHF1b3RpZW50ID0gbmV3IFBvbHlub21pYWwoYnVmZmVyLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgbGV0IGJBcnIgPSBbXTtcblxuICAgICAgICAvLyBBZGQgdGhlIG0gbGVhZGluZyBjb2VmZmljaWVudHMgb2YgdGhpcyB0byBxdW90aWVudFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgcXVvdGllbnQuc2V0Q29lZigoZCAtIGkpIC0gbSwgdGhpcy5nZXRDb2VmKGQgLSBpKSk7XG4gICAgICAgICAgICBiQXJyW2ldID0gdGhpcy5nZXRDb2VmKGQgLSBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuVGhyZWFkcyA9IG07XG5cbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5UaHJlYWRzOyBrKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBkIC0gMiAqIG0gLSBrOyBpID49IDA7IGkgPSBpIC0gblRocmVhZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDApIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpZHggPSBrO1xuICAgICAgICAgICAgICAgIGJBcnJbaWR4XSA9IEZyLmFkZCh0aGlzLmdldENvZWYoaSArIG0pLCBGci5tdWwoYkFycltpZHhdLCBiZXRhKSk7XG5cbiAgICAgICAgICAgICAgICBxdW90aWVudC5zZXRDb2VmKGksIGJBcnJbaWR4XSk7XG4gICAgICAgICAgICAgICAgaiA9IChqICsgMSkgJSBtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2VmID0gcXVvdGllbnQuY29lZjtcbiAgICB9XG5cbiAgICBkaXZCeVZhbmlzaGluZyhuLCBiZXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZ3JlZSgpIDwgbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGl2QnlWYW5pc2hpbmcgcG9seW5vbWlhbCBkaXZpc29yIG11c3QgYmUgb2YgZGVncmVlIGxvd2VyIHRoYW4gdGhlIGRpdmlkZW5kIHBvbHlub21pYWxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG5cbiAgICAgICAgbGV0IHBvbFIgPSBuZXcgUG9seW5vbWlhbCh0aGlzLmNvZWYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICB0aGlzLmNvZWYgPSB0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogRnIubjgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxlbmd0aCgpIC0gMTsgaSA+PSBuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBsZWFkaW5nQ29lZiA9IHBvbFIuZ2V0Q29lZihpKTtcbiAgICAgICAgICAgIGlmIChGci5lcShGci56ZXJvLCBsZWFkaW5nQ29lZikpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBwb2xSLnNldENvZWYoaSwgRnIuemVybyk7XG4gICAgICAgICAgICBwb2xSLnNldENvZWYoaSAtIG4sIEZyLmFkZChwb2xSLmdldENvZWYoaSAtIG4pLCBGci5tdWwoYmV0YSwgbGVhZGluZ0NvZWYpKSk7XG4gICAgICAgICAgICB0aGlzLnNldENvZWYoaSAtIG4sIEZyLmFkZCh0aGlzLmdldENvZWYoaSAtIG4pLCBsZWFkaW5nQ29lZikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbFI7XG4gICAgfVxuXG4gICAgZGl2QnlWYW5pc2hpbmcyKG0sIGJldGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVncmVlKCkgPCBtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXZCeVZhbmlzaGluZyBwb2x5bm9taWFsIGRpdmlzb3IgbXVzdCBiZSBvZiBkZWdyZWUgbG93ZXIgdGhhbiB0aGUgZGl2aWRlbmQgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcblxuICAgICAgICBsZXQgcG9sUiA9IG5ldyBQb2x5bm9taWFsKHRoaXMuY29lZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIodGhpcy5sZW5ndGgoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKiBGci5uOCk7XG5cbiAgICAgICAgbGV0IG5UaHJlYWRzID0gMztcbiAgICAgICAgbGV0IG5Ub3RhbCA9IHRoaXMubGVuZ3RoKCkgLSBtO1xuICAgICAgICBsZXQgbkVsZW1lbnRzQ2h1bmsgPSBNYXRoLmZsb29yKG5Ub3RhbCAvIG5UaHJlYWRzKTtcbiAgICAgICAgbGV0IG5FbGVtZW50c0xhc3QgPSBuVG90YWwgLSAoblRocmVhZHMgLSAxKSAqIG5FbGVtZW50c0NodW5rO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKG5Ub3RhbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKG5FbGVtZW50c0NodW5rICsgXCIgIFwiICsgbkVsZW1lbnRzTGFzdCk7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgblRocmVhZHM7IGsrKykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCI+IFRocmVhZCBcIiArIGspO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IChrID09PSAwID8gbkVsZW1lbnRzTGFzdCA6IG5FbGVtZW50c0NodW5rKTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBpZHhEc3QgPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAoayAhPT0gMCkgaWR4RHN0ICs9IChrIC0gMSkgKiBuRWxlbWVudHNDaHVuayArIG5FbGVtZW50c0xhc3Q7XG4gICAgICAgICAgICAgICAgbGV0IGlkeFNyYyA9IGlkeERzdCArIG07XG5cbiAgICAgICAgICAgICAgICBsZXQgbGVhZGluZ0NvZWYgPSBwb2xSLmdldENvZWYoaWR4U3JjKTtcbiAgICAgICAgICAgICAgICBpZiAoRnIuZXEoRnIuemVybywgbGVhZGluZ0NvZWYpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpZHhTcmMsIEZyLnplcm8pO1xuICAgICAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpZHhEc3QsIEZyLmFkZChwb2xSLmdldENvZWYoaWR4RHN0KSwgRnIubXVsKGJldGEsIGxlYWRpbmdDb2VmKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29lZihpZHhEc3QsIEZyLmFkZCh0aGlzLmdldENvZWYoaWR4RHN0KSwgbGVhZGluZ0NvZWYpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpZHhEc3QgKyBcIiA8LS0gXCIgKyBpZHhTcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmludCgpO1xuICAgICAgICByZXR1cm4gcG9sUjtcbiAgICB9XG5cbiAgICBmYXN0RGl2QnlWYW5pc2hpbmcoZGF0YSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGxldCBtID0gZGF0YVtpXVswXTtcbiAgICAgICAgICAgIGxldCBiZXRhID0gZGF0YVtpXVsxXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZGVncmVlKCkgPCBtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGl2QnlWYW5pc2hpbmcgcG9seW5vbWlhbCBkaXZpc29yIG11c3QgYmUgb2YgZGVncmVlIGxvd2VyIHRoYW4gdGhlIGRpdmlkZW5kIHBvbHlub21pYWxcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBuVGhyZWFkcyA9IDU7XG4gICAgICAgICAgICBsZXQgbkVsZW1lbnRzID0gdGhpcy5sZW5ndGgoKSAtIG07XG4gICAgICAgICAgICBsZXQgbkVsZW1lbnRzQnVja2V0ID0gTWF0aC5mbG9vcihuRWxlbWVudHMgLyBuVGhyZWFkcyAvIG0pO1xuICAgICAgICAgICAgbGV0IG5FbGVtZW50c0NodW5rID0gbkVsZW1lbnRzQnVja2V0ICogbTtcbiAgICAgICAgICAgIGxldCBuRWxlbWVudHNMYXN0ID0gbkVsZW1lbnRzIC0gblRocmVhZHMgKiBuRWxlbWVudHNDaHVuaztcblxuICAgICAgICAgICAgLy9JbiBDKysgaW1wbGVtZW50YXRpb24gdGhpcyBidWZmZXIgd2lsbCBiZSBhbGxvY2F0ZWQgb25seSBvbmNlIG91dHNpZGUgdGhlIGxvb3BcbiAgICAgICAgICAgIGxldCBwb2xUbXAgPSBuZXcgUG9seW5vbWlhbCh0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KSwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgICAgICBsZXQgcHRyID0gdGhpcy5jb2VmO1xuICAgICAgICAgICAgdGhpcy5jb2VmID0gcG9sVG1wLmNvZWY7XG4gICAgICAgICAgICBwb2xUbXAuY29lZiA9IHB0cjtcblxuICAgICAgICAgICAgLy8gU1RFUCAxOiBTZXRlamFyIGVscyBtIHZhbG9ycyBkZWwgc2Vnw7xlbnQgYnVja2V0IGFsIGNodW5rIGFjdHVhbCwgUEFSQUxFTMK3TElUWkFSXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5UaHJlYWRzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaWR4MCA9IChrICsgMSkgKiBuRWxlbWVudHNDaHVuayArIG5FbGVtZW50c0xhc3Q7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKGlkeDAgKyBpIC0gbSwgcG9sVG1wLmdldENvZWYoaWR4MCArIGkpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5FbGVtZW50c0NodW5rIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpZHgwIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBGci5hZGQocG9sVG1wLmdldENvZWYob2Zmc2V0KSwgRnIubXVsKGJldGEsIHRoaXMuZ2V0Q29lZihvZmZzZXQpKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29lZihvZmZzZXQgLSBtLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TVEVQIDI6IFNldGVqYXIgZWxzIHZhbG9ycyBkZWwgZWxlbWVudHMgbGFzdCBOTyBQQVJBTMK3TEVMSVRaQVJcbiAgICAgICAgICAgIGxldCBpZHgwID0gbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbSAmJiBwZW5kaW5nOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYoaWR4MCAtIGkgLSAxLCBwb2xUbXAuZ2V0Q29lZihpZHgwICsgbSAtIGkgLSAxKSk7XG4gICAgICAgICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmc7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpZHgwIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IEZyLmFkZChwb2xUbXAuZ2V0Q29lZihvZmZzZXQpLCBGci5tdWwoYmV0YSwgdGhpcy5nZXRDb2VmKG9mZnNldCkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYob2Zmc2V0IC0gbSwgdmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TdGVwIDM6IGNhbGN1bGFyIGFjdW11bGF0cyBOTyAgUEFSQUxFTMK3TElUWkFSXG5cbiAgICAgICAgICAgIGxldCBhY2MgPSBbXTtcbiAgICAgICAgICAgIGxldCBiZXRhUG93ID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuRWxlbWVudHNCdWNrZXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGJldGFQb3cgPSBGci5tdWwoYmV0YVBvdywgYmV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudEJldGEgPSBGci5vbmU7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBuVGhyZWFkczsgayA+IDA7IGstLSkge1xuICAgICAgICAgICAgICAgIGxldCBpZFRocmVhZCA9IGsgLSAxO1xuICAgICAgICAgICAgICAgIGxldCBpZHgwID0gaWRUaHJlYWQgKiBuRWxlbWVudHNDaHVuayArIG5FbGVtZW50c0xhc3Q7XG4gICAgICAgICAgICAgICAgYWNjW2lkVGhyZWFkXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2lkVGhyZWFkXVtpXSA9IHRoaXMuZ2V0Q29lZihpZHgwICsgaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgIT09IG5UaHJlYWRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NbaWRUaHJlYWRdW2ldID0gRnIuYWRkKGFjY1tpZFRocmVhZF1baV0sIEZyLm11bChiZXRhUG93LCBhY2NbaWRUaHJlYWQgKyAxXVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRCZXRhID0gRnIubXVsKGN1cnJlbnRCZXRhLCBiZXRhUG93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TVEVQIDQgcmVjYWxjdWxhciAgUEFSQUxFTMK3TElUWkFSXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5UaHJlYWRzOyBrKyspIHtcblxuICAgICAgICAgICAgICAgIGxldCBpZHgwID0gayAqIG5FbGVtZW50c0NodW5rICsgbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEJldGEgPSBiZXRhOyAvL1F1YW4gaG9wYXNzZW0gYSBDKysgaSBobyBwYXJhbGVsaXR6ZW0gYXF1ZXN0YSB2YXJpYWJsZSBoYSBkZSBzZXIgcHJpdmFkYVxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TSA9IG0gLSAxO1xuXG4gICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gayA9PT0gMCA/IG5FbGVtZW50c0xhc3QgOiBuRWxlbWVudHNDaHVuaztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGlkeDAgLSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IEZyLmFkZCh0aGlzLmdldENvZWYob2Zmc2V0KSwgRnIubXVsKGN1cnJlbnRCZXRhLCBhY2Nba11bY3VycmVudE1dKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKG9mZnNldCwgdmFsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBhdm9pZCBtb2R1bGFyIG9wZXJhdGlvbnMgaW4gZWFjaCBsb29wLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE0gPSBtIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCZXRhID0gRnIubXVsKGN1cnJlbnRCZXRhLCBiZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIERpdmlkZSBwb2x5bm9taWFsIGJ5IFggLSB2YWx1ZVxuICAgIGRpdkJ5WFN1YlZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvZWZzID0gdGhpcy5sZW5ndGgoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogdGhpcy5Gci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogdGhpcy5Gci5uOCk7XG5cbiAgICAgICAgY29lZnMuc2V0KHRoaXMuRnIuemVybywgKHRoaXMubGVuZ3RoKCkgLSAxKSAqIHRoaXMuRnIubjgpO1xuICAgICAgICBjb2Vmcy5zZXQodGhpcy5jb2VmLnNsaWNlKCh0aGlzLmxlbmd0aCgpIC0gMSkgKiB0aGlzLkZyLm44LCB0aGlzLmxlbmd0aCgpICogdGhpcy5Gci5uOCksICh0aGlzLmxlbmd0aCgpIC0gMikgKiB0aGlzLkZyLm44KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoKCkgLSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIGNvZWZzLnNldChcbiAgICAgICAgICAgICAgICB0aGlzLkZyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNsaWNlKGlfbjggKyB0aGlzLkZyLm44LCBpX244ICsgMiAqIHRoaXMuRnIubjgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkZyLm11bCh2YWx1ZSwgY29lZnMuc2xpY2UoaV9uOCArIHRoaXMuRnIubjgsIGlfbjggKyAyICogdGhpcy5Gci5uOCkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpICogdGhpcy5Gci5uOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuRnIuZXEoXG4gICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCksXG4gICAgICAgICAgICB0aGlzLkZyLm11bCh0aGlzLkZyLm5lZyh2YWx1ZSksIGNvZWZzLnNsaWNlKDAsIHRoaXMuRnIubjgpKVxuICAgICAgICApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5bm9taWFsIGRvZXMgbm90IGRpdmlkZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29lZiA9IGNvZWZzO1xuICAgIH1cblxuICAgIGRpdlpoKGRvbWFpblNpemUsIGV4dGVuc2lvbnMgPSA0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIubmVnKHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkpLCBpX244KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSB0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjg7XG4gICAgICAgIGZvciAobGV0IGkgPSBkb21haW5TaXplOyBpIDwgdXBwZXJCb3VuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLkZyLnN1YihcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoKGkgLSBkb21haW5TaXplKSAqIHRoaXMuRnIubjgsIChpIC0gZG9tYWluU2l6ZSkgKiB0aGlzLkZyLm44ICsgdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuY29lZi5zZXQoYSwgaV9uOCk7XG4gICAgICAgICAgICBpZiAoaSA+IChkb21haW5TaXplICogKGV4dGVuc2lvbnMtMSkgLSBleHRlbnNpb25zKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBpcyBub3QgZGl2aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRpdkJ5WmVyb2ZpZXIobiwgYmV0YSkge1xuICAgICAgICBsZXQgRnIgPSB0aGlzLkZyO1xuICAgICAgICBjb25zdCBpbnZCZXRhID0gRnIuaW52KGJldGEpO1xuICAgICAgICBjb25zdCBpbnZCZXRhTmVnID0gRnIubmVnKGludkJldGEpO1xuXG4gICAgICAgIGxldCBpc09uZSA9IEZyLmVxKEZyLm9uZSwgaW52QmV0YU5lZyk7XG4gICAgICAgIGxldCBpc05lZ09uZSA9IEZyLmVxKEZyLm5lZ29uZSwgaW52QmV0YU5lZyk7XG5cbiAgICAgICAgaWYgKCFpc09uZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpbnZCZXRhTmVnID09PSAtMSB3ZSdsbCBzYXZlIGEgbXVsdGlwbGljYXRpb24gY2hhbmdpbmcgaXQgYnkgYSBuZWcgZnVuY3Rpb24gY2FsbFxuICAgICAgICAgICAgICAgIGlmIChpc05lZ09uZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gRnIubmVnKHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBGci5tdWwoaW52QmV0YU5lZywgdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNldChlbGVtZW50LCBpX244KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlzT25lID0gRnIuZXEoRnIub25lLCBpbnZCZXRhKTtcbiAgICAgICAgaXNOZWdPbmUgPSBGci5lcShGci5uZWdvbmUsIGludkJldGEpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBuOyBpIDwgdGhpcy5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICBjb25zdCBpX3ByZXZfbjggPSAoaSAtIG4pICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLkZyLnN1YihcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoaV9wcmV2X244LCBpX3ByZXZfbjggKyB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBJZiBpbnZCZXRhID09PSAxIHdlJ2xsIG5vdCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgaWYoIWlzT25lKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaW52QmV0YSA9PT0gLTEgd2UnbGwgc2F2ZSBhIG11bHRpcGxpY2F0aW9uIGNoYW5naW5nIGl0IGJ5IGEgbmVnIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgICAgICBpZihpc05lZ09uZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gRnIubmVnKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBGci5tdWwoaW52QmV0YSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvZWYuc2V0KGVsZW1lbnQsIGlfbjgpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBwb2x5bm9taWFsIGlzIGRpdmlzaWJsZSBieSBjaGVja2luZyBpZiBuIGhpZ2ggY29lZmZpY2llbnRzIGFyZSB6ZXJvXG4gICAgICAgICAgICBpZiAoaSA+IHRoaXMubGVuZ3RoKCkgLSBuIC0gMSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBpcyBub3QgZGl2aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuLy8gZnVuY3Rpb24gZGl2aWRlQnlWYW5pc2hpbmcoZiwgbiwgcCkge1xuLy8gICAgIC8vIHBvbHlub21pYWwgZGl2aXNpb24gZihYKSAvIChYXm4gLSAxKSB3aXRoIHJlbWFpbmRlclxuLy8gICAgIC8vIHZlcnkgY2hlYXAsIDAgbXVsdGlwbGljYXRpb25zXG4vLyAgICAgLy8gc3RyYXRlZ3k6XG4vLyAgICAgLy8gc3RhcnQgd2l0aCBxKFgpID0gMCwgcihYKSA9IGYoWClcbi8vICAgICAvLyB0aGVuIHN0YXJ0IGNoYW5naW5nIHEsIHIgd2hpbGUgcHJlc2VydmluZyB0aGUgaWRlbnRpdHk6XG4vLyAgICAgLy8gZihYKSA9IHEoWCkgKiAoWF5uIC0gMSkgKyByKFgpXG4vLyAgICAgLy8gaW4gZXZlcnkgc3RlcCwgbW92ZSBoaWdoZXN0LWRlZ3JlZSB0ZXJtIG9mIHIgaW50byB0aGUgcHJvZHVjdFxuLy8gICAgIC8vID0+IHIgZXZlbnR1YWxseSBoYXMgZGVncmVlIDwgbiBhbmQgd2UncmUgZG9uZVxuLy8gICAgIGxldCBxID0gQXJyYXkoZi5sZW5ndGgpLmZpbGwoMG4pO1xuLy8gICAgIGxldCByID0gWy4uLmZdO1xuLy8gICAgIGZvciAobGV0IGkgPSBmLmxlbmd0aCAtIDE7IGkgPj0gbjsgaS0tKSB7XG4vLyAgICAgICAgIGxldCBsZWFkaW5nQ29lZmYgPSByW2ldO1xuLy8gICAgICAgICBpZiAobGVhZGluZ0NvZWZmID09PSAwbikgY29udGludWU7XG4vLyAgICAgICAgIHJbaV0gPSAwbjtcbi8vICAgICAgICAgcltpIC0gbl0gPSBtb2QocltpIC0gbl0gKyBsZWFkaW5nQ29lZmYsIHApO1xuLy8gICAgICAgICBxW2kgLSBuXSA9IG1vZChxW2kgLSBuXSArIGxlYWRpbmdDb2VmZiwgcCk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBbcSwgcl07XG4vLyB9XG5cbiAgICBieVgoKSB7XG4gICAgICAgIGNvbnN0IGNvZWZzID0gKHRoaXMubGVuZ3RoKCkgKyAxKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmNvZWYuYnl0ZUxlbmd0aCArIHRoaXMuRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5jb2VmLmJ5dGVMZW5ndGggKyB0aGlzLkZyLm44KTtcbiAgICAgICAgY29lZnMuc2V0KHRoaXMuRnIuemVybywgMCk7XG4gICAgICAgIGNvZWZzLnNldCh0aGlzLmNvZWYsIHRoaXMuRnIubjgpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IGNvZWZzO1xuICAgIH1cblxuLy8gQ29tcHV0ZSBhIG5ldyBwb2x5bm9taWFsIGYoeF5uKSBmcm9tIGYoeClcbi8vIGYoeCkgICA9IGFfMCArIGFfMcK3eCArIGFfMsK3eF4yICsgLi4uICsgYV9qwrd4Xmpcbi8vIGYoeF5uKSA9IGFfMCArIGFfMcK3eF5uICsgYV8ywrd4XjJuICsgLi4uICsgYV9qwrd4XmpuXG4gICAgc3RhdGljXG4gICAgYXN5bmMgZXhwWChwb2x5bm9taWFsLCBuLCB0cnVuY2F0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IEZyID0gcG9seW5vbWlhbC5GcjtcblxuICAgICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgICAgIC8vIG4gPT0gMCBub3QgYWxsb3dlZCBiZWNhdXNlIGl0IGhhcyBubyBzZW5zZSwgYnV0IGlmIGl0J3MgbmVjZXNzYXJ5IHdlIGhhdmUgdG8gcmV0dXJuXG4gICAgICAgICAgICAvLyBhIHplcm8gZGVncmVlIHBvbHlub21pYWwgd2l0aCBhIGNvbnN0YW50IGNvZWZmaWNpZW50IGVxdWFscyB0byB0aGUgc3VtIG9mIGFsbCB0aGUgb3JpZ2luYWwgY29lZmZpY2llbnRzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wdXRlIGEgbmV3IHBvbHlub21pYWwgdG8gYSB6ZXJvIG9yIG5lZ2F0aXZlIG51bWJlciBpcyBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICgxID09PSBuKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMocG9seW5vbWlhbC5jb2VmLCBjdXJ2ZSwgcG9seW5vbWlhbC5sb2dnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIGlzIHRoZSBsZW5ndGggb2Ygbm9uLWNvbnN0YW50IGNvZWZmaWNpZW50c1xuICAgICAgICAvLyBpZiB0cnVuY2F0ZSA9PT0gdHJ1ZSwgdGhlIGhpZ2hlc3QgemVybyBjb2VmZmljaWVudHMgKGlmIGV4aXN0KSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdHJ1bmNhdGUgPyBwb2x5bm9taWFsLmRlZ3JlZSgpIDogKHBvbHlub21pYWwubGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgY29uc3QgYnVmZmVyRHN0ID0gKGxlbmd0aCAqIG4gKyAxKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigobGVuZ3RoICogbiArIDEpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKGxlbmd0aCAqIG4gKyAxKSAqIEZyLm44KTtcblxuICAgICAgICAvLyBDb3B5IGNvbnN0YW50IGNvZWZmaWNpZW50IGFzIGlzIGJlY2F1c2UgaXMgbm90IHJlbGF0ZWQgdG8geFxuICAgICAgICBidWZmZXJEc3Quc2V0KHBvbHlub21pYWwuZ2V0Q29lZigwKSwgMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIEZyLm44O1xuXG4gICAgICAgICAgICBjb25zdCBjb2VmID0gcG9seW5vbWlhbC5nZXRDb2VmKGkpO1xuICAgICAgICAgICAgYnVmZmVyRHN0LnNldChjb2VmLCBpX3NGciAqIG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGJ1ZmZlckRzdCwgcG9seW5vbWlhbC5jdXJ2ZSwgcG9seW5vbWlhbC5sb2dnZXIpO1xuICAgIH1cblxuICAgIHNwbGl0KG51bVBvbHMsIGRlZ1BvbHMsIGJsaW5kaW5nRmFjdG9ycykge1xuICAgICAgICBpZiAobnVtUG9scyA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbHMgY2FuJ3QgYmUgc3BsaXQgaW4gJHtudW1Qb2xzfSBwYXJ0c2ApO1xuICAgICAgICB9IGVsc2UgaWYgKDEgPT09IG51bVBvbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XG4gICAgICAgIH1cblxuICAgICAgICAvL2JsaW5kaW5nIGZhY3RvcnMgY2FuIGJlIHZvaWQgb3IgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIG51bVBvbHMgLSAxXG4gICAgICAgIGlmICgwICE9PSBibGluZGluZ0ZhY3RvcnMubGVuZ3RoICYmIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPCBudW1Qb2xzIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbGluZGluZyBmYWN0b3JzIGxlbmd0aCBtdXN0IGJlICR7bnVtUG9scyAtIDF9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaHVua0J5dGVMZW5ndGggPSAoZGVnUG9scyArIDEpICogdGhpcy5Gci5uODtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuXG4gICAgICAgIC8vIENoZWNrIHBvbHlub21pYWwgY2FuIGJlIHNwbGl0IGluIG51bUNodW5rcyBwYXJ0cyBvZiBjaHVua1NpemUgYnl0ZXMuLi5cbiAgICAgICAgY29uc3QgbnVtUmVhbFBvbHMgPSBNYXRoLmNlaWwoKHRoaXMuZGVncmVlKCkgKyAxKSAqIHRoaXMuRnIubjggLyBjaHVua0J5dGVMZW5ndGgpO1xuICAgICAgICBpZiAobnVtUmVhbFBvbHMgPCBudW1Qb2xzKSB7XG4gICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbCBpcyBzaG9ydCB0byBiZSBzcGxpdCBpbiAke251bVBvbHN9IHBhcnRzIG9mICR7ZGVnUG9sc30gY29lZmZpY2llbnRzIGVhY2guYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbnVtUmVhbFBvbHM7IGkgPCBudW1Qb2xzOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBuZXcgUG9seW5vbWlhbChuZXcgVWludDhBcnJheSh0aGlzLkZyLm44KSwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbnVtUG9scyA9IE1hdGgubWluKG51bVBvbHMsIG51bVJlYWxQb2xzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2xzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdCA9IChudW1Qb2xzIC0gMSkgPT09IGk7XG4gICAgICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gaXNMYXN0ID8gdGhpcy5jb2VmLmJ5dGVMZW5ndGggLSAoKG51bVBvbHMgLSAxKSAqIGNodW5rQnl0ZUxlbmd0aCkgOiBjaHVua0J5dGVMZW5ndGggKyB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICBsZXQgYnVmZiA9IChieXRlTGVuZ3RoIC8gdGhpcy5Gci5uOCkgPiAyIDw8IDE0ID8gbmV3IEJpZ0J1ZmZlcihieXRlTGVuZ3RoKSA6IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgcmVzW2ldID0gbmV3IFBvbHlub21pYWwoYnVmZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgICAgICBjb25zdCBmciA9IGkgKiBjaHVua0J5dGVMZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0byA9IGlzTGFzdCA/IHRoaXMuY29lZi5ieXRlTGVuZ3RoIDogKGkgKyAxKSAqIGNodW5rQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldCh0aGlzLmNvZWYuc2xpY2UoZnIsIHRvKSwgMCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhIGJsaW5kaW5nIGZhY3RvciBhcyBoaWdoZXIgZGVncmVlXG4gICAgICAgICAgICBpZiAoIWlzTGFzdCkge1xuICAgICAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldChibGluZGluZ0ZhY3RvcnNbaV0sIGNodW5rQnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1YiBibGluZGluZyBmYWN0b3IgdG8gdGhlIGxvd2VzdCBkZWdyZWVcbiAgICAgICAgICAgIGlmICgwICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG93ZXN0RGVncmVlID0gdGhpcy5Gci5zdWIocmVzW2ldLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCksIGJsaW5kaW5nRmFjdG9yc1tpIC0gMV0pO1xuICAgICAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldChsb3dlc3REZWdyZWUsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldLnRydW5jYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuXG4gICAgICAgIC8vIC8vIGNvbXB1dGUgdF9sb3coWClcbiAgICAgICAgLy8gbGV0IHBvbFRMb3cgPSBuZXcgQmlnQnVmZmVyKChjaHVua1NpemUgKyAxKSAqIG44cik7XG4gICAgICAgIC8vIHBvbFRMb3cuc2V0KHQuc2xpY2UoMCwgemtleS5kb21haW5TaXplICogbjhyKSwgMCk7XG4gICAgICAgIC8vIC8vIEFkZCBibGluZGluZyBzY2FsYXIgYl8xMCBhcyBhIG5ldyBjb2VmZmljaWVudCBuXG4gICAgICAgIC8vIHBvbFRMb3cuc2V0KGNoLmJbMTBdLCB6a2V5LmRvbWFpblNpemUgKiBuOHIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAvLyBjb21wdXRlIHRfbWlkKFgpXG4gICAgICAgIC8vIGxldCBwb2xUTWlkID0gbmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgMSkgKiBuOHIpO1xuICAgICAgICAvLyBwb2xUTWlkLnNldCh0LnNsaWNlKHprZXkuZG9tYWluU2l6ZSAqIG44ciwgemtleS5kb21haW5TaXplICogMiAqIG44ciksIDApO1xuICAgICAgICAvLyAvLyBTdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMCB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfbWlkXG4gICAgICAgIC8vIGNvbnN0IGxvd2VzdE1pZCA9IEZyLnN1Yihwb2xUTWlkLnNsaWNlKDAsIG44ciksIGNoLmJbMTBdKTtcbiAgICAgICAgLy8gcG9sVE1pZC5zZXQobG93ZXN0TWlkLCAwKTtcbiAgICAgICAgLy8gLy8gQWRkIGJsaW5kaW5nIHNjYWxhciBiXzExIGFzIGEgbmV3IGNvZWZmaWNpZW50IG5cbiAgICAgICAgLy8gcG9sVE1pZC5zZXQoY2guYlsxMV0sIHprZXkuZG9tYWluU2l6ZSAqIG44cik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIC8vIGNvbXB1dGUgdF9oaWdoKFgpXG4gICAgICAgIC8vIGxldCBwb2xUSGlnaCA9IG5ldyBCaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDYpICogbjhyKTtcbiAgICAgICAgLy8gcG9sVEhpZ2guc2V0KHQuc2xpY2UoemtleS5kb21haW5TaXplICogMiAqIG44ciwgKHprZXkuZG9tYWluU2l6ZSAqIDMgKyA2KSAqIG44ciksIDApO1xuICAgICAgICAvLyAvL1N1YnRyYWN0IGJsaW5kaW5nIHNjYWxhciBiXzExIHRvIHRoZSBsb3dlc3QgY29lZmZpY2llbnQgb2YgdF9oaWdoXG4gICAgICAgIC8vIGNvbnN0IGxvd2VzdEhpZ2ggPSBGci5zdWIocG9sVEhpZ2guc2xpY2UoMCwgbjhyKSwgY2guYlsxMV0pO1xuICAgICAgICAvLyBwb2xUSGlnaC5zZXQobG93ZXN0SGlnaCwgMCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHByb29mLlQxID0gYXdhaXQgZXhwVGF1KHBvbFRMb3csIFwibXVsdGlleHAgVDFcIik7XG4gICAgICAgIC8vIHByb29mLlQyID0gYXdhaXQgZXhwVGF1KHBvbFRNaWQsIFwibXVsdGlleHAgVDJcIik7XG4gICAgICAgIC8vIHByb29mLlQzID0gYXdhaXQgZXhwVGF1KHBvbFRIaWdoLCBcIm11bHRpZXhwIFQzXCIpO1xuICAgIH1cblxuLy8gc3BsaXQyKGRlZ1BvbHMsIGJsaW5kaW5nRmFjdG9ycykge1xuLy8gICAgIGxldCBjdXJyZW50RGVncmVlID0gdGhpcy5kZWdyZWUoKTtcbi8vICAgICBjb25zdCBudW1GaWxsZWRQb2xzID0gTWF0aC5jZWlsKChjdXJyZW50RGVncmVlICsgMSkgLyAoZGVnUG9scyArIDEpKTtcbi8vXG4vLyAgICAgLy9ibGluZGluZyBmYWN0b3JzIGNhbiBiZSB2b2lkIG9yIG11c3QgaGF2ZSBhIGxlbmd0aCBvZiBudW1Qb2xzIC0gMVxuLy8gICAgIGlmICgwICE9PSBibGluZGluZ0ZhY3RvcnMubGVuZ3RoICYmIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPCBudW1GaWxsZWRQb2xzIC0gMSkge1xuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsaW5kaW5nIGZhY3RvcnMgbGVuZ3RoIG11c3QgYmUgJHtudW1GaWxsZWRQb2xzIC0gMX1gKTtcbi8vICAgICB9XG4vL1xuLy8gICAgIGNvbnN0IGNodW5rQnl0ZUxlbmd0aCA9IChkZWdQb2xzICsgMSkgKiB0aGlzLkZyLm44O1xuLy9cbi8vICAgICAvLyBDaGVjayBwb2x5bm9taWFsIGNhbiBiZSBzcGxpdCBpbiBudW1DaHVua3MgcGFydHMgb2YgY2h1bmtTaXplIGJ5dGVzLi4uXG4vLyAgICAgaWYgKHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gY2h1bmtCeXRlTGVuZ3RoIDw9IG51bUZpbGxlZFBvbHMgLSAxKSB7XG4vLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbCBpcyBzaG9ydCB0byBiZSBzcGxpdCBpbiAke251bUZpbGxlZFBvbHN9IHBhcnRzIG9mICR7ZGVnUG9sc30gY29lZmZpY2llbnRzIGVhY2guYCk7XG4vLyAgICAgfVxuLy9cbi8vICAgICBsZXQgcmVzID0gW107XG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1GaWxsZWRQb2xzOyBpKyspIHtcbi8vICAgICAgICAgY29uc3QgaXNMYXN0ID0gKG51bUZpbGxlZFBvbHMgLSAxKSA9PT0gaTtcbi8vICAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGlzTGFzdCA/IChjdXJyZW50RGVncmVlICsgMSkgKiB0aGlzLkZyLm44IC0gKChudW1GaWxsZWRQb2xzIC0gMSkgKiBjaHVua0J5dGVMZW5ndGgpIDogY2h1bmtCeXRlTGVuZ3RoICsgdGhpcy5Gci5uODtcbi8vXG4vLyAgICAgICAgIHJlc1tpXSA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoYnl0ZUxlbmd0aCksIHRoaXMuRnIsIHRoaXMubG9nZ2VyKTtcbi8vICAgICAgICAgY29uc3QgZnIgPSBpICogY2h1bmtCeXRlTGVuZ3RoO1xuLy8gICAgICAgICBjb25zdCB0byA9IGlzTGFzdCA/IChjdXJyZW50RGVncmVlICsgMSkgKiB0aGlzLkZyLm44IDogKGkgKyAxKSAqIGNodW5rQnl0ZUxlbmd0aDtcbi8vICAgICAgICAgcmVzW2ldLmNvZWYuc2V0KHRoaXMuY29lZi5zbGljZShmciwgdG8pLCAwKTtcbi8vXG4vLyAgICAgICAgIC8vIEFkZCBhIGJsaW5kaW5nIGZhY3RvciBhcyBoaWdoZXIgZGVncmVlXG4vLyAgICAgICAgIGlmICghaXNMYXN0KSB7XG4vLyAgICAgICAgICAgICByZXNbaV0uY29lZi5zZXQoYmxpbmRpbmdGYWN0b3JzW2ldLCBjaHVua0J5dGVMZW5ndGgpO1xuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICAvLyBTdWIgYmxpbmRpbmcgZmFjdG9yIHRvIHRoZSBsb3dlc3QgZGVncmVlXG4vLyAgICAgICAgIGlmICgwICE9PSBpKSB7XG4vLyAgICAgICAgICAgICBjb25zdCBsb3dlc3REZWdyZWUgPSB0aGlzLkZyLnN1YihyZXNbaV0uY29lZi5zbGljZSgwLCB0aGlzLkZyLm44KSwgYmxpbmRpbmdGYWN0b3JzW2kgLSAxXSk7XG4vLyAgICAgICAgICAgICByZXNbaV0uY29lZi5zZXQobG93ZXN0RGVncmVlLCAwKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vXG4vLyAgICAgcmV0dXJuIHJlcztcbi8vIH1cblxuLy8gbWVyZ2UocG9scywgb3ZlcmxhcCA9IHRydWUpIHtcbi8vICAgICBsZXQgbGVuZ3RoID0gMDtcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHMubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgbGVuZ3RoICs9IHBvbHNbaV0ubGVuZ3RoKCk7XG4vLyAgICAgfVxuLy9cbi8vICAgICBpZiAob3ZlcmxhcCkge1xuLy8gICAgICAgICBsZW5ndGggLT0gcG9scy5sZW5ndGggLSAxO1xuLy8gICAgIH1cbi8vXG4vLyAgICAgbGV0IHJlcyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIobGVuZ3RoICogdGhpcy5Gci5uOCkpO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9scy5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gcG9sc1tpXS5jb2VmLmJ5dGVMZW5ndGg7XG4vLyAgICAgICAgIGlmICgwID09PSBpKSB7XG4vLyAgICAgICAgICAgICByZXMuY29lZi5zZXQocG9sc1tpXS5jb2VmLCAwKTtcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vL1xuLy8gICAgIHJldHVybiByZXM7XG4vLyB9XG5cbiAgICB0cnVuY2F0ZSgpIHtcbiAgICAgICAgY29uc3QgZGVnID0gdGhpcy5kZWdyZWUoKTtcbiAgICAgICAgaWYgKGRlZyArIDEgPCB0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvZWZzID0gKGRlZyArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigoZGVnICsgMSkgKiB0aGlzLkZyLm44KSA6IG5ldyBVaW50OEFycmF5KChkZWcgKyAxKSAqIHRoaXMuRnIubjgpO1xuXG4gICAgICAgICAgICBuZXdDb2Vmcy5zZXQodGhpcy5jb2VmLnNsaWNlKDAsIChkZWcgKyAxKSAqIHRoaXMuRnIubjgpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY29lZiA9IG5ld0NvZWZzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oeEFyciwgeUFyciwgY3VydmUpIHtcbiAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgbGV0IHBvbHlub21pYWwgPSBjb21wdXRlTGFncmFuZ2VQb2x5bm9taWFsKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHhBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvbHlub21pYWwuYWRkKGNvbXB1dGVMYWdyYW5nZVBvbHlub21pYWwoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlub21pYWw7XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUxhZ3JhbmdlUG9seW5vbWlhbChpKSB7XG4gICAgICAgICAgICBsZXQgcG9seW5vbWlhbDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB4QXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvbHlub21pYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYnVmZiA9ICh4QXJyLmxlbmd0aCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIoKHhBcnIubGVuZ3RoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KCh4QXJyLmxlbmd0aCkgKiBGci5uOCk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwgPSBuZXcgUG9seW5vbWlhbChidWZmLCBjdXJ2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwuc2V0Q29lZigwLCBGci5uZWcoeEFycltqXSkpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFsLnNldENvZWYoMSwgRnIub25lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFsLmJ5WFN1YlZhbHVlKHhBcnJbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gcG9seW5vbWlhbC5ldmFsdWF0ZSh4QXJyW2ldKTtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gRnIuaW52KGRlbm9taW5hdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG11bEZhY3RvciA9IEZyLm11bCh5QXJyW2ldLCBkZW5vbWluYXRvcik7XG5cbiAgICAgICAgICAgIHBvbHlub21pYWwubXVsU2NhbGFyKG11bEZhY3Rvcik7XG5cbiAgICAgICAgICAgIHJldHVybiBwb2x5bm9taWFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHplcm9maWVyUG9seW5vbWlhbCh4QXJyLCBjdXJ2ZSkge1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBsZXQgYnVmZiA9ICh4QXJyLmxlbmd0aCArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKCh4QXJyLmxlbmd0aCArIDEpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKHhBcnIubGVuZ3RoICsgMSkgKiBGci5uOCk7XG4gICAgICAgIGxldCBwb2x5bm9taWFsID0gbmV3IFBvbHlub21pYWwoYnVmZiwgY3VydmUpO1xuXG4gICAgICAgIC8vIEJ1aWxkIGEgemVyb2ZpZXIgcG9seW5vbWlhbCB3aXRoIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAgICAgICAgLy8gemVyb2ZpZXIoWCkgPSAoWC14QXJyWzBdKShYLXhBcnJbMV0pLi4uKFgteEFycltuXSlcbiAgICAgICAgcG9seW5vbWlhbC5zZXRDb2VmKDAsIEZyLm5lZyh4QXJyWzBdKSk7XG4gICAgICAgIHBvbHlub21pYWwuc2V0Q29lZigxLCBGci5vbmUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgeEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcG9seW5vbWlhbC5ieVhTdWJWYWx1ZSh4QXJyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIHByaW50KCkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGxldCByZXMgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5kZWdyZWUoKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZWYgPSB0aGlzLmdldENvZWYoaSk7XG4gICAgICAgICAgICBpZiAoIUZyLmVxKEZyLnplcm8sIGNvZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZyLmlzTmVnYXRpdmUoY29lZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiIC0gXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpICE9PSB0aGlzLmRlZ3JlZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIiArIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMgKz0gRnIudG9TdHJpbmcoY29lZik7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBpID4gMSA/IFwieF5cIiArIGkgOiBcInhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cocmVzKTtcbiAgICB9XG5cbiAgICBhc3luYyBtdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uODtcbiAgICAgICAgY29uc3QgUFRhdU4gPSBQVGF1LnNsaWNlKDAsIG4gKiB0aGlzLkcxLkYubjggKiAyKTtcbiAgICAgICAgY29uc3QgYm0gPSBhd2FpdCB0aGlzLkZyLmJhdGNoRnJvbU1vbnRnb21lcnkodGhpcy5jb2VmKTtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHRoaXMuRzEubXVsdGlFeHBBZmZpbmUoUFRhdU4sIGJtLCB0aGlzLmxvZ2dlciwgbmFtZSk7XG4gICAgICAgIHJlcyA9IHRoaXMuRzEudG9BZmZpbmUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/polynomial/polynomial.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau.js":
/*!*************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   beacon: () => (/* reexport safe */ _powersoftau_beacon_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   challengeContribute: () => (/* reexport safe */ _powersoftau_challenge_contribute_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   contribute: () => (/* reexport safe */ _powersoftau_contribute_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   convert: () => (/* reexport safe */ _powersoftau_convert_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   exportChallenge: () => (/* reexport safe */ _powersoftau_export_challenge_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _powersoftau_export_json_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   importResponse: () => (/* reexport safe */ _powersoftau_import_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   newAccumulator: () => (/* reexport safe */ _powersoftau_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   preparePhase2: () => (/* reexport safe */ _powersoftau_preparephase2_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   truncate: () => (/* reexport safe */ _powersoftau_truncate_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _powersoftau_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _powersoftau_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_new.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_new.js\");\n/* harmony import */ var _powersoftau_export_challenge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_export_challenge.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_export_challenge.js\");\n/* harmony import */ var _powersoftau_import_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./powersoftau_import.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_import.js\");\n/* harmony import */ var _powersoftau_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./powersoftau_verify.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_verify.js\");\n/* harmony import */ var _powersoftau_challenge_contribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./powersoftau_challenge_contribute.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_challenge_contribute.js\");\n/* harmony import */ var _powersoftau_beacon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./powersoftau_beacon.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_beacon.js\");\n/* harmony import */ var _powersoftau_contribute_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./powersoftau_contribute.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_contribute.js\");\n/* harmony import */ var _powersoftau_preparephase2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./powersoftau_preparephase2.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_preparephase2.js\");\n/* harmony import */ var _powersoftau_truncate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./powersoftau_truncate.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_truncate.js\");\n/* harmony import */ var _powersoftau_convert_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./powersoftau_convert.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_convert.js\");\n/* harmony import */ var _powersoftau_export_json_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./powersoftau_export_json.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_export_json.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRStEO0FBQ2M7QUFDWDtBQUNSO0FBQzJCO0FBQzNCO0FBQ1E7QUFDTTtBQUNWO0FBQ0Y7QUFDTyIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQge2RlZmF1bHQgYXMgbmV3QWNjdW11bGF0b3J9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X25ldy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4cG9ydENoYWxsZW5nZX0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfZXhwb3J0X2NoYWxsZW5nZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGltcG9ydFJlc3BvbnNlfSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9pbXBvcnQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB2ZXJpZnl9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X3ZlcmlmeS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNoYWxsZW5nZUNvbnRyaWJ1dGV9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X2NoYWxsZW5nZV9jb250cmlidXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYmVhY29ufSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9iZWFjb24uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjb250cmlidXRlfSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9jb250cmlidXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcHJlcGFyZVBoYXNlMn0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfcHJlcGFyZXBoYXNlMi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRydW5jYXRlfSBmcm9tIFwiLi9wb3dlcnNvZnRhdV90cnVuY2F0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNvbnZlcnR9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X2NvbnZlcnQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRKc29ufSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9leHBvcnRfanNvbi5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_beacon.js":
/*!********************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_beacon.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ beacon)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function beacon(oldPtauFilename, newPTauFilename, name,  beaconHashStr,numIterationsExp, logger) {\n    const beaconHash = _misc_js__WEBPACK_IMPORTED_MODULE_1__.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        return false;\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 1, // Beacon\n        numIterationsExp: numIterationsExp,\n        beaconHash: beaconHash\n    };\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    curContribution.key = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.keyFromBeacon(curve, lastChallengeHash, beaconHash, numIterationsExp);\n\n    const responseHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_3__.blake2b.create({ dkLen: 64 });\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\", logger );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\", logger );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\", logger );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\", logger );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\", logger );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = _misc_js__WEBPACK_IMPORTED_MODULE_1__.toPartialHash(responseHasher);\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_1__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_3__.blake2b.create({ dkLen: 64 });\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_1__.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName, logger) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`applying key${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfYmVhY29uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDQTtBQUNkO0FBQ2tCOztBQUVyQztBQUNmLHVCQUF1QixtREFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsV0FBVyxxQkFBcUIsUUFBUSw0REFBd0I7QUFDaEUsV0FBVyw2QkFBNkIsUUFBUSxpRUFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0VBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0Qiw4RUFBaUM7QUFDN0Q7O0FBRUEsZ0NBQWdDLGdFQUFtQjs7QUFFbkQsMkJBQTJCLDBEQUFPLFVBQVUsV0FBVztBQUN2RDs7QUFFQSx3QkFBd0IsOERBQTBCO0FBQ2xELFVBQVUsa0VBQXFCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxtREFBa0I7O0FBRXBEOztBQUVBLElBQUksa0VBQXFCOztBQUV6QjtBQUNBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0MsZ0NBQWdDLDBEQUFPLFVBQVUsV0FBVztBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0M7O0FBRUEsVUFBVSxxRUFBd0I7O0FBRWxDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsa0VBQThCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkMsb0RBQW9ELFlBQVksSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnRUFBNEI7O0FBRTFDO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDLGdEQUFnRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDN0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfYmVhY29uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gYmVhY29uKG9sZFB0YXVGaWxlbmFtZSwgbmV3UFRhdUZpbGVuYW1lLCBuYW1lLCAgYmVhY29uSGFzaFN0cixudW1JdGVyYXRpb25zRXhwLCBsb2dnZXIpIHtcbiAgICBjb25zdCBiZWFjb25IYXNoID0gbWlzYy5oZXgyQnl0ZUFycmF5KGJlYWNvbkhhc2hTdHIpO1xuICAgIGlmICggICAoYmVhY29uSGFzaC5ieXRlTGVuZ3RoID09IDApXG4gICAgICAgIHx8IChiZWFjb25IYXNoLmJ5dGVMZW5ndGgqMiAhPWJlYWNvbkhhc2hTdHIubGVuZ3RoKSlcbiAgICB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgQmVhY29uIEhhc2guIChJdCBtdXN0IGJlIGEgdmFsaWQgaGV4YWRlY2ltYWwgc2VxdWVuY2UpXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiZWFjb25IYXNoLmxlbmd0aD49MjU2KSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIk1heGltdW0gbGVuZ3RoIG9mIGJlYWNvbiBoYXNoIGlzIDI1NSBieXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG51bUl0ZXJhdGlvbnNFeHAgPSBwYXJzZUludChudW1JdGVyYXRpb25zRXhwKTtcbiAgICBpZiAoKG51bUl0ZXJhdGlvbnNFeHA8MTApfHwobnVtSXRlcmF0aW9uc0V4cD42MykpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1JdGVyYXRpb25zRXhwLiAoTXVzdCBiZSBiZXR3ZWVuIDEwIGFuZCA2MylcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShvbGRQdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyLCBjZXJlbW9ueVBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG4gICAgaWYgKHBvd2VyICE9IGNlcmVtb255UG93ZXIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiVGhpcyBmaWxlIGhhcyBiZWVuIHJlZHVjZWQuIFlvdSBjYW5ub3QgY29udHJpYnV0ZSBpbnRvIGEgcmVkdWNlZCBmaWxlLlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc2VjdGlvbnNbMTJdKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci53YXJuKFwiQ29udHJpYnV0aW5nIGludG8gYSBmaWxlIHRoYXQgaGFzIHBoYXNlMiBjYWxjdWxhdGVkLiBZb3Ugd2lsbCBoYXZlIHRvIHByZXBhcmUgcGhhc2UyIGFnYWluLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY29udHJpYnV0aW9ucyA9IGF3YWl0IHV0aWxzLnJlYWRDb250cmlidXRpb25zKGZkT2xkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuICAgIGNvbnN0IGN1ckNvbnRyaWJ1dGlvbiA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogMSwgLy8gQmVhY29uXG4gICAgICAgIG51bUl0ZXJhdGlvbnNFeHA6IG51bUl0ZXJhdGlvbnNFeHAsXG4gICAgICAgIGJlYWNvbkhhc2g6IGJlYWNvbkhhc2hcbiAgICB9O1xuXG4gICAgbGV0IGxhc3RDaGFsbGVuZ2VIYXNoO1xuXG4gICAgaWYgKGNvbnRyaWJ1dGlvbnMubGVuZ3RoPjApIHtcbiAgICAgICAgbGFzdENoYWxsZW5nZUhhc2ggPSBjb250cmlidXRpb25zW2NvbnRyaWJ1dGlvbnMubGVuZ3RoLTFdLm5leHRDaGFsbGVuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdENoYWxsZW5nZUhhc2ggPSB1dGlscy5jYWxjdWxhdGVGaXJzdENoYWxsZW5nZUhhc2goY3VydmUsIHBvd2VyLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5rZXkgPSBhd2FpdCB1dGlscy5rZXlGcm9tQmVhY29uKGN1cnZlLCBsYXN0Q2hhbGxlbmdlSGFzaCwgYmVhY29uSGFzaCwgbnVtSXRlcmF0aW9uc0V4cCk7XG5cbiAgICBjb25zdCByZXNwb25zZUhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShsYXN0Q2hhbGxlbmdlSGFzaCk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDcpO1xuICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGNvbnN0IHN0YXJ0U2VjdGlvbnMgPSBbXTtcblxuICAgIGxldCBmaXJzdFBvaW50cztcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDIsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAqIDIgLTEsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24udGF1RzEgPSBmaXJzdFBvaW50c1sxXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIFwiRzJcIiwgICgyICoqIHBvd2VyKSAsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMlwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24udGF1RzIgPSBmaXJzdFBvaW50c1sxXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDQsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAsIGN1ckNvbnRyaWJ1dGlvbi5rZXkuYWxwaGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYWxwaGFHMSA9IGZpcnN0UG9pbnRzWzBdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNSwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICwgY3VyQ29udHJpYnV0aW9uLmtleS5iZXRhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImJldGFUYXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYmV0YUcxID0gZmlyc3RQb2ludHNbMF07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig2LCBcIkcyXCIsICAxLCBjdXJDb250cmlidXRpb24ua2V5LmJldGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYmV0YVRhdUcyXCIsIGxvZ2dlciApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5iZXRhRzIgPSBmaXJzdFBvaW50c1swXTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5wYXJ0aWFsSGFzaCA9IG1pc2MudG9QYXJ0aWFsSGFzaChyZXNwb25zZUhhc2hlcik7XG5cbiAgICBjb25zdCBidWZmS2V5ID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMio2K2N1cnZlLkYyLm44KjIqMyk7XG5cbiAgICB1dGlscy50b1B0YXVQdWJLZXlScHIoYnVmZktleSwgMCwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5rZXksIGZhbHNlKTtcblxuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShuZXcgVWludDhBcnJheShidWZmS2V5KSk7XG4gICAgY29uc3QgaGFzaFJlc3BvbnNlID0gcmVzcG9uc2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goaGFzaFJlc3BvbnNlLCBcIkNvbnRyaWJ1dGlvbiBSZXNwb25zZSBIYXNoIGltcG9ydGVkOiBcIikpO1xuXG4gICAgY29uc3QgbmV4dENoYWxsZW5nZUhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGhhc2hSZXNwb25zZSk7XG5cbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgXCJ0YXVHMlwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDQsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgXCJiZXRhRzJcIiwgbG9nZ2VyKTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbmV4dENoYWxsZW5nZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjdXJDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSwgXCJOZXh0IENoYWxsZW5nZSBIYXNoOiBcIikpO1xuXG4gICAgY29udHJpYnV0aW9ucy5wdXNoKGN1ckNvbnRyaWJ1dGlvbik7XG5cbiAgICBhd2FpdCB1dGlscy53cml0ZUNvbnRyaWJ1dGlvbnMoZmROZXcsIGN1cnZlLCBjb250cmlidXRpb25zKTtcblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcblxuICAgIHJldHVybiBoYXNoUmVzcG9uc2U7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihzZWN0aW9uSWQsIGdyb3VwTmFtZSwgTlBvaW50cywgZmlyc3QsIGluYywgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZmRPbGQucG9zID0gc2VjdGlvbnNbc2VjdGlvbklkXVswXS5wO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgc2VjdGlvbklkKTtcblxuICAgICAgICBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF0gPSBmZE5ldy5wb3M7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGguZmxvb3IoKDE8PDIwKSAvIHNHKTsgICAvLyAxMjhNYiBjaHVua3NcbiAgICAgICAgbGV0IHQgPSBmaXJzdDtcbiAgICAgICAgZm9yIChsZXQgaT0wIDsgaTxOUG9pbnRzIDsgaSs9IGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBhcHBseWluZyBrZXkke3NlY3Rpb25OYW1lfTogJHtpfS8ke05Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuPSBNYXRoLm1pbihOUG9pbnRzLWksIGNodW5rU2l6ZSApO1xuICAgICAgICAgICAgY29uc3QgYnVmZkluID0gYXdhaXQgZmRPbGQucmVhZChuICogc0cpO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dExFTSA9IGF3YWl0IEcuYmF0Y2hBcHBseUtleShidWZmSW4sIHQsIGluYyk7XG5cbiAgICAgICAgICAgIC8qIENvZGUgdG8gdGVzdCB0aGUgY2FzZSB3aGVyZSB3ZSBkb24ndCBoYXZlIHRoZSAyXm0tMiBjb21wb25lbnRcbiAgICAgICAgICAgIGlmIChzZWN0aW9uTmFtZT09IFwidGF1RzFcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ6ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXRMRU0uc2V0KGJ6LCA2NCooKDIgKiogcG93ZXIpIC0gMSApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VXcml0ZSA9IGZkTmV3LndyaXRlKGJ1ZmZPdXRMRU0pO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dEMgPSBhd2FpdCBHLmJhdGNoTEVNdG9DKGJ1ZmZPdXRMRU0pO1xuXG4gICAgICAgICAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZk91dEMpO1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZVdyaXRlO1xuICAgICAgICAgICAgaWYgKGk9PTApICAgLy8gUmV0dXJuIHRoZSAyIGZpcnN0IHBvaW50cy5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8TWF0aC5taW4oMiwgTlBvaW50cyk7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goRy5mcm9tUnByTEVNKGJ1ZmZPdXRMRU0sIGoqc0cpKTtcbiAgICAgICAgICAgIHQgPSBjdXJ2ZS5Gci5tdWwodCwgY3VydmUuRnIuZXhwKGluYywgbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZE5ldyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhc2hTZWN0aW9uKGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zRyk7XG5cbiAgICAgICAgY29uc3Qgb2xkUG9zID0gZmRUby5wb3M7XG4gICAgICAgIGZkVG8ucG9zID0gc3RhcnRTZWN0aW9uc1tzZWN0aW9uSWRdO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSGFzaGluZyAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cy1pLCBuUG9pbnRzQ2h1bmspO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmTEVNID0gYXdhaXQgZmRUby5yZWFkKG4gKiBzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZVID0gYXdhaXQgRy5iYXRjaExFTXRvVShidWZmTEVNKTtcblxuICAgICAgICAgICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoYnVmZlUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmRUby5wb3MgPSBvbGRQb3M7XG4gICAgfVxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_beacon.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_challenge_contribute.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_challenge_contribute.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ challengeContribute)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(rsc)/./node_modules/snarkjs/src/mpc_applykey.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/./node_modules/snarkjs/src/keypair.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\n\n\n\n\n\n\n\nasync function challengeContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    const fdFrom = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(challengeFilename);\n\n\n    const sG1 = curve.F1.n64*8*2;\n    const sG2 = curve.F2.n64*8*2;\n    const domainSize = (fdFrom.totalSize + sG1 - 64 - sG2) / (4*sG1 + sG2);\n    let e = domainSize;\n    let power = 0;\n    while (e>1) {\n        e = e /2;\n        power += 1;\n    }\n\n    if (2 ** power != domainSize) throw new Error(\"Invalid file size\");\n    if (logger) logger.debug(\"Power to tau size: \"+power);\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_2__.getRandomRng(entropy);\n\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(responseFileName);\n\n    // Calculate the hash\n    const challengeHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 });\n    for (let i=0; i<fdFrom.totalSize; i+= fdFrom.pageSize) {\n        if (logger) logger.debug(`Hashing challenge ${i}/${fdFrom.totalSize}`);\n        const s = Math.min(fdFrom.totalSize - i, fdFrom.pageSize);\n        const buff = await fdFrom.read(s);\n        challengeHasher.update(buff);\n    }\n\n    const claimedHash = await fdFrom.read(64, 0);\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(claimedHash, \"Claimed Previous Response Hash: \"));\n\n    const challengeHash = challengeHasher.digest();\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(challengeHash, \"Current Challenge Hash: \"));\n\n    const key = _keypair_js__WEBPACK_IMPORTED_MODULE_4__.createPTauKey(curve, challengeHash, rng);\n\n    if (logger) {\n        [\"tau\", \"alpha\", \"beta\"].forEach( (k) => {\n            logger.debug(k + \".g1_s: \" + curve.G1.toString(key[k].g1_s, 16));\n            logger.debug(k + \".g1_sx: \" + curve.G1.toString(key[k].g1_sx, 16));\n            logger.debug(k + \".g2_sp: \" + curve.G2.toString(key[k].g2_sp, 16));\n            logger.debug(k + \".g2_spx: \" + curve.G2.toString(key[k].g2_spx, 16));\n            logger.debug(\"\");\n        });\n    }\n\n    const responseHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 });\n\n    await fdTo.write(challengeHash);\n    responseHasher.update(challengeHash);\n\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)*2-1, curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG1\"     , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G2\", (2 ** power)    , curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG2\"     , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.alpha.prvKey, key.tau.prvKey, \"COMPRESSED\", \"alphaTauG1\", logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG1\" , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G2\", 1             , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG2\" , logger );\n\n    // Write and hash key\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.toPtauPubKeyRpr(buffKey, 0, curve, key, false);\n    await fdTo.write(buffKey);\n    responseHasher.update(buffKey);\n    const responseHash = responseHasher.digest();\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(responseHash, \"Contribution Response Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfY2hhbGxlbmdlX2NvbnRyaWJ1dGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDVztBQUNBO0FBQ2Q7QUFDNkI7QUFDdkI7O0FBRXpCO0FBQ2YseUJBQXlCLGtEQUFxQjs7O0FBRzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixrREFBaUI7O0FBRXZDLHVCQUF1QixvREFBdUI7O0FBRTlDO0FBQ0EsNEJBQTRCLDBEQUFPLFVBQVUsV0FBVztBQUN4RCxrQkFBa0Isb0JBQW9CO0FBQ3RDLHNEQUFzRCxFQUFFLEdBQUcsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBLDRCQUE0QixnREFBZTs7QUFFM0MsZ0JBQWdCLHNEQUFxQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsMkJBQTJCLDBEQUFPLFVBQVUsV0FBVzs7QUFFdkQ7QUFDQTs7QUFFQSxVQUFVLDRFQUEwQjtBQUNwQyxVQUFVLDRFQUEwQjtBQUNwQyxVQUFVLDRFQUEwQjtBQUNwQyxVQUFVLDRFQUEwQjtBQUNwQyxVQUFVLDRFQUEwQjs7QUFFcEM7QUFDQTtBQUNBLElBQUksa0VBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBZTs7QUFFM0M7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2NoYWxsZW5nZV9jb250cmlidXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIEZvcm1hdCBvZiB0aGUgb3V0cHV0XG4vLyAgICAgIEhhc2ggb2YgdGhlIGxhc3QgY29udHJpYnV0aW9uICA2NCBCeXRlc1xuLy8gICAgICAyXk4qMi0xIFRhdUcxIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgMl5OIFRhdUcyIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgMl5OIEFscGhhVGF1RzEgUG9pbnRzIChjb21wcmVzc2VkKVxuLy8gICAgICAyXk4gQmV0YVRhdUcxIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgUHVibGljIEtleVxuLy8gICAgICAgICAgQmV0YUcyIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqcyAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnMqdGF1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdCAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnQqYWxwaGEgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSp1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdSpiZXRhIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzIqc3AqdGF1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzIqdHAqYWxwaGEgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMip1cCpiZXRhIChjb21wcmVzc2VkKVxuXG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbiB9IGZyb20gXCIuL21wY19hcHBseWtleS5qc1wiO1xuaW1wb3J0ICogYXMga2V5UGFpciBmcm9tIFwiLi9rZXlwYWlyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGNoYWxsZW5nZUNvbnRyaWJ1dGUoY3VydmUsIGNoYWxsZW5nZUZpbGVuYW1lLCByZXNwb25zZUZpbGVOYW1lLCBlbnRyb3B5LCBsb2dnZXIpIHtcbiAgICBjb25zdCBmZEZyb20gPSBhd2FpdCBmYXN0RmlsZS5yZWFkRXhpc3RpbmcoY2hhbGxlbmdlRmlsZW5hbWUpO1xuXG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5GMS5uNjQqOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkYyLm42NCo4KjI7XG4gICAgY29uc3QgZG9tYWluU2l6ZSA9IChmZEZyb20udG90YWxTaXplICsgc0cxIC0gNjQgLSBzRzIpIC8gKDQqc0cxICsgc0cyKTtcbiAgICBsZXQgZSA9IGRvbWFpblNpemU7XG4gICAgbGV0IHBvd2VyID0gMDtcbiAgICB3aGlsZSAoZT4xKSB7XG4gICAgICAgIGUgPSBlIC8yO1xuICAgICAgICBwb3dlciArPSAxO1xuICAgIH1cblxuICAgIGlmICgyICoqIHBvd2VyICE9IGRvbWFpblNpemUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZmlsZSBzaXplXCIpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlBvd2VyIHRvIHRhdSBzaXplOiBcIitwb3dlcik7XG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBtaXNjLmdldFJhbmRvbVJuZyhlbnRyb3B5KTtcblxuICAgIGNvbnN0IGZkVG8gPSBhd2FpdCBmYXN0RmlsZS5jcmVhdGVPdmVycmlkZShyZXNwb25zZUZpbGVOYW1lKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgaGFzaFxuICAgIGNvbnN0IGNoYWxsZW5nZUhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIGZvciAobGV0IGk9MDsgaTxmZEZyb20udG90YWxTaXplOyBpKz0gZmRGcm9tLnBhZ2VTaXplKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSGFzaGluZyBjaGFsbGVuZ2UgJHtpfS8ke2ZkRnJvbS50b3RhbFNpemV9YCk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLm1pbihmZEZyb20udG90YWxTaXplIC0gaSwgZmRGcm9tLnBhZ2VTaXplKTtcbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkRnJvbS5yZWFkKHMpO1xuICAgICAgICBjaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGNvbnN0IGNsYWltZWRIYXNoID0gYXdhaXQgZmRGcm9tLnJlYWQoNjQsIDApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjbGFpbWVkSGFzaCwgXCJDbGFpbWVkIFByZXZpb3VzIFJlc3BvbnNlIEhhc2g6IFwiKSk7XG5cbiAgICBjb25zdCBjaGFsbGVuZ2VIYXNoID0gY2hhbGxlbmdlSGFzaGVyLmRpZ2VzdCgpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjaGFsbGVuZ2VIYXNoLCBcIkN1cnJlbnQgQ2hhbGxlbmdlIEhhc2g6IFwiKSk7XG5cbiAgICBjb25zdCBrZXkgPSBrZXlQYWlyLmNyZWF0ZVBUYXVLZXkoY3VydmUsIGNoYWxsZW5nZUhhc2gsIHJuZyk7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIFtcInRhdVwiLCBcImFscGhhXCIsIFwiYmV0YVwiXS5mb3JFYWNoKCAoaykgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGsgKyBcIi5nMV9zOiBcIiArIGN1cnZlLkcxLnRvU3RyaW5nKGtleVtrXS5nMV9zLCAxNikpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGsgKyBcIi5nMV9zeDogXCIgKyBjdXJ2ZS5HMS50b1N0cmluZyhrZXlba10uZzFfc3gsIDE2KSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoayArIFwiLmcyX3NwOiBcIiArIGN1cnZlLkcyLnRvU3RyaW5nKGtleVtrXS5nMl9zcCwgMTYpKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhrICsgXCIuZzJfc3B4OiBcIiArIGN1cnZlLkcyLnRvU3RyaW5nKGtleVtrXS5nMl9zcHgsIDE2KSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJcIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG5cbiAgICBhd2FpdCBmZFRvLndyaXRlKGNoYWxsZW5nZUhhc2gpO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShjaGFsbGVuZ2VIYXNoKTtcblxuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcxXCIsICgyICoqIHBvd2VyKSoyLTEsIGN1cnZlLkZyLm9uZSAgICAsIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJ0YXVHMVwiICAgICAsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcyXCIsICgyICoqIHBvd2VyKSAgICAsIGN1cnZlLkZyLm9uZSAgICAsIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJ0YXVHMlwiICAgICAsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcxXCIsICgyICoqIHBvd2VyKSAgICAsIGtleS5hbHBoYS5wcnZLZXksIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJhbHBoYVRhdUcxXCIsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcxXCIsICgyICoqIHBvd2VyKSAgICAsIGtleS5iZXRhLnBydktleSAsIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJiZXRhVGF1RzFcIiAsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcyXCIsIDEgICAgICAgICAgICAgLCBrZXkuYmV0YS5wcnZLZXkgLCBrZXkudGF1LnBydktleSwgXCJDT01QUkVTU0VEXCIsIFwiYmV0YVRhdUcyXCIgLCBsb2dnZXIgKTtcblxuICAgIC8vIFdyaXRlIGFuZCBoYXNoIGtleVxuICAgIGNvbnN0IGJ1ZmZLZXkgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCoyKjYrY3VydmUuRjIubjgqMiozKTtcbiAgICB1dGlscy50b1B0YXVQdWJLZXlScHIoYnVmZktleSwgMCwgY3VydmUsIGtleSwgZmFsc2UpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZktleSk7XG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGJ1ZmZLZXkpO1xuICAgIGNvbnN0IHJlc3BvbnNlSGFzaCA9IHJlc3BvbnNlSGFzaGVyLmRpZ2VzdCgpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChyZXNwb25zZUhhc2gsIFwiQ29udHJpYnV0aW9uIFJlc3BvbnNlIEhhc2g6IFwiKSk7XG5cbiAgICBhd2FpdCBmZFRvLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRGcm9tLmNsb3NlKCk7XG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_challenge_contribute.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_contribute.js":
/*!************************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_contribute.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ contribute)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (uncompressed)\n//      2^N TauG2 Points (uncompressed)\n//      2^N AlphaTauG1 Points (uncompressed)\n//      2^N BetaTauG1 Points (uncompressed)\n\n\n\n\n\n\n\nasync function contribute(oldPtauFilename, newPTauFilename, name, entropy, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        throw new Error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 0, // Beacon\n    };\n\n    let lastChallengeHash;\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomRng(entropy);\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    // Generate a random key\n\n\n    curContribution.key = _keypair_js__WEBPACK_IMPORTED_MODULE_1__.createPTauKey(curve, lastChallengeHash, rng);\n\n\n    const responseHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\" );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\" );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\" );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\" );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\" );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = _misc_js__WEBPACK_IMPORTED_MODULE_3__.toPartialHash(responseHasher);\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\");\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\");\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\");\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\");\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\");\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`processing: ${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if ((logger)&&i) logger.debug(`Hashing ${sectionName}: ` + i);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfY29udHJpYnV0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDQTtBQUNSO0FBQ1k7QUFDbEI7O0FBRW5COztBQUVmLFdBQVcscUJBQXFCLFFBQVEsNERBQXdCO0FBQ2hFLFdBQVcsNkJBQTZCLFFBQVEsaUVBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9FQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0Isa0RBQWlCOztBQUV2QztBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0Qiw4RUFBaUM7QUFDN0Q7O0FBRUE7OztBQUdBLDBCQUEwQixzREFBcUI7OztBQUcvQywyQkFBMkIsMERBQU8sVUFBVSxXQUFXO0FBQ3ZEOztBQUVBLHdCQUF3Qiw4REFBMEI7QUFDbEQsVUFBVSxrRUFBcUI7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLG1EQUFrQjs7QUFFcEQ7O0FBRUEsSUFBSSxrRUFBcUI7O0FBRXpCO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQyxnQ0FBZ0MsMERBQU8sVUFBVSxXQUFXO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQzs7QUFFQSxVQUFVLHFFQUF3Qjs7QUFFbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxrRUFBOEI7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQyxvREFBb0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdFQUE0Qjs7QUFFMUM7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEMscURBQXFELFlBQVk7QUFDakU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9jb250cmlidXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIEZvcm1hdCBvZiB0aGUgb3V0cHV0XG4vLyAgICAgIEhhc2ggb2YgdGhlIGxhc3QgY29udHJpYnV0aW9uICA2NCBCeXRlc1xuLy8gICAgICAyXk4qMi0xIFRhdUcxIFBvaW50cyAodW5jb21wcmVzc2VkKVxuLy8gICAgICAyXk4gVGF1RzIgUG9pbnRzICh1bmNvbXByZXNzZWQpXG4vLyAgICAgIDJeTiBBbHBoYVRhdUcxIFBvaW50cyAodW5jb21wcmVzc2VkKVxuLy8gICAgICAyXk4gQmV0YVRhdUcxIFBvaW50cyAodW5jb21wcmVzc2VkKVxuXG5pbXBvcnQgeyBibGFrZTJiIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvYmxha2UyYlwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGtleVBhaXIgZnJvbSBcIi4va2V5cGFpci5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY29udHJpYnV0ZShvbGRQdGF1RmlsZW5hbWUsIG5ld1BUYXVGaWxlbmFtZSwgbmFtZSwgZW50cm9weSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUob2xkUHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlciwgY2VyZW1vbnlQb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuICAgIGlmIChwb3dlciAhPSBjZXJlbW9ueVBvd2VyKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlRoaXMgZmlsZSBoYXMgYmVlbiByZWR1Y2VkLiBZb3UgY2Fubm90IGNvbnRyaWJ1dGUgaW50byBhIHJlZHVjZWQgZmlsZS5cIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZmlsZSBoYXMgYmVlbiByZWR1Y2VkLiBZb3UgY2Fubm90IGNvbnRyaWJ1dGUgaW50byBhIHJlZHVjZWQgZmlsZS5cIik7XG4gICAgfVxuICAgIGlmIChzZWN0aW9uc1sxMl0pIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLndhcm4oXCJXQVJOSU5HOiBDb250cmlidXRpbmcgaW50byBhIGZpbGUgdGhhdCBoYXMgcGhhc2UyIGNhbGN1bGF0ZWQuIFlvdSB3aWxsIGhhdmUgdG8gcHJlcGFyZSBwaGFzZTIgYWdhaW4uXCIpO1xuICAgIH1cbiAgICBjb25zdCBjb250cmlidXRpb25zID0gYXdhaXQgdXRpbHMucmVhZENvbnRyaWJ1dGlvbnMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiAwLCAvLyBCZWFjb25cbiAgICB9O1xuXG4gICAgbGV0IGxhc3RDaGFsbGVuZ2VIYXNoO1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5nZXRSYW5kb21SbmcoZW50cm9weSk7XG5cbiAgICBpZiAoY29udHJpYnV0aW9ucy5sZW5ndGg+MCkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IHV0aWxzLmNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgYSByYW5kb20ga2V5XG5cblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5rZXkgPSBrZXlQYWlyLmNyZWF0ZVBUYXVLZXkoY3VydmUsIGxhc3RDaGFsbGVuZ2VIYXNoLCBybmcpO1xuXG5cbiAgICBjb25zdCByZXNwb25zZUhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShsYXN0Q2hhbGxlbmdlSGFzaCk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDcpO1xuICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGNvbnN0IHN0YXJ0U2VjdGlvbnMgPSBbXTtcblxuICAgIGxldCBmaXJzdFBvaW50cztcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDIsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAqIDIgLTEsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMVwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLnRhdUcxID0gZmlyc3RQb2ludHNbMV07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbigzLCBcIkcyXCIsICAoMiAqKiBwb3dlcikgLCBjdXJ2ZS5Gci5lKDEpLCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwidGF1RzJcIiApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50YXVHMiA9IGZpcnN0UG9pbnRzWzFdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNCwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICwgY3VyQ29udHJpYnV0aW9uLmtleS5hbHBoYS5wcnZLZXksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJhbHBoYVRhdUcxXCIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYWxwaGFHMSA9IGZpcnN0UG9pbnRzWzBdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNSwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICwgY3VyQ29udHJpYnV0aW9uLmtleS5iZXRhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImJldGFUYXVHMVwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmJldGFHMSA9IGZpcnN0UG9pbnRzWzBdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNiwgXCJHMlwiLCAgMSwgY3VyQ29udHJpYnV0aW9uLmtleS5iZXRhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImJldGFUYXVHMlwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmJldGFHMiA9IGZpcnN0UG9pbnRzWzBdO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLnBhcnRpYWxIYXNoID0gbWlzYy50b1BhcnRpYWxIYXNoKHJlc3BvbnNlSGFzaGVyKTtcblxuICAgIGNvbnN0IGJ1ZmZLZXkgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCoyKjYrY3VydmUuRjIubjgqMiozKTtcblxuICAgIHV0aWxzLnRvUHRhdVB1YktleVJwcihidWZmS2V5LCAwLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmtleSwgZmFsc2UpO1xuXG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZLZXkpKTtcbiAgICBjb25zdCBoYXNoUmVzcG9uc2UgPSByZXNwb25zZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChoYXNoUmVzcG9uc2UsIFwiQ29udHJpYnV0aW9uIFJlc3BvbnNlIEhhc2ggaW1wb3J0ZWQ6IFwiKSk7XG5cbiAgICBjb25zdCBuZXh0Q2hhbGxlbmdlSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoaGFzaFJlc3BvbnNlKTtcblxuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDIsICgyICoqIHBvd2VyKSAqIDIgLTEsIFwidGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgXCJ0YXVHMlwiKTtcbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCA0LCAoMiAqKiBwb3dlcikgICAgICAgLCBcImFscGhhVGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzFcIiwgNSwgKDIgKiogcG93ZXIpICAgICAgICwgXCJiZXRhVGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgXCJiZXRhRzJcIik7XG5cbiAgICBjdXJDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSA9IG5leHRDaGFsbGVuZ2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY3VyQ29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuICAgIGNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgdXRpbHMud3JpdGVDb250cmlidXRpb25zKGZkTmV3LCBjdXJ2ZSwgY29udHJpYnV0aW9ucyk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICByZXR1cm4gaGFzaFJlc3BvbnNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIE5Qb2ludHMsIGZpcnN0LCBpbmMsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmZE9sZC5wb3MgPSBzZWN0aW9uc1tzZWN0aW9uSWRdWzBdLnA7XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkTmV3LCBzZWN0aW9uSWQpO1xuXG4gICAgICAgIHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXSA9IGZkTmV3LnBvcztcblxuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5mbG9vcigoMTw8MjApIC8gc0cpOyAgIC8vIDEyOE1iIGNodW5rc1xuICAgICAgICBsZXQgdCA9IGZpcnN0O1xuICAgICAgICBmb3IgKGxldCBpPTAgOyBpPE5Qb2ludHMgOyBpKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHByb2Nlc3Npbmc6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7TlBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG49IE1hdGgubWluKE5Qb2ludHMtaSwgY2h1bmtTaXplICk7XG4gICAgICAgICAgICBjb25zdCBidWZmSW4gPSBhd2FpdCBmZE9sZC5yZWFkKG4gKiBzRyk7XG4gICAgICAgICAgICBjb25zdCBidWZmT3V0TEVNID0gYXdhaXQgRy5iYXRjaEFwcGx5S2V5KGJ1ZmZJbiwgdCwgaW5jKTtcblxuICAgICAgICAgICAgLyogQ29kZSB0byB0ZXN0IHRoZSBjYXNlIHdoZXJlIHdlIGRvbid0IGhhdmUgdGhlIDJebS0yIGNvbXBvbmVudFxuICAgICAgICAgICAgaWYgKHNlY3Rpb25OYW1lPT0gXCJ0YXVHMVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnogPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgICAgICAgICAgICAgYnVmZk91dExFTS5zZXQoYnosIDY0KigoMiAqKiBwb3dlcikgLSAxICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZVdyaXRlID0gZmROZXcud3JpdGUoYnVmZk91dExFTSk7XG4gICAgICAgICAgICBjb25zdCBidWZmT3V0QyA9IGF3YWl0IEcuYmF0Y2hMRU10b0MoYnVmZk91dExFTSk7XG5cbiAgICAgICAgICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmT3V0Qyk7XG4gICAgICAgICAgICBhd2FpdCBwcm9taXNlV3JpdGU7XG4gICAgICAgICAgICBpZiAoaT09MCkgICAvLyBSZXR1cm4gdGhlIDIgZmlyc3QgcG9pbnRzLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxNYXRoLm1pbigyLCBOUG9pbnRzKTsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChHLmZyb21ScHJMRU0oYnVmZk91dExFTSwgaipzRykpO1xuICAgICAgICAgICAgdCA9IGN1cnZlLkZyLm11bCh0LCBjdXJ2ZS5Gci5leHAoaW5jLCBuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFzaFNlY3Rpb24oZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNlY3Rpb25OYW1lKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zRyk7XG5cbiAgICAgICAgY29uc3Qgb2xkUG9zID0gZmRUby5wb3M7XG4gICAgICAgIGZkVG8ucG9zID0gc3RhcnRTZWN0aW9uc1tzZWN0aW9uSWRdO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmaSkgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nICR7c2VjdGlvbk5hbWV9OiBgICsgaSk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cy1pLCBuUG9pbnRzQ2h1bmspO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmTEVNID0gYXdhaXQgZmRUby5yZWFkKG4gKiBzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZVID0gYXdhaXQgRy5iYXRjaExFTXRvVShidWZmTEVNKTtcblxuICAgICAgICAgICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoYnVmZlUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmRUby5wb3MgPSBvbGRQb3M7XG4gICAgfVxuXG5cbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_contribute.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_convert.js":
/*!*********************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_convert.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ convert)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(rsc)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function convert(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    // const fdTmp = await fastFile.createOverride(newPTauFilename+ \".tmp\");\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 13);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 14);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 15);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, newSectionId);\n\n        const size = sections[newSectionId][0].size;\n        const chunkSize = fdOld.pageSize;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, newSectionId);\n        for (let p=0; p<size; p+=chunkSize) {\n            const l = Math.min(size -p, chunkSize);\n            const buff = await fdOld.read(l);\n            await fdNew.write(buff);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld);\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const sGin = G.F.n8*2;\n\n            let buff;\n            buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(nPoints*sGin);\n\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld, true);\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    if (i%10000) logger.debug(`sectionName prepare L calc: ${sectionName}, ${i}/${smallM}`);\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t1\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n\n\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfY29udmVydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ0o7QUFDWDtBQUNFOztBQUV4Qjs7QUFFZixXQUFXLHFCQUFxQixRQUFRLDREQUF3QjtBQUNoRSxXQUFXLGNBQWMsUUFBUSxpRUFBb0I7O0FBRXJELHdCQUF3Qiw4REFBMEI7QUFDbEQsVUFBVSxrRUFBcUI7O0FBRS9COztBQUVBLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCOztBQUVsQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxrRUFBOEI7O0FBRTVDO0FBQ0E7QUFDQSxjQUFjLHVFQUFtQztBQUNqRCxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQTJCOztBQUV6QztBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnRUFBNEI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1EQUFTOztBQUVoQyxrQkFBa0IsdUVBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDLDZFQUE2RSxZQUFZLElBQUksRUFBRSxHQUFHLE9BQU87QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9jb252ZXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuaW1wb3J0IHtCaWdCdWZmZXJ9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY29udmVydChvbGRQdGF1RmlsZW5hbWUsIG5ld1BUYXVGaWxlbmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUob2xkUHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZShuZXdQVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxLCAxMSk7XG4gICAgYXdhaXQgdXRpbHMud3JpdGVQVGF1SGVhZGVyKGZkTmV3LCBjdXJ2ZSwgcG93ZXIpO1xuXG4gICAgLy8gY29uc3QgZmRUbXAgPSBhd2FpdCBmYXN0RmlsZS5jcmVhdGVPdmVycmlkZShuZXdQVGF1RmlsZW5hbWUrIFwiLnRtcFwiKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMyk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDQpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNik7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDcpO1xuXG4gICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgMTIsIFwiRzFcIiwgXCJ0YXVHMVwiICk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDEzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTQpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxNSk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICAvLyBhd2FpdCBmcy5wcm9taXNlcy51bmxpbmsobmV3UFRhdUZpbGVuYW1lKyBcIi50bXBcIik7XG5cbiAgICByZXR1cm47XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihvbGRTZWN0aW9uSWQsIG5ld1NlY3Rpb25JZCwgR3N0ciwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiU3RhcnRpbmcgc2VjdGlvbjogXCIrc2VjdGlvbk5hbWUpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgbmV3U2VjdGlvbklkKTtcblxuICAgICAgICBjb25zdCBzaXplID0gc2VjdGlvbnNbbmV3U2VjdGlvbklkXVswXS5zaXplO1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBmZE9sZC5wYWdlU2l6ZTtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBuZXdTZWN0aW9uSWQpO1xuICAgICAgICBmb3IgKGxldCBwPTA7IHA8c2l6ZTsgcCs9Y2h1bmtTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gTWF0aC5taW4oc2l6ZSAtcCwgY2h1bmtTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZE9sZC5yZWFkKGwpO1xuICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkT2xkKTtcblxuICAgICAgICBpZiAob2xkU2VjdGlvbklkID09IDIpIHtcbiAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uUG93ZXIocG93ZXIrMSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvblBvd2VyKHApIHtcbiAgICAgICAgICAgIGNvbnN0IG5Qb2ludHMgPSAyICoqIHA7XG4gICAgICAgICAgICBjb25zdCBHID0gY3VydmVbR3N0cl07XG4gICAgICAgICAgICBjb25zdCBzR2luID0gRy5GLm44KjI7XG5cbiAgICAgICAgICAgIGxldCBidWZmO1xuICAgICAgICAgICAgYnVmZiA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzR2luKTtcblxuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBvbGRTZWN0aW9uSWQpO1xuICAgICAgICAgICAgaWYgKChvbGRTZWN0aW9uSWQgPT0gMikmJihwPT1wb3dlcisxKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkT2xkLnJlYWRUb0J1ZmZlcihidWZmLCAwLChuUG9pbnRzLTEpKnNHaW4gKTtcbiAgICAgICAgICAgICAgICBidWZmLnNldChjdXJ2ZS5HMS56ZXJvQWZmaW5lLCAoblBvaW50cy0xKSpzR2luICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkT2xkLnJlYWRUb0J1ZmZlcihidWZmLCAwLG5Qb2ludHMqc0dpbiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkT2xkLCB0cnVlKTtcblxuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcubGFncmFuZ2VFdmFsdWF0aW9ucyhidWZmLCBcImFmZmluZVwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuXG4vKlxuICAgICAgICAgICAgaWYgKHAgPD0gY3VydmUuRnIucykge1xuICAgICAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmlmZnQoYnVmZiwgXCJhZmZpbmVcIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAgPT0gY3VydmUuRnIucysxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc21hbGxNID0gMTw8Y3VydmUuRnIucztcbiAgICAgICAgICAgICAgICBsZXQgdDAgPSBuZXcgQmlnQnVmZmVyKCBzbWFsbE0gKiBzR21pZCApO1xuICAgICAgICAgICAgICAgIGxldCB0MSA9IG5ldyBCaWdCdWZmZXIoIHNtYWxsTSAqIHNHbWlkICk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaGlmdF90b19zbWFsbF9tID0gRnIuZXhwKEZyLnNoaWZ0LCBzbWFsbE0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uZV9vdmVyX2Rlbm9tID0gRnIuaW52KEZyLnN1YihzaGlmdF90b19zbWFsbF9tLCBGci5vbmUpKTtcblxuICAgICAgICAgICAgICAgIGxldCBzSW52QWNjID0gRnIub25lO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxzbWFsbE07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSUxMDAwMCkgbG9nZ2VyLmRlYnVnKGBzZWN0aW9uTmFtZSBwcmVwYXJlIEwgY2FsYzogJHtzZWN0aW9uTmFtZX0sICR7aX0vJHtzbWFsbE19YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpID0gIGJ1ZmYuc2xpY2UoaSpzR2luLCAoaSsxKSpzR2luKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1pID0gYnVmZi5zbGljZSgoaStzbWFsbE0pKnNHaW4sIChpK3NtYWxsTSsxKSpzR2luKTtcblxuICAgICAgICAgICAgICAgICAgICB0MC5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRy5zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcudGltZXNGcih0aSAsIHNoaWZ0X3RvX3NtYWxsX20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bWlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZV9vdmVyX2Rlbm9tXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSpzR21pZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0MS5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRy5zdWIoIHRtaSwgdGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZyLm11bChzSW52QWNjLCBvbmVfb3Zlcl9kZW5vbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpKnNHbWlkXG4gICAgICAgICAgICAgICAgICAgICk7XG5cblxuICAgICAgICAgICAgICAgICAgICBzSW52QWNjID0gRnIubXVsKHNJbnZBY2MsIEZyLnNoaWZ0SW52KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdDAgPSBhd2FpdCBHLmlmZnQodDAsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiIHQwXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKHQwKTtcbiAgICAgICAgICAgICAgICB0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdDEgPSBhd2FpdCBHLmlmZnQodDEsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiIHQxXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKHQxKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQb3dlciB0b28gYmlnXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VyIHRvIGJpZ1wiKTtcbiAgICAgICAgICAgIH1cbiovXG4gICAgICAgIH1cblxuXG4gICAgfVxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_convert.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_export_challenge.js":
/*!******************************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_export_challenge.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportChallenge)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n// Format of the outpu\n//     Hash of the last contribution  64Bytes\n//     2^N * 2 -1  TauG1 points (uncompressed)\n//     2^N  TauG2 Points (uncompressed)\n//     2^N  AlphaTauG1 Points (uncompressed)\n//     2^N  BetaTauG1 Points (uncompressed)\n//     BetaG2 (uncompressed)\n\n\n\n\n\n\n\nasync function exportChallenge(pTauFilename, challengeFilename, logger) {\n    const {fd: fdFrom, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdFrom, sections);\n\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readContributions(fdFrom, curve, sections);\n    let lastResponseHash, curChallengeHash;\n    if (contributions.length == 0) {\n        lastResponseHash = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 }).digest();\n        curChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateFirstChallengeHash(curve, power);\n    } else {\n        lastResponseHash = contributions[contributions.length-1].responseHash;\n        curChallengeHash = contributions[contributions.length-1].nextChallenge;\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(lastResponseHash, \"Last Response Hash: \"));\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(curChallengeHash, \"New Challenge Hash: \"));\n\n\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(challengeFilename);\n\n    const toHash = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n    await fdTo.write(lastResponseHash);\n    toHash.update(lastResponseHash);\n\n    await exportSection(2, \"G1\", (2 ** power) * 2 -1, \"tauG1\");\n    await exportSection(3, \"G2\", (2 ** power)       , \"tauG2\");\n    await exportSection(4, \"G1\", (2 ** power)       , \"alphaTauG1\");\n    await exportSection(5, \"G1\", (2 ** power)       , \"betaTauG1\");\n    await exportSection(6, \"G2\", 1                  , \"betaG2\");\n\n    await fdFrom.close();\n    await fdTo.close();\n\n    const calcCurChallengeHash = toHash.digest();\n\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_3__.hashIsEqual (curChallengeHash, calcCurChallengeHash)) {\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(calcCurChallengeHash, \"Calc Curret Challenge Hash: \"));\n\n        if (logger) logger.error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n        throw new Error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n    }\n\n    return curChallengeHash;\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startReadUniqueSection(fdFrom, sections, sectionId);\n        for (let i=0; i< nPoints; i+= nPointsChunk) {\n            if (logger) logger.debug(`Exporting ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n            let buff;\n            buff = await fdFrom.read(n*sG);\n            buff = await G.batchLEMtoU(buff);\n            await fdTo.write(buff);\n            toHash.update(buff);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endReadSection(fdFrom);\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfZXhwb3J0X2NoYWxsZW5nZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDVztBQUNBO0FBQ0k7QUFDbEI7O0FBRW5CO0FBQ2YsV0FBVyxzQkFBc0IsUUFBUSw0REFBd0I7O0FBRWpFLFdBQVcsY0FBYyxRQUFRLGlFQUFvQjs7QUFFckQsZ0NBQWdDLG9FQUF1QjtBQUN2RDtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFPLFVBQVUsV0FBVztBQUN2RCwyQkFBMkIsOEVBQWlDO0FBQzVELE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQyw0QkFBNEIsZ0RBQWU7OztBQUczQyx1QkFBdUIsb0RBQXVCOztBQUU5QyxtQkFBbUIsMERBQU8sVUFBVSxXQUFXO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsaURBQWdCO0FBQ3pCLGdDQUFnQyxnREFBZTs7QUFFL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsdUVBQW1DO0FBQ2pELHNCQUFzQixZQUFZO0FBQ2xDLGtEQUFrRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUEyQjtBQUN6Qzs7O0FBR0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfZXhwb3J0X2NoYWxsZW5nZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGb3JtYXQgb2YgdGhlIG91dHB1XG4vLyAgICAgSGFzaCBvZiB0aGUgbGFzdCBjb250cmlidXRpb24gIDY0Qnl0ZXNcbi8vICAgICAyXk4gKiAyIC0xICBUYXVHMSBwb2ludHMgKHVuY29tcHJlc3NlZClcbi8vICAgICAyXk4gIFRhdUcyIFBvaW50cyAodW5jb21wcmVzc2VkKVxuLy8gICAgIDJeTiAgQWxwaGFUYXVHMSBQb2ludHMgKHVuY29tcHJlc3NlZClcbi8vICAgICAyXk4gIEJldGFUYXVHMSBQb2ludHMgKHVuY29tcHJlc3NlZClcbi8vICAgICBCZXRhRzIgKHVuY29tcHJlc3NlZClcblxuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5pbXBvcnQgeyBibGFrZTJiIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvYmxha2UyYlwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGV4cG9ydENoYWxsZW5nZShwVGF1RmlsZW5hbWUsIGNoYWxsZW5nZUZpbGVuYW1lLCBsb2dnZXIpIHtcbiAgICBjb25zdCB7ZmQ6IGZkRnJvbSwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHBUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuXG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZEZyb20sIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnMgPSBhd2FpdCB1dGlscy5yZWFkQ29udHJpYnV0aW9ucyhmZEZyb20sIGN1cnZlLCBzZWN0aW9ucyk7XG4gICAgbGV0IGxhc3RSZXNwb25zZUhhc2gsIGN1ckNoYWxsZW5nZUhhc2g7XG4gICAgaWYgKGNvbnRyaWJ1dGlvbnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgbGFzdFJlc3BvbnNlSGFzaCA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pLmRpZ2VzdCgpO1xuICAgICAgICBjdXJDaGFsbGVuZ2VIYXNoID0gdXRpbHMuY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdFJlc3BvbnNlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ucmVzcG9uc2VIYXNoO1xuICAgICAgICBjdXJDaGFsbGVuZ2VIYXNoID0gY29udHJpYnV0aW9uc1tjb250cmlidXRpb25zLmxlbmd0aC0xXS5uZXh0Q2hhbGxlbmdlO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChsYXN0UmVzcG9uc2VIYXNoLCBcIkxhc3QgUmVzcG9uc2UgSGFzaDogXCIpKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjdXJDaGFsbGVuZ2VIYXNoLCBcIk5ldyBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuXG4gICAgY29uc3QgZmRUbyA9IGF3YWl0IGZhc3RGaWxlLmNyZWF0ZU92ZXJyaWRlKGNoYWxsZW5nZUZpbGVuYW1lKTtcblxuICAgIGNvbnN0IHRvSGFzaCA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIGF3YWl0IGZkVG8ud3JpdGUobGFzdFJlc3BvbnNlSGFzaCk7XG4gICAgdG9IYXNoLnVwZGF0ZShsYXN0UmVzcG9uc2VIYXNoKTtcblxuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oMiwgXCJHMVwiLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIpO1xuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oMywgXCJHMlwiLCAoMiAqKiBwb3dlcikgICAgICAgLCBcInRhdUcyXCIpO1xuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oNCwgXCJHMVwiLCAoMiAqKiBwb3dlcikgICAgICAgLCBcImFscGhhVGF1RzFcIik7XG4gICAgYXdhaXQgZXhwb3J0U2VjdGlvbig1LCBcIkcxXCIsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIpO1xuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oNiwgXCJHMlwiLCAxICAgICAgICAgICAgICAgICAgLCBcImJldGFHMlwiKTtcblxuICAgIGF3YWl0IGZkRnJvbS5jbG9zZSgpO1xuICAgIGF3YWl0IGZkVG8uY2xvc2UoKTtcblxuICAgIGNvbnN0IGNhbGNDdXJDaGFsbGVuZ2VIYXNoID0gdG9IYXNoLmRpZ2VzdCgpO1xuXG4gICAgaWYgKCFtaXNjLmhhc2hJc0VxdWFsIChjdXJDaGFsbGVuZ2VIYXNoLCBjYWxjQ3VyQ2hhbGxlbmdlSGFzaCkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGNhbGNDdXJDaGFsbGVuZ2VIYXNoLCBcIkNhbGMgQ3VycmV0IENoYWxsZW5nZSBIYXNoOiBcIikpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlBUYXUgZmlsZSBpcyBjb3JydXB0ZWQuIENhbGN1bGF0ZWQgbmV3IGNoYWxsZW5nZSBoYXNoIGRvZXMgbm90IG1hdGNoIHdpdGggdGhlIGVjbGFyZWQgb25lXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQVGF1IGZpbGUgaXMgY29ycnVwdGVkLiBDYWxjdWxhdGVkIG5ldyBjaGFsbGVuZ2UgaGFzaCBkb2VzIG5vdCBtYXRjaCB3aXRoIHRoZSBlY2xhcmVkIG9uZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VyQ2hhbGxlbmdlSGFzaDtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGV4cG9ydFNlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIG5Qb2ludHMsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkRnJvbSwgc2VjdGlvbnMsIHNlY3Rpb25JZCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSs9IG5Qb2ludHNDaHVuaykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBFeHBvcnRpbmcgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMtaSwgblBvaW50c0NodW5rKTtcbiAgICAgICAgICAgIGxldCBidWZmO1xuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IGZkRnJvbS5yZWFkKG4qc0cpO1xuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcuYmF0Y2hMRU10b1UoYnVmZik7XG4gICAgICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmYpO1xuICAgICAgICAgICAgdG9IYXNoLnVwZGF0ZShidWZmKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmRGcm9tKTtcbiAgICB9XG5cblxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_export_challenge.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_export_json.js":
/*!*************************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_export_json.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportJson)\n/* harmony export */ });\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function exportJson(pTauFilename, verbose) {\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readPTauHeader(fd, sections);\n\n    const pTau = {};\n    pTau.q = curve.q;\n    pTau.power = power;\n    pTau.contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readContributions(fd, curve, sections);\n\n    pTau.tauG1 = await exportSection(2, \"G1\", (2 ** power)*2 -1, \"tauG1\");\n    pTau.tauG2 = await exportSection(3, \"G2\", (2 ** power), \"tauG2\");\n    pTau.alphaTauG1 = await exportSection(4, \"G1\", (2 ** power), \"alphaTauG1\");\n    pTau.betaTauG1 = await exportSection(5, \"G1\", (2 ** power), \"betaTauG1\");\n    pTau.betaG2 = await exportSection(6, \"G2\", 1, \"betaG2\");\n\n    pTau.lTauG1 = await exportLagrange(12, \"G1\", \"lTauG1\");\n    pTau.lTauG2 = await exportLagrange(13, \"G2\", \"lTauG2\");\n    pTau.lAlphaTauG1 = await exportLagrange(14, \"G1\", \"lAlphaTauG2\");\n    pTau.lBetaTauG1 = await exportLagrange(15, \"G1\", \"lBetaTauG2\");\n\n    await fd.close();\n\n    return (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.stringifyBigIntsWithField)(curve.Fr, pTau);\n\n\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, sectionId);\n        for (let i=0; i< nPoints; i++) {\n            if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ` + i);\n            const buff = await fd.read(sG);\n            res.push(G.fromRprLEM(buff, 0));\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n        return res;\n    }\n\n    async function exportLagrange(sectionId, groupName, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, sectionId);\n        for (let p=0; p<=power; p++) {\n            if (verbose) console.log(`${sectionName}: Power: ${p}`);\n            res[p] = [];\n            const nPoints = (2 ** p);\n            for (let i=0; i<nPoints; i++) {\n                if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ${i}/${nPoints}`);\n                const buff = await fd.read(sG);\n                res[p].push(G.fromRprLEM(buff, 0));\n            }\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd, true);\n        return res;\n    }\n\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfZXhwb3J0X2pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWdEO0FBQ0k7QUFDRTs7QUFFdkM7QUFDZixXQUFXLGNBQWMsUUFBUSw0REFBd0I7O0FBRXpELFdBQVcsY0FBYyxRQUFRLGlFQUFvQjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9FQUF1Qjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLG1FQUF5Qjs7OztBQUlwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHVFQUFtQztBQUNqRCxzQkFBc0IsWUFBWTtBQUNsQyw2REFBNkQsWUFBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUEyQjs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHVFQUFtQztBQUNqRCxzQkFBc0IsVUFBVTtBQUNoQyx3Q0FBd0MsWUFBWSxXQUFXLEVBQUU7QUFDakU7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDLGlFQUFpRSxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUEyQjtBQUN6QztBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9leHBvcnRfanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgeyBzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBleHBvcnRKc29uKHBUYXVGaWxlbmFtZSwgdmVyYm9zZSkge1xuICAgIGNvbnN0IHtmZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHBUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuXG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZCwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgcFRhdSA9IHt9O1xuICAgIHBUYXUucSA9IGN1cnZlLnE7XG4gICAgcFRhdS5wb3dlciA9IHBvd2VyO1xuICAgIHBUYXUuY29udHJpYnV0aW9ucyA9IGF3YWl0IHV0aWxzLnJlYWRDb250cmlidXRpb25zKGZkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuXG4gICAgcFRhdS50YXVHMSA9IGF3YWl0IGV4cG9ydFNlY3Rpb24oMiwgXCJHMVwiLCAoMiAqKiBwb3dlcikqMiAtMSwgXCJ0YXVHMVwiKTtcbiAgICBwVGF1LnRhdUcyID0gYXdhaXQgZXhwb3J0U2VjdGlvbigzLCBcIkcyXCIsICgyICoqIHBvd2VyKSwgXCJ0YXVHMlwiKTtcbiAgICBwVGF1LmFscGhhVGF1RzEgPSBhd2FpdCBleHBvcnRTZWN0aW9uKDQsIFwiRzFcIiwgKDIgKiogcG93ZXIpLCBcImFscGhhVGF1RzFcIik7XG4gICAgcFRhdS5iZXRhVGF1RzEgPSBhd2FpdCBleHBvcnRTZWN0aW9uKDUsIFwiRzFcIiwgKDIgKiogcG93ZXIpLCBcImJldGFUYXVHMVwiKTtcbiAgICBwVGF1LmJldGFHMiA9IGF3YWl0IGV4cG9ydFNlY3Rpb24oNiwgXCJHMlwiLCAxLCBcImJldGFHMlwiKTtcblxuICAgIHBUYXUubFRhdUcxID0gYXdhaXQgZXhwb3J0TGFncmFuZ2UoMTIsIFwiRzFcIiwgXCJsVGF1RzFcIik7XG4gICAgcFRhdS5sVGF1RzIgPSBhd2FpdCBleHBvcnRMYWdyYW5nZSgxMywgXCJHMlwiLCBcImxUYXVHMlwiKTtcbiAgICBwVGF1LmxBbHBoYVRhdUcxID0gYXdhaXQgZXhwb3J0TGFncmFuZ2UoMTQsIFwiRzFcIiwgXCJsQWxwaGFUYXVHMlwiKTtcbiAgICBwVGF1LmxCZXRhVGF1RzEgPSBhd2FpdCBleHBvcnRMYWdyYW5nZSgxNSwgXCJHMVwiLCBcImxCZXRhVGF1RzJcIik7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQoY3VydmUuRnIsIHBUYXUpO1xuXG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGV4cG9ydFNlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIG5Qb2ludHMsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIHNlY3Rpb25JZCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKHZlcmJvc2UpJiZpJiYoaSUxMDAwMCA9PSAwKSkgY29uc29sZS5sb2coYCR7c2VjdGlvbk5hbWV9OiBgICsgaSk7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRyk7XG4gICAgICAgICAgICByZXMucHVzaChHLmZyb21ScHJMRU0oYnVmZiwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBleHBvcnRMYWdyYW5nZShzZWN0aW9uSWQsIGdyb3VwTmFtZSwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgc2VjdGlvbklkKTtcbiAgICAgICAgZm9yIChsZXQgcD0wOyBwPD1wb3dlcjsgcCsrKSB7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSkgY29uc29sZS5sb2coYCR7c2VjdGlvbk5hbWV9OiBQb3dlcjogJHtwfWApO1xuICAgICAgICAgICAgcmVzW3BdID0gW107XG4gICAgICAgICAgICBjb25zdCBuUG9pbnRzID0gKDIgKiogcCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh2ZXJib3NlKSYmaSYmKGklMTAwMDAgPT0gMCkpIGNvbnNvbGUubG9nKGAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoc0cpO1xuICAgICAgICAgICAgICAgIHJlc1twXS5wdXNoKEcuZnJvbVJwckxFTShidWZmLCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_export_json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_import.js":
/*!********************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_import.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ importResponse)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger) {\n\n    const noHash = new Uint8Array(64);\n    for (let i=0; i<64; i++) noHash[i] = 0xFF;\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readContributions(fdOld, curve, sections);\n    const currentContribution = {};\n\n    if (name) currentContribution.name = name;\n\n    const sG1 = curve.F1.n8*2;\n    const scG1 = curve.F1.n8; // Compressed size\n    const sG2 = curve.F2.n8*2;\n    const scG2 = curve.F2.n8; // Compressed size\n\n    const fdResponse = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(contributionFilename);\n\n    if  (fdResponse.totalSize !=\n        64 +                            // Old Hash\n        ((2 ** power)*2-1)*scG1 +\n        (2 ** power)*scG2 +\n        (2 ** power)*scG1 +\n        (2 ** power)*scG1 +\n        scG2 +\n        sG1*6 + sG2*3)\n        throw new Error(\"Size of the contribution is invalid\");\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile(newPTauFilename, \"ptau\", 1, importPoints ? 7: 2);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    const contributionPreviousHash = await fdResponse.read(64);\n\n    if (_misc_js__WEBPACK_IMPORTED_MODULE_3__.hashIsEqual(noHash,lastChallengeHash)) {\n        lastChallengeHash = contributionPreviousHash;\n        contributions[contributions.length-1].nextChallenge = lastChallengeHash;\n    }\n\n    if(!_misc_js__WEBPACK_IMPORTED_MODULE_3__.hashIsEqual(contributionPreviousHash,lastChallengeHash))\n        throw new Error(\"Wrong contribution. This contribution is not based on the previous hash\");\n\n    const hasherResponse = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n    hasherResponse.update(contributionPreviousHash);\n\n    const startSections = [];\n    let res;\n    res = await processSection(fdResponse, fdNew, \"G1\", 2, (2 ** power) * 2 -1, [1], \"tauG1\");\n    currentContribution.tauG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 3, (2 ** power)       , [1], \"tauG2\");\n    currentContribution.tauG2 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 4, (2 ** power)       , [0], \"alphaG1\");\n    currentContribution.alphaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 5, (2 ** power)       , [0], \"betaG1\");\n    currentContribution.betaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 6, 1                  , [0], \"betaG2\");\n    currentContribution.betaG2 = res[0];\n\n    currentContribution.partialHash = _misc_js__WEBPACK_IMPORTED_MODULE_3__.toPartialHash(hasherResponse);\n\n\n    const buffKey = await fdResponse.read(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    currentContribution.key = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.fromPtauPubKeyRpr(buffKey, 0, curve, false);\n\n    hasherResponse.update(new Uint8Array(buffKey));\n    const hashResponse = hasherResponse.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    if (importPoints) {\n        const nextChallengeHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n        nextChallengeHasher.update(hashResponse);\n\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n        currentContribution.nextChallenge = nextChallengeHasher.digest();\n\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(currentContribution.nextChallenge, \"Next Challenge Hash: \"));\n    } else {\n        currentContribution.nextChallenge = noHash;\n    }\n\n    contributions.push(currentContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeContributions(fdNew, curve, contributions);\n\n    await fdResponse.close();\n    await fdNew.close();\n    await fdOld.close();\n\n    return currentContribution.nextChallenge;\n\n    async function processSection(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n        if (importPoints) {\n            return await processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        } else {\n            return await processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        }\n    }\n\n    async function processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n        const sG = G.F.n8*2;\n\n        const singularPoints = [];\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection(fdTo, sectionId);\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        startSections[sectionId] = fdTo.pos;\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            const buffLEM = await G.batchCtoLEM(buffC);\n\n            await fdTo.write(buffLEM);\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(buffLEM, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection(fdTo);\n\n        return singularPoints;\n    }\n\n\n    async function processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n\n        const singularPoints = [];\n\n        const nPointsChunk = Math.floor((1<<24)/scG);\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprCompressed(buffC, (sp-i)*scG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        return singularPoints;\n    }\n\n\n    async function hashSection(nextChallengeHasher, fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfaW1wb3J0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ1c7QUFDQTtBQUNJO0FBQ2xCOztBQUVuQjs7QUFFZjtBQUNBLGtCQUFrQixNQUFNOztBQUV4QixXQUFXLHFCQUFxQixRQUFRLDREQUF3QjtBQUNoRSxXQUFXLGNBQWMsUUFBUSxpRUFBb0I7QUFDckQsZ0NBQWdDLG9FQUF1QjtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4Qjs7QUFFOUIsNkJBQTZCLGtEQUFxQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEJBQTRCLDhFQUFpQztBQUM3RDs7QUFFQSx3QkFBd0IsOERBQTBCO0FBQ2xELFVBQVUsa0VBQXFCOztBQUUvQjs7QUFFQSxRQUFRLGlEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxpREFBZ0I7QUFDeEI7O0FBRUEsMkJBQTJCLDBEQUFPLFVBQVUsV0FBVztBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLG1EQUFrQjs7O0FBR3hEOztBQUVBLDhCQUE4QixvRUFBdUI7O0FBRXJEO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBLG9DQUFvQywwREFBTyxVQUFVLFdBQVc7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsZ0RBQWU7QUFDL0MsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSxxRUFBd0I7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLGtFQUE4QjtBQUM1Qzs7QUFFQTs7QUFFQSxzQkFBc0IsWUFBWTtBQUNsQyxrREFBa0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQy9FOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0VBQTRCOztBQUUxQztBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDLGtEQUFrRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDL0U7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDLGdEQUFnRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDN0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2ltcG9ydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0UmVzcG9uc2Uob2xkUHRhdUZpbGVuYW1lLCBjb250cmlidXRpb25GaWxlbmFtZSwgbmV3UFRhdUZpbGVuYW1lLCBuYW1lLCBpbXBvcnRQb2ludHMsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qgbm9IYXNoID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgIGZvciAobGV0IGk9MDsgaTw2NDsgaSsrKSBub0hhc2hbaV0gPSAweEZGO1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKG9sZFB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcbiAgICBjb25zdCBjb250cmlidXRpb25zID0gYXdhaXQgdXRpbHMucmVhZENvbnRyaWJ1dGlvbnMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY3VycmVudENvbnRyaWJ1dGlvbiA9IHt9O1xuXG4gICAgaWYgKG5hbWUpIGN1cnJlbnRDb250cmlidXRpb24ubmFtZSA9IG5hbWU7XG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5GMS5uOCoyO1xuICAgIGNvbnN0IHNjRzEgPSBjdXJ2ZS5GMS5uODsgLy8gQ29tcHJlc3NlZCBzaXplXG4gICAgY29uc3Qgc0cyID0gY3VydmUuRjIubjgqMjtcbiAgICBjb25zdCBzY0cyID0gY3VydmUuRjIubjg7IC8vIENvbXByZXNzZWQgc2l6ZVxuXG4gICAgY29uc3QgZmRSZXNwb25zZSA9IGF3YWl0IGZhc3RGaWxlLnJlYWRFeGlzdGluZyhjb250cmlidXRpb25GaWxlbmFtZSk7XG5cbiAgICBpZiAgKGZkUmVzcG9uc2UudG90YWxTaXplICE9XG4gICAgICAgIDY0ICsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2xkIEhhc2hcbiAgICAgICAgKCgyICoqIHBvd2VyKSoyLTEpKnNjRzEgK1xuICAgICAgICAoMiAqKiBwb3dlcikqc2NHMiArXG4gICAgICAgICgyICoqIHBvd2VyKSpzY0cxICtcbiAgICAgICAgKDIgKiogcG93ZXIpKnNjRzEgK1xuICAgICAgICBzY0cyICtcbiAgICAgICAgc0cxKjYgKyBzRzIqMylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBvZiB0aGUgY29udHJpYnV0aW9uIGlzIGludmFsaWRcIik7XG5cbiAgICBsZXQgbGFzdENoYWxsZW5nZUhhc2g7XG5cbiAgICBpZiAoY29udHJpYnV0aW9ucy5sZW5ndGg+MCkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IHV0aWxzLmNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZShuZXdQVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxLCBpbXBvcnRQb2ludHMgPyA3OiAyKTtcbiAgICBhd2FpdCB1dGlscy53cml0ZVBUYXVIZWFkZXIoZmROZXcsIGN1cnZlLCBwb3dlcik7XG5cbiAgICBjb25zdCBjb250cmlidXRpb25QcmV2aW91c0hhc2ggPSBhd2FpdCBmZFJlc3BvbnNlLnJlYWQoNjQpO1xuXG4gICAgaWYgKG1pc2MuaGFzaElzRXF1YWwobm9IYXNoLGxhc3RDaGFsbGVuZ2VIYXNoKSkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvblByZXZpb3VzSGFzaDtcbiAgICAgICAgY29udHJpYnV0aW9uc1tjb250cmlidXRpb25zLmxlbmd0aC0xXS5uZXh0Q2hhbGxlbmdlID0gbGFzdENoYWxsZW5nZUhhc2g7XG4gICAgfVxuXG4gICAgaWYoIW1pc2MuaGFzaElzRXF1YWwoY29udHJpYnV0aW9uUHJldmlvdXNIYXNoLGxhc3RDaGFsbGVuZ2VIYXNoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgY29udHJpYnV0aW9uLiBUaGlzIGNvbnRyaWJ1dGlvbiBpcyBub3QgYmFzZWQgb24gdGhlIHByZXZpb3VzIGhhc2hcIik7XG5cbiAgICBjb25zdCBoYXNoZXJSZXNwb25zZSA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIGhhc2hlclJlc3BvbnNlLnVwZGF0ZShjb250cmlidXRpb25QcmV2aW91c0hhc2gpO1xuXG4gICAgY29uc3Qgc3RhcnRTZWN0aW9ucyA9IFtdO1xuICAgIGxldCByZXM7XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzFcIiwgMiwgKDIgKiogcG93ZXIpICogMiAtMSwgWzFdLCBcInRhdUcxXCIpO1xuICAgIGN1cnJlbnRDb250cmlidXRpb24udGF1RzEgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgWzFdLCBcInRhdUcyXCIpO1xuICAgIGN1cnJlbnRDb250cmlidXRpb24udGF1RzIgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzFcIiwgNCwgKDIgKiogcG93ZXIpICAgICAgICwgWzBdLCBcImFscGhhRzFcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5hbHBoYUcxID0gcmVzWzBdO1xuICAgIHJlcyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKGZkUmVzcG9uc2UsIGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFswXSwgXCJiZXRhRzFcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5iZXRhRzEgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgWzBdLCBcImJldGFHMlwiKTtcbiAgICBjdXJyZW50Q29udHJpYnV0aW9uLmJldGFHMiA9IHJlc1swXTtcblxuICAgIGN1cnJlbnRDb250cmlidXRpb24ucGFydGlhbEhhc2ggPSBtaXNjLnRvUGFydGlhbEhhc2goaGFzaGVyUmVzcG9uc2UpO1xuXG5cbiAgICBjb25zdCBidWZmS2V5ID0gYXdhaXQgZmRSZXNwb25zZS5yZWFkKGN1cnZlLkYxLm44KjIqNitjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5rZXkgPSB1dGlscy5mcm9tUHRhdVB1YktleVJwcihidWZmS2V5LCAwLCBjdXJ2ZSwgZmFsc2UpO1xuXG4gICAgaGFzaGVyUmVzcG9uc2UudXBkYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZLZXkpKTtcbiAgICBjb25zdCBoYXNoUmVzcG9uc2UgPSBoYXNoZXJSZXNwb25zZS5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChoYXNoUmVzcG9uc2UsIFwiQ29udHJpYnV0aW9uIFJlc3BvbnNlIEhhc2ggaW1wb3J0ZWQ6IFwiKSk7XG5cbiAgICBpZiAoaW1wb3J0UG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IG5leHRDaGFsbGVuZ2VIYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTtcbiAgICAgICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoaGFzaFJlc3BvbnNlKTtcblxuICAgICAgICBhd2FpdCBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcyXCIsIDMsICgyICoqIHBvd2VyKSAgICAgICAsIFwidGF1RzJcIiwgbG9nZ2VyKTtcbiAgICAgICAgYXdhaXQgaGFzaFNlY3Rpb24obmV4dENoYWxsZW5nZUhhc2hlciwgZmROZXcsIFwiRzFcIiwgNCwgKDIgKiogcG93ZXIpICAgICAgICwgXCJhbHBoYVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcyXCIsIDYsIDEgICAgICAgICAgICAgICAgICAsIFwiYmV0YUcyXCIsIGxvZ2dlcik7XG5cbiAgICAgICAgY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbmV4dENoYWxsZW5nZUhhc2hlci5kaWdlc3QoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlLCBcIk5leHQgQ2hhbGxlbmdlIEhhc2g6IFwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbm9IYXNoO1xuICAgIH1cblxuICAgIGNvbnRyaWJ1dGlvbnMucHVzaChjdXJyZW50Q29udHJpYnV0aW9uKTtcblxuICAgIGF3YWl0IHV0aWxzLndyaXRlQ29udHJpYnV0aW9ucyhmZE5ldywgY3VydmUsIGNvbnRyaWJ1dGlvbnMpO1xuXG4gICAgYXdhaXQgZmRSZXNwb25zZS5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcblxuICAgIHJldHVybiBjdXJyZW50Q29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2U7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihmZEZyb20sIGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzaW5ndWxhclBvaW50SW5kZXhlcywgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKGltcG9ydFBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NTZWN0aW9uSW1wb3J0UG9pbnRzKGZkRnJvbSwgZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNpbmd1bGFyUG9pbnRJbmRleGVzLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc1NlY3Rpb25Ob0ltcG9ydFBvaW50cyhmZEZyb20sIGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzaW5ndWxhclBvaW50SW5kZXhlcywgc2VjdGlvbk5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb25JbXBvcnRQb2ludHMoZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNjRyA9IEcuRi5uODtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcblxuICAgICAgICBjb25zdCBzaW5ndWxhclBvaW50cyA9IFtdO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFRvLCBzZWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXSA9IGZkVG8ucG9zO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSW1wb3J0aW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDID0gYXdhaXQgZmRGcm9tLnJlYWQobiAqIHNjRyk7XG4gICAgICAgICAgICBoYXNoZXJSZXNwb25zZS51cGRhdGUoYnVmZkMpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmTEVNID0gYXdhaXQgRy5iYXRjaEN0b0xFTShidWZmQyk7XG5cbiAgICAgICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZkxFTSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8c2luZ3VsYXJQb2ludEluZGV4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcCA9IHNpbmd1bGFyUG9pbnRJbmRleGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICgoc3AgPj1pKSAmJiAoc3AgPCBpK24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJMRU0oYnVmZkxFTSwgKHNwLWkpKnNHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkVG8pO1xuXG4gICAgICAgIHJldHVybiBzaW5ndWxhclBvaW50cztcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uTm9JbXBvcnRQb2ludHMoZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNjRyA9IEcuRi5uODtcblxuICAgICAgICBjb25zdCBzaW5ndWxhclBvaW50cyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zY0cpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSW1wb3J0aW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDID0gYXdhaXQgZmRGcm9tLnJlYWQobiAqIHNjRyk7XG4gICAgICAgICAgICBoYXNoZXJSZXNwb25zZS51cGRhdGUoYnVmZkMpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8c2luZ3VsYXJQb2ludEluZGV4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcCA9IHNpbmd1bGFyUG9pbnRJbmRleGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICgoc3AgPj1pKSAmJiAoc3AgPCBpK24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJDb21wcmVzc2VkKGJ1ZmZDLCAoc3AtaSkqc2NHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2luZ3VsYXJQb2ludHM7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIGNvbnN0IG9sZFBvcyA9IGZkVG8ucG9zO1xuICAgICAgICBmZFRvLnBvcyA9IHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkgKz0gblBvaW50c0NodW5rKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEhhc2hpbmcgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMtaSwgblBvaW50c0NodW5rKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZkxFTSA9IGF3YWl0IGZkVG8ucmVhZChuICogc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmVSA9IGF3YWl0IEcuYmF0Y2hMRU10b1UoYnVmZkxFTSk7XG5cbiAgICAgICAgICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGJ1ZmZVKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZkVG8ucG9zID0gb2xkUG9zO1xuICAgIH1cblxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_import.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_new.js":
/*!*****************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_new.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ newAccumulator)\n/* harmony export */ });\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\nHeader(1)\n    n8\n    prime\n    power\ntauG1(2)\n    {(2 ** power)*2-1} [\n        G1, tau*G1, tau^2 * G1, ....\n    ]\ntauG2(3)\n    {2 ** power}[\n        G2, tau*G2, tau^2 * G2, ...\n    ]\nalphaTauG1(4)\n    {2 ** power}[\n        alpha*G1, alpha*tau*G1, alpha*tau^2*G1,....\n    ]\nbetaTauG1(5)\n    {2 ** power} []\n        beta*G1, beta*tau*G1, beta*tau^2*G1, ....\n    ]\nbetaG2(6)\n    {1}[\n        beta*G2\n    ]\ncontributions(7)\n    NContributions\n    {NContributions}[\n        tau*G1\n        tau*G2\n        alpha*G1\n        beta*G1\n        beta*G2\n        pubKey\n            tau_g1s\n            tau_g1sx\n            tau_g2spx\n            alpha_g1s\n            alpha_g1sx\n            alpha_g1spx\n            beta_g1s\n            beta_g1sx\n            beta_g1spx\n        partialHash (216 bytes) See https://github.com/mafintosh/blake2b-wasm/blob/23bee06945806309977af802bc374727542617c7/blake2b.wat#L9\n        hashNewChallenge\n    ]\n */\n\n\n\n\n\n\nasync function newAccumulator(curve, power, fileName, logger) {\n\n    const fd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(fileName, \"ptau\", 1, 7);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writePTauHeader(fd, curve, power, 0);\n\n    const buffG1 = curve.G1.oneAffine;\n    const buffG2 = curve.G2.oneAffine;\n\n    // Write tauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    const nTauG1 = (2 ** power) * 2 -1;\n    for (let i=0; i< nTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write tauG2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 3);\n    const nTauG2 = (2 ** power);\n    for (let i=0; i< nTauG2; i++) {\n        await fd.write(buffG2);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG2: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write alphaTauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 4);\n    const nAlfaTauG1 = (2 ** power);\n    for (let i=0; i< nAlfaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"alphaTauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write betaTauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 5);\n    const nBetaTauG1 = (2 ** power);\n    for (let i=0; i< nBetaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"betaTauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write betaG2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 6);\n    await fd.write(buffG2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Contributions\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 7);\n    await fd.writeULE32(0); // 0 Contributions\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await fd.close();\n\n    const firstChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.calculateFirstChallengeHash(curve, power, logger);\n\n    if (logger) logger.debug(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(_noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_3__.blake2b.create({ dkLen: 64 }).digest(), \"Blank Contribution Hash:\"));\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(firstChallengeHash, \"First Contribution Hash:\"));\n\n    return firstChallengeHash;\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfbmV3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGtCQUFrQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLLFdBQVc7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSyxXQUFXO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEtBQUssWUFBWTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZUFBZTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDQTtBQUNKO0FBQ2Q7O0FBRW5COztBQUVmLHFCQUFxQiw4REFBMEI7O0FBRS9DLFVBQVUsa0VBQXlCOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOztBQUV0QztBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOztBQUV0QztBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLDRCQUE0QjtBQUM1QixVQUFVLGdFQUE0Qjs7QUFFdEM7O0FBRUEsK0JBQStCLDhFQUFxQzs7QUFFcEUsNkJBQTZCLGdEQUFlLENBQUMsMERBQU8sVUFBVSxXQUFXOztBQUV6RSw0QkFBNEIsZ0RBQWU7O0FBRTNDOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X25ldy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKlxuSGVhZGVyKDEpXG4gICAgbjhcbiAgICBwcmltZVxuICAgIHBvd2VyXG50YXVHMSgyKVxuICAgIHsoMiAqKiBwb3dlcikqMi0xfSBbXG4gICAgICAgIEcxLCB0YXUqRzEsIHRhdV4yICogRzEsIC4uLi5cbiAgICBdXG50YXVHMigzKVxuICAgIHsyICoqIHBvd2VyfVtcbiAgICAgICAgRzIsIHRhdSpHMiwgdGF1XjIgKiBHMiwgLi4uXG4gICAgXVxuYWxwaGFUYXVHMSg0KVxuICAgIHsyICoqIHBvd2VyfVtcbiAgICAgICAgYWxwaGEqRzEsIGFscGhhKnRhdSpHMSwgYWxwaGEqdGF1XjIqRzEsLi4uLlxuICAgIF1cbmJldGFUYXVHMSg1KVxuICAgIHsyICoqIHBvd2VyfSBbXVxuICAgICAgICBiZXRhKkcxLCBiZXRhKnRhdSpHMSwgYmV0YSp0YXVeMipHMSwgLi4uLlxuICAgIF1cbmJldGFHMig2KVxuICAgIHsxfVtcbiAgICAgICAgYmV0YSpHMlxuICAgIF1cbmNvbnRyaWJ1dGlvbnMoNylcbiAgICBOQ29udHJpYnV0aW9uc1xuICAgIHtOQ29udHJpYnV0aW9uc31bXG4gICAgICAgIHRhdSpHMVxuICAgICAgICB0YXUqRzJcbiAgICAgICAgYWxwaGEqRzFcbiAgICAgICAgYmV0YSpHMVxuICAgICAgICBiZXRhKkcyXG4gICAgICAgIHB1YktleVxuICAgICAgICAgICAgdGF1X2cxc1xuICAgICAgICAgICAgdGF1X2cxc3hcbiAgICAgICAgICAgIHRhdV9nMnNweFxuICAgICAgICAgICAgYWxwaGFfZzFzXG4gICAgICAgICAgICBhbHBoYV9nMXN4XG4gICAgICAgICAgICBhbHBoYV9nMXNweFxuICAgICAgICAgICAgYmV0YV9nMXNcbiAgICAgICAgICAgIGJldGFfZzFzeFxuICAgICAgICAgICAgYmV0YV9nMXNweFxuICAgICAgICBwYXJ0aWFsSGFzaCAoMjE2IGJ5dGVzKSBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9ibGFrZTJiLXdhc20vYmxvYi8yM2JlZTA2OTQ1ODA2MzA5OTc3YWY4MDJiYzM3NDcyNzU0MjYxN2M3L2JsYWtlMmIud2F0I0w5XG4gICAgICAgIGhhc2hOZXdDaGFsbGVuZ2VcbiAgICBdXG4gKi9cblxuaW1wb3J0ICogYXMgcHRhdVV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gbmV3QWNjdW11bGF0b3IoY3VydmUsIHBvd2VyLCBmaWxlTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBmZCA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKGZpbGVOYW1lLCBcInB0YXVcIiwgMSwgNyk7XG5cbiAgICBhd2FpdCBwdGF1VXRpbHMud3JpdGVQVGF1SGVhZGVyKGZkLCBjdXJ2ZSwgcG93ZXIsIDApO1xuXG4gICAgY29uc3QgYnVmZkcxID0gY3VydmUuRzEub25lQWZmaW5lO1xuICAgIGNvbnN0IGJ1ZmZHMiA9IGN1cnZlLkcyLm9uZUFmZmluZTtcblxuICAgIC8vIFdyaXRlIHRhdUcxXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDIpO1xuICAgIGNvbnN0IG5UYXVHMSA9ICgyICoqIHBvd2VyKSAqIDIgLTE7XG4gICAgZm9yIChsZXQgaT0wOyBpPCBuVGF1RzE7IGkrKykge1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgICAgICBpZiAoKGxvZ2dlcikmJigoaSUxMDAwMDApID09IDApJiZpKSBsb2dnZXIubG9nKFwidGF1RzE6IFwiICsgaSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgdGF1RzJcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMyk7XG4gICAgY29uc3QgblRhdUcyID0gKDIgKiogcG93ZXIpO1xuICAgIGZvciAobGV0IGk9MDsgaTwgblRhdUcyOyBpKyspIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUoYnVmZkcyKTtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoKGklMTAwMDAwKSA9PSAwKSYmaSkgbG9nZ2VyLmxvZyhcInRhdUcyOiBcIiArIGkpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIGFscGhhVGF1RzFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNCk7XG4gICAgY29uc3QgbkFsZmFUYXVHMSA9ICgyICoqIHBvd2VyKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IG5BbGZhVGF1RzE7IGkrKykge1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgICAgICBpZiAoKGxvZ2dlcikmJigoaSUxMDAwMDApID09IDApJiZpKSBsb2dnZXIubG9nKFwiYWxwaGFUYXVHMTogXCIgKyBpKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSBiZXRhVGF1RzFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNSk7XG4gICAgY29uc3QgbkJldGFUYXVHMSA9ICgyICoqIHBvd2VyKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IG5CZXRhVGF1RzE7IGkrKykge1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgICAgICBpZiAoKGxvZ2dlcikmJigoaSUxMDAwMDApID09IDApJiZpKSBsb2dnZXIubG9nKFwiYmV0YVRhdUcxOiBcIiArIGkpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIGJldGFHMlxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA2KTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmRzIpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gQ29udHJpYnV0aW9uc1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA3KTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDApOyAvLyAwIENvbnRyaWJ1dGlvbnNcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICBjb25zdCBmaXJzdENoYWxsZW5nZUhhc2ggPSBwdGF1VXRpbHMuY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlciwgbG9nZ2VyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhtaXNjLmZvcm1hdEhhc2goYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSkuZGlnZXN0KCksIFwiQmxhbmsgQ29udHJpYnV0aW9uIEhhc2g6XCIpKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChmaXJzdENoYWxsZW5nZUhhc2gsIFwiRmlyc3QgQ29udHJpYnV0aW9uIEhhc2g6XCIpKTtcblxuICAgIHJldHVybiBmaXJzdENoYWxsZW5nZUhhc2g7XG5cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_new.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_preparephase2.js":
/*!***************************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_preparephase2.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ preparePhase2)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function preparePhase2(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await processSection(3, 13, \"G2\", \"tauG2\" );\n    await processSection(4, 14, \"G1\", \"alphaTauG1\" );\n    await processSection(5, 15, \"G1\", \"betaTauG1\" );\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, newSectionId);\n\n        for (let p=0; p<=power; p++) {\n            await processSectionPower(p);\n        }\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const Fr = curve.Fr;\n            const sGin = G.F.n8*2;\n            const sGmid = G.F.n8*3;\n\n            let buff;\n            buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_2__.BigBuffer(nPoints*sGin);\n\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld, true);\n\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfcHJlcGFyZXBoYXNlMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDSjtBQUNUOztBQUV4Qjs7QUFFZixXQUFXLHFCQUFxQixRQUFRLDREQUF3QjtBQUNoRSxXQUFXLGNBQWMsUUFBUSxpRUFBb0I7O0FBRXJELHdCQUF3Qiw4REFBMEI7QUFDbEQsVUFBVSxrRUFBcUI7O0FBRS9CLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxrRUFBOEI7O0FBRTVDLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0VBQTRCOzs7QUFHMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1EQUFTOztBQUVoQyxrQkFBa0IsdUVBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7O0FBRzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9wcmVwYXJlcGhhc2UyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCB7QmlnQnVmZmVyfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVQaGFzZTIob2xkUHRhdUZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKG9sZFB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUobmV3UFRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSwgMTEpO1xuICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMyk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDQpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNik7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDcpO1xuXG4gICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgMTIsIFwiRzFcIiwgXCJ0YXVHMVwiICk7XG4gICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMywgMTMsIFwiRzJcIiwgXCJ0YXVHMlwiICk7XG4gICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNCwgMTQsIFwiRzFcIiwgXCJhbHBoYVRhdUcxXCIgKTtcbiAgICBhd2FpdCBwcm9jZXNzU2VjdGlvbig1LCAxNSwgXCJHMVwiLCBcImJldGFUYXVHMVwiICk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICAvLyBhd2FpdCBmcy5wcm9taXNlcy51bmxpbmsobmV3UFRhdUZpbGVuYW1lKyBcIi50bXBcIik7XG5cbiAgICByZXR1cm47XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihvbGRTZWN0aW9uSWQsIG5ld1NlY3Rpb25JZCwgR3N0ciwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiU3RhcnRpbmcgc2VjdGlvbjogXCIrc2VjdGlvbk5hbWUpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgbmV3U2VjdGlvbklkKTtcblxuICAgICAgICBmb3IgKGxldCBwPTA7IHA8PXBvd2VyOyBwKyspIHtcbiAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uUG93ZXIocCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2xkU2VjdGlvbklkID09IDIpIHtcbiAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uUG93ZXIocG93ZXIrMSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcblxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uUG93ZXIocCkge1xuICAgICAgICAgICAgY29uc3QgblBvaW50cyA9IDIgKiogcDtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtHc3RyXTtcbiAgICAgICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgICAgICBjb25zdCBzR2luID0gRy5GLm44KjI7XG4gICAgICAgICAgICBjb25zdCBzR21pZCA9IEcuRi5uOCozO1xuXG4gICAgICAgICAgICBsZXQgYnVmZjtcbiAgICAgICAgICAgIGJ1ZmYgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0dpbik7XG5cbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgb2xkU2VjdGlvbklkKTtcbiAgICAgICAgICAgIGlmICgob2xkU2VjdGlvbklkID09IDIpJiYocD09cG93ZXIrMSkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE9sZC5yZWFkVG9CdWZmZXIoYnVmZiwgMCwoblBvaW50cy0xKSpzR2luICk7XG4gICAgICAgICAgICAgICAgYnVmZi5zZXQoY3VydmUuRzEuemVyb0FmZmluZSwgKG5Qb2ludHMtMSkqc0dpbiApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE9sZC5yZWFkVG9CdWZmZXIoYnVmZiwgMCxuUG9pbnRzKnNHaW4gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZE9sZCwgdHJ1ZSk7XG5cblxuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcubGFncmFuZ2VFdmFsdWF0aW9ucyhidWZmLCBcImFmZmluZVwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuXG4vKlxuICAgICAgICAgICAgaWYgKHAgPD0gY3VydmUuRnIucykge1xuICAgICAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmlmZnQoYnVmZiwgXCJhZmZpbmVcIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAgPT0gY3VydmUuRnIucysxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc21hbGxNID0gMTw8Y3VydmUuRnIucztcbiAgICAgICAgICAgICAgICBsZXQgdDAgPSBuZXcgQmlnQnVmZmVyKCBzbWFsbE0gKiBzR21pZCApO1xuICAgICAgICAgICAgICAgIGxldCB0MSA9IG5ldyBCaWdCdWZmZXIoIHNtYWxsTSAqIHNHbWlkICk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaGlmdF90b19zbWFsbF9tID0gRnIuZXhwKEZyLnNoaWZ0LCBzbWFsbE0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uZV9vdmVyX2Rlbm9tID0gRnIuaW52KEZyLnN1YihzaGlmdF90b19zbWFsbF9tLCBGci5vbmUpKTtcblxuICAgICAgICAgICAgICAgIGxldCBzSW52QWNjID0gRnIub25lO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxzbWFsbE07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aSA9ICBidWZmLnNsaWNlKGkqc0dpbiwgKGkrMSkqc0dpbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtaSA9IGJ1ZmYuc2xpY2UoKGkrc21hbGxNKSpzR2luLCAoaStzbWFsbE0rMSkqc0dpbik7XG5cbiAgICAgICAgICAgICAgICAgICAgdDAuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcuc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIodGkgLCBzaGlmdF90b19zbWFsbF9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVfb3Zlcl9kZW5vbVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkqc0dtaWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdDEuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcuc3ViKCB0bWksIHRpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGci5tdWwoc0ludkFjYywgb25lX292ZXJfZGVub20pXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSpzR21pZFxuICAgICAgICAgICAgICAgICAgICApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgc0ludkFjYyA9IEZyLm11bChzSW52QWNjLCBGci5zaGlmdEludik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQwID0gYXdhaXQgRy5pZmZ0KHQwLCBcImphY29iaWFuXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIiB0MFwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZSh0MCk7XG4gICAgICAgICAgICAgICAgdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHQxID0gYXdhaXQgRy5pZmZ0KHQxLCBcImphY29iaWFuXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIiB0MFwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZSh0MSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUG93ZXIgdG9vIGJpZ1wiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3dlciB0byBiaWdcIik7XG4gICAgICAgICAgICB9XG4qL1xuICAgICAgICB9XG4gICAgfVxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_preparephase2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_truncate.js":
/*!**********************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_truncate.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ truncate)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nasync function truncate(ptauFilename, template, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(ptauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    for (let p=1; p<power; p++) {\n        await generateTruncate(p);\n    }\n\n    await fdOld.close();\n\n    return true;\n\n    async function generateTruncate(p) {\n\n        let sP = p.toString();\n        while (sP.length<2) sP = \"0\" + sP;\n\n        if (logger) logger.debug(\"Writing Power: \"+sP);\n\n        const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(template + sP + \".ptau\", \"ptau\", 1, 11);\n        await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, p, ceremonyPower);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2, ((2 ** p)*2-1) * sG1 ); // tagG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3, (2 ** p) * sG2); // tauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4, (2 ** p) * sG1); // alfaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5, (2 ** p) * sG1); // betaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6,  sG2); // betaTauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7); // contributions\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 12, ((2 ** (p+1))*2 -1) * sG1); // L_tauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 13, ((2 ** p)*2 -1) * sG2); // L_tauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 14, ((2 ** p)*2 -1) * sG1); // L_alfaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 15, ((2 ** p)*2 -1) * sG1); // L_betaTauG1\n\n        await fdNew.close();\n    }\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdHJ1bmNhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDSjs7QUFFakM7O0FBRWYsV0FBVyxxQkFBcUIsUUFBUSw0REFBd0I7QUFDaEUsV0FBVyw2QkFBNkIsUUFBUSxpRUFBb0I7O0FBRXBFO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qiw4REFBMEI7QUFDdEQsY0FBYyxrRUFBcUI7O0FBRW5DLGNBQWMsNERBQXdCLG9EQUFvRDtBQUMxRixjQUFjLDREQUF3Qiw2Q0FBNkM7QUFDbkYsY0FBYyw0REFBd0IsNkNBQTZDO0FBQ25GLGNBQWMsNERBQXdCLDZDQUE2QztBQUNuRixjQUFjLDREQUF3QixtQ0FBbUM7QUFDekUsY0FBYyw0REFBd0IsNkJBQTZCO0FBQ25FLGNBQWMsNERBQXdCLHlEQUF5RDtBQUMvRixjQUFjLDREQUF3QixxREFBcUQ7QUFDM0YsY0FBYyw0REFBd0IscURBQXFEO0FBQzNGLGNBQWMsNERBQXdCLHFEQUFxRDs7QUFFM0Y7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdHJ1bmNhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB0cnVuY2F0ZShwdGF1RmlsZW5hbWUsIHRlbXBsYXRlLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShwdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyLCBjZXJlbW9ueVBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuXG4gICAgZm9yIChsZXQgcD0xOyBwPHBvd2VyOyBwKyspIHtcbiAgICAgICAgYXdhaXQgZ2VuZXJhdGVUcnVuY2F0ZShwKTtcbiAgICB9XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRydW5jYXRlKHApIHtcblxuICAgICAgICBsZXQgc1AgPSBwLnRvU3RyaW5nKCk7XG4gICAgICAgIHdoaWxlIChzUC5sZW5ndGg8Mikgc1AgPSBcIjBcIiArIHNQO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIldyaXRpbmcgUG93ZXI6IFwiK3NQKTtcblxuICAgICAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKHRlbXBsYXRlICsgc1AgKyBcIi5wdGF1XCIsIFwicHRhdVwiLCAxLCAxMSk7XG4gICAgICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHAsIGNlcmVtb255UG93ZXIpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAyLCAoKDIgKiogcCkqMi0xKSAqIHNHMSApOyAvLyB0YWdHMVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMywgKDIgKiogcCkgKiBzRzIpOyAvLyB0YXVHMlxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNCwgKDIgKiogcCkgKiBzRzEpOyAvLyBhbGZhVGF1RzFcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDUsICgyICoqIHApICogc0cxKTsgLy8gYmV0YVRhdUcxXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA2LCAgc0cyKTsgLy8gYmV0YVRhdUcyXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA3KTsgLy8gY29udHJpYnV0aW9uc1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTIsICgoMiAqKiAocCsxKSkqMiAtMSkgKiBzRzEpOyAvLyBMX3RhdUcxXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxMywgKCgyICoqIHApKjIgLTEpICogc0cyKTsgLy8gTF90YXVHMlxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTQsICgoMiAqKiBwKSoyIC0xKSAqIHNHMSk7IC8vIExfYWxmYVRhdUcxXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxNSwgKCgyICoqIHApKjIgLTEpICogc0cxKTsgLy8gTF9iZXRhVGF1RzFcblxuICAgICAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuICAgIH1cblxuXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_truncate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateFirstChallengeHash: () => (/* binding */ calculateFirstChallengeHash),\n/* harmony export */   fromPtauPubKeyRpr: () => (/* binding */ fromPtauPubKeyRpr),\n/* harmony export */   keyFromBeacon: () => (/* binding */ keyFromBeacon),\n/* harmony export */   readContributions: () => (/* binding */ readContributions),\n/* harmony export */   readPTauHeader: () => (/* binding */ readPTauHeader),\n/* harmony export */   readPtauPubKey: () => (/* binding */ readPtauPubKey),\n/* harmony export */   toPtauPubKeyRpr: () => (/* binding */ toPtauPubKeyRpr),\n/* harmony export */   writeContributions: () => (/* binding */ writeContributions),\n/* harmony export */   writePTauHeader: () => (/* binding */ writePTauHeader),\n/* harmony export */   writePtauPubKey: () => (/* binding */ writePtauPubKey)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function writePTauHeader(fd, curve, power, ceremonyPower) {\n    // Write the header\n    ///////////\n\n    if (! ceremonyPower) ceremonyPower = power;\n    await fd.writeULE32(1); // Header type\n    const pHeaderSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(curve.F1.n64*8);\n\n    const buff = new Uint8Array(curve.F1.n8);\n    ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(buff, 0, curve.q, curve.F1.n8);\n    await fd.write(buff);\n    await fd.writeULE32(power);                    // power\n    await fd.writeULE32(ceremonyPower);               // power\n\n    const headerSize = fd.pos - pHeaderSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(headerSize, pHeaderSize);\n\n    fd.pos = oldPos;\n}\n\nasync function readPTauHeader(fd, sections) {\n    if (!sections[1])  throw new Error(fd.fileName + \": File has no  header\");\n    if (sections[1].length>1) throw new Error(fd.fileName +\": File has more than one header\");\n\n    fd.pos = sections[1][0].p;\n    const n8 = await fd.readULE32();\n    const buff = await fd.read(n8);\n    const q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(buff);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_3__.getCurveFromQ)(q);\n\n    if (curve.F1.n64*8 != n8) throw new Error(fd.fileName +\": Invalid size\");\n\n    const power = await fd.readULE32();\n    const ceremonyPower = await fd.readULE32();\n\n    if (fd.pos-sections[1][0].p != sections[1][0].size) throw new Error(\"Invalid PTau header size\");\n\n    return {curve, power, ceremonyPower};\n}\n\n\nasync function readPtauPubKey(fd, curve, montgomery) {\n\n    const buff = await fd.read(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n\n    return fromPtauPubKeyRpr(buff, 0, curve, montgomery);\n}\n\nfunction fromPtauPubKeyRpr(buff, pos, curve, montgomery) {\n\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n\n    key.tau.g1_s = readG1();\n    key.tau.g1_sx = readG1();\n    key.alpha.g1_s = readG1();\n    key.alpha.g1_sx = readG1();\n    key.beta.g1_s = readG1();\n    key.beta.g1_sx = readG1();\n    key.tau.g2_spx = readG2();\n    key.alpha.g2_spx = readG2();\n    key.beta.g2_spx = readG2();\n\n    return key;\n\n    function readG1() {\n        let p;\n        if (montgomery) {\n            p = curve.G1.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G1.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G1.F.n8*2;\n        return p;\n    }\n\n    function readG2() {\n        let p;\n        if (montgomery) {\n            p = curve.G2.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G2.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G2.F.n8*2;\n        return p;\n    }\n}\n\nfunction toPtauPubKeyRpr(buff, pos, curve, key, montgomery) {\n\n    writeG1(key.tau.g1_s);\n    writeG1(key.tau.g1_sx);\n    writeG1(key.alpha.g1_s);\n    writeG1(key.alpha.g1_sx);\n    writeG1(key.beta.g1_s);\n    writeG1(key.beta.g1_sx);\n    writeG2(key.tau.g2_spx);\n    writeG2(key.alpha.g2_spx);\n    writeG2(key.beta.g2_spx);\n\n    async function writeG1(p) {\n        if (montgomery) {\n            curve.G1.toRprLEM(buff, pos, p);\n        } else {\n            curve.G1.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F1.n8*2;\n    }\n\n    async function writeG2(p) {\n        if (montgomery) {\n            curve.G2.toRprLEM(buff, pos, p);\n        } else {\n            curve.G2.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F2.n8*2;\n    }\n\n    return buff;\n}\n\nasync function writePtauPubKey(fd, curve, key, montgomery) {\n    const buff = new Uint8Array(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n    toPtauPubKeyRpr(buff, 0, curve, key, montgomery);\n    await fd.write(buff);\n}\n\nasync function readContribution(fd, curve) {\n    const c = {};\n\n    c.tauG1 = await readG1();\n    c.tauG2 = await readG2();\n    c.alphaG1 = await readG1();\n    c.betaG1 = await readG1();\n    c.betaG2 = await readG2();\n    c.key = await readPtauPubKey(fd, curve, true);\n    c.partialHash = await fd.read(216);\n    c.nextChallenge = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n    toPtauPubKeyRpr(buffV, 0, curve, c.key, false);\n\n    const responseHasher =  _misc_js__WEBPACK_IMPORTED_MODULE_2__.fromPartialHash(c.partialHash);\n    responseHasher.update(buffV);\n    c.responseHash = responseHasher.digest();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await readDV(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await readDV(1);\n            const buffStr = await readDV(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await readDV(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await readDV(1);\n            c.beaconHash = await readDV(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n\n    async function readG1() {\n        const pBuff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprLEM( pBuff );\n    }\n\n    async function readG2() {\n        const pBuff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprLEM( pBuff );\n    }\n\n    async function readDV(n) {\n        const b = await fd.read(n);\n        return new Uint8Array(b);\n    }\n}\n\nasync function readContributions(fd, curve, sections) {\n    if (!sections[7])  throw new Error(fd.fileName + \": File has no  contributions\");\n    if (sections[7][0].length>1) throw new Error(fd.fileName +\": File has more than one contributions section\");\n\n    fd.pos = sections[7][0].p;\n    const nContributions = await fd.readULE32();\n    const contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = await readContribution(fd, curve);\n        c.id = i+1;\n        contributions.push(c);\n    }\n\n    if (fd.pos-sections[7][0].p != sections[7][0].size) throw new Error(\"Invalid contribution section size\");\n\n    return contributions;\n}\n\nasync function writeContribution(fd, curve, contribution) {\n\n    const buffG1 = new Uint8Array(curve.F1.n8*2);\n    const buffG2 = new Uint8Array(curve.F2.n8*2);\n    await writeG1(contribution.tauG1);\n    await writeG2(contribution.tauG2);\n    await writeG1(contribution.alphaG1);\n    await writeG1(contribution.betaG1);\n    await writeG2(contribution.betaG2);\n    await writePtauPubKey(fd, curve, contribution.key, true);\n    await fd.write(contribution.partialHash);\n    await fd.write(contribution.nextChallenge);\n    await fd.writeULE32(contribution.type || 0);\n\n    const params = [];\n    if (contribution.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(contribution.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (contribution.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(contribution.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(contribution.beaconHash.byteLength);\n        for (let i=0; i<contribution.beaconHash.byteLength; i++) params.push(contribution.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n\n    async function writeG1(p) {\n        curve.G1.toRprLEM(buffG1, 0, p);\n        await fd.write(buffG1);\n    }\n\n    async function writeG2(p) {\n        curve.G2.toRprLEM(buffG2, 0, p);\n        await fd.write(buffG2);\n    }\n\n}\n\nasync function writeContributions(fd, curve, contributions) {\n\n    await fd.writeULE32(7); // Header type\n    const pContributionsSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(contributions.length);\n    for (let i=0; i< contributions.length; i++) {\n        await writeContribution(fd, curve, contributions[i]);\n    }\n    const contributionsSize = fd.pos - pContributionsSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(contributionsSize, pContributionsSize);\n    fd.pos = oldPos;\n}\n\nfunction calculateFirstChallengeHash(curve, power, logger) {\n    if (logger) logger.debug(\"Calculating First Challenge Hash\");\n\n    const hasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n\n    const vG1 = new Uint8Array(curve.G1.F.n8*2);\n    const vG2 = new Uint8Array(curve.G2.F.n8*2);\n    curve.G1.toRprUncompressed(vG1, 0, curve.G1.g);\n    curve.G2.toRprUncompressed(vG2, 0, curve.G2.g);\n\n    hasher.update(_noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 }).digest());\n\n    let n;\n\n    n=(2 ** power)*2 -1;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG1\");\n    hashBlock(vG1, n);\n    n= 2 ** power;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG2\");\n    hashBlock(vG2, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: alphaTauG1\");\n    hashBlock(vG1, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: betaTauG1\");\n    hashBlock(vG1, n);\n    hasher.update(vG2);\n\n    return hasher.digest();\n\n    function hashBlock(buff, n) {\n        // this block size is a good compromise between speed and the maximum\n        // input size of the Blake2b update method (65,535,720 bytes).\n        const blockSize = 341000;\n        const nBlocks = Math.floor(n / blockSize);\n        const rem = n % blockSize;\n        const bigBuff = new Uint8Array(blockSize * buff.byteLength);\n        for (let i=0; i<blockSize; i++) {\n            bigBuff.set(buff, i*buff.byteLength);\n        }\n        for (let i=0; i<nBlocks; i++) {\n            hasher.update(bigBuff);\n            if (logger) logger.debug(\"Initial hash: \" +i*blockSize);\n        }\n        for (let i=0; i<rem; i++) {\n            hasher.update(buff);\n        }\n    }\n}\n\n\nasync function keyFromBeacon(curve, challengeHash, beaconHash, numIterationsExp) {\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_2__.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const key = _keypair_js__WEBPACK_IMPORTED_MODULE_1__.createPTauKey(curve, challengeHash, rng);\n\n    return key;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0M7QUFDVTtBQUNSO0FBQ047QUFDVTs7QUFFckM7QUFDUDtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBLG1EQUFtRDtBQUNuRCxzREFBc0Q7O0FBRXREOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0RBQU07O0FBRXBCLHdCQUF3Qix5REFBYTs7QUFFckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxZQUFZO0FBQ1o7OztBQUdPOztBQUVQOztBQUVBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixxREFBb0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0Esc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPOztBQUVQLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQSxtQkFBbUIsMERBQU8sVUFBVSxXQUFXOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsMERBQU8sVUFBVSxXQUFXOztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTzs7QUFFUCxzQkFBc0IseURBQXdCOztBQUU5QyxnQkFBZ0Isc0RBQXFCOztBQUVyQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyBrZXlQYWlyIGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVQVGF1SGVhZGVyKGZkLCBjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXIpIHtcbiAgICAvLyBXcml0ZSB0aGUgaGVhZGVyXG4gICAgLy8vLy8vLy8vLy9cblxuICAgIGlmICghIGNlcmVtb255UG93ZXIpIGNlcmVtb255UG93ZXIgPSBwb3dlcjtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDEpOyAvLyBIZWFkZXIgdHlwZVxuICAgIGNvbnN0IHBIZWFkZXJTaXplID0gZmQucG9zO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFNjQoMCk7IC8vIFRlbXBvcmFsbHkgc2V0IHRvIDAgbGVuZ3RoXG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGN1cnZlLkYxLm42NCo4KTtcblxuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCk7XG4gICAgU2NhbGFyLnRvUnByTEUoYnVmZiwgMCwgY3VydmUucSwgY3VydmUuRjEubjgpO1xuICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmYpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIocG93ZXIpOyAgICAgICAgICAgICAgICAgICAgLy8gcG93ZXJcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGNlcmVtb255UG93ZXIpOyAgICAgICAgICAgICAgIC8vIHBvd2VyXG5cbiAgICBjb25zdCBoZWFkZXJTaXplID0gZmQucG9zIC0gcEhlYWRlclNpemUgLSA4O1xuXG4gICAgY29uc3Qgb2xkUG9zID0gZmQucG9zO1xuXG4gICAgYXdhaXQgZmQud3JpdGVVTEU2NChoZWFkZXJTaXplLCBwSGVhZGVyU2l6ZSk7XG5cbiAgICBmZC5wb3MgPSBvbGRQb3M7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkUFRhdUhlYWRlcihmZCwgc2VjdGlvbnMpIHtcbiAgICBpZiAoIXNlY3Rpb25zWzFdKSAgdGhyb3cgbmV3IEVycm9yKGZkLmZpbGVOYW1lICsgXCI6IEZpbGUgaGFzIG5vICBoZWFkZXJcIik7XG4gICAgaWYgKHNlY3Rpb25zWzFdLmxlbmd0aD4xKSB0aHJvdyBuZXcgRXJyb3IoZmQuZmlsZU5hbWUgK1wiOiBGaWxlIGhhcyBtb3JlIHRoYW4gb25lIGhlYWRlclwiKTtcblxuICAgIGZkLnBvcyA9IHNlY3Rpb25zWzFdWzBdLnA7XG4gICAgY29uc3QgbjggPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChuOCk7XG4gICAgY29uc3QgcSA9IFNjYWxhci5mcm9tUnByTEUoYnVmZik7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbVEocSk7XG5cbiAgICBpZiAoY3VydmUuRjEubjY0KjggIT0gbjgpIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArXCI6IEludmFsaWQgc2l6ZVwiKTtcblxuICAgIGNvbnN0IHBvd2VyID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgY29uc3QgY2VyZW1vbnlQb3dlciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuXG4gICAgaWYgKGZkLnBvcy1zZWN0aW9uc1sxXVswXS5wICE9IHNlY3Rpb25zWzFdWzBdLnNpemUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUFRhdSBoZWFkZXIgc2l6ZVwiKTtcblxuICAgIHJldHVybiB7Y3VydmUsIHBvd2VyLCBjZXJlbW9ueVBvd2VyfTtcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZFB0YXVQdWJLZXkoZmQsIGN1cnZlLCBtb250Z29tZXJ5KSB7XG5cbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5GMS5uOCoyKjYgKyBjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgcmV0dXJuIGZyb21QdGF1UHViS2V5UnByKGJ1ZmYsIDAsIGN1cnZlLCBtb250Z29tZXJ5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21QdGF1UHViS2V5UnByKGJ1ZmYsIHBvcywgY3VydmUsIG1vbnRnb21lcnkpIHtcblxuICAgIGNvbnN0IGtleSA9IHtcbiAgICAgICAgdGF1OiB7fSxcbiAgICAgICAgYWxwaGE6IHt9LFxuICAgICAgICBiZXRhOiB7fVxuICAgIH07XG5cbiAgICBrZXkudGF1LmcxX3MgPSByZWFkRzEoKTtcbiAgICBrZXkudGF1LmcxX3N4ID0gcmVhZEcxKCk7XG4gICAga2V5LmFscGhhLmcxX3MgPSByZWFkRzEoKTtcbiAgICBrZXkuYWxwaGEuZzFfc3ggPSByZWFkRzEoKTtcbiAgICBrZXkuYmV0YS5nMV9zID0gcmVhZEcxKCk7XG4gICAga2V5LmJldGEuZzFfc3ggPSByZWFkRzEoKTtcbiAgICBrZXkudGF1LmcyX3NweCA9IHJlYWRHMigpO1xuICAgIGtleS5hbHBoYS5nMl9zcHggPSByZWFkRzIoKTtcbiAgICBrZXkuYmV0YS5nMl9zcHggPSByZWFkRzIoKTtcblxuICAgIHJldHVybiBrZXk7XG5cbiAgICBmdW5jdGlvbiByZWFkRzEoKSB7XG4gICAgICAgIGxldCBwO1xuICAgICAgICBpZiAobW9udGdvbWVyeSkge1xuICAgICAgICAgICAgcCA9IGN1cnZlLkcxLmZyb21ScHJMRU0oIGJ1ZmYsIHBvcyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IGN1cnZlLkcxLmZyb21ScHJVbmNvbXByZXNzZWQoIGJ1ZmYsIHBvcyApO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRHMigpIHtcbiAgICAgICAgbGV0IHA7XG4gICAgICAgIGlmIChtb250Z29tZXJ5KSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzIuZnJvbVJwckxFTSggYnVmZiwgcG9zICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzIuZnJvbVJwclVuY29tcHJlc3NlZCggYnVmZiwgcG9zICk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGN1cnZlLkcyLkYubjgqMjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9QdGF1UHViS2V5UnByKGJ1ZmYsIHBvcywgY3VydmUsIGtleSwgbW9udGdvbWVyeSkge1xuXG4gICAgd3JpdGVHMShrZXkudGF1LmcxX3MpO1xuICAgIHdyaXRlRzEoa2V5LnRhdS5nMV9zeCk7XG4gICAgd3JpdGVHMShrZXkuYWxwaGEuZzFfcyk7XG4gICAgd3JpdGVHMShrZXkuYWxwaGEuZzFfc3gpO1xuICAgIHdyaXRlRzEoa2V5LmJldGEuZzFfcyk7XG4gICAgd3JpdGVHMShrZXkuYmV0YS5nMV9zeCk7XG4gICAgd3JpdGVHMihrZXkudGF1LmcyX3NweCk7XG4gICAgd3JpdGVHMihrZXkuYWxwaGEuZzJfc3B4KTtcbiAgICB3cml0ZUcyKGtleS5iZXRhLmcyX3NweCk7XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUcxKHApIHtcbiAgICAgICAgaWYgKG1vbnRnb21lcnkpIHtcbiAgICAgICAgICAgIGN1cnZlLkcxLnRvUnByTEVNKGJ1ZmYsIHBvcywgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJ2ZS5HMS50b1JwclVuY29tcHJlc3NlZChidWZmLCBwb3MsIHApO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjdXJ2ZS5GMS5uOCoyO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIocCkge1xuICAgICAgICBpZiAobW9udGdvbWVyeSkge1xuICAgICAgICAgICAgY3VydmUuRzIudG9ScHJMRU0oYnVmZiwgcG9zLCBwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnZlLkcyLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIHBvcywgcCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGN1cnZlLkYyLm44KjI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZVB0YXVQdWJLZXkoZmQsIGN1cnZlLCBrZXksIG1vbnRnb21lcnkpIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMio2ICsgY3VydmUuRjIubjgqMiozKTtcbiAgICB0b1B0YXVQdWJLZXlScHIoYnVmZiwgMCwgY3VydmUsIGtleSwgbW9udGdvbWVyeSk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDb250cmlidXRpb24oZmQsIGN1cnZlKSB7XG4gICAgY29uc3QgYyA9IHt9O1xuXG4gICAgYy50YXVHMSA9IGF3YWl0IHJlYWRHMSgpO1xuICAgIGMudGF1RzIgPSBhd2FpdCByZWFkRzIoKTtcbiAgICBjLmFscGhhRzEgPSBhd2FpdCByZWFkRzEoKTtcbiAgICBjLmJldGFHMSA9IGF3YWl0IHJlYWRHMSgpO1xuICAgIGMuYmV0YUcyID0gYXdhaXQgcmVhZEcyKCk7XG4gICAgYy5rZXkgPSBhd2FpdCByZWFkUHRhdVB1YktleShmZCwgY3VydmUsIHRydWUpO1xuICAgIGMucGFydGlhbEhhc2ggPSBhd2FpdCBmZC5yZWFkKDIxNik7XG4gICAgYy5uZXh0Q2hhbGxlbmdlID0gYXdhaXQgZmQucmVhZCg2NCk7XG4gICAgYy50eXBlID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG5cbiAgICBjb25zdCBidWZmViAgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIqNitjdXJ2ZS5HMi5GLm44KjIqMyk7XG4gICAgdG9QdGF1UHViS2V5UnByKGJ1ZmZWLCAwLCBjdXJ2ZSwgYy5rZXksIGZhbHNlKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSGFzaGVyID0gIG1pc2MuZnJvbVBhcnRpYWxIYXNoKGMucGFydGlhbEhhc2gpO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmVik7XG4gICAgYy5yZXNwb25zZUhhc2ggPSByZXNwb25zZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGNvbnN0IHBhcmFtTGVuZ3RoID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgY29uc3QgY3VyUG9zID0gZmQucG9zO1xuICAgIGxldCBsYXN0VHlwZSA9MDtcbiAgICB3aGlsZSAoZmQucG9zLWN1clBvcyA8IHBhcmFtTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZUeXBlID0gYXdhaXQgcmVhZERWKDEpO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF08PSBsYXN0VHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVycyBpbiB0aGUgY29udHJpYnV0aW9uIG11c3QgYmUgc29ydGVkXCIpO1xuICAgICAgICBsYXN0VHlwZSA9IGJ1ZmZUeXBlWzBdO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF09PTEpIHsgICAgIC8vIE5hbWVcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMZW4gPSBhd2FpdCByZWFkRFYoMSk7XG4gICAgICAgICAgICBjb25zdCBidWZmU3RyID0gYXdhaXQgcmVhZERWKGJ1ZmZMZW5bMF0pO1xuICAgICAgICAgICAgYy5uYW1lID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZTdHIpO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZUeXBlWzBdPT0yKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmRXhwID0gYXdhaXQgcmVhZERWKDEpO1xuICAgICAgICAgICAgYy5udW1JdGVyYXRpb25zRXhwID0gYnVmZkV4cFswXTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmVHlwZVswXT09Mykge1xuICAgICAgICAgICAgY29uc3QgYnVmZkxlbiA9IGF3YWl0IHJlYWREVigxKTtcbiAgICAgICAgICAgIGMuYmVhY29uSGFzaCA9IGF3YWl0IHJlYWREVihidWZmTGVuWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBub3QgcmVjb2duaXplZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmQucG9zICE9IGN1clBvcyArIHBhcmFtTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlcnMgZG8gbm90IG1hdGNoXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBjO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcxKCkge1xuICAgICAgICBjb25zdCBwQnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcxLmZyb21ScHJMRU0oIHBCdWZmICk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcyKCkge1xuICAgICAgICBjb25zdCBwQnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzIuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcyLmZyb21ScHJMRU0oIHBCdWZmICk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZERWKG4pIHtcbiAgICAgICAgY29uc3QgYiA9IGF3YWl0IGZkLnJlYWQobik7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiKTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkQ29udHJpYnV0aW9ucyhmZCwgY3VydmUsIHNlY3Rpb25zKSB7XG4gICAgaWYgKCFzZWN0aW9uc1s3XSkgIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArIFwiOiBGaWxlIGhhcyBubyAgY29udHJpYnV0aW9uc1wiKTtcbiAgICBpZiAoc2VjdGlvbnNbN11bMF0ubGVuZ3RoPjEpIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArXCI6IEZpbGUgaGFzIG1vcmUgdGhhbiBvbmUgY29udHJpYnV0aW9ucyBzZWN0aW9uXCIpO1xuXG4gICAgZmQucG9zID0gc2VjdGlvbnNbN11bMF0ucDtcbiAgICBjb25zdCBuQ29udHJpYnV0aW9ucyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bkNvbnRyaWJ1dGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbihmZCwgY3VydmUpO1xuICAgICAgICBjLmlkID0gaSsxO1xuICAgICAgICBjb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgaWYgKGZkLnBvcy1zZWN0aW9uc1s3XVswXS5wICE9IHNlY3Rpb25zWzddWzBdLnNpemUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29udHJpYnV0aW9uIHNlY3Rpb24gc2l6ZVwiKTtcblxuICAgIHJldHVybiBjb250cmlidXRpb25zO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsIGNvbnRyaWJ1dGlvbikge1xuXG4gICAgY29uc3QgYnVmZkcxID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMik7XG4gICAgY29uc3QgYnVmZkcyID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjIubjgqMik7XG4gICAgYXdhaXQgd3JpdGVHMShjb250cmlidXRpb24udGF1RzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoY29udHJpYnV0aW9uLnRhdUcyKTtcbiAgICBhd2FpdCB3cml0ZUcxKGNvbnRyaWJ1dGlvbi5hbHBoYUcxKTtcbiAgICBhd2FpdCB3cml0ZUcxKGNvbnRyaWJ1dGlvbi5iZXRhRzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoY29udHJpYnV0aW9uLmJldGFHMik7XG4gICAgYXdhaXQgd3JpdGVQdGF1UHViS2V5KGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9uLmtleSwgdHJ1ZSk7XG4gICAgYXdhaXQgZmQud3JpdGUoY29udHJpYnV0aW9uLnBhcnRpYWxIYXNoKTtcbiAgICBhd2FpdCBmZC53cml0ZShjb250cmlidXRpb24ubmV4dENoYWxsZW5nZSk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb250cmlidXRpb24udHlwZSB8fCAwKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGlmIChjb250cmlidXRpb24ubmFtZSkge1xuICAgICAgICBwYXJhbXMucHVzaCgxKTsgICAgICAvLyBQYXJhbSBOYW1lXG4gICAgICAgIGNvbnN0IG5hbWVEYXRhID0gbmV3IFRleHRFbmNvZGVyKFwidXRmLThcIikuZW5jb2RlKGNvbnRyaWJ1dGlvbi5uYW1lLnN1YnN0cmluZygwLDY0KSk7XG4gICAgICAgIHBhcmFtcy5wdXNoKG5hbWVEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bmFtZURhdGEuYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChuYW1lRGF0YVtpXSk7XG4gICAgfVxuICAgIGlmIChjb250cmlidXRpb24udHlwZSA9PSAxKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKDIpOyAgICAgIC8vIFBhcmFtIG51bUl0ZXJhdGlvbnNFeHBcbiAgICAgICAgcGFyYW1zLnB1c2goY29udHJpYnV0aW9uLm51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgICAgIHBhcmFtcy5wdXNoKDMpOyAgICAgIC8vIEJlYWNvbiBIYXNoXG4gICAgICAgIHBhcmFtcy5wdXNoKGNvbnRyaWJ1dGlvbi5iZWFjb25IYXNoLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29udHJpYnV0aW9uLmJlYWNvbkhhc2guYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChjb250cmlidXRpb24uYmVhY29uSGFzaFtpXSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGVuZ3RoPjApIHtcbiAgICAgICAgY29uc3QgcGFyYW1zQnVmZiA9IG5ldyBVaW50OEFycmF5KHBhcmFtcyk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIocGFyYW1zQnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUocGFyYW1zQnVmZik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMigwKTtcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEocCkge1xuICAgICAgICBjdXJ2ZS5HMS50b1JwckxFTShidWZmRzEsIDAsIHApO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIocCkge1xuICAgICAgICBjdXJ2ZS5HMi50b1JwckxFTShidWZmRzIsIDAsIHApO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzIpO1xuICAgIH1cblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVDb250cmlidXRpb25zKGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9ucykge1xuXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMig3KTsgLy8gSGVhZGVyIHR5cGVcbiAgICBjb25zdCBwQ29udHJpYnV0aW9uc1NpemUgPSBmZC5wb3M7XG4gICAgYXdhaXQgZmQud3JpdGVVTEU2NCgwKTsgLy8gVGVtcG9yYWxseSBzZXQgdG8gMCBsZW5ndGhcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY29udHJpYnV0aW9ucy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGk9MDsgaTwgY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsIGNvbnRyaWJ1dGlvbnNbaV0pO1xuICAgIH1cbiAgICBjb25zdCBjb250cmlidXRpb25zU2l6ZSA9IGZkLnBvcyAtIHBDb250cmlidXRpb25zU2l6ZSAtIDg7XG5cbiAgICBjb25zdCBvbGRQb3MgPSBmZC5wb3M7XG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KGNvbnRyaWJ1dGlvbnNTaXplLCBwQ29udHJpYnV0aW9uc1NpemUpO1xuICAgIGZkLnBvcyA9IG9sZFBvcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNhbGN1bGF0aW5nIEZpcnN0IENoYWxsZW5nZSBIYXNoXCIpO1xuXG4gICAgY29uc3QgaGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG5cbiAgICBjb25zdCB2RzEgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIpO1xuICAgIGNvbnN0IHZHMiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcyLkYubjgqMik7XG4gICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQodkcxLCAwLCBjdXJ2ZS5HMS5nKTtcbiAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZCh2RzIsIDAsIGN1cnZlLkcyLmcpO1xuXG4gICAgaGFzaGVyLnVwZGF0ZShibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KS5kaWdlc3QoKSk7XG5cbiAgICBsZXQgbjtcblxuICAgIG49KDIgKiogcG93ZXIpKjIgLTE7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQ2FsY3VsYXRlIEluaXRpYWwgSGFzaDogdGF1RzFcIik7XG4gICAgaGFzaEJsb2NrKHZHMSwgbik7XG4gICAgbj0gMiAqKiBwb3dlcjtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDYWxjdWxhdGUgSW5pdGlhbCBIYXNoOiB0YXVHMlwiKTtcbiAgICBoYXNoQmxvY2sodkcyLCBuKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDYWxjdWxhdGUgSW5pdGlhbCBIYXNoOiBhbHBoYVRhdUcxXCIpO1xuICAgIGhhc2hCbG9jayh2RzEsIG4pO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNhbGN1bGF0ZSBJbml0aWFsIEhhc2g6IGJldGFUYXVHMVwiKTtcbiAgICBoYXNoQmxvY2sodkcxLCBuKTtcbiAgICBoYXNoZXIudXBkYXRlKHZHMik7XG5cbiAgICByZXR1cm4gaGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgZnVuY3Rpb24gaGFzaEJsb2NrKGJ1ZmYsIG4pIHtcbiAgICAgICAgLy8gdGhpcyBibG9jayBzaXplIGlzIGEgZ29vZCBjb21wcm9taXNlIGJldHdlZW4gc3BlZWQgYW5kIHRoZSBtYXhpbXVtXG4gICAgICAgIC8vIGlucHV0IHNpemUgb2YgdGhlIEJsYWtlMmIgdXBkYXRlIG1ldGhvZCAoNjUsNTM1LDcyMCBieXRlcykuXG4gICAgICAgIGNvbnN0IGJsb2NrU2l6ZSA9IDM0MTAwMDtcbiAgICAgICAgY29uc3QgbkJsb2NrcyA9IE1hdGguZmxvb3IobiAvIGJsb2NrU2l6ZSk7XG4gICAgICAgIGNvbnN0IHJlbSA9IG4gJSBibG9ja1NpemU7XG4gICAgICAgIGNvbnN0IGJpZ0J1ZmYgPSBuZXcgVWludDhBcnJheShibG9ja1NpemUgKiBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YmxvY2tTaXplOyBpKyspIHtcbiAgICAgICAgICAgIGJpZ0J1ZmYuc2V0KGJ1ZmYsIGkqYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkJsb2NrczsgaSsrKSB7XG4gICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJpZ0J1ZmYpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiSW5pdGlhbCBoYXNoOiBcIiAraSpibG9ja1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZW07IGkrKykge1xuICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShidWZmKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24ga2V5RnJvbUJlYWNvbihjdXJ2ZSwgY2hhbGxlbmdlSGFzaCwgYmVhY29uSGFzaCwgbnVtSXRlcmF0aW9uc0V4cCkge1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5ybmdGcm9tQmVhY29uUGFyYW1zKGJlYWNvbkhhc2gsIG51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgY29uc3Qga2V5ID0ga2V5UGFpci5jcmVhdGVQVGF1S2V5KGN1cnZlLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuXG4gICAgcmV0dXJuIGtleTtcbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/powersoftau_verify.js":
/*!********************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_verify.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst sameRatio = _misc_js__WEBPACK_IMPORTED_MODULE_4__.sameRatio;\n\nasync function verifyContribution(curve, cur, prev, logger) {\n    let sr;\n    if (cur.type == 1) {    // Verify the beacon.\n        const beaconKey = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.keyFromBeacon(curve, prev.nextChallenge, cur.beaconHash, cur.numIterationsExp);\n\n        if (!curve.G1.eq(cur.key.tau.g1_s, beaconKey.tau.g1_s)) {\n            if (logger) logger.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.tau.g1_sx, beaconKey.tau.g1_sx)) {\n            if (logger) logger.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.tau.g2_spx, beaconKey.tau.g2_spx)) {\n            if (logger) logger.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.alpha.g1_s, beaconKey.alpha.g1_s)) {\n            if (logger) logger.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.alpha.g1_sx, beaconKey.alpha.g1_sx)) {\n            if (logger) logger.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.alpha.g2_spx, beaconKey.alpha.g2_spx)) {\n            if (logger) logger.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.beta.g1_s, beaconKey.beta.g1_s)) {\n            if (logger) logger.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.beta.g1_sx, beaconKey.beta.g1_sx)) {\n            if (logger) logger.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.beta.g2_spx, beaconKey.beta.g2_spx)) {\n            if (logger) logger.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n    }\n\n    cur.key.tau.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_1__.getG2sp(curve, 0, prev.nextChallenge, cur.key.tau.g1_s, cur.key.tau.g1_sx));\n    cur.key.alpha.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_1__.getG2sp(curve, 1, prev.nextChallenge, cur.key.alpha.g1_s, cur.key.alpha.g1_sx));\n    cur.key.beta.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_1__.getG2sp(curve, 2, prev.nextChallenge, cur.key.beta.g1_s, cur.key.beta.g1_sx));\n\n    sr = await sameRatio(curve, cur.key.tau.g1_s, cur.key.tau.g1_sx, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (tau) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.alpha.g1_s, cur.key.alpha.g1_sx, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (alpha) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.beta.g1_s, cur.key.beta.g1_sx, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (beta) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.tauG1, cur.tauG1, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.tau.g1_s, cur.key.tau.g1_sx, prev.tauG2, cur.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G2. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.alphaG1, cur.alphaG1, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID alpha*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.betaG1, cur.betaG1, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.beta.g1_s, cur.key.beta.g1_sx, prev.betaG2, cur.betaG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G2. challenge #\"+cur.id+\"It does not follow the previous contribution\");\n        return false;\n    }\n\n    if (logger) logger.info(\"Powers Of tau file OK!\");\n    return true;\n}\n\nasync function verify(tauFilename, logger) {\n    let sr;\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile(tauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readPTauHeader(fd, sections);\n    const contrs = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readContributions(fd, curve, sections);\n\n    if (logger) logger.debug(\"power: 2**\" + power);\n    // Verify Last contribution\n\n    if (logger) logger.debug(\"Computing initial contribution hash\");\n    const initialContribution = {\n        tauG1: curve.G1.g,\n        tauG2: curve.G2.g,\n        alphaG1: curve.G1.g,\n        betaG1: curve.G1.g,\n        betaG2: curve.G2.g,\n        nextChallenge: _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.calculateFirstChallengeHash(curve, ceremonyPower, logger),\n        responseHash: _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 }).digest()\n    };\n\n    if (contrs.length == 0) {\n        if (logger) logger.error(\"This file has no contribution! It cannot be used in production\");\n        return false;\n    }\n\n    let prevContr;\n    if (contrs.length>1) {\n        prevContr = contrs[contrs.length-2];\n    } else {\n        prevContr = initialContribution;\n    }\n    const curContr = contrs[contrs.length-1];\n    if (logger) logger.debug(\"Validating contribution #\"+contrs[contrs.length-1].id);\n    const res = await verifyContribution(curve, curContr, prevContr, logger);\n    if (!res) return false;\n\n\n    const nextContributionHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 });\n    nextContributionHasher.update(curContr.responseHash);\n\n    // Verify powers and compute nextChallengeHash\n\n    // await test();\n\n    // Verify Section tau*G1\n    if (logger) logger.debug(\"Verifying powers in tau*G1 section\");\n    const rTau1 = await processSection(2, \"G1\", \"tauG1\", (2 ** power)*2-1, [0, 1], logger);\n    sr = await sameRatio(curve, rTau1.R1, rTau1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curve.G1.g, rTau1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G1 section must be the generator\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.tauG1, rTau1.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G1 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // await test();\n\n    // Verify Section tau*G2\n    if (logger) logger.debug(\"Verifying powers in tau*G2 section\");\n    const rTau2 = await processSection(3, \"G2\", \"tauG2\", 2 ** power, [0, 1],  logger);\n    sr = await sameRatio(curve, curve.G1.g, curContr.tauG1, rTau2.R1, rTau2.R2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG2 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G2.eq(curve.G2.g, rTau2.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G2 section must be the generator\");\n        return false;\n    }\n    if (!curve.G2.eq(curContr.tauG2, rTau2.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section alpha*tau*G1\n    if (logger) logger.debug(\"Verifying powers in alpha*tau*G1 section\");\n    const rAlphaTauG1 = await processSection(4, \"G1\", \"alphatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rAlphaTauG1.R1, rAlphaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"alphaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.alphaG1, rAlphaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section beta*tau*G1\n    if (logger) logger.debug(\"Verifying powers in beta*tau*G1 section\");\n    const rBetaTauG1 = await processSection(5, \"G1\", \"betatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rBetaTauG1.R1, rBetaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"betaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.betaG1, rBetaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    //Verify Beta G2\n    const betaG2 = await processSectionBetaG2(logger);\n    if (!curve.G2.eq(curContr.betaG2, betaG2)) {\n        if (logger) logger.error(\"betaG2 element in betaG2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n\n    const nextContributionHash = nextContributionHasher.digest();\n\n    // Check the nextChallengeHash\n    if (power == ceremonyPower) {\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(nextContributionHash,curContr.nextChallenge)) {\n            if (logger) logger.error(\"Hash of the values does not match the next challenge of the last contributor in the contributions section\");\n            return false;\n        }\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(nextContributionHash, \"Next challenge hash: \"));\n\n    // Verify Previous contributions\n\n    printContribution(curContr, prevContr);\n    for (let i = contrs.length-2; i>=0; i--) {\n        const curContr = contrs[i];\n        const prevContr =  (i>0) ? contrs[i-1] : initialContribution;\n        const res = await verifyContribution(curve, curContr, prevContr, logger);\n        if (!res) return false;\n        printContribution(curContr, prevContr, logger);\n    }\n    if (logger) logger.info(\"-----------------------------------------------------\");\n\n    if ((!sections[12]) || (!sections[13]) || (!sections[14]) || (!sections[15])) {\n        if (logger) logger.warn(\n            \"this file does not contain phase2 precalculated values. Please run: \\n\" +\n            \"   snarkjs \\\"powersoftau preparephase2\\\" to prepare this file to be used in the phase2 ceremony.\"\n        );\n    } else {\n        let res;\n        res = await verifyLagrangeEvaluations(\"G1\", 2, 12, \"tauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G2\", 3, 13, \"tauG2\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 4, 14, \"alphaTauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 5, 15, \"betaTauG1\", logger);\n        if (!res) return false;\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"Powers of Tau Ok!\");\n\n    return true;\n\n    function printContribution(curContr, prevContr) {\n        if (!logger) return;\n        logger.info(\"-----------------------------------------------------\");\n        logger.info(`Contribution #${curContr.id}: ${curContr.name ||\"\"}`);\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(curContr.nextChallenge, \"Next Challenge: \"));\n\n        const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n        _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.toPtauPubKeyRpr(buffV, 0, curve, curContr.key, false);\n\n        const responseHasher =  _misc_js__WEBPACK_IMPORTED_MODULE_4__.fromPartialHash(curContr.partialHash);\n        responseHasher.update(buffV);\n        const responseHash = responseHasher.digest();\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(responseHash, \"Response Hash:\"));\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(prevContr.nextChallenge, \"Response Hash:\"));\n\n        if (curContr.type == 1) {\n            logger.info(`Beacon generator: ${_misc_js__WEBPACK_IMPORTED_MODULE_4__.byteArray2hex(curContr.beaconHash)}`);\n            logger.info(`Beacon iterations Exp: ${curContr.numIterationsExp}`);\n        }\n\n    }\n\n    async function processSectionBetaG2(logger) {\n        const G = curve.G2;\n        const sG = G.F.n8*2;\n        const buffUv = new Uint8Array(sG);\n\n        if (!sections[6])  {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has no BetaG2 section\");\n        }\n        if (sections[6].length>1) {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has more than one GetaG2 section\");\n        }\n        fd.pos = sections[6][0].p;\n\n        const buff = await fd.read(sG);\n        const P = G.fromRprLEM(buff);\n\n        G.toRprUncompressed(buffUv, 0, P);\n        nextContributionHasher.update(buffUv);\n\n        return P;\n    }\n\n    async function processSection(idSection, groupName, sectionName, nPoints, singularPointIndexes, logger) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startReadUniqueSection(fd, sections, idSection);\n\n        const singularPoints = [];\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        let lastBase = G.zero;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`points relations: ${sectionName}: ${i}/${nPoints} `);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases = await fd.read(n*sG);\n\n            const basesU = await G.batchLEMtoU(bases);\n            nextContributionHasher.update(basesU);\n\n            const scalars = _misc_js__WEBPACK_IMPORTED_MODULE_4__.getRandomBytes(4*(n-1));\n\n            if (i>0) {\n                const firstBase = G.fromRprLEM(bases, 0);\n                const r = _misc_js__WEBPACK_IMPORTED_MODULE_4__.readUInt32BE(_misc_js__WEBPACK_IMPORTED_MODULE_4__.getRandomBytes(4), 0);\n\n                R1 = G.add(R1, G.timesScalar(lastBase, r));\n                R2 = G.add(R2, G.timesScalar(firstBase, r));\n            }\n\n            const r1 = await G.multiExpAffine(bases.slice(0, (n-1)*sG), scalars);\n            const r2 = await G.multiExpAffine(bases.slice(sG), scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n\n            lastBase = G.fromRprLEM( bases, (n-1)*sG);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(bases, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endReadSection(fd);\n\n        return {\n            R1: R1,\n            R2: R2,\n            singularPoints: singularPoints\n        };\n\n    }\n\n    async function verifyLagrangeEvaluations(gName, tauSection, lagrangeSection, sectionName, logger) {\n\n        if (logger) logger.debug(`Verifying phase2 calculated values ${sectionName}...`);\n        const G = curve[gName];\n        const sG = G.F.n8*2;\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = _misc_js__WEBPACK_IMPORTED_MODULE_4__.readUInt32BE(_misc_js__WEBPACK_IMPORTED_MODULE_4__.getRandomBytes(4), 0);\n        }\n\n        for (let p=0; p<= power; p ++) {\n            const res = await verifyPower(p);\n            if (!res) return false;\n        }\n\n        if (tauSection == 2) {\n            const res = await verifyPower(power+1);\n            if (!res) return false;\n        }\n\n        return true;\n\n        async function verifyPower(p) {\n            if (logger) logger.debug(`Power ${p}...`);\n            const n8r = curve.Fr.n8;\n            const nPoints = 2 ** p;\n            let buff_r = new Uint32Array(nPoints);\n            let buffG;\n\n            let rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.ChaCha(seed);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((p == power+1)&&(i == nPoints-1)) {\n                    buff_r[i] = 0;\n                } else {\n                    buff_r[i] = rng.nextU32();\n                }\n            }\n\n            buff_r = new Uint8Array(buff_r.buffer, buff_r.byteOffset, buff_r.byteLength);\n\n            if (logger) logger.debug(`reading points Powers${p}...`);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startReadUniqueSection(fd, sections, tauSection);\n            buffG = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(nPoints*sG);\n            if (p == power+1) {\n                await fd.readToBuffer(buffG, 0, (nPoints-1)*sG);\n                buffG.set(curve.G1.zeroAffine, (nPoints-1)*sG);\n            } else {\n                await fd.readToBuffer(buffG, 0, nPoints*sG);\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endReadSection(fd, true);\n\n            const resTau = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p);\n\n            buff_r = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(nPoints * n8r);\n\n            rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.ChaCha(seed);\n\n            const buff4 = new Uint8Array(4);\n            const buff4V = new DataView(buff4.buffer);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((i != nPoints-1) || (p != power+1)) {\n                    buff4V.setUint32(0, rng.nextU32(), true);\n                    buff_r.set(buff4, i*n8r);\n                }\n            }\n\n            if (logger) logger.debug(`batchToMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchToMontgomery(buff_r);\n            if (logger) logger.debug(`fft ${p}...`);\n            buff_r = await curve.Fr.fft(buff_r);\n            if (logger) logger.debug(`batchFromMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchFromMontgomery(buff_r);\n\n            if (logger) logger.debug(`reading points Lagrange${p}...`);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startReadUniqueSection(fd, sections, lagrangeSection);\n            fd.pos += sG*((2 ** p)-1);\n            await fd.readToBuffer(buffG, 0, nPoints*sG);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endReadSection(fd, true);\n\n            const resLagrange = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p + \"_transformed\");\n\n            if (!G.eq(resTau, resLagrange)) {\n                if (logger) logger.error(\"Phase2 caclutation does not match with powers of tau\");\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdmVyaWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVnRDtBQUNBO0FBQ1I7QUFDWTtBQUNIO0FBQ2Y7QUFDbEMsa0JBQWtCLCtDQUFjOztBQUVoQztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGdDQUFnQyxnRUFBbUI7O0FBRW5EO0FBQ0Esc0dBQXNHLFNBQVMsRUFBRSxlQUFlO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxTQUFTLEVBQUUsZUFBZTtBQUNqSTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csU0FBUyxFQUFFLGVBQWU7QUFDbEk7QUFDQTs7QUFFQTtBQUNBLHdHQUF3RyxTQUFTLEVBQUUsZUFBZTtBQUNsSTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsU0FBUyxFQUFFLGVBQWU7QUFDbkk7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLFNBQVMsRUFBRSxlQUFlO0FBQ3BJO0FBQ0E7O0FBRUE7QUFDQSx1R0FBdUcsU0FBUyxFQUFFLGVBQWU7QUFDakk7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLFNBQVMsRUFBRSxlQUFlO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RyxTQUFTLEVBQUUsZUFBZTtBQUNuSTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLGdEQUFlO0FBQ3pELDRDQUE0QyxnREFBZTtBQUMzRCwyQ0FBMkMsZ0RBQWU7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjs7QUFFQSxXQUFXLGNBQWMsUUFBUSw0REFBd0I7QUFDekQsV0FBVyw2QkFBNkIsUUFBUSxpRUFBb0I7QUFDcEUseUJBQXlCLG9FQUF1Qjs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4RUFBaUM7QUFDeEQsc0JBQXNCLDBEQUFPLFVBQVUsV0FBVztBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxtQ0FBbUMsMERBQU8sVUFBVSxXQUFXO0FBQy9EOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpREFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQzs7QUFFQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVksSUFBSSxtQkFBbUI7O0FBRXhFLG9CQUFvQixnREFBZTs7QUFFbkM7QUFDQSxRQUFRLGtFQUFxQjs7QUFFN0IsZ0NBQWdDLHFEQUFvQjtBQUNwRDtBQUNBOztBQUVBLG9CQUFvQixnREFBZTs7QUFFbkMsb0JBQW9CLGdEQUFlOztBQUVuQztBQUNBLDZDQUE2QyxtREFBa0Isc0JBQXNCO0FBQ3JGLGtEQUFrRCwwQkFBMEI7QUFDNUU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1RUFBbUM7O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLFdBQVc7QUFDakMsMERBQTBELFlBQVksSUFBSSxFQUFFLEdBQUcsU0FBUztBQUN4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLG9EQUFtQjs7QUFFL0M7QUFDQTtBQUNBLDBCQUEwQixrREFBaUIsQ0FBQyxvREFBbUI7O0FBRS9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLCtEQUEyQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1RUFBdUUsWUFBWTtBQUNuRjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0Isc0JBQXNCLGtEQUFpQixDQUFDLG9EQUFtQjtBQUMzRDs7QUFFQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsZ0RBQU07O0FBRWhDLHNFQUFzRSxFQUFFO0FBQ3hFLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZEQUE2RCxFQUFFO0FBQy9ELGtCQUFrQix1RUFBbUM7QUFDckQsd0JBQXdCLG1EQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7QUFFN0M7O0FBRUEseUJBQXlCLG1EQUFTOztBQUVsQyxzQkFBc0IsZ0RBQU07O0FBRTVCO0FBQ0E7O0FBRUEsc0VBQXNFLEVBQUU7QUFDeEUsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsRUFBRTtBQUM1RDtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0EsNERBQTRELEVBQUU7QUFDOUQ7O0FBRUEsK0RBQStELEVBQUU7QUFDakUsa0JBQWtCLHVFQUFtQztBQUNyRDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdmVyaWZ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMga2V5UGFpciBmcm9tIFwiLi9rZXlwYWlyLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7IENoYUNoYSwgQmlnQnVmZmVyIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5jb25zdCBzYW1lUmF0aW8gPSBtaXNjLnNhbWVSYXRpbztcblxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5Q29udHJpYnV0aW9uKGN1cnZlLCBjdXIsIHByZXYsIGxvZ2dlcikge1xuICAgIGxldCBzcjtcbiAgICBpZiAoY3VyLnR5cGUgPT0gMSkgeyAgICAvLyBWZXJpZnkgdGhlIGJlYWNvbi5cbiAgICAgICAgY29uc3QgYmVhY29uS2V5ID0gYXdhaXQgdXRpbHMua2V5RnJvbUJlYWNvbihjdXJ2ZSwgcHJldi5uZXh0Q2hhbGxlbmdlLCBjdXIuYmVhY29uSGFzaCwgY3VyLm51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS50YXUuZzFfcywgYmVhY29uS2V5LnRhdS5nMV9zKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5ICh0YXVHMV9zKSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkudGF1LmcxX3N4LCBiZWFjb25LZXkudGF1LmcxX3N4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5ICh0YXVHMV9zeCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXIua2V5LnRhdS5nMl9zcHgsIGJlYWNvbktleS50YXUuZzJfc3B4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5ICh0YXVHMl9zcHgpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LmFscGhhLmcxX3MsIGJlYWNvbktleS5hbHBoYS5nMV9zKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChhbHBoYUcxX3MpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS5hbHBoYS5nMV9zeCwgYmVhY29uS2V5LmFscGhhLmcxX3N4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChhbHBoYUcxX3N4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcyLmVxKGN1ci5rZXkuYWxwaGEuZzJfc3B4LCBiZWFjb25LZXkuYWxwaGEuZzJfc3B4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChhbHBoYUcyX3NweCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkuYmV0YS5nMV9zLCBiZWFjb25LZXkuYmV0YS5nMV9zKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChiZXRhRzFfcykgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LmJldGEuZzFfc3gsIGJlYWNvbktleS5iZXRhLmcxX3N4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChiZXRhRzFfc3gpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzIuZXEoY3VyLmtleS5iZXRhLmcyX3NweCwgYmVhY29uS2V5LmJldGEuZzJfc3B4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChiZXRhRzJfc3B4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGN1ci5rZXkudGF1LmcyX3NwID0gY3VydmUuRzIudG9BZmZpbmUoa2V5UGFpci5nZXRHMnNwKGN1cnZlLCAwLCBwcmV2Lm5leHRDaGFsbGVuZ2UsIGN1ci5rZXkudGF1LmcxX3MsIGN1ci5rZXkudGF1LmcxX3N4KSk7XG4gICAgY3VyLmtleS5hbHBoYS5nMl9zcCA9IGN1cnZlLkcyLnRvQWZmaW5lKGtleVBhaXIuZ2V0RzJzcChjdXJ2ZSwgMSwgcHJldi5uZXh0Q2hhbGxlbmdlLCBjdXIua2V5LmFscGhhLmcxX3MsIGN1ci5rZXkuYWxwaGEuZzFfc3gpKTtcbiAgICBjdXIua2V5LmJldGEuZzJfc3AgPSBjdXJ2ZS5HMi50b0FmZmluZShrZXlQYWlyLmdldEcyc3AoY3VydmUsIDIsIHByZXYubmV4dENoYWxsZW5nZSwgY3VyLmtleS5iZXRhLmcxX3MsIGN1ci5rZXkuYmV0YS5nMV9zeCkpO1xuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIGN1ci5rZXkudGF1LmcxX3MsIGN1ci5rZXkudGF1LmcxX3N4LCBjdXIua2V5LnRhdS5nMl9zcCwgY3VyLmtleS50YXUuZzJfc3B4KTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCBrZXkgKHRhdSkgaW4gY2hhbGxlbmdlICNcIitjdXIuaWQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIGN1ci5rZXkuYWxwaGEuZzFfcywgY3VyLmtleS5hbHBoYS5nMV9zeCwgY3VyLmtleS5hbHBoYS5nMl9zcCwgY3VyLmtleS5hbHBoYS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGtleSAoYWxwaGEpIGluIGNoYWxsZW5nZSAjXCIrY3VyLmlkKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXIua2V5LmJldGEuZzFfcywgY3VyLmtleS5iZXRhLmcxX3N4LCBjdXIua2V5LmJldGEuZzJfc3AsIGN1ci5rZXkuYmV0YS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGtleSAoYmV0YSkgaW4gY2hhbGxlbmdlICNcIitjdXIuaWQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIHByZXYudGF1RzEsIGN1ci50YXVHMSwgY3VyLmtleS50YXUuZzJfc3AsIGN1ci5rZXkudGF1LmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgdGF1KkcxLiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCtcIiBJdCBkb2VzIG5vdCBmb2xsb3cgdGhlIHByZXZpb3VzIGNvbnRyaWJ1dGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCAgY3VyLmtleS50YXUuZzFfcywgY3VyLmtleS50YXUuZzFfc3gsIHByZXYudGF1RzIsIGN1ci50YXVHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgdGF1KkcyLiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCtcIiBJdCBkb2VzIG5vdCBmb2xsb3cgdGhlIHByZXZpb3VzIGNvbnRyaWJ1dGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBwcmV2LmFscGhhRzEsIGN1ci5hbHBoYUcxLCBjdXIua2V5LmFscGhhLmcyX3NwLCBjdXIua2V5LmFscGhhLmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgYWxwaGEqRzEuIGNoYWxsZW5nZSAjXCIrY3VyLmlkK1wiIEl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIHByZXYuYmV0YUcxLCBjdXIuYmV0YUcxLCBjdXIua2V5LmJldGEuZzJfc3AsIGN1ci5rZXkuYmV0YS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGJldGEqRzEuIGNoYWxsZW5nZSAjXCIrY3VyLmlkK1wiIEl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsICBjdXIua2V5LmJldGEuZzFfcywgY3VyLmtleS5iZXRhLmcxX3N4LCBwcmV2LmJldGFHMiwgY3VyLmJldGFHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgYmV0YSpHMi4gY2hhbGxlbmdlICNcIitjdXIuaWQrXCJJdCBkb2VzIG5vdCBmb2xsb3cgdGhlIHByZXZpb3VzIGNvbnRyaWJ1dGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUG93ZXJzIE9mIHRhdSBmaWxlIE9LIVwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5KHRhdUZpbGVuYW1lLCBsb2dnZXIpIHtcbiAgICBsZXQgc3I7XG5cbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmQsIHNlY3Rpb25zKTtcbiAgICBjb25zdCBjb250cnMgPSBhd2FpdCB1dGlscy5yZWFkQ29udHJpYnV0aW9ucyhmZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcInBvd2VyOiAyKipcIiArIHBvd2VyKTtcbiAgICAvLyBWZXJpZnkgTGFzdCBjb250cmlidXRpb25cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNvbXB1dGluZyBpbml0aWFsIGNvbnRyaWJ1dGlvbiBoYXNoXCIpO1xuICAgIGNvbnN0IGluaXRpYWxDb250cmlidXRpb24gPSB7XG4gICAgICAgIHRhdUcxOiBjdXJ2ZS5HMS5nLFxuICAgICAgICB0YXVHMjogY3VydmUuRzIuZyxcbiAgICAgICAgYWxwaGFHMTogY3VydmUuRzEuZyxcbiAgICAgICAgYmV0YUcxOiBjdXJ2ZS5HMS5nLFxuICAgICAgICBiZXRhRzI6IGN1cnZlLkcyLmcsXG4gICAgICAgIG5leHRDaGFsbGVuZ2U6IHV0aWxzLmNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgY2VyZW1vbnlQb3dlciwgbG9nZ2VyKSxcbiAgICAgICAgcmVzcG9uc2VIYXNoOiBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KS5kaWdlc3QoKVxuICAgIH07XG5cbiAgICBpZiAoY29udHJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlRoaXMgZmlsZSBoYXMgbm8gY29udHJpYnV0aW9uISBJdCBjYW5ub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHByZXZDb250cjtcbiAgICBpZiAoY29udHJzLmxlbmd0aD4xKSB7XG4gICAgICAgIHByZXZDb250ciA9IGNvbnRyc1tjb250cnMubGVuZ3RoLTJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZDb250ciA9IGluaXRpYWxDb250cmlidXRpb247XG4gICAgfVxuICAgIGNvbnN0IGN1ckNvbnRyID0gY29udHJzW2NvbnRycy5sZW5ndGgtMV07XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmFsaWRhdGluZyBjb250cmlidXRpb24gI1wiK2NvbnRyc1tjb250cnMubGVuZ3RoLTFdLmlkKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcblxuXG4gICAgY29uc3QgbmV4dENvbnRyaWJ1dGlvbkhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIG5leHRDb250cmlidXRpb25IYXNoZXIudXBkYXRlKGN1ckNvbnRyLnJlc3BvbnNlSGFzaCk7XG5cbiAgICAvLyBWZXJpZnkgcG93ZXJzIGFuZCBjb21wdXRlIG5leHRDaGFsbGVuZ2VIYXNoXG5cbiAgICAvLyBhd2FpdCB0ZXN0KCk7XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiB0YXUqRzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIHRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJUYXUxID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgXCJHMVwiLCBcInRhdUcxXCIsICgyICoqIHBvd2VyKSoyLTEsIFswLCAxXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgclRhdTEuUjEsIHJUYXUxLlIyLCBjdXJ2ZS5HMi5nLCBjdXJDb250ci50YXVHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcInRhdUcxIHNlY3Rpb24uIFBvd2VycyBkbyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXJ2ZS5HMS5nLCByVGF1MS5zaW5ndWxhclBvaW50c1swXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiRmlyc3QgZWxlbWVudCBvZiB0YXUqRzEgc2VjdGlvbiBtdXN0IGJlIHRoZSBnZW5lcmF0b3JcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXJDb250ci50YXVHMSwgclRhdTEuc2luZ3VsYXJQb2ludHNbMV0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlNlY29uZCBlbGVtZW50IG9mIHRhdSpHMSBzZWN0aW9uIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYXdhaXQgdGVzdCgpO1xuXG4gICAgLy8gVmVyaWZ5IFNlY3Rpb24gdGF1KkcyXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiB0YXUqRzIgc2VjdGlvblwiKTtcbiAgICBjb25zdCByVGF1MiA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIFwiRzJcIiwgXCJ0YXVHMlwiLCAyICoqIHBvd2VyLCBbMCwgMV0sICBsb2dnZXIpO1xuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJ2ZS5HMS5nLCBjdXJDb250ci50YXVHMSwgclRhdTIuUjEsIHJUYXUyLlIyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwidGF1RzIgc2VjdGlvbi4gUG93ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKGN1cnZlLkcyLmcsIHJUYXUyLnNpbmd1bGFyUG9pbnRzWzBdKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJGaXJzdCBlbGVtZW50IG9mIHRhdSpHMiBzZWN0aW9uIG11c3QgYmUgdGhlIGdlbmVyYXRvclwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKGN1ckNvbnRyLnRhdUcyLCByVGF1Mi5zaW5ndWxhclBvaW50c1sxXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiU2Vjb25kIGVsZW1lbnQgb2YgdGF1KkcyIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2ggdGhlIG9uZSBpbiB0aGUgY29udHJpYnV0aW9uIHNlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiBhbHBoYSp0YXUqRzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIGFscGhhKnRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJBbHBoYVRhdUcxID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNCwgXCJHMVwiLCBcImFscGhhdGF1RzFcIiwgMiAqKiBwb3dlciwgWzBdLCBsb2dnZXIpO1xuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCByQWxwaGFUYXVHMS5SMSwgckFscGhhVGF1RzEuUjIsIGN1cnZlLkcyLmcsIGN1ckNvbnRyLnRhdUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiYWxwaGFUYXVHMSBzZWN0aW9uLiBQb3dlcnMgZG8gbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoY3VyQ29udHIuYWxwaGFHMSwgckFscGhhVGF1RzEuc2luZ3VsYXJQb2ludHNbMF0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkZpcnN0IGVsZW1lbnQgb2YgYWxwaGEqdGF1KkcxIHNlY3Rpb24gKGFscGhhKkcxKSBkb2VzIG5vdCBtYXRjaCB0aGUgb25lIGluIHRoZSBjb250cmlidXRpb24gc2VjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSBTZWN0aW9uIGJldGEqdGF1KkcxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiBiZXRhKnRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJCZXRhVGF1RzEgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig1LCBcIkcxXCIsIFwiYmV0YXRhdUcxXCIsIDIgKiogcG93ZXIsIFswXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgckJldGFUYXVHMS5SMSwgckJldGFUYXVHMS5SMiwgY3VydmUuRzIuZywgY3VyQ29udHIudGF1RzIpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJiZXRhVGF1RzEgc2VjdGlvbi4gUG93ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ckNvbnRyLmJldGFHMSwgckJldGFUYXVHMS5zaW5ndWxhclBvaW50c1swXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiRmlyc3QgZWxlbWVudCBvZiBiZXRhKnRhdSpHMSBzZWN0aW9uIChiZXRhKkcxKSBkb2VzIG5vdCBtYXRjaCB0aGUgb25lIGluIHRoZSBjb250cmlidXRpb24gc2VjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vVmVyaWZ5IEJldGEgRzJcbiAgICBjb25zdCBiZXRhRzIgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbkJldGFHMihsb2dnZXIpO1xuICAgIGlmICghY3VydmUuRzIuZXEoY3VyQ29udHIuYmV0YUcyLCBiZXRhRzIpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcImJldGFHMiBlbGVtZW50IGluIGJldGFHMiBzZWN0aW9uIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBjb25zdCBuZXh0Q29udHJpYnV0aW9uSGFzaCA9IG5leHRDb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICAvLyBDaGVjayB0aGUgbmV4dENoYWxsZW5nZUhhc2hcbiAgICBpZiAocG93ZXIgPT0gY2VyZW1vbnlQb3dlcikge1xuICAgICAgICBpZiAoIW1pc2MuaGFzaElzRXF1YWwobmV4dENvbnRyaWJ1dGlvbkhhc2gsY3VyQ29udHIubmV4dENoYWxsZW5nZSkpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkhhc2ggb2YgdGhlIHZhbHVlcyBkb2VzIG5vdCBtYXRjaCB0aGUgbmV4dCBjaGFsbGVuZ2Ugb2YgdGhlIGxhc3QgY29udHJpYnV0b3IgaW4gdGhlIGNvbnRyaWJ1dGlvbnMgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChuZXh0Q29udHJpYnV0aW9uSGFzaCwgXCJOZXh0IGNoYWxsZW5nZSBoYXNoOiBcIikpO1xuXG4gICAgLy8gVmVyaWZ5IFByZXZpb3VzIGNvbnRyaWJ1dGlvbnNcblxuICAgIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIpO1xuICAgIGZvciAobGV0IGkgPSBjb250cnMubGVuZ3RoLTI7IGk+PTA7IGktLSkge1xuICAgICAgICBjb25zdCBjdXJDb250ciA9IGNvbnRyc1tpXTtcbiAgICAgICAgY29uc3QgcHJldkNvbnRyID0gIChpPjApID8gY29udHJzW2ktMV0gOiBpbml0aWFsQ29udHJpYnV0aW9uO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgfVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG5cbiAgICBpZiAoKCFzZWN0aW9uc1sxMl0pIHx8ICghc2VjdGlvbnNbMTNdKSB8fCAoIXNlY3Rpb25zWzE0XSkgfHwgKCFzZWN0aW9uc1sxNV0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgXCJ0aGlzIGZpbGUgZG9lcyBub3QgY29udGFpbiBwaGFzZTIgcHJlY2FsY3VsYXRlZCB2YWx1ZXMuIFBsZWFzZSBydW46IFxcblwiICtcbiAgICAgICAgICAgIFwiICAgc25hcmtqcyBcXFwicG93ZXJzb2Z0YXUgcHJlcGFyZXBoYXNlMlxcXCIgdG8gcHJlcGFyZSB0aGlzIGZpbGUgdG8gYmUgdXNlZCBpbiB0aGUgcGhhc2UyIGNlcmVtb255LlwiXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgcmVzID0gYXdhaXQgdmVyaWZ5TGFncmFuZ2VFdmFsdWF0aW9ucyhcIkcxXCIsIDIsIDEyLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJlcyA9IGF3YWl0IHZlcmlmeUxhZ3JhbmdlRXZhbHVhdGlvbnMoXCJHMlwiLCAzLCAxMywgXCJ0YXVHMlwiLCBsb2dnZXIpO1xuICAgICAgICBpZiAoIXJlcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXMgPSBhd2FpdCB2ZXJpZnlMYWdyYW5nZUV2YWx1YXRpb25zKFwiRzFcIiwgNCwgMTQsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgICAgICBpZiAoIXJlcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXMgPSBhd2FpdCB2ZXJpZnlMYWdyYW5nZUV2YWx1YXRpb25zKFwiRzFcIiwgNSwgMTUsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUG93ZXJzIG9mIFRhdSBPayFcIik7XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIpIHtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHJldHVybjtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYENvbnRyaWJ1dGlvbiAjJHtjdXJDb250ci5pZH06ICR7Y3VyQ29udHIubmFtZSB8fFwiXCJ9YCk7XG5cbiAgICAgICAgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGN1ckNvbnRyLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2U6IFwiKSk7XG5cbiAgICAgICAgY29uc3QgYnVmZlYgID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKjYrY3VydmUuRzIuRi5uOCoyKjMpO1xuICAgICAgICB1dGlscy50b1B0YXVQdWJLZXlScHIoYnVmZlYsIDAsIGN1cnZlLCBjdXJDb250ci5rZXksIGZhbHNlKTtcblxuICAgICAgICBjb25zdCByZXNwb25zZUhhc2hlciA9ICBtaXNjLmZyb21QYXJ0aWFsSGFzaChjdXJDb250ci5wYXJ0aWFsSGFzaCk7XG4gICAgICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmVik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGFzaCA9IHJlc3BvbnNlSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgICAgIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChyZXNwb25zZUhhc2gsIFwiUmVzcG9uc2UgSGFzaDpcIikpO1xuXG4gICAgICAgIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChwcmV2Q29udHIubmV4dENoYWxsZW5nZSwgXCJSZXNwb25zZSBIYXNoOlwiKSk7XG5cbiAgICAgICAgaWYgKGN1ckNvbnRyLnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEJlYWNvbiBnZW5lcmF0b3I6ICR7bWlzYy5ieXRlQXJyYXkyaGV4KGN1ckNvbnRyLmJlYWNvbkhhc2gpfWApO1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEJlYWNvbiBpdGVyYXRpb25zIEV4cDogJHtjdXJDb250ci5udW1JdGVyYXRpb25zRXhwfWApO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbkJldGFHMihsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlLkcyO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBidWZmVXYgPSBuZXcgVWludDhBcnJheShzRyk7XG5cbiAgICAgICAgaWYgKCFzZWN0aW9uc1s2XSkgIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkZpbGUgaGFzIG5vIEJldGFHMiBzZWN0aW9uXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlsZSBoYXMgbm8gQmV0YUcyIHNlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25zWzZdLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGaWxlIGhhcyBubyBCZXRhRzIgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGUgaGFzIG1vcmUgdGhhbiBvbmUgR2V0YUcyIHNlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZmQucG9zID0gc2VjdGlvbnNbNl1bMF0ucDtcblxuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRyk7XG4gICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJMRU0oYnVmZik7XG5cbiAgICAgICAgRy50b1JwclVuY29tcHJlc3NlZChidWZmVXYsIDAsIFApO1xuICAgICAgICBuZXh0Q29udHJpYnV0aW9uSGFzaGVyLnVwZGF0ZShidWZmVXYpO1xuXG4gICAgICAgIHJldHVybiBQO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uKGlkU2VjdGlvbiwgZ3JvdXBOYW1lLCBzZWN0aW9uTmFtZSwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDE8PDE2O1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBpZFNlY3Rpb24pO1xuXG4gICAgICAgIGNvbnN0IHNpbmd1bGFyUG9pbnRzID0gW107XG5cbiAgICAgICAgbGV0IFIxID0gRy56ZXJvO1xuICAgICAgICBsZXQgUjIgPSBHLnplcm87XG5cbiAgICAgICAgbGV0IGxhc3RCYXNlID0gRy56ZXJvO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHBvaW50cyByZWxhdGlvbnM6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c30gYCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzID0gYXdhaXQgZmQucmVhZChuKnNHKTtcblxuICAgICAgICAgICAgY29uc3QgYmFzZXNVID0gYXdhaXQgRy5iYXRjaExFTXRvVShiYXNlcyk7XG4gICAgICAgICAgICBuZXh0Q29udHJpYnV0aW9uSGFzaGVyLnVwZGF0ZShiYXNlc1UpO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsYXJzID0gbWlzYy5nZXRSYW5kb21CeXRlcyg0KihuLTEpKTtcblxuICAgICAgICAgICAgaWYgKGk+MCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0QmFzZSA9IEcuZnJvbVJwckxFTShiYXNlcywgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IG1pc2MucmVhZFVJbnQzMkJFKG1pc2MuZ2V0UmFuZG9tQnl0ZXMoNCksIDApO1xuXG4gICAgICAgICAgICAgICAgUjEgPSBHLmFkZChSMSwgRy50aW1lc1NjYWxhcihsYXN0QmFzZSwgcikpO1xuICAgICAgICAgICAgICAgIFIyID0gRy5hZGQoUjIsIEcudGltZXNTY2FsYXIoZmlyc3RCYXNlLCByKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHIxID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiYXNlcy5zbGljZSgwLCAobi0xKSpzRyksIHNjYWxhcnMpO1xuICAgICAgICAgICAgY29uc3QgcjIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJhc2VzLnNsaWNlKHNHKSwgc2NhbGFycyk7XG5cbiAgICAgICAgICAgIFIxID0gRy5hZGQoUjEsIHIxKTtcbiAgICAgICAgICAgIFIyID0gRy5hZGQoUjIsIHIyKTtcblxuICAgICAgICAgICAgbGFzdEJhc2UgPSBHLmZyb21ScHJMRU0oIGJhc2VzLCAobi0xKSpzRyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxzaW5ndWxhclBvaW50SW5kZXhlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwID0gc2luZ3VsYXJQb2ludEluZGV4ZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKChzcCA+PWkpICYmIChzcCA8IGkrbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgUCA9IEcuZnJvbVJwckxFTShiYXNlcywgKHNwLWkpKnNHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBSMTogUjEsXG4gICAgICAgICAgICBSMjogUjIsXG4gICAgICAgICAgICBzaW5ndWxhclBvaW50czogc2luZ3VsYXJQb2ludHNcbiAgICAgICAgfTtcblxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHZlcmlmeUxhZ3JhbmdlRXZhbHVhdGlvbnMoZ05hbWUsIHRhdVNlY3Rpb24sIGxhZ3JhbmdlU2VjdGlvbiwgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgVmVyaWZ5aW5nIHBoYXNlMiBjYWxjdWxhdGVkIHZhbHVlcyAke3NlY3Rpb25OYW1lfS4uLmApO1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ05hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHNlZWQ9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDg7IGkrKykge1xuICAgICAgICAgICAgc2VlZFtpXSA9IG1pc2MucmVhZFVJbnQzMkJFKG1pc2MuZ2V0UmFuZG9tQnl0ZXMoNCksIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcD0wOyBwPD0gcG93ZXI7IHAgKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHZlcmlmeVBvd2VyKHApO1xuICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXVTZWN0aW9uID09IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHZlcmlmeVBvd2VyKHBvd2VyKzEpO1xuICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBvd2VyKHApIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgUG93ZXIgJHtwfS4uLmApO1xuICAgICAgICAgICAgY29uc3QgbjhyID0gY3VydmUuRnIubjg7XG4gICAgICAgICAgICBjb25zdCBuUG9pbnRzID0gMiAqKiBwO1xuICAgICAgICAgICAgbGV0IGJ1ZmZfciA9IG5ldyBVaW50MzJBcnJheShuUG9pbnRzKTtcbiAgICAgICAgICAgIGxldCBidWZmRztcblxuICAgICAgICAgICAgbGV0IHJuZyA9IG5ldyBDaGFDaGEoc2VlZCk7XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgQ3JlYXRpbmcgcmFuZG9tIG51bWJlcnMgUG93ZXJzJHtwfS4uLmApO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgocCA9PSBwb3dlcisxKSYmKGkgPT0gblBvaW50cy0xKSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmX3JbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZfcltpXSA9IHJuZy5uZXh0VTMyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWZmX3IgPSBuZXcgVWludDhBcnJheShidWZmX3IuYnVmZmVyLCBidWZmX3IuYnl0ZU9mZnNldCwgYnVmZl9yLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHJlYWRpbmcgcG9pbnRzIFBvd2VycyR7cH0uLi5gKTtcbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgdGF1U2VjdGlvbik7XG4gICAgICAgICAgICBidWZmRyA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzRyk7XG4gICAgICAgICAgICBpZiAocCA9PSBwb3dlcisxKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmQucmVhZFRvQnVmZmVyKGJ1ZmZHLCAwLCAoblBvaW50cy0xKSpzRyk7XG4gICAgICAgICAgICAgICAgYnVmZkcuc2V0KGN1cnZlLkcxLnplcm9BZmZpbmUsIChuUG9pbnRzLTEpKnNHKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmQucmVhZFRvQnVmZmVyKGJ1ZmZHLCAwLCBuUG9pbnRzKnNHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc1RhdSA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZkcsIGJ1ZmZfciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiX1wiICsgcCk7XG5cbiAgICAgICAgICAgIGJ1ZmZfciA9IG5ldyBCaWdCdWZmZXIoblBvaW50cyAqIG44cik7XG5cbiAgICAgICAgICAgIHJuZyA9IG5ldyBDaGFDaGEoc2VlZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmY0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgICAgICBjb25zdCBidWZmNFYgPSBuZXcgRGF0YVZpZXcoYnVmZjQuYnVmZmVyKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBDcmVhdGluZyByYW5kb20gbnVtYmVycyBQb3dlcnMke3B9Li4uYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChpICE9IG5Qb2ludHMtMSkgfHwgKHAgIT0gcG93ZXIrMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZjRWLnNldFVpbnQzMigwLCBybmcubmV4dFUzMigpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZl9yLnNldChidWZmNCwgaSpuOHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBiYXRjaFRvTW9udGdvbWVyeSAke3B9Li4uYCk7XG4gICAgICAgICAgICBidWZmX3IgPSBhd2FpdCBjdXJ2ZS5Gci5iYXRjaFRvTW9udGdvbWVyeShidWZmX3IpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBmZnQgJHtwfS4uLmApO1xuICAgICAgICAgICAgYnVmZl9yID0gYXdhaXQgY3VydmUuRnIuZmZ0KGJ1ZmZfcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYGJhdGNoRnJvbU1vbnRnb21lcnkgJHtwfS4uLmApO1xuICAgICAgICAgICAgYnVmZl9yID0gYXdhaXQgY3VydmUuRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShidWZmX3IpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHJlYWRpbmcgcG9pbnRzIExhZ3JhbmdlJHtwfS4uLmApO1xuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBsYWdyYW5nZVNlY3Rpb24pO1xuICAgICAgICAgICAgZmQucG9zICs9IHNHKigoMiAqKiBwKS0xKTtcbiAgICAgICAgICAgIGF3YWl0IGZkLnJlYWRUb0J1ZmZlcihidWZmRywgMCwgblBvaW50cypzRyk7XG4gICAgICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQsIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCByZXNMYWdyYW5nZSA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZkcsIGJ1ZmZfciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiX1wiICsgcCArIFwiX3RyYW5zZm9ybWVkXCIpO1xuXG4gICAgICAgICAgICBpZiAoIUcuZXEocmVzVGF1LCByZXNMYWdyYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQaGFzZTIgY2FjbHV0YXRpb24gZG9lcyBub3QgbWF0Y2ggd2l0aCBwb3dlcnMgb2YgdGF1XCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/powersoftau_verify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/proof.js":
/*!*******************************************!*\
  !*** ./node_modules/snarkjs/src/proof.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Proof: () => (/* binding */ Proof)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass Proof {\n    constructor(curve, logger) {\n        this.curve = curve;\n        this.logger = logger;\n\n        this.resetProof();\n    }\n\n    resetProof() {\n        this.polynomials = {};\n        this.evaluations = {};\n    }\n\n    addPolynomial(key, polynomial) {\n        if (key in this.polynomials) {\n            this.logger.warn(`proof: polynomial.${key} already exist in proof`);\n        }\n        this.polynomials[key] = polynomial;\n    }\n\n    getPolynomial(key) {\n        if (!(key in this.polynomials)) {\n            this.logger.warn(`proof: polynomial ${key} does not exist in proof`);\n        }\n        return this.polynomials[key];\n    }\n\n    addEvaluation(key, evaluation) {\n        if (key in this.evaluations) {\n            this.logger.warn(`proof: evaluations.${key} already exist in proof`);\n        }\n        this.evaluations[key] = evaluation;\n    }\n\n    getEvaluation(key) {\n        if (!(key in this.evaluations)) {\n            this.logger.warn(`proof: evaluation ${key} does not exist in proof`);\n        }\n        return this.evaluations[key];\n    }\n\n    toObjectProof(splitFields = true) {\n        let res = splitFields ? {polynomials: {}, evaluations: {}} : {};\n\n        Object.keys(this.polynomials).forEach(key => {\n            const value = this.curve.G1.toObject(this.polynomials[key]);\n            if(splitFields) {\n                res.polynomials[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        Object.keys(this.evaluations).forEach(key => {\n            const value = this.curve.Fr.toObject(this.evaluations[key]);\n            if(splitFields) {\n                res.evaluations[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        return res;\n    }\n\n    fromObjectProof(objectProof) {\n        this.resetProof();\n\n        Object.keys(objectProof.polynomials).forEach(key => {\n            this.polynomials[key] = this.curve.G1.fromObject(objectProof.polynomials[key]);\n        });\n\n        Object.keys(objectProof.evaluations).forEach(key => {\n            this.evaluations[key] = this.curve.Fr.fromObject(objectProof.evaluations[key]);\n        });\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcHJvb2YuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGVBQWUsbUJBQW1COztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Byb29mLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBjbGFzcyBQcm9vZiB7XG4gICAgY29uc3RydWN0b3IoY3VydmUsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmN1cnZlID0gY3VydmU7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuXG4gICAgICAgIHRoaXMucmVzZXRQcm9vZigpO1xuICAgIH1cblxuICAgIHJlc2V0UHJvb2YoKSB7XG4gICAgICAgIHRoaXMucG9seW5vbWlhbHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmFsdWF0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGFkZFBvbHlub21pYWwoa2V5LCBwb2x5bm9taWFsKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5wb2x5bm9taWFscykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcHJvb2Y6IHBvbHlub21pYWwuJHtrZXl9IGFscmVhZHkgZXhpc3QgaW4gcHJvb2ZgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvbHlub21pYWxzW2tleV0gPSBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIGdldFBvbHlub21pYWwoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzLnBvbHlub21pYWxzKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcHJvb2Y6IHBvbHlub21pYWwgJHtrZXl9IGRvZXMgbm90IGV4aXN0IGluIHByb29mYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9seW5vbWlhbHNba2V5XTtcbiAgICB9XG5cbiAgICBhZGRFdmFsdWF0aW9uKGtleSwgZXZhbHVhdGlvbikge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuZXZhbHVhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHByb29mOiBldmFsdWF0aW9ucy4ke2tleX0gYWxyZWFkeSBleGlzdCBpbiBwcm9vZmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZhbHVhdGlvbnNba2V5XSA9IGV2YWx1YXRpb247XG4gICAgfVxuXG4gICAgZ2V0RXZhbHVhdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuZXZhbHVhdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBwcm9vZjogZXZhbHVhdGlvbiAke2tleX0gZG9lcyBub3QgZXhpc3QgaW4gcHJvb2ZgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0aW9uc1trZXldO1xuICAgIH1cblxuICAgIHRvT2JqZWN0UHJvb2Yoc3BsaXRGaWVsZHMgPSB0cnVlKSB7XG4gICAgICAgIGxldCByZXMgPSBzcGxpdEZpZWxkcyA/IHtwb2x5bm9taWFsczoge30sIGV2YWx1YXRpb25zOiB7fX0gOiB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnBvbHlub21pYWxzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY3VydmUuRzEudG9PYmplY3QodGhpcy5wb2x5bm9taWFsc1trZXldKTtcbiAgICAgICAgICAgIGlmKHNwbGl0RmllbGRzKSB7XG4gICAgICAgICAgICAgICAgcmVzLnBvbHlub21pYWxzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ldmFsdWF0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmN1cnZlLkZyLnRvT2JqZWN0KHRoaXMuZXZhbHVhdGlvbnNba2V5XSk7XG4gICAgICAgICAgICBpZihzcGxpdEZpZWxkcykge1xuICAgICAgICAgICAgICAgIHJlcy5ldmFsdWF0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnJvbU9iamVjdFByb29mKG9iamVjdFByb29mKSB7XG4gICAgICAgIHRoaXMucmVzZXRQcm9vZigpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdFByb29mLnBvbHlub21pYWxzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvbHlub21pYWxzW2tleV0gPSB0aGlzLmN1cnZlLkcxLmZyb21PYmplY3Qob2JqZWN0UHJvb2YucG9seW5vbWlhbHNba2V5XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdFByb29mLmV2YWx1YXRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2YWx1YXRpb25zW2tleV0gPSB0aGlzLmN1cnZlLkZyLmZyb21PYmplY3Qob2JqZWN0UHJvb2YuZXZhbHVhdGlvbnNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/proof.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/r1cs.js":
/*!******************************************!*\
  !*** ./node_modules/snarkjs/src/r1cs.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportJson: () => (/* reexport safe */ _r1cs_export_json_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   info: () => (/* reexport safe */ _r1cs_info_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   print: () => (/* reexport safe */ _r1cs_print_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _r1cs_print_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./r1cs_print.js */ \"(rsc)/./node_modules/snarkjs/src/r1cs_print.js\");\n/* harmony import */ var _r1cs_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./r1cs_info.js */ \"(rsc)/./node_modules/snarkjs/src/r1cs_info.js\");\n/* harmony import */ var _r1cs_export_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./r1cs_export_json.js */ \"(rsc)/./node_modules/snarkjs/src/r1cs_export_json.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVpRDtBQUNGO0FBQ2EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQge2RlZmF1bHQgYXMgcHJpbnR9IGZyb20gXCIuL3IxY3NfcHJpbnQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbmZvfSBmcm9tIFwiLi9yMWNzX2luZm8uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRKc29ufSBmcm9tIFwiLi9yMWNzX2V4cG9ydF9qc29uLmpzXCI7XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/r1cs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/r1cs_constraint_processor.js":
/*!***************************************************************!*\
  !*** ./node_modules/snarkjs/src/r1cs_constraint_processor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   r1csConstraintProcessor: () => (/* binding */ r1csConstraintProcessor)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst LINEAR_COMBINATION_NULLABLE = 0;\nconst LINEAR_COMBINATION_CONSTANT = 1;\nconst LINEAR_COMBINATION_VARIABLE = 2;\n\nclass r1csConstraintProcessor {\n    constructor(Fr, fnGetConstantConstraint, fnGetAdditionConstraint, fnGetMultiplicationConstraint, logger) {\n        this.Fr = Fr;\n        this.logger = logger;\n        this.fnGetAdditionConstraint = fnGetAdditionConstraint;\n        this.fnGetMultiplicationConstraint = fnGetMultiplicationConstraint;\n    }\n\n    processR1csConstraint(settings, lcA, lcB, lcC) {\n        this.normalizeLinearCombination(lcA);\n        this.normalizeLinearCombination(lcB);\n        this.normalizeLinearCombination(lcC);\n\n        const lctA = this.getLinearCombinationType(lcA);\n        const lctB = this.getLinearCombinationType(lcB);\n\n        if ((lctA === LINEAR_COMBINATION_NULLABLE) || (lctB === LINEAR_COMBINATION_NULLABLE)) {\n            return this.processR1csAdditionConstraint(settings, lcC);\n        } else if (lctA === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcB, lcC, lcA[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else if (lctB === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcA, lcC, lcB[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else {\n            return this.processR1csMultiplicationConstraint(settings, lcA, lcB, lcC);\n        }\n    }\n\n    getLinearCombinationType(linCom) {\n        // let k = this.Fr.zero;\n        //\n        // const signalIds = Object.keys(linCom);\n        // for (let i = 0; i < signalIds.length; i++) {\n        //     if (signalIds[i] === \"0\") {\n        //         k = this.Fr.add(k, linCom[signalIds[i]]);\n        //     } else {\n        //         return LINEAR_COMBINATION_VARIABLE;\n        //     }\n        // }\n        //\n        // if (!this.Fr.eq(k, this.Fr.zero)) return LINEAR_COMBINATION_CONSTANT;\n        //\n        // return LINEAR_COMBINATION_NULLABLE;\n\n        let k = this.Fr.zero;\n        let n = 0;\n        const ss = Object.keys(linCom);\n        for (let i = 0; i < ss.length; i++) {\n            if (linCom[ss[i]] == 0n) {\n                delete linCom[ss[i]];\n            } else if (ss[i] == 0) {\n                k = this.Fr.add(k, linCom[ss[i]]);\n            } else {\n                n++;\n            }\n        }\n        if (n > 0) return LINEAR_COMBINATION_VARIABLE;\n        if (!this.Fr.isZero(k)) return LINEAR_COMBINATION_CONSTANT;\n        return LINEAR_COMBINATION_NULLABLE;\n    }\n\n    normalizeLinearCombination(linCom) {\n        const signalIds = Object.keys(linCom);\n        for (let i = 0; i < signalIds.length; i++) {\n            if (this.Fr.isZero(linCom[signalIds[i]])) delete linCom[signalIds[i]];\n        }\n\n        return linCom;\n    }\n\n    joinLinearCombinations(linCom1, linCom2, k) {\n        const res = {};\n\n        for (let s in linCom1) {\n            if (typeof res[s] == \"undefined\") {\n                res[s] = this.Fr.mul(k, linCom1[s]);\n            } else {\n                res[s] = this.Fr.add(res[s], this.Fr.mul(k, linCom1[s]));\n            }\n        }\n\n        for (let s in linCom2) {\n            const val = this.Fr.neg(linCom2[s]);\n            if (typeof res[s] == \"undefined\") {\n                res[s] = val;\n            } else {\n                res[s] = this.Fr.add(res[s], val);\n            }\n        }\n\n        return this.normalizeLinearCombination(res);\n    }\n\n    reduceCoefs(settings, constraintsArr, additionsArr, linCom, maxC) {\n        const res = {\n            k: this.Fr.zero,\n            signals: [],\n            coefs: []\n        };\n        const cs = [];\n\n        for (let signalId in linCom) {\n            if (signalId == 0) {\n                res.k = this.Fr.add(res.k, linCom[signalId]);\n            } else if (linCom[signalId] != 0n) {\n                cs.push([Number(signalId), linCom[signalId]]);\n            }\n        }\n\n        while (cs.length > maxC) {\n            const c1 = cs.shift();\n            const c2 = cs.shift();\n            const so = settings.nVars++;\n\n            const constraints = this.fnGetAdditionConstraint(\n                c1[0], c2[0], so,\n                this.Fr.neg(c1[1]), this.Fr.neg(c2[1]), this.Fr.zero, this.Fr.one, this.Fr.zero);\n\n            constraintsArr.push(constraints);\n            additionsArr.push([c1[0], c2[0], c1[1], c2[1]]);\n\n            cs.push([so, this.Fr.one]);\n        }\n\n        for (let i = 0; i < cs.length; i++) {\n            res.signals[i] = cs[i][0];\n            res.coefs[i] = cs[i][1];\n        }\n\n        while (res.coefs.length < maxC) {\n            res.signals.push(0);\n            res.coefs.push(this.Fr.zero);\n        }\n\n        return res;\n    }\n\n    processR1csAdditionConstraint(settings, linCom) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, linCom, 3);\n\n        const constraints = this.fnGetAdditionConstraint(\n            C.signals[0], C.signals[1], C.signals[2],\n            C.coefs[0], C.coefs[1], this.Fr.zero, C.coefs[2], C.k);\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n\n    processR1csMultiplicationConstraint(settings, lcA, lcB, lcC) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const A = this.reduceCoefs(settings, constraintsArr, additionsArr, lcA, 1);\n        const B = this.reduceCoefs(settings, constraintsArr, additionsArr, lcB, 1);\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, lcC, 1);\n\n        const constraints = this.fnGetMultiplicationConstraint(\n            A.signals[0], B.signals[0], C.signals[0],\n            this.Fr.mul(A.coefs[0], B.k),\n            this.Fr.mul(A.k, B.coefs[0]),\n            this.Fr.mul(A.coefs[0], B.coefs[0]),\n            this.Fr.neg(C.coefs[0]),\n            this.Fr.sub(this.Fr.mul(A.k, B.k), C.k));\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19jb25zdHJhaW50X3Byb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19jb25zdHJhaW50X3Byb2Nlc3Nvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUgPSAwO1xuY29uc3QgTElORUFSX0NPTUJJTkFUSU9OX0NPTlNUQU5UID0gMTtcbmNvbnN0IExJTkVBUl9DT01CSU5BVElPTl9WQVJJQUJMRSA9IDI7XG5cbmV4cG9ydCBjbGFzcyByMWNzQ29uc3RyYWludFByb2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IoRnIsIGZuR2V0Q29uc3RhbnRDb25zdHJhaW50LCBmbkdldEFkZGl0aW9uQ29uc3RyYWludCwgZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLkZyID0gRnI7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLmZuR2V0QWRkaXRpb25Db25zdHJhaW50ID0gZm5HZXRBZGRpdGlvbkNvbnN0cmFpbnQ7XG4gICAgICAgIHRoaXMuZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQgPSBmbkdldE11bHRpcGxpY2F0aW9uQ29uc3RyYWludDtcbiAgICB9XG5cbiAgICBwcm9jZXNzUjFjc0NvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaW5lYXJDb21iaW5hdGlvbihsY0EpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUxpbmVhckNvbWJpbmF0aW9uKGxjQik7XG4gICAgICAgIHRoaXMubm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24obGNDKTtcblxuICAgICAgICBjb25zdCBsY3RBID0gdGhpcy5nZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGNBKTtcbiAgICAgICAgY29uc3QgbGN0QiA9IHRoaXMuZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxjQik7XG5cbiAgICAgICAgaWYgKChsY3RBID09PSBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUpIHx8IChsY3RCID09PSBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUjFjc0FkZGl0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGNDKTtcbiAgICAgICAgfSBlbHNlIGlmIChsY3RBID09PSBMSU5FQVJfQ09NQklOQVRJT05fQ09OU1RBTlQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxjQ0MgPSB0aGlzLmpvaW5MaW5lYXJDb21iaW5hdGlvbnMobGNCLCBsY0MsIGxjQVswXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUjFjc0FkZGl0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGNDQyk7XG4gICAgICAgIH0gZWxzZSBpZiAobGN0QiA9PT0gTElORUFSX0NPTUJJTkFUSU9OX0NPTlNUQU5UKSB7XG4gICAgICAgICAgICBjb25zdCBsY0NDID0gdGhpcy5qb2luTGluZWFyQ29tYmluYXRpb25zKGxjQSwgbGNDLCBsY0JbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1IxY3NBZGRpdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQ0MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1IxY3NNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxpbkNvbSkge1xuICAgICAgICAvLyBsZXQgayA9IHRoaXMuRnIuemVybztcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3Qgc2lnbmFsSWRzID0gT2JqZWN0LmtleXMobGluQ29tKTtcbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYWxJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gICAgIGlmIChzaWduYWxJZHNbaV0gPT09IFwiMFwiKSB7XG4gICAgICAgIC8vICAgICAgICAgayA9IHRoaXMuRnIuYWRkKGssIGxpbkNvbVtzaWduYWxJZHNbaV1dKTtcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9WQVJJQUJMRTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvL1xuICAgICAgICAvLyBpZiAoIXRoaXMuRnIuZXEoaywgdGhpcy5Gci56ZXJvKSkgcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9DT05TVEFOVDtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9OVUxMQUJMRTtcblxuICAgICAgICBsZXQgayA9IHRoaXMuRnIuemVybztcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBjb25zdCBzcyA9IE9iamVjdC5rZXlzKGxpbkNvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5Db21bc3NbaV1dID09IDBuKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxpbkNvbVtzc1tpXV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNzW2ldID09IDApIHtcbiAgICAgICAgICAgICAgICBrID0gdGhpcy5Gci5hZGQoaywgbGluQ29tW3NzW2ldXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+IDApIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fVkFSSUFCTEU7XG4gICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oaykpIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fQ09OU1RBTlQ7XG4gICAgICAgIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEU7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24obGluQ29tKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hbElkcyA9IE9iamVjdC5rZXlzKGxpbkNvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmFsSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5Gci5pc1plcm8obGluQ29tW3NpZ25hbElkc1tpXV0pKSBkZWxldGUgbGluQ29tW3NpZ25hbElkc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluQ29tO1xuICAgIH1cblxuICAgIGpvaW5MaW5lYXJDb21iaW5hdGlvbnMobGluQ29tMSwgbGluQ29tMiwgaykge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcblxuICAgICAgICBmb3IgKGxldCBzIGluIGxpbkNvbTEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzW3NdID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXNbc10gPSB0aGlzLkZyLm11bChrLCBsaW5Db20xW3NdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW3NdID0gdGhpcy5Gci5hZGQocmVzW3NdLCB0aGlzLkZyLm11bChrLCBsaW5Db20xW3NdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBzIGluIGxpbkNvbTIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuRnIubmVnKGxpbkNvbTJbc10pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNbc10gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJlc1tzXSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW3NdID0gdGhpcy5Gci5hZGQocmVzW3NdLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24ocmVzKTtcbiAgICB9XG5cbiAgICByZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGluQ29tLCBtYXhDKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgIGs6IHRoaXMuRnIuemVybyxcbiAgICAgICAgICAgIHNpZ25hbHM6IFtdLFxuICAgICAgICAgICAgY29lZnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgc2lnbmFsSWQgaW4gbGluQ29tKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsSWQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlcy5rID0gdGhpcy5Gci5hZGQocmVzLmssIGxpbkNvbVtzaWduYWxJZF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5Db21bc2lnbmFsSWRdICE9IDBuKSB7XG4gICAgICAgICAgICAgICAgY3MucHVzaChbTnVtYmVyKHNpZ25hbElkKSwgbGluQ29tW3NpZ25hbElkXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGNzLmxlbmd0aCA+IG1heEMpIHtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gY3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gY3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNvID0gc2V0dGluZ3MublZhcnMrKztcblxuICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmZuR2V0QWRkaXRpb25Db25zdHJhaW50KFxuICAgICAgICAgICAgICAgIGMxWzBdLCBjMlswXSwgc28sXG4gICAgICAgICAgICAgICAgdGhpcy5Gci5uZWcoYzFbMV0pLCB0aGlzLkZyLm5lZyhjMlsxXSksIHRoaXMuRnIuemVybywgdGhpcy5Gci5vbmUsIHRoaXMuRnIuemVybyk7XG5cbiAgICAgICAgICAgIGNvbnN0cmFpbnRzQXJyLnB1c2goY29uc3RyYWludHMpO1xuICAgICAgICAgICAgYWRkaXRpb25zQXJyLnB1c2goW2MxWzBdLCBjMlswXSwgYzFbMV0sIGMyWzFdXSk7XG5cbiAgICAgICAgICAgIGNzLnB1c2goW3NvLCB0aGlzLkZyLm9uZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzLnNpZ25hbHNbaV0gPSBjc1tpXVswXTtcbiAgICAgICAgICAgIHJlcy5jb2Vmc1tpXSA9IGNzW2ldWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHJlcy5jb2Vmcy5sZW5ndGggPCBtYXhDKSB7XG4gICAgICAgICAgICByZXMuc2lnbmFscy5wdXNoKDApO1xuICAgICAgICAgICAgcmVzLmNvZWZzLnB1c2godGhpcy5Gci56ZXJvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgcHJvY2Vzc1IxY3NBZGRpdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxpbkNvbSkge1xuICAgICAgICBjb25zdCBjb25zdHJhaW50c0FyciA9IFtdO1xuICAgICAgICBjb25zdCBhZGRpdGlvbnNBcnIgPSBbXTtcblxuICAgICAgICBjb25zdCBDID0gdGhpcy5yZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGluQ29tLCAzKTtcblxuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuZm5HZXRBZGRpdGlvbkNvbnN0cmFpbnQoXG4gICAgICAgICAgICBDLnNpZ25hbHNbMF0sIEMuc2lnbmFsc1sxXSwgQy5zaWduYWxzWzJdLFxuICAgICAgICAgICAgQy5jb2Vmc1swXSwgQy5jb2Vmc1sxXSwgdGhpcy5Gci56ZXJvLCBDLmNvZWZzWzJdLCBDLmspO1xuXG4gICAgICAgIGNvbnN0cmFpbnRzQXJyLnB1c2goY29uc3RyYWludHMpO1xuXG4gICAgICAgIHJldHVybiBbY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0Fycl07XG4gICAgfVxuXG4gICAgcHJvY2Vzc1IxY3NNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHNBcnIgPSBbXTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25zQXJyID0gW107XG5cbiAgICAgICAgY29uc3QgQSA9IHRoaXMucmVkdWNlQ29lZnMoc2V0dGluZ3MsIGNvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnIsIGxjQSwgMSk7XG4gICAgICAgIGNvbnN0IEIgPSB0aGlzLnJlZHVjZUNvZWZzKHNldHRpbmdzLCBjb25zdHJhaW50c0FyciwgYWRkaXRpb25zQXJyLCBsY0IsIDEpO1xuICAgICAgICBjb25zdCBDID0gdGhpcy5yZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGNDLCAxKTtcblxuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoXG4gICAgICAgICAgICBBLnNpZ25hbHNbMF0sIEIuc2lnbmFsc1swXSwgQy5zaWduYWxzWzBdLFxuICAgICAgICAgICAgdGhpcy5Gci5tdWwoQS5jb2Vmc1swXSwgQi5rKSxcbiAgICAgICAgICAgIHRoaXMuRnIubXVsKEEuaywgQi5jb2Vmc1swXSksXG4gICAgICAgICAgICB0aGlzLkZyLm11bChBLmNvZWZzWzBdLCBCLmNvZWZzWzBdKSxcbiAgICAgICAgICAgIHRoaXMuRnIubmVnKEMuY29lZnNbMF0pLFxuICAgICAgICAgICAgdGhpcy5Gci5zdWIodGhpcy5Gci5tdWwoQS5rLCBCLmspLCBDLmspKTtcblxuICAgICAgICBjb25zdHJhaW50c0Fyci5wdXNoKGNvbnN0cmFpbnRzKTtcblxuICAgICAgICByZXR1cm4gW2NvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnJdO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/r1cs_constraint_processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/r1cs_export_json.js":
/*!******************************************************!*\
  !*** ./node_modules/snarkjs/src/r1cs_export_json.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csExportJson)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(rsc)/./node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function r1csExportJson(r1csFileName, logger) {\n\n    const cir = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1cs)(r1csFileName, true, true, true, logger);\n    const Fr=cir.curve.Fr;\n    delete cir.curve;\n    delete cir.F;\n\n    return (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.stringifyBigIntsWithField)(Fr, cir);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19leHBvcnRfanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVtQztBQUNtQjs7O0FBR3ZDOztBQUVmLHNCQUFzQixrREFBUTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtRUFBeUI7QUFDcEMiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19leHBvcnRfanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQge3JlYWRSMWNzfSAgZnJvbSBcInIxY3NmaWxlXCI7XG5pbXBvcnQgeyBzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHIxY3NFeHBvcnRKc29uKHIxY3NGaWxlTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBjaXIgPSBhd2FpdCByZWFkUjFjcyhyMWNzRmlsZU5hbWUsIHRydWUsIHRydWUsIHRydWUsIGxvZ2dlcik7XG4gICAgY29uc3QgRnI9Y2lyLmN1cnZlLkZyO1xuICAgIGRlbGV0ZSBjaXIuY3VydmU7XG4gICAgZGVsZXRlIGNpci5GO1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQoRnIsIGNpcik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/r1cs_export_json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/r1cs_info.js":
/*!***********************************************!*\
  !*** ./node_modules/snarkjs/src/r1cs_info.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csInfo)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! r1csfile */ \"(rsc)/./node_modules/r1csfile/src/r1csfile.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst bls12381r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nasync function r1csInfo(r1csName, logger) {\n\n    const cir = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_1__.readR1cs)(r1csName);\n\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(cir.prime, bn128r)) {\n        if (logger) logger.info(\"Curve: bn-128\");\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(cir.prime, bls12381r)) {\n        if (logger) logger.info(\"Curve: bls12-381\");\n    } else {\n        if (logger) logger.info(`Unknown Curve. Prime: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(cir.prime)}`);\n    }\n    if (logger) logger.info(`# of Wires: ${cir.nVars}`);\n    if (logger) logger.info(`# of Constraints: ${cir.nConstraints}`);\n    if (logger) logger.info(`# of Private Inputs: ${cir.nPrvInputs}`);\n    if (logger) logger.info(`# of Public Inputs: ${cir.nPubInputs}`);\n    if (logger) logger.info(`# of Labels: ${cir.nLabels}`);\n    if (logger) logger.info(`# of Outputs: ${cir.nOutputs}`);\n\n    return cir;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19pbmZvLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXNDO0FBQ0Q7O0FBRXJDLGtCQUFrQixnREFBTTtBQUN4QixlQUFlLGdEQUFNOztBQUVOOztBQUVmLHNCQUFzQixrREFBUTs7QUFFOUIsUUFBUSxnREFBTTtBQUNkO0FBQ0EsTUFBTSxTQUFTLGdEQUFNO0FBQ3JCO0FBQ0EsTUFBTTtBQUNOLHlEQUF5RCxnREFBTSxxQkFBcUI7QUFDcEY7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRCxpREFBaUQsaUJBQWlCO0FBQ2xFLG9EQUFvRCxlQUFlO0FBQ25FLG1EQUFtRCxlQUFlO0FBQ2xFLDRDQUE0QyxZQUFZO0FBQ3hELDZDQUE2QyxhQUFhOztBQUUxRDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3IxY3NfaW5mby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgeyByZWFkUjFjcyB9ICBmcm9tIFwicjFjc2ZpbGVcIjtcblxuY29uc3QgYmxzMTIzODFyID0gU2NhbGFyLmUoXCI3M2VkYTc1MzI5OWQ3ZDQ4MzMzOWQ4MDgwOWExZDgwNTUzYmRhNDAyZmZmZTViZmVmZmZmZmZmZjAwMDAwMDAxXCIsIDE2KTtcbmNvbnN0IGJuMTI4ciA9IFNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHIxY3NJbmZvKHIxY3NOYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IGNpciA9IGF3YWl0IHJlYWRSMWNzKHIxY3NOYW1lKTtcblxuICAgIGlmIChTY2FsYXIuZXEoY2lyLnByaW1lLCBibjEyOHIpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiQ3VydmU6IGJuLTEyOFwiKTtcbiAgICB9IGVsc2UgaWYgKFNjYWxhci5lcShjaXIucHJpbWUsIGJsczEyMzgxcikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJDdXJ2ZTogYmxzMTItMzgxXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGBVbmtub3duIEN1cnZlLiBQcmltZTogJHtTY2FsYXIudG9TdHJpbmcoY2lyLnByaW1lKX1gKTtcbiAgICB9XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgV2lyZXM6ICR7Y2lyLm5WYXJzfWApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIENvbnN0cmFpbnRzOiAke2Npci5uQ29uc3RyYWludHN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgUHJpdmF0ZSBJbnB1dHM6ICR7Y2lyLm5QcnZJbnB1dHN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgUHVibGljIElucHV0czogJHtjaXIublB1YklucHV0c31gKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgIyBvZiBMYWJlbHM6ICR7Y2lyLm5MYWJlbHN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgT3V0cHV0czogJHtjaXIubk91dHB1dHN9YCk7XG5cbiAgICByZXR1cm4gY2lyO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/r1cs_info.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/r1cs_print.js":
/*!************************************************!*\
  !*** ./node_modules/snarkjs/src/r1cs_print.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csPrint)\n/* harmony export */ });\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nfunction r1csPrint(r1cs, syms, logger) {\n    for (let i=0; i<r1cs.constraints.length; i++) {\n        printCostraint(r1cs.constraints[i]);\n    }\n    function printCostraint(c) {\n        const lc2str = (lc) => {\n            let S = \"\";\n            const keys = Object.keys(lc);\n            keys.forEach( (k) => {\n                let name = syms.varIdx2Name[k];\n                if (name == \"one\") name = \"1\";\n\n                let vs = r1cs.curve.Fr.toString(lc[k]);\n                if (vs == \"1\") vs = \"\";  // Do not show ones\n                if (vs == \"-1\") vs = \"-\";  // Do not show ones\n                if ((S!=\"\")&&(vs[0]!=\"-\")) vs = \"+\"+vs;\n                if (S!=\"\") vs = \" \"+vs;\n                S= S + vs   + name;\n            });\n            return S;\n        };\n        const S = `[ ${lc2str(c[0])} ] * [ ${lc2str(c[1])} ] - [ ${lc2str(c[2])} ] = 0`;\n        if (logger) logger.info(S);\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19wcmludC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QixjQUFjLFFBQVEsY0FBYyxRQUFRLGNBQWM7QUFDakY7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9yMWNzX3ByaW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHIxY3NQcmludChyMWNzLCBzeW1zLCBsb2dnZXIpIHtcbiAgICBmb3IgKGxldCBpPTA7IGk8cjFjcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmludENvc3RyYWludChyMWNzLmNvbnN0cmFpbnRzW2ldKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJpbnRDb3N0cmFpbnQoYykge1xuICAgICAgICBjb25zdCBsYzJzdHIgPSAobGMpID0+IHtcbiAgICAgICAgICAgIGxldCBTID0gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhsYyk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goIChrKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBzeW1zLnZhcklkeDJOYW1lW2tdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwib25lXCIpIG5hbWUgPSBcIjFcIjtcblxuICAgICAgICAgICAgICAgIGxldCB2cyA9IHIxY3MuY3VydmUuRnIudG9TdHJpbmcobGNba10pO1xuICAgICAgICAgICAgICAgIGlmICh2cyA9PSBcIjFcIikgdnMgPSBcIlwiOyAgLy8gRG8gbm90IHNob3cgb25lc1xuICAgICAgICAgICAgICAgIGlmICh2cyA9PSBcIi0xXCIpIHZzID0gXCItXCI7ICAvLyBEbyBub3Qgc2hvdyBvbmVzXG4gICAgICAgICAgICAgICAgaWYgKChTIT1cIlwiKSYmKHZzWzBdIT1cIi1cIikpIHZzID0gXCIrXCIrdnM7XG4gICAgICAgICAgICAgICAgaWYgKFMhPVwiXCIpIHZzID0gXCIgXCIrdnM7XG4gICAgICAgICAgICAgICAgUz0gUyArIHZzICAgKyBuYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgUyA9IGBbICR7bGMyc3RyKGNbMF0pfSBdICogWyAke2xjMnN0cihjWzFdKX0gXSAtIFsgJHtsYzJzdHIoY1syXSl9IF0gPSAwYDtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oUyk7XG4gICAgfVxuXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/r1cs_print.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/wtns.js":
/*!******************************************!*\
  !*** ./node_modules/snarkjs/src/wtns.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculate: () => (/* reexport safe */ _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   check: () => (/* reexport safe */ _wtns_check_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   debug: () => (/* reexport safe */ _wtns_debug_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _wtns_export_json_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var _wtns_debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_debug.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_debug.js\");\n/* harmony import */ var _wtns_export_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_export_json.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_export_json.js\");\n/* harmony import */ var _wtns_check_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wtns_check.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_check.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Rucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXlEO0FBQ1I7QUFDVyIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy93dG5zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBjYWxjdWxhdGV9IGZyb20gXCIuL3d0bnNfY2FsY3VsYXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZGVidWd9IGZyb20gXCIuL3d0bnNfZGVidWcuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRKc29ufSBmcm9tIFwiLi93dG5zX2V4cG9ydF9qc29uLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY2hlY2t9IGZyb20gXCIuL3d0bnNfY2hlY2suanNcIjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/wtns.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/wtns_calculate.js":
/*!****************************************************!*\
  !*** ./node_modules/snarkjs/src/wtns_calculate.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsCalculate)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var circom_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! circom_runtime */ \"(rsc)/./node_modules/circom_runtime/main.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.utils;\n\nasync function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wc = await (0,circom_runtime__WEBPACK_IMPORTED_MODULE_1__.WitnessCalculatorBuilder)(wasm, options);\n    if (wc.circom_version() === 1) {\n        const w = await wc.calculateBinWitness(input);\n\n        const fdWtns = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n        await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.writeBin(fdWtns, w, wc.prime);\n        await fdWtns.close();\n    } else {\n        const fdWtns = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(wtnsFileName);\n\n        const w = await wc.calculateWTNSBin(input);\n\n        await fdWtns.write(w);\n        await fdWtns.close();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19jYWxjdWxhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDcUI7QUFDYjtBQUNPO0FBQ1o7QUFDeEMsUUFBUSxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFcEI7QUFDZjs7QUFFQSx5QkFBeUIsa0RBQXFCO0FBQzlDO0FBQ0E7O0FBRUEscUJBQXFCLHdFQUF3QjtBQUM3QztBQUNBOztBQUVBLDZCQUE2Qiw4REFBMEI7O0FBRXZELGNBQWMsb0RBQWtCO0FBQ2hDO0FBQ0EsTUFBTTtBQUNOLDZCQUE2QixvREFBdUI7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfY2FsY3VsYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuaW1wb3J0IHsgV2l0bmVzc0NhbGN1bGF0b3JCdWlsZGVyIH0gZnJvbSBcImNpcmNvbV9ydW50aW1lXCI7XG5pbXBvcnQgKiBhcyB3dG5zVXRpbHMgZnJvbSBcIi4vd3Ruc191dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgeyAgdXRpbHMgfSAgIGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHsgdW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB3dG5zQ2FsY3VsYXRlKF9pbnB1dCwgd2FzbUZpbGVOYW1lLCB3dG5zRmlsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyhfaW5wdXQpO1xuXG4gICAgY29uc3QgZmRXYXNtID0gYXdhaXQgZmFzdEZpbGUucmVhZEV4aXN0aW5nKHdhc21GaWxlTmFtZSk7XG4gICAgY29uc3Qgd2FzbSA9IGF3YWl0IGZkV2FzbS5yZWFkKGZkV2FzbS50b3RhbFNpemUpO1xuICAgIGF3YWl0IGZkV2FzbS5jbG9zZSgpO1xuXG4gICAgY29uc3Qgd2MgPSBhd2FpdCBXaXRuZXNzQ2FsY3VsYXRvckJ1aWxkZXIod2FzbSwgb3B0aW9ucyk7XG4gICAgaWYgKHdjLmNpcmNvbV92ZXJzaW9uKCkgPT09IDEpIHtcbiAgICAgICAgY29uc3QgdyA9IGF3YWl0IHdjLmNhbGN1bGF0ZUJpbldpdG5lc3MoaW5wdXQpO1xuXG4gICAgICAgIGNvbnN0IGZkV3RucyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKHd0bnNGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDIpO1xuXG4gICAgICAgIGF3YWl0IHd0bnNVdGlscy53cml0ZUJpbihmZFd0bnMsIHcsIHdjLnByaW1lKTtcbiAgICAgICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmRXdG5zID0gYXdhaXQgZmFzdEZpbGUuY3JlYXRlT3ZlcnJpZGUod3Ruc0ZpbGVOYW1lKTtcblxuICAgICAgICBjb25zdCB3ID0gYXdhaXQgd2MuY2FsY3VsYXRlV1ROU0JpbihpbnB1dCk7XG5cbiAgICAgICAgYXdhaXQgZmRXdG5zLndyaXRlKHcpO1xuICAgICAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/wtns_calculate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/wtns_check.js":
/*!************************************************!*\
  !*** ./node_modules/snarkjs/src/wtns_check.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsCheck)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! r1csfile */ \"(rsc)/./node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function wtnsCheck(r1csFilename, wtnsFilename, logger) {\n\n    if (logger) logger.info(\"WITNESS CHECKING STARTED\");\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {\n        fd: fdR1cs,\n        sections: sectionsR1cs\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_2__.readR1csFd)(fdR1cs, sectionsR1cs, { loadConstraints: false, loadCustomGates: false });\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(wtnsFilename, \"wtns\", 2, 1 << 22, 1 << 24);\n    const wtnsHeader = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdWtns, wtnsSections);\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.eq(r1cs.prime, wtnsHeader.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_4__.getCurveFromR(r1cs.prime);\n    const Fr = curve.Fr;\n    const sFr = Fr.n8;\n\n    const bR1cs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdR1cs, sectionsR1cs, 2);\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  WITNESS CHECK\");\n        logger.info(`  Curve:          ${r1cs.curve.name}`);\n        logger.info(`  Vars (wires):   ${r1cs.nVars}`);\n        logger.info(`  Outputs:        ${r1cs.nOutputs}`);\n        logger.info(`  Public Inputs:  ${r1cs.nPubInputs}`);\n        logger.info(`  Private Inputs: ${r1cs.nPrvInputs}`);\n        logger.info(`  Labels:         ${r1cs.nLabels}`);\n        logger.info(`  Constraints:    ${r1cs.nConstraints}`);\n        logger.info(`  Custom Gates:   ${r1cs.useCustomGates}`);\n        logger.info(\"----------------------------\");\n    }\n\n    if (logger) logger.info(\"> Checking witness correctness\");\n\n    let bR1csPos = 0;\n    let res = true;\n    for (let i = 0; i < r1cs.nConstraints; i++) {\n        if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n            logger.info(` processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n        }\n\n        //Read the three linear combinations of the constraint where A * B - C = 0\n        const lcA = readLC();\n        const lcB = readLC();\n        const lcC = readLC();\n\n        // Evaluate the linear combinations\n        const evalA = EvaluateLinearCombination(lcA);\n        const evalB = EvaluateLinearCombination(lcB);\n        const evalC = EvaluateLinearCombination(lcC);\n\n        // Check that A * B - C == 0\n        if (!Fr.eq(Fr.sub(Fr.mul(evalA, evalB), evalC), Fr.zero)) {\n            logger.warn(\" aborting checking process at constraint \" + i);\n            res = false;\n            break;\n        }\n    }\n\n    fdR1cs.close();\n\n    if (logger) {\n        if (res) {\n            logger.info(\"WITNESS IS CORRECT\");\n            logger.info(\"WITNESS CHECKING FINISHED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"WITNESS IS NOT CORRECT\");\n            logger.warn(\"WITNESS CHECKING FINISHED UNSUCCESSFULLY\");\n        }\n    }\n\n    return res;\n\n    function EvaluateLinearCombination(lc) {\n        let res = Fr.zero;\n\n        const keys = Object.keys(lc);\n        keys.forEach((signalId) => {\n            const signalValue = getWitnessValue(signalId);\n            const signalFactor = lc[signalId];\n\n            res = Fr.add(res, Fr.mul(signalValue, signalFactor));\n        });\n\n        return res;\n    }\n\n    function readLC() {\n        const lc = {};\n\n        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n        bR1csPos += 4;\n        const buffUL32V = new DataView(buffUL32.buffer);\n        const nIdx = buffUL32V.getUint32(0, true);\n\n        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n        bR1csPos += (4 + r1cs.n8) * nIdx;\n        const buffV = new DataView(buff.buffer);\n        for (let i = 0; i < nIdx; i++) {\n            const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n            const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n            lc[idx] = val;\n        }\n        return lc;\n    }\n\n    function getWitnessValue(signalId) {\n        return Fr.fromRprLE(buffWitness.slice(signalId * sFr, signalId * sFr + sFr));\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19jaGVjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDtBQUNQO0FBQ1A7QUFDQTtBQUNBOztBQUV2Qjs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxRQUFRLDREQUF3QjtBQUN0Qyx1QkFBdUIsb0RBQVUseUJBQXlCLGdEQUFnRDs7QUFFMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSw0REFBd0I7QUFDdEMsNkJBQTZCLHNEQUFvQjs7QUFFakQsU0FBUyxnREFBTTtBQUNmO0FBQ0E7O0FBRUEsOEJBQThCLDREQUF3QjtBQUN0RDs7QUFFQSx3QkFBd0IscURBQW9CO0FBQzVDO0FBQ0E7O0FBRUEsd0JBQXdCLDREQUF3Qjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RCx5Q0FBeUMsV0FBVztBQUNwRCx5Q0FBeUMsY0FBYztBQUN2RCx5Q0FBeUMsZ0JBQWdCO0FBQ3pELHlDQUF5QyxnQkFBZ0I7QUFDekQseUNBQXlDLGFBQWE7QUFDdEQseUNBQXlDLGtCQUFrQjtBQUMzRCx5Q0FBeUMsb0JBQW9CO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQSwyREFBMkQsRUFBRSxHQUFHLGtCQUFrQjtBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfY2hlY2suanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB3dG5zVXRpbHMgZnJvbSBcIi4vd3Ruc191dGlscy5qc1wiO1xuaW1wb3J0IHsgcmVhZFIxY3NGZCB9IGZyb20gXCJyMWNzZmlsZVwiO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0ICogYXMgY3VydmVzIGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB3dG5zQ2hlY2socjFjc0ZpbGVuYW1lLCB3dG5zRmlsZW5hbWUsIGxvZ2dlcikge1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJXSVRORVNTIENIRUNLSU5HIFNUQVJURURcIik7XG5cbiAgICAvLyBSZWFkIHIxY3MgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIHIxY3MgZmlsZVwiKTtcbiAgICBjb25zdCB7XG4gICAgICAgIGZkOiBmZFIxY3MsXG4gICAgICAgIHNlY3Rpb25zOiBzZWN0aW9uc1IxY3NcbiAgICB9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHIxY3NGaWxlbmFtZSwgXCJyMWNzXCIsIDEsIDEgPDwgMjIsIDEgPDwgMjQpO1xuICAgIGNvbnN0IHIxY3MgPSBhd2FpdCByZWFkUjFjc0ZkKGZkUjFjcywgc2VjdGlvbnNSMWNzLCB7IGxvYWRDb25zdHJhaW50czogZmFsc2UsIGxvYWRDdXN0b21HYXRlczogZmFsc2UgfSk7XG5cbiAgICAvLyBSZWFkIHdpdG5lc3MgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIHdpdG5lc3MgZmlsZVwiKTtcbiAgICBjb25zdCB7XG4gICAgICAgIGZkOiBmZFd0bnMsXG4gICAgICAgIHNlY3Rpb25zOiB3dG5zU2VjdGlvbnNcbiAgICB9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHd0bnNGaWxlbmFtZSwgXCJ3dG5zXCIsIDIsIDEgPDwgMjIsIDEgPDwgMjQpO1xuICAgIGNvbnN0IHd0bnNIZWFkZXIgPSBhd2FpdCB3dG5zVXRpbHMucmVhZEhlYWRlcihmZFd0bnMsIHd0bnNTZWN0aW9ucyk7XG5cbiAgICBpZiAoIVNjYWxhci5lcShyMWNzLnByaW1lLCB3dG5zSGVhZGVyLnEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN1cnZlIG9mIHRoZSB3aXRuZXNzIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJ2ZSBvZiB0aGUgcHJvdmluZyBrZXlcIik7XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRXdG5zLCB3dG5zU2VjdGlvbnMsIDIpO1xuICAgIGF3YWl0IGZkV3Rucy5jbG9zZSgpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBjdXJ2ZXMuZ2V0Q3VydmVGcm9tUihyMWNzLnByaW1lKTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHNGciA9IEZyLm44O1xuXG4gICAgY29uc3QgYlIxY3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRSMWNzLCBzZWN0aW9uc1IxY3MsIDIpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiICBXSVRORVNTIENIRUNLXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXJ2ZTogICAgICAgICAgJHtyMWNzLmN1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFZhcnMgKHdpcmVzKTogICAke3IxY3MublZhcnN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIE91dHB1dHM6ICAgICAgICAke3IxY3Mubk91dHB1dHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFB1YmxpYyBJbnB1dHM6ICAke3IxY3MublB1YklucHV0c31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHJpdmF0ZSBJbnB1dHM6ICR7cjFjcy5uUHJ2SW5wdXRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBMYWJlbHM6ICAgICAgICAgJHtyMWNzLm5MYWJlbHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENvbnN0cmFpbnRzOiAgICAke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXN0b20gR2F0ZXM6ICAgJHtyMWNzLnVzZUN1c3RvbUdhdGVzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENoZWNraW5nIHdpdG5lc3MgY29ycmVjdG5lc3NcIik7XG5cbiAgICBsZXQgYlIxY3NQb3MgPSAwO1xuICAgIGxldCByZXMgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjFjcy5uQ29uc3RyYWludHM7IGkrKykge1xuICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGkgIT09IDApICYmIChpICUgNTAwMDAwID09PSAwKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYMK3wrfCtyBwcm9jZXNzaW5nIHIxY3MgY29uc3RyYWludHMgJHtpfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9SZWFkIHRoZSB0aHJlZSBsaW5lYXIgY29tYmluYXRpb25zIG9mIHRoZSBjb25zdHJhaW50IHdoZXJlIEEgKiBCIC0gQyA9IDBcbiAgICAgICAgY29uc3QgbGNBID0gcmVhZExDKCk7XG4gICAgICAgIGNvbnN0IGxjQiA9IHJlYWRMQygpO1xuICAgICAgICBjb25zdCBsY0MgPSByZWFkTEMoKTtcblxuICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgbGluZWFyIGNvbWJpbmF0aW9uc1xuICAgICAgICBjb25zdCBldmFsQSA9IEV2YWx1YXRlTGluZWFyQ29tYmluYXRpb24obGNBKTtcbiAgICAgICAgY29uc3QgZXZhbEIgPSBFdmFsdWF0ZUxpbmVhckNvbWJpbmF0aW9uKGxjQik7XG4gICAgICAgIGNvbnN0IGV2YWxDID0gRXZhbHVhdGVMaW5lYXJDb21iaW5hdGlvbihsY0MpO1xuXG4gICAgICAgIC8vIENoZWNrIHRoYXQgQSAqIEIgLSBDID09IDBcbiAgICAgICAgaWYgKCFGci5lcShGci5zdWIoRnIubXVsKGV2YWxBLCBldmFsQiksIGV2YWxDKSwgRnIuemVybykpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiwrfCt8K3IGFib3J0aW5nIGNoZWNraW5nIHByb2Nlc3MgYXQgY29uc3RyYWludCBcIiArIGkpO1xuICAgICAgICAgICAgcmVzID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZkUjFjcy5jbG9zZSgpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIldJVE5FU1MgSVMgQ09SUkVDVFwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiV0lUTkVTUyBDSEVDS0lORyBGSU5JU0hFRCBTVUNDRVNTRlVMTFlcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIldJVE5FU1MgSVMgTk9UIENPUlJFQ1RcIik7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIldJVE5FU1MgQ0hFQ0tJTkcgRklOSVNIRUQgVU5TVUNDRVNTRlVMTFlcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuXG4gICAgZnVuY3Rpb24gRXZhbHVhdGVMaW5lYXJDb21iaW5hdGlvbihsYykge1xuICAgICAgICBsZXQgcmVzID0gRnIuemVybztcblxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobGMpO1xuICAgICAgICBrZXlzLmZvckVhY2goKHNpZ25hbElkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxWYWx1ZSA9IGdldFdpdG5lc3NWYWx1ZShzaWduYWxJZCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxGYWN0b3IgPSBsY1tzaWduYWxJZF07XG5cbiAgICAgICAgICAgIHJlcyA9IEZyLmFkZChyZXMsIEZyLm11bChzaWduYWxWYWx1ZSwgc2lnbmFsRmFjdG9yKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZExDKCkge1xuICAgICAgICBjb25zdCBsYyA9IHt9O1xuXG4gICAgICAgIGNvbnN0IGJ1ZmZVTDMyID0gYlIxY3Muc2xpY2UoYlIxY3NQb3MsIGJSMWNzUG9zICsgNCk7XG4gICAgICAgIGJSMWNzUG9zICs9IDQ7XG4gICAgICAgIGNvbnN0IGJ1ZmZVTDMyViA9IG5ldyBEYXRhVmlldyhidWZmVUwzMi5idWZmZXIpO1xuICAgICAgICBjb25zdCBuSWR4ID0gYnVmZlVMMzJWLmdldFVpbnQzMigwLCB0cnVlKTtcblxuICAgICAgICBjb25zdCBidWZmID0gYlIxY3Muc2xpY2UoYlIxY3NQb3MsIGJSMWNzUG9zICsgKDQgKyByMWNzLm44KSAqIG5JZHgpO1xuICAgICAgICBiUjFjc1BvcyArPSAoNCArIHIxY3MubjgpICogbklkeDtcbiAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5JZHg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gYnVmZlYuZ2V0VWludDMyKGkgKiAoNCArIHIxY3MubjgpLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHIxY3MuRi5mcm9tUnByTEUoYnVmZiwgaSAqICg0ICsgcjFjcy5uOCkgKyA0KTtcbiAgICAgICAgICAgIGxjW2lkeF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpdG5lc3NWYWx1ZShzaWduYWxJZCkge1xuICAgICAgICByZXR1cm4gRnIuZnJvbVJwckxFKGJ1ZmZXaXRuZXNzLnNsaWNlKHNpZ25hbElkICogc0ZyLCBzaWduYWxJZCAqIHNGciArIHNGcikpO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/wtns_check.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/wtns_debug.js":
/*!************************************************!*\
  !*** ./node_modules/snarkjs/src/wtns_debug.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsDebug)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var circom_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! circom_runtime */ \"(rsc)/./node_modules/circom_runtime/main.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _loadsyms_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loadsyms.js */ \"(rsc)/./node_modules/snarkjs/src/loadsyms.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_5__.utils;\n\n\nasync function wtnsDebug(_input, wasmFileName, wtnsFileName, symName, options, logger) {\n\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wcOps = {...options, sanityCheck: true};\n    let sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n    if (options.set) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logSetSignal= function(labelIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"SET \" + sym.labelIdx2Name[labelIdx] + \" <\" + \"-- \" + value.toString());\n        };\n    }\n    if (options.get) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logGetSignal= function(varIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"GET \" + sym.labelIdx2Name[varIdx] + \" --\" + \"> \" + value.toString());\n        };\n    }\n    if (options.trigger) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logStartComponent= function(cIdx) {\n            if (logger) logger.info(\"START: \" + sym.componentIdx2Name[cIdx]);\n        };\n        wcOps.logFinishComponent= function(cIdx) {\n            if (logger) logger.info(\"FINISH: \" + sym.componentIdx2Name[cIdx]);\n        };\n    }\n    wcOps.sym = sym;\n\n    const wc = await (0,circom_runtime__WEBPACK_IMPORTED_MODULE_1__.WitnessCalculatorBuilder)(wasm, wcOps);\n    const w = await wc.calculateWitness(input, true);\n\n    const fdWtns = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n    await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.write(fdWtns, w, wc.prime);\n\n    await fdWtns.close();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDcUI7QUFDYjtBQUNPO0FBQ2Y7QUFDRztBQUN4QyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOzs7QUFHbkI7O0FBRWY7O0FBRUEseUJBQXlCLGtEQUFxQjtBQUM5QztBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixvQkFBb0Isd0RBQVE7QUFDNUI7QUFDQSw4QkFBOEIsd0RBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdEQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3REFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix3RUFBd0I7QUFDN0M7O0FBRUEseUJBQXlCLDhEQUEwQjs7QUFFbkQsVUFBVSxpREFBZTs7QUFFekI7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy93dG5zX2RlYnVnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuaW1wb3J0IHsgV2l0bmVzc0NhbGN1bGF0b3JCdWlsZGVyIH0gZnJvbSBcImNpcmNvbV9ydW50aW1lXCI7XG5pbXBvcnQgKiBhcyB3dG5zVXRpbHMgZnJvbSBcIi4vd3Ruc191dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgbG9hZFN5bXMgZnJvbSBcIi4vbG9hZHN5bXMuanNcIjtcbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB3dG5zRGVidWcoX2lucHV0LCB3YXNtRmlsZU5hbWUsIHd0bnNGaWxlTmFtZSwgc3ltTmFtZSwgb3B0aW9ucywgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyhfaW5wdXQpO1xuXG4gICAgY29uc3QgZmRXYXNtID0gYXdhaXQgZmFzdEZpbGUucmVhZEV4aXN0aW5nKHdhc21GaWxlTmFtZSk7XG4gICAgY29uc3Qgd2FzbSA9IGF3YWl0IGZkV2FzbS5yZWFkKGZkV2FzbS50b3RhbFNpemUpO1xuICAgIGF3YWl0IGZkV2FzbS5jbG9zZSgpO1xuXG4gICAgY29uc3Qgd2NPcHMgPSB7Li4ub3B0aW9ucywgc2FuaXR5Q2hlY2s6IHRydWV9O1xuICAgIGxldCBzeW0gPSBhd2FpdCBsb2FkU3ltcyhzeW1OYW1lKTtcbiAgICBpZiAob3B0aW9ucy5zZXQpIHtcbiAgICAgICAgaWYgKCFzeW0pIHN5bSA9IGF3YWl0IGxvYWRTeW1zKHN5bU5hbWUpO1xuICAgICAgICB3Y09wcy5sb2dTZXRTaWduYWw9IGZ1bmN0aW9uKGxhYmVsSWR4LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIGxpbmUgYmVsb3cgc3BsaXRzIHRoZSBhcnJvdyBsb2cgaW50byAyIHN0cmluZ3MgdG8gYXZvaWQgc29tZSBTZWN1cmUgRUNNQVNjcmlwdCBpc3N1ZXNcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiU0VUIFwiICsgc3ltLmxhYmVsSWR4Mk5hbWVbbGFiZWxJZHhdICsgXCIgPFwiICsgXCItLSBcIiArIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5nZXQpIHtcbiAgICAgICAgaWYgKCFzeW0pIHN5bSA9IGF3YWl0IGxvYWRTeW1zKHN5bU5hbWUpO1xuICAgICAgICB3Y09wcy5sb2dHZXRTaWduYWw9IGZ1bmN0aW9uKHZhcklkeCwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBsaW5lIGJlbG93IHNwbGl0cyB0aGUgYXJyb3cgbG9nIGludG8gMiBzdHJpbmdzIHRvIGF2b2lkIHNvbWUgU2VjdXJlIEVDTUFTY3JpcHQgaXNzdWVzXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkdFVCBcIiArIHN5bS5sYWJlbElkeDJOYW1lW3ZhcklkeF0gKyBcIiAtLVwiICsgXCI+IFwiICsgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRyaWdnZXIpIHtcbiAgICAgICAgaWYgKCFzeW0pIHN5bSA9IGF3YWl0IGxvYWRTeW1zKHN5bU5hbWUpO1xuICAgICAgICB3Y09wcy5sb2dTdGFydENvbXBvbmVudD0gZnVuY3Rpb24oY0lkeCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJTVEFSVDogXCIgKyBzeW0uY29tcG9uZW50SWR4Mk5hbWVbY0lkeF0pO1xuICAgICAgICB9O1xuICAgICAgICB3Y09wcy5sb2dGaW5pc2hDb21wb25lbnQ9IGZ1bmN0aW9uKGNJZHgpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRklOSVNIOiBcIiArIHN5bS5jb21wb25lbnRJZHgyTmFtZVtjSWR4XSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHdjT3BzLnN5bSA9IHN5bTtcblxuICAgIGNvbnN0IHdjID0gYXdhaXQgV2l0bmVzc0NhbGN1bGF0b3JCdWlsZGVyKHdhc20sIHdjT3BzKTtcbiAgICBjb25zdCB3ID0gYXdhaXQgd2MuY2FsY3VsYXRlV2l0bmVzcyhpbnB1dCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBmZFd0bnMgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZSh3dG5zRmlsZU5hbWUsIFwid3Ruc1wiLCAyLCAyKTtcblxuICAgIGF3YWl0IHd0bnNVdGlscy53cml0ZShmZFd0bnMsIHcsIHdjLnByaW1lKTtcblxuICAgIGF3YWl0IGZkV3Rucy5jbG9zZSgpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/wtns_debug.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/wtns_export_json.js":
/*!******************************************************!*\
  !*** ./node_modules/snarkjs/src/wtns_export_json.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsExportJson)\n/* harmony export */ });\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wtns_utils.js */ \"(rsc)/./node_modules/snarkjs/src/wtns_utils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nasync function wtnsExportJson(wtnsFileName) {\n\n    const w = await (0,_wtns_utils_js__WEBPACK_IMPORTED_MODULE_0__.read)(wtnsFileName);\n\n    return w;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19leHBvcnRfanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFDOztBQUV0Qjs7QUFFZixvQkFBb0Isb0RBQUk7O0FBRXhCO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19leHBvcnRfanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQge3JlYWR9IGZyb20gXCIuL3d0bnNfdXRpbHMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gd3Ruc0V4cG9ydEpzb24od3Ruc0ZpbGVOYW1lKSB7XG5cbiAgICBjb25zdCB3ID0gYXdhaXQgcmVhZCh3dG5zRmlsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHc7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/wtns_export_json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/wtns_utils.js":
/*!************************************************!*\
  !*** ./node_modules/snarkjs/src/wtns_utils.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   read: () => (/* binding */ read),\n/* harmony export */   readHeader: () => (/* binding */ readHeader),\n/* harmony export */   write: () => (/* binding */ write),\n/* harmony export */   writeBin: () => (/* binding */ writeBin)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function write(fd, witness, prime) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, prime, n8);\n    await fd.writeULE32(witness.length);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    for (let i=0; i<witness.length; i++) {\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, witness[i], n8);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd, 2);\n\n\n}\n\nasync function writeBin(fd, witnessBin, prime) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, prime, n8);\n    if (witnessBin.byteLength % n8 != 0) {\n        throw new Error(\"Invalid witness length\");\n    }\n    await fd.writeULE32(witnessBin.byteLength / n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    await fd.write(witnessBin);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n}\n\nasync function readHeader(fd, sections) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 1);\n    const n8 = await fd.readULE32();\n    const q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8);\n    const nWitness = await fd.readULE32();\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return {n8, q, nWitness};\n\n}\n\nasync function read(fileName) {\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(fileName, \"wtns\", 2);\n\n    const {n8, nWitness} = await readHeader(fd, sections);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const res = [];\n    for (let i=0; i<nWitness; i++) {\n        const v = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8);\n        res.push(v);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    await fd.close();\n\n    return res;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVzQzs7QUFFYzs7O0FBRzdDOztBQUVQLFVBQVUsa0VBQThCO0FBQ3hDLDZCQUE2QixnREFBTTtBQUNuQztBQUNBLFVBQVUsNERBQXdCO0FBQ2xDO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixrQkFBa0I7QUFDcEMsY0FBYyw0REFBd0I7QUFDdEM7QUFDQSxVQUFVLGdFQUE0Qjs7O0FBR3RDOztBQUVPOztBQUVQLFVBQVUsa0VBQThCO0FBQ3hDLDZCQUE2QixnREFBTTtBQUNuQztBQUNBLFVBQVUsNERBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7OztBQUd0QyxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLFVBQVUsZ0VBQTRCOztBQUV0Qzs7QUFFTzs7QUFFUCxVQUFVLHVFQUFtQztBQUM3QztBQUNBLG9CQUFvQiwyREFBdUI7QUFDM0M7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckMsWUFBWTs7QUFFWjs7QUFFTzs7QUFFUCxXQUFXLGNBQWMsUUFBUSw0REFBd0I7O0FBRXpELFdBQVcsY0FBYzs7QUFFekIsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSxrQkFBa0IsWUFBWTtBQUM5Qix3QkFBd0IsMkRBQXVCO0FBQy9DO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckM7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy93dG5zX3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlKGZkLCB3aXRuZXNzLCBwcmltZSkge1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAxKTtcbiAgICBjb25zdCBuOCA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZSkgLSAxKSAvIDY0KSArMSkqODtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKG44KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMud3JpdGVCaWdJbnQoZmQsIHByaW1lLCBuOCk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMih3aXRuZXNzLmxlbmd0aCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDIpO1xuICAgIGZvciAobGV0IGk9MDsgaTx3aXRuZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy53cml0ZUJpZ0ludChmZCwgd2l0bmVzc1tpXSwgbjgpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkLCAyKTtcblxuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZUJpbihmZCwgd2l0bmVzc0JpbiwgcHJpbWUpIHtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMSk7XG4gICAgY29uc3QgbjggPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWUpIC0gMSkgLyA2NCkgKzEpKjg7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihuOCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLndyaXRlQmlnSW50KGZkLCBwcmltZSwgbjgpO1xuICAgIGlmICh3aXRuZXNzQmluLmJ5dGVMZW5ndGggJSBuOCAhPSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2l0bmVzcyBsZW5ndGhcIik7XG4gICAgfVxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIod2l0bmVzc0Jpbi5ieXRlTGVuZ3RoIC8gbjgpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDIpO1xuICAgIGF3YWl0IGZkLndyaXRlKHdpdG5lc3NCaW4pO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyKGZkLCBzZWN0aW9ucykge1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAxKTtcbiAgICBjb25zdCBuOCA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IHEgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpZ0ludChmZCwgbjgpO1xuICAgIGNvbnN0IG5XaXRuZXNzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiB7bjgsIHEsIG5XaXRuZXNzfTtcblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZChmaWxlTmFtZSkge1xuXG4gICAgY29uc3Qge2ZkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoZmlsZU5hbWUsIFwid3Ruc1wiLCAyKTtcblxuICAgIGNvbnN0IHtuOCwgbldpdG5lc3N9ID0gYXdhaXQgcmVhZEhlYWRlcihmZCwgc2VjdGlvbnMpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAyKTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bldpdG5lc3M7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaWdJbnQoZmQsIG44KTtcbiAgICAgICAgcmVzLnB1c2godik7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/wtns_utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey.js":
/*!******************************************!*\
  !*** ./node_modules/snarkjs/src/zkey.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   beacon: () => (/* reexport safe */ _zkey_beacon_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   bellmanContribute: () => (/* reexport safe */ _zkey_bellman_contribute_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   contribute: () => (/* reexport safe */ _zkey_contribute_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   exportBellman: () => (/* reexport safe */ _zkey_export_bellman_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _zkey_export_json_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   exportSolidityVerifier: () => (/* reexport safe */ _zkey_export_solidityverifier_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   exportVerificationKey: () => (/* reexport safe */ _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   importBellman: () => (/* reexport safe */ _zkey_import_bellman_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   newZKey: () => (/* reexport safe */ _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verifyFromInit: () => (/* reexport safe */ _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   verifyFromR1cs: () => (/* reexport safe */ _zkey_verify_fromr1cs_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_new.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_new.js\");\n/* harmony import */ var _zkey_export_bellman_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_export_bellman.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_export_bellman.js\");\n/* harmony import */ var _zkey_import_bellman_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zkey_import_bellman.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_import_bellman.js\");\n/* harmony import */ var _zkey_verify_fromr1cs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zkey_verify_fromr1cs.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_verify_fromr1cs.js\");\n/* harmony import */ var _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_verify_frominit.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_verify_frominit.js\");\n/* harmony import */ var _zkey_contribute_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zkey_contribute.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_contribute.js\");\n/* harmony import */ var _zkey_beacon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zkey_beacon.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_beacon.js\");\n/* harmony import */ var _zkey_export_json_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zkey_export_json.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_export_json.js\");\n/* harmony import */ var _zkey_bellman_contribute_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./zkey_bellman_contribute.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_bellman_contribute.js\");\n/* harmony import */ var _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./zkey_export_verificationkey.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_export_verificationkey.js\");\n/* harmony import */ var _zkey_export_solidityverifier_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./zkey_export_solidityverifier.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_export_solidityverifier.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR2lEO0FBQ2lCO0FBQ0E7QUFDRTtBQUNBO0FBQ1Q7QUFDUjtBQUNTO0FBQ2M7QUFDUTtBQUNFIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuXG5leHBvcnQge2RlZmF1bHQgYXMgbmV3WktleX0gZnJvbSBcIi4vemtleV9uZXcuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRCZWxsbWFufSBmcm9tIFwiLi96a2V5X2V4cG9ydF9iZWxsbWFuLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW1wb3J0QmVsbG1hbn0gZnJvbSBcIi4vemtleV9pbXBvcnRfYmVsbG1hbi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZlcmlmeUZyb21SMWNzfSBmcm9tIFwiLi96a2V5X3ZlcmlmeV9mcm9tcjFjcy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZlcmlmeUZyb21Jbml0fSBmcm9tIFwiLi96a2V5X3ZlcmlmeV9mcm9taW5pdC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNvbnRyaWJ1dGV9IGZyb20gXCIuL3prZXlfY29udHJpYnV0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGJlYWNvbn0gZnJvbSBcIi4vemtleV9iZWFjb24uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRKc29ufSBmcm9tIFwiLi96a2V5X2V4cG9ydF9qc29uLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYmVsbG1hbkNvbnRyaWJ1dGV9IGZyb20gXCIuL3prZXlfYmVsbG1hbl9jb250cmlidXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0VmVyaWZpY2F0aW9uS2V5fSBmcm9tIFwiLi96a2V5X2V4cG9ydF92ZXJpZmljYXRpb25rZXkuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRTb2xpZGl0eVZlcmlmaWVyfSBmcm9tIFwiLi96a2V5X2V4cG9ydF9zb2xpZGl0eXZlcmlmaWVyLmpzXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_beacon.js":
/*!*************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_beacon.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ beacon)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(rsc)/./node_modules/snarkjs/src/mpc_applykey.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\nasync function beacon(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger) {\n    const beaconHash = _misc_js__WEBPACK_IMPORTED_MODULE_3__.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections: sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdOld, sections);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const transcriptHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });;\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_4__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 1;\n    curContribution.numIterationsExp = numIterationsExp;\n    curContribution.beaconHash = beaconHash;\n\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeHeader(fdNew, zkey);\n\n    // IC\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__.applyKeyToSection)(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__.applyKeyToSection)(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });;\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9iZWFjb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDtBQUNQO0FBQ1c7QUFDdEI7QUFDYztBQUNQO0FBQ1c7QUFDRTs7O0FBR3ZDO0FBQ2YsdUJBQXVCLG1EQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxXQUFXLCtCQUErQixRQUFRLDREQUF3QjtBQUMxRSx1QkFBdUIsc0RBQW9COztBQUUzQztBQUNBO0FBQ0E7OztBQUdBLHdCQUF3Qix5REFBUTs7QUFFaEMsNEJBQTRCLHlEQUF1Qjs7QUFFbkQsd0JBQXdCLDhEQUEwQjs7QUFFbEQsc0JBQXNCLHlEQUF3Qjs7QUFFOUMsNkJBQTZCLDBEQUFPLFVBQVUsV0FBVztBQUN6RDtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQsUUFBUSxzREFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0RBQVk7QUFDaEIsSUFBSSxrREFBWTtBQUNoQjtBQUNBLGtDQUFrQyxxREFBUTtBQUMxQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLHVEQUFxQjs7QUFFL0I7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLG1FQUFpQjtBQUMzQixVQUFVLG1FQUFpQjs7QUFFM0IsVUFBVSwwREFBd0I7O0FBRWxDO0FBQ0E7O0FBRUEsK0JBQStCLDBEQUFPLFVBQVUsV0FBVztBQUMzRCxJQUFJLHNEQUFnQjs7QUFFcEI7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfYmVhY29uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IGdldEN1cnZlRnJvbVEgYXMgZ2V0Q3VydmUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgYmxha2UyYiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2JsYWtlMmJcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IGhhc2hUb0cyIGFzIGhhc2hUb0cyIH0gZnJvbSBcIi4va2V5cGFpci5qc1wiO1xuaW1wb3J0IHsgYXBwbHlLZXlUb1NlY3Rpb24gfSBmcm9tIFwiLi9tcGNfYXBwbHlrZXkuanNcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBiZWFjb24oemtleU5hbWVPbGQsIHprZXlOYW1lTmV3LCBuYW1lLCBiZWFjb25IYXNoU3RyLCBudW1JdGVyYXRpb25zRXhwLCBsb2dnZXIpIHtcbiAgICBjb25zdCBiZWFjb25IYXNoID0gbWlzYy5oZXgyQnl0ZUFycmF5KGJlYWNvbkhhc2hTdHIpO1xuICAgIGlmICggICAoYmVhY29uSGFzaC5ieXRlTGVuZ3RoID09IDApXG4gICAgICAgIHx8IChiZWFjb25IYXNoLmJ5dGVMZW5ndGgqMiAhPWJlYWNvbkhhc2hTdHIubGVuZ3RoKSlcbiAgICB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgQmVhY29uIEhhc2guIChJdCBtdXN0IGJlIGEgdmFsaWQgaGV4YWRlY2ltYWwgc2VxdWVuY2UpXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiZWFjb25IYXNoLmxlbmd0aD49MjU2KSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIk1heGltdW0gbGVuZ3RoIG9mIGJlYWNvbiBoYXNoIGlzIDI1NSBieXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG51bUl0ZXJhdGlvbnNFeHAgPSBwYXJzZUludChudW1JdGVyYXRpb25zRXhwKTtcbiAgICBpZiAoKG51bUl0ZXJhdGlvbnNFeHA8MTApfHwobnVtSXRlcmF0aW9uc0V4cD42MykpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1JdGVyYXRpb25zRXhwLiAoTXVzdCBiZSBiZXR3ZWVuIDEwIGFuZCA2MylcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zOiBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoemtleU5hbWVPbGQsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcblxuICAgIGlmICh6a2V5LnByb3RvY29sICE9IFwiZ3JvdGgxNlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcblxuICAgIGNvbnN0IG1wY1BhcmFtcyA9IGF3YWl0IHprZXlVdGlscy5yZWFkTVBDUGFyYW1zKGZkT2xkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZSh6a2V5TmFtZU5ldywgXCJ6a2V5XCIsIDEsIDEwKTtcblxuICAgIGNvbnN0IHJuZyA9IGF3YWl0IG1pc2Mucm5nRnJvbUJlYWNvblBhcmFtcyhiZWFjb25IYXNoLCBudW1JdGVyYXRpb25zRXhwKTtcblxuICAgIGNvbnN0IHRyYW5zY3JpcHRIYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTs7XG4gICAgdHJhbnNjcmlwdEhhc2hlci51cGRhdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHV0aWxzLmhhc2hQdWJLZXkodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJDb250cmlidXRpb24gPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEgPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5ID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEuZnJvbVJuZyhybmcpKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KSk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3gpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0ID0gdHJhbnNjcmlwdEhhc2hlci5kaWdlc3QoKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AgPSBoYXNoVG9HMihjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLnRyYW5zY3JpcHQpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcHggPSBjdXJ2ZS5HMi50b0FmZmluZShjdXJ2ZS5HMi50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcCwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSkpO1xuXG4gICAgemtleS52a19kZWx0YV8xID0gY3VydmUuRzEudGltZXNGcih6a2V5LnZrX2RlbHRhXzEsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpO1xuICAgIHprZXkudmtfZGVsdGFfMiA9IGN1cnZlLkcyLnRpbWVzRnIoemtleS52a19kZWx0YV8yLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YUFmdGVyID0gemtleS52a19kZWx0YV8xO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLnR5cGUgPSAxO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5udW1JdGVyYXRpb25zRXhwID0gbnVtSXRlcmF0aW9uc0V4cDtcbiAgICBjdXJDb250cmlidXRpb24uYmVhY29uSGFzaCA9IGJlYWNvbkhhc2g7XG5cbiAgICBpZiAobmFtZSkgY3VyQ29udHJpYnV0aW9uLm5hbWUgPSBuYW1lO1xuXG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgemtleVV0aWxzLndyaXRlSGVhZGVyKGZkTmV3LCB6a2V5KTtcblxuICAgIC8vIElDXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDMpO1xuXG4gICAgLy8gQ29lZmZzIChLZWVwIG9yaWdpbmFsKVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA0KTtcblxuICAgIC8vIEEgU2VjdGlvblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1KTtcblxuICAgIC8vIEIxIFNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNik7XG5cbiAgICAvLyBCMiBTZWN0aW9uXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDcpO1xuXG4gICAgY29uc3QgaW52RGVsdGEgPSBjdXJ2ZS5Gci5pbnYoY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOCwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiTCBTZWN0aW9uXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOSwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiSCBTZWN0aW9uXCIsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCB6a2V5VXRpbHMud3JpdGVNUENQYXJhbXMoZmROZXcsIGN1cnZlLCBtcGNQYXJhbXMpO1xuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7O1xuICAgIHV0aWxzLmhhc2hQdWJLZXkoY29udHJpYnV0aW9uSGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2ggPSBjb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY29udHJpYnV0aW9uSGFzaCwgXCJDb250cmlidXRpb24gSGFzaDogXCIpKTtcblxuICAgIHJldHVybiBjb250cmlidXRpb25IYXNoO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_beacon.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_bellman_contribute.js":
/*!*************************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_bellman_contribute.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ bellmanContribute)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(rsc)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(rsc)/./node_modules/snarkjs/src/mpc_applykey.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/./node_modules/snarkjs/src/keypair.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\n\n\n\n\n\n\n\n\nasync function bellmanContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_2__.getRandomRng(entropy);\n\n    const delta = curve.Fr.fromRng(rng);\n    const invDelta = curve.Fr.inv(delta);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const fdFrom = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(challengeFilename);\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(responseFileName);\n\n\n    await copy(sG1); // alpha1\n    await copy(sG1); // beta1\n    await copy(sG2); // beta2\n    await copy(sG2); // gamma2\n    const oldDelta1 = await readG1();\n    const delta1 = curve.G1.timesFr(oldDelta1, delta);\n    await writeG1(delta1);\n    const oldDelta2 = await readG2();\n    const delta2 = curve.G2.timesFr(oldDelta2, delta);\n    await writeG2(delta2);\n\n    // IC\n    const nIC = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nIC);\n    await copy(nIC*sG1);\n\n    // H\n    const nH = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nH);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, null, curve, \"G1\", nH, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"H\", logger);\n\n    // L\n    const nL = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nL);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, null, curve, \"G1\", nL, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"L\", logger);\n\n    // A\n    const nA = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nA);\n    await copy(nA*sG1);\n\n    // B1\n    const nB1 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB1);\n    await copy(nB1*sG1);\n\n    // B2\n    const nB2 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB2);\n    await copy(nB2*sG2);\n\n\n    //////////\n    /// Read contributions\n    //////////\n    const transcriptHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 });;\n\n    const mpcParams = {};\n    // csHash\n    mpcParams.csHash =  await fdFrom.read(64);\n    transcriptHasher.update(mpcParams.csHash);\n\n    const nContributions = await fdFrom.readUBE32();\n    mpcParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1();\n        c.delta.g1_s = await readG1();\n        c.delta.g1_sx = await readG1();\n        c.delta.g2_spx = await readG2();\n        c.transcript = await fdFrom.read(64);\n        mpcParams.contributions.push(c);\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(transcriptHasher, curve, c);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = delta;\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, delta));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_4__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, delta));\n    curContribution.deltaAfter = delta1;\n    curContribution.type = 0;\n    mpcParams.contributions.push(curContribution);\n\n\n    //////////\n    /// Write Contribution\n    //////////\n\n    await fdTo.write(mpcParams.csHash);\n    await fdTo.writeUBE32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdTo.write(c.transcript);\n    }\n\n    const contributionHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 });;\n    (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n\n    return contributionHash;\n\n    async function copy(nBytes) {\n        const CHUNK_SIZE = fdFrom.pageSize*2;\n        for (let i=0; i<nBytes; i+= CHUNK_SIZE) {\n            const n = Math.min(nBytes -i, CHUNK_SIZE);\n            const buff = await fdFrom.read(n);\n            await fdTo.write(buff);\n        }\n    }\n\n    async function readG1() {\n        const buff = await fdFrom.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2() {\n        const buff = await fdFrom.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9iZWxsbWFuX2NvbnRyaWJ1dGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDVztBQUNQO0FBQ1A7QUFDNkI7QUFDbEI7QUFDTzs7QUFFckM7QUFDZixzQkFBc0Isa0RBQWlCOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLGtEQUFxQjtBQUM5Qyx1QkFBdUIsb0RBQXVCOzs7QUFHOUMscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRFQUEwQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0RUFBMEI7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQU8sVUFBVSxXQUFXOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBVTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCO0FBQ0Esa0NBQWtDLHFEQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isa0NBQWtDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiwwREFBTyxVQUFVLFdBQVc7QUFDM0QsSUFBSSwwREFBVTs7QUFFZDs7QUFFQSw0QkFBNEIsZ0RBQWU7O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2JlbGxtYW5fY29udHJpYnV0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBGb3JtYXQgb2YgdGhlIG91dHB1dFxuLy8gICAgICBIYXNoIG9mIHRoZSBsYXN0IGNvbnRyaWJ1dGlvbiAgNjQgQnl0ZXNcbi8vICAgICAgMl5OKjItMSBUYXVHMSBQb2ludHMgKGNvbXByZXNzZWQpXG4vLyAgICAgIDJeTiBUYXVHMiBQb2ludHMgKGNvbXByZXNzZWQpXG4vLyAgICAgIDJeTiBBbHBoYVRhdUcxIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgMl5OIEJldGFUYXVHMSBQb2ludHMgKGNvbXByZXNzZWQpXG4vLyAgICAgIFB1YmxpYyBLZXlcbi8vICAgICAgICAgIEJldGFHMiAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnMgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSpzKnRhdSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnQgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSp0KmFscGhhIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnUqYmV0YSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcyKnNwKnRhdSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcyKnRwKmFscGhhIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzIqdXAqYmV0YSAoY29tcHJlc3NlZClcblxuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5pbXBvcnQgeyBibGFrZTJiIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvYmxha2UyYlwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbiB9IGZyb20gXCIuL21wY19hcHBseWtleS5qc1wiO1xuaW1wb3J0IHsgaGFzaFB1YktleSB9IGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IGhhc2hUb0cyIGFzIGhhc2hUb0cyIH0gZnJvbSBcIi4va2V5cGFpci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBiZWxsbWFuQ29udHJpYnV0ZShjdXJ2ZSwgY2hhbGxlbmdlRmlsZW5hbWUsIHJlc3BvbnNlRmlsZU5hbWUsIGVudHJvcHksIGxvZ2dlcikge1xuICAgIGNvbnN0IHJuZyA9IGF3YWl0IG1pc2MuZ2V0UmFuZG9tUm5nKGVudHJvcHkpO1xuXG4gICAgY29uc3QgZGVsdGEgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAgY29uc3QgaW52RGVsdGEgPSBjdXJ2ZS5Gci5pbnYoZGVsdGEpO1xuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcblxuICAgIGNvbnN0IGZkRnJvbSA9IGF3YWl0IGZhc3RGaWxlLnJlYWRFeGlzdGluZyhjaGFsbGVuZ2VGaWxlbmFtZSk7XG4gICAgY29uc3QgZmRUbyA9IGF3YWl0IGZhc3RGaWxlLmNyZWF0ZU92ZXJyaWRlKHJlc3BvbnNlRmlsZU5hbWUpO1xuXG5cbiAgICBhd2FpdCBjb3B5KHNHMSk7IC8vIGFscGhhMVxuICAgIGF3YWl0IGNvcHkoc0cxKTsgLy8gYmV0YTFcbiAgICBhd2FpdCBjb3B5KHNHMik7IC8vIGJldGEyXG4gICAgYXdhaXQgY29weShzRzIpOyAvLyBnYW1tYTJcbiAgICBjb25zdCBvbGREZWx0YTEgPSBhd2FpdCByZWFkRzEoKTtcbiAgICBjb25zdCBkZWx0YTEgPSBjdXJ2ZS5HMS50aW1lc0ZyKG9sZERlbHRhMSwgZGVsdGEpO1xuICAgIGF3YWl0IHdyaXRlRzEoZGVsdGExKTtcbiAgICBjb25zdCBvbGREZWx0YTIgPSBhd2FpdCByZWFkRzIoKTtcbiAgICBjb25zdCBkZWx0YTIgPSBjdXJ2ZS5HMi50aW1lc0ZyKG9sZERlbHRhMiwgZGVsdGEpO1xuICAgIGF3YWl0IHdyaXRlRzIoZGVsdGEyKTtcblxuICAgIC8vIElDXG4gICAgY29uc3QgbklDID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuSUMpO1xuICAgIGF3YWl0IGNvcHkobklDKnNHMSk7XG5cbiAgICAvLyBIXG4gICAgY29uc3QgbkggPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5IKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIG51bGwsIGN1cnZlLCBcIkcxXCIsIG5ILCBpbnZEZWx0YSwgY3VydmUuRnIuZSgxKSwgXCJVTkNPTVBSRVNTRURcIiwgXCJIXCIsIGxvZ2dlcik7XG5cbiAgICAvLyBMXG4gICAgY29uc3QgbkwgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5MKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIG51bGwsIGN1cnZlLCBcIkcxXCIsIG5MLCBpbnZEZWx0YSwgY3VydmUuRnIuZSgxKSwgXCJVTkNPTVBSRVNTRURcIiwgXCJMXCIsIGxvZ2dlcik7XG5cbiAgICAvLyBBXG4gICAgY29uc3QgbkEgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5BKTtcbiAgICBhd2FpdCBjb3B5KG5BKnNHMSk7XG5cbiAgICAvLyBCMVxuICAgIGNvbnN0IG5CMSA9IGF3YWl0IGZkRnJvbS5yZWFkVUJFMzIoKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlVUJFMzIobkIxKTtcbiAgICBhd2FpdCBjb3B5KG5CMSpzRzEpO1xuXG4gICAgLy8gQjJcbiAgICBjb25zdCBuQjIgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5CMik7XG4gICAgYXdhaXQgY29weShuQjIqc0cyKTtcblxuXG4gICAgLy8vLy8vLy8vL1xuICAgIC8vLyBSZWFkIGNvbnRyaWJ1dGlvbnNcbiAgICAvLy8vLy8vLy8vXG4gICAgY29uc3QgdHJhbnNjcmlwdEhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pOztcblxuICAgIGNvbnN0IG1wY1BhcmFtcyA9IHt9O1xuICAgIC8vIGNzSGFzaFxuICAgIG1wY1BhcmFtcy5jc0hhc2ggPSAgYXdhaXQgZmRGcm9tLnJlYWQoNjQpO1xuICAgIHRyYW5zY3JpcHRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuXG4gICAgY29uc3QgbkNvbnRyaWJ1dGlvbnMgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bkNvbnRyaWJ1dGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBjID0geyBkZWx0YTp7fSB9O1xuICAgICAgICBjLmRlbHRhQWZ0ZXIgPSBhd2FpdCByZWFkRzEoKTtcbiAgICAgICAgYy5kZWx0YS5nMV9zID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgICAgIGMuZGVsdGEuZzFfc3ggPSBhd2FpdCByZWFkRzEoKTtcbiAgICAgICAgYy5kZWx0YS5nMl9zcHggPSBhd2FpdCByZWFkRzIoKTtcbiAgICAgICAgYy50cmFuc2NyaXB0ID0gYXdhaXQgZmRGcm9tLnJlYWQoNjQpO1xuICAgICAgICBtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5wdXNoKGMpO1xuICAgICAgICBoYXNoUHViS2V5KHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJDb250cmlidXRpb24gPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEgPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5ID0gZGVsdGE7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzRnIoY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MsIGRlbHRhKSk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3gpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0ID0gdHJhbnNjcmlwdEhhc2hlci5kaWdlc3QoKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AgPSBoYXNoVG9HMihjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLnRyYW5zY3JpcHQpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcHggPSBjdXJ2ZS5HMi50b0FmZmluZShjdXJ2ZS5HMi50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcCwgZGVsdGEpKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGFBZnRlciA9IGRlbHRhMTtcbiAgICBjdXJDb250cmlidXRpb24udHlwZSA9IDA7XG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG5cbiAgICAvLy8vLy8vLy8vXG4gICAgLy8vIFdyaXRlIENvbnRyaWJ1dGlvblxuICAgIC8vLy8vLy8vLy9cblxuICAgIGF3YWl0IGZkVG8ud3JpdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGFBZnRlcik7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YS5nMV9zKTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhLmcxX3N4KTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMihjLmRlbHRhLmcyX3NweCk7XG4gICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYy50cmFuc2NyaXB0KTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250cmlidXRpb25IYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTs7XG4gICAgaGFzaFB1YktleShjb250cmlidXRpb25IYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24pO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaCA9IGNvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjb250cmlidXRpb25IYXNoLCBcIkNvbnRyaWJ1dGlvbiBIYXNoOiBcIikpO1xuXG4gICAgYXdhaXQgZmRUby5jbG9zZSgpO1xuICAgIGF3YWl0IGZkRnJvbS5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIGNvbnRyaWJ1dGlvbkhhc2g7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb3B5KG5CeXRlcykge1xuICAgICAgICBjb25zdCBDSFVOS19TSVpFID0gZmRGcm9tLnBhZ2VTaXplKjI7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQnl0ZXM7IGkrPSBDSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4obkJ5dGVzIC1pLCBDSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChuKTtcbiAgICAgICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzEoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChjdXJ2ZS5HMS5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzEuZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCAwKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzIoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChjdXJ2ZS5HMi5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzIuZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCAwKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUcxKFApIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHNHMSk7XG4gICAgICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDAsIFApO1xuICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIoUCkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc0cyKTtcbiAgICAgICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgUCk7XG4gICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZik7XG4gICAgfVxuXG5cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_bellman_contribute.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_constants.js":
/*!****************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_constants.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FFLONK_PROTOCOL_ID: () => (/* binding */ FFLONK_PROTOCOL_ID),\n/* harmony export */   GROTH16_PROTOCOL_ID: () => (/* binding */ GROTH16_PROTOCOL_ID),\n/* harmony export */   HEADER_ZKEY_SECTION: () => (/* binding */ HEADER_ZKEY_SECTION),\n/* harmony export */   PLONK_PROTOCOL_ID: () => (/* binding */ PLONK_PROTOCOL_ID)\n/* harmony export */ });\nconst HEADER_ZKEY_SECTION = 1;\n\nconst GROTH16_PROTOCOL_ID = 1;\nconst PLONK_PROTOCOL_ID = 2;\nconst FFLONK_PROTOCOL_ID = 10;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFPOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgSEVBREVSX1pLRVlfU0VDVElPTiA9IDE7XG5cbmV4cG9ydCBjb25zdCBHUk9USDE2X1BST1RPQ09MX0lEID0gMTtcbmV4cG9ydCBjb25zdCBQTE9OS19QUk9UT0NPTF9JRCA9IDI7XG5leHBvcnQgY29uc3QgRkZMT05LX1BST1RPQ09MX0lEID0gMTA7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_contribute.js":
/*!*****************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_contribute.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2contribute)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(rsc)/./node_modules/snarkjs/src/mpc_applykey.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\nasync function phase2contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger) {\n\n    const {fd: fdOld, sections: sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdOld, sections);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomRng(entropy);\n\n    const transcriptHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_4__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 0;\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeHeader(fdNew, zkey);\n\n    // IC\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__.applyKeyToSection)(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__.applyKeyToSection)(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9jb250cmlidXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDUDtBQUNXO0FBQ3RCO0FBQ2M7QUFDUDtBQUNXO0FBQ0U7O0FBRXZDOztBQUVmLFdBQVcsK0JBQStCLFFBQVEsNERBQXdCO0FBQzFFLHVCQUF1QixzREFBb0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix5REFBUTs7QUFFaEMsNEJBQTRCLHlEQUF1Qjs7QUFFbkQsd0JBQXdCLDhEQUEwQjs7O0FBR2xELHNCQUFzQixrREFBaUI7O0FBRXZDLDZCQUE2QiwwREFBTyxVQUFVLFdBQVc7QUFDekQ7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELFFBQVEsc0RBQWdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtEQUFZO0FBQ2hCLElBQUksa0RBQVk7QUFDaEI7QUFDQSxrQ0FBa0MscURBQVE7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsdURBQXFCOztBQUUvQjtBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsbUVBQWlCO0FBQzNCLFVBQVUsbUVBQWlCOztBQUUzQixVQUFVLDBEQUF3Qjs7QUFFbEM7QUFDQTs7QUFFQSwrQkFBK0IsMERBQU8sVUFBVSxXQUFXO0FBQzNELElBQUksc0RBQWdCOztBQUVwQjs7QUFFQSw0QkFBNEIsZ0RBQWU7QUFDM0MsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfY29udHJpYnV0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHprZXlVdGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21RIGFzIGdldEN1cnZlIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBoYXNoVG9HMiBhcyBoYXNoVG9HMiB9IGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmltcG9ydCB7IGFwcGx5S2V5VG9TZWN0aW9uIH0gZnJvbSBcIi4vbXBjX2FwcGx5a2V5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBoYXNlMmNvbnRyaWJ1dGUoemtleU5hbWVPbGQsIHprZXlOYW1lTmV3LCBuYW1lLCBlbnRyb3B5LCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zOiBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoemtleU5hbWVPbGQsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuXG4gICAgY29uc3QgbXBjUGFyYW1zID0gYXdhaXQgemtleVV0aWxzLnJlYWRNUENQYXJhbXMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKHprZXlOYW1lTmV3LCBcInprZXlcIiwgMSwgMTApO1xuXG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBtaXNjLmdldFJhbmRvbVJuZyhlbnRyb3B5KTtcblxuICAgIGNvbnN0IHRyYW5zY3JpcHRIYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTtcbiAgICB0cmFuc2NyaXB0SGFzaGVyLnVwZGF0ZShtcGNQYXJhbXMuY3NIYXNoKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXRpbHMuaGFzaFB1YktleSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0pO1xuICAgIH1cblxuICAgIGNvbnN0IGN1ckNvbnRyaWJ1dGlvbiA9IHt9O1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YSA9IHt9O1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzRnIoY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpKTtcbiAgICB1dGlscy5oYXNoRzEodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zKTtcbiAgICB1dGlscy5oYXNoRzEodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zeCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLnRyYW5zY3JpcHQgPSB0cmFuc2NyaXB0SGFzaGVyLmRpZ2VzdCgpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcCA9IGhhc2hUb0cyKGN1cnZlLCBjdXJDb250cmlidXRpb24udHJhbnNjcmlwdCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NweCA9IGN1cnZlLkcyLnRvQWZmaW5lKGN1cnZlLkcyLnRpbWVzRnIoY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NwLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KSk7XG5cbiAgICB6a2V5LnZrX2RlbHRhXzEgPSBjdXJ2ZS5HMS50aW1lc0ZyKHprZXkudmtfZGVsdGFfMSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG4gICAgemtleS52a19kZWx0YV8yID0gY3VydmUuRzIudGltZXNGcih6a2V5LnZrX2RlbHRhXzIsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhQWZ0ZXIgPSB6a2V5LnZrX2RlbHRhXzE7XG5cbiAgICBjdXJDb250cmlidXRpb24udHlwZSA9IDA7XG4gICAgaWYgKG5hbWUpIGN1ckNvbnRyaWJ1dGlvbi5uYW1lID0gbmFtZTtcblxuICAgIG1wY1BhcmFtcy5jb250cmlidXRpb25zLnB1c2goY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGF3YWl0IHprZXlVdGlscy53cml0ZUhlYWRlcihmZE5ldywgemtleSk7XG5cbiAgICAvLyBJQ1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAzKTtcblxuICAgIC8vIENvZWZmcyAoS2VlcCBvcmlnaW5hbClcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNCk7XG5cbiAgICAvLyBBIFNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNSk7XG5cbiAgICAvLyBCMSBTZWN0aW9uXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDYpO1xuXG4gICAgLy8gQjIgU2VjdGlvblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA3KTtcblxuICAgIGNvbnN0IGludkRlbHRhID0gY3VydmUuRnIuaW52KGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9TZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDgsIGN1cnZlLCBcIkcxXCIsIGludkRlbHRhLCBjdXJ2ZS5Gci5lKDEpLCBcIkwgU2VjdGlvblwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9TZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDksIGN1cnZlLCBcIkcxXCIsIGludkRlbHRhLCBjdXJ2ZS5Gci5lKDEpLCBcIkggU2VjdGlvblwiLCBsb2dnZXIpO1xuXG4gICAgYXdhaXQgemtleVV0aWxzLndyaXRlTVBDUGFyYW1zKGZkTmV3LCBjdXJ2ZSwgbXBjUGFyYW1zKTtcblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIHV0aWxzLmhhc2hQdWJLZXkoY29udHJpYnV0aW9uSGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2ggPSBjb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2gobXBjUGFyYW1zLmNzSGFzaCwgXCJDaXJjdWl0IEhhc2g6IFwiKSk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGNvbnRyaWJ1dGlvbkhhc2gsIFwiQ29udHJpYnV0aW9uIEhhc2g6IFwiKSk7XG5cbiAgICByZXR1cm4gY29udHJpYnV0aW9uSGFzaDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_contribute.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_export_bellman.js":
/*!*********************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_export_bellman.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2exportMPCParams)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(rsc)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n\n\n\n\n\n\nasync function phase2exportMPCParams(zkeyName, mpcparamsName, logger) {\n\n    const {fd: fdZKey, sections: sectionsZKey} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, sectionsZKey);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_3__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdZKey, curve, sectionsZKey);\n\n    const fdMPCParams = await fastfile__WEBPACK_IMPORTED_MODULE_2__.createOverride(mpcparamsName);\n\n    /////////////////////\n    // Verification Key Section\n    /////////////////////\n    await writeG1(zkey.vk_alpha_1);\n    await writeG1(zkey.vk_beta_1);\n    await writeG2(zkey.vk_beta_2);\n    await writeG2(zkey.vk_gamma_2);\n    await writeG1(zkey.vk_delta_1);\n    await writeG2(zkey.vk_delta_2);\n\n    // IC\n    let buffBasesIC;\n    buffBasesIC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 3);\n    buffBasesIC = await curve.G1.batchLEMtoU(buffBasesIC);\n\n    await writePointArray(\"G1\", buffBasesIC);\n\n    /////////////////////\n    // h Section\n    /////////////////////\n    const buffBasesH_Lodd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 9);\n\n    let buffBasesH_Tau;\n    buffBasesH_Tau = await curve.G1.fft(buffBasesH_Lodd, \"affine\", \"jacobian\", logger);\n    buffBasesH_Tau = await curve.G1.batchApplyKey(buffBasesH_Tau, curve.Fr.neg(curve.Fr.e(2)), curve.Fr.w[zkey.power+1], \"jacobian\", \"affine\", logger);\n\n    // Remove last element.  (The degree of H will be always m-2)\n    buffBasesH_Tau = buffBasesH_Tau.slice(0, buffBasesH_Tau.byteLength - sG1);\n    buffBasesH_Tau = await curve.G1.batchLEMtoU(buffBasesH_Tau);\n    await writePointArray(\"G1\", buffBasesH_Tau);\n\n    /////////////////////\n    // L section\n    /////////////////////\n    let buffBasesC;\n    buffBasesC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 8);\n    buffBasesC = await curve.G1.batchLEMtoU(buffBasesC);\n    await writePointArray(\"G1\", buffBasesC);\n\n    /////////////////////\n    // A Section (C section)\n    /////////////////////\n    let buffBasesA;\n    buffBasesA = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 5);\n    buffBasesA = await curve.G1.batchLEMtoU(buffBasesA);\n    await writePointArray(\"G1\", buffBasesA);\n\n    /////////////////////\n    // B1 Section\n    /////////////////////\n    let buffBasesB1;\n    buffBasesB1 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 6);\n    buffBasesB1 = await curve.G1.batchLEMtoU(buffBasesB1);\n    await writePointArray(\"G1\", buffBasesB1);\n\n    /////////////////////\n    // B2 Section\n    /////////////////////\n    let buffBasesB2;\n    buffBasesB2 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 7);\n    buffBasesB2 = await curve.G2.batchLEMtoU(buffBasesB2);\n    await writePointArray(\"G2\", buffBasesB2);\n\n    await fdMPCParams.write(mpcParams.csHash);\n    await writeU32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdMPCParams.write(c.transcript);\n    }\n\n    await fdZKey.close();\n    await fdMPCParams.close();\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writePointArray(groupName, buff) {\n        let sG;\n        if (groupName == \"G1\") {\n            sG = sG1;\n        } else {\n            sG = sG2;\n        }\n\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, buff.byteLength / sG, false);\n\n        await fdMPCParams.write(buffSize);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeU32(n) {\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, n, false);\n\n        await fdMPCParams.write(buffSize);\n    }\n\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfYmVsbG1hbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDb0Q7QUFDUDtBQUNSO0FBQ21COztBQUV6Qzs7QUFFZixXQUFXLG9DQUFvQyxRQUFRLDREQUF3QjtBQUMvRSx1QkFBdUIsc0RBQW9CO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IseURBQVE7QUFDaEM7QUFDQTs7QUFFQSw0QkFBNEIseURBQXVCOztBQUVuRCw4QkFBOEIsb0RBQXVCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qiw0REFBd0I7QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDREQUF3Qjs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDREQUF3QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDREQUF3QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfZXhwb3J0X2JlbGxtYW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHprZXlVdGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCB7IGdldEN1cnZlRnJvbVEgYXMgZ2V0Q3VydmUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGhhc2UyZXhwb3J0TVBDUGFyYW1zKHprZXlOYW1lLCBtcGNwYXJhbXNOYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRaS2V5LCBzZWN0aW9uczogc2VjdGlvbnNaS2V5fSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5TmFtZSwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXkgPSBhd2FpdCB6a2V5VXRpbHMucmVhZEhlYWRlcihmZFpLZXksIHNlY3Rpb25zWktleSk7XG4gICAgaWYgKHprZXkucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuXG4gICAgY29uc3QgbXBjUGFyYW1zID0gYXdhaXQgemtleVV0aWxzLnJlYWRNUENQYXJhbXMoZmRaS2V5LCBjdXJ2ZSwgc2VjdGlvbnNaS2V5KTtcblxuICAgIGNvbnN0IGZkTVBDUGFyYW1zID0gYXdhaXQgZmFzdEZpbGUuY3JlYXRlT3ZlcnJpZGUobXBjcGFyYW1zTmFtZSk7XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBWZXJpZmljYXRpb24gS2V5IFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBhd2FpdCB3cml0ZUcxKHprZXkudmtfYWxwaGFfMSk7XG4gICAgYXdhaXQgd3JpdGVHMSh6a2V5LnZrX2JldGFfMSk7XG4gICAgYXdhaXQgd3JpdGVHMih6a2V5LnZrX2JldGFfMik7XG4gICAgYXdhaXQgd3JpdGVHMih6a2V5LnZrX2dhbW1hXzIpO1xuICAgIGF3YWl0IHdyaXRlRzEoemtleS52a19kZWx0YV8xKTtcbiAgICBhd2FpdCB3cml0ZUcyKHprZXkudmtfZGVsdGFfMik7XG5cbiAgICAvLyBJQ1xuICAgIGxldCBidWZmQmFzZXNJQztcbiAgICBidWZmQmFzZXNJQyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgMyk7XG4gICAgYnVmZkJhc2VzSUMgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShidWZmQmFzZXNJQyk7XG5cbiAgICBhd2FpdCB3cml0ZVBvaW50QXJyYXkoXCJHMVwiLCBidWZmQmFzZXNJQyk7XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBoIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBjb25zdCBidWZmQmFzZXNIX0xvZGQgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDkpO1xuXG4gICAgbGV0IGJ1ZmZCYXNlc0hfVGF1O1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuZmZ0KGJ1ZmZCYXNlc0hfTG9kZCwgXCJhZmZpbmVcIiwgXCJqYWNvYmlhblwiLCBsb2dnZXIpO1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hBcHBseUtleShidWZmQmFzZXNIX1RhdSwgY3VydmUuRnIubmVnKGN1cnZlLkZyLmUoMikpLCBjdXJ2ZS5Gci53W3prZXkucG93ZXIrMV0sIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyKTtcblxuICAgIC8vIFJlbW92ZSBsYXN0IGVsZW1lbnQuICAoVGhlIGRlZ3JlZSBvZiBIIHdpbGwgYmUgYWx3YXlzIG0tMilcbiAgICBidWZmQmFzZXNIX1RhdSA9IGJ1ZmZCYXNlc0hfVGF1LnNsaWNlKDAsIGJ1ZmZCYXNlc0hfVGF1LmJ5dGVMZW5ndGggLSBzRzEpO1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzSF9UYXUpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0hfVGF1KTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEwgc2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGxldCBidWZmQmFzZXNDO1xuICAgIGJ1ZmZCYXNlc0MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDgpO1xuICAgIGJ1ZmZCYXNlc0MgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShidWZmQmFzZXNDKTtcbiAgICBhd2FpdCB3cml0ZVBvaW50QXJyYXkoXCJHMVwiLCBidWZmQmFzZXNDKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEEgU2VjdGlvbiAoQyBzZWN0aW9uKVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGxldCBidWZmQmFzZXNBO1xuICAgIGJ1ZmZCYXNlc0EgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDUpO1xuICAgIGJ1ZmZCYXNlc0EgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShidWZmQmFzZXNBKTtcbiAgICBhd2FpdCB3cml0ZVBvaW50QXJyYXkoXCJHMVwiLCBidWZmQmFzZXNBKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEIxIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBsZXQgYnVmZkJhc2VzQjE7XG4gICAgYnVmZkJhc2VzQjEgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDYpO1xuICAgIGJ1ZmZCYXNlc0IxID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzQjEpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0IxKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEIyIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBsZXQgYnVmZkJhc2VzQjI7XG4gICAgYnVmZkJhc2VzQjIgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDcpO1xuICAgIGJ1ZmZCYXNlc0IyID0gYXdhaXQgY3VydmUuRzIuYmF0Y2hMRU10b1UoYnVmZkJhc2VzQjIpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcyXCIsIGJ1ZmZCYXNlc0IyKTtcblxuICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGF3YWl0IHdyaXRlVTMyKG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGFBZnRlcik7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YS5nMV9zKTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhLmcxX3N4KTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMihjLmRlbHRhLmcyX3NweCk7XG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGMudHJhbnNjcmlwdCk7XG4gICAgfVxuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRNUENQYXJhbXMuY2xvc2UoKTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEoUCkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc0cxKTtcbiAgICAgICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgUCk7XG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIoUCkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc0cyKTtcbiAgICAgICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgUCk7XG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUG9pbnRBcnJheShncm91cE5hbWUsIGJ1ZmYpIHtcbiAgICAgICAgbGV0IHNHO1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgc0cgPSBzRzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzRyA9IHNHMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZTaXplID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZTaXplViA9IG5ldyBEYXRhVmlldyhidWZmU2l6ZS5idWZmZXIsIGJ1ZmZTaXplLmJ5dGVPZmZzZXQsIGJ1ZmZTaXplLmJ5dGVMZW5ndGgpO1xuICAgICAgICBidWZmU2l6ZVYuc2V0VWludDMyKDAsIGJ1ZmYuYnl0ZUxlbmd0aCAvIHNHLCBmYWxzZSk7XG5cbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYnVmZlNpemUpO1xuICAgICAgICBhd2FpdCBmZE1QQ1BhcmFtcy53cml0ZShidWZmKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVUzMihuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZTaXplID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZTaXplViA9IG5ldyBEYXRhVmlldyhidWZmU2l6ZS5idWZmZXIsIGJ1ZmZTaXplLmJ5dGVPZmZzZXQsIGJ1ZmZTaXplLmJ5dGVMZW5ndGgpO1xuICAgICAgICBidWZmU2l6ZVYuc2V0VWludDMyKDAsIG4sIGZhbHNlKTtcblxuICAgICAgICBhd2FpdCBmZE1QQ1BhcmFtcy53cml0ZShidWZmU2l6ZSk7XG4gICAgfVxuXG5cblxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_export_bellman.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_export_json.js":
/*!******************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_export_json.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ zkeyExportJson)\n/* harmony export */ });\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n\n\n\nasync function zkeyExportJson(zkeyFileName) {\n\n    const zKey = await (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readZKey)(zkeyFileName, true);\n    delete zKey.curve;\n    delete zKey.F;\n\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils.stringifyBigInts(zKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUQ7QUFDbEI7O0FBRXRCOztBQUVmLHVCQUF1Qix3REFBUTtBQUMvQjtBQUNBOztBQUVBLFdBQVcsK0NBQUs7QUFDaEIiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWFkWktleSBhcyByZWFkWktleSB9IGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IHV0aWxzIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB6a2V5RXhwb3J0SnNvbih6a2V5RmlsZU5hbWUpIHtcblxuICAgIGNvbnN0IHpLZXkgPSBhd2FpdCByZWFkWktleSh6a2V5RmlsZU5hbWUsIHRydWUpO1xuICAgIGRlbGV0ZSB6S2V5LmN1cnZlO1xuICAgIGRlbGV0ZSB6S2V5LkY7XG5cbiAgICByZXR1cm4gdXRpbHMuc3RyaW5naWZ5QmlnSW50cyh6S2V5KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_export_json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_export_solidityverifier.js":
/*!******************************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_export_solidityverifier.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportSolidityVerifier)\n/* harmony export */ });\n/* harmony import */ var ejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ejs */ \"(rsc)/./node_modules/ejs/lib/ejs.js\");\n/* harmony import */ var _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_export_verificationkey.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_export_verificationkey.js\");\n/* harmony import */ var _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fflonk_export_solidity_verifier.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\");\n\n\n\n\n// Not ready yet\n// module.exports.generateVerifier_kimleeoh = generateVerifier_kimleeoh;\n\nasync function exportSolidityVerifier(zKeyName, templates, logger) {\n\n    const verificationKey = await (0,_zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(zKeyName, logger);\n\n    if (\"fflonk\" === verificationKey.protocol) {\n        return (0,_fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(verificationKey, templates, logger);\n    }\n\n    let template = templates[verificationKey.protocol];\n\n    return ejs__WEBPACK_IMPORTED_MODULE_0__.render(template, verificationKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfc29saWRpdHl2ZXJpZmllci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNCOztBQUUrQztBQUNjO0FBQ25GO0FBQ0E7O0FBRWU7O0FBRWYsa0NBQWtDLDJFQUFxQjs7QUFFdkQ7QUFDQSxlQUFlLCtFQUErQjtBQUM5Qzs7QUFFQTs7QUFFQSxXQUFXLHVDQUFVO0FBQ3JCIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfZXhwb3J0X3NvbGlkaXR5dmVyaWZpZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGVqcyBmcm9tIFwiZWpzXCI7XG5cbmltcG9ydCBleHBvcnRWZXJpZmljYXRpb25LZXkgZnJvbSBcIi4vemtleV9leHBvcnRfdmVyaWZpY2F0aW9ua2V5LmpzXCI7XG5pbXBvcnQgZmZsb25rRXhwb3J0U29saWRpdHlWZXJpZmllckNtZCBmcm9tIFwiLi9mZmxvbmtfZXhwb3J0X3NvbGlkaXR5X3ZlcmlmaWVyLmpzXCI7XG4vLyBOb3QgcmVhZHkgeWV0XG4vLyBtb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZVZlcmlmaWVyX2tpbWxlZW9oID0gZ2VuZXJhdGVWZXJpZmllcl9raW1sZWVvaDtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0U29saWRpdHlWZXJpZmllcih6S2V5TmFtZSwgdGVtcGxhdGVzLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHZlcmlmaWNhdGlvbktleSA9IGF3YWl0IGV4cG9ydFZlcmlmaWNhdGlvbktleSh6S2V5TmFtZSwgbG9nZ2VyKTtcblxuICAgIGlmIChcImZmbG9ua1wiID09PSB2ZXJpZmljYXRpb25LZXkucHJvdG9jb2wpIHtcbiAgICAgICAgcmV0dXJuIGZmbG9ua0V4cG9ydFNvbGlkaXR5VmVyaWZpZXJDbWQodmVyaWZpY2F0aW9uS2V5LCB0ZW1wbGF0ZXMsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVzW3ZlcmlmaWNhdGlvbktleS5wcm90b2NvbF07XG5cbiAgICByZXR1cm4gZWpzLnJlbmRlcih0ZW1wbGF0ZSwgdmVyaWZpY2F0aW9uS2V5KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_export_solidityverifier.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_export_verificationkey.js":
/*!*****************************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_export_verificationkey.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ zkeyExportVerificationKey)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_constants.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_3__.utils;\n\nasync function zkeyExportVerificationKey(zkeyName, logger) {\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY STARTED\");\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fd, sections);\n\n    if (logger) logger.info(\"> Detected protocol: \" + zkey.protocol);\n\n    let res;\n    if (zkey.protocol === \"groth16\") {\n        res = await groth16Vk(zkey, fd, sections);\n    } else if (zkey.protocol === \"plonk\") {\n        res = await plonkVk(zkey);\n    } else if (zkey.protocolId && zkey.protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        res = await exportFFlonkVk(zkey, logger);\n    } else {\n        throw new Error(\"zkey file protocol unrecognized\");\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY FINISHED\");\n\n    return res;\n}\n\n\nasync function groth16Vk(zkey, fd, sections) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8 * 2;\n\n    const alphaBeta = await curve.pairing(zkey.vk_alpha_1, zkey.vk_beta_2);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n\n        vk_alpha_1: curve.G1.toObject(zkey.vk_alpha_1),\n\n        vk_beta_2: curve.G2.toObject(zkey.vk_beta_2),\n        vk_gamma_2: curve.G2.toObject(zkey.vk_gamma_2),\n        vk_delta_2: curve.G2.toObject(zkey.vk_delta_2),\n\n        vk_alphabeta_12: curve.Gt.toObject(alphaBeta)\n    };\n\n    // Read IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd, sections, 3);\n    vKey.IC = [];\n    for (let i = 0; i <= zkey.nPublic; i++) {\n        const buff = await fd.read(sG1);\n        const P = curve.G1.toObject(buff);\n        vKey.IC.push(P);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd);\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\n\nasync function plonkVk(zkey) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        Qm: curve.G1.toObject(zkey.Qm),\n        Ql: curve.G1.toObject(zkey.Ql),\n        Qr: curve.G1.toObject(zkey.Qr),\n        Qo: curve.G1.toObject(zkey.Qo),\n        Qc: curve.G1.toObject(zkey.Qc),\n        S1: curve.G1.toObject(zkey.S1),\n        S2: curve.G1.toObject(zkey.S2),\n        S3: curve.G1.toObject(zkey.S3),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power])\n    };\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\nasync function exportFFlonkVk(zkey, logger) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power]),\n        //wW: curve.Fr.toObject(curve.Fr.w[zkey.power + 1]),\n        w3: curve.Fr.toObject(zkey.w3),\n        w4: curve.Fr.toObject(zkey.w4),\n        w8: curve.Fr.toObject(zkey.w8),\n        wr: curve.Fr.toObject(zkey.wr),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        C0: curve.G1.toObject(zkey.C0),\n    };\n\n    return stringifyBigInts(vKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfdmVyaWZpY2F0aW9ua2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ1A7QUFDUztBQUNuQjtBQUNvQjs7QUFFdkQsT0FBTyxrQkFBa0IsRUFBRSwrQ0FBSzs7QUFFakI7QUFDZjs7QUFFQSxXQUFXLGNBQWMsUUFBUSw0REFBd0I7QUFDekQsdUJBQXVCLHNEQUFvQjs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTSxnREFBZ0Qsa0VBQWtCO0FBQ3hFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSx3QkFBd0IseURBQVE7QUFDaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOztBQUVyQzs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLHdCQUF3Qix5REFBUTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHlEQUFROztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2V4cG9ydF92ZXJpZmljYXRpb25rZXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0IHtnZXRDdXJ2ZUZyb21RIGFzIGdldEN1cnZlfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7dXRpbHN9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCB7RkZMT05LX1BST1RPQ09MX0lEfSBmcm9tIFwiLi96a2V5X2NvbnN0YW50cy5qc1wiO1xuXG5jb25zdCB7c3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gemtleUV4cG9ydFZlcmlmaWNhdGlvbktleSh6a2V5TmFtZSwgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJFWFBPUlQgVkVSSUZJQ0FUSU9OIEtFWSBTVEFSVEVEXCIpO1xuXG4gICAgY29uc3Qge2ZkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoemtleU5hbWUsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmQsIHNlY3Rpb25zKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBEZXRlY3RlZCBwcm90b2NvbDogXCIgKyB6a2V5LnByb3RvY29sKTtcblxuICAgIGxldCByZXM7XG4gICAgaWYgKHprZXkucHJvdG9jb2wgPT09IFwiZ3JvdGgxNlwiKSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IGdyb3RoMTZWayh6a2V5LCBmZCwgc2VjdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoemtleS5wcm90b2NvbCA9PT0gXCJwbG9ua1wiKSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IHBsb25rVmsoemtleSk7XG4gICAgfSBlbHNlIGlmICh6a2V5LnByb3RvY29sSWQgJiYgemtleS5wcm90b2NvbElkID09PSBGRkxPTktfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgcmVzID0gYXdhaXQgZXhwb3J0RkZsb25rVmsoemtleSwgbG9nZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgcHJvdG9jb2wgdW5yZWNvZ25pemVkXCIpO1xuICAgIH1cblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkVYUE9SVCBWRVJJRklDQVRJT04gS0VZIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBncm90aDE2VmsoemtleSwgZmQsIHNlY3Rpb25zKSB7XG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjggKiAyO1xuXG4gICAgY29uc3QgYWxwaGFCZXRhID0gYXdhaXQgY3VydmUucGFpcmluZyh6a2V5LnZrX2FscGhhXzEsIHprZXkudmtfYmV0YV8yKTtcblxuICAgIGxldCB2S2V5ID0ge1xuICAgICAgICBwcm90b2NvbDogemtleS5wcm90b2NvbCxcbiAgICAgICAgY3VydmU6IGN1cnZlLm5hbWUsXG4gICAgICAgIG5QdWJsaWM6IHprZXkublB1YmxpYyxcblxuICAgICAgICB2a19hbHBoYV8xOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LnZrX2FscGhhXzEpLFxuXG4gICAgICAgIHZrX2JldGFfMjogY3VydmUuRzIudG9PYmplY3QoemtleS52a19iZXRhXzIpLFxuICAgICAgICB2a19nYW1tYV8yOiBjdXJ2ZS5HMi50b09iamVjdCh6a2V5LnZrX2dhbW1hXzIpLFxuICAgICAgICB2a19kZWx0YV8yOiBjdXJ2ZS5HMi50b09iamVjdCh6a2V5LnZrX2RlbHRhXzIpLFxuXG4gICAgICAgIHZrX2FscGhhYmV0YV8xMjogY3VydmUuR3QudG9PYmplY3QoYWxwaGFCZXRhKVxuICAgIH07XG5cbiAgICAvLyBSZWFkIElDIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMyk7XG4gICAgdktleS5JQyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKHNHMSk7XG4gICAgICAgIGNvbnN0IFAgPSBjdXJ2ZS5HMS50b09iamVjdChidWZmKTtcbiAgICAgICAgdktleS5JQy5wdXNoKFApO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgdktleSA9IHN0cmluZ2lmeUJpZ0ludHModktleSk7XG5cbiAgICByZXR1cm4gdktleTtcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBwbG9ua1ZrKHprZXkpIHtcbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSk7XG5cbiAgICBsZXQgdktleSA9IHtcbiAgICAgICAgcHJvdG9jb2w6IHprZXkucHJvdG9jb2wsXG4gICAgICAgIGN1cnZlOiBjdXJ2ZS5uYW1lLFxuICAgICAgICBuUHVibGljOiB6a2V5Lm5QdWJsaWMsXG4gICAgICAgIHBvd2VyOiB6a2V5LnBvd2VyLFxuXG4gICAgICAgIGsxOiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5LmsxKSxcbiAgICAgICAgazI6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkuazIpLFxuXG4gICAgICAgIFFtOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlFtKSxcbiAgICAgICAgUWw6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUWwpLFxuICAgICAgICBRcjogY3VydmUuRzEudG9PYmplY3QoemtleS5RciksXG4gICAgICAgIFFvOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlFvKSxcbiAgICAgICAgUWM6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUWMpLFxuICAgICAgICBTMTogY3VydmUuRzEudG9PYmplY3QoemtleS5TMSksXG4gICAgICAgIFMyOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlMyKSxcbiAgICAgICAgUzM6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUzMpLFxuXG4gICAgICAgIFhfMjogY3VydmUuRzIudG9PYmplY3QoemtleS5YXzIpLFxuXG4gICAgICAgIHc6IGN1cnZlLkZyLnRvT2JqZWN0KGN1cnZlLkZyLndbemtleS5wb3dlcl0pXG4gICAgfTtcblxuICAgIHZLZXkgPSBzdHJpbmdpZnlCaWdJbnRzKHZLZXkpO1xuXG4gICAgcmV0dXJuIHZLZXk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4cG9ydEZGbG9ua1ZrKHprZXksIGxvZ2dlcikge1xuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcblxuICAgIGxldCB2S2V5ID0ge1xuICAgICAgICBwcm90b2NvbDogemtleS5wcm90b2NvbCxcbiAgICAgICAgY3VydmU6IGN1cnZlLm5hbWUsXG4gICAgICAgIG5QdWJsaWM6IHprZXkublB1YmxpYyxcbiAgICAgICAgcG93ZXI6IHprZXkucG93ZXIsXG5cbiAgICAgICAgazE6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkuazEpLFxuICAgICAgICBrMjogY3VydmUuRnIudG9PYmplY3QoemtleS5rMiksXG5cbiAgICAgICAgdzogY3VydmUuRnIudG9PYmplY3QoY3VydmUuRnIud1t6a2V5LnBvd2VyXSksXG4gICAgICAgIC8vd1c6IGN1cnZlLkZyLnRvT2JqZWN0KGN1cnZlLkZyLndbemtleS5wb3dlciArIDFdKSxcbiAgICAgICAgdzM6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkudzMpLFxuICAgICAgICB3NDogY3VydmUuRnIudG9PYmplY3QoemtleS53NCksXG4gICAgICAgIHc4OiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5Lnc4KSxcbiAgICAgICAgd3I6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkud3IpLFxuXG4gICAgICAgIFhfMjogY3VydmUuRzIudG9PYmplY3QoemtleS5YXzIpLFxuXG4gICAgICAgIEMwOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LkMwKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeUJpZ0ludHModktleSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_export_verificationkey.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_import_bellman.js":
/*!*********************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_import_bellman.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2importMPCParams)\n/* harmony export */ });\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(rsc)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function phase2importMPCParams(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger) {\n\n    const {fd: fdZKeyOld, sections: sectionsZKeyOld} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkeyHeader = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readHeader(fdZKeyOld, sectionsZKeyOld, false);\n    if (zkeyHeader.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_3__.getCurveFromQ)(zkeyHeader.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const oldMPCParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readMPCParams(fdZKeyOld, curve, sectionsZKeyOld);\n    const newMPCParams = {};\n\n    const fdMPCParams = await fastfile__WEBPACK_IMPORTED_MODULE_2__.readExisting(mpcparamsName);\n\n    fdMPCParams.pos =\n        sG1*3 + sG2*3 +                     // vKey\n        8 + sG1*zkeyHeader.nVars +              // IC + C\n        4 + sG1*(zkeyHeader.domainSize-1) +     // H\n        4 + sG1*zkeyHeader.nVars +              // A\n        4 + sG1*zkeyHeader.nVars +              // B1\n        4 + sG2*zkeyHeader.nVars;               // B2\n\n    // csHash\n    newMPCParams.csHash =  await fdMPCParams.read(64);\n\n    const nContributions = await fdMPCParams.readUBE32();\n    newMPCParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1(fdMPCParams);\n        c.delta.g1_s = await readG1(fdMPCParams);\n        c.delta.g1_sx = await readG1(fdMPCParams);\n        c.delta.g2_spx = await readG2(fdMPCParams);\n        c.transcript = await fdMPCParams.read(64);\n        if (i<oldMPCParams.contributions.length) {\n            c.type = oldMPCParams.contributions[i].type;\n            if (c.type==1) {\n                c.beaconHash = oldMPCParams.contributions[i].beaconHash;\n                c.numIterationsExp = oldMPCParams.contributions[i].numIterationsExp;\n            }\n            if (oldMPCParams.contributions[i].name) {\n                c.name = oldMPCParams.contributions[i].name;\n            }\n        }\n        newMPCParams.contributions.push(c);\n    }\n\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(newMPCParams.csHash, oldMPCParams.csHash)) {\n        if (logger) logger.error(\"Hash of the original circuit does not match with the MPC one\");\n        return false;\n    }\n\n    if (oldMPCParams.contributions.length > newMPCParams.contributions.length) {\n        if (logger) logger.error(\"The impoerted file does not include new contributions\");\n        return false;\n    }\n\n    for (let i=0; i<oldMPCParams.contributions.length; i++) {\n        if (!contributionIsEqual(oldMPCParams.contributions[i], newMPCParams.contributions[i])) {\n            if (logger) logger.error(`Previous contribution ${i} does not match`);\n            return false;\n        }\n    }\n\n\n    // Set the same name to all new contributions\n    if (name) {\n        for (let i=oldMPCParams.contributions.length; i<newMPCParams.contributions.length; i++) {\n            newMPCParams.contributions[i].name = name;\n        }\n    }\n\n    const fdZKeyNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n    fdMPCParams.pos = 0;\n\n    // Header\n    fdMPCParams.pos += sG1;  // ignore alpha1 (keep original)\n    fdMPCParams.pos += sG1;  // ignore beta1\n    fdMPCParams.pos += sG2;  // ignore beta2\n    fdMPCParams.pos += sG2;  // ignore gamma2\n    zkeyHeader.vk_delta_1 = await readG1(fdMPCParams);\n    zkeyHeader.vk_delta_2 = await readG2(fdMPCParams);\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeHeader(fdZKeyNew, zkeyHeader);\n\n    // IC (Keep original)\n    const nIC = await fdMPCParams.readUBE32();\n    if (nIC != zkeyHeader.nPublic +1) {\n        if (logger) logger.error(\"Invalid number of points in IC\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nPublic+1);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 4);\n\n    // H Section\n    const nH = await fdMPCParams.readUBE32();\n    if (nH != zkeyHeader.domainSize-1) {\n        if (logger) logger.error(\"Invalid number of points in H\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffH;\n    const buffTauU = await fdMPCParams.read(sG1*(zkeyHeader.domainSize-1));\n    const buffTauLEM = await curve.G1.batchUtoLEM(buffTauU);\n    buffH = new Uint8Array(zkeyHeader.domainSize*sG1);\n    buffH.set(buffTauLEM);   // Let the last one to zero.\n    curve.G1.toRprLEM(buffH, sG1*(zkeyHeader.domainSize-1), curve.G1.zeroAffine);\n    const n2Inv = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n    const wInv = curve.Fr.inv(curve.Fr.w[zkeyHeader.power+1]);\n    buffH = await curve.G1.batchApplyKey(buffH, n2Inv, wInv, \"affine\", \"jacobian\", logger);\n    buffH = await curve.G1.ifft(buffH, \"jacobian\", \"affine\", logger);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fdZKeyNew, 9);\n    await fdZKeyNew.write(buffH);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fdZKeyNew);\n\n    // C Section (L section)\n    const nL = await fdMPCParams.readUBE32();\n    if (nL != (zkeyHeader.nVars-zkeyHeader.nPublic-1)) {\n        if (logger) logger.error(\"Invalid number of points in L\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffL;\n    buffL = await fdMPCParams.read(sG1*(zkeyHeader.nVars-zkeyHeader.nPublic-1));\n    buffL = await curve.G1.batchUtoLEM(buffL);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fdZKeyNew, 8);\n    await fdZKeyNew.write(buffL);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fdZKeyNew);\n\n    // A Section\n    const nA = await fdMPCParams.readUBE32();\n    if (nA != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in A\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 5);\n\n    // B1 Section\n    const nB1 = await fdMPCParams.readUBE32();\n    if (nB1 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B1\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 6);\n\n    // B2 Section\n    const nB2 = await fdMPCParams.readUBE32();\n    if (nB2 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B2\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG2*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 7);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeMPCParams(fdZKeyNew, curve, newMPCParams);\n\n    await fdMPCParams.close();\n    await fdZKeyNew.close();\n    await fdZKeyOld.close();\n\n    return true;\n\n    async function readG1(fd) {\n        const buff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2(fd) {\n        const buff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n\n    function contributionIsEqual(c1, c2) {\n        if (!curve.G1.eq(c1.deltaAfter   , c2.deltaAfter)) return false;\n        if (!curve.G1.eq(c1.delta.g1_s   , c2.delta.g1_s)) return false;\n        if (!curve.G1.eq(c1.delta.g1_sx  , c2.delta.g1_sx)) return false;\n        if (!curve.G2.eq(c1.delta.g2_spx , c2.delta.g2_spx)) return false;\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(c1.transcript, c2.transcript)) return false;\n        return true;\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9pbXBvcnRfYmVsbG1hbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU2QztBQUNPO0FBQ2Y7QUFDbUI7QUFDdEI7O0FBRW5COztBQUVmLFdBQVcsMENBQTBDLFFBQVEsNERBQXdCO0FBQ3JGLDZCQUE2QixzREFBb0I7QUFDakQ7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix5REFBUTtBQUNoQztBQUNBOztBQUVBLCtCQUErQix5REFBdUI7QUFDdEQ7O0FBRUEsOEJBQThCLGtEQUFxQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsaURBQWdCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUNBQXFDO0FBQ3ZEO0FBQ0EsOERBQThELEdBQUc7QUFDakU7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esc0RBQXNELHFDQUFxQztBQUMzRjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDhEQUEwQjtBQUN0RDs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSx1REFBcUI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLFVBQVUsZ0VBQTRCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0REFBd0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNERBQXdCOztBQUVsQyxVQUFVLDBEQUF3Qjs7QUFFbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpREFBZ0I7QUFDN0I7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9pbXBvcnRfYmVsbG1hbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCB7IGdldEN1cnZlRnJvbVEgYXMgZ2V0Q3VydmUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwaGFzZTJpbXBvcnRNUENQYXJhbXMoemtleU5hbWVPbGQsIG1wY3BhcmFtc05hbWUsIHprZXlOYW1lTmV3LCBuYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRaS2V5T2xkLCBzZWN0aW9uczogc2VjdGlvbnNaS2V5T2xkfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5TmFtZU9sZCwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXlIZWFkZXIgPSBhd2FpdCB6a2V5VXRpbHMucmVhZEhlYWRlcihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmFsc2UpO1xuICAgIGlmICh6a2V5SGVhZGVyLnByb3RvY29sICE9IFwiZ3JvdGgxNlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXlIZWFkZXIucSk7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcblxuICAgIGNvbnN0IG9sZE1QQ1BhcmFtcyA9IGF3YWl0IHprZXlVdGlscy5yZWFkTVBDUGFyYW1zKGZkWktleU9sZCwgY3VydmUsIHNlY3Rpb25zWktleU9sZCk7XG4gICAgY29uc3QgbmV3TVBDUGFyYW1zID0ge307XG5cbiAgICBjb25zdCBmZE1QQ1BhcmFtcyA9IGF3YWl0IGZhc3RGaWxlLnJlYWRFeGlzdGluZyhtcGNwYXJhbXNOYW1lKTtcblxuICAgIGZkTVBDUGFyYW1zLnBvcyA9XG4gICAgICAgIHNHMSozICsgc0cyKjMgKyAgICAgICAgICAgICAgICAgICAgIC8vIHZLZXlcbiAgICAgICAgOCArIHNHMSp6a2V5SGVhZGVyLm5WYXJzICsgICAgICAgICAgICAgIC8vIElDICsgQ1xuICAgICAgICA0ICsgc0cxKih6a2V5SGVhZGVyLmRvbWFpblNpemUtMSkgKyAgICAgLy8gSFxuICAgICAgICA0ICsgc0cxKnprZXlIZWFkZXIublZhcnMgKyAgICAgICAgICAgICAgLy8gQVxuICAgICAgICA0ICsgc0cxKnprZXlIZWFkZXIublZhcnMgKyAgICAgICAgICAgICAgLy8gQjFcbiAgICAgICAgNCArIHNHMip6a2V5SGVhZGVyLm5WYXJzOyAgICAgICAgICAgICAgIC8vIEIyXG5cbiAgICAvLyBjc0hhc2hcbiAgICBuZXdNUENQYXJhbXMuY3NIYXNoID0gIGF3YWl0IGZkTVBDUGFyYW1zLnJlYWQoNjQpO1xuXG4gICAgY29uc3QgbkNvbnRyaWJ1dGlvbnMgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkVUJFMzIoKTtcbiAgICBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxuQ29udHJpYnV0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSB7IGRlbHRhOnt9IH07XG4gICAgICAgIGMuZGVsdGFBZnRlciA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMuZGVsdGEuZzFfcyA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMuZGVsdGEuZzFfc3ggPSBhd2FpdCByZWFkRzEoZmRNUENQYXJhbXMpO1xuICAgICAgICBjLmRlbHRhLmcyX3NweCA9IGF3YWl0IHJlYWRHMihmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMudHJhbnNjcmlwdCA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWQoNjQpO1xuICAgICAgICBpZiAoaTxvbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGMudHlwZSA9IG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLnR5cGU7XG4gICAgICAgICAgICBpZiAoYy50eXBlPT0xKSB7XG4gICAgICAgICAgICAgICAgYy5iZWFjb25IYXNoID0gb2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0uYmVhY29uSGFzaDtcbiAgICAgICAgICAgICAgICBjLm51bUl0ZXJhdGlvbnNFeHAgPSBvbGRNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXS5udW1JdGVyYXRpb25zRXhwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjLm5hbWUgPSBvbGRNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgaWYgKCFtaXNjLmhhc2hJc0VxdWFsKG5ld01QQ1BhcmFtcy5jc0hhc2gsIG9sZE1QQ1BhcmFtcy5jc0hhc2gpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkhhc2ggb2YgdGhlIG9yaWdpbmFsIGNpcmN1aXQgZG9lcyBub3QgbWF0Y2ggd2l0aCB0aGUgTVBDIG9uZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGggPiBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiVGhlIGltcG9lcnRlZCBmaWxlIGRvZXMgbm90IGluY2x1ZGUgbmV3IGNvbnRyaWJ1dGlvbnNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8b2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFjb250cmlidXRpb25Jc0VxdWFsKG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLCBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXSkpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihgUHJldmlvdXMgY29udHJpYnV0aW9uICR7aX0gZG9lcyBub3QgbWF0Y2hgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gU2V0IHRoZSBzYW1lIG5hbWUgdG8gYWxsIG5ldyBjb250cmlidXRpb25zXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgaT1vbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGk8bmV3TVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLm5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmRaS2V5TmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUoemtleU5hbWVOZXcsIFwiemtleVwiLCAxLCAxMCk7XG4gICAgZmRNUENQYXJhbXMucG9zID0gMDtcblxuICAgIC8vIEhlYWRlclxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzE7ICAvLyBpZ25vcmUgYWxwaGExIChrZWVwIG9yaWdpbmFsKVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzE7ICAvLyBpZ25vcmUgYmV0YTFcbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cyOyAgLy8gaWdub3JlIGJldGEyXG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMjsgIC8vIGlnbm9yZSBnYW1tYTJcbiAgICB6a2V5SGVhZGVyLnZrX2RlbHRhXzEgPSBhd2FpdCByZWFkRzEoZmRNUENQYXJhbXMpO1xuICAgIHprZXlIZWFkZXIudmtfZGVsdGFfMiA9IGF3YWl0IHJlYWRHMihmZE1QQ1BhcmFtcyk7XG4gICAgYXdhaXQgemtleVV0aWxzLndyaXRlSGVhZGVyKGZkWktleU5ldywgemtleUhlYWRlcik7XG5cbiAgICAvLyBJQyAoS2VlcCBvcmlnaW5hbClcbiAgICBjb25zdCBuSUMgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkVUJFMzIoKTtcbiAgICBpZiAobklDICE9IHprZXlIZWFkZXIublB1YmxpYyArMSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gSUNcIik7XG4gICAgICAgIGF3YWl0IGZkWktleU5ldy5kaXNjYXJkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMSooemtleUhlYWRlci5uUHVibGljKzEpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmRaS2V5TmV3LCAzKTtcblxuICAgIC8vIENvZWZmcyAoS2VlcCBvcmlnaW5hbClcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgNCk7XG5cbiAgICAvLyBIIFNlY3Rpb25cbiAgICBjb25zdCBuSCA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuSCAhPSB6a2V5SGVhZGVyLmRvbWFpblNpemUtMSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gSFwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYnVmZkg7XG4gICAgY29uc3QgYnVmZlRhdVUgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkKHNHMSooemtleUhlYWRlci5kb21haW5TaXplLTEpKTtcbiAgICBjb25zdCBidWZmVGF1TEVNID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hVdG9MRU0oYnVmZlRhdVUpO1xuICAgIGJ1ZmZIID0gbmV3IFVpbnQ4QXJyYXkoemtleUhlYWRlci5kb21haW5TaXplKnNHMSk7XG4gICAgYnVmZkguc2V0KGJ1ZmZUYXVMRU0pOyAgIC8vIExldCB0aGUgbGFzdCBvbmUgdG8gemVyby5cbiAgICBjdXJ2ZS5HMS50b1JwckxFTShidWZmSCwgc0cxKih6a2V5SGVhZGVyLmRvbWFpblNpemUtMSksIGN1cnZlLkcxLnplcm9BZmZpbmUpO1xuICAgIGNvbnN0IG4ySW52ID0gY3VydmUuRnIubmVnKGN1cnZlLkZyLmludihjdXJ2ZS5Gci5lKDIpKSk7XG4gICAgY29uc3Qgd0ludiA9IGN1cnZlLkZyLmludihjdXJ2ZS5Gci53W3prZXlIZWFkZXIucG93ZXIrMV0pO1xuICAgIGJ1ZmZIID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hBcHBseUtleShidWZmSCwgbjJJbnYsIHdJbnYsIFwiYWZmaW5lXCIsIFwiamFjb2JpYW5cIiwgbG9nZ2VyKTtcbiAgICBidWZmSCA9IGF3YWl0IGN1cnZlLkcxLmlmZnQoYnVmZkgsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5TmV3LCA5KTtcbiAgICBhd2FpdCBmZFpLZXlOZXcud3JpdGUoYnVmZkgpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmRaS2V5TmV3KTtcblxuICAgIC8vIEMgU2VjdGlvbiAoTCBzZWN0aW9uKVxuICAgIGNvbnN0IG5MID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5MICE9ICh6a2V5SGVhZGVyLm5WYXJzLXprZXlIZWFkZXIublB1YmxpYy0xKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTFwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYnVmZkw7XG4gICAgYnVmZkwgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkKHNHMSooemtleUhlYWRlci5uVmFycy16a2V5SGVhZGVyLm5QdWJsaWMtMSkpO1xuICAgIGJ1ZmZMID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hVdG9MRU0oYnVmZkwpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFpLZXlOZXcsIDgpO1xuICAgIGF3YWl0IGZkWktleU5ldy53cml0ZShidWZmTCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXlOZXcpO1xuXG4gICAgLy8gQSBTZWN0aW9uXG4gICAgY29uc3QgbkEgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkVUJFMzIoKTtcbiAgICBpZiAobkEgIT0gemtleUhlYWRlci5uVmFycykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gQVwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cxKih6a2V5SGVhZGVyLm5WYXJzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgNSk7XG5cbiAgICAvLyBCMSBTZWN0aW9uXG4gICAgY29uc3QgbkIxID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5CMSAhPSB6a2V5SGVhZGVyLm5WYXJzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBCMVwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cxKih6a2V5SGVhZGVyLm5WYXJzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgNik7XG5cbiAgICAvLyBCMiBTZWN0aW9uXG4gICAgY29uc3QgbkIyID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5CMiAhPSB6a2V5SGVhZGVyLm5WYXJzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBCMlwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cyKih6a2V5SGVhZGVyLm5WYXJzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgNyk7XG5cbiAgICBhd2FpdCB6a2V5VXRpbHMud3JpdGVNUENQYXJhbXMoZmRaS2V5TmV3LCBjdXJ2ZSwgbmV3TVBDUGFyYW1zKTtcblxuICAgIGF3YWl0IGZkTVBDUGFyYW1zLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRaS2V5TmV3LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRaS2V5T2xkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRHMShmZCkge1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5HMS5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzEuZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCAwKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzIoZmQpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzIuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcyLmZyb21ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb250cmlidXRpb25Jc0VxdWFsKGMxLCBjMikge1xuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGMxLmRlbHRhQWZ0ZXIgICAsIGMyLmRlbHRhQWZ0ZXIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoYzEuZGVsdGEuZzFfcyAgICwgYzIuZGVsdGEuZzFfcykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjMS5kZWx0YS5nMV9zeCAgLCBjMi5kZWx0YS5nMV9zeCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFjdXJ2ZS5HMi5lcShjMS5kZWx0YS5nMl9zcHggLCBjMi5kZWx0YS5nMl9zcHgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghbWlzYy5oYXNoSXNFcXVhbChjMS50cmFuc2NyaXB0LCBjMi50cmFuc2NyaXB0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_import_bellman.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_new.js":
/*!**********************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_new.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ newZKey)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(rsc)/./node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(rsc)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bigarray.js */ \"(rsc)/./node_modules/snarkjs/src/bigarray.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\nasync function newZKey(r1csName, ptauName, zkeyName, logger) {\n\n    const TAU_G1 = 0;\n    const TAU_G2 = 1;\n    const ALPHATAU_G1 = 2;\n    const BETATAU_G1 = 3;\n    const csHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });\n\n    const {fd: fdPTau, sections: sectionsPTau} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csHeader)(fdR1cs, sectionsR1cs, false);\n\n    const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyName, \"zkey\", 1, 10, 1<<22, 1<<24);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    const cirPower = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(r1cs.nConstraints + r1cs.nPubInputs + r1cs.nOutputs +1 -1) +1;\n\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${r1cs.nConstraints}*2 > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n    const domainSize = 2 ** cirPower;\n\n    // Write the header\n    ///////////\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 1);\n    await fdZKey.writeULE32(1); // Groth\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    // Write the Groth header section\n    ///////////\n\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.shl(1, n8r*8), primeR);\n    const R2r = curve.Fr.e(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mul(Rr,Rr), primeR));\n\n    await fdZKey.writeULE32(n8q);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n    await fdZKey.writeULE32(n8r);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n    await fdZKey.writeULE32(r1cs.nVars);                         // Total number of bars\n    await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n    await fdZKey.writeULE32(domainSize);                  // domainSize\n\n    let bAlpha1;\n    bAlpha1 = await fdPTau.read(sG1, sectionsPTau[4][0].p);\n    await fdZKey.write(bAlpha1);\n    bAlpha1 = await curve.G1.batchLEMtoU(bAlpha1);\n    csHasher.update(bAlpha1);\n\n    let bBeta1;\n    bBeta1 = await fdPTau.read(sG1, sectionsPTau[5][0].p);\n    await fdZKey.write(bBeta1);\n    bBeta1 = await curve.G1.batchLEMtoU(bBeta1);\n    csHasher.update(bBeta1);\n\n    let bBeta2;\n    bBeta2 = await fdPTau.read(sG2, sectionsPTau[6][0].p);\n    await fdZKey.write(bBeta2);\n    bBeta2 = await curve.G2.batchLEMtoU(bBeta2);\n    csHasher.update(bBeta2);\n\n    const bg1 = new Uint8Array(sG1);\n    curve.G1.toRprLEM(bg1, 0, curve.G1.g);\n    const bg2 = new Uint8Array(sG2);\n    curve.G2.toRprLEM(bg2, 0, curve.G2.g);\n    const bg1U = new Uint8Array(sG1);\n    curve.G1.toRprUncompressed(bg1U, 0, curve.G1.g);\n    const bg2U = new Uint8Array(sG2);\n    curve.G2.toRprUncompressed(bg2U, 0, curve.G2.g);\n\n    await fdZKey.write(bg2);        // gamma2\n    await fdZKey.write(bg1);        // delta1\n    await fdZKey.write(bg2);        // delta2\n    csHasher.update(bg2U);      // gamma2\n    csHasher.update(bg1U);      // delta1\n    csHasher.update(bg2U);      // delta2\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdR1cs, sectionsR1cs, 2);\n\n    const A = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](r1cs.nVars);\n    const B1 = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](r1cs.nVars);\n    const B2 = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](r1cs.nVars);\n    const C = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](r1cs.nVars- nPublic -1);\n    const IC = new Array(nPublic+1);\n\n    if (logger) logger.info(\"Reading tauG1\");\n    let sTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 12, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading tauG2\");\n    let sTauG2 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 13, (domainSize -1)*sG2, domainSize*sG2);\n    if (logger) logger.info(\"Reading alphatauG1\");\n    let sAlphaTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 14, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading betatauG1\");\n    let sBetaTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 15, (domainSize -1)*sG1, domainSize*sG1);\n\n    await processConstraints();\n\n    await composeAndWritePoints(3, \"G1\", IC, \"IC\");\n\n    await writeHs();\n\n    await hashHPoints();\n\n    await composeAndWritePoints(8, \"G1\", C, \"C\");\n    await composeAndWritePoints(5, \"G1\", A, \"A\");\n    await composeAndWritePoints(6, \"G1\", B1, \"B1\");\n    await composeAndWritePoints(7, \"G2\", B2, \"B2\");\n\n    const csHash = csHasher.digest();\n    // Contributions section\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 10);\n    await fdZKey.write(csHash);\n    await fdZKey.writeULE32(0);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    if (logger) logger.info((0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash)(csHash, \"Circuit hash: \"));\n\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    return csHash;\n\n    async function writeHs() {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 9);\n        const buffOut = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*sG1);\n        if (cirPower < curve.Fr.s) {\n            let sTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 12, (domainSize*2-1)*sG1, domainSize*2*sG1);\n            for (let i=0; i< domainSize; i++) {\n                if ((logger)&&(i%10000 == 0)) logger.debug(`splitting buffer: ${i}/${domainSize}`);\n                const buff = sTauG1.slice( (i*2+1)*sG1, (i*2+1)*sG1 + sG1 );\n                buffOut.set(buff, i*sG1);\n            }\n        } else if (cirPower == curve.Fr.s) {\n            const o = sectionsPTau[12][0].p + ((2 ** (cirPower+1)) -1)*sG1;\n            await fdPTau.readToBuffer(buffOut, 0, domainSize*sG1, o + domainSize*sG1);\n        } else {\n            if (logger) logger.error(\"Circuit too big\");\n            throw new Error(\"Circuit too big for this curve\");\n        }\n        await fdZKey.write(buffOut);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function processConstraints() {\n        const buffCoeff = new Uint8Array(12 + curve.Fr.n8);\n        const buffCoeffV = new DataView(buffCoeff.buffer);\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let r1csPos = 0;\n\n        function r1cs_readULE32() {\n            const buff = sR1cs.slice(r1csPos, r1csPos+4);\n            r1csPos += 4;\n            const buffV = new DataView(buff.buffer);\n            return buffV.getUint32(0, true);\n        }\n\n        const coefs = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n        for (let c=0; c<r1cs.nConstraints; c++) {\n            if ((logger)&&(c%10000 == 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            const nA = r1cs_readULE32();\n            for (let i=0; i<nA; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = BETATAU_G1;\n                const l2 = sG1*c;\n                if (typeof A[s] === \"undefined\") A[s] = [];\n                A[s].push([l1t, l1, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l2t, l2, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s - nPublic -1].push([l2t, l2, coefp]);\n                }\n                coefs.push([0, c, s, coefp]);\n            }\n\n            const nB = r1cs_readULE32();\n            for (let i=0; i<nB; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = TAU_G2;\n                const l2 = sG2*c;\n                const l3t = ALPHATAU_G1;\n                const l3 = sG1*c;\n                if (typeof B1[s] === \"undefined\") B1[s] = [];\n                B1[s].push([l1t, l1, coefp]);\n                if (typeof B2[s] === \"undefined\") B2[s] = [];\n                B2[s].push([l2t, l2, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l3t, l3, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l3t, l3, coefp]);\n                }\n\n                coefs.push([1, c, s, coefp]);\n            }\n\n            const nC = r1cs_readULE32();\n            for (let i=0; i<nC; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l1t, l1, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l1t, l1, coefp]);\n                }\n            }\n        }\n\n        for (let s = 0; s <= nPublic ; s++) {\n            const l1t = TAU_G1;\n            const l1 = sG1*(r1cs.nConstraints + s);\n            const l2t = BETATAU_G1;\n            const l2 = sG1*(r1cs.nConstraints + s);\n            if (typeof A[s] === \"undefined\") A[s] = [];\n            A[s].push([l1t, l1, -1]);\n            if (typeof IC[s] === \"undefined\") IC[s] = [];\n            IC[s].push([l2t, l2, -1]);\n            coefs.push([0, r1cs.nConstraints + s, s, -1]);\n        }\n\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 4);\n\n        const buffSection = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(coefs.length*(12+curve.Fr.n8) + 4);\n\n        const buff4 = new Uint8Array(4);\n        const buff4V = new DataView(buff4.buffer);\n        buff4V.setUint32(0, coefs.length, true);\n        buffSection.set(buff4);\n        let coefsPos = 4;\n        for (let i=0; i<coefs.length; i++) {\n            if ((logger)&&(i%100000 == 0)) logger.debug(`writing coeffs: ${i}/${coefs.length}`);\n            writeCoef(coefs[i]);\n        }\n\n        await fdZKey.write(buffSection);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        function writeCoef(c) {\n            buffCoeffV.setUint32(0, c[0], true);\n            buffCoeffV.setUint32(4, c[1], true);\n            buffCoeffV.setUint32(8, c[2], true);\n            let n;\n            if (c[3]>=0) {\n                n = curve.Fr.fromRprLE(sR1cs.slice(c[3], c[3] + curve.Fr.n8), 0);\n            } else {\n                n = curve.Fr.fromRprLE(bOne, 0);\n            }\n            const nR2 = curve.Fr.mul(n, R2r);\n            curve.Fr.toRprLE(buffCoeff, 12, nR2);\n            buffSection.set(buffCoeff, coefsPos);\n            coefsPos += buffCoeff.length;\n        }\n\n    }\n\n    async function composeAndWritePoints(idSection, groupName, arr, sectionName) {\n        const CHUNK_SIZE= 1<<15;\n        const G = curve[groupName];\n\n        hashU32(arr.length);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, idSection);\n\n        let opPromises = [];\n\n        let i=0;\n        while (i<arr.length) {\n\n            let t=0;\n            while ((i<arr.length)&&(t<curve.tm.concurrency)) {\n                if (logger)  logger.debug(`Writing points start ${sectionName}: ${i}/${arr.length}`);\n                let n = 1;\n                let nP = (arr[i] ? arr[i].length : 0);\n                while ((i + n < arr.length) && (nP + (arr[i+n] ? arr[i+n].length : 0) < CHUNK_SIZE) && (n<CHUNK_SIZE)) {\n                    nP += (arr[i+n] ? arr[i+n].length : 0);\n                    n ++;\n                }\n                const subArr = arr.slice(i, i + n);\n                const _i = i;\n                opPromises.push(composeAndWritePointsThread(groupName, subArr, logger, sectionName).then( (r) => {\n                    if (logger)  logger.debug(`Writing points end ${sectionName}: ${_i}/${arr.length}`);\n                    return r;\n                }));\n                i += n;\n                t++;\n            }\n\n            const result = await Promise.all(opPromises);\n\n            for (let k=0; k<result.length; k++) {\n                await fdZKey.write(result[k][0]);\n                const buff = await G.batchLEMtoU(result[k][0]);\n                csHasher.update(buff);\n            }\n            opPromises = [];\n\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    }\n\n    async function composeAndWritePointsThread(groupName, arr, logger, sectionName) {\n        const G = curve[groupName];\n        const sGin = G.F.n8*2;\n        const sGmid = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnExp, fnMultiExp, fnBatchToAffine, fnZero;\n        if (groupName == \"G1\") {\n            fnExp = \"g1m_timesScalarAffine\";\n            fnMultiExp = \"g1m_multiexpAffine\";\n            fnBatchToAffine = \"g1m_batchToAffine\";\n            fnZero = \"g1m_zero\";\n        } else if (groupName == \"G2\") {\n            fnExp = \"g2m_timesScalarAffine\";\n            fnMultiExp = \"g2m_multiexpAffine\";\n            fnBatchToAffine = \"g2m_batchToAffine\";\n            fnZero = \"g2m_zero\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        let acc =0;\n        for (let i=0; i<arr.length; i++) acc += arr[i] ? arr[i].length : 0;\n        let bBases, bScalars;\n        if (acc> 2<<14) {\n            bBases = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(acc*sGin);\n            bScalars = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(acc*curve.Fr.n8);\n        } else {\n            bBases = new Uint8Array(acc*sGin);\n            bScalars = new Uint8Array(acc*curve.Fr.n8);\n        }\n        let pB =0;\n        let pS =0;\n\n        const sBuffs = [\n            sTauG1,\n            sTauG2,\n            sAlphaTauG1,\n            sBetaTauG1\n        ];\n\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let offset = 0;\n        for (let i=0; i<arr.length; i++) {\n            if (!arr[i]) continue;\n            for (let j=0; j<arr[i].length; j++) {\n                if ((logger)&&(j)&&(j%10000 == 0))  logger.debug(`Configuring big array ${sectionName}: ${j}/${arr[i].length}`);\n                bBases.set(\n                    sBuffs[arr[i][j][0]].slice(\n                        arr[i][j][1],\n                        arr[i][j][1] + sGin\n                    ), offset*sGin\n                );\n                if (arr[i][j][2]>=0) {\n                    bScalars.set(\n                        sR1cs.slice(\n                            arr[i][j][2],\n                            arr[i][j][2] + curve.Fr.n8\n                        ),\n                        offset*curve.Fr.n8\n                    );\n                } else {\n                    bScalars.set(bOne, offset*curve.Fr.n8);\n                }\n                offset ++;\n            }\n        }\n\n        if (arr.length>1) {\n            const task = [];\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: bBases});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: bScalars});\n            task.push({cmd: \"ALLOC\", var: 2, len: arr.length*sGmid});\n            pB = 0;\n            pS = 0;\n            let pD =0;\n            for (let i=0; i<arr.length; i++) {\n                if (!arr[i]) {\n                    task.push({cmd: \"CALL\", fnName: fnZero, params: [\n                        {var: 2, offset: pD}\n                    ]});\n                    pD += sGmid;\n                    continue;\n                }\n                if (arr[i].length == 1) {\n                    task.push({cmd: \"CALL\", fnName: fnExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {var: 2, offset: pD}\n                    ]});\n                } else {\n                    task.push({cmd: \"CALL\", fnName: fnMultiExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {val: arr[i].length},\n                        {var: 2, offset: pD}\n                    ]});\n                }\n                pB += sGin*arr[i].length;\n                pS += curve.Fr.n8*arr[i].length;\n                pD += sGmid;\n            }\n            task.push({cmd: \"CALL\", fnName: fnBatchToAffine, params: [\n                {var: 2},\n                {val: arr.length},\n                {var: 2},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: arr.length*sGout});\n\n            const res = await curve.tm.queueAction(task);\n            return res;\n        } else {\n            let res = await G.multiExpAffine(bBases, bScalars, logger, sectionName);\n            res = [ G.toAffine(res) ];\n            return res;\n        }\n    }\n\n\n    async function hashHPoints() {\n        const CHUNK_SIZE = 1<<14;\n\n        hashU32(domainSize-1);\n\n        for (let i=0; i<domainSize-1; i+= CHUNK_SIZE) {\n            if (logger)  logger.debug(`HashingHPoints: ${i}/${domainSize}`);\n            const n = Math.min(domainSize-1, CHUNK_SIZE);\n            await hashHPointsChunk(i, n);\n        }\n    }\n\n    async function hashHPointsChunk(offset, nPoints) {\n        const buff1 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + (offset + domainSize)*sG1);\n        const buff2 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + offset*sG1);\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(hashHPointsThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        for (let i=0; i<result.length; i++) {\n            csHasher.update(result[i][0]);\n        }\n    }\n\n    async function hashHPointsThread(buff1, buff2) {\n        const nPoints = buff1.byteLength/sG1;\n        const sGmid = curve.G1.F.n8*3;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchLEMtoU\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n    function hashU32(n) {\n        const buff = new Uint8Array(4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        buffV.setUint32(0, n, false);\n        csHasher.update(buff);\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9uZXcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUV3QztBQUNRO0FBUW5CO0FBQ2dCO0FBQ0k7QUFDRDtBQUNYOzs7QUFHdEI7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMERBQU8sVUFBVSxXQUFXOztBQUVqRCxXQUFXLG9DQUFvQyxRQUFRLGdFQUFXO0FBQ2xFLFdBQVcsY0FBYyxRQUFRLGlFQUFvQjtBQUNyRCxXQUFXLG9DQUFvQyxRQUFRLGdFQUFXO0FBQ2xFLHVCQUF1Qix3REFBYzs7QUFFckMseUJBQXlCLGtFQUFhOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiw4Q0FBSTs7QUFFekI7QUFDQSxvRkFBb0Ysa0JBQWtCLFVBQVUsTUFBTTtBQUN0SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsc0VBQWlCO0FBQzNCLGdDQUFnQztBQUNoQyxVQUFVLG9FQUFlOztBQUV6QjtBQUNBOztBQUVBLFVBQVUsc0VBQWlCO0FBQzNCO0FBQ0EsOEJBQThCLGdEQUFNOztBQUVwQztBQUNBLDhCQUE4QixnREFBTTtBQUNwQyxlQUFlLGdEQUFNLEtBQUssZ0RBQU07QUFDaEMsMkJBQTJCLGdEQUFNLEtBQUssZ0RBQU07O0FBRTVDO0FBQ0EsVUFBVSxnRUFBVztBQUNyQjtBQUNBLFVBQVUsZ0VBQVc7QUFDckIsaUVBQWlFO0FBQ2pFLDREQUE0RDtBQUM1RCwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsVUFBVSxvRUFBZTs7QUFFekI7QUFDQSxzQkFBc0IsZ0VBQVc7O0FBRWpDLGtCQUFrQixvREFBUTtBQUMxQixtQkFBbUIsb0RBQVE7QUFDM0IsbUJBQW1CLG9EQUFRO0FBQzNCLGtCQUFrQixvREFBUTtBQUMxQjs7QUFFQTtBQUNBLHVCQUF1QixnRUFBVztBQUNsQztBQUNBLHVCQUF1QixnRUFBVztBQUNsQztBQUNBLDRCQUE0QixnRUFBVztBQUN2QztBQUNBLDJCQUEyQixnRUFBVzs7QUFFdEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsc0VBQWlCO0FBQzNCO0FBQ0E7QUFDQSxVQUFVLG9FQUFlOztBQUV6Qiw0QkFBNEIsb0RBQVU7OztBQUd0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQiw0QkFBNEIsbURBQVM7QUFDckM7QUFDQSwrQkFBK0IsZ0VBQVc7QUFDMUMsMEJBQTBCLGVBQWU7QUFDekMsZ0ZBQWdGLEVBQUUsR0FBRyxXQUFXO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsb0RBQVE7QUFDbEMsc0JBQXNCLHFCQUFxQjtBQUMzQyxrRkFBa0YsRUFBRSxHQUFHLGtCQUFrQjtBQUN6RztBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsY0FBYyxzRUFBaUI7O0FBRS9CLGdDQUFnQyxtREFBUzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEMsMkVBQTJFLEVBQUUsR0FBRyxhQUFhO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG9FQUFlOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQjs7QUFFL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVksSUFBSSxFQUFFLEdBQUcsV0FBVztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsWUFBWSxJQUFJLEdBQUcsR0FBRyxXQUFXO0FBQ3JHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG9FQUFlOztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQSx5QkFBeUIsbURBQVM7QUFDbEMsMkJBQTJCLG1EQUFTO0FBQ3BDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDLDBGQUEwRixZQUFZLElBQUksRUFBRSxHQUFHLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdELHVCQUF1Qix3Q0FBd0M7QUFDL0QsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHlCQUF5QixtQkFBbUI7QUFDNUMseUJBQXlCLG1CQUFtQjtBQUM1Qyx5QkFBeUIsaUJBQWlCO0FBQzFDLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLCtCQUErQjtBQUMvQix5QkFBeUIsbUJBQW1CO0FBQzVDLHlCQUF5QixtQkFBbUI7QUFDNUMseUJBQXlCLGlCQUFpQjtBQUMxQyx5QkFBeUIsbUJBQW1CO0FBQzVDLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsZ0JBQWdCO0FBQ2pDLGlCQUFpQixPQUFPO0FBQ3hCLGNBQWM7QUFDZCx1QkFBdUIsa0RBQWtEOztBQUV6RTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0Qyx5REFBeUQsRUFBRSxHQUFHLFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQixxQ0FBcUM7QUFDeEQsbUJBQW1CLHlDQUF5QztBQUM1RCxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0MscUJBQXFCLHNCQUFzQjtBQUMzQyxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCLFVBQVU7QUFDVixtQkFBbUI7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsYUFBYTtBQUMxQixhQUFhLE9BQU87QUFDcEIsVUFBVTtBQUNWLG1CQUFtQiw2Q0FBNkM7O0FBRWhFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfbmV3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7cmVhZFIxY3NIZWFkZXJ9IGZyb20gXCJyMWNzZmlsZVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCB7XG4gICAgcmVhZEJpbkZpbGUsXG4gICAgY3JlYXRlQmluRmlsZSxcbiAgICByZWFkU2VjdGlvbixcbiAgICB3cml0ZUJpZ0ludCxcbiAgICBzdGFydFdyaXRlU2VjdGlvbixcbiAgICBlbmRXcml0ZVNlY3Rpb24sXG59IGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgeyBsb2cyLCBmb3JtYXRIYXNoIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgU2NhbGFyLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgeyBibGFrZTJiIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvYmxha2UyYlwiO1xuaW1wb3J0IEJpZ0FycmF5IGZyb20gXCIuL2JpZ2FycmF5LmpzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gbmV3WktleShyMWNzTmFtZSwgcHRhdU5hbWUsIHprZXlOYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IFRBVV9HMSA9IDA7XG4gICAgY29uc3QgVEFVX0cyID0gMTtcbiAgICBjb25zdCBBTFBIQVRBVV9HMSA9IDI7XG4gICAgY29uc3QgQkVUQVRBVV9HMSA9IDM7XG4gICAgY29uc3QgY3NIYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTtcblxuICAgIGNvbnN0IHtmZDogZmRQVGF1LCBzZWN0aW9uczogc2VjdGlvbnNQVGF1fSA9IGF3YWl0IHJlYWRCaW5GaWxlKHB0YXVOYW1lLCBcInB0YXVcIiwgMSwgMTw8MjIsIDE8PDI0KTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkUFRhdSwgc2VjdGlvbnNQVGF1KTtcbiAgICBjb25zdCB7ZmQ6IGZkUjFjcywgc2VjdGlvbnM6IHNlY3Rpb25zUjFjc30gPSBhd2FpdCByZWFkQmluRmlsZShyMWNzTmFtZSwgXCJyMWNzXCIsIDEsIDE8PDIyLCAxPDwyNCk7XG4gICAgY29uc3QgcjFjcyA9IGF3YWl0IHJlYWRSMWNzSGVhZGVyKGZkUjFjcywgc2VjdGlvbnNSMWNzLCBmYWxzZSk7XG5cbiAgICBjb25zdCBmZFpLZXkgPSBhd2FpdCBjcmVhdGVCaW5GaWxlKHprZXlOYW1lLCBcInprZXlcIiwgMSwgMTAsIDE8PDIyLCAxPDwyNCk7XG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuXG4gICAgaWYgKHIxY3MucHJpbWUgIT0gY3VydmUucikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJyMWNzIGN1cnZlIGRvZXMgbm90IG1hdGNoIHBvd2VycyBvZiB0YXUgY2VyZW1vbnkgY3VydmVcIik7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBjb25zdCBjaXJQb3dlciA9IGxvZzIocjFjcy5uQ29uc3RyYWludHMgKyByMWNzLm5QdWJJbnB1dHMgKyByMWNzLm5PdXRwdXRzICsxIC0xKSArMTtcblxuICAgIGlmIChjaXJQb3dlciA+IHBvd2VyKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihgY2lyY3VpdCB0b28gYmlnIGZvciB0aGlzIHBvd2VyIG9mIHRhdSBjZXJlbW9ueS4gJHtyMWNzLm5Db25zdHJhaW50c30qMiA+IDIqKiR7cG93ZXJ9YCk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoIXNlY3Rpb25zUFRhdVsxMl0pIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUG93ZXJzIG9mIHRhdSBpcyBub3QgcHJlcGFyZWQuXCIpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgY29uc3QgblB1YmxpYyA9IHIxY3Mubk91dHB1dHMgKyByMWNzLm5QdWJJbnB1dHM7XG4gICAgY29uc3QgZG9tYWluU2l6ZSA9IDIgKiogY2lyUG93ZXI7XG5cbiAgICAvLyBXcml0ZSB0aGUgaGVhZGVyXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDEpO1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKDEpOyAvLyBHcm90aFxuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuXG4gICAgLy8gV3JpdGUgdGhlIEdyb3RoIGhlYWRlciBzZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cblxuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMik7XG4gICAgY29uc3QgcHJpbWVRID0gY3VydmUucTtcbiAgICBjb25zdCBuOHEgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVSKSAtIDEpIC8gNjQpICsxKSo4O1xuICAgIGNvbnN0IFJyID0gU2NhbGFyLm1vZChTY2FsYXIuc2hsKDEsIG44cio4KSwgcHJpbWVSKTtcbiAgICBjb25zdCBSMnIgPSBjdXJ2ZS5Gci5lKFNjYWxhci5tb2QoU2NhbGFyLm11bChScixSciksIHByaW1lUikpO1xuXG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhxKTtcbiAgICBhd2FpdCB3cml0ZUJpZ0ludChmZFpLZXksIHByaW1lUSwgbjhxKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHIpO1xuICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkWktleSwgcHJpbWVSLCBuOHIpO1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHIxY3MublZhcnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgYmFyc1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG5QdWJsaWMpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIHB1YmxpYyB2YXJzIChub3QgaW5jbHVkaW5nIE9ORSlcbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihkb21haW5TaXplKTsgICAgICAgICAgICAgICAgICAvLyBkb21haW5TaXplXG5cbiAgICBsZXQgYkFscGhhMTtcbiAgICBiQWxwaGExID0gYXdhaXQgZmRQVGF1LnJlYWQoc0cxLCBzZWN0aW9uc1BUYXVbNF1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJBbHBoYTEpO1xuICAgIGJBbHBoYTEgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShiQWxwaGExKTtcbiAgICBjc0hhc2hlci51cGRhdGUoYkFscGhhMSk7XG5cbiAgICBsZXQgYkJldGExO1xuICAgIGJCZXRhMSA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMSwgc2VjdGlvbnNQVGF1WzVdWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShiQmV0YTEpO1xuICAgIGJCZXRhMSA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJCZXRhMSk7XG4gICAgY3NIYXNoZXIudXBkYXRlKGJCZXRhMSk7XG5cbiAgICBsZXQgYkJldGEyO1xuICAgIGJCZXRhMiA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMiwgc2VjdGlvbnNQVGF1WzZdWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShiQmV0YTIpO1xuICAgIGJCZXRhMiA9IGF3YWl0IGN1cnZlLkcyLmJhdGNoTEVNdG9VKGJCZXRhMik7XG4gICAgY3NIYXNoZXIudXBkYXRlKGJCZXRhMik7XG5cbiAgICBjb25zdCBiZzEgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgIGN1cnZlLkcxLnRvUnByTEVNKGJnMSwgMCwgY3VydmUuRzEuZyk7XG4gICAgY29uc3QgYmcyID0gbmV3IFVpbnQ4QXJyYXkoc0cyKTtcbiAgICBjdXJ2ZS5HMi50b1JwckxFTShiZzIsIDAsIGN1cnZlLkcyLmcpO1xuICAgIGNvbnN0IGJnMVUgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKGJnMVUsIDAsIGN1cnZlLkcxLmcpO1xuICAgIGNvbnN0IGJnMlUgPSBuZXcgVWludDhBcnJheShzRzIpO1xuICAgIGN1cnZlLkcyLnRvUnByVW5jb21wcmVzc2VkKGJnMlUsIDAsIGN1cnZlLkcyLmcpO1xuXG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJnMik7ICAgICAgICAvLyBnYW1tYTJcbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoYmcxKTsgICAgICAgIC8vIGRlbHRhMVxuICAgIGF3YWl0IGZkWktleS53cml0ZShiZzIpOyAgICAgICAgLy8gZGVsdGEyXG4gICAgY3NIYXNoZXIudXBkYXRlKGJnMlUpOyAgICAgIC8vIGdhbW1hMlxuICAgIGNzSGFzaGVyLnVwZGF0ZShiZzFVKTsgICAgICAvLyBkZWx0YTFcbiAgICBjc0hhc2hlci51cGRhdGUoYmcyVSk7ICAgICAgLy8gZGVsdGEyXG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgcjFjc1wiKTtcbiAgICBsZXQgc1IxY3MgPSBhd2FpdCByZWFkU2VjdGlvbihmZFIxY3MsIHNlY3Rpb25zUjFjcywgMik7XG5cbiAgICBjb25zdCBBID0gbmV3IEJpZ0FycmF5KHIxY3MublZhcnMpO1xuICAgIGNvbnN0IEIxID0gbmV3IEJpZ0FycmF5KHIxY3MublZhcnMpO1xuICAgIGNvbnN0IEIyID0gbmV3IEJpZ0FycmF5KHIxY3MublZhcnMpO1xuICAgIGNvbnN0IEMgPSBuZXcgQmlnQXJyYXkocjFjcy5uVmFycy0gblB1YmxpYyAtMSk7XG4gICAgY29uc3QgSUMgPSBuZXcgQXJyYXkoblB1YmxpYysxKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUmVhZGluZyB0YXVHMVwiKTtcbiAgICBsZXQgc1RhdUcxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDEyLCAoZG9tYWluU2l6ZSAtMSkqc0cxLCBkb21haW5TaXplKnNHMSk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIHRhdUcyXCIpO1xuICAgIGxldCBzVGF1RzIgPSBhd2FpdCByZWFkU2VjdGlvbihmZFBUYXUsIHNlY3Rpb25zUFRhdSwgMTMsIChkb21haW5TaXplIC0xKSpzRzIsIGRvbWFpblNpemUqc0cyKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgYWxwaGF0YXVHMVwiKTtcbiAgICBsZXQgc0FscGhhVGF1RzEgPSBhd2FpdCByZWFkU2VjdGlvbihmZFBUYXUsIHNlY3Rpb25zUFRhdSwgMTQsIChkb21haW5TaXplIC0xKSpzRzEsIGRvbWFpblNpemUqc0cxKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgYmV0YXRhdUcxXCIpO1xuICAgIGxldCBzQmV0YVRhdUcxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDE1LCAoZG9tYWluU2l6ZSAtMSkqc0cxLCBkb21haW5TaXplKnNHMSk7XG5cbiAgICBhd2FpdCBwcm9jZXNzQ29uc3RyYWludHMoKTtcblxuICAgIGF3YWl0IGNvbXBvc2VBbmRXcml0ZVBvaW50cygzLCBcIkcxXCIsIElDLCBcIklDXCIpO1xuXG4gICAgYXdhaXQgd3JpdGVIcygpO1xuXG4gICAgYXdhaXQgaGFzaEhQb2ludHMoKTtcblxuICAgIGF3YWl0IGNvbXBvc2VBbmRXcml0ZVBvaW50cyg4LCBcIkcxXCIsIEMsIFwiQ1wiKTtcbiAgICBhd2FpdCBjb21wb3NlQW5kV3JpdGVQb2ludHMoNSwgXCJHMVwiLCBBLCBcIkFcIik7XG4gICAgYXdhaXQgY29tcG9zZUFuZFdyaXRlUG9pbnRzKDYsIFwiRzFcIiwgQjEsIFwiQjFcIik7XG4gICAgYXdhaXQgY29tcG9zZUFuZFdyaXRlUG9pbnRzKDcsIFwiRzJcIiwgQjIsIFwiQjJcIik7XG5cbiAgICBjb25zdCBjc0hhc2ggPSBjc0hhc2hlci5kaWdlc3QoKTtcbiAgICAvLyBDb250cmlidXRpb25zIHNlY3Rpb25cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDEwKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoY3NIYXNoKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMigwKTtcbiAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goY3NIYXNoLCBcIkNpcmN1aXQgaGFzaDogXCIpKTtcblxuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRSMWNzLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRQVGF1LmNsb3NlKCk7XG5cbiAgICByZXR1cm4gY3NIYXNoO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVIcygpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCA5KTtcbiAgICAgICAgY29uc3QgYnVmZk91dCA9IG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSpzRzEpO1xuICAgICAgICBpZiAoY2lyUG93ZXIgPCBjdXJ2ZS5Gci5zKSB7XG4gICAgICAgICAgICBsZXQgc1RhdUcxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDEyLCAoZG9tYWluU2l6ZSoyLTEpKnNHMSwgZG9tYWluU2l6ZSoyKnNHMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8IGRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgc3BsaXR0aW5nIGJ1ZmZlcjogJHtpfS8ke2RvbWFpblNpemV9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IHNUYXVHMS5zbGljZSggKGkqMisxKSpzRzEsIChpKjIrMSkqc0cxICsgc0cxICk7XG4gICAgICAgICAgICAgICAgYnVmZk91dC5zZXQoYnVmZiwgaSpzRzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNpclBvd2VyID09IGN1cnZlLkZyLnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBzZWN0aW9uc1BUYXVbMTJdWzBdLnAgKyAoKDIgKiogKGNpclBvd2VyKzEpKSAtMSkqc0cxO1xuICAgICAgICAgICAgYXdhaXQgZmRQVGF1LnJlYWRUb0J1ZmZlcihidWZmT3V0LCAwLCBkb21haW5TaXplKnNHMSwgbyArIGRvbWFpblNpemUqc0cxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkNpcmN1aXQgdG9vIGJpZ1wiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNpcmN1aXQgdG9vIGJpZyBmb3IgdGhpcyBjdXJ2ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYnVmZk91dCk7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDb25zdHJhaW50cygpIHtcbiAgICAgICAgY29uc3QgYnVmZkNvZWZmID0gbmV3IFVpbnQ4QXJyYXkoMTIgKyBjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZDb2VmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZkNvZWZmLmJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGJPbmUgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGN1cnZlLkZyLnRvUnByTEUoYk9uZSwgMCwgY3VydmUuRnIuZSgxKSk7XG5cbiAgICAgICAgbGV0IHIxY3NQb3MgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHIxY3NfcmVhZFVMRTMyKCkge1xuICAgICAgICAgICAgY29uc3QgYnVmZiA9IHNSMWNzLnNsaWNlKHIxY3NQb3MsIHIxY3NQb3MrNCk7XG4gICAgICAgICAgICByMWNzUG9zICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gYnVmZlYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29lZnMgPSBuZXcgQmlnQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgYz0wOyBjPHIxY3MubkNvbnN0cmFpbnRzOyBjKyspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGMlMTAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1ZyhgcHJvY2Vzc2luZyBjb25zdHJhaW50czogJHtjfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbkEgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5BOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2VmcCA9IHIxY3NQb3M7XG4gICAgICAgICAgICAgICAgcjFjc1BvcyArPSBjdXJ2ZS5Gci5uODtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGwxdCA9IFRBVV9HMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsMSA9IHNHMSpjO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwydCA9IEJFVEFUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEFbc10gPT09IFwidW5kZWZpbmVkXCIpIEFbc10gPSBbXTtcbiAgICAgICAgICAgICAgICBBW3NdLnB1c2goW2wxdCwgbDEsIGNvZWZwXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocyA8PSBuUHVibGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICAgICAgICAgIElDW3NdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBDW3MtIG5QdWJsaWMgLTFdID09PSBcInVuZGVmaW5lZFwiKSBDW3MtIG5QdWJsaWMgLTFdID0gW107XG4gICAgICAgICAgICAgICAgICAgIENbcyAtIG5QdWJsaWMgLTFdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZWZzLnB1c2goWzAsIGMsIHMsIGNvZWZwXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5CID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuQjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29lZnAgPSByMWNzUG9zO1xuICAgICAgICAgICAgICAgIHIxY3NQb3MgKz0gY3VydmUuRnIubjg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsMXQgPSBUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDEgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBjb25zdCBsMnQgPSBUQVVfRzI7XG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBzRzIqYztcbiAgICAgICAgICAgICAgICBjb25zdCBsM3QgPSBBTFBIQVRBVV9HMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsMyA9IHNHMSpjO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQjFbc10gPT09IFwidW5kZWZpbmVkXCIpIEIxW3NdID0gW107XG4gICAgICAgICAgICAgICAgQjFbc10ucHVzaChbbDF0LCBsMSwgY29lZnBdKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEIyW3NdID09PSBcInVuZGVmaW5lZFwiKSBCMltzXSA9IFtdO1xuICAgICAgICAgICAgICAgIEIyW3NdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocyA8PSBuUHVibGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICAgICAgICAgIElDW3NdLnB1c2goW2wzdCwgbDMsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBDW3MtIG5QdWJsaWMgLTFdID09PSBcInVuZGVmaW5lZFwiKSBDW3MtIG5QdWJsaWMgLTFdID0gW107XG4gICAgICAgICAgICAgICAgICAgIENbcy0gblB1YmxpYyAtMV0ucHVzaChbbDN0LCBsMywgY29lZnBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2Vmcy5wdXNoKFsxLCBjLCBzLCBjb2VmcF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuQyA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZWZwID0gcjFjc1BvcztcbiAgICAgICAgICAgICAgICByMWNzUG9zICs9IGN1cnZlLkZyLm44O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbDF0ID0gVEFVX0cxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwxID0gc0cxKmM7XG4gICAgICAgICAgICAgICAgaWYgKHMgPD0gblB1YmxpYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIElDW3NdID09PSBcInVuZGVmaW5lZFwiKSBJQ1tzXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBJQ1tzXS5wdXNoKFtsMXQsIGwxLCBjb2VmcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQ1tzLSBuUHVibGljIC0xXSA9PT0gXCJ1bmRlZmluZWRcIikgQ1tzLSBuUHVibGljIC0xXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBDW3MtIG5QdWJsaWMgLTFdLnB1c2goW2wxdCwgbDEsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPD0gblB1YmxpYyA7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgbDF0ID0gVEFVX0cxO1xuICAgICAgICAgICAgY29uc3QgbDEgPSBzRzEqKHIxY3MubkNvbnN0cmFpbnRzICsgcyk7XG4gICAgICAgICAgICBjb25zdCBsMnQgPSBCRVRBVEFVX0cxO1xuICAgICAgICAgICAgY29uc3QgbDIgPSBzRzEqKHIxY3MubkNvbnN0cmFpbnRzICsgcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEFbc10gPT09IFwidW5kZWZpbmVkXCIpIEFbc10gPSBbXTtcbiAgICAgICAgICAgIEFbc10ucHVzaChbbDF0LCBsMSwgLTFdKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICBJQ1tzXS5wdXNoKFtsMnQsIGwyLCAtMV0pO1xuICAgICAgICAgICAgY29lZnMucHVzaChbMCwgcjFjcy5uQ29uc3RyYWludHMgKyBzLCBzLCAtMV0pO1xuICAgICAgICB9XG5cblxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDQpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmZTZWN0aW9uID0gbmV3IEJpZ0J1ZmZlcihjb2Vmcy5sZW5ndGgqKDEyK2N1cnZlLkZyLm44KSArIDQpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmY0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IGJ1ZmY0ViA9IG5ldyBEYXRhVmlldyhidWZmNC5idWZmZXIpO1xuICAgICAgICBidWZmNFYuc2V0VWludDMyKDAsIGNvZWZzLmxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgIGJ1ZmZTZWN0aW9uLnNldChidWZmNCk7XG4gICAgICAgIGxldCBjb2Vmc1BvcyA9IDQ7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb2Vmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyBjb2VmZnM6ICR7aX0vJHtjb2Vmcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB3cml0ZUNvZWYoY29lZnNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJ1ZmZTZWN0aW9uKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDb2VmKGMpIHtcbiAgICAgICAgICAgIGJ1ZmZDb2VmZlYuc2V0VWludDMyKDAsIGNbMF0sIHRydWUpO1xuICAgICAgICAgICAgYnVmZkNvZWZmVi5zZXRVaW50MzIoNCwgY1sxXSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmQ29lZmZWLnNldFVpbnQzMig4LCBjWzJdLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGNbM10+PTApIHtcbiAgICAgICAgICAgICAgICBuID0gY3VydmUuRnIuZnJvbVJwckxFKHNSMWNzLnNsaWNlKGNbM10sIGNbM10gKyBjdXJ2ZS5Gci5uOCksIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gY3VydmUuRnIuZnJvbVJwckxFKGJPbmUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgblIyID0gY3VydmUuRnIubXVsKG4sIFIycik7XG4gICAgICAgICAgICBjdXJ2ZS5Gci50b1JwckxFKGJ1ZmZDb2VmZiwgMTIsIG5SMik7XG4gICAgICAgICAgICBidWZmU2VjdGlvbi5zZXQoYnVmZkNvZWZmLCBjb2Vmc1Bvcyk7XG4gICAgICAgICAgICBjb2Vmc1BvcyArPSBidWZmQ29lZmYubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wb3NlQW5kV3JpdGVQb2ludHMoaWRTZWN0aW9uLCBncm91cE5hbWUsIGFyciwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgQ0hVTktfU0laRT0gMTw8MTU7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuXG4gICAgICAgIGhhc2hVMzIoYXJyLmxlbmd0aCk7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgaWRTZWN0aW9uKTtcblxuICAgICAgICBsZXQgb3BQcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGxldCBpPTA7XG4gICAgICAgIHdoaWxlIChpPGFyci5sZW5ndGgpIHtcblxuICAgICAgICAgICAgbGV0IHQ9MDtcbiAgICAgICAgICAgIHdoaWxlICgoaTxhcnIubGVuZ3RoKSYmKHQ8Y3VydmUudG0uY29uY3VycmVuY3kpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgIGxvZ2dlci5kZWJ1ZyhgV3JpdGluZyBwb2ludHMgc3RhcnQgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHthcnIubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIGxldCBuID0gMTtcbiAgICAgICAgICAgICAgICBsZXQgblAgPSAoYXJyW2ldID8gYXJyW2ldLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoaSArIG4gPCBhcnIubGVuZ3RoKSAmJiAoblAgKyAoYXJyW2krbl0gPyBhcnJbaStuXS5sZW5ndGggOiAwKSA8IENIVU5LX1NJWkUpICYmIChuPENIVU5LX1NJWkUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5QICs9IChhcnJbaStuXSA/IGFycltpK25dLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgICAgICAgICBuICsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdWJBcnIgPSBhcnIuc2xpY2UoaSwgaSArIG4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9pID0gaTtcbiAgICAgICAgICAgICAgICBvcFByb21pc2VzLnB1c2goY29tcG9zZUFuZFdyaXRlUG9pbnRzVGhyZWFkKGdyb3VwTmFtZSwgc3ViQXJyLCBsb2dnZXIsIHNlY3Rpb25OYW1lKS50aGVuKCAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSAgbG9nZ2VyLmRlYnVnKGBXcml0aW5nIHBvaW50cyBlbmQgJHtzZWN0aW9uTmFtZX06ICR7X2l9LyR7YXJyLmxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGkgKz0gbjtcbiAgICAgICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBrPTA7IGs8cmVzdWx0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHJlc3VsdFtrXVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IEcuYmF0Y2hMRU10b1UocmVzdWx0W2tdWzBdKTtcbiAgICAgICAgICAgICAgICBjc0hhc2hlci51cGRhdGUoYnVmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcFByb21pc2VzID0gW107XG5cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXBvc2VBbmRXcml0ZVBvaW50c1RocmVhZChncm91cE5hbWUsIGFyciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0dpbiA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBzR21pZCA9IEcuRi5uOCozO1xuICAgICAgICBjb25zdCBzR291dCA9IEcuRi5uOCoyO1xuICAgICAgICBsZXQgZm5FeHAsIGZuTXVsdGlFeHAsIGZuQmF0Y2hUb0FmZmluZSwgZm5aZXJvO1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgZm5FeHAgPSBcImcxbV90aW1lc1NjYWxhckFmZmluZVwiO1xuICAgICAgICAgICAgZm5NdWx0aUV4cCA9IFwiZzFtX211bHRpZXhwQWZmaW5lXCI7XG4gICAgICAgICAgICBmbkJhdGNoVG9BZmZpbmUgPSBcImcxbV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICBmblplcm8gPSBcImcxbV96ZXJvXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgZm5FeHAgPSBcImcybV90aW1lc1NjYWxhckFmZmluZVwiO1xuICAgICAgICAgICAgZm5NdWx0aUV4cCA9IFwiZzJtX211bHRpZXhwQWZmaW5lXCI7XG4gICAgICAgICAgICBmbkJhdGNoVG9BZmZpbmUgPSBcImcybV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICBmblplcm8gPSBcImcybV96ZXJvXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY2MgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIGFjYyArPSBhcnJbaV0gPyBhcnJbaV0ubGVuZ3RoIDogMDtcbiAgICAgICAgbGV0IGJCYXNlcywgYlNjYWxhcnM7XG4gICAgICAgIGlmIChhY2M+IDI8PDE0KSB7XG4gICAgICAgICAgICBiQmFzZXMgPSBuZXcgQmlnQnVmZmVyKGFjYypzR2luKTtcbiAgICAgICAgICAgIGJTY2FsYXJzID0gbmV3IEJpZ0J1ZmZlcihhY2MqY3VydmUuRnIubjgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYkJhc2VzID0gbmV3IFVpbnQ4QXJyYXkoYWNjKnNHaW4pO1xuICAgICAgICAgICAgYlNjYWxhcnMgPSBuZXcgVWludDhBcnJheShhY2MqY3VydmUuRnIubjgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwQiA9MDtcbiAgICAgICAgbGV0IHBTID0wO1xuXG4gICAgICAgIGNvbnN0IHNCdWZmcyA9IFtcbiAgICAgICAgICAgIHNUYXVHMSxcbiAgICAgICAgICAgIHNUYXVHMixcbiAgICAgICAgICAgIHNBbHBoYVRhdUcxLFxuICAgICAgICAgICAgc0JldGFUYXVHMVxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGJPbmUgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGN1cnZlLkZyLnRvUnByTEUoYk9uZSwgMCwgY3VydmUuRnIuZSgxKSk7XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghYXJyW2ldKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxhcnJbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihqKSYmKGolMTAwMDAgPT0gMCkpICBsb2dnZXIuZGVidWcoYENvbmZpZ3VyaW5nIGJpZyBhcnJheSAke3NlY3Rpb25OYW1lfTogJHtqfS8ke2FycltpXS5sZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgYkJhc2VzLnNldChcbiAgICAgICAgICAgICAgICAgICAgc0J1ZmZzW2FycltpXVtqXVswXV0uc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMV0gKyBzR2luXG4gICAgICAgICAgICAgICAgICAgICksIG9mZnNldCpzR2luXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldW2pdWzJdPj0wKSB7XG4gICAgICAgICAgICAgICAgICAgIGJTY2FsYXJzLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIHNSMWNzLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXVtqXVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMl0gKyBjdXJ2ZS5Gci5uOFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCpjdXJ2ZS5Gci5uOFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJTY2FsYXJzLnNldChiT25lLCBvZmZzZXQqY3VydmUuRnIubjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJCYXNlc30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBiU2NhbGFyc30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IGFyci5sZW5ndGgqc0dtaWR9KTtcbiAgICAgICAgICAgIHBCID0gMDtcbiAgICAgICAgICAgIHBTID0gMDtcbiAgICAgICAgICAgIGxldCBwRCA9MDtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycltpXSkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5aZXJvLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogcER9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICAgICAgcEQgKz0gc0dtaWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkV4cCwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwLCBvZmZzZXQ6IHBCfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogcFN9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogY3VydmUuRnIubjh9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMiwgb2Zmc2V0OiBwRH1cbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk11bHRpRXhwLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDAsIG9mZnNldDogcEJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMSwgb2Zmc2V0OiBwU30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBjdXJ2ZS5Gci5uOH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBhcnJbaV0ubGVuZ3RofSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogcER9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcEIgKz0gc0dpbiphcnJbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBTICs9IGN1cnZlLkZyLm44KmFycltpXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcEQgKz0gc0dtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5CYXRjaFRvQWZmaW5lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBhcnIubGVuZ3RofSxcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBhcnIubGVuZ3RoKnNHb3V0fSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJCYXNlcywgYlNjYWxhcnMsIGxvZ2dlciwgc2VjdGlvbk5hbWUpO1xuICAgICAgICAgICAgcmVzID0gWyBHLnRvQWZmaW5lKHJlcykgXTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhc2hIUG9pbnRzKCkge1xuICAgICAgICBjb25zdCBDSFVOS19TSVpFID0gMTw8MTQ7XG5cbiAgICAgICAgaGFzaFUzMihkb21haW5TaXplLTEpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxkb21haW5TaXplLTE7IGkrPSBDSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSAgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nSFBvaW50czogJHtpfS8ke2RvbWFpblNpemV9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oZG9tYWluU2l6ZS0xLCBDSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGF3YWl0IGhhc2hIUG9pbnRzQ2h1bmsoaSwgbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoSFBvaW50c0NodW5rKG9mZnNldCwgblBvaW50cykge1xuICAgICAgICBjb25zdCBidWZmMSA9IGF3YWl0IGZkUFRhdS5yZWFkKG5Qb2ludHMgKnNHMSwgc2VjdGlvbnNQVGF1WzJdWzBdLnAgKyAob2Zmc2V0ICsgZG9tYWluU2l6ZSkqc0cxKTtcbiAgICAgICAgY29uc3QgYnVmZjIgPSBhd2FpdCBmZFBUYXUucmVhZChuUG9pbnRzICpzRzEsIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgb2Zmc2V0KnNHMSk7XG4gICAgICAgIGNvbnN0IGNvbmN1cnJlbmN5PSBjdXJ2ZS50bS5jb25jdXJyZW5jeTtcbiAgICAgICAgY29uc3QgblBvaW50c1BlclRocmVhZCA9IE1hdGguZmxvb3IoblBvaW50cyAvIGNvbmN1cnJlbmN5KTtcbiAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzUGVyVGhyZWFkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqblBvaW50c1BlclRocmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuPT0wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3Qgc3ViQnVmZjEgPSBidWZmMS5zbGljZShpKm5Qb2ludHNQZXJUaHJlYWQqc0cxLCAoaSpuUG9pbnRzUGVyVGhyZWFkK24pKnNHMSk7XG4gICAgICAgICAgICBjb25zdCBzdWJCdWZmMiA9IGJ1ZmYyLnNsaWNlKGkqblBvaW50c1BlclRocmVhZCpzRzEsIChpKm5Qb2ludHNQZXJUaHJlYWQrbikqc0cxKTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChoYXNoSFBvaW50c1RocmVhZChzdWJCdWZmMSwgc3ViQnVmZjIpKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3NIYXNoZXIudXBkYXRlKHJlc3VsdFtpXVswXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoSFBvaW50c1RocmVhZChidWZmMSwgYnVmZjIpIHtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGgvc0cxO1xuICAgICAgICBjb25zdCBzR21pZCA9IGN1cnZlLkcxLkYubjgqMztcbiAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJ1ZmYxfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYnVmZjJ9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IG5Qb2ludHMqc0dtaWR9KTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgdGFzay5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbWQ6IFwiQ0FMTFwiLFxuICAgICAgICAgICAgICAgIGZuTmFtZTogXCJnMW1fc3ViQWZmaW5lXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDAsIG9mZnNldDogaSpzRzF9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAxLCBvZmZzZXQ6IGkqc0cxfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMiwgb2Zmc2V0OiBpKnNHbWlkfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJnMW1fYmF0Y2hUb0FmZmluZVwiLCBwYXJhbXM6IFtcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAge3ZhbDogblBvaW50c30sXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgXX0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJnMW1fYmF0Y2hMRU10b1VcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIHt2YWw6IG5Qb2ludHN9LFxuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgIF19KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAyLCBsZW46IG5Qb2ludHMqc0cxfSk7XG5cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUudG0ucXVldWVBY3Rpb24odGFzayk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNoVTMyKG4pIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0LCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICBidWZmVi5zZXRVaW50MzIoMCwgbiwgZmFsc2UpO1xuICAgICAgICBjc0hhc2hlci51cGRhdGUoYnVmZik7XG4gICAgfVxuXG59XG5cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_new.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_utils.js":
/*!************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_utils.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashG1: () => (/* binding */ hashG1),\n/* harmony export */   hashG2: () => (/* binding */ hashG2),\n/* harmony export */   hashPubKey: () => (/* binding */ hashPubKey),\n/* harmony export */   readHeader: () => (/* binding */ readHeader),\n/* harmony export */   readMPCParams: () => (/* binding */ readMPCParams),\n/* harmony export */   readZKey: () => (/* binding */ readZKey),\n/* harmony export */   writeHeader: () => (/* binding */ writeHeader),\n/* harmony export */   writeMPCParams: () => (/* binding */ writeMPCParams),\n/* harmony export */   writeZKey: () => (/* binding */ writeZKey)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(rsc)/./node_modules/snarkjs/src/fflonk_constants.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format\n// ======\n// Header(1)\n//      Prover Type 1 Groth\n// HeaderGroth(2)\n//      n8q\n//      q\n//      n8r\n//      r\n//      NVars\n//      NPub\n//      DomainSize  (multiple of 2\n//      alpha1\n//      beta1\n//      delta1\n//      beta2\n//      gamma2\n//      delta2\n// IC(3)\n// Coefs(4)\n// PointsA(5)\n// PointsB1(6)\n// PointsB2(7)\n// PointsC(8)\n// PointsH(9)\n// Contributions(10)\n\n\n\n\n\n\n\n\n\nasync function writeHeader(fd, zkey) {\n\n    // Write the header\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    await fd.writeULE32(1); // Groth\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write the Groth header section\n    ///////////\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n    await fd.writeULE32(n8q);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, primeQ, n8q);\n    await fd.writeULE32(n8r);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, primeR, n8r);\n    await fd.writeULE32(zkey.nVars);                         // Total number of bars\n    await fd.writeULE32(zkey.nPublic);                       // Total number of public vars (not including ONE)\n    await fd.writeULE32(zkey.domainSize);                  // domainSize\n    await writeG1(fd, curve, zkey.vk_alpha_1);\n    await writeG1(fd, curve, zkey.vk_beta_1);\n    await writeG2(fd, curve, zkey.vk_beta_2);\n    await writeG2(fd, curve, zkey.vk_gamma_2);\n    await writeG1(fd, curve, zkey.vk_delta_1);\n    await writeG2(fd, curve, zkey.vk_delta_2);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n}\n\nasync function writeZKey(fileName, zkey) {\n\n    let curve = (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const fd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(fileName,\"zkey\", 1, 9);\n\n    await writeHeader(fd, zkey);\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(zkey.r) - 1) / 64) +1)*8;\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.shl(1, n8r*8), zkey.r);\n    const R2r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mul(Rr,Rr), zkey.r);\n\n    // Write Pols (A and B (C can be omitted))\n    ///////////\n\n    zkey.ccoefs = zkey.ccoefs.filter(c => c.matrix<2);\n    zkey.ccoefs.sort( (a,b) => a.constraint - b.constraint );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 4);\n    await fd.writeULE32(zkey.ccoefs.length);\n    for (let i=0; i<zkey.ccoefs.length; i++) {\n        const coef = zkey.ccoefs[i];\n        await fd.writeULE32(coef.matrix);\n        await fd.writeULE32(coef.constraint);\n        await fd.writeULE32(coef.signal);\n        await writeFr2(coef.value);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 3);\n    for (let i=0; i<= zkey.nPublic; i++) {\n        await writeG1(fd, curve, zkey.IC[i] );\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write A\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 5);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.A[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write B1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 6);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.B1[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write B2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 7);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG2(fd, curve, zkey.B2[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write C\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 8);\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.C[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write H points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 9);\n    for (let i=0; i<zkey.domainSize; i++) {\n        await writeG1(fd, curve, zkey.hExps[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await fd.close();\n\n    async function writeFr2(n) {\n        // Convert to montgomery\n        n = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod( ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mul(n, R2r), zkey.r);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, n, n8r);\n    }\n\n}\n\nasync function writeG1(fd, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function writeG2(fd, curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function readG1(fd, curve, toObject) {\n    const buff = await fd.read(curve.G1.F.n8*2);\n    const res = curve.G1.fromRprLEM(buff, 0);\n    return toObject ? curve.G1.toObject(res) : res;\n}\n\nasync function readG2(fd, curve, toObject) {\n    const buff = await fd.read(curve.G2.F.n8*2);\n    const res = curve.G2.fromRprLEM(buff, 0);\n    return toObject ? curve.G2.toObject(res) : res;\n}\n\n\nasync function readHeader(fd, sections, toObject, options) {\n    // Read Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 1);\n    const protocolId = await fd.readULE32();\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.GROTH16_PROTOCOL_ID) {\n        return await readHeaderGroth16(fd, sections, toObject, options);\n    } else if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.PLONK_PROTOCOL_ID) {\n        return await readHeaderPlonk(fd, sections, toObject, options);\n    } else if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        return await readHeaderFFlonk(fd, sections, toObject, options);\n    } else {\n        throw new Error(\"Protocol not supported: \");\n    }\n}\n\n\n\n\nasync function readHeaderGroth16(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"groth16\";\n\n    // Read Groth Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.vk_alpha_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_gamma_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_delta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_delta_2 = await readG2(fd, zkey.curve, toObject);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n\n}\n\nasync function readHeaderPlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"plonk\";\n\n    // Read Plonk Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.Qm = await readG1(fd, zkey.curve, toObject);\n    zkey.Ql = await readG1(fd, zkey.curve, toObject);\n    zkey.Qr = await readG1(fd, zkey.curve, toObject);\n    zkey.Qo = await readG1(fd, zkey.curve, toObject);\n    zkey.Qc = await readG1(fd, zkey.curve, toObject);\n    zkey.S1 = await readG1(fd, zkey.curve, toObject);\n    zkey.S2 = await readG1(fd, zkey.curve, toObject);\n    zkey.S3 = await readG1(fd, zkey.curve, toObject);\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readHeaderFFlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"fflonk\";\n    zkey.protocolId = _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID;\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_HEADER_SECTION);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q, options);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.w3 = await fd.read(n8r);\n    zkey.w4 = await fd.read(n8r);\n    zkey.w8 = await fd.read(n8r);\n    zkey.wr = await fd.read(n8r);\n\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    zkey.C0 = await readG1(fd, zkey.curve, toObject);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readZKey(fileName, toObject) {\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(fileName, \"zkey\", 1);\n\n    const zkey = await readHeader(fd, sections, toObject);\n\n    const Fr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.F1Field(zkey.r);\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.shl(1, zkey.n8r*8), zkey.r);\n    const Rri = Fr.inv(Rr);\n    const Rri2 = Fr.mul(Rri, Rri);\n\n    let curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    // Read IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 3);\n    zkey.IC = [];\n    for (let i=0; i<= zkey.nPublic; i++) {\n        const P = await readG1(fd, curve, toObject);\n        zkey.IC.push(P);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read Coefs\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 4);\n    const nCCoefs = await fd.readULE32();\n    zkey.ccoefs = [];\n    for (let i=0; i<nCCoefs; i++) {\n        const m = await fd.readULE32();\n        const c = await fd.readULE32();\n        const s = await fd.readULE32();\n        const v = await readFr2(toObject);\n        zkey.ccoefs.push({\n            matrix: m,\n            constraint: c,\n            signal: s,\n            value: v\n        });\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    // Read A points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 5);\n    zkey.A = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const A = await readG1(fd, curve, toObject);\n        zkey.A[i] = A;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read B1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 6);\n    zkey.B1 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B1 = await readG1(fd, curve, toObject);\n\n        zkey.B1[i] = B1;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read B2 points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 7);\n    zkey.B2 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B2 = await readG2(fd, curve, toObject);\n        zkey.B2[i] = B2;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read C points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 8);\n    zkey.C = [];\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        const C = await readG1(fd, curve, toObject);\n\n        zkey.C[i] = C;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read H points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 9);\n    zkey.hExps = [];\n    for (let i=0; i<zkey.domainSize; i++) {\n        const H = await readG1(fd, curve, toObject);\n        zkey.hExps.push(H);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    await fd.close();\n\n    return zkey;\n\n    async function readFr2(/* toObject */) {\n        const n = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, zkey.n8r);\n        return Fr.mul(n, Rri2);\n    }\n\n}\n\n\nasync function readContribution(fd, curve, toObject) {\n    const c = {delta:{}};\n    c.deltaAfter = await readG1(fd, curve, toObject);\n    c.delta.g1_s = await readG1(fd, curve, toObject);\n    c.delta.g1_sx = await readG1(fd, curve, toObject);\n    c.delta.g2_spx = await readG2(fd, curve, toObject);\n    c.transcript = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await fd.read(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await fd.read(1);\n            const buffStr = await fd.read(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await fd.read(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await fd.read(1);\n            c.beaconHash = await fd.read(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n}\n\n\nasync function readMPCParams(fd, curve, sections) {\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 10);\n    const res = { contributions: []};\n    res.csHash = await fd.read(64);\n    const n = await fd.readULE32();\n    for (let i=0; i<n; i++) {\n        const c = await readContribution(fd, curve);\n        res.contributions.push(c);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return res;\n}\n\nasync function writeContribution(fd, curve, c) {\n    await writeG1(fd, curve, c.deltaAfter);\n    await writeG1(fd, curve, c.delta.g1_s);\n    await writeG1(fd, curve, c.delta.g1_sx);\n    await writeG2(fd, curve, c.delta.g2_spx);\n    await fd.write(c.transcript);\n    await fd.writeULE32(c.type || 0);\n\n    const params = [];\n    if (c.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(c.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (c.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(c.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(c.beaconHash.byteLength);\n        for (let i=0; i<c.beaconHash.byteLength; i++) params.push(c.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n}\n\nasync function writeMPCParams(fd, curve, mpcParams) {\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 10);\n    await fd.write(mpcParams.csHash);\n    await fd.writeULE32(mpcParams.contributions.length);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        await writeContribution(fd, curve,mpcParams.contributions[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n}\n\nfunction hashG1(hasher, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashG2(hasher,curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashPubKey(hasher, curve, c) {\n    hashG1(hasher, curve, c.deltaAfter);\n    hashG1(hasher, curve, c.delta.g1_s);\n    hashG1(hasher, curve, c.delta.g1_sx);\n    hashG2(hasher, curve, c.delta.g2_spx);\n    hasher.update(c.transcript);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStDO0FBQ0s7O0FBRUk7QUFDdkI7QUFDOEQ7QUFDbEM7O0FBRXREOztBQUVQO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4Qyw0QkFBNEI7QUFDNUIsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7O0FBRUEsd0JBQXdCLHlEQUFROztBQUVoQyxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLDhCQUE4QixnREFBTTs7QUFFcEM7QUFDQSw4QkFBOEIsZ0RBQU07O0FBRXBDO0FBQ0EsVUFBVSw0REFBd0I7QUFDbEM7QUFDQSxVQUFVLDREQUF3QjtBQUNsQyw2REFBNkQ7QUFDN0QsNkRBQTZEO0FBQzdELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnRUFBNEI7OztBQUd0Qzs7QUFFTzs7QUFFUCxnQkFBZ0IseURBQVE7O0FBRXhCLHFCQUFxQiw4REFBMEI7O0FBRS9DO0FBQ0EsOEJBQThCLGdEQUFNO0FBQ3BDLGVBQWUsZ0RBQU0sS0FBSyxnREFBTTtBQUNoQyxnQkFBZ0IsZ0RBQU0sS0FBSyxnREFBTTs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOzs7QUFHdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOzs7QUFHdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7O0FBR3RDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QyxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBLFlBQVksZ0RBQU0sTUFBTSxnREFBTTs7QUFFOUIsY0FBYyw0REFBd0I7QUFDdEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckMsdUJBQXVCLG1FQUFtQjtBQUMxQztBQUNBLE1BQU0sd0JBQXdCLGlFQUFpQjtBQUMvQztBQUNBLE1BQU0sd0JBQXdCLGtFQUFrQjtBQUNoRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQTtBQUNBLG1CQUFtQiwyREFBdUI7O0FBRTFDO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQXVCO0FBQzFDLHVCQUF1Qix5REFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrREFBMkI7O0FBRXJDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQXVCOztBQUUxQztBQUNBO0FBQ0EsbUJBQW1CLDJEQUF1QjtBQUMxQyx1QkFBdUIseURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLCtEQUEyQjs7QUFFckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGtFQUFrQjs7QUFFeEMsVUFBVSx1RUFBbUMsZUFBZSx3RUFBc0I7QUFDbEY7QUFDQTtBQUNBLG1CQUFtQiwyREFBdUI7QUFDMUMsdUJBQXVCLHlEQUFROztBQUUvQjtBQUNBO0FBQ0EsbUJBQW1CLDJEQUF1Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLCtEQUEyQjs7QUFFckM7QUFDQTs7QUFFTztBQUNQLFdBQVcsY0FBYyxRQUFRLDREQUF3Qjs7QUFFekQ7O0FBRUEsbUJBQW1CLGlEQUFPO0FBQzFCLGVBQWUsZ0RBQU0sS0FBSyxnREFBTTtBQUNoQztBQUNBOztBQUVBLHNCQUFzQix5REFBUTs7QUFFOUI7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7O0FBR3JDO0FBQ0E7QUFDQSxVQUFVLHVFQUFtQztBQUM3QztBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsVUFBVSwrREFBMkI7O0FBRXJDO0FBQ0E7QUFDQSxVQUFVLHVFQUFtQztBQUM3QztBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOzs7QUFHckM7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7O0FBRUE7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOzs7QUFHckM7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrREFBMkI7OztBQUdyQztBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSwrQkFBK0IsY0FBYztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0EsVUFBVSwrREFBMkI7OztBQUdyQztBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOztBQUVyQzs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QiwyREFBdUI7QUFDL0M7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdPO0FBQ1AsVUFBVSx1RUFBbUM7QUFDN0Msa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRU87QUFDUCxVQUFVLGtFQUE4QjtBQUN4QztBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7QUFDdEM7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLy8gRm9ybWF0XG4vLyA9PT09PT1cbi8vIEhlYWRlcigxKVxuLy8gICAgICBQcm92ZXIgVHlwZSAxIEdyb3RoXG4vLyBIZWFkZXJHcm90aCgyKVxuLy8gICAgICBuOHFcbi8vICAgICAgcVxuLy8gICAgICBuOHJcbi8vICAgICAgclxuLy8gICAgICBOVmFyc1xuLy8gICAgICBOUHViXG4vLyAgICAgIERvbWFpblNpemUgIChtdWx0aXBsZSBvZiAyXG4vLyAgICAgIGFscGhhMVxuLy8gICAgICBiZXRhMVxuLy8gICAgICBkZWx0YTFcbi8vICAgICAgYmV0YTJcbi8vICAgICAgZ2FtbWEyXG4vLyAgICAgIGRlbHRhMlxuLy8gSUMoMylcbi8vIENvZWZzKDQpXG4vLyBQb2ludHNBKDUpXG4vLyBQb2ludHNCMSg2KVxuLy8gUG9pbnRzQjIoNylcbi8vIFBvaW50c0MoOClcbi8vIFBvaW50c0goOSlcbi8vIENvbnRyaWJ1dGlvbnMoMTApXG5cbmltcG9ydCB7IFNjYWxhciwgRjFGaWVsZCB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuXG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21RIGFzIGdldEN1cnZlIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgeyBsb2cyIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHtGRkxPTktfUFJPVE9DT0xfSUQsIEdST1RIMTZfUFJPVE9DT0xfSUQsIFBMT05LX1BST1RPQ09MX0lEfSBmcm9tIFwiLi96a2V5X2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHtaS0VZX0ZGX0hFQURFUl9TRUNUSU9OfSBmcm9tIFwiLi9mZmxvbmtfY29uc3RhbnRzLmpzXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZUhlYWRlcihmZCwgemtleSkge1xuXG4gICAgLy8gV3JpdGUgdGhlIGhlYWRlclxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAxKTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDEpOyAvLyBHcm90aFxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgdGhlIEdyb3RoIGhlYWRlciBzZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMik7XG4gICAgY29uc3QgcHJpbWVRID0gY3VydmUucTtcbiAgICBjb25zdCBuOHEgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVSKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihuOHEpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy53cml0ZUJpZ0ludChmZCwgcHJpbWVRLCBuOHEpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobjhyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMud3JpdGVCaWdJbnQoZmQsIHByaW1lUiwgbjhyKTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHprZXkublZhcnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgYmFyc1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoemtleS5uUHVibGljKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBwdWJsaWMgdmFycyAobm90IGluY2x1ZGluZyBPTkUpXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMih6a2V5LmRvbWFpblNpemUpOyAgICAgICAgICAgICAgICAgIC8vIGRvbWFpblNpemVcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS52a19hbHBoYV8xKTtcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS52a19iZXRhXzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoZmQsIGN1cnZlLCB6a2V5LnZrX2JldGFfMik7XG4gICAgYXdhaXQgd3JpdGVHMihmZCwgY3VydmUsIHprZXkudmtfZ2FtbWFfMik7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkudmtfZGVsdGFfMSk7XG4gICAgYXdhaXQgd3JpdGVHMihmZCwgY3VydmUsIHprZXkudmtfZGVsdGFfMik7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZVpLZXkoZmlsZU5hbWUsIHprZXkpIHtcblxuICAgIGxldCBjdXJ2ZSA9IGdldEN1cnZlKHprZXkucSk7XG5cbiAgICBjb25zdCBmZCA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKGZpbGVOYW1lLFwiemtleVwiLCAxLCA5KTtcblxuICAgIGF3YWl0IHdyaXRlSGVhZGVyKGZkLCB6a2V5KTtcbiAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgoemtleS5yKSAtIDEpIC8gNjQpICsxKSo4O1xuICAgIGNvbnN0IFJyID0gU2NhbGFyLm1vZChTY2FsYXIuc2hsKDEsIG44cio4KSwgemtleS5yKTtcbiAgICBjb25zdCBSMnIgPSBTY2FsYXIubW9kKFNjYWxhci5tdWwoUnIsUnIpLCB6a2V5LnIpO1xuXG4gICAgLy8gV3JpdGUgUG9scyAoQSBhbmQgQiAoQyBjYW4gYmUgb21pdHRlZCkpXG4gICAgLy8vLy8vLy8vLy9cblxuICAgIHprZXkuY2NvZWZzID0gemtleS5jY29lZnMuZmlsdGVyKGMgPT4gYy5tYXRyaXg8Mik7XG4gICAgemtleS5jY29lZnMuc29ydCggKGEsYikgPT4gYS5jb25zdHJhaW50IC0gYi5jb25zdHJhaW50ICk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA0KTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHprZXkuY2NvZWZzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkuY2NvZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZWYgPSB6a2V5LmNjb2Vmc1tpXTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb2VmLm1hdHJpeCk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY29lZi5jb25zdHJhaW50KTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb2VmLnNpZ25hbCk7XG4gICAgICAgIGF3YWl0IHdyaXRlRnIyKGNvZWYudmFsdWUpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gV3JpdGUgSUMgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAzKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS5JQ1tpXSApO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gV3JpdGUgQVxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA1KTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LkFbaV0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIEIxXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDYpO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkuQjFbaV0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIEIyXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDcpO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVHMihmZCwgY3VydmUsIHprZXkuQjJbaV0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIENcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgOCk7XG4gICAgZm9yIChsZXQgaT16a2V5Lm5QdWJsaWMrMTsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkuQ1tpXSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBXcml0ZSBIIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA5KTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkuaEV4cHNbaV0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUZyMihuKSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gbW9udGdvbWVyeVxuICAgICAgICBuID0gU2NhbGFyLm1vZCggU2NhbGFyLm11bChuLCBSMnIpLCB6a2V5LnIpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy53cml0ZUJpZ0ludChmZCwgbiwgbjhyKTtcbiAgICB9XG5cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVHMShmZCwgY3VydmUsIHApIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKTtcbiAgICBjdXJ2ZS5HMS50b1JwckxFTShidWZmLCAwLCBwKTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVHMihmZCwgY3VydmUsIHApIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzIuRi5uOCoyKTtcbiAgICBjdXJ2ZS5HMi50b1JwckxFTShidWZmLCAwLCBwKTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpIHtcbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5HMS5GLm44KjIpO1xuICAgIGNvbnN0IHJlcyA9IGN1cnZlLkcxLmZyb21ScHJMRU0oYnVmZiwgMCk7XG4gICAgcmV0dXJuIHRvT2JqZWN0ID8gY3VydmUuRzEudG9PYmplY3QocmVzKSA6IHJlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEcyKGZkLCBjdXJ2ZSwgdG9PYmplY3QpIHtcbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5HMi5GLm44KjIpO1xuICAgIGNvbnN0IHJlcyA9IGN1cnZlLkcyLmZyb21ScHJMRU0oYnVmZiwgMCk7XG4gICAgcmV0dXJuIHRvT2JqZWN0ID8gY3VydmUuRzIudG9PYmplY3QocmVzKSA6IHJlcztcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlcihmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgLy8gUmVhZCBIZWFkZXJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDEpO1xuICAgIGNvbnN0IHByb3RvY29sSWQgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgaWYgKHByb3RvY29sSWQgPT09IEdST1RIMTZfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRIZWFkZXJHcm90aDE2KGZkLCBzZWN0aW9ucywgdG9PYmplY3QsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xJZCA9PT0gUExPTktfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRIZWFkZXJQbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHByb3RvY29sSWQgPT09IEZGTE9OS19QUk9UT0NPTF9JRCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVhZEhlYWRlckZGbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm90b2NvbCBub3Qgc3VwcG9ydGVkOiBcIik7XG4gICAgfVxufVxuXG5cblxuXG5hc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyR3JvdGgxNihmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgemtleSA9IHt9O1xuXG4gICAgemtleS5wcm90b2NvbCA9IFwiZ3JvdGgxNlwiO1xuXG4gICAgLy8gUmVhZCBHcm90aCBIZWFkZXJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDIpO1xuICAgIGNvbnN0IG44cSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhxID0gbjhxO1xuICAgIHprZXkucSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCBuOHEpO1xuXG4gICAgY29uc3QgbjhyID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uOHIgPSBuOHI7XG4gICAgemtleS5yID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaWdJbnQoZmQsIG44cik7XG4gICAgemtleS5jdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSwgb3B0aW9ucyk7XG4gICAgemtleS5uVmFycyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkublB1YmxpYyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuZG9tYWluU2l6ZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkucG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG4gICAgemtleS52a19hbHBoYV8xID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS52a19iZXRhXzEgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LnZrX2JldGFfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfZ2FtbWFfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfZGVsdGFfMSA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfZGVsdGFfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICByZXR1cm4gemtleTtcblxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyUGxvbmsoZmQsIHNlY3Rpb25zLCB0b09iamVjdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHprZXkgPSB7fTtcblxuICAgIHprZXkucHJvdG9jb2wgPSBcInBsb25rXCI7XG5cbiAgICAvLyBSZWFkIFBsb25rIEhlYWRlclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMik7XG4gICAgY29uc3QgbjhxID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uOHEgPSBuOHE7XG4gICAgemtleS5xID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaWdJbnQoZmQsIG44cSk7XG5cbiAgICBjb25zdCBuOHIgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm44ciA9IG44cjtcbiAgICB6a2V5LnIgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpZ0ludChmZCwgbjhyKTtcbiAgICB6a2V5LmN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xLCBvcHRpb25zKTtcbiAgICB6a2V5Lm5WYXJzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uUHVibGljID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5kb21haW5TaXplID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5wb3dlciA9IGxvZzIoemtleS5kb21haW5TaXplKTtcbiAgICB6a2V5Lm5BZGRpdGlvbnMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm5Db25zdHJhaW50cyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuazEgPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS5rMiA9IGF3YWl0IGZkLnJlYWQobjhyKTtcblxuICAgIHprZXkuUW0gPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlFsID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5RciA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUW8gPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlFjID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5TMSA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUzIgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlMzID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5YXzIgPSBhd2FpdCByZWFkRzIoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICByZXR1cm4gemtleTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlckZGbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgemtleSA9IHt9O1xuXG4gICAgemtleS5wcm90b2NvbCA9IFwiZmZsb25rXCI7XG4gICAgemtleS5wcm90b2NvbElkID0gRkZMT05LX1BST1RPQ09MX0lEO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBaS0VZX0ZGX0hFQURFUl9TRUNUSU9OKTtcbiAgICBjb25zdCBuOHEgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm44cSA9IG44cTtcbiAgICB6a2V5LnEgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpZ0ludChmZCwgbjhxKTtcbiAgICB6a2V5LmN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IG44ciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhyID0gbjhyO1xuICAgIHprZXkuciA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCBuOHIpO1xuXG4gICAgemtleS5uVmFycyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkublB1YmxpYyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuZG9tYWluU2l6ZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkucG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG4gICAgemtleS5uQWRkaXRpb25zID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uQ29uc3RyYWludHMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcblxuICAgIHprZXkuazEgPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS5rMiA9IGF3YWl0IGZkLnJlYWQobjhyKTtcblxuICAgIHprZXkudzMgPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS53NCA9IGF3YWl0IGZkLnJlYWQobjhyKTtcbiAgICB6a2V5Lnc4ID0gYXdhaXQgZmQucmVhZChuOHIpO1xuICAgIHprZXkud3IgPSBhd2FpdCBmZC5yZWFkKG44cik7XG5cbiAgICB6a2V5LlhfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuXG4gICAgemtleS5DMCA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiB6a2V5O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZFpLZXkoZmlsZU5hbWUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3Qge2ZkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoZmlsZU5hbWUsIFwiemtleVwiLCAxKTtcblxuICAgIGNvbnN0IHprZXkgPSBhd2FpdCByZWFkSGVhZGVyKGZkLCBzZWN0aW9ucywgdG9PYmplY3QpO1xuXG4gICAgY29uc3QgRnIgPSBuZXcgRjFGaWVsZCh6a2V5LnIpO1xuICAgIGNvbnN0IFJyID0gU2NhbGFyLm1vZChTY2FsYXIuc2hsKDEsIHprZXkubjhyKjgpLCB6a2V5LnIpO1xuICAgIGNvbnN0IFJyaSA9IEZyLmludihScik7XG4gICAgY29uc3QgUnJpMiA9IEZyLm11bChScmksIFJyaSk7XG5cbiAgICBsZXQgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuXG4gICAgLy8gUmVhZCBJQyBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDMpO1xuICAgIHprZXkuSUMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBQID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgICAgICB6a2V5LklDLnB1c2goUCk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQ29lZnNcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgNCk7XG4gICAgY29uc3QgbkNDb2VmcyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuY2NvZWZzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5DQ29lZnM7IGkrKykge1xuICAgICAgICBjb25zdCBtID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgICAgIGNvbnN0IGMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICAgICAgY29uc3QgcyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgICAgICBjb25zdCB2ID0gYXdhaXQgcmVhZEZyMih0b09iamVjdCk7XG4gICAgICAgIHprZXkuY2NvZWZzLnB1c2goe1xuICAgICAgICAgICAgbWF0cml4OiBtLFxuICAgICAgICAgICAgY29uc3RyYWludDogYyxcbiAgICAgICAgICAgIHNpZ25hbDogcyxcbiAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgLy8gUmVhZCBBIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA1KTtcbiAgICB6a2V5LkEgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEEgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgICAgIHprZXkuQVtpXSA9IEE7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQjFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgNik7XG4gICAgemtleS5CMSA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgY29uc3QgQjEgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG5cbiAgICAgICAgemtleS5CMVtpXSA9IEIxO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBSZWFkIEIyIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA3KTtcbiAgICB6a2V5LkIyID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBjb25zdCBCMiA9IGF3YWl0IHJlYWRHMihmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICAgICAgemtleS5CMltpXSA9IEIyO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBSZWFkIEMgcG9pbnRzXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDgpO1xuICAgIHprZXkuQyA9IFtdO1xuICAgIGZvciAobGV0IGk9emtleS5uUHVibGljKzE7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEMgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG5cbiAgICAgICAgemtleS5DW2ldID0gQztcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gUmVhZCBIIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA5KTtcbiAgICB6a2V5LmhFeHBzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEggPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgICAgIHprZXkuaEV4cHMucHVzaChIKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gemtleTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRGcjIoLyogdG9PYmplY3QgKi8pIHtcbiAgICAgICAgY29uc3QgbiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCB6a2V5Lm44cik7XG4gICAgICAgIHJldHVybiBGci5tdWwobiwgUnJpMik7XG4gICAgfVxuXG59XG5cblxuYXN5bmMgZnVuY3Rpb24gcmVhZENvbnRyaWJ1dGlvbihmZCwgY3VydmUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3QgYyA9IHtkZWx0YTp7fX07XG4gICAgYy5kZWx0YUFmdGVyID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMuZGVsdGEuZzFfcyA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICBjLmRlbHRhLmcxX3N4ID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMuZGVsdGEuZzJfc3B4ID0gYXdhaXQgcmVhZEcyKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMudHJhbnNjcmlwdCA9IGF3YWl0IGZkLnJlYWQoNjQpO1xuICAgIGMudHlwZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuXG4gICAgY29uc3QgcGFyYW1MZW5ndGggPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBjdXJQb3MgPSBmZC5wb3M7XG4gICAgbGV0IGxhc3RUeXBlID0wO1xuICAgIHdoaWxlIChmZC5wb3MtY3VyUG9zIDwgcGFyYW1MZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYnVmZlR5cGUgPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF08PSBsYXN0VHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVycyBpbiB0aGUgY29udHJpYnV0aW9uIG11c3QgYmUgc29ydGVkXCIpO1xuICAgICAgICBsYXN0VHlwZSA9IGJ1ZmZUeXBlWzBdO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF09PTEpIHsgICAgIC8vIE5hbWVcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMZW4gPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICAgICAgY29uc3QgYnVmZlN0ciA9IGF3YWl0IGZkLnJlYWQoYnVmZkxlblswXSk7XG4gICAgICAgICAgICBjLm5hbWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZlN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZlR5cGVbMF09PTIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZFeHAgPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICAgICAgYy5udW1JdGVyYXRpb25zRXhwID0gYnVmZkV4cFswXTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmVHlwZVswXT09Mykge1xuICAgICAgICAgICAgY29uc3QgYnVmZkxlbiA9IGF3YWl0IGZkLnJlYWQoMSk7XG4gICAgICAgICAgICBjLmJlYWNvbkhhc2ggPSBhd2FpdCBmZC5yZWFkKGJ1ZmZMZW5bMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG5vdCByZWNvZ25pemVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmZC5wb3MgIT0gY3VyUG9zICsgcGFyYW1MZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVycyBkbyBub3QgbWF0Y2hcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGM7XG59XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRNUENQYXJhbXMoZmQsIGN1cnZlLCBzZWN0aW9ucykge1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMTApO1xuICAgIGNvbnN0IHJlcyA9IHsgY29udHJpYnV0aW9uczogW119O1xuICAgIHJlcy5jc0hhc2ggPSBhd2FpdCBmZC5yZWFkKDY0KTtcbiAgICBjb25zdCBuID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPG47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbihmZCwgY3VydmUpO1xuICAgICAgICByZXMuY29udHJpYnV0aW9ucy5wdXNoKGMpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVDb250cmlidXRpb24oZmQsIGN1cnZlLCBjKSB7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIGMuZGVsdGFBZnRlcik7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIGMuZGVsdGEuZzFfcyk7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIGMuZGVsdGEuZzFfc3gpO1xuICAgIGF3YWl0IHdyaXRlRzIoZmQsIGN1cnZlLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgYXdhaXQgZmQud3JpdGUoYy50cmFuc2NyaXB0KTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGMudHlwZSB8fCAwKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGlmIChjLm5hbWUpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goMSk7ICAgICAgLy8gUGFyYW0gTmFtZVxuICAgICAgICBjb25zdCBuYW1lRGF0YSA9IG5ldyBUZXh0RW5jb2RlcihcInV0Zi04XCIpLmVuY29kZShjLm5hbWUuc3Vic3RyaW5nKDAsNjQpKTtcbiAgICAgICAgcGFyYW1zLnB1c2gobmFtZURhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuYW1lRGF0YS5ieXRlTGVuZ3RoOyBpKyspIHBhcmFtcy5wdXNoKG5hbWVEYXRhW2ldKTtcbiAgICB9XG4gICAgaWYgKGMudHlwZSA9PSAxKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKDIpOyAgICAgIC8vIFBhcmFtIG51bUl0ZXJhdGlvbnNFeHBcbiAgICAgICAgcGFyYW1zLnB1c2goYy5udW1JdGVyYXRpb25zRXhwKTtcblxuICAgICAgICBwYXJhbXMucHVzaCgzKTsgICAgICAvLyBCZWFjb24gSGFzaFxuICAgICAgICBwYXJhbXMucHVzaChjLmJlYWNvbkhhc2guYnl0ZUxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjLmJlYWNvbkhhc2guYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChjLmJlYWNvbkhhc2hbaV0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxlbmd0aD4wKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc0J1ZmYgPSBuZXcgVWludDhBcnJheShwYXJhbXMpO1xuICAgICAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHBhcmFtc0J1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlKHBhcmFtc0J1ZmYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoMCk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZU1QQ1BhcmFtcyhmZCwgY3VydmUsIG1wY1BhcmFtcykge1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMTApO1xuICAgIGF3YWl0IGZkLndyaXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVDb250cmlidXRpb24oZmQsIGN1cnZlLG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNoRzEoaGFzaGVyLCBjdXJ2ZSwgcCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIpO1xuICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDAsIHApO1xuICAgIGhhc2hlci51cGRhdGUoYnVmZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNoRzIoaGFzaGVyLGN1cnZlLCBwKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcyLkYubjgqMik7XG4gICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgcCk7XG4gICAgaGFzaGVyLnVwZGF0ZShidWZmKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hQdWJLZXkoaGFzaGVyLCBjdXJ2ZSwgYykge1xuICAgIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBjLmRlbHRhQWZ0ZXIpO1xuICAgIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcxX3MpO1xuICAgIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcxX3N4KTtcbiAgICBoYXNoRzIoaGFzaGVyLCBjdXJ2ZSwgYy5kZWx0YS5nMl9zcHgpO1xuICAgIGhhc2hlci51cGRhdGUoYy50cmFuc2NyaXB0KTtcbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_verify_frominit.js":
/*!**********************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_verify_frominit.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2verifyFromInit)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(rsc)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(rsc)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(rsc)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(rsc)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypair.js */ \"(rsc)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ffjavascript */ \"(rsc)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst sameRatio = _misc_js__WEBPACK_IMPORTED_MODULE_3__.sameRatio;\n\n\n\n\n\nasync function phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger) {\n\n    let sr;\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fd, sections, false);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fd, curve, sections);\n\n    const accumulatedHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });\n    accumulatedHasher.update(mpcParams.csHash);\n    let curDelta = curve.G1.g;\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        const ourHasher = _misc_js__WEBPACK_IMPORTED_MODULE_3__.cloneHasher(accumulatedHasher);\n\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1)(ourHasher, curve, c.delta.g1_s);\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1)(ourHasher, curve, c.delta.g1_sx);\n\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_3__.hashIsEqual(ourHasher.digest(), c.transcript)) {\n            console.log(`INVALID(${i}): Inconsistent transcript `);\n            return false;\n        }\n\n        const delta_g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_4__.hashToG2)(curve, c.transcript);\n\n        sr = await sameRatio(curve, c.delta.g1_s, c.delta.g1_sx, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): public key G1 and G2 do not have the same ration `);\n            return false;\n        }\n\n        sr = await sameRatio(curve, curDelta, c.deltaAfter, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): deltaAfter does not fillow the public key `);\n            return false;\n        }\n\n        if (c.type == 1) {\n            const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.rngFromBeaconParams(c.beaconHash, c.numIterationsExp);\n            const expected_prvKey = curve.Fr.fromRng(rng);\n            const expected_g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n            const expected_g1_sx = curve.G1.toAffine(curve.G1.timesFr(expected_g1_s, expected_prvKey));\n            if (curve.G1.eq(expected_g1_s, c.delta.g1_s) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_s `);\n                return false;\n            }\n            if (curve.G1.eq(expected_g1_sx, c.delta.g1_sx) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_sx `);\n                return false;\n            }\n        }\n\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(accumulatedHasher, curve, c);\n\n        const contributionHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(contributionHasher, curve, c);\n\n        c.contributionHash = contributionHasher.digest();\n\n        curDelta = c.deltaAfter;\n    }\n\n\n    const {fd: fdInit, sections: sectionsInit} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(initFileName, \"zkey\", 2);\n    const zkeyInit = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdInit, sectionsInit, false);\n\n    if (zkeyInit.protocol != \"groth16\") {\n        throw new Error(\"zkeyinit file is not groth16\");\n    }\n\n    if (  (!ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.eq(zkeyInit.q, zkey.q))\n        ||(!ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.eq(zkeyInit.r, zkey.r))\n        ||(zkeyInit.n8q != zkey.n8q)\n        ||(zkeyInit.n8r != zkey.n8r))\n    {\n        if (logger) logger.error(\"INVALID:  Different curves\");\n        return false;\n    }\n\n    if (  (zkeyInit.nVars != zkey.nVars)\n        ||(zkeyInit.nPublic !=  zkey.nPublic)\n        ||(zkeyInit.domainSize != zkey.domainSize))\n    {\n        if (logger) logger.error(\"INVALID:  Different circuit parameters\");\n        return false;\n    }\n\n    if (!curve.G1.eq(zkey.vk_alpha_1, zkeyInit.vk_alpha_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid alpha1\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_beta_1, zkeyInit.vk_beta_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta1\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_beta_2, zkeyInit.vk_beta_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta2\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_gamma_2, zkeyInit.vk_gamma_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid gamma2\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_delta_1, curDelta)) {\n        if (logger) logger.error(\"INVALID:  Invalid delta1\");\n        return false;\n    }\n    sr = await sameRatio(curve, curve.G1.g, curDelta, curve.G2.g, zkey.vk_delta_2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID:  Invalid delta2\");\n        return false;\n    }\n\n    const mpcParamsInit = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdInit, curve, sectionsInit);\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_3__.hashIsEqual(mpcParams.csHash, mpcParamsInit.csHash)) {\n        if (logger) logger.error(\"INVALID:  Circuit does not match\");\n        return false;\n    }\n\n    // Check sizes of sections\n    if (sections[8][0].size != sG1*(zkey.nVars-zkey.nPublic-1)) {\n        if (logger) logger.error(\"INVALID:  Invalid L section size\");\n        return false;\n    }\n\n    if (sections[9][0].size != sG1*(zkey.domainSize)) {\n        if (logger) logger.error(\"INVALID:  Invalid H section size\");\n        return false;\n    }\n\n    let ss;\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 3);\n    if (!ss) {\n        if (logger) logger.error(\"INVALID:  IC section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 4);\n    if (!ss) {\n        if (logger) logger.error(\"Coeffs section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 5);\n    if (!ss) {\n        if (logger) logger.error(\"A section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 6);\n    if (!ss) {\n        if (logger) logger.error(\"B1 section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 7);\n    if (!ss) {\n        if (logger) logger.error(\"B2 section is not identical\");\n        return false;\n    }\n\n    // Check L\n    sr = await sectionHasSameRatio(\"G1\", fdInit, sectionsInit, fd, sections, 8, zkey.vk_delta_2, zkeyInit.vk_delta_2, \"L section\");\n    if (sr!==true) {\n        if (logger) logger.error(\"L section does not match\");\n        return false;\n    }\n\n    // Check H\n    sr = await sameRatioH();\n    if (sr!==true) {\n        if (logger) logger.error(\"H section does not match\");\n        return false;\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n\n    await fd.close();\n    await fdInit.close();\n\n    for (let i=mpcParams.contributions.length-1; i>=0; i--) {\n        const c = mpcParams.contributions[i];\n        if (logger) logger.info(\"-------------------------\");\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(c.contributionHash, `contribution #${i+1} ${c.name ? c.name : \"\"}:`));\n        if (c.type == 1) {\n            if (logger) logger.info(`Beacon generator: ${_misc_js__WEBPACK_IMPORTED_MODULE_3__.byteArray2hex(c.beaconHash)}`);\n            if (logger) logger.info(`Beacon iterations Exp: ${c.numIterationsExp}`);\n        }\n    }\n    if (logger) logger.info(\"-------------------------\");\n\n    if (logger) logger.info(\"ZKey Ok!\");\n\n    return true;\n\n\n    async function sectionHasSameRatio(groupName, fd1, sections1, fd2, sections2, idSection, g2sp, g2spx, sectionName) {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd1, sections1, idSection);\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd2, sections2, idSection);\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        const nPoints = sections1[idSection][0].size / sG;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`Same ratio check ${sectionName}:  ${i}/${nPoints}`);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases1 = await fd1.read(n*sG);\n            const bases2 = await fd2.read(n*sG);\n\n            const scalars = _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomBytes(4*n);\n\n            const r1 = await G.multiExpAffine(bases1, scalars);\n            const r2 = await G.multiExpAffine(bases2, scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd1);\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd2);\n\n        if (nPoints == 0) return true;\n\n        sr = await sameRatio(curve, R1, R2, g2sp, g2spx);\n        if (sr !== true) return false;\n\n        return true;\n    }\n\n    async function sameRatioH() {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve.G1;\n        const Fr = curve.Fr;\n        const sG = G.F.n8*2;\n\n        const {fd: fdPTau, sections: sectionsPTau} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(pTauFileName, \"ptau\", 1);\n\n        let buff_r = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * zkey.n8r);\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = _misc_js__WEBPACK_IMPORTED_MODULE_3__.readUInt32BE(_misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomBytes(4), 0);\n        }\n        const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.ChaCha(seed);\n        for (let i=0; i<zkey.domainSize-1; i++) {   // Note that last one is zero\n            const e = Fr.fromRng(rng);\n            Fr.toRprLE(buff_r, i*zkey.n8r, e);\n        }\n        Fr.toRprLE(buff_r, (zkey.domainSize-1)*zkey.n8r, Fr.zero);\n\n        let R1 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(tau):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff1 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + zkey.domainSize*sG + i*sG);\n            const buff2 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + i*sG);\n\n            const buffB = await batchSubtract(buff1, buff2);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buffB, buffS);\n\n            R1 = G.add(R1, r);\n        }\n\n        // Calculate odd coefficients in transformed domain\n\n        buff_r = await Fr.batchToMontgomery(buff_r);\n        // const first = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n        // Works*2   const first = curve.Fr.neg(curve.Fr.e(2));\n\n\n        let first;\n\n        if (zkey.power < Fr.s) {\n            first = Fr.neg(Fr.e(2));\n        } else {\n            const small_m  = 2 ** Fr.s;\n            const shift_to_small_m = Fr.exp(Fr.shift, small_m);\n            first = Fr.sub( shift_to_small_m, Fr.one);\n        }\n\n        // const inc = curve.Fr.inv(curve.PFr.w[zkey.power+1]);\n        const inc = zkey.power < Fr.s ? Fr.w[zkey.power+1] : Fr.shift;\n        buff_r = await Fr.batchApplyKey(buff_r, first, inc);\n        buff_r = await Fr.fft(buff_r);\n        buff_r = await Fr.batchFromMontgomery(buff_r);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd, sections, 9);\n        let R2 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(lagrange):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff = await fd.read(sG*n);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buff, buffS);\n\n            R2 = G.add(R2, r);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd);\n\n        sr = await sameRatio(curve, R1, R2, zkey.vk_delta_2, zkeyInit.vk_delta_2);\n        if (sr !== true) return false;\n\n\n        return true;\n\n    }\n\n    async function batchSubtract(buff1, buff2) {\n        const sG = curve.G1.F.n8*2;\n        const nPoints = buff1.byteLength / sG;\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(batchSubtractThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        const fullBuffOut = new Uint8Array(nPoints*sG);\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    }\n\n\n    async function batchSubtractThread(buff1, buff2) {\n        const sG1 = curve.G1.F.n8*2;\n        const sGmid = curve.G1.F.n8*3;\n        const nPoints = buff1.byteLength/sG1;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV92ZXJpZnlfZnJvbWluaXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDtBQUNQO0FBQ1c7QUFDUjtBQUNkO0FBQ2tCO0FBQ3BELGtCQUFrQiwrQ0FBYztBQUNtQjtBQUNNOzs7O0FBSTFDOztBQUVmO0FBQ0EsV0FBVyxjQUFjLFFBQVEsNERBQXdCO0FBQ3pELHVCQUF1QixzREFBb0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix5REFBUTtBQUNoQzs7QUFFQSw0QkFBNEIseURBQXVCOztBQUVuRCw4QkFBOEIsMERBQU8sVUFBVSxXQUFXO0FBQzFEO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BEO0FBQ0EsMEJBQTBCLGlEQUFnQjs7QUFFMUMsUUFBUSxzREFBTTtBQUNkLFFBQVEsc0RBQU07O0FBRWQsYUFBYSxpREFBZ0I7QUFDN0IsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTs7QUFFQSw0QkFBNEIscURBQVE7O0FBRXBDO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRTtBQUNyQztBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHlEQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLDBEQUFVOztBQUVsQixtQ0FBbUMsMERBQU8sVUFBVSxXQUFXO0FBQy9ELFFBQVEsMERBQVU7O0FBRWxCOztBQUVBO0FBQ0E7OztBQUdBLFdBQVcsb0NBQW9DLFFBQVEsNERBQXdCO0FBQy9FLDJCQUEyQixzREFBb0I7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGdEQUFNO0FBQ2xCLFlBQVksZ0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyx5REFBdUI7QUFDdkQsU0FBUyxpREFBZ0I7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0M7QUFDQTs7QUFFQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFlLHNDQUFzQyxLQUFLLEVBQUUscUJBQXFCO0FBQ2pIO0FBQ0EseURBQXlELG1EQUFrQixlQUFlO0FBQzFGLDhEQUE4RCxtQkFBbUI7QUFDakY7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUVBQW1DO0FBQ2pELGNBQWMsdUVBQW1DOztBQUVqRDtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixXQUFXO0FBQ2pDLHlEQUF5RCxZQUFZLEtBQUssRUFBRSxHQUFHLFFBQVE7QUFDdkY7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixvREFBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBMkI7QUFDekMsY0FBYywrREFBMkI7O0FBRXpDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsb0NBQW9DLFFBQVEsNERBQXdCOztBQUVuRix5QkFBeUIsbURBQVM7O0FBRWxDO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0Isc0JBQXNCLGtEQUFpQixDQUFDLG9EQUFtQjtBQUMzRDtBQUNBLHdCQUF3QixnREFBTTtBQUM5QixzQkFBc0IscUJBQXFCLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLDhEQUE4RCxFQUFFLEdBQUcsZ0JBQWdCO0FBQ25GOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1RUFBbUM7QUFDakQ7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLG1FQUFtRSxFQUFFLEdBQUcsZ0JBQWdCO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYywrREFBMkI7O0FBRXpDO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RCxtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQix5Q0FBeUM7QUFDNUQsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDLHFCQUFxQixzQkFBc0I7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsT0FBTztBQUNwQixVQUFVO0FBQ1YsbUJBQW1CLDZDQUE2Qzs7QUFFaEU7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X3ZlcmlmeV9mcm9taW5pdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHprZXlVdGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21RIGFzIGdldEN1cnZlIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgeyBibGFrZTJiIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvYmxha2UyYlwiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBoYXNoVG9HMiBhcyBoYXNoVG9HMiB9IGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmNvbnN0IHNhbWVSYXRpbyA9IG1pc2Muc2FtZVJhdGlvO1xuaW1wb3J0IHtoYXNoRzEsIGhhc2hQdWJLZXl9IGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IFNjYWxhciwgQ2hhQ2hhLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwaGFzZTJ2ZXJpZnlGcm9tSW5pdChpbml0RmlsZU5hbWUsIHBUYXVGaWxlTmFtZSwgemtleUZpbGVOYW1lLCBsb2dnZXIpIHtcblxuICAgIGxldCBzcjtcbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmQsIHNlY3Rpb25zLCBmYWxzZSk7XG4gICAgaWYgKHprZXkucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG5cbiAgICBjb25zdCBtcGNQYXJhbXMgPSBhd2FpdCB6a2V5VXRpbHMucmVhZE1QQ1BhcmFtcyhmZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGFjY3VtdWxhdGVkSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgYWNjdW11bGF0ZWRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGxldCBjdXJEZWx0YSA9IGN1cnZlLkcxLmc7XG4gICAgZm9yIChsZXQgaT0wOyBpPG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXTtcbiAgICAgICAgY29uc3Qgb3VySGFzaGVyID0gbWlzYy5jbG9uZUhhc2hlcihhY2N1bXVsYXRlZEhhc2hlcik7XG5cbiAgICAgICAgaGFzaEcxKG91ckhhc2hlciwgY3VydmUsIGMuZGVsdGEuZzFfcyk7XG4gICAgICAgIGhhc2hHMShvdXJIYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcxX3N4KTtcblxuICAgICAgICBpZiAoIW1pc2MuaGFzaElzRXF1YWwob3VySGFzaGVyLmRpZ2VzdCgpLCBjLnRyYW5zY3JpcHQpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgSU5WQUxJRCgke2l9KTogSW5jb25zaXN0ZW50IHRyYW5zY3JpcHQgYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWx0YV9nMl9zcCA9IGhhc2hUb0cyKGN1cnZlLCBjLnRyYW5zY3JpcHQpO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjLmRlbHRhLmcxX3MsIGMuZGVsdGEuZzFfc3gsIGRlbHRhX2cyX3NwLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYElOVkFMSUQoJHtpfSk6IHB1YmxpYyBrZXkgRzEgYW5kIEcyIGRvIG5vdCBoYXZlIHRoZSBzYW1lIHJhdGlvbiBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJEZWx0YSwgYy5kZWx0YUFmdGVyLCBkZWx0YV9nMl9zcCwgYy5kZWx0YS5nMl9zcHgpO1xuICAgICAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJTlZBTElEKCR7aX0pOiBkZWx0YUFmdGVyIGRvZXMgbm90IGZpbGxvdyB0aGUgcHVibGljIGtleSBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjLnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5ybmdGcm9tQmVhY29uUGFyYW1zKGMuYmVhY29uSGFzaCwgYy5udW1JdGVyYXRpb25zRXhwKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkX3BydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkX2cxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRfZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGV4cGVjdGVkX2cxX3MsIGV4cGVjdGVkX3BydktleSkpO1xuICAgICAgICAgICAgaWYgKGN1cnZlLkcxLmVxKGV4cGVjdGVkX2cxX3MsIGMuZGVsdGEuZzFfcykgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSU5WQUxJRCgke2l9KTogS2V5IG9mIHRoZSBiZWFjb24gZG9lcyBub3QgbWF0Y2guIGcxX3MgYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnZlLkcxLmVxKGV4cGVjdGVkX2cxX3N4LCBjLmRlbHRhLmcxX3N4KSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJTlZBTElEKCR7aX0pOiBLZXkgb2YgdGhlIGJlYWNvbiBkb2VzIG5vdCBtYXRjaC4gZzFfc3ggYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaGFzaFB1YktleShhY2N1bXVsYXRlZEhhc2hlciwgY3VydmUsIGMpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgICAgICBoYXNoUHViS2V5KGNvbnRyaWJ1dGlvbkhhc2hlciwgY3VydmUsIGMpO1xuXG4gICAgICAgIGMuY29udHJpYnV0aW9uSGFzaCA9IGNvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgICAgICBjdXJEZWx0YSA9IGMuZGVsdGFBZnRlcjtcbiAgICB9XG5cblxuICAgIGNvbnN0IHtmZDogZmRJbml0LCBzZWN0aW9uczogc2VjdGlvbnNJbml0fSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShpbml0RmlsZU5hbWUsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5SW5pdCA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkSW5pdCwgc2VjdGlvbnNJbml0LCBmYWxzZSk7XG5cbiAgICBpZiAoemtleUluaXQucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleWluaXQgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cbiAgICBpZiAoICAoIVNjYWxhci5lcSh6a2V5SW5pdC5xLCB6a2V5LnEpKVxuICAgICAgICB8fCghU2NhbGFyLmVxKHprZXlJbml0LnIsIHprZXkucikpXG4gICAgICAgIHx8KHprZXlJbml0Lm44cSAhPSB6a2V5Lm44cSlcbiAgICAgICAgfHwoemtleUluaXQubjhyICE9IHprZXkubjhyKSlcbiAgICB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBEaWZmZXJlbnQgY3VydmVzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCAgKHprZXlJbml0Lm5WYXJzICE9IHprZXkublZhcnMpXG4gICAgICAgIHx8KHprZXlJbml0Lm5QdWJsaWMgIT0gIHprZXkublB1YmxpYylcbiAgICAgICAgfHwoemtleUluaXQuZG9tYWluU2l6ZSAhPSB6a2V5LmRvbWFpblNpemUpKVxuICAgIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIERpZmZlcmVudCBjaXJjdWl0IHBhcmFtZXRlcnNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWN1cnZlLkcxLmVxKHprZXkudmtfYWxwaGFfMSwgemtleUluaXQudmtfYWxwaGFfMSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgYWxwaGExXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoemtleS52a19iZXRhXzEsIHprZXlJbml0LnZrX2JldGFfMSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgYmV0YTFcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMi5lcSh6a2V5LnZrX2JldGFfMiwgemtleUluaXQudmtfYmV0YV8yKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBiZXRhMlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKHprZXkudmtfZ2FtbWFfMiwgemtleUluaXQudmtfZ2FtbWFfMikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZ2FtbWEyXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoemtleS52a19kZWx0YV8xLCBjdXJEZWx0YSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZGVsdGExXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJ2ZS5HMS5nLCBjdXJEZWx0YSwgY3VydmUuRzIuZywgemtleS52a19kZWx0YV8yKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZGVsdGEyXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbXBjUGFyYW1zSW5pdCA9IGF3YWl0IHprZXlVdGlscy5yZWFkTVBDUGFyYW1zKGZkSW5pdCwgY3VydmUsIHNlY3Rpb25zSW5pdCk7XG4gICAgaWYgKCFtaXNjLmhhc2hJc0VxdWFsKG1wY1BhcmFtcy5jc0hhc2gsIG1wY1BhcmFtc0luaXQuY3NIYXNoKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgQ2lyY3VpdCBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHNpemVzIG9mIHNlY3Rpb25zXG4gICAgaWYgKHNlY3Rpb25zWzhdWzBdLnNpemUgIT0gc0cxKih6a2V5Lm5WYXJzLXprZXkublB1YmxpYy0xKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBMIHNlY3Rpb24gc2l6ZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzZWN0aW9uc1s5XVswXS5zaXplICE9IHNHMSooemtleS5kb21haW5TaXplKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBIIHNlY3Rpb24gc2l6ZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBzcztcbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCAzKTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJQyBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA0KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkNvZWZmcyBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA1KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkEgc2VjdGlvbiBpcyBub3QgaWRlbnRpY2FsXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMuc2VjdGlvbklzRXF1YWwoZmQsIHNlY3Rpb25zLCBmZEluaXQsIHNlY3Rpb25zSW5pdCwgNik7XG4gICAgaWYgKCFzcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJCMSBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA3KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkIyIHNlY3Rpb24gaXMgbm90IGlkZW50aWNhbFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIExcbiAgICBzciA9IGF3YWl0IHNlY3Rpb25IYXNTYW1lUmF0aW8oXCJHMVwiLCBmZEluaXQsIHNlY3Rpb25zSW5pdCwgZmQsIHNlY3Rpb25zLCA4LCB6a2V5LnZrX2RlbHRhXzIsIHprZXlJbml0LnZrX2RlbHRhXzIsIFwiTCBzZWN0aW9uXCIpO1xuICAgIGlmIChzciE9PXRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiTCBzZWN0aW9uIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgSFxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvSCgpO1xuICAgIGlmIChzciE9PXRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSCBzZWN0aW9uIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKG1wY1BhcmFtcy5jc0hhc2gsIFwiQ2lyY3VpdCBIYXNoOiBcIikpO1xuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZEluaXQuY2xvc2UoKTtcblxuICAgIGZvciAobGV0IGk9bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICBjb25zdCBjID0gbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV07XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGMuY29udHJpYnV0aW9uSGFzaCwgYGNvbnRyaWJ1dGlvbiAjJHtpKzF9ICR7Yy5uYW1lID8gYy5uYW1lIDogXCJcIn06YCkpO1xuICAgICAgICBpZiAoYy50eXBlID09IDEpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGBCZWFjb24gZ2VuZXJhdG9yOiAke21pc2MuYnl0ZUFycmF5MmhleChjLmJlYWNvbkhhc2gpfWApO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYEJlYWNvbiBpdGVyYXRpb25zIEV4cDogJHtjLm51bUl0ZXJhdGlvbnNFeHB9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJaS2V5IE9rIVwiKTtcblxuICAgIHJldHVybiB0cnVlO1xuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBzZWN0aW9uSGFzU2FtZVJhdGlvKGdyb3VwTmFtZSwgZmQxLCBzZWN0aW9uczEsIGZkMiwgc2VjdGlvbnMyLCBpZFNlY3Rpb24sIGcyc3AsIGcyc3B4LCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDE8PDIwO1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQxLCBzZWN0aW9uczEsIGlkU2VjdGlvbik7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkMiwgc2VjdGlvbnMyLCBpZFNlY3Rpb24pO1xuXG4gICAgICAgIGxldCBSMSA9IEcuemVybztcbiAgICAgICAgbGV0IFIyID0gRy56ZXJvO1xuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBzZWN0aW9uczFbaWRTZWN0aW9uXVswXS5zaXplIC8gc0c7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgU2FtZSByYXRpbyBjaGVjayAke3NlY3Rpb25OYW1lfTogICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMgLSBpLCBNQVhfQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBjb25zdCBiYXNlczEgPSBhd2FpdCBmZDEucmVhZChuKnNHKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzMiA9IGF3YWl0IGZkMi5yZWFkKG4qc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsYXJzID0gbWlzYy5nZXRSYW5kb21CeXRlcyg0Km4pO1xuXG4gICAgICAgICAgICBjb25zdCByMSA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYmFzZXMxLCBzY2FsYXJzKTtcbiAgICAgICAgICAgIGNvbnN0IHIyID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiYXNlczIsIHNjYWxhcnMpO1xuXG4gICAgICAgICAgICBSMSA9IEcuYWRkKFIxLCByMSk7XG4gICAgICAgICAgICBSMiA9IEcuYWRkKFIyLCByMik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkMSk7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZDIpO1xuXG4gICAgICAgIGlmIChuUG9pbnRzID09IDApIHJldHVybiB0cnVlO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBSMSwgUjIsIGcyc3AsIGcyc3B4KTtcbiAgICAgICAgaWYgKHNyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gc2FtZVJhdGlvSCgpIHtcbiAgICAgICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxPDwyMDtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlLkcxO1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHtmZDogZmRQVGF1LCBzZWN0aW9uczogc2VjdGlvbnNQVGF1fSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShwVGF1RmlsZU5hbWUsIFwicHRhdVwiLCAxKTtcblxuICAgICAgICBsZXQgYnVmZl9yID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiB6a2V5Lm44cik7XG5cbiAgICAgICAgY29uc3Qgc2VlZD0gbmV3IEFycmF5KDgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgICAgICBzZWVkW2ldID0gbWlzYy5yZWFkVUludDMyQkUobWlzYy5nZXRSYW5kb21CeXRlcyg0KSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm5nID0gbmV3IENoYUNoYShzZWVkKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZS0xOyBpKyspIHsgICAvLyBOb3RlIHRoYXQgbGFzdCBvbmUgaXMgemVyb1xuICAgICAgICAgICAgY29uc3QgZSA9IEZyLmZyb21Sbmcocm5nKTtcbiAgICAgICAgICAgIEZyLnRvUnByTEUoYnVmZl9yLCBpKnprZXkubjhyLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBGci50b1JwckxFKGJ1ZmZfciwgKHprZXkuZG9tYWluU2l6ZS0xKSp6a2V5Lm44ciwgRnIuemVybyk7XG5cbiAgICAgICAgbGV0IFIxID0gRy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEggVmVyaWZpY2F0aW9uKHRhdSk6ICAke2l9LyR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKHprZXkuZG9tYWluU2l6ZSAtIGksIE1BWF9DSFVOS19TSVpFKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZjEgPSBhd2FpdCBmZFBUYXUucmVhZChzRypuLCBzZWN0aW9uc1BUYXVbMl1bMF0ucCArIHprZXkuZG9tYWluU2l6ZSpzRyArIGkqc0cpO1xuICAgICAgICAgICAgY29uc3QgYnVmZjIgPSBhd2FpdCBmZFBUYXUucmVhZChzRypuLCBzZWN0aW9uc1BUYXVbMl1bMF0ucCArIGkqc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmQiA9IGF3YWl0IGJhdGNoU3VidHJhY3QoYnVmZjEsIGJ1ZmYyKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZTID0gYnVmZl9yLnNsaWNlKGkqemtleS5uOHIsIChpK24pKnprZXkubjhyKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJ1ZmZCLCBidWZmUyk7XG5cbiAgICAgICAgICAgIFIxID0gRy5hZGQoUjEsIHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG9kZCBjb2VmZmljaWVudHMgaW4gdHJhbnNmb3JtZWQgZG9tYWluXG5cbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZl9yKTtcbiAgICAgICAgLy8gY29uc3QgZmlyc3QgPSBjdXJ2ZS5Gci5uZWcoY3VydmUuRnIuaW52KGN1cnZlLkZyLmUoMikpKTtcbiAgICAgICAgLy8gV29ya3MqMiAgIGNvbnN0IGZpcnN0ID0gY3VydmUuRnIubmVnKGN1cnZlLkZyLmUoMikpO1xuXG5cbiAgICAgICAgbGV0IGZpcnN0O1xuXG4gICAgICAgIGlmICh6a2V5LnBvd2VyIDwgRnIucykge1xuICAgICAgICAgICAgZmlyc3QgPSBGci5uZWcoRnIuZSgyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzbWFsbF9tICA9IDIgKiogRnIucztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0X3RvX3NtYWxsX20gPSBGci5leHAoRnIuc2hpZnQsIHNtYWxsX20pO1xuICAgICAgICAgICAgZmlyc3QgPSBGci5zdWIoIHNoaWZ0X3RvX3NtYWxsX20sIEZyLm9uZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zdCBpbmMgPSBjdXJ2ZS5Gci5pbnYoY3VydmUuUEZyLndbemtleS5wb3dlcisxXSk7XG4gICAgICAgIGNvbnN0IGluYyA9IHprZXkucG93ZXIgPCBGci5zID8gRnIud1t6a2V5LnBvd2VyKzFdIDogRnIuc2hpZnQ7XG4gICAgICAgIGJ1ZmZfciA9IGF3YWl0IEZyLmJhdGNoQXBwbHlLZXkoYnVmZl9yLCBmaXJzdCwgaW5jKTtcbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuZmZ0KGJ1ZmZfcik7XG4gICAgICAgIGJ1ZmZfciA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoYnVmZl9yKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDkpO1xuICAgICAgICBsZXQgUjIgPSBHLnplcm87XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemU7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSCBWZXJpZmljYXRpb24obGFncmFuZ2UpOiAgJHtpfS8ke3prZXkuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbih6a2V5LmRvbWFpblNpemUgLSBpLCBNQVhfQ0hVTktfU0laRSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKHNHKm4pO1xuICAgICAgICAgICAgY29uc3QgYnVmZlMgPSBidWZmX3Iuc2xpY2UoaSp6a2V5Lm44ciwgKGkrbikqemtleS5uOHIpO1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZiwgYnVmZlMpO1xuXG4gICAgICAgICAgICBSMiA9IEcuYWRkKFIyLCByKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBSMSwgUjIsIHprZXkudmtfZGVsdGFfMiwgemtleUluaXQudmtfZGVsdGFfMik7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBiYXRjaFN1YnRyYWN0KGJ1ZmYxLCBidWZmMikge1xuICAgICAgICBjb25zdCBzRyA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGggLyBzRztcbiAgICAgICAgY29uc3QgY29uY3VycmVuY3k9IGN1cnZlLnRtLmNvbmN1cnJlbmN5O1xuICAgICAgICBjb25zdCBuUG9pbnRzUGVyVGhyZWFkID0gTWF0aC5mbG9vcihuUG9pbnRzIC8gY29uY3VycmVuY3kpO1xuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGlmIChpPCBjb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHNQZXJUaHJlYWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzIC0gaSpuUG9pbnRzUGVyVGhyZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBzdWJCdWZmMSA9IGJ1ZmYxLnNsaWNlKGkqblBvaW50c1BlclRocmVhZCpzRzEsIChpKm5Qb2ludHNQZXJUaHJlYWQrbikqc0cxKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YkJ1ZmYyID0gYnVmZjIuc2xpY2UoaSpuUG9pbnRzUGVyVGhyZWFkKnNHMSwgKGkqblBvaW50c1BlclRocmVhZCtuKSpzRzEpO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKGJhdGNoU3VidHJhY3RUaHJlYWQoc3ViQnVmZjEsIHN1YkJ1ZmYyKSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGNvbnN0IGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzRyk7XG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dC5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bGxCdWZmT3V0O1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gYmF0Y2hTdWJ0cmFjdFRocmVhZChidWZmMSwgYnVmZjIpIHtcbiAgICAgICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgICAgICBjb25zdCBzR21pZCA9IGN1cnZlLkcxLkYubjgqMztcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGgvc0cxO1xuICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYnVmZjF9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBidWZmMn0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDIsIGxlbjogblBvaW50cypzR21pZH0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICB0YXNrLnB1c2goe1xuICAgICAgICAgICAgICAgIGNtZDogXCJDQUxMXCIsXG4gICAgICAgICAgICAgICAgZm5OYW1lOiBcImcxbV9zdWJBZmZpbmVcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMCwgb2Zmc2V0OiBpKnNHMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogaSpzRzF9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAyLCBvZmZzZXQ6IGkqc0dtaWR9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcImcxbV9iYXRjaFRvQWZmaW5lXCIsIHBhcmFtczogW1xuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICB7dmFsOiBuUG9pbnRzfSxcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBuUG9pbnRzKnNHMX0pO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_verify_frominit.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snarkjs/src/zkey_verify_fromr1cs.js":
/*!**********************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_verify_fromr1cs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2verifyFromR1cs)\n/* harmony export */ });\n/* harmony import */ var _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_new.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_new.js\");\n/* harmony import */ var _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_verify_frominit.js */ \"(rsc)/./node_modules/snarkjs/src/zkey_verify_frominit.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nasync function phase2verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger) {\n\n    // const initFileName = \"~\" + zkeyFileName + \".init\";\n    const initFileName = {type: \"bigMem\"};\n    await (0,_zkey_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(r1csFileName, pTauFileName, initFileName, logger);\n\n    return await (0,_zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(initFileName, pTauFileName, zkeyFileName, logger);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV92ZXJpZnlfZnJvbXIxY3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDeUI7O0FBRTlDOztBQUVmO0FBQ0EsMEJBQTBCO0FBQzFCLFVBQVUsd0RBQU87O0FBRWpCLGlCQUFpQixvRUFBb0I7QUFDckMiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV92ZXJpZnlfZnJvbXIxY3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IG5ld1pLZXkgZnJvbSBcIi4vemtleV9uZXcuanNcIjtcbmltcG9ydCBwaGFzZTJ2ZXJpZnlGcm9tSW5pdCBmcm9tIFwiLi96a2V5X3ZlcmlmeV9mcm9taW5pdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwaGFzZTJ2ZXJpZnlGcm9tUjFjcyhyMWNzRmlsZU5hbWUsIHBUYXVGaWxlTmFtZSwgemtleUZpbGVOYW1lLCBsb2dnZXIpIHtcblxuICAgIC8vIGNvbnN0IGluaXRGaWxlTmFtZSA9IFwiflwiICsgemtleUZpbGVOYW1lICsgXCIuaW5pdFwiO1xuICAgIGNvbnN0IGluaXRGaWxlTmFtZSA9IHt0eXBlOiBcImJpZ01lbVwifTtcbiAgICBhd2FpdCBuZXdaS2V5KHIxY3NGaWxlTmFtZSwgcFRhdUZpbGVOYW1lLCBpbml0RmlsZU5hbWUsIGxvZ2dlcik7XG5cbiAgICByZXR1cm4gYXdhaXQgcGhhc2UydmVyaWZ5RnJvbUluaXQoaW5pdEZpbGVOYW1lLCBwVGF1RmlsZU5hbWUsIHprZXlGaWxlTmFtZSwgbG9nZ2VyKTtcbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snarkjs/src/zkey_verify_fromr1cs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/main.js":
/*!**************************************!*\
  !*** ./node_modules/snarkjs/main.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curves: () => (/* reexport module object */ _src_curves_js__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   fflonk: () => (/* reexport module object */ _src_fflonk_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   groth16: () => (/* reexport module object */ _src_groth16_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   plonk: () => (/* reexport module object */ _src_plonk_js__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   powersOfTau: () => (/* reexport module object */ _src_powersoftau_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   r1cs: () => (/* reexport module object */ _src_r1cs_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   wtns: () => (/* reexport module object */ _src_wtns_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   zKey: () => (/* reexport module object */ _src_zkey_js__WEBPACK_IMPORTED_MODULE_4__)\n/* harmony export */ });\n/* harmony import */ var _src_groth16_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/groth16.js */ \"(ssr)/./node_modules/snarkjs/src/groth16.js\");\n/* harmony import */ var _src_powersoftau_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/powersoftau.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau.js\");\n/* harmony import */ var _src_r1cs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/r1cs.js */ \"(ssr)/./node_modules/snarkjs/src/r1cs.js\");\n/* harmony import */ var _src_wtns_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/wtns.js */ \"(ssr)/./node_modules/snarkjs/src/wtns.js\");\n/* harmony import */ var _src_zkey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/zkey.js */ \"(ssr)/./node_modules/snarkjs/src/zkey.js\");\n/* harmony import */ var _src_plonk_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/plonk.js */ \"(ssr)/./node_modules/snarkjs/src/plonk.js\");\n/* harmony import */ var _src_fflonk_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/fflonk.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk.js\");\n/* harmony import */ var _src_curves_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9tYWluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEM7QUFDUTtBQUNkO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogYXMgZ3JvdGgxNiBmcm9tIFwiLi9zcmMvZ3JvdGgxNi5qc1wiO1xuZXhwb3J0ICogYXMgcG93ZXJzT2ZUYXUgZnJvbSBcIi4vc3JjL3Bvd2Vyc29mdGF1LmpzXCI7XG5leHBvcnQgKiBhcyByMWNzIGZyb20gXCIuL3NyYy9yMWNzLmpzXCI7XG5leHBvcnQgKiBhcyB3dG5zIGZyb20gXCIuL3NyYy93dG5zLmpzXCI7XG5leHBvcnQgKiBhcyB6S2V5IGZyb20gXCIuL3NyYy96a2V5LmpzXCI7XG5leHBvcnQgKiBhcyBwbG9uayBmcm9tIFwiLi9zcmMvcGxvbmsuanNcIjtcbmV4cG9ydCAqIGFzIGZmbG9uayBmcm9tIFwiLi9zcmMvZmZsb25rLmpzXCI7XG5leHBvcnQgKiBhcyBjdXJ2ZXMgZnJvbSBcIi4vc3JjL2N1cnZlcy5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/main.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js":
/*!****************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/main.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigBuffer: () => (/* reexport safe */ _src_bigbuffer_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   ChaCha: () => (/* reexport safe */ _src_chacha_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   EC: () => (/* reexport safe */ _src_ec_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   F1Field: () => (/* reexport safe */ _src_f1field_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   F2Field: () => (/* reexport safe */ _src_f2field_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   F3Field: () => (/* reexport safe */ _src_f3field_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   PolField: () => (/* reexport safe */ _src_polfield_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   Scalar: () => (/* binding */ Scalar),\n/* harmony export */   ZqField: () => (/* reexport safe */ _src_f1field_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   buildBls12381: () => (/* reexport safe */ _src_bls12381_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   buildBn128: () => (/* reexport safe */ _src_bn128_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   getCurveFromName: () => (/* reexport safe */ _src_curves_js__WEBPACK_IMPORTED_MODULE_11__.getCurveFromName),\n/* harmony export */   getCurveFromQ: () => (/* reexport safe */ _src_curves_js__WEBPACK_IMPORTED_MODULE_11__.getCurveFromQ),\n/* harmony export */   getCurveFromR: () => (/* reexport safe */ _src_curves_js__WEBPACK_IMPORTED_MODULE_11__.getCurveFromR),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/* harmony import */ var _src_scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _src_polfield_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/polfield.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/polfield.js\");\n/* harmony import */ var _src_f1field_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/f1field.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/f1field.js\");\n/* harmony import */ var _src_f2field_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/f2field.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/f2field.js\");\n/* harmony import */ var _src_f3field_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/f3field.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/f3field.js\");\n/* harmony import */ var _src_ec_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/ec.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/ec.js\");\n/* harmony import */ var _src_bn128_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/bn128.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js\");\n/* harmony import */ var _src_bls12381_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/bls12381.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js\");\n/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/utils.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js\");\n/* harmony import */ var _src_chacha_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/chacha.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js\");\n/* harmony import */ var _src_bigbuffer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/bigbuffer.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\");\n/* harmony import */ var _src_curves_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/curves.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/curves.js\");\n\n\nconst Scalar=_src_scalar_js__WEBPACK_IMPORTED_MODULE_0__;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst utils = _src_utils_js__WEBPACK_IMPORTED_MODULE_8__;\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L21haW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUM0QztBQUNyQyxhQUFhLDJDQUFPOztBQUUyQjtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFVjs7QUFFVztBQUNNOztBQUVsQjtBQUNsQyxjQUFjLDBDQUFNO0FBQ3VCOztBQUVNOztBQUV1QiIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCAqIGFzIF9TY2FsYXIgIGZyb20gXCIuL3NyYy9zY2FsYXIuanNcIjtcbmV4cG9ydCBjb25zdCBTY2FsYXI9X1NjYWxhcjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIFBvbEZpZWxkfSBmcm9tIFwiLi9zcmMvcG9sZmllbGQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBGMUZpZWxkfSBmcm9tIFwiLi9zcmMvZjFmaWVsZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEYyRmllbGR9IGZyb20gXCIuL3NyYy9mMmZpZWxkLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgRjNGaWVsZH0gZnJvbSBcIi4vc3JjL2YzZmllbGQuanNcIjtcblxuZXhwb3J0IHtkZWZhdWx0IGFzIFpxRmllbGR9IGZyb20gXCIuL3NyYy9mMWZpZWxkLmpzXCI7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBFQ30gZnJvbSBcIi4vc3JjL2VjLmpzXCI7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBidWlsZEJuMTI4fSBmcm9tIFwiLi9zcmMvYm4xMjguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBidWlsZEJsczEyMzgxfSBmcm9tIFwiLi9zcmMvYmxzMTIzODEuanNcIjtcblxuaW1wb3J0ICogYXMgX3V0aWxzIGZyb20gXCIuL3NyYy91dGlscy5qc1wiO1xuZXhwb3J0IGNvbnN0IHV0aWxzID0gX3V0aWxzO1xuZXhwb3J0IHtkZWZhdWx0IGFzIENoYUNoYX0gZnJvbSBcIi4vc3JjL2NoYWNoYS5qc1wiO1xuXG5leHBvcnQge2RlZmF1bHQgYXMgQmlnQnVmZmVyfSBmcm9tIFwiLi9zcmMvYmlnYnVmZmVyLmpzXCI7XG5cbmV4cG9ydCB7Z2V0Q3VydmVGcm9tUiwgZ2V0Q3VydmVGcm9tUSwgZ2V0Q3VydmVGcm9tTmFtZX0gZnJvbSBcIi4vc3JjL2N1cnZlcy5qc1wiO1xuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BigBuffer)\n/* harmony export */ });\n\nconst PAGE_SIZE = 1<<30;\n\nclass BigBuffer {\n\n    constructor(size) {\n        this.buffers = [];\n        this.byteLength = size;\n        for (let i=0; i<size; i+= PAGE_SIZE) {\n            const n = Math.min(size-i, PAGE_SIZE);\n            this.buffers.push(new Uint8Array(n));\n        }\n\n    }\n\n    slice(fr, to) {\n        if ( to === undefined ) to = this.byteLength;\n        if ( fr === undefined ) fr = 0;\n        const len = to-fr;\n\n        const firstPage = Math.floor(fr / PAGE_SIZE);\n        const lastPage = Math.floor((fr+len-1) / PAGE_SIZE);\n\n        if ((firstPage == lastPage)||(len==0))\n            return this.buffers[firstPage].slice(fr%PAGE_SIZE, fr%PAGE_SIZE + len);\n\n        let buff;\n\n        let p = firstPage;\n        let o = fr % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset+o, l);\n            if (l == len) return srcView.slice();\n            if (!buff) {\n                if (len <= PAGE_SIZE) {\n                    buff = new Uint8Array(len);\n                } else {\n                    buff = new BigBuffer(len);\n                }\n            }\n            buff.set(srcView, len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        return buff;\n    }\n\n    set(buff, offset) {\n        if (offset === undefined) offset = 0;\n\n        const len = buff.byteLength;\n\n        if (len==0) return;\n\n        const firstPage = Math.floor(offset / PAGE_SIZE);\n        const lastPage = Math.floor((offset+len-1) / PAGE_SIZE);\n\n        if (firstPage == lastPage) {\n            if ((buff instanceof BigBuffer)&&(buff.buffers.length==1)) {\n                return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);\n            } else {\n                return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);\n            }\n\n        }\n\n\n        let p = firstPage;\n        let o = offset % PAGE_SIZE;\n        let r = len;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice( len -r, len -r+l);\n            const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9iaWdidWZmZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2JpZ2J1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IFBBR0VfU0laRSA9IDE8PDMwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCaWdCdWZmZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHNpemU7IGkrPSBQQUdFX1NJWkUpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihzaXplLWksIFBBR0VfU0laRSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShuKSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHNsaWNlKGZyLCB0bykge1xuICAgICAgICBpZiAoIHRvID09PSB1bmRlZmluZWQgKSB0byA9IHRoaXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKCBmciA9PT0gdW5kZWZpbmVkICkgZnIgPSAwO1xuICAgICAgICBjb25zdCBsZW4gPSB0by1mcjtcblxuICAgICAgICBjb25zdCBmaXJzdFBhZ2UgPSBNYXRoLmZsb29yKGZyIC8gUEFHRV9TSVpFKTtcbiAgICAgICAgY29uc3QgbGFzdFBhZ2UgPSBNYXRoLmZsb29yKChmcitsZW4tMSkgLyBQQUdFX1NJWkUpO1xuXG4gICAgICAgIGlmICgoZmlyc3RQYWdlID09IGxhc3RQYWdlKXx8KGxlbj09MCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzW2ZpcnN0UGFnZV0uc2xpY2UoZnIlUEFHRV9TSVpFLCBmciVQQUdFX1NJWkUgKyBsZW4pO1xuXG4gICAgICAgIGxldCBidWZmO1xuXG4gICAgICAgIGxldCBwID0gZmlyc3RQYWdlO1xuICAgICAgICBsZXQgbyA9IGZyICUgUEFHRV9TSVpFO1xuICAgICAgICAvLyBSZW1haW5pbmcgYnl0ZXMgdG8gcmVhZFxuICAgICAgICBsZXQgciA9IGxlbjtcbiAgICAgICAgd2hpbGUgKHI+MCkge1xuICAgICAgICAgICAgLy8gYnl0ZXMgdG8gY29weSBmcm9tIHRoaXMgcGFnZVxuICAgICAgICAgICAgY29uc3QgbCA9IChvK3IgPiBQQUdFX1NJWkUpID8gKFBBR0VfU0laRSAtbykgOiByO1xuICAgICAgICAgICAgY29uc3Qgc3JjVmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyc1twXS5idWZmZXIsIHRoaXMuYnVmZmVyc1twXS5ieXRlT2Zmc2V0K28sIGwpO1xuICAgICAgICAgICAgaWYgKGwgPT0gbGVuKSByZXR1cm4gc3JjVmlldy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKCFidWZmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBQQUdFX1NJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZiA9IG5ldyBCaWdCdWZmZXIobGVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmLnNldChzcmNWaWV3LCBsZW4tcik7XG4gICAgICAgICAgICByID0gci1sO1xuICAgICAgICAgICAgcCArKztcbiAgICAgICAgICAgIG8gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfVxuXG4gICAgc2V0KGJ1ZmYsIG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIG9mZnNldCA9IDA7XG5cbiAgICAgICAgY29uc3QgbGVuID0gYnVmZi5ieXRlTGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW49PTApIHJldHVybjtcblxuICAgICAgICBjb25zdCBmaXJzdFBhZ2UgPSBNYXRoLmZsb29yKG9mZnNldCAvIFBBR0VfU0laRSk7XG4gICAgICAgIGNvbnN0IGxhc3RQYWdlID0gTWF0aC5mbG9vcigob2Zmc2V0K2xlbi0xKSAvIFBBR0VfU0laRSk7XG5cbiAgICAgICAgaWYgKGZpcnN0UGFnZSA9PSBsYXN0UGFnZSkge1xuICAgICAgICAgICAgaWYgKChidWZmIGluc3RhbmNlb2YgQmlnQnVmZmVyKSYmKGJ1ZmYuYnVmZmVycy5sZW5ndGg9PTEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyc1tmaXJzdFBhZ2VdLnNldChidWZmLmJ1ZmZlcnNbMF0sIG9mZnNldCAlIFBBR0VfU0laRSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbZmlyc3RQYWdlXS5zZXQoYnVmZiwgb2Zmc2V0ICUgUEFHRV9TSVpFKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuICAgICAgICBsZXQgcCA9IGZpcnN0UGFnZTtcbiAgICAgICAgbGV0IG8gPSBvZmZzZXQgJSBQQUdFX1NJWkU7XG4gICAgICAgIGxldCByID0gbGVuO1xuICAgICAgICB3aGlsZSAocj4wKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gKG8rciA+IFBBR0VfU0laRSkgPyAoUEFHRV9TSVpFIC1vKSA6IHI7XG4gICAgICAgICAgICBjb25zdCBzcmNWaWV3ID0gYnVmZi5zbGljZSggbGVuIC1yLCBsZW4gLXIrbCk7XG4gICAgICAgICAgICBjb25zdCBkc3RWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXJzW3BdLmJ1ZmZlciwgdGhpcy5idWZmZXJzW3BdLmJ5dGVPZmZzZXQgKyBvLCBsKTtcbiAgICAgICAgICAgIGRzdFZpZXcuc2V0KHNyY1ZpZXcpO1xuICAgICAgICAgICAgciA9IHItbDtcbiAgICAgICAgICAgIHAgKys7XG4gICAgICAgICAgICBvID0gMDtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js":
/*!************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildBls12381)\n/* harmony export */ });\n/* harmony import */ var wasmcurves__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wasmcurves */ \"(ssr)/./node_modules/wasmcurves/index.js\");\n/* harmony import */ var _engine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var wasmbuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wasmbuilder */ \"(ssr)/./node_modules/wasmbuilder/main.js\");\n\n\n\n\n\nglobalThis.curve_bls12381 = null;\n\nasync function buildBls12381(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bls12381)) return globalThis.curve_bls12381;\n\n    const moduleBuilder = new wasmbuilder__WEBPACK_IMPORTED_MODULE_3__.ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    (0,wasmcurves__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bls12381wasm = {};\n\n    bls12381wasm.code = moduleBuilder.build();\n    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;\n    bls12381wasm.pr = moduleBuilder.modules.frm.pq;\n    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;\n    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;\n    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;\n    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;\n    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;\n    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;\n    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;\n    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;\n    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;\n    bls12381wasm.n8q = 48;\n    bls12381wasm.n8r = 32;\n    bls12381wasm.q = moduleBuilder.modules.bls12381.q;\n    bls12381wasm.r = moduleBuilder.modules.bls12381.r;\n\n\n    const params = {\n        name: \"bls12381\",\n        wasm: bls12381wasm,\n        q: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16),\n        r: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16),\n        n8q: 48,\n        n8r: 32,\n        cofactorG1: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"0x396c8c005555e1568c00aaab0000aaab\", 16),\n        cofactorG2: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await (0,_engine_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bls12381 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bls12381 = curve;\n    }\n\n    return curve;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9ibHMxMjM4MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnRTtBQUMxQjtBQUNBO0FBQ007O0FBRTVDOztBQUVlO0FBQ2Y7O0FBRUEsOEJBQThCLHNEQUFhO0FBQzNDO0FBQ0EsSUFBSSx5REFBaUI7O0FBRXJCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUFRO0FBQ25CLFdBQVcseUNBQVE7QUFDbkI7QUFDQTtBQUNBLG9CQUFvQix5Q0FBUTtBQUM1QixvQkFBb0IseUNBQVE7QUFDNUI7QUFDQTs7QUFFQSx3QkFBd0Isc0RBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvYmxzMTIzODEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnVpbGRCbHMxMjM4MSBhcyBidWlsZEJsczEyMzgxd2FzbSB9IGZyb20gXCJ3YXNtY3VydmVzXCI7XG5pbXBvcnQgYnVpbGRFbmdpbmUgZnJvbSBcIi4vZW5naW5lLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5pbXBvcnQgeyBNb2R1bGVCdWlsZGVyIH0gZnJvbSBcIndhc21idWlsZGVyXCI7XG5cbmdsb2JhbFRoaXMuY3VydmVfYmxzMTIzODEgPSBudWxsO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGlmICgoIXNpbmdsZVRocmVhZCkgJiYgKGdsb2JhbFRoaXMuY3VydmVfYmxzMTIzODEpKSByZXR1cm4gZ2xvYmFsVGhpcy5jdXJ2ZV9ibHMxMjM4MTtcblxuICAgIGNvbnN0IG1vZHVsZUJ1aWxkZXIgPSBuZXcgTW9kdWxlQnVpbGRlcigpO1xuICAgIG1vZHVsZUJ1aWxkZXIuc2V0TWVtb3J5KDI1KTtcbiAgICBidWlsZEJsczEyMzgxd2FzbShtb2R1bGVCdWlsZGVyKTtcblxuICAgIGlmIChwbHVnaW5zKSBwbHVnaW5zKG1vZHVsZUJ1aWxkZXIpO1xuXG4gICAgY29uc3QgYmxzMTIzODF3YXNtID0ge307XG5cbiAgICBibHMxMjM4MXdhc20uY29kZSA9IG1vZHVsZUJ1aWxkZXIuYnVpbGQoKTtcbiAgICBibHMxMjM4MXdhc20ucHEgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuZjFtLnBxO1xuICAgIGJsczEyMzgxd2FzbS5wciA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5mcm0ucHE7XG4gICAgYmxzMTIzODF3YXNtLnBHMWdlbiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wRzFnZW47XG4gICAgYmxzMTIzODF3YXNtLnBHMXplcm8gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucEcxemVybztcbiAgICBibHMxMjM4MXdhc20ucEcxYiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wRzFiO1xuICAgIGJsczEyMzgxd2FzbS5wRzJnZW4gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucEcyZ2VuO1xuICAgIGJsczEyMzgxd2FzbS5wRzJ6ZXJvID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnBHMnplcm87XG4gICAgYmxzMTIzODF3YXNtLnBHMmIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucEcyYjtcbiAgICBibHMxMjM4MXdhc20ucE9uZVQgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucE9uZVQ7XG4gICAgYmxzMTIzODF3YXNtLnByZVBTaXplID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnByZVBTaXplO1xuICAgIGJsczEyMzgxd2FzbS5wcmVRU2l6ZSA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wcmVRU2l6ZTtcbiAgICBibHMxMjM4MXdhc20ubjhxID0gNDg7XG4gICAgYmxzMTIzODF3YXNtLm44ciA9IDMyO1xuICAgIGJsczEyMzgxd2FzbS5xID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnE7XG4gICAgYmxzMTIzODF3YXNtLnIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucjtcblxuXG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBuYW1lOiBcImJsczEyMzgxXCIsXG4gICAgICAgIHdhc206IGJsczEyMzgxd2FzbSxcbiAgICAgICAgcTogU2NhbGFyLmUoXCIxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJcIiwgMTYpLFxuICAgICAgICByOiBTY2FsYXIuZShcIjczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDFcIiwgMTYpLFxuICAgICAgICBuOHE6IDQ4LFxuICAgICAgICBuOHI6IDMyLFxuICAgICAgICBjb2ZhY3RvckcxOiBTY2FsYXIuZShcIjB4Mzk2YzhjMDA1NTU1ZTE1NjhjMDBhYWFiMDAwMGFhYWJcIiwgMTYpLFxuICAgICAgICBjb2ZhY3RvckcyOiBTY2FsYXIuZShcIjB4NWQ1NDNhOTU0MTRlN2YxMDkxZDUwNzkyODc2YTIwMmNkOTFkZTQ1NDcwODVhYmFhNjhhMjA1YjJlNWE3ZGRmYTYyOGYxY2I0ZDllODJlZjIxNTM3ZTI5M2E2NjkxYWUxNjE2ZWM2ZTc4NmYwYzcwY2YxYzM4ZTMxYzcyMzhlNVwiLCAxNiksXG4gICAgICAgIHNpbmdsZVRocmVhZDogc2luZ2xlVGhyZWFkID8gdHJ1ZSA6IGZhbHNlXG4gICAgfTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgYnVpbGRFbmdpbmUocGFyYW1zKTtcbiAgICBjdXJ2ZS50ZXJtaW5hdGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcGFyYW1zLnNpbmdsZVRocmVhZCkge1xuICAgICAgICAgICAgZ2xvYmFsVGhpcy5jdXJ2ZV9ibHMxMjM4MSA9IG51bGw7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRtLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICghc2luZ2xlVGhyZWFkKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuY3VydmVfYmxzMTIzODEgPSBjdXJ2ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildBn128)\n/* harmony export */ });\n/* harmony import */ var wasmcurves__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wasmcurves */ \"(ssr)/./node_modules/wasmcurves/index.js\");\n/* harmony import */ var _engine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var wasmbuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wasmbuilder */ \"(ssr)/./node_modules/wasmbuilder/main.js\");\n\n\n\n\n\nglobalThis.curve_bn128 = null;\n\nasync function buildBn128(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bn128)) return globalThis.curve_bn128;\n\n    const moduleBuilder = new wasmbuilder__WEBPACK_IMPORTED_MODULE_3__.ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    (0,wasmcurves__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bn128wasm = {};\n\n    bn128wasm.code = moduleBuilder.build();\n    bn128wasm.pq = moduleBuilder.modules.f1m.pq;\n    bn128wasm.pr = moduleBuilder.modules.frm.pq;\n    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;\n    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;\n    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;\n    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;\n    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;\n    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;\n    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;\n    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;\n    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;\n    bn128wasm.n8q = 32;\n    bn128wasm.n8r = 32;\n    bn128wasm.q = moduleBuilder.modules.bn128.q;\n    bn128wasm.r = moduleBuilder.modules.bn128.r;\n\n    const params = {\n        name: \"bn128\",\n        wasm: bn128wasm,\n        q: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\"),\n        r: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\"),\n        n8q: 32,\n        n8r: 32,\n        cofactorG2: _scalar_js__WEBPACK_IMPORTED_MODULE_2__.e(\"30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await (0,_engine_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bn128 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bn128 = curve;\n    }\n\n    return curve;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9ibjEyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwRDtBQUNwQjtBQUNBO0FBQ007O0FBRTVDOztBQUVlO0FBQ2Y7O0FBRUEsOEJBQThCLHNEQUFhO0FBQzNDO0FBQ0EsSUFBSSxzREFBYzs7QUFFbEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBUTtBQUNuQixXQUFXLHlDQUFRO0FBQ25CO0FBQ0E7QUFDQSxvQkFBb0IseUNBQVE7QUFDNUI7QUFDQTs7QUFFQSx3QkFBd0Isc0RBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvYm4xMjguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnVpbGRCbjEyOCBhcyBidWlsZEJuMTI4d2FzbSB9IGZyb20gXCJ3YXNtY3VydmVzXCI7XG5pbXBvcnQgYnVpbGRFbmdpbmUgZnJvbSBcIi4vZW5naW5lLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5pbXBvcnQgeyBNb2R1bGVCdWlsZGVyIH0gZnJvbSBcIndhc21idWlsZGVyXCI7XG5cbmdsb2JhbFRoaXMuY3VydmVfYm4xMjggPSBudWxsO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGlmICgoIXNpbmdsZVRocmVhZCkgJiYgKGdsb2JhbFRoaXMuY3VydmVfYm4xMjgpKSByZXR1cm4gZ2xvYmFsVGhpcy5jdXJ2ZV9ibjEyODtcblxuICAgIGNvbnN0IG1vZHVsZUJ1aWxkZXIgPSBuZXcgTW9kdWxlQnVpbGRlcigpO1xuICAgIG1vZHVsZUJ1aWxkZXIuc2V0TWVtb3J5KDI1KTtcbiAgICBidWlsZEJuMTI4d2FzbShtb2R1bGVCdWlsZGVyKTtcblxuICAgIGlmIChwbHVnaW5zKSBwbHVnaW5zKG1vZHVsZUJ1aWxkZXIpO1xuXG4gICAgY29uc3QgYm4xMjh3YXNtID0ge307XG5cbiAgICBibjEyOHdhc20uY29kZSA9IG1vZHVsZUJ1aWxkZXIuYnVpbGQoKTtcbiAgICBibjEyOHdhc20ucHEgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuZjFtLnBxO1xuICAgIGJuMTI4d2FzbS5wciA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5mcm0ucHE7XG4gICAgYm4xMjh3YXNtLnBHMWdlbiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5wRzFnZW47XG4gICAgYm4xMjh3YXNtLnBHMXplcm8gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucEcxemVybztcbiAgICBibjEyOHdhc20ucEcxYiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5wRzFiO1xuICAgIGJuMTI4d2FzbS5wRzJnZW4gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucEcyZ2VuO1xuICAgIGJuMTI4d2FzbS5wRzJ6ZXJvID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnBHMnplcm87XG4gICAgYm4xMjh3YXNtLnBHMmIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucEcyYjtcbiAgICBibjEyOHdhc20ucE9uZVQgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucE9uZVQ7XG4gICAgYm4xMjh3YXNtLnByZVBTaXplID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnByZVBTaXplO1xuICAgIGJuMTI4d2FzbS5wcmVRU2l6ZSA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5wcmVRU2l6ZTtcbiAgICBibjEyOHdhc20ubjhxID0gMzI7XG4gICAgYm4xMjh3YXNtLm44ciA9IDMyO1xuICAgIGJuMTI4d2FzbS5xID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnE7XG4gICAgYm4xMjh3YXNtLnIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucjtcblxuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgbmFtZTogXCJibjEyOFwiLFxuICAgICAgICB3YXNtOiBibjEyOHdhc20sXG4gICAgICAgIHE6IFNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg2OTYzMTExNTcyOTc4MjM2NjI2ODkwMzc4OTQ2NDUyMjYyMDg1ODNcIiksXG4gICAgICAgIHI6IFNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIiksXG4gICAgICAgIG44cTogMzIsXG4gICAgICAgIG44cjogMzIsXG4gICAgICAgIGNvZmFjdG9yRzI6IFNjYWxhci5lKFwiMzA2NDRlNzJlMTMxYTAyOWI4NTA0NWI2ODE4MTU4NWUwNmNlZWNkYTU3MmEyNDg5MzQ1ZjIyOTljMGY5ZmE4ZFwiLCAxNiksXG4gICAgICAgIHNpbmdsZVRocmVhZDogc2luZ2xlVGhyZWFkID8gdHJ1ZSA6IGZhbHNlXG4gICAgfTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgYnVpbGRFbmdpbmUocGFyYW1zKTtcbiAgICBjdXJ2ZS50ZXJtaW5hdGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcGFyYW1zLnNpbmdsZVRocmVhZCkge1xuICAgICAgICAgICAgZ2xvYmFsVGhpcy5jdXJ2ZV9ibjEyOCA9IG51bGw7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRtLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICghc2luZ2xlVGhyZWFkKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuY3VydmVfYm4xMjggPSBjdXJ2ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChaCha)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n\n\n\n\n\nfunction quarterRound(st, a, b, c, d) {\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 16) | ((st[d]>>>16) & 0xFFFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 12) | ((st[b]>>>20) & 0xFFF)) >>> 0;\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 8) | ((st[d]>>>24) & 0xFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 7) | ((st[b]>>>25) & 0x7F)) >>> 0;\n}\n\nfunction doubleRound(st) {\n    quarterRound(st, 0, 4, 8,12);\n    quarterRound(st, 1, 5, 9,13);\n    quarterRound(st, 2, 6,10,14);\n    quarterRound(st, 3, 7,11,15);\n\n    quarterRound(st, 0, 5,10,15);\n    quarterRound(st, 1, 6,11,12);\n    quarterRound(st, 2, 7, 8,13);\n    quarterRound(st, 3, 4, 9,14);\n}\n\nclass ChaCha {\n\n    constructor(seed) {\n        seed = seed || [0,0,0,0,0,0,0,0];\n        this.state = [\n            0x61707865,\n            0x3320646E,\n            0x79622D32,\n            0x6B206574,\n            seed[0],\n            seed[1],\n            seed[2],\n            seed[3],\n            seed[4],\n            seed[5],\n            seed[6],\n            seed[7],\n            0,\n            0,\n            0,\n            0\n        ];\n        this.idx = 16;\n        this.buff = new Array(16);\n    }\n\n    nextU32() {\n        if (this.idx == 16) this.update();\n        return this.buff[this.idx++];\n    }\n\n    nextU64() {\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.add(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mul(this.nextU32(), 0x100000000), this.nextU32());\n    }\n\n    nextBool() {\n        return (this.nextU32() & 1) == 1;\n    }\n\n    update() {\n        // Copy the state\n        for (let i=0; i<16; i++) this.buff[i] = this.state[i];\n\n        // Apply the rounds\n        for (let i=0; i<10; i++) doubleRound(this.buff);\n\n        // Add to the initial\n        for (let i=0; i<16; i++) this.buff[i] = (this.buff[i] + this.state[i]) >>> 0;\n\n        this.idx = 0;\n\n        this.state[12] = (this.state[12] + 1) >>> 0;\n        if (this.state[12] != 0) return;\n        this.state[13] = (this.state[13] + 1) >>> 0;\n        if (this.state[13] != 0) return;\n        this.state[14] = (this.state[14] + 1) >>> 0;\n        if (this.state[14] != 0) return;\n        this.state[15] = (this.state[15] + 1) >>> 0;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9jaGFjaGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVzQzs7O0FBR3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyQ0FBVSxDQUFDLDJDQUFVO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07O0FBRTVCO0FBQ0Esc0JBQXNCLE1BQU07O0FBRTVCO0FBQ0Esc0JBQXNCLE1BQU07O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2NoYWNoYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0ICogYXMgU2NhbGFyIGZyb20gXCIuL3NjYWxhci5qc1wiO1xuXG5cbmZ1bmN0aW9uIHF1YXJ0ZXJSb3VuZChzdCwgYSwgYiwgYywgZCkge1xuXG4gICAgc3RbYV0gPSAoc3RbYV0gKyBzdFtiXSkgPj4+IDA7XG4gICAgc3RbZF0gPSAoc3RbZF0gXiBzdFthXSkgPj4+IDA7XG4gICAgc3RbZF0gPSAoKHN0W2RdIDw8IDE2KSB8ICgoc3RbZF0+Pj4xNikgJiAweEZGRkYpKSA+Pj4gMDtcblxuICAgIHN0W2NdID0gKHN0W2NdICsgc3RbZF0pID4+PiAwO1xuICAgIHN0W2JdID0gKHN0W2JdIF4gc3RbY10pID4+PiAwO1xuICAgIHN0W2JdID0gKChzdFtiXSA8PCAxMikgfCAoKHN0W2JdPj4+MjApICYgMHhGRkYpKSA+Pj4gMDtcblxuICAgIHN0W2FdID0gKHN0W2FdICsgc3RbYl0pID4+PiAwO1xuICAgIHN0W2RdID0gKHN0W2RdIF4gc3RbYV0pID4+PiAwO1xuICAgIHN0W2RdID0gKChzdFtkXSA8PCA4KSB8ICgoc3RbZF0+Pj4yNCkgJiAweEZGKSkgPj4+IDA7XG5cbiAgICBzdFtjXSA9IChzdFtjXSArIHN0W2RdKSA+Pj4gMDtcbiAgICBzdFtiXSA9IChzdFtiXSBeIHN0W2NdKSA+Pj4gMDtcbiAgICBzdFtiXSA9ICgoc3RbYl0gPDwgNykgfCAoKHN0W2JdPj4+MjUpICYgMHg3RikpID4+PiAwO1xufVxuXG5mdW5jdGlvbiBkb3VibGVSb3VuZChzdCkge1xuICAgIHF1YXJ0ZXJSb3VuZChzdCwgMCwgNCwgOCwxMik7XG4gICAgcXVhcnRlclJvdW5kKHN0LCAxLCA1LCA5LDEzKTtcbiAgICBxdWFydGVyUm91bmQoc3QsIDIsIDYsMTAsMTQpO1xuICAgIHF1YXJ0ZXJSb3VuZChzdCwgMywgNywxMSwxNSk7XG5cbiAgICBxdWFydGVyUm91bmQoc3QsIDAsIDUsMTAsMTUpO1xuICAgIHF1YXJ0ZXJSb3VuZChzdCwgMSwgNiwxMSwxMik7XG4gICAgcXVhcnRlclJvdW5kKHN0LCAyLCA3LCA4LDEzKTtcbiAgICBxdWFydGVyUm91bmQoc3QsIDMsIDQsIDksMTQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFDaGEge1xuXG4gICAgY29uc3RydWN0b3Ioc2VlZCkge1xuICAgICAgICBzZWVkID0gc2VlZCB8fCBbMCwwLDAsMCwwLDAsMCwwXTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFtcbiAgICAgICAgICAgIDB4NjE3MDc4NjUsXG4gICAgICAgICAgICAweDMzMjA2NDZFLFxuICAgICAgICAgICAgMHg3OTYyMkQzMixcbiAgICAgICAgICAgIDB4NkIyMDY1NzQsXG4gICAgICAgICAgICBzZWVkWzBdLFxuICAgICAgICAgICAgc2VlZFsxXSxcbiAgICAgICAgICAgIHNlZWRbMl0sXG4gICAgICAgICAgICBzZWVkWzNdLFxuICAgICAgICAgICAgc2VlZFs0XSxcbiAgICAgICAgICAgIHNlZWRbNV0sXG4gICAgICAgICAgICBzZWVkWzZdLFxuICAgICAgICAgICAgc2VlZFs3XSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5pZHggPSAxNjtcbiAgICAgICAgdGhpcy5idWZmID0gbmV3IEFycmF5KDE2KTtcbiAgICB9XG5cbiAgICBuZXh0VTMyKCkge1xuICAgICAgICBpZiAodGhpcy5pZHggPT0gMTYpIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZbdGhpcy5pZHgrK107XG4gICAgfVxuXG4gICAgbmV4dFU2NCgpIHtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5hZGQoU2NhbGFyLm11bCh0aGlzLm5leHRVMzIoKSwgMHgxMDAwMDAwMDApLCB0aGlzLm5leHRVMzIoKSk7XG4gICAgfVxuXG4gICAgbmV4dEJvb2woKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5uZXh0VTMyKCkgJiAxKSA9PSAxO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gQ29weSB0aGUgc3RhdGVcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDE2OyBpKyspIHRoaXMuYnVmZltpXSA9IHRoaXMuc3RhdGVbaV07XG5cbiAgICAgICAgLy8gQXBwbHkgdGhlIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8MTA7IGkrKykgZG91YmxlUm91bmQodGhpcy5idWZmKTtcblxuICAgICAgICAvLyBBZGQgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDE2OyBpKyspIHRoaXMuYnVmZltpXSA9ICh0aGlzLmJ1ZmZbaV0gKyB0aGlzLnN0YXRlW2ldKSA+Pj4gMDtcblxuICAgICAgICB0aGlzLmlkeCA9IDA7XG5cbiAgICAgICAgdGhpcy5zdGF0ZVsxMl0gPSAodGhpcy5zdGF0ZVsxMl0gKyAxKSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVbMTJdICE9IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZVsxM10gPSAodGhpcy5zdGF0ZVsxM10gKyAxKSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVbMTNdICE9IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZVsxNF0gPSAodGhpcy5zdGF0ZVsxNF0gKyAxKSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVbMTRdICE9IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGF0ZVsxNV0gPSAodGhpcy5zdGF0ZVsxNV0gKyAxKSA+Pj4gMDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/curves.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/curves.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurveFromName: () => (/* binding */ getCurveFromName),\n/* harmony export */   getCurveFromQ: () => (/* binding */ getCurveFromQ),\n/* harmony export */   getCurveFromR: () => (/* binding */ getCurveFromR)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _bn128_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bn128.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bn128.js\");\n/* harmony import */ var _bls12381_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bls12381.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bls12381.js\");\n\n\n\n\nconst bls12381r = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nasync function getCurveFromR(r, singleThread, plugins) {\n    let curve;\n    if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(r, bn128r)) {\n        curve = await (0,_bn128_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(singleThread, plugins);\n    } else if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(r, bls12381r)) {\n        curve = await (0,_bls12381_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${_scalar_js__WEBPACK_IMPORTED_MODULE_0__.toString(r)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromQ(q, singleThread, plugins) {\n    let curve;\n    if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(q, bn128q)) {\n        curve = await (0,_bn128_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(singleThread, plugins);\n    } else if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(q, bls12381q)) {\n        curve = await (0,_bls12381_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${_scalar_js__WEBPACK_IMPORTED_MODULE_0__.toString(q, 16)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromName(name, singleThread, plugins) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await (0,_bn128_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(singleThread, plugins);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await (0,_bls12381_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9jdXJ2ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNDO0FBQ1c7QUFDTTs7QUFFdkQsa0JBQWtCLHlDQUFRO0FBQzFCLGVBQWUseUNBQVE7O0FBRXZCLGtCQUFrQix5Q0FBUTtBQUMxQixlQUFlLHlDQUFROztBQUVoQjtBQUNQO0FBQ0EsUUFBUSwwQ0FBUztBQUNqQixzQkFBc0IscURBQVU7QUFDaEMsTUFBTSxTQUFTLDBDQUFTO0FBQ3hCLHNCQUFzQix3REFBYTtBQUNuQyxNQUFNO0FBQ04sZ0RBQWdELGdEQUFlLElBQUk7QUFDbkU7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxRQUFRLDBDQUFTO0FBQ2pCLHNCQUFzQixxREFBVTtBQUNoQyxNQUFNLFNBQVMsMENBQVM7QUFDeEIsc0JBQXNCLHdEQUFhO0FBQ25DLE1BQU07QUFDTixnREFBZ0QsZ0RBQWUsUUFBUTtBQUN2RTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEMsTUFBTTtBQUNOLHNCQUFzQix3REFBYTtBQUNuQyxNQUFNO0FBQ04sZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9jdXJ2ZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgU2NhbGFyIGZyb20gXCIuL3NjYWxhci5qc1wiO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGJ1aWxkQm4xMjh9IGZyb20gXCIuL2JuMTI4LmpzXCI7XG5pbXBvcnQge2RlZmF1bHQgYXMgYnVpbGRCbHMxMjM4MX0gZnJvbSBcIi4vYmxzMTIzODEuanNcIjtcblxuY29uc3QgYmxzMTIzODFyID0gU2NhbGFyLmUoXCI3M2VkYTc1MzI5OWQ3ZDQ4MzMzOWQ4MDgwOWExZDgwNTUzYmRhNDAyZmZmZTViZmVmZmZmZmZmZjAwMDAwMDAxXCIsIDE2KTtcbmNvbnN0IGJuMTI4ciA9IFNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIik7XG5cbmNvbnN0IGJsczEyMzgxcSA9IFNjYWxhci5lKFwiMWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiXCIsIDE2KTtcbmNvbnN0IGJuMTI4cSA9IFNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg2OTYzMTExNTcyOTc4MjM2NjI2ODkwMzc4OTQ2NDUyMjYyMDg1ODNcIik7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDdXJ2ZUZyb21SKHIsIHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGxldCBjdXJ2ZTtcbiAgICBpZiAoU2NhbGFyLmVxKHIsIGJuMTI4cikpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCwgcGx1Z2lucyk7XG4gICAgfSBlbHNlIGlmIChTY2FsYXIuZXEociwgYmxzMTIzODFyKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQmxzMTIzODEoc2luZ2xlVGhyZWFkLCBwbHVnaW5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN1cnZlIG5vdCBzdXBwb3J0ZWQ6ICR7U2NhbGFyLnRvU3RyaW5nKHIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDdXJ2ZUZyb21RKHEsIHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGxldCBjdXJ2ZTtcbiAgICBpZiAoU2NhbGFyLmVxKHEsIGJuMTI4cSkpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCwgcGx1Z2lucyk7XG4gICAgfSBlbHNlIGlmIChTY2FsYXIuZXEocSwgYmxzMTIzODFxKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQmxzMTIzODEoc2luZ2xlVGhyZWFkLCBwbHVnaW5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN1cnZlIG5vdCBzdXBwb3J0ZWQ6ICR7U2NhbGFyLnRvU3RyaW5nKHEsIDE2KX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VydmVGcm9tTmFtZShuYW1lLCBzaW5nbGVUaHJlYWQsIHBsdWdpbnMpIHtcbiAgICBsZXQgY3VydmU7XG4gICAgY29uc3Qgbm9ybU5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIGlmIChbXCJCTjEyOFwiLCBcIkJOMjU0XCIsIFwiQUxUQk4xMjhcIl0uaW5kZXhPZihub3JtTmFtZSkgPj0gMCkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQm4xMjgoc2luZ2xlVGhyZWFkLCBwbHVnaW5zKTtcbiAgICB9IGVsc2UgaWYgKFtcIkJMUzEyMzgxXCJdLmluZGV4T2Yobm9ybU5hbWUpID49IDApIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCwgcGx1Z2lucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2ZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobikge1xuICAgICAgICByZXR1cm4gbi50b1VwcGVyQ2FzZSgpLm1hdGNoKC9bQS1aYS16MC05XSsvZykuam9pbihcIlwiKTtcbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/curves.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/ec.js":
/*!******************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/ec.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EC)\n/* harmony export */ });\n/* harmony import */ var _futils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./futils.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nfunction isGreatest(F, a) {\n    if (Array.isArray(a)) {\n        for (let i=a.length-1; i>=0; i--) {\n            if (!F.F.isZero(a[i])) {\n                return isGreatest(F.F, a[i]);\n            }\n        }\n        return 0;\n    } else {\n        const na = F.neg(a);\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_1__.gt(a, na);\n    }\n}\n\n\nclass EC {\n\n    constructor(F, g) {\n        this.F = F;\n        this.g = g;\n        if (this.g.length == 2) this.g[2] = this.F.one;\n        this.zero = [this.F.zero, this.F.one, this.F.zero];\n    }\n\n    add(p1, p2) {\n\n        const F = this.F;\n\n        if (this.eq(p1, this.zero)) return p2;\n        if (this.eq(p2, this.zero)) return p1;\n\n        const res = new Array(3);\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );     // U1 = X1  * Z2Z2\n        const U2 = F.mul( p2[0] , Z1Z1 );     // U2 = X2  * Z1Z1\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);  // S1 = Y1 * Z2 * Z2Z2\n        const S2 = F.mul( p2[1] , Z1_cubed);  // S2 = Y2 * Z1 * Z1Z1\n\n        if (F.eq(U1,U2) && F.eq(S1,S2)) {\n            return this.double(p1);\n        }\n\n        const H = F.sub( U2 , U1 );                    // H = U2-U1\n\n        const S2_minus_S1 = F.sub( S2 , S1 );\n\n        const I = F.square( F.add(H,H) );         // I = (2 * H)^2\n        const J = F.mul( H , I );                      // J = H * I\n\n        const r = F.add( S2_minus_S1 , S2_minus_S1 );  // r = 2 * (S2-S1)\n        const V = F.mul( U1 , I );                     // V = U1 * I\n\n        res[0] =\n            F.sub(\n                F.sub( F.square(r) , J ),\n                F.add( V , V ));                       // X3 = r^2 - J - 2 * V\n\n        const S1_J = F.mul( S1 , J );\n\n        res[1] =\n            F.sub(\n                F.mul( r , F.sub(V,res[0])),\n                F.add( S1_J,S1_J ));                   // Y3 = r * (V-X3)-2 S1 J\n\n        res[2] =\n            F.mul(\n                H,\n                F.sub(\n                    F.square( F.add(p1[2],p2[2]) ),\n                    F.add( Z1Z1 , Z2Z2 )));            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2) * H\n\n        return res;\n    }\n\n    neg(p) {\n        return [p[0], this.F.neg(p[1]), p[2]];\n    }\n\n    sub(a, b) {\n        return this.add(a, this.neg(b));\n    }\n\n    double(p) {\n        const F = this.F;\n\n        const res = new Array(3);\n\n        if (this.eq(p, this.zero)) return p;\n\n        const A = F.square( p[0] );                    // A = X1^2\n        const B = F.square( p[1] );                    // B = Y1^2\n        const C = F.square( B );                       // C = B^2\n\n        let D =\n            F.sub(\n                F.square( F.add(p[0] , B )),\n                F.add( A , C));\n        D = F.add(D,D);                    // D = 2 * ((X1 + B)^2 - A - C)\n\n        const E = F.add( F.add(A,A), A);          // E = 3 * A\n        const FF =F.square( E );                       // F = E^2\n\n        res[0] = F.sub( FF , F.add(D,D) );         // X3 = F - 2 D\n\n        let eightC = F.add( C , C );\n        eightC = F.add( eightC , eightC );\n        eightC = F.add( eightC , eightC );\n\n        res[1] =\n            F.sub(\n                F.mul(\n                    E,\n                    F.sub( D, res[0] )),\n                eightC);                                    // Y3 = E * (D - X3) - 8 * C\n\n        const Y1Z1 = F.mul( p[1] , p[2] );\n        res[2] = F.add( Y1Z1 , Y1Z1 );                 // Z3 = 2 * Y1 * Z1\n\n        return res;\n    }\n\n    timesScalar(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.mulScalar(this, base, e);\n    }\n\n    mulScalar(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.mulScalar(this, base, e);\n    }\n\n    affine(p) {\n        const F = this.F;\n        if (this.isZero(p)) {\n            return this.zero;\n        } else if (F.eq(p[2], F.one)) {\n            return p;\n        } else {\n            const Z_inv = F.inv(p[2]);\n            const Z2_inv = F.square(Z_inv);\n            const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n            const res = new Array(3);\n            res[0] = F.mul(p[0],Z2_inv);\n            res[1] = F.mul(p[1],Z3_inv);\n            res[2] = F.one;\n\n            return res;\n        }\n    }\n\n    multiAffine(arr) {\n        const keys = Object.keys(arr);\n        const F = this.F;\n        const accMul = new Array(keys.length+1);\n        accMul[0] = F.one;\n        for (let i = 0; i< keys.length; i++) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i+1] = accMul[i];\n            } else {\n                accMul[i+1] = F.mul(accMul[i], arr[keys[i]][2]);\n            }\n        }\n\n        accMul[keys.length] = F.inv(accMul[keys.length]);\n\n        for (let i = keys.length-1; i>=0; i--) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i] = accMul[i+1];\n                arr[keys[i]] = this.zero;\n            } else {\n                const Z_inv = F.mul(accMul[i], accMul[i+1]);\n                accMul[i] = F.mul(arr[keys[i]][2], accMul[i+1]);\n\n                const Z2_inv = F.square(Z_inv);\n                const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n                arr[keys[i]][0] = F.mul(arr[keys[i]][0],Z2_inv);\n                arr[keys[i]][1] = F.mul(arr[keys[i]][1],Z3_inv);\n                arr[keys[i]][2] = F.one;\n            }\n        }\n\n    }\n\n    eq(p1, p2) {\n        const F = this.F;\n\n        if (this.F.eq(p1[2], this.F.zero)) return this.F.eq(p2[2], this.F.zero);\n        if (this.F.eq(p2[2], this.F.zero)) return false;\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );\n        const U2 = F.mul( p2[0] , Z1Z1 );\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);\n        const S2 = F.mul( p2[1] , Z1_cubed);\n\n        return (F.eq(U1,U2) && F.eq(S1,S2));\n    }\n\n    isZero(p) {\n        return this.F.isZero(p[2]);\n    }\n\n    toString(p) {\n        const cp = this.affine(p);\n        return `[ ${this.F.toString(cp[0])} , ${this.F.toString(cp[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n            P[1] = F.sqrt(x3b);\n        } while ((P[1] == null)||(F.isZero[P]));\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        if (this.cofactor) {\n            P = this.mulScalar(P, this.cofactor);\n        }\n\n        P = this.affine(P);\n\n        return P;\n\n    }\n\n    toRprLE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLE(buff, o, p[0]);\n        this.F.toRprLE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprBE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n        this.F.toRprBE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEJM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n        this.F.toRprLEM(buff, o+2*this.F.n8, p[2]);\n    }\n\n\n    toRprBEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBEM(buff, o, p[0]);\n        this.F.toRprBEM(buff, o+this.F.n8, p[1]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLE(buff, o);\n        const y = this.F.fromRprLE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBE(buff, o);\n        const y = this.F.fromRprBE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEJM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        const z = this.F.fromRprLEM(buff, o+this.F.n8*2);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, z];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBEM(buff, o);\n        const y = this.F.fromRprBEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprCompressed(buff, o) {\n        const F = this.F;\n        const v = new Uint8Array(buff.buffer, o, F.n8);\n        if (v[0] & 0x40) return this.zero;\n        const P = new Array(3);\n\n        const greatest = ((v[0] & 0x80) != 0);\n        v[0] = v[0] & 0x7F;\n        P[0] = F.fromRprBE(buff, o);\n        if (greatest) v[0] = v[0] | 0x80;  // set back again the old value\n\n        const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        P[1] = F.sqrt(x3b);\n\n        if (P[1] === null) {\n            throw new Error(\"Invalid Point!\");\n        }\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        return P;\n    }\n\n    toRprCompressed(buff, o, p) {\n        p = this.affine(p);\n        const v = new Uint8Array(buff.buffer, o, this.F.n8);\n        if (this.isZero(p)) {\n            v.fill(0);\n            v[0] = 0x40;\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n\n        if (isGreatest(this.F, p[1])) {\n            v[0] = v[0] | 0x80;\n        }\n    }\n\n\n    fromRprUncompressed(buff, o) {\n        if (buff[0] & 0x40) return this.zero;\n\n        return this.fromRprBE(buff, o);\n    }\n\n    toRprUncompressed(buff, o, p) {\n        this.toRprBE(buff, o, p);\n\n        if (this.isZero(p)) {\n            buff[o] = buff[o] | 0x40;\n        }\n    }\n\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSXNDO0FBQ0E7OztBQUd0QztBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWUsMENBQVM7QUFDeEI7QUFDQTs7O0FBR2U7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUMsOENBQThDOztBQUU5QztBQUNBOztBQUVBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7O0FBRXZEOztBQUVBLGtEQUFrRDtBQUNsRCx1REFBdUQ7O0FBRXZELHVEQUF1RDtBQUN2RCx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDLGtEQUFrRDtBQUNsRCx1REFBdUQ7O0FBRXZELG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBOztBQUVBO0FBQ0EsZUFBZSxpREFBZ0I7QUFDL0I7O0FBRUE7QUFDQSxlQUFlLGlEQUFnQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxNQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QixJQUFJLHdCQUF3QjtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2VjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuXG5pbXBvcnQgKiBhcyBmVXRpbHMgZnJvbSBcIi4vZnV0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5cblxuZnVuY3Rpb24gaXNHcmVhdGVzdChGLCBhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgZm9yIChsZXQgaT1hLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICghRi5GLmlzWmVybyhhW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0dyZWF0ZXN0KEYuRiwgYVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmEgPSBGLm5lZyhhKTtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5ndChhLCBuYSk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVDIHtcblxuICAgIGNvbnN0cnVjdG9yKEYsIGcpIHtcbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICAgICAgaWYgKHRoaXMuZy5sZW5ndGggPT0gMikgdGhpcy5nWzJdID0gdGhpcy5GLm9uZTtcbiAgICAgICAgdGhpcy56ZXJvID0gW3RoaXMuRi56ZXJvLCB0aGlzLkYub25lLCB0aGlzLkYuemVyb107XG4gICAgfVxuXG4gICAgYWRkKHAxLCBwMikge1xuXG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG5cbiAgICAgICAgaWYgKHRoaXMuZXEocDEsIHRoaXMuemVybykpIHJldHVybiBwMjtcbiAgICAgICAgaWYgKHRoaXMuZXEocDIsIHRoaXMuemVybykpIHJldHVybiBwMTtcblxuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkoMyk7XG5cbiAgICAgICAgY29uc3QgWjFaMSA9IEYuc3F1YXJlKCBwMVsyXSApO1xuICAgICAgICBjb25zdCBaMloyID0gRi5zcXVhcmUoIHAyWzJdICk7XG5cbiAgICAgICAgY29uc3QgVTEgPSBGLm11bCggcDFbMF0gLCBaMloyICk7ICAgICAvLyBVMSA9IFgxICAqIFoyWjJcbiAgICAgICAgY29uc3QgVTIgPSBGLm11bCggcDJbMF0gLCBaMVoxICk7ICAgICAvLyBVMiA9IFgyICAqIFoxWjFcblxuICAgICAgICBjb25zdCBaMV9jdWJlZCA9IEYubXVsKCBwMVsyXSAsIFoxWjEpO1xuICAgICAgICBjb25zdCBaMl9jdWJlZCA9IEYubXVsKCBwMlsyXSAsIFoyWjIpO1xuXG4gICAgICAgIGNvbnN0IFMxID0gRi5tdWwoIHAxWzFdICwgWjJfY3ViZWQpOyAgLy8gUzEgPSBZMSAqIFoyICogWjJaMlxuICAgICAgICBjb25zdCBTMiA9IEYubXVsKCBwMlsxXSAsIFoxX2N1YmVkKTsgIC8vIFMyID0gWTIgKiBaMSAqIFoxWjFcblxuICAgICAgICBpZiAoRi5lcShVMSxVMikgJiYgRi5lcShTMSxTMikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvdWJsZShwMSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBIID0gRi5zdWIoIFUyICwgVTEgKTsgICAgICAgICAgICAgICAgICAgIC8vIEggPSBVMi1VMVxuXG4gICAgICAgIGNvbnN0IFMyX21pbnVzX1MxID0gRi5zdWIoIFMyICwgUzEgKTtcblxuICAgICAgICBjb25zdCBJID0gRi5zcXVhcmUoIEYuYWRkKEgsSCkgKTsgICAgICAgICAvLyBJID0gKDIgKiBIKV4yXG4gICAgICAgIGNvbnN0IEogPSBGLm11bCggSCAsIEkgKTsgICAgICAgICAgICAgICAgICAgICAgLy8gSiA9IEggKiBJXG5cbiAgICAgICAgY29uc3QgciA9IEYuYWRkKCBTMl9taW51c19TMSAsIFMyX21pbnVzX1MxICk7ICAvLyByID0gMiAqIChTMi1TMSlcbiAgICAgICAgY29uc3QgViA9IEYubXVsKCBVMSAsIEkgKTsgICAgICAgICAgICAgICAgICAgICAvLyBWID0gVTEgKiBJXG5cbiAgICAgICAgcmVzWzBdID1cbiAgICAgICAgICAgIEYuc3ViKFxuICAgICAgICAgICAgICAgIEYuc3ViKCBGLnNxdWFyZShyKSAsIEogKSxcbiAgICAgICAgICAgICAgICBGLmFkZCggViAsIFYgKSk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBYMyA9IHJeMiAtIEogLSAyICogVlxuXG4gICAgICAgIGNvbnN0IFMxX0ogPSBGLm11bCggUzEgLCBKICk7XG5cbiAgICAgICAgcmVzWzFdID1cbiAgICAgICAgICAgIEYuc3ViKFxuICAgICAgICAgICAgICAgIEYubXVsKCByICwgRi5zdWIoVixyZXNbMF0pKSxcbiAgICAgICAgICAgICAgICBGLmFkZCggUzFfSixTMV9KICkpOyAgICAgICAgICAgICAgICAgICAvLyBZMyA9IHIgKiAoVi1YMyktMiBTMSBKXG5cbiAgICAgICAgcmVzWzJdID1cbiAgICAgICAgICAgIEYubXVsKFxuICAgICAgICAgICAgICAgIEgsXG4gICAgICAgICAgICAgICAgRi5zdWIoXG4gICAgICAgICAgICAgICAgICAgIEYuc3F1YXJlKCBGLmFkZChwMVsyXSxwMlsyXSkgKSxcbiAgICAgICAgICAgICAgICAgICAgRi5hZGQoIFoxWjEgLCBaMloyICkpKTsgICAgICAgICAgICAvLyBaMyA9ICgoWjErWjIpXjItWjFaMS1aMloyKSAqIEhcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIG5lZyhwKSB7XG4gICAgICAgIHJldHVybiBbcFswXSwgdGhpcy5GLm5lZyhwWzFdKSwgcFsyXV07XG4gICAgfVxuXG4gICAgc3ViKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGEsIHRoaXMubmVnKGIpKTtcbiAgICB9XG5cbiAgICBkb3VibGUocCkge1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheSgzKTtcblxuICAgICAgICBpZiAodGhpcy5lcShwLCB0aGlzLnplcm8pKSByZXR1cm4gcDtcblxuICAgICAgICBjb25zdCBBID0gRi5zcXVhcmUoIHBbMF0gKTsgICAgICAgICAgICAgICAgICAgIC8vIEEgPSBYMV4yXG4gICAgICAgIGNvbnN0IEIgPSBGLnNxdWFyZSggcFsxXSApOyAgICAgICAgICAgICAgICAgICAgLy8gQiA9IFkxXjJcbiAgICAgICAgY29uc3QgQyA9IEYuc3F1YXJlKCBCICk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBDID0gQl4yXG5cbiAgICAgICAgbGV0IEQgPVxuICAgICAgICAgICAgRi5zdWIoXG4gICAgICAgICAgICAgICAgRi5zcXVhcmUoIEYuYWRkKHBbMF0gLCBCICkpLFxuICAgICAgICAgICAgICAgIEYuYWRkKCBBICwgQykpO1xuICAgICAgICBEID0gRi5hZGQoRCxEKTsgICAgICAgICAgICAgICAgICAgIC8vIEQgPSAyICogKChYMSArIEIpXjIgLSBBIC0gQylcblxuICAgICAgICBjb25zdCBFID0gRi5hZGQoIEYuYWRkKEEsQSksIEEpOyAgICAgICAgICAvLyBFID0gMyAqIEFcbiAgICAgICAgY29uc3QgRkYgPUYuc3F1YXJlKCBFICk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBGID0gRV4yXG5cbiAgICAgICAgcmVzWzBdID0gRi5zdWIoIEZGICwgRi5hZGQoRCxEKSApOyAgICAgICAgIC8vIFgzID0gRiAtIDIgRFxuXG4gICAgICAgIGxldCBlaWdodEMgPSBGLmFkZCggQyAsIEMgKTtcbiAgICAgICAgZWlnaHRDID0gRi5hZGQoIGVpZ2h0QyAsIGVpZ2h0QyApO1xuICAgICAgICBlaWdodEMgPSBGLmFkZCggZWlnaHRDICwgZWlnaHRDICk7XG5cbiAgICAgICAgcmVzWzFdID1cbiAgICAgICAgICAgIEYuc3ViKFxuICAgICAgICAgICAgICAgIEYubXVsKFxuICAgICAgICAgICAgICAgICAgICBFLFxuICAgICAgICAgICAgICAgICAgICBGLnN1YiggRCwgcmVzWzBdICkpLFxuICAgICAgICAgICAgICAgIGVpZ2h0Qyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWTMgPSBFICogKEQgLSBYMykgLSA4ICogQ1xuXG4gICAgICAgIGNvbnN0IFkxWjEgPSBGLm11bCggcFsxXSAsIHBbMl0gKTtcbiAgICAgICAgcmVzWzJdID0gRi5hZGQoIFkxWjEgLCBZMVoxICk7ICAgICAgICAgICAgICAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICB0aW1lc1NjYWxhcihiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBmVXRpbHMubXVsU2NhbGFyKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIG11bFNjYWxhcihiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBmVXRpbHMubXVsU2NhbGFyKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIGFmZmluZShwKSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfSBlbHNlIGlmIChGLmVxKHBbMl0sIEYub25lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBaX2ludiA9IEYuaW52KHBbMl0pO1xuICAgICAgICAgICAgY29uc3QgWjJfaW52ID0gRi5zcXVhcmUoWl9pbnYpO1xuICAgICAgICAgICAgY29uc3QgWjNfaW52ID0gRi5tdWwoWjJfaW52LCBaX2ludik7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheSgzKTtcbiAgICAgICAgICAgIHJlc1swXSA9IEYubXVsKHBbMF0sWjJfaW52KTtcbiAgICAgICAgICAgIHJlc1sxXSA9IEYubXVsKHBbMV0sWjNfaW52KTtcbiAgICAgICAgICAgIHJlc1syXSA9IEYub25lO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbXVsdGlBZmZpbmUoYXJyKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcnIpO1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuICAgICAgICBjb25zdCBhY2NNdWwgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgrMSk7XG4gICAgICAgIGFjY011bFswXSA9IEYub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaTwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKEYuZXEoYXJyW2tleXNbaV1dWzJdLCBGLnplcm8pKSB7XG4gICAgICAgICAgICAgICAgYWNjTXVsW2krMV0gPSBhY2NNdWxbaV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjY011bFtpKzFdID0gRi5tdWwoYWNjTXVsW2ldLCBhcnJba2V5c1tpXV1bMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWNjTXVsW2tleXMubGVuZ3RoXSA9IEYuaW52KGFjY011bFtrZXlzLmxlbmd0aF0pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBrZXlzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChGLmVxKGFycltrZXlzW2ldXVsyXSwgRi56ZXJvKSkge1xuICAgICAgICAgICAgICAgIGFjY011bFtpXSA9IGFjY011bFtpKzFdO1xuICAgICAgICAgICAgICAgIGFycltrZXlzW2ldXSA9IHRoaXMuemVybztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgWl9pbnYgPSBGLm11bChhY2NNdWxbaV0sIGFjY011bFtpKzFdKTtcbiAgICAgICAgICAgICAgICBhY2NNdWxbaV0gPSBGLm11bChhcnJba2V5c1tpXV1bMl0sIGFjY011bFtpKzFdKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IFoyX2ludiA9IEYuc3F1YXJlKFpfaW52KTtcbiAgICAgICAgICAgICAgICBjb25zdCBaM19pbnYgPSBGLm11bChaMl9pbnYsIFpfaW52KTtcblxuICAgICAgICAgICAgICAgIGFycltrZXlzW2ldXVswXSA9IEYubXVsKGFycltrZXlzW2ldXVswXSxaMl9pbnYpO1xuICAgICAgICAgICAgICAgIGFycltrZXlzW2ldXVsxXSA9IEYubXVsKGFycltrZXlzW2ldXVsxXSxaM19pbnYpO1xuICAgICAgICAgICAgICAgIGFycltrZXlzW2ldXVsyXSA9IEYub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBlcShwMSwgcDIpIHtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcblxuICAgICAgICBpZiAodGhpcy5GLmVxKHAxWzJdLCB0aGlzLkYuemVybykpIHJldHVybiB0aGlzLkYuZXEocDJbMl0sIHRoaXMuRi56ZXJvKTtcbiAgICAgICAgaWYgKHRoaXMuRi5lcShwMlsyXSwgdGhpcy5GLnplcm8pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgWjFaMSA9IEYuc3F1YXJlKCBwMVsyXSApO1xuICAgICAgICBjb25zdCBaMloyID0gRi5zcXVhcmUoIHAyWzJdICk7XG5cbiAgICAgICAgY29uc3QgVTEgPSBGLm11bCggcDFbMF0gLCBaMloyICk7XG4gICAgICAgIGNvbnN0IFUyID0gRi5tdWwoIHAyWzBdICwgWjFaMSApO1xuXG4gICAgICAgIGNvbnN0IFoxX2N1YmVkID0gRi5tdWwoIHAxWzJdICwgWjFaMSk7XG4gICAgICAgIGNvbnN0IFoyX2N1YmVkID0gRi5tdWwoIHAyWzJdICwgWjJaMik7XG5cbiAgICAgICAgY29uc3QgUzEgPSBGLm11bCggcDFbMV0gLCBaMl9jdWJlZCk7XG4gICAgICAgIGNvbnN0IFMyID0gRi5tdWwoIHAyWzFdICwgWjFfY3ViZWQpO1xuXG4gICAgICAgIHJldHVybiAoRi5lcShVMSxVMikgJiYgRi5lcShTMSxTMikpO1xuICAgIH1cblxuICAgIGlzWmVybyhwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYuaXNaZXJvKHBbMl0pO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKHApIHtcbiAgICAgICAgY29uc3QgY3AgPSB0aGlzLmFmZmluZShwKTtcbiAgICAgICAgcmV0dXJuIGBbICR7dGhpcy5GLnRvU3RyaW5nKGNwWzBdKX0gLCAke3RoaXMuRi50b1N0cmluZyhjcFsxXSl9IF1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG4gICAgICAgIGxldCBQID0gW107XG4gICAgICAgIGxldCBncmVhdGVzdDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgUFswXSA9IEYuZnJvbVJuZyhybmcpO1xuICAgICAgICAgICAgZ3JlYXRlc3QgPSBybmcubmV4dEJvb2woKTtcbiAgICAgICAgICAgIGNvbnN0IHgzYiA9IEYuYWRkKEYubXVsKEYuc3F1YXJlKFBbMF0pLCBQWzBdKSwgdGhpcy5iKTtcbiAgICAgICAgICAgIFBbMV0gPSBGLnNxcnQoeDNiKTtcbiAgICAgICAgfSB3aGlsZSAoKFBbMV0gPT0gbnVsbCl8fChGLmlzWmVyb1tQXSkpO1xuXG4gICAgICAgIGNvbnN0IHMgPSBpc0dyZWF0ZXN0KEYsIFBbMV0pO1xuICAgICAgICBpZiAoZ3JlYXRlc3QgXiBzKSBQWzFdID0gRi5uZWcoUFsxXSk7XG4gICAgICAgIFBbMl0gPSBGLm9uZTtcblxuICAgICAgICBpZiAodGhpcy5jb2ZhY3Rvcikge1xuICAgICAgICAgICAgUCA9IHRoaXMubXVsU2NhbGFyKFAsIHRoaXMuY29mYWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgUCA9IHRoaXMuYWZmaW5lKFApO1xuXG4gICAgICAgIHJldHVybiBQO1xuXG4gICAgfVxuXG4gICAgdG9ScHJMRShidWZmLCBvLCBwKSB7XG4gICAgICAgIHAgPSB0aGlzLmFmZmluZShwKTtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKHApKSB7XG4gICAgICAgICAgICBjb25zdCBCdWZmViA9IG5ldyBVaW50OEFycmF5KGJ1ZmYsIG8sIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIEJ1ZmZWLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbywgcFswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFKGJ1ZmYsIG8rdGhpcy5GLm44LCBwWzFdKTtcbiAgICB9XG5cbiAgICB0b1JwckJFKGJ1ZmYsIG8sIHApIHtcbiAgICAgICAgcCA9IHRoaXMuYWZmaW5lKHApO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIGNvbnN0IEJ1ZmZWID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiwgbywgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgQnVmZlYuZmlsbCgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvLCBwWzBdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkUoYnVmZiwgbyt0aGlzLkYubjgsIHBbMV0pO1xuICAgIH1cblxuICAgIHRvUnByTEVNKGJ1ZmYsIG8sIHApIHtcbiAgICAgICAgcCA9IHRoaXMuYWZmaW5lKHApO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIGNvbnN0IEJ1ZmZWID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiwgbywgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgQnVmZlYuZmlsbCgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbywgcFswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFTShidWZmLCBvK3RoaXMuRi5uOCwgcFsxXSk7XG4gICAgfVxuXG4gICAgdG9ScHJMRUpNKGJ1ZmYsIG8sIHApIHtcbiAgICAgICAgcCA9IHRoaXMuYWZmaW5lKHApO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIGNvbnN0IEJ1ZmZWID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiwgbywgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgQnVmZlYuZmlsbCgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbywgcFswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFTShidWZmLCBvK3RoaXMuRi5uOCwgcFsxXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFTShidWZmLCBvKzIqdGhpcy5GLm44LCBwWzJdKTtcbiAgICB9XG5cblxuICAgIHRvUnByQkVNKGJ1ZmYsIG8sIHApIHtcbiAgICAgICAgcCA9IHRoaXMuYWZmaW5lKHApO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIGNvbnN0IEJ1ZmZWID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiwgbywgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgQnVmZlYuZmlsbCgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkYudG9ScHJCRU0oYnVmZiwgbywgcFswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckJFTShidWZmLCBvK3RoaXMuRi5uOCwgcFsxXSk7XG4gICAgfVxuXG4gICAgZnJvbVJwckxFKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuRi5mcm9tUnByTEUoYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLkYuZnJvbVJwckxFKGJ1ZmYsIG8rdGhpcy5GLm44KTtcbiAgICAgICAgaWYgKHRoaXMuRi5pc1plcm8oeCkgJiYgdGhpcy5GLmlzWmVybyh5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHksIHRoaXMuRi5vbmVdO1xuICAgIH1cblxuICAgIGZyb21ScHJCRShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5GLmZyb21ScHJCRShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIGlmICh0aGlzLkYuaXNaZXJvKHgpICYmIHRoaXMuRi5pc1plcm8oeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5LCB0aGlzLkYub25lXTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuRi5mcm9tUnByTEVNKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICBpZiAodGhpcy5GLmlzWmVybyh4KSAmJiB0aGlzLkYuaXNaZXJvKHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeSwgdGhpcy5GLm9uZV07XG4gICAgfVxuXG4gICAgZnJvbVJwckxFSk0oYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIGNvbnN0IHogPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvK3RoaXMuRi5uOCoyKTtcbiAgICAgICAgaWYgKHRoaXMuRi5pc1plcm8oeCkgJiYgdGhpcy5GLmlzWmVybyh5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgIH1cblxuICAgIGZyb21ScHJCRU0oYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5GLmZyb21ScHJCRU0oYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIGlmICh0aGlzLkYuaXNaZXJvKHgpICYmIHRoaXMuRi5pc1plcm8oeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5LCB0aGlzLkYub25lXTtcbiAgICB9XG5cbiAgICBmcm9tUnByQ29tcHJlc3NlZChidWZmLCBvKSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgVWludDhBcnJheShidWZmLmJ1ZmZlciwgbywgRi5uOCk7XG4gICAgICAgIGlmICh2WzBdICYgMHg0MCkgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgY29uc3QgUCA9IG5ldyBBcnJheSgzKTtcblxuICAgICAgICBjb25zdCBncmVhdGVzdCA9ICgodlswXSAmIDB4ODApICE9IDApO1xuICAgICAgICB2WzBdID0gdlswXSAmIDB4N0Y7XG4gICAgICAgIFBbMF0gPSBGLmZyb21ScHJCRShidWZmLCBvKTtcbiAgICAgICAgaWYgKGdyZWF0ZXN0KSB2WzBdID0gdlswXSB8IDB4ODA7ICAvLyBzZXQgYmFjayBhZ2FpbiB0aGUgb2xkIHZhbHVlXG5cbiAgICAgICAgY29uc3QgeDNiID0gRi5hZGQoRi5tdWwoRi5zcXVhcmUoUFswXSksIFBbMF0pLCB0aGlzLmIpO1xuICAgICAgICBQWzFdID0gRi5zcXJ0KHgzYik7XG5cbiAgICAgICAgaWYgKFBbMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUG9pbnQhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcyA9IGlzR3JlYXRlc3QoRiwgUFsxXSk7XG4gICAgICAgIGlmIChncmVhdGVzdCBeIHMpIFBbMV0gPSBGLm5lZyhQWzFdKTtcbiAgICAgICAgUFsyXSA9IEYub25lO1xuXG4gICAgICAgIHJldHVybiBQO1xuICAgIH1cblxuICAgIHRvUnByQ29tcHJlc3NlZChidWZmLCBvLCBwKSB7XG4gICAgICAgIHAgPSB0aGlzLmFmZmluZShwKTtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBVaW50OEFycmF5KGJ1ZmYuYnVmZmVyLCBvLCB0aGlzLkYubjgpO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIHYuZmlsbCgwKTtcbiAgICAgICAgICAgIHZbMF0gPSAweDQwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8sIHBbMF0pO1xuXG4gICAgICAgIGlmIChpc0dyZWF0ZXN0KHRoaXMuRiwgcFsxXSkpIHtcbiAgICAgICAgICAgIHZbMF0gPSB2WzBdIHwgMHg4MDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCBvKSB7XG4gICAgICAgIGlmIChidWZmWzBdICYgMHg0MCkgcmV0dXJuIHRoaXMuemVybztcblxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tUnByQkUoYnVmZiwgbyk7XG4gICAgfVxuXG4gICAgdG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgbywgcCkge1xuICAgICAgICB0aGlzLnRvUnByQkUoYnVmZiwgbywgcCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKHApKSB7XG4gICAgICAgICAgICBidWZmW29dID0gYnVmZltvXSB8IDB4NDA7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/ec.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildEngine)\n/* harmony export */ });\n/* harmony import */ var _wasm_field1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wasm_field1.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field1.js\");\n/* harmony import */ var _wasm_field2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wasm_field2.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field2.js\");\n/* harmony import */ var _wasm_field3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wasm_field3.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field3.js\");\n/* harmony import */ var _wasm_curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wasm_curve.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_curve.js\");\n/* harmony import */ var _threadman_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./threadman.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _engine_applykey_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./engine_applykey.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_applykey.js\");\n/* harmony import */ var _engine_pairing_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./engine_pairing.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_pairing.js\");\n/* harmony import */ var _engine_multiexp_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./engine_multiexp.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_multiexp.js\");\n/* harmony import */ var _engine_fft_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./engine_fft.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_fft.js\");\n\n\n\n\n\n\n\n\n\n\n\nasync function buildEngine(params) {\n\n    const tm = await (0,_threadman_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(params.wasm, params.singleThread);\n\n\n    const curve = {};\n\n    curve.q = _scalar_js__WEBPACK_IMPORTED_MODULE_5__.e(params.wasm.q.toString());\n    curve.r = _scalar_js__WEBPACK_IMPORTED_MODULE_5__.e(params.wasm.r.toString());\n    curve.name = params.name;\n    curve.tm = tm;\n    curve.prePSize = params.wasm.prePSize;\n    curve.preQSize = params.wasm.preQSize;\n    curve.Fr = new _wasm_field1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](tm, \"frm\", params.n8r, params.r);\n    curve.F1 = new _wasm_field1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](tm, \"f1m\", params.n8q, params.q);\n    curve.F2 = new _wasm_field2_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](tm, \"f2m\", curve.F1);\n    curve.G1 = new _wasm_curve_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tm, \"g1m\", curve.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);\n    curve.G2 = new _wasm_curve_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tm, \"g2m\", curve.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);\n    curve.F6 = new _wasm_field3_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](tm, \"f6m\", curve.F2);\n    curve.F12 = new _wasm_field2_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](tm, \"ftm\", curve.F6);\n\n    curve.Gt = curve.F12;\n\n    (0,_engine_applykey_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(curve, \"G1\");\n    (0,_engine_applykey_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(curve, \"G2\");\n    (0,_engine_applykey_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(curve, \"Fr\");\n\n    (0,_engine_multiexp_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(curve, \"G1\");\n    (0,_engine_multiexp_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(curve, \"G2\");\n\n    (0,_engine_fft_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(curve, \"G1\");\n    (0,_engine_fft_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(curve, \"G2\");\n    (0,_engine_fft_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(curve, \"Fr\");\n\n    (0,_engine_pairing_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(curve);\n\n    curve.array2buffer = function(arr, sG) {\n        const buff = new Uint8Array(sG*arr.length);\n\n        for (let i=0; i<arr.length; i++) {\n            buff.set(arr[i], i*sG);\n        }\n\n        return buff;\n    };\n\n    curve.buffer2array = function(buff , sG) {\n        const n= buff.byteLength / sG;\n        const arr = new Array(n);\n        for (let i=0; i<n; i++) {\n            arr[i] = buff.slice(i*sG, i*sG+sG);\n        }\n        return arr;\n    };\n\n    return curve;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMEM7QUFDQTtBQUNBO0FBQ0Y7QUFDUTtBQUNWO0FBQ2dCO0FBQ1A7QUFDRTtBQUNWOztBQUV4Qjs7QUFFZixxQkFBcUIseURBQWtCOzs7QUFHdkM7O0FBRUEsY0FBYyx5Q0FBUTtBQUN0QixjQUFjLHlDQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFVO0FBQzdCLG1CQUFtQix1REFBVTtBQUM3QixtQkFBbUIsdURBQVU7QUFDN0IsbUJBQW1CLHNEQUFTO0FBQzVCLG1CQUFtQixzREFBUztBQUM1QixtQkFBbUIsdURBQVU7QUFDN0Isb0JBQW9CLHVEQUFVOztBQUU5Qjs7QUFFQSxJQUFJLCtEQUFrQjtBQUN0QixJQUFJLCtEQUFrQjtBQUN0QixJQUFJLCtEQUFrQjs7QUFFdEIsSUFBSSwrREFBYTtBQUNqQixJQUFJLCtEQUFhOztBQUVqQixJQUFJLDBEQUFRO0FBQ1osSUFBSSwwREFBUTtBQUNaLElBQUksMERBQVE7O0FBRVosSUFBSSw4REFBWTs7QUFFaEI7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2VuZ2luZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgV2FzbUZpZWxkMSBmcm9tIFwiLi93YXNtX2ZpZWxkMS5qc1wiO1xuaW1wb3J0IFdhc21GaWVsZDIgZnJvbSBcIi4vd2FzbV9maWVsZDIuanNcIjtcbmltcG9ydCBXYXNtRmllbGQzIGZyb20gXCIuL3dhc21fZmllbGQzLmpzXCI7XG5pbXBvcnQgV2FzbUN1cnZlIGZyb20gXCIuL3dhc21fY3VydmUuanNcIjtcbmltcG9ydCBidWlsZFRocmVhZE1hbmFnZXIgZnJvbSBcIi4vdGhyZWFkbWFuLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5pbXBvcnQgYnVpbGRCYXRjaEFwcGx5S2V5IGZyb20gXCIuL2VuZ2luZV9hcHBseWtleS5qc1wiO1xuaW1wb3J0IGJ1aWxkUGFpcmluZyBmcm9tIFwiLi9lbmdpbmVfcGFpcmluZy5qc1wiO1xuaW1wb3J0IGJ1aWxkTXVsdGlFeHAgZnJvbSBcIi4vZW5naW5lX211bHRpZXhwLmpzXCI7XG5pbXBvcnQgYnVpbGRGRlQgZnJvbSBcIi4vZW5naW5lX2ZmdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBidWlsZEVuZ2luZShwYXJhbXMpIHtcblxuICAgIGNvbnN0IHRtID0gYXdhaXQgYnVpbGRUaHJlYWRNYW5hZ2VyKHBhcmFtcy53YXNtLCBwYXJhbXMuc2luZ2xlVGhyZWFkKTtcblxuXG4gICAgY29uc3QgY3VydmUgPSB7fTtcblxuICAgIGN1cnZlLnEgPSBTY2FsYXIuZShwYXJhbXMud2FzbS5xLnRvU3RyaW5nKCkpO1xuICAgIGN1cnZlLnIgPSBTY2FsYXIuZShwYXJhbXMud2FzbS5yLnRvU3RyaW5nKCkpO1xuICAgIGN1cnZlLm5hbWUgPSBwYXJhbXMubmFtZTtcbiAgICBjdXJ2ZS50bSA9IHRtO1xuICAgIGN1cnZlLnByZVBTaXplID0gcGFyYW1zLndhc20ucHJlUFNpemU7XG4gICAgY3VydmUucHJlUVNpemUgPSBwYXJhbXMud2FzbS5wcmVRU2l6ZTtcbiAgICBjdXJ2ZS5GciA9IG5ldyBXYXNtRmllbGQxKHRtLCBcImZybVwiLCBwYXJhbXMubjhyLCBwYXJhbXMucik7XG4gICAgY3VydmUuRjEgPSBuZXcgV2FzbUZpZWxkMSh0bSwgXCJmMW1cIiwgcGFyYW1zLm44cSwgcGFyYW1zLnEpO1xuICAgIGN1cnZlLkYyID0gbmV3IFdhc21GaWVsZDIodG0sIFwiZjJtXCIsIGN1cnZlLkYxKTtcbiAgICBjdXJ2ZS5HMSA9IG5ldyBXYXNtQ3VydmUodG0sIFwiZzFtXCIsIGN1cnZlLkYxLCBwYXJhbXMud2FzbS5wRzFnZW4sIHBhcmFtcy53YXNtLnBHMWIsIHBhcmFtcy5jb2ZhY3RvckcxKTtcbiAgICBjdXJ2ZS5HMiA9IG5ldyBXYXNtQ3VydmUodG0sIFwiZzJtXCIsIGN1cnZlLkYyLCBwYXJhbXMud2FzbS5wRzJnZW4sIHBhcmFtcy53YXNtLnBHMmIsIHBhcmFtcy5jb2ZhY3RvckcyKTtcbiAgICBjdXJ2ZS5GNiA9IG5ldyBXYXNtRmllbGQzKHRtLCBcImY2bVwiLCBjdXJ2ZS5GMik7XG4gICAgY3VydmUuRjEyID0gbmV3IFdhc21GaWVsZDIodG0sIFwiZnRtXCIsIGN1cnZlLkY2KTtcblxuICAgIGN1cnZlLkd0ID0gY3VydmUuRjEyO1xuXG4gICAgYnVpbGRCYXRjaEFwcGx5S2V5KGN1cnZlLCBcIkcxXCIpO1xuICAgIGJ1aWxkQmF0Y2hBcHBseUtleShjdXJ2ZSwgXCJHMlwiKTtcbiAgICBidWlsZEJhdGNoQXBwbHlLZXkoY3VydmUsIFwiRnJcIik7XG5cbiAgICBidWlsZE11bHRpRXhwKGN1cnZlLCBcIkcxXCIpO1xuICAgIGJ1aWxkTXVsdGlFeHAoY3VydmUsIFwiRzJcIik7XG5cbiAgICBidWlsZEZGVChjdXJ2ZSwgXCJHMVwiKTtcbiAgICBidWlsZEZGVChjdXJ2ZSwgXCJHMlwiKTtcbiAgICBidWlsZEZGVChjdXJ2ZSwgXCJGclwiKTtcblxuICAgIGJ1aWxkUGFpcmluZyhjdXJ2ZSk7XG5cbiAgICBjdXJ2ZS5hcnJheTJidWZmZXIgPSBmdW5jdGlvbihhcnIsIHNHKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRyphcnIubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBidWZmLnNldChhcnJbaV0sIGkqc0cpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfTtcblxuICAgIGN1cnZlLmJ1ZmZlcjJhcnJheSA9IGZ1bmN0aW9uKGJ1ZmYgLCBzRykge1xuICAgICAgICBjb25zdCBuPSBidWZmLmJ5dGVMZW5ndGggLyBzRztcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBidWZmLnNsaWNlKGkqc0csIGkqc0crc0cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAgIHJldHVybiBjdXJ2ZTtcbn1cblxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_applykey.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine_applykey.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildBatchApplyKey)\n/* harmony export */ });\n/* harmony import */ var _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bigbuffer.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\");\n\n\nfunction buildBatchApplyKey(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = curve.tm;\n\n    curve[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        let fnName, fnAffine;\n        let sGin, sGmid, sGout;\n        if (groupName == \"G1\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g1m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g1m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g1m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g2m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g2m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g2m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_batchApplyKey\";\n            sGin = G.n8;\n            sGmid = G.n8;\n            sGout = G.n8;\n        } else {\n            throw new Error(\"Invalid group: \" + groupName);\n        }\n        const nPoints = Math.floor(buff.byteLength / sGin);\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        inc = Fr.e(inc);\n        let t = Fr.e(first);\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({\n                cmd: \"ALLOCSET\",\n                var: 0,\n                buff: buff.slice(i*pointsPerChunk*sGin, i*pointsPerChunk*sGin + n*sGin)\n            });\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: t});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: inc});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*Math.max(sGmid, sGout)});\n            task.push({\n                cmd: \"CALL\",\n                fnName: fnName,\n                params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1},\n                    {var: 2},\n                    {var:3}\n                ]\n            });\n            if (fnAffine) {\n                task.push({\n                    cmd: \"CALL\",\n                    fnName: fnAffine,\n                    params: [\n                        {var: 3},\n                        {val: n},\n                        {var: 3},\n                    ]\n                });\n            }\n            task.push({cmd: \"GET\", out: 0, var: 3, len: n*sGout});\n\n            opPromises.push(tm.queueAction(task));\n            t = Fr.mul(t, Fr.exp(inc, n));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let outBuff;\n        if (buff instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n            outBuff = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](nPoints*sGout);\n        } else {\n            outBuff = new Uint8Array(nPoints*sGout);\n        }\n\n        let p=0;\n        for (let i=0; i<result.length; i++) {\n            outBuff.set(result[i][0], p);\n            p += result[i][0].byteLength;\n        }\n\n        return outBuff;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfYXBwbHlrZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7O0FBRXhCO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QixpQ0FBaUM7QUFDeEQsdUJBQXVCLG1DQUFtQztBQUMxRCx1QkFBdUIsb0RBQW9EO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIscUJBQXFCLE9BQU87QUFDNUIscUJBQXFCLE9BQU87QUFDNUIscUJBQXFCLE9BQU87QUFDNUIscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHVCQUF1Qix5Q0FBeUM7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QixxREFBUztBQUNyQywwQkFBMEIscURBQVM7QUFDbkMsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfYXBwbHlrZXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJpZ0J1ZmZlciBmcm9tIFwiLi9iaWdidWZmZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRCYXRjaEFwcGx5S2V5KGN1cnZlLCBncm91cE5hbWUpIHtcbiAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHRtID0gY3VydmUudG07XG5cbiAgICBjdXJ2ZVtncm91cE5hbWVdLmJhdGNoQXBwbHlLZXkgPSBhc3luYyBmdW5jdGlvbihidWZmLCBmaXJzdCwgaW5jLCBpblR5cGUsIG91dFR5cGUpIHtcbiAgICAgICAgaW5UeXBlID0gaW5UeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIG91dFR5cGUgPSBvdXRUeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIGxldCBmbk5hbWUsIGZuQWZmaW5lO1xuICAgICAgICBsZXQgc0dpbiwgc0dtaWQsIHNHb3V0O1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImphY29iaWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzR2luID0gRy5GLm44KjM7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMW1fYmF0Y2hBcHBseUtleVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzR2luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMW1fYmF0Y2hBcHBseUtleU1peGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzR21pZCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgaWYgKG91dFR5cGUgPT0gXCJqYWNvYmlhblwiKSB7XG4gICAgICAgICAgICAgICAgc0dvdXQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm5BZmZpbmUgPSBcImcxbV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICAgICAgc0dvdXQgPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiamFjb2JpYW5cIikge1xuICAgICAgICAgICAgICAgIHNHaW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcybV9iYXRjaEFwcGx5S2V5XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNHaW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcybV9iYXRjaEFwcGx5S2V5TWl4ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNHbWlkID0gRy5GLm44KjM7XG4gICAgICAgICAgICBpZiAob3V0VHlwZSA9PSBcImphY29iaWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzR291dCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbkFmZmluZSA9IFwiZzJtX2JhdGNoVG9BZmZpbmVcIjtcbiAgICAgICAgICAgICAgICBzR291dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkZyXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZnJtX2JhdGNoQXBwbHlLZXlcIjtcbiAgICAgICAgICAgIHNHaW4gPSBHLm44O1xuICAgICAgICAgICAgc0dtaWQgPSBHLm44O1xuICAgICAgICAgICAgc0dvdXQgPSBHLm44O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cDogXCIgKyBncm91cE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmYuYnl0ZUxlbmd0aCAvIHNHaW4pO1xuICAgICAgICBjb25zdCBwb2ludHNQZXJDaHVuayA9IE1hdGguZmxvb3IoblBvaW50cy90bS5jb25jdXJyZW5jeSk7XG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaW5jID0gRnIuZShpbmMpO1xuICAgICAgICBsZXQgdCA9IEZyLmUoZmlyc3QpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dG0uY29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgdG0uY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBwb2ludHNQZXJDaHVuaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHMgLSBpKnBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG5cbiAgICAgICAgICAgIHRhc2sucHVzaCh7XG4gICAgICAgICAgICAgICAgY21kOiBcIkFMTE9DU0VUXCIsXG4gICAgICAgICAgICAgICAgdmFyOiAwLFxuICAgICAgICAgICAgICAgIGJ1ZmY6IGJ1ZmYuc2xpY2UoaSpwb2ludHNQZXJDaHVuaypzR2luLCBpKnBvaW50c1BlckNodW5rKnNHaW4gKyBuKnNHaW4pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogdH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAyLCBidWZmOiBpbmN9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMywgbGVuOiBuKk1hdGgubWF4KHNHbWlkLCBzR291dCl9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7XG4gICAgICAgICAgICAgICAgY21kOiBcIkNBTExcIixcbiAgICAgICAgICAgICAgICBmbk5hbWU6IGZuTmFtZSxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6M31cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmbkFmZmluZSkge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogXCJDQUxMXCIsXG4gICAgICAgICAgICAgICAgICAgIGZuTmFtZTogZm5BZmZpbmUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogM30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDMsIGxlbjogbipzR291dH0pO1xuXG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2godG0ucXVldWVBY3Rpb24odGFzaykpO1xuICAgICAgICAgICAgdCA9IEZyLm11bCh0LCBGci5leHAoaW5jLCBuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgb3V0QnVmZjtcbiAgICAgICAgaWYgKGJ1ZmYgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIG91dEJ1ZmYgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0dvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0QnVmZiA9IG5ldyBVaW50OEFycmF5KG5Qb2ludHMqc0dvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHA9MDtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0QnVmZi5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHAgKz0gcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0QnVmZjtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_applykey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildBatchConvert)\n/* harmony export */ });\n/* harmony import */ var _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bigbuffer.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\");\n\n\nfunction buildBatchConvert(tm, fnName, sIn, sOut) {\n    return async function batchConvert(buffIn) {\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1}\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n            fullBuffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfYmF0Y2hjb252ZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDOztBQUV4QjtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pELGlCQUFpQixtQ0FBbUM7QUFDcEQsaUJBQWlCO0FBQ2pCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsaUJBQWlCLHlDQUF5QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLHFEQUFTO0FBQ3ZDLDhCQUE4QixxREFBUztBQUN2QyxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2VuZ2luZV9iYXRjaGNvbnZlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJpZ0J1ZmZlciBmcm9tIFwiLi9iaWdidWZmZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRCYXRjaENvbnZlcnQodG0sIGZuTmFtZSwgc0luLCBzT3V0KSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIGJhdGNoQ29udmVydChidWZmSW4pIHtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoYnVmZkluLmJ5dGVMZW5ndGggLyBzSW4pO1xuICAgICAgICBpZiAoIG5Qb2ludHMgKiBzSW4gIT09IGJ1ZmZJbi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ1ZmZlciBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50c1BlckNodW5rID0gTWF0aC5mbG9vcihuUG9pbnRzL3RtLmNvbmN1cnJlbmN5KTtcbiAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dG0uY29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgdG0uY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBwb2ludHNQZXJDaHVuaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHMgLSBpKnBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmQ2h1bmsgPSBidWZmSW4uc2xpY2UoaSpwb2ludHNQZXJDaHVuaypzSW4sIGkqcG9pbnRzUGVyQ2h1bmsqc0luICsgbipzSW4pO1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjpidWZmQ2h1bmt9LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAxLCBsZW46c091dCAqIG59LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuTmFtZSwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMX1cbiAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMSwgbGVuOnNPdXQgKiBufSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgdG0ucXVldWVBY3Rpb24odGFzaylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgZnVsbEJ1ZmZPdXQ7XG4gICAgICAgIGlmIChidWZmSW4gaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNPdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNPdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHAgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0LnNldChyZXN1bHRbaV1bMF0sIHApO1xuICAgICAgICAgICAgcCs9cmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVsbEJ1ZmZPdXQ7XG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_fft.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine_fft.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildFFT)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js\");\n/* harmony import */ var _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bigbuffer.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\");\n\n\n\n\nfunction buildFFT(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = G.tm;\n    async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {\n\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        const MAX_BITS_THREAD = 14;\n\n        let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g1m_fftFinal\";\n            }\n            fnFFTJoin = \"g1m_fftJoin\";\n            fnFFTMix = \"g1m_fftMix\";\n\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g1m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g2m_fftFinal\";\n            }\n            fnFFTJoin = \"g2m_fftJoin\";\n            fnFFTMix = \"g2m_fftMix\";\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g2m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = G.n8;\n            sMid = G.n8;\n            sOut = G.n8;\n            if (inverse) {\n                fnFFTFinal = \"frm_fftFinal\";\n            }\n            fnFFTMix = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        }\n\n\n        let returnArray = false;\n        if (Array.isArray(buff)) {\n            buff = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.array2buffer)(buff, sIn);\n            returnArray = true;\n        } else {\n            buff = buff.slice(0, buff.byteLength);\n        }\n\n        const nPoints = buff.byteLength / sIn;\n        const bits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints);\n\n        if  ((1 << bits) != nPoints) {\n            throw new Error(\"fft must be multiple of 2\" );\n        }\n\n        if (bits == Fr.s +1) {\n            let buffOut;\n\n            if (inverse) {\n                buffOut =  await _fftExtInv(buff, inType, outType, logger, loggerTxt);\n            } else {\n                buffOut =  await _fftExt(buff, inType, outType, logger, loggerTxt);\n            }\n\n            if (returnArray) {\n                return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.buffer2array)(buffOut, sOut);\n            } else {\n                return buffOut;\n            }\n        }\n\n        let inv;\n        if (inverse) {\n            inv = Fr.inv(Fr.e(nPoints));\n        }\n\n        let buffOut;\n\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.buffReverseBits)(buff, sIn);\n\n        let chunks;\n        let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);\n        let nChunks = nPoints / pointsInChunk;\n\n        while ((nChunks < tm.concurrency)&&(pointsInChunk>=16)) {\n            nChunks *= 2;\n            pointsInChunk /= 2;\n        }\n\n        const l2Chunk = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(pointsInChunk);\n\n        const promises = [];\n        for (let i = 0; i< nChunks; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix start: ${i}/${nChunks}`);\n            const task = [];\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*pointsInChunk});\n            const buffChunk = buff.slice( (pointsInChunk * i)*sIn, (pointsInChunk * (i+1))*sIn);\n            task.push({cmd: \"SET\", var: 0, buff: buffChunk});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n            }\n            for (let j=1; j<=l2Chunk;j++) {\n                task.push({cmd: \"CALL\", fnName:fnFFTMix, params: [{var:0}, {val: pointsInChunk}, {val: j}]});\n            }\n\n            if (l2Chunk==bits) {\n                if (fnFFTFinal) {\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: inv});\n                    task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                        {var: 0},\n                        {val: pointsInChunk},\n                        {var: 1},\n                    ]});\n                }\n                if (fnMid2Out) {\n                    task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                }\n                task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n            } else {\n                task.push({cmd: \"GET\", out:0, var: 0, len: sMid*pointsInChunk});\n            }\n            promises.push(tm.queueAction(task).then( (r) => {\n                if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix end: ${i}/${nChunks}`);\n                return r;\n            }));\n        }\n\n        chunks = await Promise.all(promises);\n        for (let i = 0; i< nChunks; i++) chunks[i] = chunks[i][0];\n\n        for (let i = l2Chunk+1;   i<=bits; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft  ${bits}  join: ${i}/${bits}`);\n            const nGroups = 1 << (bits - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsInChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsInChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    if (i==bits) {\n                        if (fnFFTFinal) {\n                            task.push({cmd: \"ALLOCSET\", var: 4, buff: inv});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 0},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 1},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                        }\n                        if (fnMid2Out) {\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: pointsInChunk}, {var: 1}]});\n                        }\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sOut});\n                    } else {\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sMid});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sMid});\n                    }\n                    opPromises.push(tm.queueAction(task).then( (r) => {\n                        if (logger) logger.debug(`${loggerTxt}: fft ${bits} join  ${i}/${bits}  ${j+1}/${nGroups} ${k}/${nChunksPerGroup/2}`);\n                        return r;\n                    }));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        if (buff instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n            buffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sOut);\n        } else {\n            buffOut = new Uint8Array(nPoints*sOut);\n        }\n        if (inverse) {\n            buffOut.set(chunks[0].slice((pointsInChunk-1)*sOut));\n            let p= sOut;\n            for (let i=nChunks-1; i>0; i--) {\n                buffOut.set(chunks[i], p);\n                p += pointsInChunk*sOut;\n                delete chunks[i];  // Liberate mem\n            }\n            buffOut.set(chunks[0].slice(0, (pointsInChunk-1)*sOut), p);\n            delete chunks[0];\n        } else {\n            for (let i=0; i<nChunks; i++) {\n                buffOut.set(chunks[i], pointsInChunk*sOut*i);\n                delete chunks[i];\n            }\n        }\n\n        if (returnArray) {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.buffer2array)(buffOut, sOut);\n        } else {\n            return buffOut;\n        }\n    }\n\n    async function _fftExt(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        [b1, b2] = await _fftJoinExt(b1, b2, \"fftJoinExt\", Fr.one, Fr.shift, inType, \"jacobian\", logger, loggerTxt);\n\n        promises.push( _fft(b1, false, \"jacobian\", outType, logger, loggerTxt));\n        promises.push( _fft(b2, false, \"jacobian\", outType, logger, loggerTxt));\n\n        const res1 = await Promise.all(promises);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n    async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        promises.push( _fft(b1, true, inType, \"jacobian\", logger, loggerTxt));\n        promises.push( _fft(b2, true, inType, \"jacobian\", logger, loggerTxt));\n\n        [b1, b2] = await Promise.all(promises);\n\n        const res1 = await _fftJoinExt(b1, b2, \"fftJoinExtInv\", Fr.one, Fr.shiftInv, \"jacobian\", outType, logger, loggerTxt);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n\n    async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const MIN_CHUNK_SIZE = 1<<4;\n\n        let fnName;\n        let fnIn2Mid, fnMid2Out;\n        let sOut, sIn, sMid;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            fnName = \"g1m_\"+fn;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g1m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            fnName = \"g2m_\"+fn;\n            sMid = G.F.n8*3;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g2m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n            sOut = Fr.n8;\n            sMid = Fr.n8;\n            fnName = \"frm_\" + fn;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sIn);\n        if (nPoints != 1 << (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let chunkSize = Math.floor(nPoints /tm.concurrency);\n        if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n        if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n\n        const opPromises = [];\n\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n\n            const firstChunk = Fr.mul(first, Fr.exp( inc, i));\n            const task = [];\n\n            const b1 = buff1.slice(i*sIn, (i+n)*sIn);\n            const b2 = buff2.slice(i*sIn, (i+n)*sIn);\n\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*n});\n            task.push({cmd: \"SET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOC\", var: 1, len: sMid*n});\n            task.push({cmd: \"SET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: n},\n                {var: 2},\n                {var: 3},\n                {val: Fr.s},\n            ]});\n            if (fnMid2Out) {\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sOut});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: n*sOut});\n            opPromises.push(\n                tm.queueAction(task).then( (r) => {\n                    if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);\n                    return r;\n                })\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (nPoints * sOut > 1<<28) {\n            fullBuffOut1 = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sOut);\n            fullBuffOut2 = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sOut);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sOut);\n            fullBuffOut2 = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    }\n\n\n    G.fft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, false, inType, outType, logger, loggerTxt);\n    };\n\n    G.ifft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, true, inType, outType, logger, loggerTxt);\n    };\n\n    G.lagrangeEvaluations = async function (buff, inType, outType, logger, loggerTxt) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n\n        let sIn;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = buff.byteLength /sIn;\n        const bits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints);\n\n        if ((2 ** bits)*sIn != buff.byteLength) {\n            if (logger) logger.error(\"lagrangeEvaluations iinvalid input size\");\n            throw new Error(\"lagrangeEvaluations invalid Input size\");\n        }\n\n        if (bits <= Fr.s) {\n            return await G.ifft(buff, inType, outType, logger, loggerTxt);\n        }\n\n        if (bits > Fr.s+1) {\n            if (logger) logger.error(\"lagrangeEvaluations input too big\");\n            throw new Error(\"lagrangeEvaluations input too big\");\n        }\n\n        let t0 = buff.slice(0, buff.byteLength/2);\n        let t1 = buff.slice(buff.byteLength/2, buff.byteLength);\n\n\n        const shiftToSmallM = Fr.exp(Fr.shift, nPoints/2);\n        const sConst = Fr.inv( Fr.sub(Fr.one, shiftToSmallM));\n\n        [t0, t1] = await _fftJoinExt(t0, t1, \"prepareLagrangeEvaluation\", sConst, Fr.shiftInv, inType, \"jacobian\", logger, loggerTxt + \" prep\");\n\n        const promises = [];\n\n        promises.push( _fft(t0, true, \"jacobian\", outType, logger, loggerTxt + \" t0\"));\n        promises.push( _fft(t1, true, \"jacobian\", outType, logger, loggerTxt + \" t1\"));\n\n        [t0, t1] = await Promise.all(promises);\n\n        let buffOut;\n        if (t0.byteLength > (1<<28)) {\n            buffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](t0.byteLength*2);\n        } else {\n            buffOut = new Uint8Array(t0.byteLength*2);\n        }\n\n        buffOut.set(t0);\n        buffOut.set(t1, t0.byteLength);\n\n        return buffOut;\n    };\n\n    G.fftMix = async function fftMix(buff) {\n        const sG = G.F.n8*3;\n        let fnName, fnFFTJoin;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftMix\";\n            fnFFTJoin = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftMix\";\n            fnFFTJoin = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        const power = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints);\n\n        let nChunks = 1 << (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(tm.concurrency);\n\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n        const powerChunk = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(pointsPerChunk);\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            for (let j=1; j<=powerChunk; j++) {\n                task.push({cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: pointsPerChunk},\n                    {val: j}\n                ]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        const chunks = [];\n        for (let i=0; i<result.length; i++) chunks[i] = result[i][0];\n\n\n        for (let i = powerChunk+1; i<=power; i++) {\n            const nGroups = 1 << (power - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsPerChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsPerChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n                    task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n                    opPromises.push(tm.queueAction(task));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        let fullBuffOut;\n        if (buff instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n            fullBuffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sG);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sG);\n        }\n        let p =0;\n        for (let i=0; i<nChunks; i++) {\n            fullBuffOut.set(chunks[i], p);\n            p+=chunks[i].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n\n    G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {\n        const sG = G.F.n8*3;\n        let fnName;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sG);\n        if (nPoints != 1 << (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let nChunks = 1 << (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(tm.concurrency);\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n\n            const firstChunk = Fr.mul(first, Fr.exp(inc, i*pointsPerChunk));\n            const b1 = buff1.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            const b2 = buff2.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: pointsPerChunk},\n                {var: 2},\n                {var: 3}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (buff1 instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n            fullBuffOut1 = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sG);\n            fullBuffOut2 = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sG);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sG);\n            fullBuffOut2 = new Uint8Array(nPoints*sG);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    };\n\n\n\n    G.fftFinal =  async function fftFinal(buff, factor) {\n        const sG = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnName, fnToAffine;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftFinal\";\n            fnToAffine = \"g1m_batchToAffine\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftFinal\";\n            fnToAffine = \"g2m_batchToAffine\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        if (nPoints != 1 << (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        const pointsPerChunk = Math.floor(nPoints / tm.concurrency);\n\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, (i*pointsPerChunk+n)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: factor});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {val: n},\n                {var: 1},\n            ]});\n            task.push({cmd: \"CALL\", fnName: fnToAffine, params: [\n                {var: 0},\n                {val: n},\n                {var: 0},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sGout});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buff instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n            fullBuffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](nPoints*sGout);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sGout);\n        }\n\n        let p =0;\n        for (let i=result.length-1; i>=0; i--) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfZmZ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2RTtBQUN0Qzs7O0FBR3hCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQkFBbUIsdURBQVk7QUFDL0I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwrQ0FBSTs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHVEQUFZO0FBQ25DLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSwwREFBZTs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwrQ0FBSTs7QUFFNUI7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyx3Q0FBd0MsVUFBVSxRQUFRLE1BQU0sYUFBYSxFQUFFLEdBQUcsUUFBUTtBQUMxRjtBQUNBLHVCQUF1Qiw4Q0FBOEM7QUFDckU7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0EsMkJBQTJCLHdDQUF3QyxNQUFNLEdBQUcsbUJBQW1CLEdBQUcsT0FBTyxFQUFFO0FBQzNHO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsMkJBQTJCLHdDQUF3QyxNQUFNLEdBQUcsbUJBQW1CLEdBQUcsT0FBTyxFQUFFO0FBQzNHOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFLCtCQUErQjtBQUMvQix5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsbUJBQW1CO0FBQzVDLHlCQUF5QixPQUFPO0FBQ2hDLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsK0JBQStCLHlDQUF5QyxNQUFNLEdBQUcsbUJBQW1CLEdBQUcsT0FBTyxFQUFFO0FBQ2hIO0FBQ0EsMkJBQTJCLG9EQUFvRDtBQUMvRSxjQUFjO0FBQ2QsMkJBQTJCLG1EQUFtRDtBQUM5RTtBQUNBO0FBQ0EsNENBQTRDLFVBQVUsUUFBUSxNQUFNLFdBQVcsRUFBRSxHQUFHLFFBQVE7QUFDNUY7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSx3QkFBd0IsWUFBWTs7QUFFcEMsa0NBQWtDLFNBQVM7QUFDM0Msd0NBQXdDLFVBQVUsU0FBUyxPQUFPLFFBQVEsRUFBRSxHQUFHLEtBQUs7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQiwwQ0FBMEM7QUFDekUsK0JBQStCLDBDQUEwQztBQUN6RSwrQkFBK0IscUNBQXFDO0FBQ3BFLCtCQUErQixtQ0FBbUM7QUFDbEUsK0JBQStCO0FBQy9CLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixtQkFBbUI7QUFDNUMseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsdUNBQXVDLG1DQUFtQztBQUMxRSx1Q0FBdUM7QUFDdkMsaUNBQWlDLE9BQU87QUFDeEMsaUNBQWlDLG1CQUFtQjtBQUNwRCxpQ0FBaUMsT0FBTztBQUN4Qyw4QkFBOEI7QUFDOUIsdUNBQXVDO0FBQ3ZDLGlDQUFpQyxPQUFPO0FBQ3hDLGlDQUFpQyxtQkFBbUI7QUFDcEQsaUNBQWlDLE9BQU87QUFDeEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSx1Q0FBdUMseUNBQXlDLE1BQU0sR0FBRyxtQkFBbUIsR0FBRyxPQUFPLEVBQUU7QUFDeEgsdUNBQXVDLHlDQUF5QyxNQUFNLEdBQUcsbUJBQW1CLEdBQUcsT0FBTyxFQUFFO0FBQ3hIO0FBQ0EsbUNBQW1DLG9EQUFvRDtBQUN2RixtQ0FBbUMsb0RBQW9EO0FBQ3ZGLHNCQUFzQjtBQUN0QixtQ0FBbUMsb0RBQW9EO0FBQ3ZGLG1DQUFtQyxvREFBb0Q7QUFDdkY7QUFDQTtBQUNBLG9EQUFvRCxVQUFVLFFBQVEsTUFBTSxRQUFRLEVBQUUsR0FBRyxPQUFPLEVBQUUsSUFBSSxHQUFHLFNBQVMsRUFBRSxFQUFFLEdBQUcsa0JBQWtCO0FBQzNJO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyw4QkFBOEIsc0JBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLHFEQUFTO0FBQ3JDLDBCQUEwQixxREFBUztBQUNuQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHVEQUFZO0FBQy9CLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFTO0FBQ25DLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIscURBQVM7QUFDbkMsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBSTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsV0FBVztBQUNqQyx3Q0FBd0MsVUFBVSxzQkFBc0IsRUFBRSxHQUFHLFFBQVE7QUFDckY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixrQ0FBa0M7QUFDekQsdUJBQXVCLDZCQUE2QjtBQUNwRCx1QkFBdUIsa0NBQWtDO0FBQ3pELHVCQUF1Qiw2QkFBNkI7QUFDcEQsdUJBQXVCLDBDQUEwQztBQUNqRSx1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0EsMkJBQTJCLHdDQUF3QyxNQUFNLEdBQUcsT0FBTyxHQUFHLE9BQU8sRUFBRTtBQUMvRiwyQkFBMkIsd0NBQXdDLE1BQU0sR0FBRyxPQUFPLEdBQUcsT0FBTyxFQUFFO0FBQy9GO0FBQ0EsdUJBQXVCO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixVQUFVO0FBQzNCLGNBQWM7QUFDZDtBQUNBLDJCQUEyQix5Q0FBeUMsTUFBTSxHQUFHLE9BQU8sR0FBRyxPQUFPLEVBQUU7QUFDaEcsMkJBQTJCLHlDQUF5QyxNQUFNLEdBQUcsT0FBTyxHQUFHLE9BQU8sRUFBRTtBQUNoRztBQUNBLHVCQUF1Qix3Q0FBd0M7QUFDL0QsdUJBQXVCLHdDQUF3QztBQUMvRDtBQUNBO0FBQ0EsZ0RBQWdELFVBQVUsb0JBQW9CLEVBQUUsR0FBRyxRQUFRO0FBQzNGO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFEQUFTO0FBQ3hDLCtCQUErQixxREFBUztBQUN4QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLCtDQUFJOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIscURBQVM7QUFDbkMsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiwrQ0FBSTs7QUFFMUIsMkJBQTJCLCtDQUFJOztBQUUvQjs7QUFFQTs7QUFFQSwyQkFBMkIsK0NBQUk7O0FBRS9CO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUM7QUFDeEQsMEJBQTBCLGVBQWU7QUFDekMsMkJBQTJCO0FBQzNCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixvQkFBb0I7QUFDekMscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBLHVCQUF1QixtREFBbUQ7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsaUJBQWlCOzs7QUFHdkMsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQiwwQ0FBMEM7QUFDekUsK0JBQStCLDBDQUEwQztBQUN6RSwrQkFBK0IscUNBQXFDO0FBQ3BFLCtCQUErQixtQ0FBbUM7QUFDbEUsK0JBQStCO0FBQy9CLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixvQkFBb0I7QUFDN0MseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QiwrQkFBK0IsbURBQW1EO0FBQ2xGLCtCQUErQixtREFBbUQ7QUFDbEY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHFEQUFTO0FBQ3JDLDhCQUE4QixxREFBUztBQUN2QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUFJO0FBQ2hDO0FBQ0E7O0FBRUEsMkJBQTJCLCtDQUFJO0FBQy9COztBQUVBOzs7QUFHQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQsdUJBQXVCLGtDQUFrQztBQUN6RCx1QkFBdUIsMENBQTBDO0FBQ2pFLHVCQUF1QixtQ0FBbUM7QUFDMUQsdUJBQXVCO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixvQkFBb0I7QUFDckMsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCx1QkFBdUIsbURBQW1EO0FBQzFFLHVCQUF1QixtREFBbUQ7QUFDMUU7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFTO0FBQ3RDLCtCQUErQixxREFBUztBQUN4QywrQkFBK0IscURBQVM7QUFDeEMsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QiwrQ0FBSTtBQUNoQztBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUM7QUFDeEQsdUJBQXVCLHNDQUFzQztBQUM3RCx1QkFBdUI7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsY0FBYztBQUNkLHVCQUF1QjtBQUN2QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixjQUFjO0FBQ2QsdUJBQXVCLHlDQUF5QztBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIscURBQVM7QUFDckMsOEJBQThCLHFEQUFTO0FBQ3ZDLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2VuZ2luZV9mZnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtsb2cyLCBidWZmUmV2ZXJzZUJpdHMsIGFycmF5MmJ1ZmZlciwgYnVmZmVyMmFycmF5fSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IEJpZ0J1ZmZlciBmcm9tIFwiLi9iaWdidWZmZXIuanNcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZGVChjdXJ2ZSwgZ3JvdXBOYW1lKSB7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCB0bSA9IEcudG07XG4gICAgYXN5bmMgZnVuY3Rpb24gX2ZmdChidWZmLCBpbnZlcnNlLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG5cbiAgICAgICAgaW5UeXBlID0gaW5UeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIG91dFR5cGUgPSBvdXRUeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIGNvbnN0IE1BWF9CSVRTX1RIUkVBRCA9IDE0O1xuXG4gICAgICAgIGxldCBzSW4sIHNNaWQsIHNPdXQsIGZuSW4yTWlkLCBmbk1pZDJPdXQsIGZuRkZUTWl4LCBmbkZGVEpvaW4sIGZuRkZURmluYWw7XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgICAgICBmbkluMk1pZCA9IFwiZzFtX2JhdGNoVG9KYWNvYmlhblwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNNaWQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICAgICAgZm5GRlRGaW5hbCA9IFwiZzFtX2ZmdEZpbmFsXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbkZGVEpvaW4gPSBcImcxbV9mZnRKb2luXCI7XG4gICAgICAgICAgICBmbkZGVE1peCA9IFwiZzFtX2ZmdE1peFwiO1xuXG4gICAgICAgICAgICBpZiAob3V0VHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgICAgIGZuTWlkMk91dCA9IFwiZzFtX2JhdGNoVG9BZmZpbmVcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5JbjJNaWQgPSBcImcybV9iYXRjaFRvSmFjb2JpYW5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzTWlkID0gRy5GLm44KjM7XG4gICAgICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgICAgIGZuRkZURmluYWwgPSBcImcybV9mZnRGaW5hbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm5GRlRKb2luID0gXCJnMm1fZmZ0Sm9pblwiO1xuICAgICAgICAgICAgZm5GRlRNaXggPSBcImcybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGlmIChvdXRUeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5NaWQyT3V0ID0gXCJnMm1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRnJcIikge1xuICAgICAgICAgICAgc0luID0gRy5uODtcbiAgICAgICAgICAgIHNNaWQgPSBHLm44O1xuICAgICAgICAgICAgc091dCA9IEcubjg7XG4gICAgICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgICAgIGZuRkZURmluYWwgPSBcImZybV9mZnRGaW5hbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm5GRlRNaXggPSBcImZybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZnJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGV0IHJldHVybkFycmF5ID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmYpKSB7XG4gICAgICAgICAgICBidWZmID0gYXJyYXkyYnVmZmVyKGJ1ZmYsIHNJbik7XG4gICAgICAgICAgICByZXR1cm5BcnJheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmID0gYnVmZi5zbGljZSgwLCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYuYnl0ZUxlbmd0aCAvIHNJbjtcbiAgICAgICAgY29uc3QgYml0cyA9IGxvZzIoblBvaW50cyk7XG5cbiAgICAgICAgaWYgICgoMSA8PCBiaXRzKSAhPSBuUG9pbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmZnQgbXVzdCBiZSBtdWx0aXBsZSBvZiAyXCIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXRzID09IEZyLnMgKzEpIHtcbiAgICAgICAgICAgIGxldCBidWZmT3V0O1xuXG4gICAgICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXQgPSAgYXdhaXQgX2ZmdEV4dEludihidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZk91dCA9ICBhd2FpdCBfZmZ0RXh0KGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmV0dXJuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyMmFycmF5KGJ1ZmZPdXQsIHNPdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZk91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnY7XG4gICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICBpbnYgPSBGci5pbnYoRnIuZShuUG9pbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYnVmZk91dDtcblxuICAgICAgICBidWZmUmV2ZXJzZUJpdHMoYnVmZiwgc0luKTtcblxuICAgICAgICBsZXQgY2h1bmtzO1xuICAgICAgICBsZXQgcG9pbnRzSW5DaHVuayA9IE1hdGgubWluKDEgPDwgTUFYX0JJVFNfVEhSRUFELCBuUG9pbnRzKTtcbiAgICAgICAgbGV0IG5DaHVua3MgPSBuUG9pbnRzIC8gcG9pbnRzSW5DaHVuaztcblxuICAgICAgICB3aGlsZSAoKG5DaHVua3MgPCB0bS5jb25jdXJyZW5jeSkmJihwb2ludHNJbkNodW5rPj0xNikpIHtcbiAgICAgICAgICAgIG5DaHVua3MgKj0gMjtcbiAgICAgICAgICAgIHBvaW50c0luQ2h1bmsgLz0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGwyQ2h1bmsgPSBsb2cyKHBvaW50c0luQ2h1bmspO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPCBuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgJHtsb2dnZXJUeHR9OiBmZnQgJHtiaXRzfSBtaXggc3RhcnQ6ICR7aX0vJHtuQ2h1bmtzfWApO1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAwLCBsZW46IHNNaWQqcG9pbnRzSW5DaHVua30pO1xuICAgICAgICAgICAgY29uc3QgYnVmZkNodW5rID0gYnVmZi5zbGljZSggKHBvaW50c0luQ2h1bmsgKiBpKSpzSW4sIChwb2ludHNJbkNodW5rICogKGkrMSkpKnNJbik7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJTRVRcIiwgdmFyOiAwLCBidWZmOiBidWZmQ2h1bmt9KTtcbiAgICAgICAgICAgIGlmIChmbkluMk1pZCkge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuSW4yTWlkLCBwYXJhbXM6IFt7dmFyOjB9LCB7dmFsOiBwb2ludHNJbkNodW5rfSwge3ZhcjogMH1dfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBqPTE7IGo8PWwyQ2h1bms7aisrKSB7XG4gICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6Zm5GRlRNaXgsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFsOiBqfV19KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGwyQ2h1bms9PWJpdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm5GRlRGaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IGludn0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5GRlRGaW5hbCwgIHBhcmFtczpbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c0luQ2h1bmt9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZuTWlkMk91dCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFyOiAwfV19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAwLCBsZW46IHBvaW50c0luQ2h1bmsqc091dH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OjAsIHZhcjogMCwgbGVuOiBzTWlkKnBvaW50c0luQ2h1bmt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godG0ucXVldWVBY3Rpb24odGFzaykudGhlbiggKHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYCR7bG9nZ2VyVHh0fTogZmZ0ICR7Yml0c30gbWl4IGVuZDogJHtpfS8ke25DaHVua3N9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBjaHVua3MgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPCBuQ2h1bmtzOyBpKyspIGNodW5rc1tpXSA9IGNodW5rc1tpXVswXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbDJDaHVuaysxOyAgIGk8PWJpdHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGAke2xvZ2dlclR4dH06IGZmdCAgJHtiaXRzfSAgam9pbjogJHtpfS8ke2JpdHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuR3JvdXBzID0gMSA8PCAoYml0cyAtIGkpO1xuICAgICAgICAgICAgY29uc3QgbkNodW5rc1Blckdyb3VwID0gbkNodW5rcyAvIG5Hcm91cHM7XG4gICAgICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8bkdyb3VwczsgaisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaz0wOyBrIDxuQ2h1bmtzUGVyR3JvdXAvMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gRnIuZXhwKCBGci53W2ldLCBrKnBvaW50c0luQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmMgPSBGci53W2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvMSA9IGoqbkNodW5rc1Blckdyb3VwICsgaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzIgPSBqKm5DaHVua3NQZXJHcm91cCArIGsgKyBuQ2h1bmtzUGVyR3JvdXAvMjtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogY2h1bmtzW28xXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IGNodW5rc1tvMl19KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAyLCBidWZmOiBmaXJzdH0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDMsIGJ1ZmY6IGluY30pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5GRlRKb2luLCAgcGFyYW1zOltcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBwb2ludHNJbkNodW5rfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogM31cbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaT09Yml0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuRkZURmluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDQsIGJ1ZmY6IGludn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkZGVEZpbmFsLCAgcGFyYW1zOltcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c0luQ2h1bmt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiA0fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuRkZURmluYWwsICBwYXJhbXM6W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogcG9pbnRzSW5DaHVua30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDR9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbk1pZDJPdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFyOiAwfV19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MX0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFyOiAxfV19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBwb2ludHNJbkNodW5rKnNPdXR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDEsIHZhcjogMSwgbGVuOiBwb2ludHNJbkNodW5rKnNPdXR9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBwb2ludHNJbkNodW5rKnNNaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDEsIHZhcjogMSwgbGVuOiBwb2ludHNJbkNodW5rKnNNaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcFByb21pc2VzLnB1c2godG0ucXVldWVBY3Rpb24odGFzaykudGhlbiggKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgJHtsb2dnZXJUeHR9OiBmZnQgJHtiaXRzfSBqb2luICAke2l9LyR7Yml0c30gICR7aisxfS8ke25Hcm91cHN9ICR7a30vJHtuQ2h1bmtzUGVyR3JvdXAvMn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxuR3JvdXBzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrPTA7IGsgPG5DaHVua3NQZXJHcm91cC8yOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzEgPSBqKm5DaHVua3NQZXJHcm91cCArIGs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8yID0gaipuQ2h1bmtzUGVyR3JvdXAgKyBrICsgbkNodW5rc1Blckdyb3VwLzI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc0NodW5rID0gcmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1tvMV0gPSByZXNDaHVua1swXTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW28yXSA9IHJlc0NodW5rWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNPdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZk91dCA9IG5ldyBVaW50OEFycmF5KG5Qb2ludHMqc091dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQuc2V0KGNodW5rc1swXS5zbGljZSgocG9pbnRzSW5DaHVuay0xKSpzT3V0KSk7XG4gICAgICAgICAgICBsZXQgcD0gc091dDtcbiAgICAgICAgICAgIGZvciAobGV0IGk9bkNodW5rcy0xOyBpPjA7IGktLSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXQuc2V0KGNodW5rc1tpXSwgcCk7XG4gICAgICAgICAgICAgICAgcCArPSBwb2ludHNJbkNodW5rKnNPdXQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNodW5rc1tpXTsgIC8vIExpYmVyYXRlIG1lbVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZk91dC5zZXQoY2h1bmtzWzBdLnNsaWNlKDAsIChwb2ludHNJbkNodW5rLTEpKnNPdXQpLCBwKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjaHVua3NbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkNodW5rczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmZk91dC5zZXQoY2h1bmtzW2ldLCBwb2ludHNJbkNodW5rKnNPdXQqaSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNodW5rc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR1cm5BcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjJhcnJheShidWZmT3V0LCBzT3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmT3V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX2ZmdEV4dChidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIGxldCBiMSwgYjI7XG4gICAgICAgIGIxID0gYnVmZi5zbGljZSggMCAsIGJ1ZmYuYnl0ZUxlbmd0aC8yKTtcbiAgICAgICAgYjIgPSBidWZmLnNsaWNlKCBidWZmLmJ5dGVMZW5ndGgvMiwgYnVmZi5ieXRlTGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIFtiMSwgYjJdID0gYXdhaXQgX2ZmdEpvaW5FeHQoYjEsIGIyLCBcImZmdEpvaW5FeHRcIiwgRnIub25lLCBGci5zaGlmdCwgaW5UeXBlLCBcImphY29iaWFuXCIsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcblxuICAgICAgICBwcm9taXNlcy5wdXNoKCBfZmZ0KGIxLCBmYWxzZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCkpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKCBfZmZ0KGIyLCBmYWxzZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCkpO1xuXG4gICAgICAgIGNvbnN0IHJlczEgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgICAgbGV0IGJ1ZmZPdXQ7XG4gICAgICAgIGlmIChyZXMxWzBdLmJ5dGVMZW5ndGggPiAoMTw8MjgpKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihyZXMxWzBdLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkocmVzMVswXS5ieXRlTGVuZ3RoKjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZk91dC5zZXQocmVzMVswXSk7XG4gICAgICAgIGJ1ZmZPdXQuc2V0KHJlczFbMV0sIHJlczFbMF0uYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZPdXQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX2ZmdEV4dEludihidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIGxldCBiMSwgYjI7XG4gICAgICAgIGIxID0gYnVmZi5zbGljZSggMCAsIGJ1ZmYuYnl0ZUxlbmd0aC8yKTtcbiAgICAgICAgYjIgPSBidWZmLnNsaWNlKCBidWZmLmJ5dGVMZW5ndGgvMiwgYnVmZi5ieXRlTGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIHByb21pc2VzLnB1c2goIF9mZnQoYjEsIHRydWUsIGluVHlwZSwgXCJqYWNvYmlhblwiLCBsb2dnZXIsIGxvZ2dlclR4dCkpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKCBfZmZ0KGIyLCB0cnVlLCBpblR5cGUsIFwiamFjb2JpYW5cIiwgbG9nZ2VyLCBsb2dnZXJUeHQpKTtcblxuICAgICAgICBbYjEsIGIyXSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICBjb25zdCByZXMxID0gYXdhaXQgX2ZmdEpvaW5FeHQoYjEsIGIyLCBcImZmdEpvaW5FeHRJbnZcIiwgRnIub25lLCBGci5zaGlmdEludiwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCk7XG5cbiAgICAgICAgbGV0IGJ1ZmZPdXQ7XG4gICAgICAgIGlmIChyZXMxWzBdLmJ5dGVMZW5ndGggPiAoMTw8MjgpKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihyZXMxWzBdLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkocmVzMVswXS5ieXRlTGVuZ3RoKjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZk91dC5zZXQocmVzMVswXSk7XG4gICAgICAgIGJ1ZmZPdXQuc2V0KHJlczFbMV0sIHJlczFbMF0uYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZPdXQ7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBfZmZ0Sm9pbkV4dChidWZmMSwgYnVmZjIsIGZuLCBmaXJzdCwgaW5jLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIGNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTw8MTY7XG4gICAgICAgIGNvbnN0IE1JTl9DSFVOS19TSVpFID0gMTw8NDtcblxuICAgICAgICBsZXQgZm5OYW1lO1xuICAgICAgICBsZXQgZm5JbjJNaWQsIGZuTWlkMk91dDtcbiAgICAgICAgbGV0IHNPdXQsIHNJbiwgc01pZDtcblxuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5JbjJNaWQgPSBcImcxbV9iYXRjaFRvSmFjb2JpYW5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzTWlkID0gRy5GLm44KjM7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9cIitmbjtcbiAgICAgICAgICAgIGlmIChvdXRUeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBmbk1pZDJPdXQgPSBcImcxbV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5JbjJNaWQgPSBcImcybV9iYXRjaFRvSmFjb2JpYW5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcybV9cIitmbjtcbiAgICAgICAgICAgIHNNaWQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIGlmIChvdXRUeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBmbk1pZDJPdXQgPSBcImcybV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICAgICAgc091dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRnJcIikge1xuICAgICAgICAgICAgc0luID0gRnIubjg7XG4gICAgICAgICAgICBzT3V0ID0gRnIubjg7XG4gICAgICAgICAgICBzTWlkID0gRnIubjg7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImZybV9cIiArIGZuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmMS5ieXRlTGVuZ3RoICE9IGJ1ZmYyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnVmZmVyIHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoYnVmZjEuYnl0ZUxlbmd0aCAvIHNJbik7XG4gICAgICAgIGlmIChuUG9pbnRzICE9IDEgPDwgbG9nMihuUG9pbnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNodW5rU2l6ZSA9IE1hdGguZmxvb3IoblBvaW50cyAvdG0uY29uY3VycmVuY3kpO1xuICAgICAgICBpZiAoY2h1bmtTaXplIDwgTUlOX0NIVU5LX1NJWkUpIGNodW5rU2l6ZSA9IE1JTl9DSFVOS19TSVpFO1xuICAgICAgICBpZiAoY2h1bmtTaXplID4gTUFYX0NIVU5LX1NJWkUpIGNodW5rU2l6ZSA9IE1BWF9DSFVOS19TSVpFO1xuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSArPSBjaHVua1NpemUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgJHtsb2dnZXJUeHR9OiBmZnRKb2luRXh0IFN0YXJ0OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG49IE1hdGgubWluKG5Qb2ludHMgLSBpLCBjaHVua1NpemUpO1xuXG4gICAgICAgICAgICBjb25zdCBmaXJzdENodW5rID0gRnIubXVsKGZpcnN0LCBGci5leHAoIGluYywgaSkpO1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgICAgICBjb25zdCBiMSA9IGJ1ZmYxLnNsaWNlKGkqc0luLCAoaStuKSpzSW4pO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBidWZmMi5zbGljZShpKnNJbiwgKGkrbikqc0luKTtcblxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAwLCBsZW46IHNNaWQqbn0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiU0VUXCIsIHZhcjogMCwgYnVmZjogYjF9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMSwgbGVuOiBzTWlkKm59KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIlNFVFwiLCB2YXI6IDEsIGJ1ZmY6IGIyfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDIsIGJ1ZmY6IGZpcnN0Q2h1bmt9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMywgYnVmZjogaW5jfSk7XG4gICAgICAgICAgICBpZiAoZm5JbjJNaWQpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbkluMk1pZCwgcGFyYW1zOiBbe3ZhcjowfSwge3ZhbDogbn0sIHt2YXI6IDB9XX0pO1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuSW4yTWlkLCBwYXJhbXM6IFt7dmFyOjF9LCB7dmFsOiBufSwge3ZhcjogMX1dfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5OYW1lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAzfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBGci5zfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIGlmIChmbk1pZDJPdXQpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IG59LCB7dmFyOiAwfV19KTtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbk1pZDJPdXQsIHBhcmFtczogW3t2YXI6MX0sIHt2YWw6IG59LCB7dmFyOiAxfV19KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBuKnNPdXR9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDEsIHZhcjogMSwgbGVuOiBuKnNPdXR9KTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKS50aGVuKCAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYCR7bG9nZ2VyVHh0fTogZmZ0Sm9pbkV4dCBFbmQ6ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDE7XG4gICAgICAgIGxldCBmdWxsQnVmZk91dDI7XG4gICAgICAgIGlmIChuUG9pbnRzICogc091dCA+IDE8PDI4KSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc091dCk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc091dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNPdXQpO1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQyID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIuc2V0KHJlc3VsdFtpXVsxXSwgcCk7XG4gICAgICAgICAgICBwKz1yZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZnVsbEJ1ZmZPdXQxLCBmdWxsQnVmZk91dDJdO1xuICAgIH1cblxuXG4gICAgRy5mZnQgPSBhc3luYyBmdW5jdGlvbihidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfZmZ0KGJ1ZmYsIGZhbHNlLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcbiAgICB9O1xuXG4gICAgRy5pZmZ0ID0gYXN5bmMgZnVuY3Rpb24oYnVmZiwgaW5UeXBlLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgX2ZmdChidWZmLCB0cnVlLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcbiAgICB9O1xuXG4gICAgRy5sYWdyYW5nZUV2YWx1YXRpb25zID0gYXN5bmMgZnVuY3Rpb24gKGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpIHtcbiAgICAgICAgaW5UeXBlID0gaW5UeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIG91dFR5cGUgPSBvdXRUeXBlIHx8IFwiYWZmaW5lXCI7XG5cbiAgICAgICAgbGV0IHNJbjtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNJbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRnJcIikge1xuICAgICAgICAgICAgc0luID0gRnIubjg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYuYnl0ZUxlbmd0aCAvc0luO1xuICAgICAgICBjb25zdCBiaXRzID0gbG9nMihuUG9pbnRzKTtcblxuICAgICAgICBpZiAoKDIgKiogYml0cykqc0luICE9IGJ1ZmYuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwibGFncmFuZ2VFdmFsdWF0aW9ucyBpaW52YWxpZCBpbnB1dCBzaXplXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGFncmFuZ2VFdmFsdWF0aW9ucyBpbnZhbGlkIElucHV0IHNpemVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0cyA8PSBGci5zKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgRy5pZmZ0KGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdHMgPiBGci5zKzEpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcImxhZ3JhbmdlRXZhbHVhdGlvbnMgaW5wdXQgdG9vIGJpZ1wiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxhZ3JhbmdlRXZhbHVhdGlvbnMgaW5wdXQgdG9vIGJpZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0MCA9IGJ1ZmYuc2xpY2UoMCwgYnVmZi5ieXRlTGVuZ3RoLzIpO1xuICAgICAgICBsZXQgdDEgPSBidWZmLnNsaWNlKGJ1ZmYuYnl0ZUxlbmd0aC8yLCBidWZmLmJ5dGVMZW5ndGgpO1xuXG5cbiAgICAgICAgY29uc3Qgc2hpZnRUb1NtYWxsTSA9IEZyLmV4cChGci5zaGlmdCwgblBvaW50cy8yKTtcbiAgICAgICAgY29uc3Qgc0NvbnN0ID0gRnIuaW52KCBGci5zdWIoRnIub25lLCBzaGlmdFRvU21hbGxNKSk7XG5cbiAgICAgICAgW3QwLCB0MV0gPSBhd2FpdCBfZmZ0Sm9pbkV4dCh0MCwgdDEsIFwicHJlcGFyZUxhZ3JhbmdlRXZhbHVhdGlvblwiLCBzQ29uc3QsIEZyLnNoaWZ0SW52LCBpblR5cGUsIFwiamFjb2JpYW5cIiwgbG9nZ2VyLCBsb2dnZXJUeHQgKyBcIiBwcmVwXCIpO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICAgICAgcHJvbWlzZXMucHVzaCggX2ZmdCh0MCwgdHJ1ZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCArIFwiIHQwXCIpKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCggX2ZmdCh0MSwgdHJ1ZSwgXCJqYWNvYmlhblwiLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCArIFwiIHQxXCIpKTtcblxuICAgICAgICBbdDAsIHQxXSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICBsZXQgYnVmZk91dDtcbiAgICAgICAgaWYgKHQwLmJ5dGVMZW5ndGggPiAoMTw8MjgpKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcih0MC5ieXRlTGVuZ3RoKjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZk91dCA9IG5ldyBVaW50OEFycmF5KHQwLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmT3V0LnNldCh0MCk7XG4gICAgICAgIGJ1ZmZPdXQuc2V0KHQxLCB0MC5ieXRlTGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gYnVmZk91dDtcbiAgICB9O1xuXG4gICAgRy5mZnRNaXggPSBhc3luYyBmdW5jdGlvbiBmZnRNaXgoYnVmZikge1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCozO1xuICAgICAgICBsZXQgZm5OYW1lLCBmbkZGVEpvaW47XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZzFtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZzJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJGclwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImZybV9mZnRNaXhcIjtcbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZnJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuUG9pbnRzID0gTWF0aC5mbG9vcihidWZmLmJ5dGVMZW5ndGggLyBzRyk7XG4gICAgICAgIGNvbnN0IHBvd2VyID0gbG9nMihuUG9pbnRzKTtcblxuICAgICAgICBsZXQgbkNodW5rcyA9IDEgPDwgbG9nMih0bS5jb25jdXJyZW5jeSk7XG5cbiAgICAgICAgaWYgKG5Qb2ludHMgPD0gbkNodW5rcyoyKSBuQ2h1bmtzID0gMTtcblxuICAgICAgICBjb25zdCBwb2ludHNQZXJDaHVuayA9IG5Qb2ludHMgLyBuQ2h1bmtzO1xuXG4gICAgICAgIGNvbnN0IHBvd2VyQ2h1bmsgPSBsb2cyKHBvaW50c1BlckNodW5rKTtcblxuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBidWZmLnNsaWNlKChpKiBwb2ludHNQZXJDaHVuaykqc0csICgoaSsxKSogcG9pbnRzUGVyQ2h1bmspKnNHKTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYn0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0xOyBqPD1wb3dlckNodW5rOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5OYW1lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c1BlckNodW5rfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhbDogan1cbiAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDAsIGxlbjogcG9pbnRzUGVyQ2h1bmsqc0d9KTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSBjaHVua3NbaV0gPSByZXN1bHRbaV1bMF07XG5cblxuICAgICAgICBmb3IgKGxldCBpID0gcG93ZXJDaHVuaysxOyBpPD1wb3dlcjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuR3JvdXBzID0gMSA8PCAocG93ZXIgLSBpKTtcbiAgICAgICAgICAgIGNvbnN0IG5DaHVua3NQZXJHcm91cCA9IG5DaHVua3MgLyBuR3JvdXBzO1xuICAgICAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5Hcm91cHM7IGorKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGs9MDsgayA8bkNodW5rc1Blckdyb3VwLzI7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IEZyLmV4cCggRnIud1tpXSwgaypwb2ludHNQZXJDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluYyA9IEZyLndbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8xID0gaipuQ2h1bmtzUGVyR3JvdXAgKyBrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvMiA9IGoqbkNodW5rc1Blckdyb3VwICsgayArIG5DaHVua3NQZXJHcm91cC8yO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBjaHVua3NbbzFdfSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogY2h1bmtzW28yXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDIsIGJ1ZmY6IGZpcnN0fSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMywgYnVmZjogaW5jfSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkZGVEpvaW4sICBwYXJhbXM6W1xuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c1BlckNodW5rfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogM31cbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDAsIGxlbjogcG9pbnRzUGVyQ2h1bmsqc0d9KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMSwgdmFyOiAxLCBsZW46IHBvaW50c1BlckNodW5rKnNHfSk7XG4gICAgICAgICAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaCh0bS5xdWV1ZUFjdGlvbih0YXNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxuR3JvdXBzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrPTA7IGsgPG5DaHVua3NQZXJHcm91cC8yOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzEgPSBqKm5DaHVua3NQZXJHcm91cCArIGs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8yID0gaipuQ2h1bmtzUGVyR3JvdXAgKyBrICsgbkNodW5rc1Blckdyb3VwLzI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc0NodW5rID0gcmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1tvMV0gPSByZXNDaHVua1swXTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW28yXSA9IHJlc0NodW5rWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDtcbiAgICAgICAgaWYgKGJ1ZmYgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNHKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzRyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHAgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0LnNldChjaHVua3NbaV0sIHApO1xuICAgICAgICAgICAgcCs9Y2h1bmtzW2ldLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVsbEJ1ZmZPdXQ7XG4gICAgfTtcblxuICAgIEcuZmZ0Sm9pbiA9IGFzeW5jIGZ1bmN0aW9uIGZmdEpvaW4oYnVmZjEsIGJ1ZmYyLCBmaXJzdCwgaW5jKSB7XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjM7XG4gICAgICAgIGxldCBmbk5hbWU7XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9mZnRKb2luXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgZm5OYW1lID0gXCJnMm1fZmZ0Sm9pblwiO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkZyXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZnJtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnVmZjEuYnl0ZUxlbmd0aCAhPSBidWZmMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ1ZmZlciBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmYxLmJ5dGVMZW5ndGggLyBzRyk7XG4gICAgICAgIGlmIChuUG9pbnRzICE9IDEgPDwgbG9nMihuUG9pbnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5DaHVua3MgPSAxIDw8IGxvZzIodG0uY29uY3VycmVuY3kpO1xuICAgICAgICBpZiAoblBvaW50cyA8PSBuQ2h1bmtzKjIpIG5DaHVua3MgPSAxO1xuXG4gICAgICAgIGNvbnN0IHBvaW50c1BlckNodW5rID0gblBvaW50cyAvIG5DaHVua3M7XG5cblxuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcblxuICAgICAgICAgICAgY29uc3QgZmlyc3RDaHVuayA9IEZyLm11bChmaXJzdCwgRnIuZXhwKGluYywgaSpwb2ludHNQZXJDaHVuaykpO1xuICAgICAgICAgICAgY29uc3QgYjEgPSBidWZmMS5zbGljZSgoaSogcG9pbnRzUGVyQ2h1bmspKnNHLCAoKGkrMSkqIHBvaW50c1BlckNodW5rKSpzRyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGJ1ZmYyLnNsaWNlKChpKiBwb2ludHNQZXJDaHVuaykqc0csICgoaSsxKSogcG9pbnRzUGVyQ2h1bmspKnNHKTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYjF9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYjJ9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMiwgYnVmZjogZmlyc3RDaHVua30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAzLCBidWZmOiBpbmN9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk5hbWUsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c1BlckNodW5rfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAzfVxuICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAwLCBsZW46IHBvaW50c1BlckNodW5rKnNHfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAxLCB2YXI6IDEsIGxlbjogcG9pbnRzUGVyQ2h1bmsqc0d9KTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICB9XG5cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgZnVsbEJ1ZmZPdXQxO1xuICAgICAgICBsZXQgZnVsbEJ1ZmZPdXQyO1xuICAgICAgICBpZiAoYnVmZjEgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0MSA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzRyk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQxID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzRyk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNHKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIuc2V0KHJlc3VsdFtpXVsxXSwgcCk7XG4gICAgICAgICAgICBwKz1yZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZnVsbEJ1ZmZPdXQxLCBmdWxsQnVmZk91dDJdO1xuICAgIH07XG5cblxuXG4gICAgRy5mZnRGaW5hbCA9ICBhc3luYyBmdW5jdGlvbiBmZnRGaW5hbChidWZmLCBmYWN0b3IpIHtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMztcbiAgICAgICAgY29uc3Qgc0dvdXQgPSBHLkYubjgqMjtcbiAgICAgICAgbGV0IGZuTmFtZSwgZm5Ub0FmZmluZTtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX2ZmdEZpbmFsXCI7XG4gICAgICAgICAgICBmblRvQWZmaW5lID0gXCJnMW1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkcyXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZzJtX2ZmdEZpbmFsXCI7XG4gICAgICAgICAgICBmblRvQWZmaW5lID0gXCJnMm1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmYuYnl0ZUxlbmd0aCAvIHNHKTtcbiAgICAgICAgaWYgKG5Qb2ludHMgIT0gMSA8PCBsb2cyKG5Qb2ludHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb2ludHNQZXJDaHVuayA9IE1hdGguZmxvb3IoblBvaW50cyAvIHRtLmNvbmN1cnJlbmN5KTtcblxuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0bS5jb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGlmIChpPCB0bS5jb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IHBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqcG9pbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobj09MCkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgICAgICBjb25zdCBiID0gYnVmZi5zbGljZSgoaSogcG9pbnRzUGVyQ2h1bmspKnNHLCAoaSpwb2ludHNQZXJDaHVuaytuKSpzRyk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJ9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogZmFjdG9yfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5OYW1lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmblRvQWZmaW5lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBuKnNHb3V0fSk7XG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgdG0ucXVldWVBY3Rpb24odGFzaylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDtcbiAgICAgICAgaWYgKGJ1ZmYgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNHb3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzR291dCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcCA9MDtcbiAgICAgICAgZm9yIChsZXQgaT1yZXN1bHQubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgICAgICBwKz1yZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdWxsQnVmZk91dDtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_fft.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_multiexp.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine_multiexp.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildMultiexp)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js\");\n\n\nconst pTSizes = [\n    1 ,  1,  1,  1,    2,  3,  4,  5,\n    6 ,  7,  7,  8,    9, 10, 11, 12,\n    13, 13, 14, 15,   16, 16, 17, 17,\n    17, 17, 17, 17,   17, 17, 17, 17\n];\n\nfunction buildMultiexp(curve, groupName) {\n    const G = curve[groupName];\n    const tm = G.tm;\n    async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {\n        if ( ! (buffBases instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n        }\n        if ( ! (buffScalars instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n        }\n        inType = inType || \"affine\";\n\n        let sGIn;\n        let fnName;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                fnName = \"g1m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g1m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                fnName = \"g2m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g2m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff: buffBases},\n                {cmd: \"ALLOCSET\", var: 1, buff: buffScalars},\n                {cmd: \"ALLOC\", var: 2, len: G.F.n8*3},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {var: 1},\n                    {val: sScalar},\n                    {val: nPoints},\n                    {val: i*bitChunkSize},\n                    {val: Math.min(sScalar*8 - i*bitChunkSize, bitChunkSize)},\n                    {var: 2}\n                ]},\n                {cmd: \"GET\", out: 0, var: 2, len: G.F.n8*3}\n            ];\n            opPromises.push(\n                G.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            if (!G.isZero(res)) {\n                for (let j=0; j<bitChunkSize; j++) res = G.double(res);\n            }\n            res = G.add(res, result[i][0]);\n        }\n\n        return res;\n    }\n\n    async function _multiExp(buffBases, buffScalars, inType, logger, logText) {\n        const MAX_CHUNK_SIZE = 1 << 22;\n        const MIN_CHUNK_SIZE = 1 << 10;\n        let sGIn;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.log2)(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        let chunkSize;\n        chunkSize = Math.floor(nPoints / (tm.concurrency /nChunks));\n        if (chunkSize>MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n        if (chunkSize<MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n\n        const opPromises = [];\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n            const buffBasesChunk = buffBases.slice(i*sGIn, (i+n)*sGIn);\n            const buffScalarsChunk = buffScalars.slice(i*sScalar, (i+n)*sScalar);\n            opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then( (r) => {\n                if (logger) logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);\n                return r;\n            }));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            res = G.add(res, result[i]);\n        }\n\n        return res;\n    }\n\n    G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"jacobian\", logger, logText);\n    };\n    G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"affine\", logger, logText);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfbXVsdGlleHAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pELCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQywrQ0FBSTtBQUN6Qzs7QUFFQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0EsaUJBQWlCLHlDQUF5QztBQUMxRCxpQkFBaUIsMkNBQTJDO0FBQzVELGlCQUFpQixvQ0FBb0M7QUFDckQsaUJBQWlCO0FBQ2pCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixhQUFhO0FBQ2xDLHFCQUFxQixhQUFhO0FBQ2xDLHFCQUFxQixvQkFBb0I7QUFDekMscUJBQXFCLHdEQUF3RDtBQUM3RSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsK0NBQUk7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsV0FBVztBQUNqQyx3REFBd0QsUUFBUSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFFBQVEsSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUNuRjtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2VuZ2luZV9tdWx0aWV4cC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsb2cyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcblxuY29uc3QgcFRTaXplcyA9IFtcbiAgICAxICwgIDEsICAxLCAgMSwgICAgMiwgIDMsICA0LCAgNSxcbiAgICA2ICwgIDcsICA3LCAgOCwgICAgOSwgMTAsIDExLCAxMixcbiAgICAxMywgMTMsIDE0LCAxNSwgICAxNiwgMTYsIDE3LCAxNyxcbiAgICAxNywgMTcsIDE3LCAxNywgICAxNywgMTcsIDE3LCAxN1xuXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRNdWx0aWV4cChjdXJ2ZSwgZ3JvdXBOYW1lKSB7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3QgdG0gPSBHLnRtO1xuICAgIGFzeW5jIGZ1bmN0aW9uIF9tdWx0aUV4cENodW5rKGJ1ZmZCYXNlcywgYnVmZlNjYWxhcnMsIGluVHlwZSwgbG9nZ2VyLCBsb2dUZXh0KSB7XG4gICAgICAgIGlmICggISAoYnVmZkJhc2VzIGluc3RhbmNlb2YgVWludDhBcnJheSkgKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYCR7bG9nVGV4dH0gX211bHRpRXhwQ2h1bmsgYnVmZkJhc2VzIGlzIG5vdCBVaW50OEFycmF5YCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bG9nVGV4dH0gX211bHRpRXhwQ2h1bmsgYnVmZkJhc2VzIGlzIG5vdCBVaW50OEFycmF5YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhIChidWZmU2NhbGFycyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGAke2xvZ1RleHR9IF9tdWx0aUV4cENodW5rIGJ1ZmZTY2FsYXJzIGlzIG5vdCBVaW50OEFycmF5YCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bG9nVGV4dH0gX211bHRpRXhwQ2h1bmsgYnVmZlNjYWxhcnMgaXMgbm90IFVpbnQ4QXJyYXlgKTtcbiAgICAgICAgfVxuICAgICAgICBpblR5cGUgPSBpblR5cGUgfHwgXCJhZmZpbmVcIjtcblxuICAgICAgICBsZXQgc0dJbjtcbiAgICAgICAgbGV0IGZuTmFtZTtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX211bHRpZXhwQWZmaW5lX2NodW5rXCI7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcxbV9tdWx0aWV4cF9jaHVua1wiO1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcybV9tdWx0aWV4cEFmZmluZV9jaHVua1wiO1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMm1fbXVsdGlleHBfY2h1bmtcIjtcbiAgICAgICAgICAgICAgICBzR0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmZCYXNlcy5ieXRlTGVuZ3RoIC8gc0dJbik7XG5cbiAgICAgICAgaWYgKG5Qb2ludHMgPT0gMCkgcmV0dXJuIEcuemVybztcbiAgICAgICAgY29uc3Qgc1NjYWxhciA9IE1hdGguZmxvb3IoYnVmZlNjYWxhcnMuYnl0ZUxlbmd0aCAvIG5Qb2ludHMpO1xuICAgICAgICBpZiggc1NjYWxhciAqIG5Qb2ludHMgIT0gYnVmZlNjYWxhcnMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NhbGFyIHNpemUgZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiaXRDaHVua1NpemUgPSBwVFNpemVzW2xvZzIoblBvaW50cyldO1xuICAgICAgICBjb25zdCBuQ2h1bmtzID0gTWF0aC5mbG9vcigoc1NjYWxhcio4IC0gMSkgLyBiaXRDaHVua1NpemUpICsxO1xuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5DaHVua3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYnVmZkJhc2VzfSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYnVmZlNjYWxhcnN9LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IEcuRi5uOCozfSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk5hbWUsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IHNTY2FsYXJ9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBuUG9pbnRzfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhbDogaSpiaXRDaHVua1NpemV9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBNYXRoLm1pbihzU2NhbGFyKjggLSBpKmJpdENodW5rU2l6ZSwgYml0Q2h1bmtTaXplKX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDJ9XG4gICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAge2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDIsIGxlbjogRy5GLm44KjN9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIEcudG0ucXVldWVBY3Rpb24odGFzaylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgcmVzID0gRy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPXJlc3VsdC5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoIUcuaXNaZXJvKHJlcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8Yml0Q2h1bmtTaXplOyBqKyspIHJlcyA9IEcuZG91YmxlKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBHLmFkZChyZXMsIHJlc3VsdFtpXVswXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9tdWx0aUV4cChidWZmQmFzZXMsIGJ1ZmZTY2FsYXJzLCBpblR5cGUsIGxvZ2dlciwgbG9nVGV4dCkge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDEgPDwgMjI7XG4gICAgICAgIGNvbnN0IE1JTl9DSFVOS19TSVpFID0gMSA8PCAxMDtcbiAgICAgICAgbGV0IHNHSW47XG5cbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkcyXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmZCYXNlcy5ieXRlTGVuZ3RoIC8gc0dJbik7XG4gICAgICAgIGlmIChuUG9pbnRzID09IDApIHJldHVybiBHLnplcm87XG4gICAgICAgIGNvbnN0IHNTY2FsYXIgPSBNYXRoLmZsb29yKGJ1ZmZTY2FsYXJzLmJ5dGVMZW5ndGggLyBuUG9pbnRzKTtcbiAgICAgICAgaWYoIHNTY2FsYXIgKiBuUG9pbnRzICE9IGJ1ZmZTY2FsYXJzLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjYWxhciBzaXplIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYml0Q2h1bmtTaXplID0gcFRTaXplc1tsb2cyKG5Qb2ludHMpXTtcbiAgICAgICAgY29uc3QgbkNodW5rcyA9IE1hdGguZmxvb3IoKHNTY2FsYXIqOCAtIDEpIC8gYml0Q2h1bmtTaXplKSArMTtcblxuICAgICAgICBsZXQgY2h1bmtTaXplO1xuICAgICAgICBjaHVua1NpemUgPSBNYXRoLmZsb29yKG5Qb2ludHMgLyAodG0uY29uY3VycmVuY3kgL25DaHVua3MpKTtcbiAgICAgICAgaWYgKGNodW5rU2l6ZT5NQVhfQ0hVTktfU0laRSkgY2h1bmtTaXplID0gTUFYX0NIVU5LX1NJWkU7XG4gICAgICAgIGlmIChjaHVua1NpemU8TUlOX0NIVU5LX1NJWkUpIGNodW5rU2l6ZSA9IE1JTl9DSFVOS19TSVpFO1xuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYE11bHRpZXhwIHN0YXJ0OiAke2xvZ1RleHR9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG49IE1hdGgubWluKG5Qb2ludHMgLSBpLCBjaHVua1NpemUpO1xuICAgICAgICAgICAgY29uc3QgYnVmZkJhc2VzQ2h1bmsgPSBidWZmQmFzZXMuc2xpY2UoaSpzR0luLCAoaStuKSpzR0luKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZTY2FsYXJzQ2h1bmsgPSBidWZmU2NhbGFycy5zbGljZShpKnNTY2FsYXIsIChpK24pKnNTY2FsYXIpO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKF9tdWx0aUV4cENodW5rKGJ1ZmZCYXNlc0NodW5rLCBidWZmU2NhbGFyc0NodW5rLCBpblR5cGUsIGxvZ2dlciwgbG9nVGV4dCkudGhlbiggKHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYE11bHRpZXhwIGVuZDogJHtsb2dUZXh0fTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgcmVzID0gRy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPXJlc3VsdC5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICByZXMgPSBHLmFkZChyZXMsIHJlc3VsdFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIEcubXVsdGlFeHAgPSBhc3luYyBmdW5jdGlvbiBtdWx0aUV4cEFmZmluZShidWZmQmFzZXMsIGJ1ZmZTY2FsYXJzLCBsb2dnZXIsIGxvZ1RleHQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9tdWx0aUV4cChidWZmQmFzZXMsIGJ1ZmZTY2FsYXJzLCBcImphY29iaWFuXCIsIGxvZ2dlciwgbG9nVGV4dCk7XG4gICAgfTtcbiAgICBHLm11bHRpRXhwQWZmaW5lID0gYXN5bmMgZnVuY3Rpb24gbXVsdGlFeHBBZmZpbmUoYnVmZkJhc2VzLCBidWZmU2NhbGFycywgbG9nZ2VyLCBsb2dUZXh0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfbXVsdGlFeHAoYnVmZkJhc2VzLCBidWZmU2NhbGFycywgXCJhZmZpbmVcIiwgbG9nZ2VyLCBsb2dUZXh0KTtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_multiexp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_pairing.js":
/*!******************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/engine_pairing.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildPairing)\n/* harmony export */ });\n\nfunction buildPairing(curve) {\n    const tm = curve.tm;\n    curve.pairing = function pairing(a, b) {\n\n        tm.startSyncOp();\n        const pA = tm.allocBuff(curve.G1.toJacobian(a));\n        const pB = tm.allocBuff(curve.G2.toJacobian(b));\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports[curve.name + \"_pairing\"](pA, pB, pRes);\n\n        const res = tm.getBuff(pRes, curve.Gt.n8);\n\n        tm.endSyncOp();\n        return res;\n    };\n\n    curve.pairingEq = async function pairingEq() {\n        let  buffCt;\n        let nEqs;\n        if ((arguments.length % 2) == 1) {\n            buffCt = arguments[arguments.length-1];\n            nEqs = (arguments.length -1) /2;\n        } else {\n            buffCt = curve.Gt.one;\n            nEqs = arguments.length /2;\n        }\n\n        const opPromises = [];\n        for (let i=0; i<nEqs; i++) {\n\n            const task = [];\n\n            const g1Buff = curve.G1.toJacobian(arguments[i*2]);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: g1Buff});\n            task.push({cmd: \"ALLOC\", var: 1, len: curve.prePSize});\n\n            const g2Buff = curve.G2.toJacobian(arguments[i*2 +1]);\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: g2Buff});\n            task.push({cmd: \"ALLOC\", var: 3, len: curve.preQSize});\n\n            task.push({cmd: \"ALLOC\", var: 4, len: curve.Gt.n8});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG1\", params: [\n                {var: 0},\n                {var: 1}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG2\", params: [\n                {var: 2},\n                {var: 3}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_millerLoop\", params: [\n                {var: 1},\n                {var: 3},\n                {var: 4}\n            ]});\n\n            task.push({cmd: \"GET\", out: 0, var: 4, len: curve.Gt.n8});\n\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        tm.startSyncOp();\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports.ftm_one(pRes);\n\n        for (let i=0; i<result.length; i++) {\n            const pMR = tm.allocBuff(result[i][0]);\n            tm.instance.exports.ftm_mul(pRes, pMR, pRes);\n        }\n        tm.instance.exports[curve.name + \"_finalExponentiation\"](pRes, pRes);\n\n        const pCt = tm.allocBuff(buffCt);\n\n        const r = !!tm.instance.exports.ftm_eq(pRes, pCt);\n\n        tm.endSyncOp();\n\n        return r;\n    };\n\n    curve.prepareG1 = function(p) {\n        this.tm.startSyncOp();\n        const pP = this.tm.allocBuff(p);\n        const pPrepP = this.tm.alloc(this.prePSize);\n        this.tm.instance.exports[this.name + \"_prepareG1\"](pP, pPrepP);\n        const res = this.tm.getBuff(pPrepP, this.prePSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.prepareG2 = function(q) {\n        this.tm.startSyncOp();\n        const pQ = this.tm.allocBuff(q);\n        const pPrepQ = this.tm.alloc(this.preQSize);\n        this.tm.instance.exports[this.name + \"_prepareG2\"](pQ, pPrepQ);\n        const res = this.tm.getBuff(pPrepQ, this.preQSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.millerLoop = function(preP, preQ) {\n        this.tm.startSyncOp();\n        const pPreP = this.tm.allocBuff(preP);\n        const pPreQ = this.tm.allocBuff(preQ);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_millerLoop\"](pPreP, pPreQ, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.finalExponentiation = function(a) {\n        this.tm.startSyncOp();\n        const pA = this.tm.allocBuff(a);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_finalExponentiation\"](pA, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfcGFpcmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUNlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFFBQVE7O0FBRTlCOztBQUVBO0FBQ0EsdUJBQXVCLHNDQUFzQztBQUM3RCx1QkFBdUIsMENBQTBDOztBQUVqRTtBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0QsdUJBQXVCLDBDQUEwQzs7QUFFakUsdUJBQXVCLHVDQUF1Qzs7QUFFOUQsdUJBQXVCO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQjtBQUNqQixjQUFjOztBQUVkLHVCQUF1QjtBQUN2QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUI7QUFDakIsY0FBYzs7QUFFZCx1QkFBdUI7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCO0FBQ2pCLGNBQWM7O0FBRWQsdUJBQXVCLDZDQUE2Qzs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9lbmdpbmVfcGFpcmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkUGFpcmluZyhjdXJ2ZSkge1xuICAgIGNvbnN0IHRtID0gY3VydmUudG07XG4gICAgY3VydmUucGFpcmluZyA9IGZ1bmN0aW9uIHBhaXJpbmcoYSwgYikge1xuXG4gICAgICAgIHRtLnN0YXJ0U3luY09wKCk7XG4gICAgICAgIGNvbnN0IHBBID0gdG0uYWxsb2NCdWZmKGN1cnZlLkcxLnRvSmFjb2JpYW4oYSkpO1xuICAgICAgICBjb25zdCBwQiA9IHRtLmFsbG9jQnVmZihjdXJ2ZS5HMi50b0phY29iaWFuKGIpKTtcbiAgICAgICAgY29uc3QgcFJlcyA9IHRtLmFsbG9jKGN1cnZlLkd0Lm44KTtcbiAgICAgICAgdG0uaW5zdGFuY2UuZXhwb3J0c1tjdXJ2ZS5uYW1lICsgXCJfcGFpcmluZ1wiXShwQSwgcEIsIHBSZXMpO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IHRtLmdldEJ1ZmYocFJlcywgY3VydmUuR3QubjgpO1xuXG4gICAgICAgIHRtLmVuZFN5bmNPcCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICBjdXJ2ZS5wYWlyaW5nRXEgPSBhc3luYyBmdW5jdGlvbiBwYWlyaW5nRXEoKSB7XG4gICAgICAgIGxldCAgYnVmZkN0O1xuICAgICAgICBsZXQgbkVxcztcbiAgICAgICAgaWYgKChhcmd1bWVudHMubGVuZ3RoICUgMikgPT0gMSkge1xuICAgICAgICAgICAgYnVmZkN0ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV07XG4gICAgICAgICAgICBuRXFzID0gKGFyZ3VtZW50cy5sZW5ndGggLTEpIC8yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZkN0ID0gY3VydmUuR3Qub25lO1xuICAgICAgICAgICAgbkVxcyA9IGFyZ3VtZW50cy5sZW5ndGggLzI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuRXFzOyBpKyspIHtcblxuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgICAgICBjb25zdCBnMUJ1ZmYgPSBjdXJ2ZS5HMS50b0phY29iaWFuKGFyZ3VtZW50c1tpKjJdKTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogZzFCdWZmfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDEsIGxlbjogY3VydmUucHJlUFNpemV9KTtcblxuICAgICAgICAgICAgY29uc3QgZzJCdWZmID0gY3VydmUuRzIudG9KYWNvYmlhbihhcmd1bWVudHNbaSoyICsxXSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDIsIGJ1ZmY6IGcyQnVmZn0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAzLCBsZW46IGN1cnZlLnByZVFTaXplfSk7XG5cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogNCwgbGVuOiBjdXJ2ZS5HdC5uOH0pO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogY3VydmUubmFtZSArIFwiX3ByZXBhcmVHMVwiLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAxfVxuICAgICAgICAgICAgXX0pO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogY3VydmUubmFtZSArIFwiX3ByZXBhcmVHMlwiLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFyOiAzfVxuICAgICAgICAgICAgXX0pO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogY3VydmUubmFtZSArIFwiX21pbGxlckxvb3BcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAge3ZhcjogM30sXG4gICAgICAgICAgICAgICAge3ZhcjogNH1cbiAgICAgICAgICAgIF19KTtcblxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiA0LCBsZW46IGN1cnZlLkd0Lm44fSk7XG5cbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgdG0uc3RhcnRTeW5jT3AoKTtcbiAgICAgICAgY29uc3QgcFJlcyA9IHRtLmFsbG9jKGN1cnZlLkd0Lm44KTtcbiAgICAgICAgdG0uaW5zdGFuY2UuZXhwb3J0cy5mdG1fb25lKHBSZXMpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBNUiA9IHRtLmFsbG9jQnVmZihyZXN1bHRbaV1bMF0pO1xuICAgICAgICAgICAgdG0uaW5zdGFuY2UuZXhwb3J0cy5mdG1fbXVsKHBSZXMsIHBNUiwgcFJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdG0uaW5zdGFuY2UuZXhwb3J0c1tjdXJ2ZS5uYW1lICsgXCJfZmluYWxFeHBvbmVudGlhdGlvblwiXShwUmVzLCBwUmVzKTtcblxuICAgICAgICBjb25zdCBwQ3QgPSB0bS5hbGxvY0J1ZmYoYnVmZkN0KTtcblxuICAgICAgICBjb25zdCByID0gISF0bS5pbnN0YW5jZS5leHBvcnRzLmZ0bV9lcShwUmVzLCBwQ3QpO1xuXG4gICAgICAgIHRtLmVuZFN5bmNPcCgpO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBjdXJ2ZS5wcmVwYXJlRzEgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMudG0uc3RhcnRTeW5jT3AoKTtcbiAgICAgICAgY29uc3QgcFAgPSB0aGlzLnRtLmFsbG9jQnVmZihwKTtcbiAgICAgICAgY29uc3QgcFByZXBQID0gdGhpcy50bS5hbGxvYyh0aGlzLnByZVBTaXplKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMubmFtZSArIFwiX3ByZXBhcmVHMVwiXShwUCwgcFByZXBQKTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy50bS5nZXRCdWZmKHBQcmVwUCwgdGhpcy5wcmVQU2l6ZSk7XG4gICAgICAgIHRoaXMudG0uZW5kU3luY09wKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIGN1cnZlLnByZXBhcmVHMiA9IGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgdGhpcy50bS5zdGFydFN5bmNPcCgpO1xuICAgICAgICBjb25zdCBwUSA9IHRoaXMudG0uYWxsb2NCdWZmKHEpO1xuICAgICAgICBjb25zdCBwUHJlcFEgPSB0aGlzLnRtLmFsbG9jKHRoaXMucHJlUVNpemUpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5uYW1lICsgXCJfcHJlcGFyZUcyXCJdKHBRLCBwUHJlcFEpO1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnRtLmdldEJ1ZmYocFByZXBRLCB0aGlzLnByZVFTaXplKTtcbiAgICAgICAgdGhpcy50bS5lbmRTeW5jT3AoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgY3VydmUubWlsbGVyTG9vcCA9IGZ1bmN0aW9uKHByZVAsIHByZVEpIHtcbiAgICAgICAgdGhpcy50bS5zdGFydFN5bmNPcCgpO1xuICAgICAgICBjb25zdCBwUHJlUCA9IHRoaXMudG0uYWxsb2NCdWZmKHByZVApO1xuICAgICAgICBjb25zdCBwUHJlUSA9IHRoaXMudG0uYWxsb2NCdWZmKHByZVEpO1xuICAgICAgICBjb25zdCBwUmVzID0gdGhpcy50bS5hbGxvYyh0aGlzLkd0Lm44KTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMubmFtZSArIFwiX21pbGxlckxvb3BcIl0ocFByZVAsIHBQcmVRLCBwUmVzKTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy50bS5nZXRCdWZmKHBSZXMsIHRoaXMuR3QubjgpO1xuICAgICAgICB0aGlzLnRtLmVuZFN5bmNPcCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICBjdXJ2ZS5maW5hbEV4cG9uZW50aWF0aW9uID0gZnVuY3Rpb24oYSkge1xuICAgICAgICB0aGlzLnRtLnN0YXJ0U3luY09wKCk7XG4gICAgICAgIGNvbnN0IHBBID0gdGhpcy50bS5hbGxvY0J1ZmYoYSk7XG4gICAgICAgIGNvbnN0IHBSZXMgPSB0aGlzLnRtLmFsbG9jKHRoaXMuR3QubjgpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5uYW1lICsgXCJfZmluYWxFeHBvbmVudGlhdGlvblwiXShwQSwgcFJlcyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudG0uZ2V0QnVmZihwUmVzLCB0aGlzLkd0Lm44KTtcbiAgICAgICAgdGhpcy50bS5lbmRTeW5jT3AoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_pairing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/f1field.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/f1field.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ZqField)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _futils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./futils.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js\");\n/* harmony import */ var _fsqrt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fsqrt.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/fsqrt.js\");\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./random.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js\");\n/* harmony import */ var _fft_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fft.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/fft.js\");\n/* global BigInt */\n\n\n\n\n\n\nclass ZqField {\n    constructor(p) {\n        this.type=\"F1\";\n        this.one = BigInt(1);\n        this.zero = BigInt(0);\n        this.p = BigInt(p);\n        this.m = 1;\n        this.negone = this.p-this.one;\n        this.two = BigInt(2);\n        this.half = this.p >> this.one;\n        this.bitLength = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.bitLength(this.p);\n        this.mask = (this.one << BigInt(this.bitLength)) - this.one;\n\n        this.n64 = Math.floor((this.bitLength - 1) / 64)+1;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n        this.R = this.e(this.one << BigInt(this.n64*64));\n        this.Ri = this.inv(this.R);\n\n        const e = this.negone >> this.one;\n        this.nqr = this.two;\n        let r = this.pow(this.nqr, e);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.nqr + this.one;\n            r = this.pow(this.nqr, e);\n        }\n\n\n        this.s = 0;\n        this.t = this.negone;\n\n        while ((this.t & this.one) == this.zero) {\n            this.s = this.s + 1;\n            this.t = this.t >> this.one;\n        }\n\n        this.nqr_to_t = this.pow(this.nqr, this.t);\n\n        (0,_fsqrt_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this);\n\n        this.FFT = new _fft_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this, this, this.mul.bind(this));\n\n        this.fft = this.FFT.fft.bind(this.FFT);\n        this.ifft = this.FFT.ifft.bind(this.FFT);\n        this.w = this.FFT.w;\n        this.wi = this.FFT.wi; \n    \n        this.shift = this.square(this.nqr);\n        this.k = this.exp(this.nqr, 2**this.s);\n    }\n\n    e(a,b) {\n        let res;\n        if (!b) {\n            res = BigInt(a);\n        } else if (b==16) {\n            res = BigInt(\"0x\"+a);\n        }\n        if (res < 0) {\n            let nres = -res;\n            if (nres >= this.p) nres = nres % this.p;\n            return this.p - nres;\n        } else {\n            return (res>= this.p) ? res%this.p : res;\n        }\n\n    }\n\n    add(a, b) {\n        const res = a + b;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    sub(a, b) {\n        return (a >= b) ? a-b : this.p-b+a;\n    }\n\n    neg(a) {\n        return a ? this.p-a : a;\n    }\n\n    mul(a, b) {\n        return (a*b)%this.p;\n    }\n\n    mulScalar(base, s) {\n        return (base * this.e(s)) % this.p;\n    }\n\n    square(a) {\n        return (a*a) % this.p;\n    }\n\n    eq(a, b) {\n        return a==b;\n    }\n\n    neq(a, b) {\n        return a!=b;\n    }\n\n    lt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa < bb;\n    }\n\n    gt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa > bb;\n    }\n\n    leq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa <= bb;\n    }\n\n    geq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa >= bb;\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    idiv(a, b) {\n        if (!b) throw new Error(\"Division by zero\");\n        return a / b;\n    }\n\n    inv(a) {\n        if (!a) throw new Error(\"Division by zero\");\n\n        let t = this.zero;\n        let r = this.p;\n        let newt = this.one;\n        let newr = a % this.p;\n        while (newr) {\n            let q = r/newr;\n            [t, newt] = [newt, t-q*newt];\n            [r, newr] = [newr, r-q*newr];\n        }\n        if (t<this.zero) t += this.p;\n        return t;\n    }\n\n    mod(a, b) {\n        return a % b;\n    }\n\n    pow(b, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_1__.exp(this, b, e);\n    }\n\n    exp(b, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_1__.exp(this, b, e);\n    }\n\n    band(a, b) {\n        const res =  ((a & b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bor(a, b) {\n        const res =  ((a | b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bxor(a, b) {\n        const res =  ((a ^ b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bnot(a) {\n        const res = a ^ this.mask;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    shl(a, b) {\n        if (Number(b) < this.bitLength) {\n            const res = (a << b) & this.mask;\n            return res >= this.p ? res-this.p : res;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                return a >> nb;\n            } else {\n                return this.zero;\n            }\n        }\n    }\n\n    shr(a, b) {\n        if (Number(b) < this.bitLength) {\n            return a >> b;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                const res = (a << nb) & this.mask;\n                return res >= this.p ? res-this.p : res;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    land(a, b) {\n        return (a && b) ? this.one : this.zero;\n    }\n\n    lor(a, b) {\n        return (a || b) ? this.one : this.zero;\n    }\n\n    lnot(a) {\n        return (a) ? this.zero : this.one;\n    }\n\n    sqrt_old(n) {\n\n        if (n == this.zero) return this.zero;\n\n        // Test that have solution\n        const res = this.pow(n, this.negone >> this.one);\n        if ( res != this.one ) return null;\n\n        let m = this.s;\n        let c = this.nqr_to_t;\n        let t = this.pow(n, this.t);\n        let r = this.pow(n, this.add(this.t, this.one) >> this.one );\n\n        while ( t != this.one ) {\n            let sq = this.square(t);\n            let i = 1;\n            while (sq != this.one ) {\n                i++;\n                sq = this.square(sq);\n            }\n\n            // b = c ^ m-i-1\n            let b = c;\n            for (let j=0; j< m-i-1; j ++) b = this.square(b);\n\n            m = i;\n            c = this.square(b);\n            t = this.mul(t, c);\n            r = this.mul(r, b);\n        }\n\n        if (r > (this.p >> this.one)) {\n            r = this.neg(r);\n        }\n\n        return r;\n    }\n\n    normalize(a, b) {\n        a = BigInt(a,b);\n        if (a < 0) {\n            let na = -a;\n            if (na >= this.p) na = na % this.p;\n            return this.p - na;\n        } else {\n            return (a>= this.p) ? a%this.p : a;\n        }\n    }\n\n    random() {\n        const nBytes = (this.bitLength*2 / 8);\n        let res =this.zero;\n        for (let i=0; i<nBytes; i++) {\n            res = (res << BigInt(8)) + BigInt((0,_random_js__WEBPACK_IMPORTED_MODULE_3__.getRandomBytes)(1)[0]);\n        }\n        return res % this.p;\n    }\n\n    toString(a, base) {\n        base = base || 10;\n        let vs;\n        if ((a > this.half)&&(base == 10)) {\n            const v = this.p-a;\n            vs = \"-\"+v.toString(base);\n        } else {\n            vs = a.toString(base);\n        }\n        return vs;\n    }\n\n    isZero(a) {\n        return a == this.zero;\n    }\n\n    fromRng(rng) {\n        let v;\n        do {\n            v=this.zero;\n            for (let i=0; i<this.n64; i++) {\n                v += rng.nextU64() << BigInt(64 *i);\n            }\n            v &= this.mask;\n        } while (v >= this.p);\n        v = (v * this.Ri) % this.p;   // Convert from montgomery\n        return v;\n    }\n\n    fft(a) {\n        return this.FFT.fft(a);\n    }\n\n    ifft(a) {\n        return this.FFT.ifft(a);\n    }\n\n    // Returns a buffer with Little Endian Representation\n    toRprLE(buff, o, e) {\n        _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toRprLE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Representation\n    toRprBE(buff, o, e) {\n        _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toRprBE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Montgomery Representation\n    toRprBEM(buff, o, e) {\n        return this.toRprBE(buff, o, this.mul(this.R, e));\n    }\n\n    toRprLEM(buff, o, e) {\n        return this.toRprLE(buff, o, this.mul(this.R, e));\n    }\n\n\n    // Pases a buffer with Little Endian Representation\n    fromRprLE(buff, o) {\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.fromRprLE(buff, o, this.n8);\n    }\n\n    // Pases a buffer with Big Endian Representation\n    fromRprBE(buff, o) {\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.fromRprBE(buff, o, this.n8);\n    }\n\n    fromRprLEM(buff, o) {\n        return this.mul(this.fromRprLE(buff, o), this.Ri);\n    }\n\n    fromRprBEM(buff, o) {\n        return this.mul(this.fromRprBE(buff, o), this.Ri);\n    }\n\n    toObject(a) {\n        return a;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mMWZpZWxkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ3NDO0FBQ0E7QUFDSDtBQUNRO0FBQ2Y7O0FBRWI7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxxREFBUzs7QUFFakIsdUJBQXVCLCtDQUFJOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDJDQUFVO0FBQ3pCOztBQUVBO0FBQ0EsZUFBZSwyQ0FBVTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQyw4Q0FBOEMsMERBQWM7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBYztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBYztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxlQUFlLGlEQUFnQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxpREFBZ0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL2YxZmllbGQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIEJpZ0ludCAqL1xuaW1wb3J0ICogYXMgU2NhbGFyIGZyb20gXCIuL3NjYWxhci5qc1wiO1xuaW1wb3J0ICogYXMgZnV0aWxzIGZyb20gXCIuL2Z1dGlscy5qc1wiO1xuaW1wb3J0IGJ1aWxkU3FydCBmcm9tIFwiLi9mc3FydC5qc1wiO1xuaW1wb3J0IHtnZXRSYW5kb21CeXRlc30gZnJvbSBcIi4vcmFuZG9tLmpzXCI7XG5pbXBvcnQgRkZGVCBmcm9tIFwiLi9mZnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWnFGaWVsZCB7XG4gICAgY29uc3RydWN0b3IocCkge1xuICAgICAgICB0aGlzLnR5cGU9XCJGMVwiO1xuICAgICAgICB0aGlzLm9uZSA9IEJpZ0ludCgxKTtcbiAgICAgICAgdGhpcy56ZXJvID0gQmlnSW50KDApO1xuICAgICAgICB0aGlzLnAgPSBCaWdJbnQocCk7XG4gICAgICAgIHRoaXMubSA9IDE7XG4gICAgICAgIHRoaXMubmVnb25lID0gdGhpcy5wLXRoaXMub25lO1xuICAgICAgICB0aGlzLnR3byA9IEJpZ0ludCgyKTtcbiAgICAgICAgdGhpcy5oYWxmID0gdGhpcy5wID4+IHRoaXMub25lO1xuICAgICAgICB0aGlzLmJpdExlbmd0aCA9IFNjYWxhci5iaXRMZW5ndGgodGhpcy5wKTtcbiAgICAgICAgdGhpcy5tYXNrID0gKHRoaXMub25lIDw8IEJpZ0ludCh0aGlzLmJpdExlbmd0aCkpIC0gdGhpcy5vbmU7XG5cbiAgICAgICAgdGhpcy5uNjQgPSBNYXRoLmZsb29yKCh0aGlzLmJpdExlbmd0aCAtIDEpIC8gNjQpKzE7XG4gICAgICAgIHRoaXMubjMyID0gdGhpcy5uNjQqMjtcbiAgICAgICAgdGhpcy5uOCA9IHRoaXMubjY0Kjg7XG4gICAgICAgIHRoaXMuUiA9IHRoaXMuZSh0aGlzLm9uZSA8PCBCaWdJbnQodGhpcy5uNjQqNjQpKTtcbiAgICAgICAgdGhpcy5SaSA9IHRoaXMuaW52KHRoaXMuUik7XG5cbiAgICAgICAgY29uc3QgZSA9IHRoaXMubmVnb25lID4+IHRoaXMub25lO1xuICAgICAgICB0aGlzLm5xciA9IHRoaXMudHdvO1xuICAgICAgICBsZXQgciA9IHRoaXMucG93KHRoaXMubnFyLCBlKTtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmVxKHIsIHRoaXMubmVnb25lKSkge1xuICAgICAgICAgICAgdGhpcy5ucXIgPSB0aGlzLm5xciArIHRoaXMub25lO1xuICAgICAgICAgICAgciA9IHRoaXMucG93KHRoaXMubnFyLCBlKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5zID0gMDtcbiAgICAgICAgdGhpcy50ID0gdGhpcy5uZWdvbmU7XG5cbiAgICAgICAgd2hpbGUgKCh0aGlzLnQgJiB0aGlzLm9uZSkgPT0gdGhpcy56ZXJvKSB7XG4gICAgICAgICAgICB0aGlzLnMgPSB0aGlzLnMgKyAxO1xuICAgICAgICAgICAgdGhpcy50ID0gdGhpcy50ID4+IHRoaXMub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ucXJfdG9fdCA9IHRoaXMucG93KHRoaXMubnFyLCB0aGlzLnQpO1xuXG4gICAgICAgIGJ1aWxkU3FydCh0aGlzKTtcblxuICAgICAgICB0aGlzLkZGVCA9IG5ldyBGRkZUKHRoaXMsIHRoaXMsIHRoaXMubXVsLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuZmZ0ID0gdGhpcy5GRlQuZmZ0LmJpbmQodGhpcy5GRlQpO1xuICAgICAgICB0aGlzLmlmZnQgPSB0aGlzLkZGVC5pZmZ0LmJpbmQodGhpcy5GRlQpO1xuICAgICAgICB0aGlzLncgPSB0aGlzLkZGVC53O1xuICAgICAgICB0aGlzLndpID0gdGhpcy5GRlQud2k7IFxuICAgIFxuICAgICAgICB0aGlzLnNoaWZ0ID0gdGhpcy5zcXVhcmUodGhpcy5ucXIpO1xuICAgICAgICB0aGlzLmsgPSB0aGlzLmV4cCh0aGlzLm5xciwgMioqdGhpcy5zKTtcbiAgICB9XG5cbiAgICBlKGEsYikge1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgIHJlcyA9IEJpZ0ludChhKTtcbiAgICAgICAgfSBlbHNlIGlmIChiPT0xNikge1xuICAgICAgICAgICAgcmVzID0gQmlnSW50KFwiMHhcIithKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzIDwgMCkge1xuICAgICAgICAgICAgbGV0IG5yZXMgPSAtcmVzO1xuICAgICAgICAgICAgaWYgKG5yZXMgPj0gdGhpcy5wKSBucmVzID0gbnJlcyAlIHRoaXMucDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnAgLSBucmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChyZXM+PSB0aGlzLnApID8gcmVzJXRoaXMucCA6IHJlcztcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYWRkKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYSArIGI7XG4gICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5wID8gcmVzLXRoaXMucCA6IHJlcztcbiAgICB9XG5cbiAgICBzdWIoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgPj0gYikgPyBhLWIgOiB0aGlzLnAtYithO1xuICAgIH1cblxuICAgIG5lZyhhKSB7XG4gICAgICAgIHJldHVybiBhID8gdGhpcy5wLWEgOiBhO1xuICAgIH1cblxuICAgIG11bChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYSpiKSV0aGlzLnA7XG4gICAgfVxuXG4gICAgbXVsU2NhbGFyKGJhc2UsIHMpIHtcbiAgICAgICAgcmV0dXJuIChiYXNlICogdGhpcy5lKHMpKSAlIHRoaXMucDtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gKGEqYSkgJSB0aGlzLnA7XG4gICAgfVxuXG4gICAgZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gYT09YjtcbiAgICB9XG5cbiAgICBuZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gYSE9YjtcbiAgICB9XG5cbiAgICBsdChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFhID0gKGEgPiB0aGlzLmhhbGYpID8gYSAtIHRoaXMucCA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gKGIgPiB0aGlzLmhhbGYpID8gYiAtIHRoaXMucCA6IGI7XG4gICAgICAgIHJldHVybiBhYSA8IGJiO1xuICAgIH1cblxuICAgIGd0KGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWEgPSAoYSA+IHRoaXMuaGFsZikgPyBhIC0gdGhpcy5wIDogYTtcbiAgICAgICAgY29uc3QgYmIgPSAoYiA+IHRoaXMuaGFsZikgPyBiIC0gdGhpcy5wIDogYjtcbiAgICAgICAgcmV0dXJuIGFhID4gYmI7XG4gICAgfVxuXG4gICAgbGVxKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWEgPSAoYSA+IHRoaXMuaGFsZikgPyBhIC0gdGhpcy5wIDogYTtcbiAgICAgICAgY29uc3QgYmIgPSAoYiA+IHRoaXMuaGFsZikgPyBiIC0gdGhpcy5wIDogYjtcbiAgICAgICAgcmV0dXJuIGFhIDw9IGJiO1xuICAgIH1cblxuICAgIGdlcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFhID0gKGEgPiB0aGlzLmhhbGYpID8gYSAtIHRoaXMucCA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gKGIgPiB0aGlzLmhhbGYpID8gYiAtIHRoaXMucCA6IGI7XG4gICAgICAgIHJldHVybiBhYSA+PSBiYjtcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgdGhpcy5pbnYoYikpO1xuICAgIH1cblxuICAgIGlkaXYoYSwgYikge1xuICAgICAgICBpZiAoIWIpIHRocm93IG5ldyBFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm9cIik7XG4gICAgICAgIHJldHVybiBhIC8gYjtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICBpZiAoIWEpIHRocm93IG5ldyBFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm9cIik7XG5cbiAgICAgICAgbGV0IHQgPSB0aGlzLnplcm87XG4gICAgICAgIGxldCByID0gdGhpcy5wO1xuICAgICAgICBsZXQgbmV3dCA9IHRoaXMub25lO1xuICAgICAgICBsZXQgbmV3ciA9IGEgJSB0aGlzLnA7XG4gICAgICAgIHdoaWxlIChuZXdyKSB7XG4gICAgICAgICAgICBsZXQgcSA9IHIvbmV3cjtcbiAgICAgICAgICAgIFt0LCBuZXd0XSA9IFtuZXd0LCB0LXEqbmV3dF07XG4gICAgICAgICAgICBbciwgbmV3cl0gPSBbbmV3ciwgci1xKm5ld3JdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0PHRoaXMuemVybykgdCArPSB0aGlzLnA7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIG1vZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICUgYjtcbiAgICB9XG5cbiAgICBwb3coYiwgZSkge1xuICAgICAgICByZXR1cm4gZnV0aWxzLmV4cCh0aGlzLCBiLCBlKTtcbiAgICB9XG5cbiAgICBleHAoYiwgZSkge1xuICAgICAgICByZXR1cm4gZnV0aWxzLmV4cCh0aGlzLCBiLCBlKTtcbiAgICB9XG5cbiAgICBiYW5kKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gICgoYSAmIGIpICYgdGhpcy5tYXNrKTtcbiAgICAgICAgcmV0dXJuIHJlcyA+PSB0aGlzLnAgPyByZXMtdGhpcy5wIDogcmVzO1xuICAgIH1cblxuICAgIGJvcihhLCBiKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9ICAoKGEgfCBiKSAmIHRoaXMubWFzayk7XG4gICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5wID8gcmVzLXRoaXMucCA6IHJlcztcbiAgICB9XG5cbiAgICBieG9yKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gICgoYSBeIGIpICYgdGhpcy5tYXNrKTtcbiAgICAgICAgcmV0dXJuIHJlcyA+PSB0aGlzLnAgPyByZXMtdGhpcy5wIDogcmVzO1xuICAgIH1cblxuICAgIGJub3QoYSkge1xuICAgICAgICBjb25zdCByZXMgPSBhIF4gdGhpcy5tYXNrO1xuICAgICAgICByZXR1cm4gcmVzID49IHRoaXMucCA/IHJlcy10aGlzLnAgOiByZXM7XG4gICAgfVxuXG4gICAgc2hsKGEsIGIpIHtcbiAgICAgICAgaWYgKE51bWJlcihiKSA8IHRoaXMuYml0TGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSAoYSA8PCBiKSAmIHRoaXMubWFzaztcbiAgICAgICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5wID8gcmVzLXRoaXMucCA6IHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5iID0gdGhpcy5wIC0gYjtcbiAgICAgICAgICAgIGlmIChOdW1iZXIobmIpIDwgdGhpcy5iaXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA+PiBuYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNocihhLCBiKSB7XG4gICAgICAgIGlmIChOdW1iZXIoYikgPCB0aGlzLmJpdExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGEgPj4gYjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5iID0gdGhpcy5wIC0gYjtcbiAgICAgICAgICAgIGlmIChOdW1iZXIobmIpIDwgdGhpcy5iaXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSAoYSA8PCBuYikgJiB0aGlzLm1hc2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcyA+PSB0aGlzLnAgPyByZXMtdGhpcy5wIDogcmVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxhbmQoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgJiYgYikgPyB0aGlzLm9uZSA6IHRoaXMuemVybztcbiAgICB9XG5cbiAgICBsb3IoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgfHwgYikgPyB0aGlzLm9uZSA6IHRoaXMuemVybztcbiAgICB9XG5cbiAgICBsbm90KGEpIHtcbiAgICAgICAgcmV0dXJuIChhKSA/IHRoaXMuemVybyA6IHRoaXMub25lO1xuICAgIH1cblxuICAgIHNxcnRfb2xkKG4pIHtcblxuICAgICAgICBpZiAobiA9PSB0aGlzLnplcm8pIHJldHVybiB0aGlzLnplcm87XG5cbiAgICAgICAgLy8gVGVzdCB0aGF0IGhhdmUgc29sdXRpb25cbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5wb3cobiwgdGhpcy5uZWdvbmUgPj4gdGhpcy5vbmUpO1xuICAgICAgICBpZiAoIHJlcyAhPSB0aGlzLm9uZSApIHJldHVybiBudWxsO1xuXG4gICAgICAgIGxldCBtID0gdGhpcy5zO1xuICAgICAgICBsZXQgYyA9IHRoaXMubnFyX3RvX3Q7XG4gICAgICAgIGxldCB0ID0gdGhpcy5wb3cobiwgdGhpcy50KTtcbiAgICAgICAgbGV0IHIgPSB0aGlzLnBvdyhuLCB0aGlzLmFkZCh0aGlzLnQsIHRoaXMub25lKSA+PiB0aGlzLm9uZSApO1xuXG4gICAgICAgIHdoaWxlICggdCAhPSB0aGlzLm9uZSApIHtcbiAgICAgICAgICAgIGxldCBzcSA9IHRoaXMuc3F1YXJlKHQpO1xuICAgICAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICAgICAgd2hpbGUgKHNxICE9IHRoaXMub25lICkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBzcSA9IHRoaXMuc3F1YXJlKHNxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYiA9IGMgXiBtLWktMVxuICAgICAgICAgICAgbGV0IGIgPSBjO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPCBtLWktMTsgaiArKykgYiA9IHRoaXMuc3F1YXJlKGIpO1xuXG4gICAgICAgICAgICBtID0gaTtcbiAgICAgICAgICAgIGMgPSB0aGlzLnNxdWFyZShiKTtcbiAgICAgICAgICAgIHQgPSB0aGlzLm11bCh0LCBjKTtcbiAgICAgICAgICAgIHIgPSB0aGlzLm11bChyLCBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyID4gKHRoaXMucCA+PiB0aGlzLm9uZSkpIHtcbiAgICAgICAgICAgIHIgPSB0aGlzLm5lZyhyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZShhLCBiKSB7XG4gICAgICAgIGEgPSBCaWdJbnQoYSxiKTtcbiAgICAgICAgaWYgKGEgPCAwKSB7XG4gICAgICAgICAgICBsZXQgbmEgPSAtYTtcbiAgICAgICAgICAgIGlmIChuYSA+PSB0aGlzLnApIG5hID0gbmEgJSB0aGlzLnA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wIC0gbmE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKGE+PSB0aGlzLnApID8gYSV0aGlzLnAgOiBhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmFuZG9tKCkge1xuICAgICAgICBjb25zdCBuQnl0ZXMgPSAodGhpcy5iaXRMZW5ndGgqMiAvIDgpO1xuICAgICAgICBsZXQgcmVzID10aGlzLnplcm87XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCBCaWdJbnQoOCkpICsgQmlnSW50KGdldFJhbmRvbUJ5dGVzKDEpWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzICUgdGhpcy5wO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKGEsIGJhc2UpIHtcbiAgICAgICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgICAgIGxldCB2cztcbiAgICAgICAgaWYgKChhID4gdGhpcy5oYWxmKSYmKGJhc2UgPT0gMTApKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy5wLWE7XG4gICAgICAgICAgICB2cyA9IFwiLVwiK3YudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2cyA9IGEudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZzO1xuICAgIH1cblxuICAgIGlzWmVybyhhKSB7XG4gICAgICAgIHJldHVybiBhID09IHRoaXMuemVybztcbiAgICB9XG5cbiAgICBmcm9tUm5nKHJuZykge1xuICAgICAgICBsZXQgdjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdj10aGlzLnplcm87XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5uNjQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHYgKz0gcm5nLm5leHRVNjQoKSA8PCBCaWdJbnQoNjQgKmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdiAmPSB0aGlzLm1hc2s7XG4gICAgICAgIH0gd2hpbGUgKHYgPj0gdGhpcy5wKTtcbiAgICAgICAgdiA9ICh2ICogdGhpcy5SaSkgJSB0aGlzLnA7ICAgLy8gQ29udmVydCBmcm9tIG1vbnRnb21lcnlcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgZmZ0KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRkZULmZmdChhKTtcbiAgICB9XG5cbiAgICBpZmZ0KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRkZULmlmZnQoYSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIExpdHRsZSBFbmRpYW4gUmVwcmVzZW50YXRpb25cbiAgICB0b1JwckxFKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgU2NhbGFyLnRvUnByTEUoYnVmZiwgbywgZSwgdGhpcy5uNjQqOCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gUmVwcmVzZW50YXRpb25cbiAgICB0b1JwckJFKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgU2NhbGFyLnRvUnByQkUoYnVmZiwgbywgZSwgdGhpcy5uNjQqOCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gTW9udGdvbWVyeSBSZXByZXNlbnRhdGlvblxuICAgIHRvUnByQkVNKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9ScHJCRShidWZmLCBvLCB0aGlzLm11bCh0aGlzLlIsIGUpKTtcbiAgICB9XG5cbiAgICB0b1JwckxFTShidWZmLCBvLCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUnByTEUoYnVmZiwgbywgdGhpcy5tdWwodGhpcy5SLCBlKSk7XG4gICAgfVxuXG5cbiAgICAvLyBQYXNlcyBhIGJ1ZmZlciB3aXRoIExpdHRsZSBFbmRpYW4gUmVwcmVzZW50YXRpb25cbiAgICBmcm9tUnByTEUoYnVmZiwgbykge1xuICAgICAgICByZXR1cm4gU2NhbGFyLmZyb21ScHJMRShidWZmLCBvLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICAvLyBQYXNlcyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gUmVwcmVzZW50YXRpb25cbiAgICBmcm9tUnByQkUoYnVmZiwgbykge1xuICAgICAgICByZXR1cm4gU2NhbGFyLmZyb21ScHJCRShidWZmLCBvLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKHRoaXMuZnJvbVJwckxFKGJ1ZmYsIG8pLCB0aGlzLlJpKTtcbiAgICB9XG5cbiAgICBmcm9tUnByQkVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKHRoaXMuZnJvbVJwckJFKGJ1ZmYsIG8pLCB0aGlzLlJpKTtcbiAgICB9XG5cbiAgICB0b09iamVjdChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/f1field.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/f2field.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/f2field.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ F2Field)\n/* harmony export */ });\n/* harmony import */ var _futils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./futils.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js\");\n/* harmony import */ var _fsqrt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fsqrt.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/fsqrt.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nclass F2Field {\n    constructor(F, nonResidue) {\n        this.type=\"F2\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*2;\n        this.p = F.p;\n        this.n64 = F.n64*2;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n\n        (0,_fsqrt_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this);\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    conjugate(a) {\n        return [\n            a[0],\n            this.F.neg(a[1])\n        ];\n    }\n\n    mul(a, b) {\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n\n        return [\n            this.F.add( aA , this._mulByNonResidue(bB)),\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]),\n                    this.F.add(b[0], b[1])),\n                this.F.add(aA, bB))];\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);\n        const t1 = this.F.square(a[1]);\n        const t2 = this.F.sub(t0, this._mulByNonResidue(t1));\n        const t3 = this.F.inv(t2);\n        return [\n            this.F.mul(a[0], t3),\n            this.F.neg(this.F.mul( a[1], t3)) ];\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const ab = this.F.mul(a[0] , a[1]);\n\n        /*\n        [\n            (a + b) * (a + non_residue * b) - ab - non_residue * ab,\n            ab + ab\n        ];\n        */\n\n        return [\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]) ,\n                    this.F.add(\n                        a[0] ,\n                        this._mulByNonResidue(a[1]))),\n                this.F.add(\n                    ab,\n                    this._mulByNonResidue(ab))),\n            this.F.add(ab, ab)\n        ];\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]);\n    }\n\n    mulScalar(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        return [c0, c1];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        return false;\n    }\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBE(buff, o);\n        const c0 = this.F.fromRprBE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBEM(buff, o);\n        const c0 = this.F.fromRprBEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    toObject(a) {\n        return a;\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mMmZpZWxkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXNDO0FBQ0g7O0FBRXBCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEscURBQVM7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsaURBQWdCO0FBQy9COztBQUVBO0FBQ0EsZUFBZSwyQ0FBVTtBQUN6Qjs7QUFFQTtBQUNBLGVBQWUsMkNBQVU7QUFDekI7O0FBRUE7QUFDQSxvQkFBb0IsdUJBQXVCLElBQUksdUJBQXVCO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvZjJmaWVsZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBmVXRpbHMgZnJvbSBcIi4vZnV0aWxzLmpzXCI7XG5pbXBvcnQgYnVpbGRTcXJ0IGZyb20gXCIuL2ZzcXJ0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEYyRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKEYsIG5vblJlc2lkdWUpIHtcbiAgICAgICAgdGhpcy50eXBlPVwiRjJcIjtcbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy56ZXJvID0gW3RoaXMuRi56ZXJvLCB0aGlzLkYuemVyb107XG4gICAgICAgIHRoaXMub25lID0gW3RoaXMuRi5vbmUsIHRoaXMuRi56ZXJvXTtcbiAgICAgICAgdGhpcy5uZWdvbmUgPSB0aGlzLm5lZyh0aGlzLm9uZSk7XG4gICAgICAgIHRoaXMubm9uUmVzaWR1ZSA9IG5vblJlc2lkdWU7XG4gICAgICAgIHRoaXMubSA9IEYubSoyO1xuICAgICAgICB0aGlzLnAgPSBGLnA7XG4gICAgICAgIHRoaXMubjY0ID0gRi5uNjQqMjtcbiAgICAgICAgdGhpcy5uMzIgPSB0aGlzLm42NCoyO1xuICAgICAgICB0aGlzLm44ID0gdGhpcy5uNjQqODtcblxuICAgICAgICBidWlsZFNxcnQodGhpcyk7XG4gICAgfVxuXG4gICAgX211bEJ5Tm9uUmVzaWR1ZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYubXVsKHRoaXMubm9uUmVzaWR1ZSwgYSk7XG4gICAgfVxuXG4gICAgY29weShhKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5GLmNvcHkoYVswXSksIHRoaXMuRi5jb3B5KGFbMV0pXTtcbiAgICB9XG5cbiAgICBhZGQoYSwgYikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5GLmFkZChhWzBdLCBiWzBdKSxcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoYVsxXSwgYlsxXSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBkb3VibGUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYSxhKTtcbiAgICB9XG5cbiAgICBzdWIoYSwgYikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5GLnN1YihhWzBdLCBiWzBdKSxcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoYVsxXSwgYlsxXSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBuZWcoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy56ZXJvLCBhKTtcbiAgICB9XG5cbiAgICBjb25qdWdhdGUoYSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYVswXSxcbiAgICAgICAgICAgIHRoaXMuRi5uZWcoYVsxXSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBtdWwoYSwgYikge1xuICAgICAgICBjb25zdCBhQSA9IHRoaXMuRi5tdWwoYVswXSAsIGJbMF0pO1xuICAgICAgICBjb25zdCBiQiA9IHRoaXMuRi5tdWwoYVsxXSAsIGJbMV0pO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuYWRkKCBhQSAsIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZShiQikpLFxuICAgICAgICAgICAgdGhpcy5GLnN1YihcbiAgICAgICAgICAgICAgICB0aGlzLkYubXVsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFbMF0sIGFbMV0pLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGJbMF0sIGJbMV0pKSxcbiAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFBLCBiQikpXTtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICBjb25zdCB0MCA9IHRoaXMuRi5zcXVhcmUoYVswXSk7XG4gICAgICAgIGNvbnN0IHQxID0gdGhpcy5GLnNxdWFyZShhWzFdKTtcbiAgICAgICAgY29uc3QgdDIgPSB0aGlzLkYuc3ViKHQwLCB0aGlzLl9tdWxCeU5vblJlc2lkdWUodDEpKTtcbiAgICAgICAgY29uc3QgdDMgPSB0aGlzLkYuaW52KHQyKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5tdWwoYVswXSwgdDMpLFxuICAgICAgICAgICAgdGhpcy5GLm5lZyh0aGlzLkYubXVsKCBhWzFdLCB0MykpIF07XG4gICAgfVxuXG4gICAgZGl2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKGEsIHRoaXMuaW52KGIpKTtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICBjb25zdCBhYiA9IHRoaXMuRi5tdWwoYVswXSAsIGFbMV0pO1xuXG4gICAgICAgIC8qXG4gICAgICAgIFtcbiAgICAgICAgICAgIChhICsgYikgKiAoYSArIG5vbl9yZXNpZHVlICogYikgLSBhYiAtIG5vbl9yZXNpZHVlICogYWIsXG4gICAgICAgICAgICBhYiArIGFiXG4gICAgICAgIF07XG4gICAgICAgICovXG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoXG4gICAgICAgICAgICAgICAgdGhpcy5GLm11bChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhWzBdLCBhWzFdKSAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBhWzBdICxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZShhWzFdKSkpLFxuICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgICAgIGFiLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tdWxCeU5vblJlc2lkdWUoYWIpKSksXG4gICAgICAgICAgICB0aGlzLkYuYWRkKGFiLCBhYilcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5GLmlzWmVybyhhWzBdKSAmJiB0aGlzLkYuaXNaZXJvKGFbMV0pO1xuICAgIH1cblxuICAgIGVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRi5lcShhWzBdLCBiWzBdKSAmJiB0aGlzLkYuZXEoYVsxXSwgYlsxXSk7XG4gICAgfVxuXG4gICAgbXVsU2NhbGFyKGJhc2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIGZVdGlscy5tdWxTY2FsYXIodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgcG93KGJhc2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIGZVdGlscy5leHAodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgZXhwKGJhc2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIGZVdGlscy5leHAodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoYSkge1xuICAgICAgICByZXR1cm4gYFsgJHt0aGlzLkYudG9TdHJpbmcoYVswXSl9ICwgJHt0aGlzLkYudG9TdHJpbmcoYVsxXSl9IF1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMV07XG4gICAgfVxuXG4gICAgZ3QoYSwgYikge1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMF0sIGJbMF0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChiWzBdLCBhWzBdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMV0sIGJbMV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGdlcShhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmd0KGEsIGIpIHx8IHRoaXMuZXEoYSwgYik7XG4gICAgfVxuXG4gICAgbHQoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZ2VxKGEsYik7XG4gICAgfVxuXG4gICAgbGVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmd0KGEsYik7XG4gICAgfVxuXG4gICAgbmVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVxKGEsYik7XG4gICAgfVxuXG4gICAgcmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuRi5yYW5kb20oKSwgdGhpcy5GLnJhbmRvbSgpXTtcbiAgICB9XG5cblxuICAgIHRvUnByTEUoYnVmZiwgbywgZSkge1xuICAgICAgICB0aGlzLkYudG9ScHJMRShidWZmLCBvLCBlWzBdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbyt0aGlzLkYubjgsIGVbMV0pO1xuICAgIH1cblxuICAgIHRvUnByQkUoYnVmZiwgbywgZSkge1xuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvLCBlWzFdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkUoYnVmZiwgbyt0aGlzLkYubjgsIGVbMF0pO1xuICAgIH1cblxuICAgIHRvUnByTEVNKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8sIGVbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgsIGVbMV0pO1xuICAgIH1cblxuXG4gICAgdG9ScHJCRU0oYnVmZiwgbywgZSkge1xuICAgICAgICB0aGlzLkYudG9ScHJCRU0oYnVmZiwgbywgZVsxXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckJFTShidWZmLCBvK3RoaXMuRi5uOCwgZVswXSk7XG4gICAgfVxuXG4gICAgZnJvbVJwckxFKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckxFKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5mcm9tUnByTEUoYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMV07XG4gICAgfVxuXG4gICAgZnJvbVJwckJFKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5mcm9tUnByQkUoYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMV07XG4gICAgfVxuXG4gICAgZnJvbVJwckxFTShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMV07XG4gICAgfVxuXG4gICAgZnJvbVJwckJFTShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21ScHJCRU0oYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21ScHJCRU0oYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMV07XG4gICAgfVxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/f2field.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/f3field.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/f3field.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ F3Field)\n/* harmony export */ });\n/* harmony import */ var _futils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./futils.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nclass F3Field {\n    constructor(F, nonResidue) {\n        this.type=\"F3\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*3;\n        this.p = F.p;\n        this.n64 = F.n64*3;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1]), this.F.copy(a[2])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1]),\n            this.F.add(a[2], b[2])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1]),\n            this.F.sub(a[2], b[2])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    mul(a, b) {\n\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n        const cC = this.F.mul(a[2] , b[2]);\n\n        return [\n            this.F.add(\n                aA,\n                this._mulByNonResidue(\n                    this.F.sub(\n                        this.F.mul(\n                            this.F.add(a[1], a[2]),\n                            this.F.add(b[1], b[2])),\n                        this.F.add(bB, cC)))),    // aA + non_residue*((b+c)*(B+C)-bB-cC),\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[1]),\n                        this.F.add(b[0], b[1])),\n                    this.F.add(aA, bB)),\n                this._mulByNonResidue( cC)),   // (a+b)*(A+B)-aA-bB+non_residue*cC\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[2]),\n                        this.F.add(b[0], b[2])),\n                    this.F.add(aA, cC)),\n                bB)];                           // (a+c)*(A+C)-aA+bB-cC)\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);             // t0 = a^2 ;\n        const t1 = this.F.square(a[1]);             // t1 = b^2 ;\n        const t2 = this.F.square(a[2]);             // t2 = c^2;\n        const t3 = this.F.mul(a[0],a[1]);           // t3 = ab\n        const t4 = this.F.mul(a[0],a[2]);           // t4 = ac\n        const t5 = this.F.mul(a[1],a[2]);           // t5 = bc;\n        // c0 = t0 - non_residue * t5;\n        const c0 = this.F.sub(t0, this._mulByNonResidue(t5));\n        // c1 = non_residue * t2 - t3;\n        const c1 = this.F.sub(this._mulByNonResidue(t2), t3);\n        const c2 = this.F.sub(t1, t4);              // c2 = t1-t4\n\n        // t6 = (a * c0 + non_residue * (c * c1 + b * c2)).inv();\n        const t6 =\n            this.F.inv(\n                this.F.add(\n                    this.F.mul(a[0], c0),\n                    this._mulByNonResidue(\n                        this.F.add(\n                            this.F.mul(a[2], c1),\n                            this.F.mul(a[1], c2)))));\n\n        return [\n            this.F.mul(t6, c0),         // t6*c0\n            this.F.mul(t6, c1),         // t6*c1\n            this.F.mul(t6, c2)];        // t6*c2\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const s0 = this.F.square(a[0]);                   // s0 = a^2\n        const ab = this.F.mul(a[0], a[1]);                // ab = a*b\n        const s1 = this.F.add(ab, ab);                    // s1 = 2ab;\n        const s2 = this.F.square(\n            this.F.add(this.F.sub(a[0],a[1]), a[2]));     // s2 = (a - b + c)^2;\n        const bc = this.F.mul(a[1],a[2]);                 // bc = b*c\n        const s3 = this.F.add(bc, bc);                    // s3 = 2*bc\n        const s4 = this.F.square(a[2]);                   // s4 = c^2\n\n\n        return [\n            this.F.add(\n                s0,\n                this._mulByNonResidue(s3)),           // s0 + non_residue * s3,\n            this.F.add(\n                s1,\n                this._mulByNonResidue(s4)),           // s1 + non_residue * s4,\n            this.F.sub(\n                this.F.add( this.F.add(s1, s2) , s3 ),\n                this.F.add(s0, s4))];                      // s1 + s2 + s3 - s0 - s4\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]) && this.F.isZero(a[2]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]) && this.F.eq(a[2], b[2]);\n    }\n\n    affine(a) {\n        return [this.F.affine(a[0]), this.F.affine(a[1]), this.F.affine(a[2])];\n    }\n\n    mulScalar(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return _futils_js__WEBPACK_IMPORTED_MODULE_0__.exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])}, ${this.F.toString(a[2])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        return [c0, c1, c2];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        if (this.F.gt(b[1], a[1])) return false;\n        if (this.F.gt(a[2], b[2])) return true;\n        return false;\n    }\n\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n        this.F.toRprLE(buff, o+this.F.n8*2, e[2]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[2]);\n        this.F.toRprBE(buff, o+this.F.n8, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8*2, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprLEM(buff, o+this.F.n8*2, e[2]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[2]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8*2, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.n8);\n        const c2 = this.F.fromRprLE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBE(buff, o);\n        const c1 = this.F.fromRprBE(buff, o+this.n8);\n        const c0 = this.F.fromRprBE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.n8);\n        const c2 = this.F.fromRprLEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBEM(buff, o);\n        const c1 = this.F.fromRprBEM(buff, o+this.n8);\n        const c0 = this.F.fromRprBEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mM2ZpZWxkLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0M7O0FBRXZCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQ7QUFDQSwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCwwREFBMEQ7OztBQUcxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGlEQUFnQjtBQUMvQjs7QUFFQTtBQUNBLGVBQWUsMkNBQVU7QUFDekI7O0FBRUE7QUFDQSxlQUFlLDJDQUFVO0FBQ3pCOztBQUVBO0FBQ0Esb0JBQW9CLHVCQUF1QixJQUFJLHNCQUFzQixJQUFJLHVCQUF1QjtBQUNoRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mM2ZpZWxkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGZVdGlscyBmcm9tIFwiLi9mdXRpbHMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRjNGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoRiwgbm9uUmVzaWR1ZSkge1xuICAgICAgICB0aGlzLnR5cGU9XCJGM1wiO1xuICAgICAgICB0aGlzLkYgPSBGO1xuICAgICAgICB0aGlzLnplcm8gPSBbdGhpcy5GLnplcm8sIHRoaXMuRi56ZXJvLCB0aGlzLkYuemVyb107XG4gICAgICAgIHRoaXMub25lID0gW3RoaXMuRi5vbmUsIHRoaXMuRi56ZXJvLCB0aGlzLkYuemVyb107XG4gICAgICAgIHRoaXMubmVnb25lID0gdGhpcy5uZWcodGhpcy5vbmUpO1xuICAgICAgICB0aGlzLm5vblJlc2lkdWUgPSBub25SZXNpZHVlO1xuICAgICAgICB0aGlzLm0gPSBGLm0qMztcbiAgICAgICAgdGhpcy5wID0gRi5wO1xuICAgICAgICB0aGlzLm42NCA9IEYubjY0KjM7XG4gICAgICAgIHRoaXMubjMyID0gdGhpcy5uNjQqMjtcbiAgICAgICAgdGhpcy5uOCA9IHRoaXMubjY0Kjg7XG4gICAgfVxuXG4gICAgX211bEJ5Tm9uUmVzaWR1ZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYubXVsKHRoaXMubm9uUmVzaWR1ZSwgYSk7XG4gICAgfVxuXG4gICAgY29weShhKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5GLmNvcHkoYVswXSksIHRoaXMuRi5jb3B5KGFbMV0pLCB0aGlzLkYuY29weShhWzJdKV07XG4gICAgfVxuXG4gICAgYWRkKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoYVswXSwgYlswXSksXG4gICAgICAgICAgICB0aGlzLkYuYWRkKGFbMV0sIGJbMV0pLFxuICAgICAgICAgICAgdGhpcy5GLmFkZChhWzJdLCBiWzJdKVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGRvdWJsZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhLGEpO1xuICAgIH1cblxuICAgIHN1YihhLCBiKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuc3ViKGFbMF0sIGJbMF0pLFxuICAgICAgICAgICAgdGhpcy5GLnN1YihhWzFdLCBiWzFdKSxcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoYVsyXSwgYlsyXSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBuZWcoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy56ZXJvLCBhKTtcbiAgICB9XG5cbiAgICBtdWwoYSwgYikge1xuXG4gICAgICAgIGNvbnN0IGFBID0gdGhpcy5GLm11bChhWzBdICwgYlswXSk7XG4gICAgICAgIGNvbnN0IGJCID0gdGhpcy5GLm11bChhWzFdICwgYlsxXSk7XG4gICAgICAgIGNvbnN0IGNDID0gdGhpcy5GLm11bChhWzJdICwgYlsyXSk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgYUEsXG4gICAgICAgICAgICAgICAgdGhpcy5fbXVsQnlOb25SZXNpZHVlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLm11bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFbMV0sIGFbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYlsxXSwgYlsyXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChiQiwgY0MpKSkpLCAgICAvLyBhQSArIG5vbl9yZXNpZHVlKigoYitjKSooQitDKS1iQi1jQyksXG5cbiAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgdGhpcy5GLnN1YihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLm11bChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYVswXSwgYVsxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGJbMF0sIGJbMV0pKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhQSwgYkIpKSxcbiAgICAgICAgICAgICAgICB0aGlzLl9tdWxCeU5vblJlc2lkdWUoIGNDKSksICAgLy8gKGErYikqKEErQiktYUEtYkIrbm9uX3Jlc2lkdWUqY0NcblxuICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICB0aGlzLkYuc3ViKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhWzBdLCBhWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYlswXSwgYlsyXSkpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFBLCBjQykpLFxuICAgICAgICAgICAgICAgIGJCKV07ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGErYykqKEErQyktYUErYkItY0MpXG4gICAgfVxuXG4gICAgaW52KGEpIHtcbiAgICAgICAgY29uc3QgdDAgPSB0aGlzLkYuc3F1YXJlKGFbMF0pOyAgICAgICAgICAgICAvLyB0MCA9IGFeMiA7XG4gICAgICAgIGNvbnN0IHQxID0gdGhpcy5GLnNxdWFyZShhWzFdKTsgICAgICAgICAgICAgLy8gdDEgPSBiXjIgO1xuICAgICAgICBjb25zdCB0MiA9IHRoaXMuRi5zcXVhcmUoYVsyXSk7ICAgICAgICAgICAgIC8vIHQyID0gY14yO1xuICAgICAgICBjb25zdCB0MyA9IHRoaXMuRi5tdWwoYVswXSxhWzFdKTsgICAgICAgICAgIC8vIHQzID0gYWJcbiAgICAgICAgY29uc3QgdDQgPSB0aGlzLkYubXVsKGFbMF0sYVsyXSk7ICAgICAgICAgICAvLyB0NCA9IGFjXG4gICAgICAgIGNvbnN0IHQ1ID0gdGhpcy5GLm11bChhWzFdLGFbMl0pOyAgICAgICAgICAgLy8gdDUgPSBiYztcbiAgICAgICAgLy8gYzAgPSB0MCAtIG5vbl9yZXNpZHVlICogdDU7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLnN1Yih0MCwgdGhpcy5fbXVsQnlOb25SZXNpZHVlKHQ1KSk7XG4gICAgICAgIC8vIGMxID0gbm9uX3Jlc2lkdWUgKiB0MiAtIHQzO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5zdWIodGhpcy5fbXVsQnlOb25SZXNpZHVlKHQyKSwgdDMpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5zdWIodDEsIHQ0KTsgICAgICAgICAgICAgIC8vIGMyID0gdDEtdDRcblxuICAgICAgICAvLyB0NiA9IChhICogYzAgKyBub25fcmVzaWR1ZSAqIChjICogYzEgKyBiICogYzIpKS5pbnYoKTtcbiAgICAgICAgY29uc3QgdDYgPVxuICAgICAgICAgICAgdGhpcy5GLmludihcbiAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKGFbMF0sIGMwKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXVsQnlOb25SZXNpZHVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKGFbMl0sIGMxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYubXVsKGFbMV0sIGMyKSkpKSk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5tdWwodDYsIGMwKSwgICAgICAgICAvLyB0NipjMFxuICAgICAgICAgICAgdGhpcy5GLm11bCh0NiwgYzEpLCAgICAgICAgIC8vIHQ2KmMxXG4gICAgICAgICAgICB0aGlzLkYubXVsKHQ2LCBjMildOyAgICAgICAgLy8gdDYqYzJcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgdGhpcy5pbnYoYikpO1xuICAgIH1cblxuICAgIHNxdWFyZShhKSB7XG4gICAgICAgIGNvbnN0IHMwID0gdGhpcy5GLnNxdWFyZShhWzBdKTsgICAgICAgICAgICAgICAgICAgLy8gczAgPSBhXjJcbiAgICAgICAgY29uc3QgYWIgPSB0aGlzLkYubXVsKGFbMF0sIGFbMV0pOyAgICAgICAgICAgICAgICAvLyBhYiA9IGEqYlxuICAgICAgICBjb25zdCBzMSA9IHRoaXMuRi5hZGQoYWIsIGFiKTsgICAgICAgICAgICAgICAgICAgIC8vIHMxID0gMmFiO1xuICAgICAgICBjb25zdCBzMiA9IHRoaXMuRi5zcXVhcmUoXG4gICAgICAgICAgICB0aGlzLkYuYWRkKHRoaXMuRi5zdWIoYVswXSxhWzFdKSwgYVsyXSkpOyAgICAgLy8gczIgPSAoYSAtIGIgKyBjKV4yO1xuICAgICAgICBjb25zdCBiYyA9IHRoaXMuRi5tdWwoYVsxXSxhWzJdKTsgICAgICAgICAgICAgICAgIC8vIGJjID0gYipjXG4gICAgICAgIGNvbnN0IHMzID0gdGhpcy5GLmFkZChiYywgYmMpOyAgICAgICAgICAgICAgICAgICAgLy8gczMgPSAyKmJjXG4gICAgICAgIGNvbnN0IHM0ID0gdGhpcy5GLnNxdWFyZShhWzJdKTsgICAgICAgICAgICAgICAgICAgLy8gczQgPSBjXjJcblxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuYWRkKFxuICAgICAgICAgICAgICAgIHMwLFxuICAgICAgICAgICAgICAgIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZShzMykpLCAgICAgICAgICAgLy8gczAgKyBub25fcmVzaWR1ZSAqIHMzLFxuICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICBzMSxcbiAgICAgICAgICAgICAgICB0aGlzLl9tdWxCeU5vblJlc2lkdWUoczQpKSwgICAgICAgICAgIC8vIHMxICsgbm9uX3Jlc2lkdWUgKiBzNCxcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoXG4gICAgICAgICAgICAgICAgdGhpcy5GLmFkZCggdGhpcy5GLmFkZChzMSwgczIpICwgczMgKSxcbiAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKHMwLCBzNCkpXTsgICAgICAgICAgICAgICAgICAgICAgLy8gczEgKyBzMiArIHMzIC0gczAgLSBzNFxuICAgIH1cblxuICAgIGlzWmVybyhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYuaXNaZXJvKGFbMF0pICYmIHRoaXMuRi5pc1plcm8oYVsxXSkgJiYgdGhpcy5GLmlzWmVybyhhWzJdKTtcbiAgICB9XG5cbiAgICBlcShhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYuZXEoYVswXSwgYlswXSkgJiYgdGhpcy5GLmVxKGFbMV0sIGJbMV0pICYmIHRoaXMuRi5lcShhWzJdLCBiWzJdKTtcbiAgICB9XG5cbiAgICBhZmZpbmUoYSkge1xuICAgICAgICByZXR1cm4gW3RoaXMuRi5hZmZpbmUoYVswXSksIHRoaXMuRi5hZmZpbmUoYVsxXSksIHRoaXMuRi5hZmZpbmUoYVsyXSldO1xuICAgIH1cblxuICAgIG11bFNjYWxhcihiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBmVXRpbHMubXVsU2NhbGFyKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIHBvdyhiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBmVXRpbHMuZXhwKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIGV4cChiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBmVXRpbHMuZXhwKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKGEpIHtcbiAgICAgICAgcmV0dXJuIGBbICR7dGhpcy5GLnRvU3RyaW5nKGFbMF0pfSAsICR7dGhpcy5GLnRvU3RyaW5nKGFbMV0pfSwgJHt0aGlzLkYudG9TdHJpbmcoYVsyXSl9IF1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgIHJldHVybiBbYzAsIGMxLCBjMl07XG4gICAgfVxuXG4gICAgZ3QoYSwgYikge1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMF0sIGJbMF0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChiWzBdLCBhWzBdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMV0sIGJbMV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChiWzFdLCBhWzFdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5GLmd0KGFbMl0sIGJbMl0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgZ2VxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3QoYSwgYikgfHwgdGhpcy5lcShhLCBiKTtcbiAgICB9XG5cbiAgICBsdChhLCBiKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5nZXEoYSxiKTtcbiAgICB9XG5cbiAgICBsZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZ3QoYSxiKTtcbiAgICB9XG5cbiAgICBuZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXEoYSxiKTtcbiAgICB9XG5cbiAgICByYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5GLnJhbmRvbSgpLCB0aGlzLkYucmFuZG9tKCksIHRoaXMuRi5yYW5kb20oKV07XG4gICAgfVxuXG5cbiAgICB0b1JwckxFKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbywgZVswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFKGJ1ZmYsIG8rdGhpcy5GLm44LCBlWzFdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbyt0aGlzLkYubjgqMiwgZVsyXSk7XG4gICAgfVxuXG4gICAgdG9ScHJCRShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8sIGVbMl0pO1xuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvK3RoaXMuRi5uOCwgZVsxXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8rdGhpcy5GLm44KjIsIGVbMF0pO1xuICAgIH1cblxuICAgIHRvUnByTEVNKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8sIGVbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgsIGVbMV0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbyt0aGlzLkYubjgqMiwgZVsyXSk7XG4gICAgfVxuXG5cbiAgICB0b1JwckJFTShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckJFTShidWZmLCBvLCBlWzJdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkVNKGJ1ZmYsIG8rdGhpcy5GLm44LCBlWzFdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkVNKGJ1ZmYsIG8rdGhpcy5GLm44KjIsIGVbMF0pO1xuICAgIH1cblxuICAgIGZyb21ScHJMRShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21ScHJMRShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckxFKGJ1ZmYsIG8rdGhpcy5uOCk7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5GLmZyb21ScHJMRShidWZmLCBvK3RoaXMubjgqMik7XG4gICAgICAgIHJldHVybiBbYzAsIGMxLCBjMl07XG4gICAgfVxuXG4gICAgZnJvbVJwckJFKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8pO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5mcm9tUnByQkUoYnVmZiwgbyt0aGlzLm44KTtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8rdGhpcy5uOCoyKTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzEsIGMyXTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvK3RoaXMubjgpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5mcm9tUnByTEVNKGJ1ZmYsIG8rdGhpcy5uOCoyKTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzEsIGMyXTtcbiAgICB9XG5cbiAgICBmcm9tUnByQkVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvK3RoaXMubjgpO1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5mcm9tUnByQkVNKGJ1ZmYsIG8rdGhpcy5uOCoyKTtcbiAgICAgICAgcmV0dXJuIFtjMCwgYzEsIGMyXTtcbiAgICB9XG5cbiAgICB0b09iamVjdChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/f3field.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/fft.js":
/*!*******************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/fft.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FFT)\n/* harmony export */ });\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nclass FFT {\n    constructor (G, F, opMulGF) {\n        this.F = F;\n        this.G = G;\n        this.opMulGF = opMulGF;\n\n        let rem = F.sqrt_t || F.t;\n        let s = F.sqrt_s || F.s;\n\n        let nqr = F.one;\n        while (F.eq(F.pow(nqr, F.half), F.one)) nqr = F.add(nqr, F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(nqr, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n        /*\n        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n        */\n        this._setRoots(Math.min(s, 15));\n    }\n\n    _setRoots(n) {\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots[i] = rootsi;\n        }\n    }\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res = __fft(this, p, bits, 0, 1);\n        return res;\n    }\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res =  __fft(this, p, bits, 0, 1);\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.opMulGF(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n    }\n\n\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.G.add(pall[offset], pall[offset + step]),\n            PF.G.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n        out[i+ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n    }\n\n    return out;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mZnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvZmZ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8qXG4gICAgVGhpcyBsaWJyYXJ5IGRvZXMgb3BlcmF0aW9ucyBvbiBwb2x5bm9taWFscyB3aXRoIGNvZWZmaWNpZW50cyBpbiBhIGZpZWxkIEYuXG5cbiAgICBBIHBvbHlub21pYWwgUCh4KSA9IHAwICsgcDEgKiB4ICsgcDIgKiB4XjIgKyAuLi4gKyBwbiAqIHhebiAgaXMgcmVwcmVzZW50ZWRcbiAgICBieSB0aGUgYXJyYXkgWyBwMCwgcDEsIHAyLCAuLi4gLCBwbiBdLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZGVCB7XG4gICAgY29uc3RydWN0b3IgKEcsIEYsIG9wTXVsR0YpIHtcbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy5HID0gRztcbiAgICAgICAgdGhpcy5vcE11bEdGID0gb3BNdWxHRjtcblxuICAgICAgICBsZXQgcmVtID0gRi5zcXJ0X3QgfHwgRi50O1xuICAgICAgICBsZXQgcyA9IEYuc3FydF9zIHx8IEYucztcblxuICAgICAgICBsZXQgbnFyID0gRi5vbmU7XG4gICAgICAgIHdoaWxlIChGLmVxKEYucG93KG5xciwgRi5oYWxmKSwgRi5vbmUpKSBucXIgPSBGLmFkZChucXIsIEYub25lKTtcblxuICAgICAgICB0aGlzLncgPSBuZXcgQXJyYXkocysxKTtcbiAgICAgICAgdGhpcy53aSA9IG5ldyBBcnJheShzKzEpO1xuICAgICAgICB0aGlzLndbc10gPSB0aGlzLkYucG93KG5xciwgcmVtKTtcbiAgICAgICAgdGhpcy53aVtzXSA9IHRoaXMuRi5pbnYodGhpcy53W3NdKTtcblxuICAgICAgICBsZXQgbj1zLTE7XG4gICAgICAgIHdoaWxlIChuPj0wKSB7XG4gICAgICAgICAgICB0aGlzLndbbl0gPSB0aGlzLkYuc3F1YXJlKHRoaXMud1tuKzFdKTtcbiAgICAgICAgICAgIHRoaXMud2lbbl0gPSB0aGlzLkYuc3F1YXJlKHRoaXMud2lbbisxXSk7XG4gICAgICAgICAgICBuLS07XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMucm9vdHMgPSBbXTtcbiAgICAgICAgLypcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDE2OyBpKyspIHtcbiAgICAgICAgICAgIGxldCByID0gdGhpcy5GLm9uZTtcbiAgICAgICAgICAgIG4gPSAxIDw8IGk7XG4gICAgICAgICAgICBjb25zdCByb290c2kgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8bjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNpW2pdID0gcjtcbiAgICAgICAgICAgICAgICByID0gdGhpcy5GLm11bChyLCB0aGlzLndbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJvb3RzLnB1c2gocm9vdHNpKTtcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZXRSb290cyhNYXRoLm1pbihzLCAxNSkpO1xuICAgIH1cblxuICAgIF9zZXRSb290cyhuKSB7XG4gICAgICAgIGZvciAobGV0IGk9bjsgKGk+PTApICYmICghdGhpcy5yb290c1tpXSk7IGktLSkge1xuICAgICAgICAgICAgbGV0IHIgPSB0aGlzLkYub25lO1xuICAgICAgICAgICAgY29uc3QgbnJvb3RzID0gMSA8PCBpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdHNpID0gbmV3IEFycmF5KG5yb290cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8bnJvb3RzOyBqKyspIHtcbiAgICAgICAgICAgICAgICByb290c2lbal0gPSByO1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzLkYubXVsKHIsIHRoaXMud1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucm9vdHNbaV0gPSByb290c2k7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmZnQocCkge1xuICAgICAgICBpZiAocC5sZW5ndGggPD0gMSkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuXG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHM7XG4gICAgICAgIGlmIChwLmxlbmd0aCAhPSBtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplIG11c3QgYmUgbXVsdGlwbGUgb2YgMlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBfX2ZmdCh0aGlzLCBwLCBiaXRzLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZmZ0KHApIHtcblxuICAgICAgICBpZiAocC5sZW5ndGggPD0gMSkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuICAgICAgICBjb25zdCBtID0gMSA8PCBiaXRzO1xuICAgICAgICBpZiAocC5sZW5ndGggIT0gbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBtdXN0IGJlIG11bHRpcGxlIG9mIDJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gIF9fZmZ0KHRoaXMsIHAsIGJpdHMsIDAsIDEpO1xuICAgICAgICBjb25zdCB0d29pbnZtID0gdGhpcy5GLmludiggdGhpcy5GLm11bFNjYWxhcih0aGlzLkYub25lLCBtKSApO1xuICAgICAgICBjb25zdCByZXNuID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bTsgaSsrKSB7XG4gICAgICAgICAgICByZXNuW2ldID0gdGhpcy5vcE11bEdGKHJlc1sobS1pKSVtXSwgdHdvaW52bSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzbjtcbiAgICB9XG5cblxufVxuXG5mdW5jdGlvbiBsb2cyKCBWIClcbntcbiAgICByZXR1cm4oICggKCBWICYgMHhGRkZGMDAwMCApICE9PSAwID8gKCBWICY9IDB4RkZGRjAwMDAsIDE2ICkgOiAwICkgfCAoICggViAmIDB4RkYwMEZGMDAgKSAhPT0gMCA/ICggViAmPSAweEZGMDBGRjAwLCA4ICkgOiAwICkgfCAoICggViAmIDB4RjBGMEYwRjAgKSAhPT0gMCA/ICggViAmPSAweEYwRjBGMEYwLCA0ICkgOiAwICkgfCAoICggViAmIDB4Q0NDQ0NDQ0MgKSAhPT0gMCA/ICggViAmPSAweENDQ0NDQ0NDLCAyICkgOiAwICkgfCAoICggViAmIDB4QUFBQUFBQUEgKSAhPT0gMCApICk7XG59XG5cblxuZnVuY3Rpb24gX19mZnQoUEYsIHBhbGwsIGJpdHMsIG9mZnNldCwgc3RlcCkge1xuXG4gICAgY29uc3QgbiA9IDEgPDwgYml0cztcbiAgICBpZiAobj09MSkge1xuICAgICAgICByZXR1cm4gWyBwYWxsW29mZnNldF0gXTtcbiAgICB9IGVsc2UgaWYgKG49PTIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFBGLkcuYWRkKHBhbGxbb2Zmc2V0XSwgcGFsbFtvZmZzZXQgKyBzdGVwXSksXG4gICAgICAgICAgICBQRi5HLnN1YihwYWxsW29mZnNldF0sIHBhbGxbb2Zmc2V0ICsgc3RlcF0pXTtcbiAgICB9XG5cbiAgICBjb25zdCBuZGl2MiA9IG4gPj4gMTtcbiAgICBjb25zdCBwMSA9IF9fZmZ0KFBGLCBwYWxsLCBiaXRzLTEsIG9mZnNldCwgc3RlcCoyKTtcbiAgICBjb25zdCBwMiA9IF9fZmZ0KFBGLCBwYWxsLCBiaXRzLTEsIG9mZnNldCtzdGVwLCBzdGVwKjIpO1xuXG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgZm9yIChsZXQgaT0wOyBpPG5kaXYyOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gUEYuRy5hZGQocDFbaV0sIFBGLm9wTXVsR0YocDJbaV0sIFBGLnJvb3RzW2JpdHNdW2ldKSk7XG4gICAgICAgIG91dFtpK25kaXYyXSA9IFBGLkcuc3ViKHAxW2ldLCBQRi5vcE11bEdGKHAyW2ldLCBQRi5yb290c1tiaXRzXVtpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/fft.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/fsqrt.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/fsqrt.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ buildSqrt)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n\n// Check here: https://eprint.iacr.org/2012/685.pdf\n\nfunction buildSqrt (F) {\n    if ((F.m % 2) == 1) {\n        if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 4), 1 )) {\n            if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 8), 1 )) {\n                if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 16), 1 )) {\n                    // alg7_muller(F);\n                    alg5_tonelliShanks(F);\n                } else if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 16), 9 )) {\n                    alg4_kong(F);\n                } else {\n                    throw new Error(\"Field withot sqrt\");\n                }\n            } else if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 8), 5 )) {\n                alg3_atkin(F);\n            } else {\n                throw new Error(\"Field withot sqrt\");\n            }\n        } else if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.eq(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(F.p, 4), 3 )) {\n            alg2_shanks(F);\n        }\n    } else {\n        const pm2mod4 = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.pow(F.p, F.m/2), 4);\n        if (pm2mod4 == 1) {\n            alg10_adj(F);\n        } else if (pm2mod4 == 3) {\n            alg9_adj(F);\n        } else {\n            alg8_complex(F);\n        }\n\n    }\n}\n\n\nfunction alg5_tonelliShanks(F) {\n    F.sqrt_q = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.pow(F.p, F.m);\n\n    F.sqrt_s = 0;\n    F.sqrt_t = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(F.sqrt_q, 1);\n\n    while (!_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isOdd(F.sqrt_t)) {\n        F.sqrt_s = F.sqrt_s + 1;\n        F.sqrt_t = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.div(F.sqrt_t, 2);\n    }\n\n    let c0 = F.one;\n\n    while (F.eq(c0, F.one)) {\n        const c = F.random();\n        F.sqrt_z = F.pow(c, F.sqrt_t);\n        c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s-1) );\n    }\n\n    F.sqrt_tm1d2 = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.div(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(F.sqrt_t, 1),2);\n\n    F.sqrt = function(a) {\n        const F=this;\n        if (F.isZero(a)) return F.zero;\n        let w = F.pow(a, F.sqrt_tm1d2);\n        const a0 = F.pow( F.mul(F.square(w), a), 2 ** (F.sqrt_s-1) );\n        if (F.eq(a0, F.negone)) return null;\n\n        let v = F.sqrt_s;\n        let x = F.mul(a, w);\n        let b = F.mul(x, w);\n        let z = F.sqrt_z;\n        while (!F.eq(b, F.one)) {\n            let b2k = F.square(b);\n            let k=1;\n            while (!F.eq(b2k, F.one)) {\n                b2k = F.square(b2k);\n                k++;\n            }\n\n            w = z;\n            for (let i=0; i<v-k-1; i++) {\n                w = F.square(w);\n            }\n            z = F.square(w);\n            b = F.mul(b, z);\n            x = F.mul(x, w);\n            v = k;\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg4_kong(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 4 not implemented\");\n    };\n}\n\nfunction alg3_atkin(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 3 not implemented\");\n    };\n}\n\nfunction alg2_shanks(F) {\n\n    F.sqrt_q = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.pow(F.p, F.m);\n    F.sqrt_e1 = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.div( _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(F.sqrt_q, 3) , 4);\n\n    F.sqrt = function(a) {\n        if (this.isZero(a)) return this.zero;\n\n        // Test that have solution\n        const a1 = this.pow(a, this.sqrt_e1);\n\n        const a0 = this.mul(this.square(a1), a);\n\n        if ( this.eq(a0, this.negone) ) return null;\n\n        const x = this.mul(a1, a);\n\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg10_adj(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 10 not implemented\");\n    };\n}\n\nfunction alg9_adj(F) {\n    F.sqrt_q = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.pow(F.p, F.m/2);\n    F.sqrt_e34 = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.div( _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(F.sqrt_q, 3) , 4);\n    F.sqrt_e12 = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.div( _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(F.sqrt_q, 1) , 2);\n\n    F.frobenius = function(n, x) {\n        if ((n%2) == 1) {\n            return F.conjugate(x);\n        } else {\n            return x;\n        }\n    };\n\n    F.sqrt = function(a) {\n        const F = this;\n        const a1 = F.pow(a, F.sqrt_e34);\n        const alfa = F.mul(F.square(a1), a);\n        const a0 = F.mul(F.frobenius(1, alfa), alfa);\n        if (F.eq(a0, F.negone)) return null;\n        const x0 = F.mul(a1, a);\n        let x;\n        if (F.eq(alfa, F.negone)) {\n            x = F.mul(x0, [F.F.zero, F.F.one]);\n        } else {\n            const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n            x = F.mul(b, x0);\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\n\nfunction alg8_complex(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 8 not implemented\");\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mc3FydC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFzQztBQUN0Qzs7QUFFZTtBQUNmO0FBQ0EsWUFBWSwwQ0FBUyxDQUFDLDJDQUFVO0FBQ2hDLGdCQUFnQiwwQ0FBUyxDQUFDLDJDQUFVO0FBQ3BDLG9CQUFvQiwwQ0FBUyxDQUFDLDJDQUFVO0FBQ3hDO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUywwQ0FBUyxDQUFDLDJDQUFVO0FBQy9DO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjLFNBQVMsMENBQVMsQ0FBQywyQ0FBVTtBQUMzQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVSxTQUFTLDBDQUFTLENBQUMsMkNBQVU7QUFDdkM7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0IsMkNBQVUsQ0FBQywyQ0FBVTtBQUM3QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSxlQUFlLDJDQUFVOztBQUV6QjtBQUNBLGVBQWUsMkNBQVU7O0FBRXpCLFlBQVksNkNBQVk7QUFDeEI7QUFDQSxtQkFBbUIsMkNBQVU7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMkNBQVUsQ0FBQywyQ0FBVTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSwyQ0FBVTtBQUN6QixnQkFBZ0IsMkNBQVUsRUFBRSwyQ0FBVTs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyQ0FBVTtBQUN6QixpQkFBaUIsMkNBQVUsRUFBRSwyQ0FBVTtBQUN2QyxpQkFBaUIsMkNBQVUsRUFBRSwyQ0FBVTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mc3FydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG4vLyBDaGVjayBoZXJlOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGZcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRTcXJ0IChGKSB7XG4gICAgaWYgKChGLm0gJSAyKSA9PSAxKSB7XG4gICAgICAgIGlmIChTY2FsYXIuZXEoU2NhbGFyLm1vZChGLnAsIDQpLCAxICkpIHtcbiAgICAgICAgICAgIGlmIChTY2FsYXIuZXEoU2NhbGFyLm1vZChGLnAsIDgpLCAxICkpIHtcbiAgICAgICAgICAgICAgICBpZiAoU2NhbGFyLmVxKFNjYWxhci5tb2QoRi5wLCAxNiksIDEgKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGc3X211bGxlcihGKTtcbiAgICAgICAgICAgICAgICAgICAgYWxnNV90b25lbGxpU2hhbmtzKEYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoU2NhbGFyLmVxKFNjYWxhci5tb2QoRi5wLCAxNiksIDkgKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGc0X2tvbmcoRik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgd2l0aG90IHNxcnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChTY2FsYXIuZXEoU2NhbGFyLm1vZChGLnAsIDgpLCA1ICkpIHtcbiAgICAgICAgICAgICAgICBhbGczX2F0a2luKEYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCB3aXRob3Qgc3FydFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChTY2FsYXIuZXEoU2NhbGFyLm1vZChGLnAsIDQpLCAzICkpIHtcbiAgICAgICAgICAgIGFsZzJfc2hhbmtzKEYpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcG0ybW9kNCA9IFNjYWxhci5tb2QoU2NhbGFyLnBvdyhGLnAsIEYubS8yKSwgNCk7XG4gICAgICAgIGlmIChwbTJtb2Q0ID09IDEpIHtcbiAgICAgICAgICAgIGFsZzEwX2FkaihGKTtcbiAgICAgICAgfSBlbHNlIGlmIChwbTJtb2Q0ID09IDMpIHtcbiAgICAgICAgICAgIGFsZzlfYWRqKEYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxnOF9jb21wbGV4KEYpO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gYWxnNV90b25lbGxpU2hhbmtzKEYpIHtcbiAgICBGLnNxcnRfcSA9IFNjYWxhci5wb3coRi5wLCBGLm0pO1xuXG4gICAgRi5zcXJ0X3MgPSAwO1xuICAgIEYuc3FydF90ID0gU2NhbGFyLnN1YihGLnNxcnRfcSwgMSk7XG5cbiAgICB3aGlsZSAoIVNjYWxhci5pc09kZChGLnNxcnRfdCkpIHtcbiAgICAgICAgRi5zcXJ0X3MgPSBGLnNxcnRfcyArIDE7XG4gICAgICAgIEYuc3FydF90ID0gU2NhbGFyLmRpdihGLnNxcnRfdCwgMik7XG4gICAgfVxuXG4gICAgbGV0IGMwID0gRi5vbmU7XG5cbiAgICB3aGlsZSAoRi5lcShjMCwgRi5vbmUpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBGLnJhbmRvbSgpO1xuICAgICAgICBGLnNxcnRfeiA9IEYucG93KGMsIEYuc3FydF90KTtcbiAgICAgICAgYzAgPSBGLnBvdyhGLnNxcnRfeiwgMiAqKiAoRi5zcXJ0X3MtMSkgKTtcbiAgICB9XG5cbiAgICBGLnNxcnRfdG0xZDIgPSBTY2FsYXIuZGl2KFNjYWxhci5zdWIoRi5zcXJ0X3QsIDEpLDIpO1xuXG4gICAgRi5zcXJ0ID0gZnVuY3Rpb24oYSkge1xuICAgICAgICBjb25zdCBGPXRoaXM7XG4gICAgICAgIGlmIChGLmlzWmVybyhhKSkgcmV0dXJuIEYuemVybztcbiAgICAgICAgbGV0IHcgPSBGLnBvdyhhLCBGLnNxcnRfdG0xZDIpO1xuICAgICAgICBjb25zdCBhMCA9IEYucG93KCBGLm11bChGLnNxdWFyZSh3KSwgYSksIDIgKiogKEYuc3FydF9zLTEpICk7XG4gICAgICAgIGlmIChGLmVxKGEwLCBGLm5lZ29uZSkpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGxldCB2ID0gRi5zcXJ0X3M7XG4gICAgICAgIGxldCB4ID0gRi5tdWwoYSwgdyk7XG4gICAgICAgIGxldCBiID0gRi5tdWwoeCwgdyk7XG4gICAgICAgIGxldCB6ID0gRi5zcXJ0X3o7XG4gICAgICAgIHdoaWxlICghRi5lcShiLCBGLm9uZSkpIHtcbiAgICAgICAgICAgIGxldCBiMmsgPSBGLnNxdWFyZShiKTtcbiAgICAgICAgICAgIGxldCBrPTE7XG4gICAgICAgICAgICB3aGlsZSAoIUYuZXEoYjJrLCBGLm9uZSkpIHtcbiAgICAgICAgICAgICAgICBiMmsgPSBGLnNxdWFyZShiMmspO1xuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdyA9IHo7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8di1rLTE7IGkrKykge1xuICAgICAgICAgICAgICAgIHcgPSBGLnNxdWFyZSh3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHogPSBGLnNxdWFyZSh3KTtcbiAgICAgICAgICAgIGIgPSBGLm11bChiLCB6KTtcbiAgICAgICAgICAgIHggPSBGLm11bCh4LCB3KTtcbiAgICAgICAgICAgIHYgPSBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGLmdlcSh4LCBGLnplcm8pID8geCA6IEYubmVnKHgpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFsZzRfa29uZyhGKSB7XG4gICAgRi5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNxcnQgYWxnIDQgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFsZzNfYXRraW4oRikge1xuICAgIEYuc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcXJ0IGFsZyAzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhbGcyX3NoYW5rcyhGKSB7XG5cbiAgICBGLnNxcnRfcSA9IFNjYWxhci5wb3coRi5wLCBGLm0pO1xuICAgIEYuc3FydF9lMSA9IFNjYWxhci5kaXYoIFNjYWxhci5zdWIoRi5zcXJ0X3EsIDMpICwgNCk7XG5cbiAgICBGLnNxcnQgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhhKSkgcmV0dXJuIHRoaXMuemVybztcblxuICAgICAgICAvLyBUZXN0IHRoYXQgaGF2ZSBzb2x1dGlvblxuICAgICAgICBjb25zdCBhMSA9IHRoaXMucG93KGEsIHRoaXMuc3FydF9lMSk7XG5cbiAgICAgICAgY29uc3QgYTAgPSB0aGlzLm11bCh0aGlzLnNxdWFyZShhMSksIGEpO1xuXG4gICAgICAgIGlmICggdGhpcy5lcShhMCwgdGhpcy5uZWdvbmUpICkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgeCA9IHRoaXMubXVsKGExLCBhKTtcblxuICAgICAgICByZXR1cm4gRi5nZXEoeCwgRi56ZXJvKSA/IHggOiBGLm5lZyh4KTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhbGcxMF9hZGooRikge1xuICAgIEYuc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcXJ0IGFsZyAxMCBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWxnOV9hZGooRikge1xuICAgIEYuc3FydF9xID0gU2NhbGFyLnBvdyhGLnAsIEYubS8yKTtcbiAgICBGLnNxcnRfZTM0ID0gU2NhbGFyLmRpdiggU2NhbGFyLnN1YihGLnNxcnRfcSwgMykgLCA0KTtcbiAgICBGLnNxcnRfZTEyID0gU2NhbGFyLmRpdiggU2NhbGFyLnN1YihGLnNxcnRfcSwgMSkgLCAyKTtcblxuICAgIEYuZnJvYmVuaXVzID0gZnVuY3Rpb24obiwgeCkge1xuICAgICAgICBpZiAoKG4lMikgPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIEYuY29uanVnYXRlKHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRi5zcXJ0ID0gZnVuY3Rpb24oYSkge1xuICAgICAgICBjb25zdCBGID0gdGhpcztcbiAgICAgICAgY29uc3QgYTEgPSBGLnBvdyhhLCBGLnNxcnRfZTM0KTtcbiAgICAgICAgY29uc3QgYWxmYSA9IEYubXVsKEYuc3F1YXJlKGExKSwgYSk7XG4gICAgICAgIGNvbnN0IGEwID0gRi5tdWwoRi5mcm9iZW5pdXMoMSwgYWxmYSksIGFsZmEpO1xuICAgICAgICBpZiAoRi5lcShhMCwgRi5uZWdvbmUpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgeDAgPSBGLm11bChhMSwgYSk7XG4gICAgICAgIGxldCB4O1xuICAgICAgICBpZiAoRi5lcShhbGZhLCBGLm5lZ29uZSkpIHtcbiAgICAgICAgICAgIHggPSBGLm11bCh4MCwgW0YuRi56ZXJvLCBGLkYub25lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBiID0gRi5wb3coRi5hZGQoRi5vbmUsIGFsZmEpLCBGLnNxcnRfZTEyKTtcbiAgICAgICAgICAgIHggPSBGLm11bChiLCB4MCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEYuZ2VxKHgsIEYuemVybykgPyB4IDogRi5uZWcoeCk7XG4gICAgfTtcbn1cblxuXG5mdW5jdGlvbiBhbGc4X2NvbXBsZXgoRikge1xuICAgIEYuc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcXJ0IGFsZyA4IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/fsqrt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exp: () => (/* binding */ exp),\n/* harmony export */   mulScalar: () => (/* binding */ mulScalar)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nfunction mulScalar(F, base, e) {\n    let res;\n\n    if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isZero(e)) return F.zero;\n\n    const n = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.naf(e);\n\n    if (n[n.length-1] == 1) {\n        res = base;\n    } else if (n[n.length-1] == -1) {\n        res = F.neg(base);\n    } else {\n        throw new Error(\"invlaud NAF\");\n    }\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.double(res);\n\n        if (n[i] == 1) {\n            res = F.add(res, base);\n        } else if (n[i] == -1) {\n            res = F.sub(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n/*\nexports.mulScalar = (F, base, e) =>{\n    let res = F.zero;\n    let rem = bigInt(e);\n    let exp = base;\n\n    while (! rem.eq(bigInt.zero)) {\n        if (rem.and(bigInt.one).eq(bigInt.one)) {\n            res = F.add(res, exp);\n        }\n        exp = F.double(exp);\n        rem = rem.shiftRight(1);\n    }\n\n    return res;\n};\n*/\n\n\nfunction exp(F, base, e) {\n\n    if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isZero(e)) return F.one;\n\n    const n = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.bits(e);\n\n    if (n.length==0) return F.one;\n\n    let res = base;\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.square(res);\n\n        if (n[i]) {\n            res = F.mul(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9mdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0M7OztBQUcvQjtBQUNQOztBQUVBLFFBQVEsOENBQWE7O0FBRXJCLGNBQWMsMkNBQVU7O0FBRXhCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSwyQkFBMkIsTUFBTTs7QUFFakM7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdPOztBQUVQLFFBQVEsOENBQWE7O0FBRXJCLGNBQWMsNENBQVc7O0FBRXpCOztBQUVBOztBQUVBLDJCQUEyQixNQUFNOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvZnV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIFNjYWxhciBmcm9tIFwiLi9zY2FsYXIuanNcIjtcblxuXG5leHBvcnQgZnVuY3Rpb24gbXVsU2NhbGFyKEYsIGJhc2UsIGUpIHtcbiAgICBsZXQgcmVzO1xuXG4gICAgaWYgKFNjYWxhci5pc1plcm8oZSkpIHJldHVybiBGLnplcm87XG5cbiAgICBjb25zdCBuID0gU2NhbGFyLm5hZihlKTtcblxuICAgIGlmIChuW24ubGVuZ3RoLTFdID09IDEpIHtcbiAgICAgICAgcmVzID0gYmFzZTtcbiAgICB9IGVsc2UgaWYgKG5bbi5sZW5ndGgtMV0gPT0gLTEpIHtcbiAgICAgICAgcmVzID0gRi5uZWcoYmFzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52bGF1ZCBOQUZcIik7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaT1uLmxlbmd0aC0yOyBpPj0wOyBpLS0pIHtcblxuICAgICAgICByZXMgPSBGLmRvdWJsZShyZXMpO1xuXG4gICAgICAgIGlmIChuW2ldID09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9IEYuYWRkKHJlcywgYmFzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobltpXSA9PSAtMSkge1xuICAgICAgICAgICAgcmVzID0gRi5zdWIocmVzLCBiYXNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cblxuLypcbmV4cG9ydHMubXVsU2NhbGFyID0gKEYsIGJhc2UsIGUpID0+e1xuICAgIGxldCByZXMgPSBGLnplcm87XG4gICAgbGV0IHJlbSA9IGJpZ0ludChlKTtcbiAgICBsZXQgZXhwID0gYmFzZTtcblxuICAgIHdoaWxlICghIHJlbS5lcShiaWdJbnQuemVybykpIHtcbiAgICAgICAgaWYgKHJlbS5hbmQoYmlnSW50Lm9uZSkuZXEoYmlnSW50Lm9uZSkpIHtcbiAgICAgICAgICAgIHJlcyA9IEYuYWRkKHJlcywgZXhwKTtcbiAgICAgICAgfVxuICAgICAgICBleHAgPSBGLmRvdWJsZShleHApO1xuICAgICAgICByZW0gPSByZW0uc2hpZnRSaWdodCgxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufTtcbiovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cChGLCBiYXNlLCBlKSB7XG5cbiAgICBpZiAoU2NhbGFyLmlzWmVybyhlKSkgcmV0dXJuIEYub25lO1xuXG4gICAgY29uc3QgbiA9IFNjYWxhci5iaXRzKGUpO1xuXG4gICAgaWYgKG4ubGVuZ3RoPT0wKSByZXR1cm4gRi5vbmU7XG5cbiAgICBsZXQgcmVzID0gYmFzZTtcblxuICAgIGZvciAobGV0IGk9bi5sZW5ndGgtMjsgaT49MDsgaS0tKSB7XG5cbiAgICAgICAgcmVzID0gRi5zcXVhcmUocmVzKTtcblxuICAgICAgICBpZiAobltpXSkge1xuICAgICAgICAgICAgcmVzID0gRi5tdWwocmVzLCBiYXNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/futils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/polfield.js":
/*!************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/polfield.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PolField)\n/* harmony export */ });\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nclass PolField {\n    constructor (F) {\n        this.F = F;\n\n        let rem = F.sqrt_t;\n        let s = F.sqrt_s;\n\n        const five = this.F.add(this.F.add(this.F.two, this.F.two), this.F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(five, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n/*        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n    */\n        this._setRoots(15);\n    }\n\n    _setRoots(n) {\n        if (n > this.F.sqrt_s) n = this.s;\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n            this.roots[i] = rootsi;\n        }\n    }\n\n    add(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.add(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.sub(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    mulScalar(p, b) {\n        if (this.F.eq(b, this.F.zero)) return [];\n        if (this.F.eq(b, this.F.one)) return p;\n        const res = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.mul(p[i], b);\n        }\n        return res;\n    }\n\n\n\n    mul(a, b) {\n        if (a.length == 0) return [];\n        if (b.length == 0) return [];\n        if (a.length == 1) return this.mulScalar(b, a[0]);\n        if (b.length == 1) return this.mulScalar(a, b[0]);\n\n        if (b.length > a.length) {\n            [b, a] = [a, b];\n        }\n\n        if ((b.length <= 2) || (b.length < log2(a.length))) {\n            return this.mulNormal(a,b);\n        } else {\n            return this.mulFFT(a,b);\n        }\n    }\n\n    mulNormal(a, b) {\n        let res = [];\n        for (let i=0; i<b.length; i++) {\n            res = this.add(res, this.scaleX(this.mulScalar(a, b[i]), i) );\n        }\n        return res;\n    }\n\n    mulFFT(a,b) {\n        const longestN = Math.max(a.length, b.length);\n        const bitsResult = log2(longestN-1)+2;\n        this._setRoots(bitsResult);\n\n        const m = 1 << bitsResult;\n        const ea = this.extend(a,m);\n        const eb = this.extend(b,m);\n\n        const ta = __fft(this, ea, bitsResult, 0, 1, false);\n        const tb = __fft(this, eb, bitsResult, 0, 1, false);\n\n        const tres = new Array(m);\n\n        for (let i=0; i<m; i++) {\n            tres[i] = this.F.mul(ta[i], tb[i]);\n        }\n\n        const res = __fft(this, tres, bitsResult, 0, 1, true);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return this.reduce(resn);\n    }\n\n\n\n    square(a) {\n        return this.mul(a,a);\n    }\n\n    scaleX(p, n) {\n        if (n==0) {\n            return p;\n        } else if (n>0) {\n            const z = new Array(n).fill(this.F.zero);\n            return z.concat(p);\n        } else {\n            if (-n >= p.length) return [];\n            return p.slice(-n);\n        }\n    }\n\n    eval2(p, x) {\n        let v = this.F.zero;\n        let ix = this.F.one;\n        for (let i=0; i<p.length; i++) {\n            v = this.F.add(v, this.F.mul(p[i], ix));\n            ix = this.F.mul(ix, x);\n        }\n        return v;\n    }\n\n    evaluate(p,x) {\n        const F = this.F;\n        if (p.length == 0) return F.zero;\n        const m = this._next2Power(p.length);\n        const ep = this.extend(p, m);\n\n        return _eval(ep, x, 0, 1, m);\n\n        function _eval(p, x, offset, step, n) {\n            if (n==1) return p[offset];\n            const newX = F.square(x);\n            const res= F.add(\n                _eval(p, newX, offset, step << 1, n >> 1),\n                F.mul(\n                    x,\n                    _eval(p, newX, offset+step , step << 1, n >> 1)));\n            return res;\n        }\n    }\n\n    lagrange(points) {\n        let roots = [this.F.one];\n        for (let i=0; i<points.length; i++) {\n            roots = this.mul(roots, [this.F.neg(points[i][0]), this.F.one]);\n        }\n\n        let sum = [];\n        for (let i=0; i<points.length; i++) {\n            let mpol = this.ruffini(roots, points[i][0]);\n            const factor =\n                this.F.mul(\n                    this.F.inv(this.evaluate(mpol, points[i][0])),\n                    points[i][1]);\n            mpol = this.mulScalar(mpol, factor);\n            sum = this.add(sum, mpol);\n        }\n        return sum;\n    }\n\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res = __fft(this, ep, bits, 0, 1);\n        return res;\n    }\n\n    fft2(p) {\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res = __fft2(this, ep, bits);\n        return res;\n    }\n\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res =  __fft(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n\n    ifft2(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res =  __fft2(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n    _fft(pall, bits, offset, step) {\n\n        const n = 1 << bits;\n        if (n==1) {\n            return [ pall[offset] ];\n        }\n\n        const ndiv2 = n >> 1;\n        const p1 = this._fft(pall, bits-1, offset, step*2);\n        const p2 = this._fft(pall, bits-1, offset+step, step*2);\n\n        const out = new Array(n);\n\n        let m= this.F.one;\n        for (let i=0; i<ndiv2; i++) {\n            out[i] = this.F.add(p1[i], this.F.mul(m, p2[i]));\n            out[i+ndiv2] = this.F.sub(p1[i], this.F.mul(m, p2[i]));\n            m = this.F.mul(m, this.w[bits]);\n        }\n\n        return out;\n    }\n\n    extend(p, e) {\n        if (e == p.length) return p;\n        const z = new Array(e-p.length).fill(this.F.zero);\n\n        return p.concat(z);\n    }\n\n    reduce(p) {\n        if (p.length == 0) return p;\n        if (! this.F.eq(p[p.length-1], this.F.zero) ) return p;\n        let i=p.length-1;\n        while( i>0 && this.F.eq(p[i], this.F.zero) ) i--;\n        return p.slice(0, i+1);\n    }\n\n    eq(a, b) {\n        const pa = this.reduce(a);\n        const pb = this.reduce(b);\n\n        if (pa.length != pb.length) return false;\n        for (let i=0; i<pb.length; i++) {\n            if (!this.F.eq(pa[i], pb[i])) return false;\n        }\n\n        return true;\n    }\n\n    ruffini(p, r) {\n        const res = new Array(p.length-1);\n        res[res.length-1] = p[p.length-1];\n        for (let i = res.length-2; i>=0; i--) {\n            res[i] = this.F.add(this.F.mul(res[i+1], r), p[i+1]);\n        }\n        return res;\n    }\n\n    _next2Power(v) {\n        v--;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v++;\n        return v;\n    }\n\n    toString(p) {\n        const ap = this.normalize(p);\n        let S = \"\";\n        for (let i=ap.length-1; i>=0; i--) {\n            if (!this.F.eq(p[i], this.F.zero)) {\n                if (S!=\"\") S += \" + \";\n                S = S + p[i].toString(10);\n                if (i>0) {\n                    S = S + \"x\";\n                    if (i>1) {\n                        S = S + \"^\" +i;\n                    }\n                }\n            }\n        }\n        return S;\n    }\n\n    normalize(p) {\n        const res  = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.normalize(p[i]);\n        }\n        return res;\n    }\n\n\n    _reciprocal(p, bits) {\n        const k = 1 << bits;\n        if (k==1) {\n            return [ this.F.inv(p[0]) ];\n        }\n        const np = this.scaleX(p, -k/2);\n        const q = this._reciprocal(np, bits-1);\n        const a = this.scaleX(this.double(q), 3*k/2-2);\n        const b = this.mul( this.square(q), p);\n\n        return this.scaleX(this.sub(a,b),   -(k-2));\n    }\n\n    // divides x^m / v\n    _div2(m, v) {\n        const kbits = log2(v.length-1)+1;\n        const k = 1 << kbits;\n\n        const scaleV = k - v.length;\n\n        // rec = x^(k - 2) / v* x^scaleV =>\n        // rec = x^(k-2-scaleV)/ v\n        //\n        // res = x^m/v = x^(m + (2*k-2 - scaleV) - (2*k-2 - scaleV)) /v =>\n        // res = rec * x^(m - (2*k-2 - scaleV)) =>\n        // res = rec * x^(m - 2*k + 2 + scaleV)\n\n        const rec = this._reciprocal(this.scaleX(v, scaleV), kbits);\n        const res = this.scaleX(rec, m - 2*k + 2 + scaleV);\n\n        return res;\n    }\n\n    div(_u, _v) {\n        if (_u.length < _v.length) return [];\n        const kbits = log2(_v.length-1)+1;\n        const k = 1 << kbits;\n\n        const u = this.scaleX(_u, k-_v.length);\n        const v = this.scaleX(_v, k-_v.length);\n\n        const n = v.length-1;\n        let m = u.length-1;\n\n        const s = this._reciprocal(v, kbits);\n        let t;\n        if (m>2*n) {\n            t = this.sub(this.scaleX([this.F.one], 2*n), this.mul(s, v));\n        }\n\n        let q = [];\n        let rem = u;\n        let us, ut;\n        let finish = false;\n\n        while (!finish) {\n            us = this.mul(rem, s);\n            q = this.add(q, this.scaleX(us, -2*n));\n\n            if ( m > 2*n ) {\n                ut = this.mul(rem, t);\n                rem = this.scaleX(ut, -2*n);\n                m = rem.length-1;\n            } else {\n                finish = true;\n            }\n        }\n\n        return q;\n    }\n\n\n    // returns the ith nth-root of one\n    oneRoot(n, i) {\n        let nbits = log2(n-1)+1;\n        let res = this.F.one;\n        let r = i;\n\n        if(i>=n) {\n            throw new Error(\"Given 'i' should be lower than 'n'\");\n        }\n        else if (1<<nbits !== n) {\n            throw new Error(`Internal errlr: ${n} should equal ${1<<nbits}`);\n        }\n\n        while (r>0) {\n            if (r & 1 == 1) {\n                res = this.F.mul(res, this.w[nbits]);\n            }\n            r = r >> 1;\n            nbits --;\n        }\n        return res;\n    }\n\n    computeVanishingPolinomial(bits, t) {\n        const m = 1 << bits;\n        return this.F.sub(this.F.pow(t, m), this.F.one);\n    }\n\n    evaluateLagrangePolynomials(bits, t) {\n        const m= 1 << bits;\n        const tm = this.F.pow(t, m);\n        const u= new Array(m).fill(this.F.zero);\n        this._setRoots(bits);\n        const omega = this.w[bits];\n\n        if (this.F.eq(tm, this.F.one)) {\n            for (let i = 0; i < m; i++) {\n                if (this.F.eq(this.roots[bits][0],t)) { // i.e., t equals omega^i\n                    u[i] = this.F.one;\n                    return u;\n                }\n            }\n        }\n\n        const z = this.F.sub(tm, this.F.one);\n        //        let l = this.F.mul(z,  this.F.pow(this.F.twoinv, m));\n        let l = this.F.mul(z,  this.F.inv(this.F.e(m)));\n        for (let i = 0; i < m; i++) {\n            u[i] = this.F.mul(l, this.F.inv(this.F.sub(t,this.roots[bits][i])));\n            l = this.F.mul(l, omega);\n        }\n\n        return u;\n    }\n\n    log2(V) {\n        return log2(V);\n    }\n}\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.F.add(pall[offset], pall[offset + step]),\n            PF.F.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\n\nfunction __fft2(PF, pall, bits) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[0] ];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft2(PF, pall.slice(0, ndiv2), bits-1);\n    const p2 = __fft2(PF, pall.slice(ndiv2), bits-1);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction rev(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\nfunction __bitReverse(p, bits) {\n    for (let k=0; k<p.length; k++) {\n        const r = rev(k, bits);\n        if (r>k) {\n            const tmp= p[k];\n            p[k] = p[r];\n            p[r] = tmp;\n        }\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9wb2xmaWVsZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxHQUFHLGVBQWUsU0FBUztBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkMsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9wb2xmaWVsZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKlxuICAgIFRoaXMgbGlicmFyeSBkb2VzIG9wZXJhdGlvbnMgb24gcG9seW5vbWlhbHMgd2l0aCBjb2VmZmljaWVudHMgaW4gYSBmaWVsZCBGLlxuXG4gICAgQSBwb2x5bm9taWFsIFAoeCkgPSBwMCArIHAxICogeCArIHAyICogeF4yICsgLi4uICsgcG4gKiB4Xm4gIGlzIHJlcHJlc2VudGVkXG4gICAgYnkgdGhlIGFycmF5IFsgcDAsIHAxLCBwMiwgLi4uICwgcG4gXS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2xGaWVsZCB7XG4gICAgY29uc3RydWN0b3IgKEYpIHtcbiAgICAgICAgdGhpcy5GID0gRjtcblxuICAgICAgICBsZXQgcmVtID0gRi5zcXJ0X3Q7XG4gICAgICAgIGxldCBzID0gRi5zcXJ0X3M7XG5cbiAgICAgICAgY29uc3QgZml2ZSA9IHRoaXMuRi5hZGQodGhpcy5GLmFkZCh0aGlzLkYudHdvLCB0aGlzLkYudHdvKSwgdGhpcy5GLm9uZSk7XG5cbiAgICAgICAgdGhpcy53ID0gbmV3IEFycmF5KHMrMSk7XG4gICAgICAgIHRoaXMud2kgPSBuZXcgQXJyYXkocysxKTtcbiAgICAgICAgdGhpcy53W3NdID0gdGhpcy5GLnBvdyhmaXZlLCByZW0pO1xuICAgICAgICB0aGlzLndpW3NdID0gdGhpcy5GLmludih0aGlzLndbc10pO1xuXG4gICAgICAgIGxldCBuPXMtMTtcbiAgICAgICAgd2hpbGUgKG4+PTApIHtcbiAgICAgICAgICAgIHRoaXMud1tuXSA9IHRoaXMuRi5zcXVhcmUodGhpcy53W24rMV0pO1xuICAgICAgICAgICAgdGhpcy53aVtuXSA9IHRoaXMuRi5zcXVhcmUodGhpcy53aVtuKzFdKTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5yb290cyA9IFtdO1xuLyogICAgICAgIGZvciAobGV0IGk9MDsgaTwxNjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgciA9IHRoaXMuRi5vbmU7XG4gICAgICAgICAgICBuID0gMSA8PCBpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdHNpID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG47IGorKykge1xuICAgICAgICAgICAgICAgIHJvb3RzaVtqXSA9IHI7XG4gICAgICAgICAgICAgICAgciA9IHRoaXMuRi5tdWwociwgdGhpcy53W2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yb290cy5wdXNoKHJvb3RzaSk7XG4gICAgICAgIH1cbiAgICAqL1xuICAgICAgICB0aGlzLl9zZXRSb290cygxNSk7XG4gICAgfVxuXG4gICAgX3NldFJvb3RzKG4pIHtcbiAgICAgICAgaWYgKG4gPiB0aGlzLkYuc3FydF9zKSBuID0gdGhpcy5zO1xuICAgICAgICBmb3IgKGxldCBpPW47IChpPj0wKSAmJiAoIXRoaXMucm9vdHNbaV0pOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCByID0gdGhpcy5GLm9uZTtcbiAgICAgICAgICAgIGNvbnN0IG5yb290cyA9IDEgPDwgaTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RzaSA9IG5ldyBBcnJheShucm9vdHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5yb290czsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNpW2pdID0gcjtcbiAgICAgICAgICAgICAgICByID0gdGhpcy5GLm11bChyLCB0aGlzLndbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb290c1tpXSA9IHJvb3RzaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZChhLCBiKSB7XG4gICAgICAgIGNvbnN0IG0gPSBNYXRoLm1heChhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IHRoaXMuRi5hZGQoYVtpXSB8fCB0aGlzLkYuemVybywgYltpXSB8fCB0aGlzLkYuemVybyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKHJlcyk7XG4gICAgfVxuXG4gICAgZG91YmxlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGEsYSk7XG4gICAgfVxuXG4gICAgc3ViKGEsIGIpIHtcbiAgICAgICAgY29uc3QgbSA9IE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG07IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5GLnN1YihhW2ldIHx8IHRoaXMuRi56ZXJvLCBiW2ldIHx8IHRoaXMuRi56ZXJvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UocmVzKTtcbiAgICB9XG5cbiAgICBtdWxTY2FsYXIocCwgYikge1xuICAgICAgICBpZiAodGhpcy5GLmVxKGIsIHRoaXMuRi56ZXJvKSkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAodGhpcy5GLmVxKGIsIHRoaXMuRi5vbmUpKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IHRoaXMuRi5tdWwocFtpXSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxuXG4gICAgbXVsKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoID09IDApIHJldHVybiBbXTtcbiAgICAgICAgaWYgKGIubGVuZ3RoID09IDApIHJldHVybiBbXTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLm11bFNjYWxhcihiLCBhWzBdKTtcbiAgICAgICAgaWYgKGIubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLm11bFNjYWxhcihhLCBiWzBdKTtcblxuICAgICAgICBpZiAoYi5sZW5ndGggPiBhLmxlbmd0aCkge1xuICAgICAgICAgICAgW2IsIGFdID0gW2EsIGJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChiLmxlbmd0aCA8PSAyKSB8fCAoYi5sZW5ndGggPCBsb2cyKGEubGVuZ3RoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bE5vcm1hbChhLGIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsRkZUKGEsYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtdWxOb3JtYWwoYSwgYikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXMgPSB0aGlzLmFkZChyZXMsIHRoaXMuc2NhbGVYKHRoaXMubXVsU2NhbGFyKGEsIGJbaV0pLCBpKSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgbXVsRkZUKGEsYikge1xuICAgICAgICBjb25zdCBsb25nZXN0TiA9IE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGJpdHNSZXN1bHQgPSBsb2cyKGxvbmdlc3ROLTEpKzI7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHNSZXN1bHQpO1xuXG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHNSZXN1bHQ7XG4gICAgICAgIGNvbnN0IGVhID0gdGhpcy5leHRlbmQoYSxtKTtcbiAgICAgICAgY29uc3QgZWIgPSB0aGlzLmV4dGVuZChiLG0pO1xuXG4gICAgICAgIGNvbnN0IHRhID0gX19mZnQodGhpcywgZWEsIGJpdHNSZXN1bHQsIDAsIDEsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgdGIgPSBfX2ZmdCh0aGlzLCBlYiwgYml0c1Jlc3VsdCwgMCwgMSwgZmFsc2UpO1xuXG4gICAgICAgIGNvbnN0IHRyZXMgPSBuZXcgQXJyYXkobSk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG07IGkrKykge1xuICAgICAgICAgICAgdHJlc1tpXSA9IHRoaXMuRi5tdWwodGFbaV0sIHRiW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlcyA9IF9fZmZ0KHRoaXMsIHRyZXMsIGJpdHNSZXN1bHQsIDAsIDEsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IHR3b2ludm0gPSB0aGlzLkYuaW52KCB0aGlzLkYubXVsU2NhbGFyKHRoaXMuRi5vbmUsIG0pICk7XG4gICAgICAgIGNvbnN0IHJlc24gPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgIHJlc25baV0gPSB0aGlzLkYubXVsKHJlc1sobS1pKSVtXSwgdHdvaW52bSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UocmVzbik7XG4gICAgfVxuXG5cblxuICAgIHNxdWFyZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bChhLGEpO1xuICAgIH1cblxuICAgIHNjYWxlWChwLCBuKSB7XG4gICAgICAgIGlmIChuPT0wKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSBlbHNlIGlmIChuPjApIHtcbiAgICAgICAgICAgIGNvbnN0IHogPSBuZXcgQXJyYXkobikuZmlsbCh0aGlzLkYuemVybyk7XG4gICAgICAgICAgICByZXR1cm4gei5jb25jYXQocCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoLW4gPj0gcC5sZW5ndGgpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBwLnNsaWNlKC1uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV2YWwyKHAsIHgpIHtcbiAgICAgICAgbGV0IHYgPSB0aGlzLkYuemVybztcbiAgICAgICAgbGV0IGl4ID0gdGhpcy5GLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLkYuYWRkKHYsIHRoaXMuRi5tdWwocFtpXSwgaXgpKTtcbiAgICAgICAgICAgIGl4ID0gdGhpcy5GLm11bChpeCwgeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUocCx4KSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG4gICAgICAgIGlmIChwLmxlbmd0aCA9PSAwKSByZXR1cm4gRi56ZXJvO1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fbmV4dDJQb3dlcihwLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGVwID0gdGhpcy5leHRlbmQocCwgbSk7XG5cbiAgICAgICAgcmV0dXJuIF9ldmFsKGVwLCB4LCAwLCAxLCBtKTtcblxuICAgICAgICBmdW5jdGlvbiBfZXZhbChwLCB4LCBvZmZzZXQsIHN0ZXAsIG4pIHtcbiAgICAgICAgICAgIGlmIChuPT0xKSByZXR1cm4gcFtvZmZzZXRdO1xuICAgICAgICAgICAgY29uc3QgbmV3WCA9IEYuc3F1YXJlKHgpO1xuICAgICAgICAgICAgY29uc3QgcmVzPSBGLmFkZChcbiAgICAgICAgICAgICAgICBfZXZhbChwLCBuZXdYLCBvZmZzZXQsIHN0ZXAgPDwgMSwgbiA+PiAxKSxcbiAgICAgICAgICAgICAgICBGLm11bChcbiAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgX2V2YWwocCwgbmV3WCwgb2Zmc2V0K3N0ZXAgLCBzdGVwIDw8IDEsIG4gPj4gMSkpKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsYWdyYW5nZShwb2ludHMpIHtcbiAgICAgICAgbGV0IHJvb3RzID0gW3RoaXMuRi5vbmVdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByb290cyA9IHRoaXMubXVsKHJvb3RzLCBbdGhpcy5GLm5lZyhwb2ludHNbaV1bMF0pLCB0aGlzLkYub25lXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3VtID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtcG9sID0gdGhpcy5ydWZmaW5pKHJvb3RzLCBwb2ludHNbaV1bMF0pO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yID1cbiAgICAgICAgICAgICAgICB0aGlzLkYubXVsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuaW52KHRoaXMuZXZhbHVhdGUobXBvbCwgcG9pbnRzW2ldWzBdKSksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tpXVsxXSk7XG4gICAgICAgICAgICBtcG9sID0gdGhpcy5tdWxTY2FsYXIobXBvbCwgZmFjdG9yKTtcbiAgICAgICAgICAgIHN1bSA9IHRoaXMuYWRkKHN1bSwgbXBvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cblxuICAgIGZmdChwKSB7XG4gICAgICAgIGlmIChwLmxlbmd0aCA8PSAxKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgYml0cyA9IGxvZzIocC5sZW5ndGgtMSkrMTtcbiAgICAgICAgdGhpcy5fc2V0Um9vdHMoYml0cyk7XG5cbiAgICAgICAgY29uc3QgbSA9IDEgPDwgYml0cztcbiAgICAgICAgY29uc3QgZXAgPSB0aGlzLmV4dGVuZChwLCBtKTtcbiAgICAgICAgY29uc3QgcmVzID0gX19mZnQodGhpcywgZXAsIGJpdHMsIDAsIDEpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZmdDIocCkge1xuICAgICAgICBpZiAocC5sZW5ndGggPD0gMSkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuXG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHM7XG4gICAgICAgIGNvbnN0IGVwID0gdGhpcy5leHRlbmQocCwgbSk7XG4gICAgICAgIF9fYml0UmV2ZXJzZShlcCwgYml0cyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IF9fZmZ0Mih0aGlzLCBlcCwgYml0cyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG5cbiAgICBpZmZ0KHApIHtcblxuICAgICAgICBpZiAocC5sZW5ndGggPD0gMSkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuICAgICAgICBjb25zdCBtID0gMSA8PCBiaXRzO1xuICAgICAgICBjb25zdCBlcCA9IHRoaXMuZXh0ZW5kKHAsIG0pO1xuICAgICAgICBjb25zdCByZXMgPSAgX19mZnQodGhpcywgZXAsIGJpdHMsIDAsIDEpO1xuXG4gICAgICAgIGNvbnN0IHR3b2ludm0gPSB0aGlzLkYuaW52KCB0aGlzLkYubXVsU2NhbGFyKHRoaXMuRi5vbmUsIG0pICk7XG4gICAgICAgIGNvbnN0IHJlc24gPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgIHJlc25baV0gPSB0aGlzLkYubXVsKHJlc1sobS1pKSVtXSwgdHdvaW52bSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzbjtcblxuICAgIH1cblxuXG4gICAgaWZmdDIocCkge1xuXG4gICAgICAgIGlmIChwLmxlbmd0aCA8PSAxKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgYml0cyA9IGxvZzIocC5sZW5ndGgtMSkrMTtcbiAgICAgICAgdGhpcy5fc2V0Um9vdHMoYml0cyk7XG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHM7XG4gICAgICAgIGNvbnN0IGVwID0gdGhpcy5leHRlbmQocCwgbSk7XG4gICAgICAgIF9fYml0UmV2ZXJzZShlcCwgYml0cyk7XG4gICAgICAgIGNvbnN0IHJlcyA9ICBfX2ZmdDIodGhpcywgZXAsIGJpdHMsIDAsIDEpO1xuXG4gICAgICAgIGNvbnN0IHR3b2ludm0gPSB0aGlzLkYuaW52KCB0aGlzLkYubXVsU2NhbGFyKHRoaXMuRi5vbmUsIG0pICk7XG4gICAgICAgIGNvbnN0IHJlc24gPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgIHJlc25baV0gPSB0aGlzLkYubXVsKHJlc1sobS1pKSVtXSwgdHdvaW52bSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzbjtcblxuICAgIH1cblxuICAgIF9mZnQocGFsbCwgYml0cywgb2Zmc2V0LCBzdGVwKSB7XG5cbiAgICAgICAgY29uc3QgbiA9IDEgPDwgYml0cztcbiAgICAgICAgaWYgKG49PTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbIHBhbGxbb2Zmc2V0XSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmRpdjIgPSBuID4+IDE7XG4gICAgICAgIGNvbnN0IHAxID0gdGhpcy5fZmZ0KHBhbGwsIGJpdHMtMSwgb2Zmc2V0LCBzdGVwKjIpO1xuICAgICAgICBjb25zdCBwMiA9IHRoaXMuX2ZmdChwYWxsLCBiaXRzLTEsIG9mZnNldCtzdGVwLCBzdGVwKjIpO1xuXG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBBcnJheShuKTtcblxuICAgICAgICBsZXQgbT0gdGhpcy5GLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5kaXYyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IHRoaXMuRi5hZGQocDFbaV0sIHRoaXMuRi5tdWwobSwgcDJbaV0pKTtcbiAgICAgICAgICAgIG91dFtpK25kaXYyXSA9IHRoaXMuRi5zdWIocDFbaV0sIHRoaXMuRi5tdWwobSwgcDJbaV0pKTtcbiAgICAgICAgICAgIG0gPSB0aGlzLkYubXVsKG0sIHRoaXMud1tiaXRzXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGV4dGVuZChwLCBlKSB7XG4gICAgICAgIGlmIChlID09IHAubGVuZ3RoKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgeiA9IG5ldyBBcnJheShlLXAubGVuZ3RoKS5maWxsKHRoaXMuRi56ZXJvKTtcblxuICAgICAgICByZXR1cm4gcC5jb25jYXQoeik7XG4gICAgfVxuXG4gICAgcmVkdWNlKHApIHtcbiAgICAgICAgaWYgKHAubGVuZ3RoID09IDApIHJldHVybiBwO1xuICAgICAgICBpZiAoISB0aGlzLkYuZXEocFtwLmxlbmd0aC0xXSwgdGhpcy5GLnplcm8pICkgcmV0dXJuIHA7XG4gICAgICAgIGxldCBpPXAubGVuZ3RoLTE7XG4gICAgICAgIHdoaWxlKCBpPjAgJiYgdGhpcy5GLmVxKHBbaV0sIHRoaXMuRi56ZXJvKSApIGktLTtcbiAgICAgICAgcmV0dXJuIHAuc2xpY2UoMCwgaSsxKTtcbiAgICB9XG5cbiAgICBlcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IHBhID0gdGhpcy5yZWR1Y2UoYSk7XG4gICAgICAgIGNvbnN0IHBiID0gdGhpcy5yZWR1Y2UoYik7XG5cbiAgICAgICAgaWYgKHBhLmxlbmd0aCAhPSBwYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuRi5lcShwYVtpXSwgcGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBydWZmaW5pKHAsIHIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEFycmF5KHAubGVuZ3RoLTEpO1xuICAgICAgICByZXNbcmVzLmxlbmd0aC0xXSA9IHBbcC5sZW5ndGgtMV07XG4gICAgICAgIGZvciAobGV0IGkgPSByZXMubGVuZ3RoLTI7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5GLmFkZCh0aGlzLkYubXVsKHJlc1tpKzFdLCByKSwgcFtpKzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIF9uZXh0MlBvd2VyKHYpIHtcbiAgICAgICAgdi0tO1xuICAgICAgICB2IHw9IHYgPj4gMTtcbiAgICAgICAgdiB8PSB2ID4+IDI7XG4gICAgICAgIHYgfD0gdiA+PiA0O1xuICAgICAgICB2IHw9IHYgPj4gODtcbiAgICAgICAgdiB8PSB2ID4+IDE2O1xuICAgICAgICB2Kys7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKHApIHtcbiAgICAgICAgY29uc3QgYXAgPSB0aGlzLm5vcm1hbGl6ZShwKTtcbiAgICAgICAgbGV0IFMgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpPWFwLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5GLmVxKHBbaV0sIHRoaXMuRi56ZXJvKSkge1xuICAgICAgICAgICAgICAgIGlmIChTIT1cIlwiKSBTICs9IFwiICsgXCI7XG4gICAgICAgICAgICAgICAgUyA9IFMgKyBwW2ldLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoaT4wKSB7XG4gICAgICAgICAgICAgICAgICAgIFMgPSBTICsgXCJ4XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpPjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFMgPSBTICsgXCJeXCIgK2k7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFM7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplKHApIHtcbiAgICAgICAgY29uc3QgcmVzICA9IG5ldyBBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSB0aGlzLkYubm9ybWFsaXplKHBbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG5cbiAgICBfcmVjaXByb2NhbChwLCBiaXRzKSB7XG4gICAgICAgIGNvbnN0IGsgPSAxIDw8IGJpdHM7XG4gICAgICAgIGlmIChrPT0xKSB7XG4gICAgICAgICAgICByZXR1cm4gWyB0aGlzLkYuaW52KHBbMF0pIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnAgPSB0aGlzLnNjYWxlWChwLCAtay8yKTtcbiAgICAgICAgY29uc3QgcSA9IHRoaXMuX3JlY2lwcm9jYWwobnAsIGJpdHMtMSk7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLnNjYWxlWCh0aGlzLmRvdWJsZShxKSwgMyprLzItMik7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLm11bCggdGhpcy5zcXVhcmUocSksIHApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlWCh0aGlzLnN1YihhLGIpLCAgIC0oay0yKSk7XG4gICAgfVxuXG4gICAgLy8gZGl2aWRlcyB4Xm0gLyB2XG4gICAgX2RpdjIobSwgdikge1xuICAgICAgICBjb25zdCBrYml0cyA9IGxvZzIodi5sZW5ndGgtMSkrMTtcbiAgICAgICAgY29uc3QgayA9IDEgPDwga2JpdHM7XG5cbiAgICAgICAgY29uc3Qgc2NhbGVWID0gayAtIHYubGVuZ3RoO1xuXG4gICAgICAgIC8vIHJlYyA9IHheKGsgLSAyKSAvIHYqIHhec2NhbGVWID0+XG4gICAgICAgIC8vIHJlYyA9IHheKGstMi1zY2FsZVYpLyB2XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHJlcyA9IHhebS92ID0geF4obSArICgyKmstMiAtIHNjYWxlVikgLSAoMiprLTIgLSBzY2FsZVYpKSAvdiA9PlxuICAgICAgICAvLyByZXMgPSByZWMgKiB4XihtIC0gKDIqay0yIC0gc2NhbGVWKSkgPT5cbiAgICAgICAgLy8gcmVzID0gcmVjICogeF4obSAtIDIqayArIDIgKyBzY2FsZVYpXG5cbiAgICAgICAgY29uc3QgcmVjID0gdGhpcy5fcmVjaXByb2NhbCh0aGlzLnNjYWxlWCh2LCBzY2FsZVYpLCBrYml0cyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuc2NhbGVYKHJlYywgbSAtIDIqayArIDIgKyBzY2FsZVYpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZGl2KF91LCBfdikge1xuICAgICAgICBpZiAoX3UubGVuZ3RoIDwgX3YubGVuZ3RoKSByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IGtiaXRzID0gbG9nMihfdi5sZW5ndGgtMSkrMTtcbiAgICAgICAgY29uc3QgayA9IDEgPDwga2JpdHM7XG5cbiAgICAgICAgY29uc3QgdSA9IHRoaXMuc2NhbGVYKF91LCBrLV92Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLnNjYWxlWChfdiwgay1fdi5sZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IG4gPSB2Lmxlbmd0aC0xO1xuICAgICAgICBsZXQgbSA9IHUubGVuZ3RoLTE7XG5cbiAgICAgICAgY29uc3QgcyA9IHRoaXMuX3JlY2lwcm9jYWwodiwga2JpdHMpO1xuICAgICAgICBsZXQgdDtcbiAgICAgICAgaWYgKG0+MipuKSB7XG4gICAgICAgICAgICB0ID0gdGhpcy5zdWIodGhpcy5zY2FsZVgoW3RoaXMuRi5vbmVdLCAyKm4pLCB0aGlzLm11bChzLCB2KSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcSA9IFtdO1xuICAgICAgICBsZXQgcmVtID0gdTtcbiAgICAgICAgbGV0IHVzLCB1dDtcbiAgICAgICAgbGV0IGZpbmlzaCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlICghZmluaXNoKSB7XG4gICAgICAgICAgICB1cyA9IHRoaXMubXVsKHJlbSwgcyk7XG4gICAgICAgICAgICBxID0gdGhpcy5hZGQocSwgdGhpcy5zY2FsZVgodXMsIC0yKm4pKTtcblxuICAgICAgICAgICAgaWYgKCBtID4gMipuICkge1xuICAgICAgICAgICAgICAgIHV0ID0gdGhpcy5tdWwocmVtLCB0KTtcbiAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnNjYWxlWCh1dCwgLTIqbik7XG4gICAgICAgICAgICAgICAgbSA9IHJlbS5sZW5ndGgtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluaXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxO1xuICAgIH1cblxuXG4gICAgLy8gcmV0dXJucyB0aGUgaXRoIG50aC1yb290IG9mIG9uZVxuICAgIG9uZVJvb3QobiwgaSkge1xuICAgICAgICBsZXQgbmJpdHMgPSBsb2cyKG4tMSkrMTtcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuRi5vbmU7XG4gICAgICAgIGxldCByID0gaTtcblxuICAgICAgICBpZihpPj1uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiAnaScgc2hvdWxkIGJlIGxvd2VyIHRoYW4gJ24nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKDE8PG5iaXRzICE9PSBuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIGVycmxyOiAke259IHNob3VsZCBlcXVhbCAkezE8PG5iaXRzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHI+MCkge1xuICAgICAgICAgICAgaWYgKHIgJiAxID09IDEpIHtcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLkYubXVsKHJlcywgdGhpcy53W25iaXRzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByID0gciA+PiAxO1xuICAgICAgICAgICAgbmJpdHMgLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBjb21wdXRlVmFuaXNoaW5nUG9saW5vbWlhbChiaXRzLCB0KSB7XG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHM7XG4gICAgICAgIHJldHVybiB0aGlzLkYuc3ViKHRoaXMuRi5wb3codCwgbSksIHRoaXMuRi5vbmUpO1xuICAgIH1cblxuICAgIGV2YWx1YXRlTGFncmFuZ2VQb2x5bm9taWFscyhiaXRzLCB0KSB7XG4gICAgICAgIGNvbnN0IG09IDEgPDwgYml0cztcbiAgICAgICAgY29uc3QgdG0gPSB0aGlzLkYucG93KHQsIG0pO1xuICAgICAgICBjb25zdCB1PSBuZXcgQXJyYXkobSkuZmlsbCh0aGlzLkYuemVybyk7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuICAgICAgICBjb25zdCBvbWVnYSA9IHRoaXMud1tiaXRzXTtcblxuICAgICAgICBpZiAodGhpcy5GLmVxKHRtLCB0aGlzLkYub25lKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5GLmVxKHRoaXMucm9vdHNbYml0c11bMF0sdCkpIHsgLy8gaS5lLiwgdCBlcXVhbHMgb21lZ2FeaVxuICAgICAgICAgICAgICAgICAgICB1W2ldID0gdGhpcy5GLm9uZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeiA9IHRoaXMuRi5zdWIodG0sIHRoaXMuRi5vbmUpO1xuICAgICAgICAvLyAgICAgICAgbGV0IGwgPSB0aGlzLkYubXVsKHosICB0aGlzLkYucG93KHRoaXMuRi50d29pbnYsIG0pKTtcbiAgICAgICAgbGV0IGwgPSB0aGlzLkYubXVsKHosICB0aGlzLkYuaW52KHRoaXMuRi5lKG0pKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICB1W2ldID0gdGhpcy5GLm11bChsLCB0aGlzLkYuaW52KHRoaXMuRi5zdWIodCx0aGlzLnJvb3RzW2JpdHNdW2ldKSkpO1xuICAgICAgICAgICAgbCA9IHRoaXMuRi5tdWwobCwgb21lZ2EpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHU7XG4gICAgfVxuXG4gICAgbG9nMihWKSB7XG4gICAgICAgIHJldHVybiBsb2cyKFYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbG9nMiggViApXG57XG4gICAgcmV0dXJuKCAoICggViAmIDB4RkZGRjAwMDAgKSAhPT0gMCA/ICggViAmPSAweEZGRkYwMDAwLCAxNiApIDogMCApIHwgKCAoIFYgJiAweEZGMDBGRjAwICkgIT09IDAgPyAoIFYgJj0gMHhGRjAwRkYwMCwgOCApIDogMCApIHwgKCAoIFYgJiAweEYwRjBGMEYwICkgIT09IDAgPyAoIFYgJj0gMHhGMEYwRjBGMCwgNCApIDogMCApIHwgKCAoIFYgJiAweENDQ0NDQ0NDICkgIT09IDAgPyAoIFYgJj0gMHhDQ0NDQ0NDQywgMiApIDogMCApIHwgKCAoIFYgJiAweEFBQUFBQUFBICkgIT09IDAgKSApO1xufVxuXG5cbmZ1bmN0aW9uIF9fZmZ0KFBGLCBwYWxsLCBiaXRzLCBvZmZzZXQsIHN0ZXApIHtcblxuICAgIGNvbnN0IG4gPSAxIDw8IGJpdHM7XG4gICAgaWYgKG49PTEpIHtcbiAgICAgICAgcmV0dXJuIFsgcGFsbFtvZmZzZXRdIF07XG4gICAgfSBlbHNlIGlmIChuPT0yKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBQRi5GLmFkZChwYWxsW29mZnNldF0sIHBhbGxbb2Zmc2V0ICsgc3RlcF0pLFxuICAgICAgICAgICAgUEYuRi5zdWIocGFsbFtvZmZzZXRdLCBwYWxsW29mZnNldCArIHN0ZXBdKV07XG4gICAgfVxuXG4gICAgY29uc3QgbmRpdjIgPSBuID4+IDE7XG4gICAgY29uc3QgcDEgPSBfX2ZmdChQRiwgcGFsbCwgYml0cy0xLCBvZmZzZXQsIHN0ZXAqMik7XG4gICAgY29uc3QgcDIgPSBfX2ZmdChQRiwgcGFsbCwgYml0cy0xLCBvZmZzZXQrc3RlcCwgc3RlcCoyKTtcblxuICAgIGNvbnN0IG91dCA9IG5ldyBBcnJheShuKTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxuZGl2MjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IFBGLkYuYWRkKHAxW2ldLCBQRi5GLm11bChQRi5yb290c1tiaXRzXVtpXSwgcDJbaV0pKTtcbiAgICAgICAgb3V0W2krbmRpdjJdID0gUEYuRi5zdWIocDFbaV0sIFBGLkYubXVsKFBGLnJvb3RzW2JpdHNdW2ldLCBwMltpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cblxuZnVuY3Rpb24gX19mZnQyKFBGLCBwYWxsLCBiaXRzKSB7XG5cbiAgICBjb25zdCBuID0gMSA8PCBiaXRzO1xuICAgIGlmIChuPT0xKSB7XG4gICAgICAgIHJldHVybiBbIHBhbGxbMF0gXTtcbiAgICB9XG5cbiAgICBjb25zdCBuZGl2MiA9IG4gPj4gMTtcbiAgICBjb25zdCBwMSA9IF9fZmZ0MihQRiwgcGFsbC5zbGljZSgwLCBuZGl2MiksIGJpdHMtMSk7XG4gICAgY29uc3QgcDIgPSBfX2ZmdDIoUEYsIHBhbGwuc2xpY2UobmRpdjIpLCBiaXRzLTEpO1xuXG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgZm9yIChsZXQgaT0wOyBpPG5kaXYyOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gUEYuRi5hZGQocDFbaV0sIFBGLkYubXVsKFBGLnJvb3RzW2JpdHNdW2ldLCBwMltpXSkpO1xuICAgICAgICBvdXRbaStuZGl2Ml0gPSBQRi5GLnN1YihwMVtpXSwgUEYuRi5tdWwoUEYucm9vdHNbYml0c11baV0sIHAyW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuY29uc3QgX3JldlRhYmxlID0gW107XG5mb3IgKGxldCBpPTA7IGk8MjU2OyBpKyspIHtcbiAgICBfcmV2VGFibGVbaV0gPSBfcmV2U2xvdyhpLCA4KTtcbn1cblxuZnVuY3Rpb24gX3JldlNsb3coaWR4LCBiaXRzKSB7XG4gICAgbGV0IHJlcyA9MDtcbiAgICBsZXQgYSA9IGlkeDtcbiAgICBmb3IgKGxldCBpPTA7IGk8Yml0czsgaSsrKSB7XG4gICAgICAgIHJlcyA8PD0gMTtcbiAgICAgICAgcmVzID0gcmVzIHwgKGEgJjEpO1xuICAgICAgICBhID4+PTE7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHJldihpZHgsIGJpdHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBfcmV2VGFibGVbaWR4ID4+PiAyNF0gfFxuICAgICAgICAoX3JldlRhYmxlWyhpZHggPj4+IDE2KSAmIDB4RkZdIDw8IDgpIHxcbiAgICAgICAgKF9yZXZUYWJsZVsoaWR4ID4+PiA4KSAmIDB4RkZdIDw8IDE2KSB8XG4gICAgICAgIChfcmV2VGFibGVbaWR4ICYgMHhGRl0gPDwgMjQpXG4gICAgKSA+Pj4gKDMyLWJpdHMpO1xufVxuXG5mdW5jdGlvbiBfX2JpdFJldmVyc2UocCwgYml0cykge1xuICAgIGZvciAobGV0IGs9MDsgazxwLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGNvbnN0IHIgPSByZXYoaywgYml0cyk7XG4gICAgICAgIGlmIChyPmspIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcD0gcFtrXTtcbiAgICAgICAgICAgIHBba10gPSBwW3JdO1xuICAgICAgICAgICAgcFtyXSA9IHRtcDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/polfield.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/random.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getRandomBytes: () => (/* binding */ getRandomBytes),\n/* harmony export */   getRandomSeed: () => (/* binding */ getRandomSeed),\n/* harmony export */   getThreadRng: () => (/* binding */ getThreadRng)\n/* harmony export */ });\n/* harmony import */ var _chacha_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chacha.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/chacha.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n\n\n\nfunction getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (false) {}\n    else { // NodeJS\n        crypto__WEBPACK_IMPORTED_MODULE_1__.randomFillSync(array);\n    }\n    return array;\n}\n\nfunction getRandomSeed() {\n    const arr = getRandomBytes(32);\n    const arrV = new Uint32Array(arr.buffer);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed.push(arrV[i]);\n    }\n    return seed;\n}\n\nlet threadRng = null;\n\nfunction getThreadRng() {\n    if (threadRng) return threadRng;\n    threadRng = new _chacha_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](getRandomSeed());\n    return threadRng;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9yYW5kb20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUM7QUFDTDs7QUFFckI7QUFDUDtBQUNBLFFBQVEsS0FBZSxFQUFFLEVBUXBCO0FBQ0wsV0FBVztBQUNYLFFBQVEsa0RBQXFCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQSxvQkFBb0Isa0RBQU07QUFDMUI7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL3JhbmRvbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2hhQ2hhIGZyb20gXCIuL2NoYWNoYS5qc1wiO1xuaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhuKSB7XG4gICAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3NlcikgeyAvLyBCcm93c2VyXG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8gIT09IFwidW5kZWZpbmVkXCIpIHsgLy8gU3VwcG9ydGVkXG4gICAgICAgICAgICBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgICAgICB9IGVsc2UgeyAvLyBmYWxsYmFja1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gKE1hdGgucmFuZG9tKCkqNDI5NDk2NzI5Nik+Pj4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgeyAvLyBOb2RlSlNcbiAgICAgICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZG9tU2VlZCgpIHtcbiAgICBjb25zdCBhcnIgPSBnZXRSYW5kb21CeXRlcygzMik7XG4gICAgY29uc3QgYXJyViA9IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyKTtcbiAgICBjb25zdCBzZWVkID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPDg7IGkrKykge1xuICAgICAgICBzZWVkLnB1c2goYXJyVltpXSk7XG4gICAgfVxuICAgIHJldHVybiBzZWVkO1xufVxuXG5sZXQgdGhyZWFkUm5nID0gbnVsbDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRocmVhZFJuZygpIHtcbiAgICBpZiAodGhyZWFkUm5nKSByZXR1cm4gdGhyZWFkUm5nO1xuICAgIHRocmVhZFJuZyA9IG5ldyBDaGFDaGEoZ2V0UmFuZG9tU2VlZCgpKTtcbiAgICByZXR1cm4gdGhyZWFkUm5nO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abs: () => (/* binding */ abs),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   band: () => (/* binding */ band),\n/* harmony export */   bitLength: () => (/* binding */ bitLength),\n/* harmony export */   bits: () => (/* binding */ bits),\n/* harmony export */   bor: () => (/* binding */ bor),\n/* harmony export */   bxor: () => (/* binding */ bxor),\n/* harmony export */   div: () => (/* binding */ div),\n/* harmony export */   e: () => (/* binding */ e),\n/* harmony export */   eq: () => (/* binding */ eq),\n/* harmony export */   exp: () => (/* binding */ exp),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromRprBE: () => (/* binding */ fromRprBE),\n/* harmony export */   fromRprLE: () => (/* binding */ fromRprLE),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   geq: () => (/* binding */ geq),\n/* harmony export */   gt: () => (/* binding */ gt),\n/* harmony export */   isNegative: () => (/* binding */ isNegative),\n/* harmony export */   isOdd: () => (/* binding */ isOdd),\n/* harmony export */   isZero: () => (/* binding */ isZero),\n/* harmony export */   land: () => (/* binding */ land),\n/* harmony export */   leq: () => (/* binding */ leq),\n/* harmony export */   lnot: () => (/* binding */ lnot),\n/* harmony export */   lor: () => (/* binding */ lor),\n/* harmony export */   lt: () => (/* binding */ lt),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   mul: () => (/* binding */ mul),\n/* harmony export */   naf: () => (/* binding */ naf),\n/* harmony export */   neg: () => (/* binding */ neg),\n/* harmony export */   neq: () => (/* binding */ neq),\n/* harmony export */   one: () => (/* binding */ one),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   shiftLeft: () => (/* binding */ shiftLeft),\n/* harmony export */   shiftRight: () => (/* binding */ shiftRight),\n/* harmony export */   shl: () => (/* binding */ shl),\n/* harmony export */   shr: () => (/* binding */ shr),\n/* harmony export */   square: () => (/* binding */ square),\n/* harmony export */   sub: () => (/* binding */ sub),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toLEBuff: () => (/* binding */ toLEBuff),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toRprBE: () => (/* binding */ toRprBE),\n/* harmony export */   toRprLE: () => (/* binding */ toRprLE),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   zero: () => (/* binding */ zero)\n/* harmony export */ });\n\n/* global BigInt */\nconst hexLen = [ 0, 1, 2, 2, 3, 3, 3, 3, 4 ,4 ,4 ,4 ,4 ,4 ,4 ,4];\n\nfunction fromString(s, radix) {\n    if ((!radix)||(radix==10)) {\n        return BigInt(s);\n    } else if (radix==16) {\n        if (s.slice(0,2) == \"0x\") {\n            return BigInt(s);\n        } else {\n            return BigInt(\"0x\"+s);\n        }\n    }\n}\n\nconst e = fromString;\n\nfunction fromArray(a, radix) {\n    let acc =BigInt(0);\n    radix = BigInt(radix);\n    for (let i=0; i<a.length; i++) {\n        acc = acc*radix + BigInt(a[i]);\n    }\n    return acc;\n}\n\nfunction bitLength(a) {\n    const aS =a.toString(16);\n    return (aS.length-1)*4 +hexLen[parseInt(aS[0], 16)];\n}\n\nfunction isNegative(a) {\n    return BigInt(a) < BigInt(0);\n}\n\nfunction isZero(a) {\n    return !a;\n}\n\nfunction shiftLeft(a, n) {\n    return BigInt(a) << BigInt(n);\n}\n\nfunction shiftRight(a, n) {\n    return BigInt(a) >> BigInt(n);\n}\n\nconst shl = shiftLeft;\nconst shr = shiftRight;\n\nfunction isOdd(a) {\n    return (BigInt(a) & BigInt(1)) == BigInt(1);\n}\n\n\nfunction naf(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            const z = 2 - Number(E % BigInt(4));\n            res.push( z );\n            E = E - BigInt(z);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\n\nfunction bits(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\nfunction toNumber(s) {\n    if (s>BigInt(Number.MAX_SAFE_INTEGER )) {\n        throw new Error(\"Number too big\");\n    }\n    return Number(s);\n}\n\nfunction toArray(s, radix) {\n    const res = [];\n    let rem = BigInt(s);\n    radix = BigInt(radix);\n    while (rem) {\n        res.unshift( Number(rem % radix));\n        rem = rem / radix;\n    }\n    return res;\n}\n\n\nfunction add(a, b) {\n    return BigInt(a) + BigInt(b);\n}\n\nfunction sub(a, b) {\n    return BigInt(a) - BigInt(b);\n}\n\nfunction neg(a) {\n    return -BigInt(a);\n}\n\nfunction mul(a, b) {\n    return BigInt(a) * BigInt(b);\n}\n\nfunction square(a) {\n    return BigInt(a) * BigInt(a);\n}\n\nfunction pow(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nfunction exp(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nfunction abs(a) {\n    return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);\n}\n\nfunction div(a, b) {\n    return BigInt(a) / BigInt(b);\n}\n\nfunction mod(a, b) {\n    return BigInt(a) % BigInt(b);\n}\n\nfunction eq(a, b) {\n    return BigInt(a) == BigInt(b);\n}\n\nfunction neq(a, b) {\n    return BigInt(a) != BigInt(b);\n}\n\nfunction lt(a, b) {\n    return BigInt(a) < BigInt(b);\n}\n\nfunction gt(a, b) {\n    return BigInt(a) > BigInt(b);\n}\n\nfunction leq(a, b) {\n    return BigInt(a) <= BigInt(b);\n}\n\nfunction geq(a, b) {\n    return BigInt(a) >= BigInt(b);\n}\n\nfunction band(a, b) {\n    return BigInt(a) & BigInt(b);\n}\n\nfunction bor(a, b) {\n    return BigInt(a) | BigInt(b);\n}\n\nfunction bxor(a, b) {\n    return BigInt(a) ^ BigInt(b);\n}\n\nfunction land(a, b) {\n    return BigInt(a) && BigInt(b);\n}\n\nfunction lor(a, b) {\n    return BigInt(a) || BigInt(b);\n}\n\nfunction lnot(a) {\n    return !BigInt(a);\n}\n\n// Returns a buffer with Little Endian Representation\nfunction toRprLE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v[i] = parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16);\n    for (let i=l; i<v.length; i++) v[i] = 0;\n    for (let i=v.length*4; i<n8; i++) buff[i] = toNumber(band(shiftRight(e, i*8), 0xFF));\n}\n\n// Returns a buffer with Big Endian Representation\nfunction toRprBE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v.setUint32(n8-i*4 -4, parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16), false);\n    for (let i=0; i<n8/4-l; i++) v[i] = 0;\n}\n\n// Pases a buffer with Little Endian Representation\nfunction fromRprLE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const a = new Array(n8/4);\n    v.forEach( (ch,i) => a[a.length-i-1] = ch.toString(16).padStart(8,\"0\") );\n    return fromString(a.join(\"\"), 16);\n}\n\n// Pases a buffer with Big Endian Representation\nfunction fromRprBE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const a = new Array(n8/4);\n    for (let i=0; i<n8/4; i++) {\n        a[i] = v.getUint32(i*4, false).toString(16).padStart(8, \"0\");\n    }\n    return fromString(a.join(\"\"), 16);\n}\n\nfunction toString(a, radix) {\n    return a.toString(radix);\n}\n\nfunction toLEBuff(a) {\n    const buff = new Uint8Array(Math.floor((bitLength(a) - 1) / 8) +1);\n    toRprLE(buff, 0, a, buff.byteLength);\n    return buff;\n}\n\nconst zero = e(0);\nconst one = e(1);\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy9zY2FsYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ0E7O0FBRUE7QUFDUDtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxrQkFBa0IsS0FBSztBQUN2QixrQkFBa0IsWUFBWTtBQUM5QiwyQkFBMkIsTUFBTTtBQUNqQzs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxrQkFBa0IsS0FBSztBQUN2QixrQkFBa0IsVUFBVTtBQUM1Qjs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL3NjYWxhci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIGdsb2JhbCBCaWdJbnQgKi9cbmNvbnN0IGhleExlbiA9IFsgMCwgMSwgMiwgMiwgMywgMywgMywgMywgNCAsNCAsNCAsNCAsNCAsNCAsNCAsNF07XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHMsIHJhZGl4KSB7XG4gICAgaWYgKCghcmFkaXgpfHwocmFkaXg9PTEwKSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KHMpO1xuICAgIH0gZWxzZSBpZiAocmFkaXg9PTE2KSB7XG4gICAgICAgIGlmIChzLnNsaWNlKDAsMikgPT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludChcIjB4XCIrcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBlID0gZnJvbVN0cmluZztcblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21BcnJheShhLCByYWRpeCkge1xuICAgIGxldCBhY2MgPUJpZ0ludCgwKTtcbiAgICByYWRpeCA9IEJpZ0ludChyYWRpeCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjID0gYWNjKnJhZGl4ICsgQmlnSW50KGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuZ3RoKGEpIHtcbiAgICBjb25zdCBhUyA9YS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIChhUy5sZW5ndGgtMSkqNCAraGV4TGVuW3BhcnNlSW50KGFTWzBdLCAxNildO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOZWdhdGl2ZShhKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA8IEJpZ0ludCgwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzWmVybyhhKSB7XG4gICAgcmV0dXJuICFhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpZnRMZWZ0KGEsIG4pIHtcbiAgICByZXR1cm4gQmlnSW50KGEpIDw8IEJpZ0ludChuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaWZ0UmlnaHQoYSwgbikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPj4gQmlnSW50KG4pO1xufVxuXG5leHBvcnQgY29uc3Qgc2hsID0gc2hpZnRMZWZ0O1xuZXhwb3J0IGNvbnN0IHNociA9IHNoaWZ0UmlnaHQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09kZChhKSB7XG4gICAgcmV0dXJuIChCaWdJbnQoYSkgJiBCaWdJbnQoMSkpID09IEJpZ0ludCgxKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gbmFmKG4pIHtcbiAgICBsZXQgRSA9IEJpZ0ludChuKTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICB3aGlsZSAoRSkge1xuICAgICAgICBpZiAoRSAmIEJpZ0ludCgxKSkge1xuICAgICAgICAgICAgY29uc3QgeiA9IDIgLSBOdW1iZXIoRSAlIEJpZ0ludCg0KSk7XG4gICAgICAgICAgICByZXMucHVzaCggeiApO1xuICAgICAgICAgICAgRSA9IEUgLSBCaWdJbnQoeik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMucHVzaCggMCApO1xuICAgICAgICB9XG4gICAgICAgIEUgPSBFID4+IEJpZ0ludCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYml0cyhuKSB7XG4gICAgbGV0IEUgPSBCaWdJbnQobik7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgd2hpbGUgKEUpIHtcbiAgICAgICAgaWYgKEUgJiBCaWdJbnQoMSkpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnB1c2goIDAgKTtcbiAgICAgICAgfVxuICAgICAgICBFID0gRSA+PiBCaWdJbnQoMSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcihzKSB7XG4gICAgaWYgKHM+QmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWdcIik7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIocyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KHMsIHJhZGl4KSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgbGV0IHJlbSA9IEJpZ0ludChzKTtcbiAgICByYWRpeCA9IEJpZ0ludChyYWRpeCk7XG4gICAgd2hpbGUgKHJlbSkge1xuICAgICAgICByZXMudW5zaGlmdCggTnVtYmVyKHJlbSAlIHJhZGl4KSk7XG4gICAgICAgIHJlbSA9IHJlbSAvIHJhZGl4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgKyBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWIoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgLSBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZWcoYSkge1xuICAgIHJldHVybiAtQmlnSW50KGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICogQmlnSW50KGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlKGEpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICogQmlnSW50KGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG93KGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICoqIEJpZ0ludChiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cChhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSAqKiBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhYnMoYSkge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPj0gMCA/IEJpZ0ludChhKSA6IC1CaWdJbnQoYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXYoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgLyBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgJSBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcShhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA9PSBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXEoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgIT0gQmlnSW50KGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbHQoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPCBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBndChhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA+IEJpZ0ludChiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcShhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA8PSBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXEoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPj0gQmlnSW50KGIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFuZChhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSAmIEJpZ0ludChiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJvcihhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSB8IEJpZ0ludChiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ4b3IoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgXiBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYW5kKGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICYmIEJpZ0ludChiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvcihhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSB8fCBCaWdJbnQoYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsbm90KGEpIHtcbiAgICByZXR1cm4gIUJpZ0ludChhKTtcbn1cblxuLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIExpdHRsZSBFbmRpYW4gUmVwcmVzZW50YXRpb25cbmV4cG9ydCBmdW5jdGlvbiB0b1JwckxFKGJ1ZmYsIG8sIGUsIG44KSB7XG4gICAgY29uc3QgcyA9IFwiMDAwMDAwMFwiICsgZS50b1N0cmluZygxNik7XG4gICAgY29uc3QgdiA9IG5ldyBVaW50MzJBcnJheShidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0ICsgbywgbjgvNCk7XG4gICAgY29uc3QgbCA9ICgoKHMubGVuZ3RoLTcpKjQgLSAxKSA+PiA1KSsxOyAgICAvLyBOdW1iZXIgb2YgMzJiaXQgd29yZHM7XG4gICAgZm9yIChsZXQgaT0wOyBpPGw7IGkrKykgdltpXSA9IHBhcnNlSW50KHMuc3Vic3RyaW5nKHMubGVuZ3RoLTgqaS04LCBzLmxlbmd0aC04KmkpLCAxNik7XG4gICAgZm9yIChsZXQgaT1sOyBpPHYubGVuZ3RoOyBpKyspIHZbaV0gPSAwO1xuICAgIGZvciAobGV0IGk9di5sZW5ndGgqNDsgaTxuODsgaSsrKSBidWZmW2ldID0gdG9OdW1iZXIoYmFuZChzaGlmdFJpZ2h0KGUsIGkqOCksIDB4RkYpKTtcbn1cblxuLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gUmVwcmVzZW50YXRpb25cbmV4cG9ydCBmdW5jdGlvbiB0b1JwckJFKGJ1ZmYsIG8sIGUsIG44KSB7XG4gICAgY29uc3QgcyA9IFwiMDAwMDAwMFwiICsgZS50b1N0cmluZygxNik7XG4gICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0ICsgbywgbjgpO1xuICAgIGNvbnN0IGwgPSAoKChzLmxlbmd0aC03KSo0IC0gMSkgPj4gNSkrMTsgICAgLy8gTnVtYmVyIG9mIDMyYml0IHdvcmRzO1xuICAgIGZvciAobGV0IGk9MDsgaTxsOyBpKyspIHYuc2V0VWludDMyKG44LWkqNCAtNCwgcGFyc2VJbnQocy5zdWJzdHJpbmcocy5sZW5ndGgtOCppLTgsIHMubGVuZ3RoLTgqaSksIDE2KSwgZmFsc2UpO1xuICAgIGZvciAobGV0IGk9MDsgaTxuOC80LWw7IGkrKykgdltpXSA9IDA7XG59XG5cbi8vIFBhc2VzIGEgYnVmZmVyIHdpdGggTGl0dGxlIEVuZGlhbiBSZXByZXNlbnRhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScHJMRShidWZmLCBvLCBuOCkge1xuICAgIG44ID0gbjggfHwgYnVmZi5ieXRlTGVuZ3RoO1xuICAgIG8gPSBvIHx8IDA7XG4gICAgY29uc3QgdiA9IG5ldyBVaW50MzJBcnJheShidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0ICsgbywgbjgvNCk7XG4gICAgY29uc3QgYSA9IG5ldyBBcnJheShuOC80KTtcbiAgICB2LmZvckVhY2goIChjaCxpKSA9PiBhW2EubGVuZ3RoLWktMV0gPSBjaC50b1N0cmluZygxNikucGFkU3RhcnQoOCxcIjBcIikgKTtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhhLmpvaW4oXCJcIiksIDE2KTtcbn1cblxuLy8gUGFzZXMgYSBidWZmZXIgd2l0aCBCaWcgRW5kaWFuIFJlcHJlc2VudGF0aW9uXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwckJFKGJ1ZmYsIG8sIG44KSB7XG4gICAgbjggPSBuOCB8fCBidWZmLmJ5dGVMZW5ndGg7XG4gICAgbyA9IG8gfHwgMDtcbiAgICBjb25zdCB2ID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQgKyBvLCBuOCk7XG4gICAgY29uc3QgYSA9IG5ldyBBcnJheShuOC80KTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bjgvNDsgaSsrKSB7XG4gICAgICAgIGFbaV0gPSB2LmdldFVpbnQzMihpKjQsIGZhbHNlKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbVN0cmluZyhhLmpvaW4oXCJcIiksIDE2KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGEsIHJhZGl4KSB7XG4gICAgcmV0dXJuIGEudG9TdHJpbmcocmFkaXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9MRUJ1ZmYoYSkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShNYXRoLmZsb29yKChiaXRMZW5ndGgoYSkgLSAxKSAvIDgpICsxKTtcbiAgICB0b1JwckxFKGJ1ZmYsIDAsIGEsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmV4cG9ydCBjb25zdCB6ZXJvID0gZSgwKTtcbmV4cG9ydCBjb25zdCBvbmUgPSBlKDEpO1xuXG5cblxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/threadman.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ThreadManager: () => (/* binding */ ThreadManager),\n/* harmony export */   \"default\": () => (/* binding */ buildThreadManager)\n/* harmony export */ });\n/* harmony import */ var _threadman_thread_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./threadman_thread.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman_thread.js\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var web_worker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! web-worker */ \"(ssr)/./node_modules/web-worker/cjs/node.js\");\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// const MEM_SIZE = 1000;  // Memory size in 64K Pakes (512Mb)\nconst MEM_SIZE = 25;  // Memory size in 64K Pakes (1600Kb)\n\n\n\n\n\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject)=> {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nlet workerSource;\n\nconst threadStr = `(${_threadman_thread_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toString()})(self)`;\nif(false) {} else {  \n    workerSource = \"data:application/javascript;base64,\" + Buffer.from(threadStr).toString(\"base64\");\n}\n\n\n\nasync function buildThreadManager(wasm, singleThread) {\n    const tm = new ThreadManager();\n\n    tm.memory = new WebAssembly.Memory({initial:MEM_SIZE});\n    tm.u8 = new Uint8Array(tm.memory.buffer);\n    tm.u32 = new Uint32Array(tm.memory.buffer);\n\n    const wasmModule = await WebAssembly.compile(wasm.code);\n\n    tm.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": tm.memory\n        }\n    });\n    \n    if(false) {}\n    \n    tm.singleThread = singleThread;\n    tm.initalPFree = tm.u32[0];   // Save the Pointer to free space.\n    tm.pq = wasm.pq;\n    tm.pr = wasm.pr;\n    tm.pG1gen = wasm.pG1gen;\n    tm.pG1zero = wasm.pG1zero;\n    tm.pG2gen = wasm.pG2gen;\n    tm.pG2zero = wasm.pG2zero;\n    tm.pOneT = wasm.pOneT;\n\n    //    tm.pTmp0 = tm.alloc(curve.G2.F.n8*3);\n    //    tm.pTmp1 = tm.alloc(curve.G2.F.n8*3);\n\n    if (singleThread) {\n        tm.code = wasm.code;\n        tm.taskManager = (0,_threadman_thread_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        await tm.taskManager([{\n            cmd: \"INIT\",\n            init: MEM_SIZE,\n            code: tm.code.slice()\n        }]);\n        tm.concurrency  = 1;\n    } else {\n        tm.workers = [];\n        tm.pendingDeferreds = [];\n        tm.working = [];\n\n        let concurrency = 2;\n        if (false) {} else {\n            concurrency = os__WEBPACK_IMPORTED_MODULE_1__.cpus().length;\n        }\n\n        if(concurrency == 0){\n            concurrency = 2;\n        }\n\n        // Limit to 64 threads for memory reasons.\n        if (concurrency>64) concurrency=64;\n        tm.concurrency = concurrency;\n\n        for (let i = 0; i<concurrency; i++) {\n\n            tm.workers[i] = new web_worker__WEBPACK_IMPORTED_MODULE_2__(workerSource);\n\n            tm.workers[i].addEventListener(\"message\", getOnMsg(i));\n\n            tm.working[i]=false;\n        }\n\n        const initPromises = [];\n        for (let i=0; i<tm.workers.length;i++) {\n            const copyCode = wasm.code.slice();\n            initPromises.push(tm.postAction(i, [{\n                cmd: \"INIT\",\n                init: MEM_SIZE,\n                code: copyCode\n            }], [copyCode.buffer]));\n        }\n\n        await Promise.all(initPromises);\n\n    }\n    return tm;\n\n    function getOnMsg(i) {\n        return function(e) {\n            let data;\n            if ((e)&&(e.data)) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            tm.working[i]=false;\n            tm.pendingDeferreds[i].resolve(data);\n            tm.processWorks();\n        };\n    }\n\n}\n\nclass ThreadManager {\n    constructor() {\n        this.actionQueue = [];\n        this.oldPFree = 0;\n    }\n\n    startSyncOp() {\n        if (this.oldPFree != 0) throw new Error(\"Sync operation in progress\");\n        this.oldPFree = this.u32[0];\n    }\n\n    endSyncOp() {\n        if (this.oldPFree == 0) throw new Error(\"No sync operation in progress\");\n        this.u32[0] = this.oldPFree;\n        this.oldPFree = 0;\n    }\n\n    postAction(workerId, e, transfers, _deferred) {\n        if (this.working[workerId]) {\n            throw new Error(\"Posting a job t a working worker\");\n        }\n        this.working[workerId] = true;\n\n        this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();\n        this.workers[workerId].postMessage(e, transfers);\n\n        return this.pendingDeferreds[workerId].promise;\n    }\n\n    processWorks() {\n        for (let i=0; (i<this.workers.length)&&(this.actionQueue.length > 0); i++) {\n            if (this.working[i] == false) {\n                const work = this.actionQueue.shift();\n                this.postAction(i, work.data, work.transfers, work.deferred);\n            }\n        }\n    }\n\n    queueAction(actionData, transfers) {\n        const d = new Deferred();\n\n        if (this.singleThread) {\n            const res = this.taskManager(actionData);\n            d.resolve(res);\n        } else {\n            this.actionQueue.push({\n                data: actionData,\n                transfers: transfers,\n                deferred: d\n            });\n            this.processWorks();\n        }\n        return d.promise;\n    }\n\n    resetMemory() {\n        this.u32[0] = this.initalPFree;\n    }\n\n    allocBuff(buff) {\n        const pointer = this.alloc(buff.byteLength);\n        this.setBuff(pointer, buff);\n        return pointer;\n    }\n\n    getBuff(pointer, length) {\n        return this.u8.slice(pointer, pointer+ length);\n    }\n\n    setBuff(pointer, buffer) {\n        this.u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    alloc(length) {\n        while (this.u32[0] & 3) this.u32[0]++;  // Return always aligned pointers\n        const res = this.u32[0];\n        this.u32[0] += length;\n        return res;\n    }\n\n    async terminate() {\n        for (let i=0; i<this.workers.length; i++) {\n            this.workers[i].postMessage([{cmd: \"TERMINATE\"}]);\n        }\n        await sleep(200);\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy90aHJlYWRtYW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQixzQkFBc0I7OztBQUdxQjtBQUN2QjtBQUNZOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQiw0REFBTSxZQUFZO0FBQ3hDLEdBQUcsS0FBZSxFQUFFLEVBUW5CLENBQUM7QUFDRixnREFBZ0Q7QUFDaEQ7Ozs7QUFJZTtBQUNmOztBQUVBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE9BQU8sS0FBc0MsRUFBRSxFQUUxQztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGdFQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksS0FBZSxFQUFFLEVBSXBCLENBQUM7QUFDViwwQkFBMEIsb0NBQU87QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZUFBZTs7QUFFdkMsZ0NBQWdDLHVDQUFNOztBQUV0Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHdEQUF3RDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0MsMENBQTBDLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy90aHJlYWRtYW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21zbmFyayAoV2ViIEFzc2VtYmx5IHprU25hcmsgUHJvdmVyKS5cblxuICAgIHdhc21zbmFyayBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21zbmFyayBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtc25hcmsuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBjb25zdCBNRU1fU0laRSA9IDEwMDA7ICAvLyBNZW1vcnkgc2l6ZSBpbiA2NEsgUGFrZXMgKDUxMk1iKVxuY29uc3QgTUVNX1NJWkUgPSAyNTsgIC8vIE1lbW9yeSBzaXplIGluIDY0SyBQYWtlcyAoMTYwMEtiKVxuXG5cbmltcG9ydCB0aHJlYWQgZnJvbSBcIi4vdGhyZWFkbWFuX3RocmVhZC5qc1wiO1xuaW1wb3J0IG9zIGZyb20gXCJvc1wiO1xuaW1wb3J0IFdvcmtlciBmcm9tIFwid2ViLXdvcmtlclwiO1xuXG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG5sZXQgd29ya2VyU291cmNlO1xuXG5jb25zdCB0aHJlYWRTdHIgPSBgKCR7dGhyZWFkLnRvU3RyaW5nKCl9KShzZWxmKWA7XG5pZihwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICBpZihnbG9iYWxUaGlzPy5CbG9iKSB7XG4gICAgICAgIGNvbnN0IHRocmVhZEJ5dGVzPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGhyZWFkU3RyKTtcbiAgICAgICAgY29uc3Qgd29ya2VyQmxvYiA9IG5ldyBCbG9iKFt0aHJlYWRCeXRlc10sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIgfSkgO1xuICAgICAgICB3b3JrZXJTb3VyY2UgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHdvcmtlckJsb2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtlclNvdXJjZSA9IFwiZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0O2Jhc2U2NCxcIiArIGdsb2JhbFRoaXMuYnRvYSh0aHJlYWRTdHIpO1xuICAgIH1cbn0gZWxzZSB7ICBcbiAgICB3b3JrZXJTb3VyY2UgPSBcImRhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdDtiYXNlNjQsXCIgKyBCdWZmZXIuZnJvbSh0aHJlYWRTdHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuXG5cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gYnVpbGRUaHJlYWRNYW5hZ2VyKHdhc20sIHNpbmdsZVRocmVhZCkge1xuICAgIGNvbnN0IHRtID0gbmV3IFRocmVhZE1hbmFnZXIoKTtcblxuICAgIHRtLm1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6TUVNX1NJWkV9KTtcbiAgICB0bS51OCA9IG5ldyBVaW50OEFycmF5KHRtLm1lbW9yeS5idWZmZXIpO1xuICAgIHRtLnUzMiA9IG5ldyBVaW50MzJBcnJheSh0bS5tZW1vcnkuYnVmZmVyKTtcblxuICAgIGNvbnN0IHdhc21Nb2R1bGUgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKHdhc20uY29kZSk7XG5cbiAgICB0bS5pbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21Nb2R1bGUsIHtcbiAgICAgICAgZW52OiB7XG4gICAgICAgICAgICBcIm1lbW9yeVwiOiB0bS5tZW1vcnlcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmKHByb2Nlc3MuYnJvd3NlciAmJiAhZ2xvYmFsVGhpcz8uV29ya2VyKSB7XG4gICAgICAgIHNpbmdsZVRocmVhZCA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIHRtLnNpbmdsZVRocmVhZCA9IHNpbmdsZVRocmVhZDtcbiAgICB0bS5pbml0YWxQRnJlZSA9IHRtLnUzMlswXTsgICAvLyBTYXZlIHRoZSBQb2ludGVyIHRvIGZyZWUgc3BhY2UuXG4gICAgdG0ucHEgPSB3YXNtLnBxO1xuICAgIHRtLnByID0gd2FzbS5wcjtcbiAgICB0bS5wRzFnZW4gPSB3YXNtLnBHMWdlbjtcbiAgICB0bS5wRzF6ZXJvID0gd2FzbS5wRzF6ZXJvO1xuICAgIHRtLnBHMmdlbiA9IHdhc20ucEcyZ2VuO1xuICAgIHRtLnBHMnplcm8gPSB3YXNtLnBHMnplcm87XG4gICAgdG0ucE9uZVQgPSB3YXNtLnBPbmVUO1xuXG4gICAgLy8gICAgdG0ucFRtcDAgPSB0bS5hbGxvYyhjdXJ2ZS5HMi5GLm44KjMpO1xuICAgIC8vICAgIHRtLnBUbXAxID0gdG0uYWxsb2MoY3VydmUuRzIuRi5uOCozKTtcblxuICAgIGlmIChzaW5nbGVUaHJlYWQpIHtcbiAgICAgICAgdG0uY29kZSA9IHdhc20uY29kZTtcbiAgICAgICAgdG0udGFza01hbmFnZXIgPSB0aHJlYWQoKTtcbiAgICAgICAgYXdhaXQgdG0udGFza01hbmFnZXIoW3tcbiAgICAgICAgICAgIGNtZDogXCJJTklUXCIsXG4gICAgICAgICAgICBpbml0OiBNRU1fU0laRSxcbiAgICAgICAgICAgIGNvZGU6IHRtLmNvZGUuc2xpY2UoKVxuICAgICAgICB9XSk7XG4gICAgICAgIHRtLmNvbmN1cnJlbmN5ICA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdG0ud29ya2VycyA9IFtdO1xuICAgICAgICB0bS5wZW5kaW5nRGVmZXJyZWRzID0gW107XG4gICAgICAgIHRtLndvcmtpbmcgPSBbXTtcblxuICAgICAgICBsZXQgY29uY3VycmVuY3kgPSAyO1xuICAgICAgICBpZiAocHJvY2Vzcy5icm93c2VyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IG9zLmNwdXMoKS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZihjb25jdXJyZW5jeSA9PSAwKXtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExpbWl0IHRvIDY0IHRocmVhZHMgZm9yIG1lbW9yeSByZWFzb25zLlxuICAgICAgICBpZiAoY29uY3VycmVuY3k+NjQpIGNvbmN1cnJlbmN5PTY0O1xuICAgICAgICB0bS5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPGNvbmN1cnJlbmN5OyBpKyspIHtcblxuICAgICAgICAgICAgdG0ud29ya2Vyc1tpXSA9IG5ldyBXb3JrZXIod29ya2VyU291cmNlKTtcblxuICAgICAgICAgICAgdG0ud29ya2Vyc1tpXS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBnZXRPbk1zZyhpKSk7XG5cbiAgICAgICAgICAgIHRtLndvcmtpbmdbaV09ZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbml0UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRtLndvcmtlcnMubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgY29uc3QgY29weUNvZGUgPSB3YXNtLmNvZGUuc2xpY2UoKTtcbiAgICAgICAgICAgIGluaXRQcm9taXNlcy5wdXNoKHRtLnBvc3RBY3Rpb24oaSwgW3tcbiAgICAgICAgICAgICAgICBjbWQ6IFwiSU5JVFwiLFxuICAgICAgICAgICAgICAgIGluaXQ6IE1FTV9TSVpFLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvcHlDb2RlXG4gICAgICAgICAgICB9XSwgW2NvcHlDb2RlLmJ1ZmZlcl0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluaXRQcm9taXNlcyk7XG5cbiAgICB9XG4gICAgcmV0dXJuIHRtO1xuXG4gICAgZnVuY3Rpb24gZ2V0T25Nc2coaSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBpZiAoKGUpJiYoZS5kYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bS53b3JraW5nW2ldPWZhbHNlO1xuICAgICAgICAgICAgdG0ucGVuZGluZ0RlZmVycmVkc1tpXS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgdG0ucHJvY2Vzc1dvcmtzKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cbmV4cG9ydCBjbGFzcyBUaHJlYWRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLm9sZFBGcmVlID0gMDtcbiAgICB9XG5cbiAgICBzdGFydFN5bmNPcCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2xkUEZyZWUgIT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiU3luYyBvcGVyYXRpb24gaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIHRoaXMub2xkUEZyZWUgPSB0aGlzLnUzMlswXTtcbiAgICB9XG5cbiAgICBlbmRTeW5jT3AoKSB7XG4gICAgICAgIGlmICh0aGlzLm9sZFBGcmVlID09IDApIHRocm93IG5ldyBFcnJvcihcIk5vIHN5bmMgb3BlcmF0aW9uIGluIHByb2dyZXNzXCIpO1xuICAgICAgICB0aGlzLnUzMlswXSA9IHRoaXMub2xkUEZyZWU7XG4gICAgICAgIHRoaXMub2xkUEZyZWUgPSAwO1xuICAgIH1cblxuICAgIHBvc3RBY3Rpb24od29ya2VySWQsIGUsIHRyYW5zZmVycywgX2RlZmVycmVkKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmdbd29ya2VySWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0aW5nIGEgam9iIHQgYSB3b3JraW5nIHdvcmtlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndvcmtpbmdbd29ya2VySWRdID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnBlbmRpbmdEZWZlcnJlZHNbd29ya2VySWRdID0gX2RlZmVycmVkID8gX2RlZmVycmVkIDogbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMud29ya2Vyc1t3b3JrZXJJZF0ucG9zdE1lc3NhZ2UoZSwgdHJhbnNmZXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nRGVmZXJyZWRzW3dvcmtlcklkXS5wcm9taXNlO1xuICAgIH1cblxuICAgIHByb2Nlc3NXb3JrcygpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyAoaTx0aGlzLndvcmtlcnMubGVuZ3RoKSYmKHRoaXMuYWN0aW9uUXVldWUubGVuZ3RoID4gMCk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMud29ya2luZ1tpXSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmsgPSB0aGlzLmFjdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0QWN0aW9uKGksIHdvcmsuZGF0YSwgd29yay50cmFuc2ZlcnMsIHdvcmsuZGVmZXJyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVldWVBY3Rpb24oYWN0aW9uRGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgICAgIGNvbnN0IGQgPSBuZXcgRGVmZXJyZWQoKTtcblxuICAgICAgICBpZiAodGhpcy5zaW5nbGVUaHJlYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudGFza01hbmFnZXIoYWN0aW9uRGF0YSk7XG4gICAgICAgICAgICBkLnJlc29sdmUocmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogYWN0aW9uRGF0YSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcnM6IHRyYW5zZmVycyxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZDogZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NXb3JrcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkLnByb21pc2U7XG4gICAgfVxuXG4gICAgcmVzZXRNZW1vcnkoKSB7XG4gICAgICAgIHRoaXMudTMyWzBdID0gdGhpcy5pbml0YWxQRnJlZTtcbiAgICB9XG5cbiAgICBhbGxvY0J1ZmYoYnVmZikge1xuICAgICAgICBjb25zdCBwb2ludGVyID0gdGhpcy5hbGxvYyhidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLnNldEJ1ZmYocG9pbnRlciwgYnVmZik7XG4gICAgICAgIHJldHVybiBwb2ludGVyO1xuICAgIH1cblxuICAgIGdldEJ1ZmYocG9pbnRlciwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnU4LnNsaWNlKHBvaW50ZXIsIHBvaW50ZXIrIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgc2V0QnVmZihwb2ludGVyLCBidWZmZXIpIHtcbiAgICAgICAgdGhpcy51OC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSwgcG9pbnRlcik7XG4gICAgfVxuXG4gICAgYWxsb2MobGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnUzMlswXSAmIDMpIHRoaXMudTMyWzBdKys7ICAvLyBSZXR1cm4gYWx3YXlzIGFsaWduZWQgcG9pbnRlcnNcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy51MzJbMF07XG4gICAgICAgIHRoaXMudTMyWzBdICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBhc3luYyB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLndvcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud29ya2Vyc1tpXS5wb3N0TWVzc2FnZShbe2NtZDogXCJURVJNSU5BVEVcIn1dKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman_thread.js":
/*!********************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/threadman_thread.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ thread)\n/* harmony export */ });\n/* global WebAssembly */\n\nfunction thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == \"INIT\") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == \"TERMINATE\") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == \"INIT\") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case \"ALLOCSET\":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case \"ALLOC\":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case \"SET\":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case \"CALL\": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== \"undefined\") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != \"undefined\") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case \"GET\":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error(\"Invalid cmd\");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy90aHJlYWRtYW5fdGhyZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQ0FBbUM7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7O0FBSUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvc3JjL3RocmVhZG1hbl90aHJlYWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIFdlYkFzc2VtYmx5ICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRocmVhZChzZWxmKSB7XG4gICAgY29uc3QgTUFYTUVNID0gMzI3Njc7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGxldCBtZW1vcnk7XG5cbiAgICBpZiAoc2VsZikge1xuICAgICAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgaWYgKGUuZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YVswXS5jbWQgPT0gXCJJTklUXCIpIHtcbiAgICAgICAgICAgICAgICBpbml0KGRhdGFbMF0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhWzBdLmNtZCA9PSBcIlRFUk1JTkFURVwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBydW5UYXNrKGRhdGEpO1xuICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBpbml0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IG5ldyBVaW50OEFycmF5KGRhdGEuY29kZSk7XG4gICAgICAgIGNvbnN0IHdhc21Nb2R1bGUgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKGNvZGUpO1xuICAgICAgICBtZW1vcnkgPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOmRhdGEuaW5pdCwgbWF4aW11bTogTUFYTUVNfSk7XG5cbiAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh3YXNtTW9kdWxlLCB7XG4gICAgICAgICAgICBlbnY6IHtcbiAgICAgICAgICAgICAgICBcIm1lbW9yeVwiOiBtZW1vcnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIGFsbG9jKGxlbmd0aCkge1xuICAgICAgICBjb25zdCB1MzIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlciwgMCwgMSk7XG4gICAgICAgIHdoaWxlICh1MzJbMF0gJiAzKSB1MzJbMF0rKzsgIC8vIFJldHVybiBhbHdheXMgYWxpZ25lZCBwb2ludGVyc1xuICAgICAgICBjb25zdCByZXMgPSB1MzJbMF07XG4gICAgICAgIHUzMlswXSArPSBsZW5ndGg7XG4gICAgICAgIGlmICh1MzJbMF0gKyBsZW5ndGggPiBtZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYWdlcyA9IG1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aCAvIDB4MTAwMDA7XG4gICAgICAgICAgICBsZXQgcmVxdWlyZWRQYWdlcyA9IE1hdGguZmxvb3IoKHUzMlswXSArIGxlbmd0aCkgLyAweDEwMDAwKSsxO1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkUGFnZXM+TUFYTUVNKSByZXF1aXJlZFBhZ2VzPU1BWE1FTTtcbiAgICAgICAgICAgIG1lbW9yeS5ncm93KHJlcXVpcmVkUGFnZXMtY3VycmVudFBhZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsbG9jQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBwID0gYWxsb2MoYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICBzZXRCdWZmZXIocCwgYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QnVmZmVyKHBvaW50ZXIsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCB1OCA9IG5ldyBVaW50OEFycmF5KG1lbW9yeS5idWZmZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodTguYnVmZmVyLCB1OC5ieXRlT2Zmc2V0ICsgcG9pbnRlciwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRCdWZmZXIocG9pbnRlciwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHU4ID0gbmV3IFVpbnQ4QXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgICAgIHU4LnNldChuZXcgVWludDhBcnJheShidWZmZXIpLCBwb2ludGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5UYXNrKHRhc2spIHtcbiAgICAgICAgaWYgKHRhc2tbMF0uY21kID09IFwiSU5JVFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdCh0YXNrWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICB2YXJzOiBbXSxcbiAgICAgICAgICAgIG91dDogW11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdTMyYSA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyLCAwLCAxKTtcbiAgICAgICAgY29uc3Qgb2xkQWxsb2MgPSB1MzJhWzBdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGFzay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3dpdGNoICh0YXNrW2ldLmNtZCkge1xuICAgICAgICAgICAgY2FzZSBcIkFMTE9DU0VUXCI6XG4gICAgICAgICAgICAgICAgY3R4LnZhcnNbdGFza1tpXS52YXJdID0gYWxsb2NCdWZmZXIodGFza1tpXS5idWZmKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBTExPQ1wiOlxuICAgICAgICAgICAgICAgIGN0eC52YXJzW3Rhc2tbaV0udmFyXSA9IGFsbG9jKHRhc2tbaV0ubGVuKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTRVRcIjpcbiAgICAgICAgICAgICAgICBzZXRCdWZmZXIoY3R4LnZhcnNbdGFza1tpXS52YXJdLCB0YXNrW2ldLmJ1ZmYpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkNBTExcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajx0YXNrW2ldLnBhcmFtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gdGFza1tpXS5wYXJhbXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcC52YXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGN0eC52YXJzW3AudmFyXSArIChwLm9mZnNldCB8fCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHAudmFsICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHAudmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5leHBvcnRzW3Rhc2tbaV0uZm5OYW1lXSguLi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkdFVFwiOlxuICAgICAgICAgICAgICAgIGN0eC5vdXRbdGFza1tpXS5vdXRdID0gZ2V0QnVmZmVyKGN0eC52YXJzW3Rhc2tbaV0udmFyXSwgdGFza1tpXS5sZW4pLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY21kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHUzMmIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlciwgMCwgMSk7XG4gICAgICAgIHUzMmJbMF0gPSBvbGRBbGxvYztcbiAgICAgICAgcmV0dXJuIGN0eC5vdXQ7XG4gICAgfVxuXG5cbiAgICByZXR1cm4gcnVuVGFzaztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/threadman_thread.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   array2buffer: () => (/* binding */ array2buffer),\n/* harmony export */   beBuff2int: () => (/* binding */ beBuff2int),\n/* harmony export */   beInt2Buff: () => (/* binding */ beInt2Buff),\n/* harmony export */   bitReverse: () => (/* binding */ bitReverse),\n/* harmony export */   buffReverseBits: () => (/* binding */ buffReverseBits),\n/* harmony export */   buffer2array: () => (/* binding */ buffer2array),\n/* harmony export */   leBuff2int: () => (/* binding */ leBuff2int),\n/* harmony export */   leInt2Buff: () => (/* binding */ leInt2Buff),\n/* harmony export */   log2: () => (/* binding */ log2),\n/* harmony export */   stringifyBigInts: () => (/* binding */ stringifyBigInts),\n/* harmony export */   stringifyFElements: () => (/* binding */ stringifyFElements),\n/* harmony export */   unstringifyBigInts: () => (/* binding */ unstringifyBigInts),\n/* harmony export */   unstringifyFElements: () => (/* binding */ unstringifyFElements)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* global BigInt */\n\n\nfunction stringifyBigInts(o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.fromRprLE(o, 0);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigInts);\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction unstringifyBigInts(o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return BigInt(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return BigInt(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyBigInts);\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction beBuff2int(buff) {\n    let res = BigInt(0);\n    let i = buff.length;\n    let offset = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i > 0) {\n        if (i >= 4) {\n            i -= 4;\n            res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);\n            offset += 4;\n        } else if (i >= 2) {\n            i -= 2;\n            res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);\n            offset += 2;\n        } else {\n            i -= 1;\n            res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);\n            offset += 1;\n        }\n    }\n    return res;\n}\n\nfunction beInt2Buff(n, len) {\n    let r = n;\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = len;\n    while (o > 0) {\n        if (o - 4 >= 0) {\n            o -= 4;\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)));\n            r = r >> BigInt(32);\n        } else if (o - 2 >= 0) {\n            o -= 2;\n            buffV.setUint16(o, Number(r & BigInt(0xffff)));\n            r = r >> BigInt(16);\n        } else {\n            o -= 1;\n            buffV.setUint8(o, Number(r & BigInt(0xff)));\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nfunction leBuff2int(buff) {\n    let res = BigInt(0);\n    let i = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i < buff.length) {\n        if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);\n            i += 4;\n        } else if (i + 2 <= buff.length) {\n            res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);\n            i += 2;\n        } else {\n            res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);\n            i += 1;\n        }\n    }\n    return res;\n}\n\nfunction leInt2Buff(n, len) {\n    let r = n;\n    if (typeof len === \"undefined\") {\n        len = Math.floor((_scalar_js__WEBPACK_IMPORTED_MODULE_0__.bitLength(n) - 1) / 8) + 1;\n        if (len == 0) len = 1;\n    }\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = 0;\n    while (o < len) {\n        if (o + 4 <= len) {\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)), true);\n            o += 4;\n            r = r >> BigInt(32);\n        } else if (o + 2 <= len) {\n            buffV.setUint16(o, Number(r & BigInt(0xffff)), true);\n            o += 2;\n            r = r >> BigInt(16);\n        } else {\n            buffV.setUint8(o, Number(r & BigInt(0xff)), true);\n            o += 1;\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nfunction stringifyFElements(F, o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return F.toString(F.e(o));\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction unstringifyFElements(F, o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return F.e(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return F.e(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nconst _revTable = [];\nfor (let i = 0; i < 256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res = 0;\n    let a = idx;\n    for (let i = 0; i < bits; i++) {\n        res <<= 1;\n        res = res | (a & 1);\n        a >>= 1;\n    }\n    return res;\n}\n\nfunction bitReverse(idx, bits) {\n    return (\n        (_revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xff] << 8) |\n        (_revTable[(idx >>> 8) & 0xff] << 16) |\n        (_revTable[idx & 0xff] << 24)) >>>\n        (32 - bits)\n    );\n}\n\nfunction log2(V) {\n    return (\n        ((V & 0xffff0000) !== 0 ? ((V &= 0xffff0000), 16) : 0) |\n        ((V & 0xff00ff00) !== 0 ? ((V &= 0xff00ff00), 8) : 0) |\n        ((V & 0xf0f0f0f0) !== 0 ? ((V &= 0xf0f0f0f0), 4) : 0) |\n        ((V & 0xcccccccc) !== 0 ? ((V &= 0xcccccccc), 2) : 0) |\n        ((V & 0xaaaaaaaa) !== 0)\n    );\n}\n\nfunction buffReverseBits(buff, eSize) {\n    const n = buff.byteLength / eSize;\n    const bits = log2(n);\n    if (n != 1 << bits) {\n        throw new Error(\"Invalid number of pointers\");\n    }\n    for (let i = 0; i < n; i++) {\n        const r = bitReverse(i, bits);\n        if (i > r) {\n            const tmp = buff.slice(i * eSize, (i + 1) * eSize);\n            buff.set(buff.slice(r * eSize, (r + 1) * eSize), i * eSize);\n            buff.set(tmp, r * eSize);\n        }\n    }\n}\n\nfunction array2buffer(arr, sG) {\n    const buff = new Uint8Array(sG * arr.length);\n\n    for (let i = 0; i < arr.length; i++) {\n        buff.set(arr[i], i * sG);\n    }\n\n    return buff;\n}\n\nfunction buffer2array(buff, sG) {\n    const n = buff.byteLength / sG;\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = buff.slice(i * sG, i * sG + sG);\n    }\n    return arr;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3NDOztBQUUvQjtBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZSxpREFBZ0I7QUFDL0IsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQixpREFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgQmlnSW50ICovXG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlCaWdJbnRzKG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJiaWdpbnRcIiB8fCBvLmVxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG8udG9TdHJpbmcoMTApO1xuICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5mcm9tUnByTEUobywgMCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgICAgIHJldHVybiBvLm1hcChzdHJpbmdpZnlCaWdJbnRzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICByZXNba10gPSBzdHJpbmdpZnlCaWdJbnRzKG9ba10pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnN0cmluZ2lmeUJpZ0ludHMobykge1xuICAgIGlmICh0eXBlb2YgbyA9PSBcInN0cmluZ1wiICYmIC9eWzAtOV0rJC8udGVzdChvKSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KG8pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAvXjB4WzAtOWEtZkEtRl0rJC8udGVzdChvKSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KG8pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgICByZXR1cm4gby5tYXAodW5zdHJpbmdpZnlCaWdJbnRzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKG8gPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG8pO1xuICAgICAgICBrZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIHJlc1trXSA9IHVuc3RyaW5naWZ5QmlnSW50cyhvW2tdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVCdWZmMmludChidWZmKSB7XG4gICAgbGV0IHJlcyA9IEJpZ0ludCgwKTtcbiAgICBsZXQgaSA9IGJ1ZmYubGVuZ3RoO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgIGlmIChpID49IDQpIHtcbiAgICAgICAgICAgIGkgLT0gNDtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDMyKGkpKSA8PCBCaWdJbnQob2Zmc2V0ICogOCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgfSBlbHNlIGlmIChpID49IDIpIHtcbiAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDE2KGkpKSA8PCBCaWdJbnQob2Zmc2V0ICogOCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDgoaSkpIDw8IEJpZ0ludChvZmZzZXQgKiA4KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZUludDJCdWZmKG4sIGxlbikge1xuICAgIGxldCByID0gbjtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcik7XG4gICAgbGV0IG8gPSBsZW47XG4gICAgd2hpbGUgKG8gPiAwKSB7XG4gICAgICAgIGlmIChvIC0gNCA+PSAwKSB7XG4gICAgICAgICAgICBvIC09IDQ7XG4gICAgICAgICAgICBidWZmVi5zZXRVaW50MzIobywgTnVtYmVyKHIgJiBCaWdJbnQoMHhmZmZmZmZmZikpKTtcbiAgICAgICAgICAgIHIgPSByID4+IEJpZ0ludCgzMik7XG4gICAgICAgIH0gZWxzZSBpZiAobyAtIDIgPj0gMCkge1xuICAgICAgICAgICAgbyAtPSAyO1xuICAgICAgICAgICAgYnVmZlYuc2V0VWludDE2KG8sIE51bWJlcihyICYgQmlnSW50KDB4ZmZmZikpKTtcbiAgICAgICAgICAgIHIgPSByID4+IEJpZ0ludCgxNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvIC09IDE7XG4gICAgICAgICAgICBidWZmVi5zZXRVaW50OChvLCBOdW1iZXIociAmIEJpZ0ludCgweGZmKSkpO1xuICAgICAgICAgICAgciA9IHIgPj4gQmlnSW50KDgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBkb2VzIG5vdCBmaXQgaW4gdGhpcyBsZW5ndGhcIik7XG4gICAgfVxuICAgIHJldHVybiBidWZmO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVCdWZmMmludChidWZmKSB7XG4gICAgbGV0IHJlcyA9IEJpZ0ludCgwKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIsIGJ1ZmYuYnl0ZU9mZnNldCwgYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICB3aGlsZSAoaSA8IGJ1ZmYubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpICsgNCA8PSBidWZmLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzICs9IEJpZ0ludChidWZmVi5nZXRVaW50MzIoaSwgdHJ1ZSkpIDw8IEJpZ0ludChpICogOCk7XG4gICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDIgPD0gYnVmZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDE2KGksIHRydWUpKSA8PCBCaWdJbnQoaSAqIDgpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IEJpZ0ludChidWZmVi5nZXRVaW50OChpLCB0cnVlKSkgPDwgQmlnSW50KGkgKiA4KTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVJbnQyQnVmZihuLCBsZW4pIHtcbiAgICBsZXQgciA9IG47XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbGVuID0gTWF0aC5mbG9vcigoU2NhbGFyLmJpdExlbmd0aChuKSAtIDEpIC8gOCkgKyAxO1xuICAgICAgICBpZiAobGVuID09IDApIGxlbiA9IDE7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKTtcbiAgICBsZXQgbyA9IDA7XG4gICAgd2hpbGUgKG8gPCBsZW4pIHtcbiAgICAgICAgaWYgKG8gKyA0IDw9IGxlbikge1xuICAgICAgICAgICAgYnVmZlYuc2V0VWludDMyKG8sIE51bWJlcihyICYgQmlnSW50KDB4ZmZmZmZmZmYpKSwgdHJ1ZSk7XG4gICAgICAgICAgICBvICs9IDQ7XG4gICAgICAgICAgICByID0gciA+PiBCaWdJbnQoMzIpO1xuICAgICAgICB9IGVsc2UgaWYgKG8gKyAyIDw9IGxlbikge1xuICAgICAgICAgICAgYnVmZlYuc2V0VWludDE2KG8sIE51bWJlcihyICYgQmlnSW50KDB4ZmZmZikpLCB0cnVlKTtcbiAgICAgICAgICAgIG8gKz0gMjtcbiAgICAgICAgICAgIHIgPSByID4+IEJpZ0ludCgxNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmVi5zZXRVaW50OChvLCBOdW1iZXIociAmIEJpZ0ludCgweGZmKSksIHRydWUpO1xuICAgICAgICAgICAgbyArPSAxO1xuICAgICAgICAgICAgciA9IHIgPj4gQmlnSW50KDgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBkb2VzIG5vdCBmaXQgaW4gdGhpcyBsZW5ndGhcIik7XG4gICAgfVxuICAgIHJldHVybiBidWZmO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5RkVsZW1lbnRzKEYsIG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJiaWdpbnRcIiB8fCBvLmVxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG8udG9TdHJpbmcoMTApO1xuICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEYudG9TdHJpbmcoRi5lKG8pKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHN0cmluZ2lmeUZFbGVtZW50cy5iaW5kKHRoaXMsIEYpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICByZXNba10gPSBzdHJpbmdpZnlGRWxlbWVudHMoRiwgb1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc3RyaW5naWZ5RkVsZW1lbnRzKEYsIG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAvXlswLTldKyQvLnRlc3QobykpIHtcbiAgICAgICAgcmV0dXJuIEYuZShvKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwic3RyaW5nXCIgJiYgL14weFswLTlhLWZBLUZdKyQvLnRlc3QobykpIHtcbiAgICAgICAgcmV0dXJuIEYuZShvKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHVuc3RyaW5naWZ5RkVsZW1lbnRzLmJpbmQodGhpcywgRikpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAobyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobyk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgcmVzW2tdID0gdW5zdHJpbmdpZnlGRWxlbWVudHMoRiwgb1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cblxuY29uc3QgX3JldlRhYmxlID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX3JldlRhYmxlW2ldID0gX3JldlNsb3coaSwgOCk7XG59XG5cbmZ1bmN0aW9uIF9yZXZTbG93KGlkeCwgYml0cykge1xuICAgIGxldCByZXMgPSAwO1xuICAgIGxldCBhID0gaWR4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYml0czsgaSsrKSB7XG4gICAgICAgIHJlcyA8PD0gMTtcbiAgICAgICAgcmVzID0gcmVzIHwgKGEgJiAxKTtcbiAgICAgICAgYSA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpdFJldmVyc2UoaWR4LCBiaXRzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgKF9yZXZUYWJsZVtpZHggPj4+IDI0XSB8XG4gICAgICAgIChfcmV2VGFibGVbKGlkeCA+Pj4gMTYpICYgMHhmZl0gPDwgOCkgfFxuICAgICAgICAoX3JldlRhYmxlWyhpZHggPj4+IDgpICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgKF9yZXZUYWJsZVtpZHggJiAweGZmXSA8PCAyNCkpID4+PlxuICAgICAgICAoMzIgLSBiaXRzKVxuICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2cyKFYpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAoKFYgJiAweGZmZmYwMDAwKSAhPT0gMCA/ICgoViAmPSAweGZmZmYwMDAwKSwgMTYpIDogMCkgfFxuICAgICAgICAoKFYgJiAweGZmMDBmZjAwKSAhPT0gMCA/ICgoViAmPSAweGZmMDBmZjAwKSwgOCkgOiAwKSB8XG4gICAgICAgICgoViAmIDB4ZjBmMGYwZjApICE9PSAwID8gKChWICY9IDB4ZjBmMGYwZjApLCA0KSA6IDApIHxcbiAgICAgICAgKChWICYgMHhjY2NjY2NjYykgIT09IDAgPyAoKFYgJj0gMHhjY2NjY2NjYyksIDIpIDogMCkgfFxuICAgICAgICAoKFYgJiAweGFhYWFhYWFhKSAhPT0gMClcbiAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVmZlJldmVyc2VCaXRzKGJ1ZmYsIGVTaXplKSB7XG4gICAgY29uc3QgbiA9IGJ1ZmYuYnl0ZUxlbmd0aCAvIGVTaXplO1xuICAgIGNvbnN0IGJpdHMgPSBsb2cyKG4pO1xuICAgIGlmIChuICE9IDEgPDwgYml0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludGVyc1wiKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgciA9IGJpdFJldmVyc2UoaSwgYml0cyk7XG4gICAgICAgIGlmIChpID4gcikge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gYnVmZi5zbGljZShpICogZVNpemUsIChpICsgMSkgKiBlU2l6ZSk7XG4gICAgICAgICAgICBidWZmLnNldChidWZmLnNsaWNlKHIgKiBlU2l6ZSwgKHIgKyAxKSAqIGVTaXplKSwgaSAqIGVTaXplKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KHRtcCwgciAqIGVTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5MmJ1ZmZlcihhcnIsIHNHKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHNHICogYXJyLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWZmLnNldChhcnJbaV0sIGkgKiBzRyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIyYXJyYXkoYnVmZiwgc0cpIHtcbiAgICBjb25zdCBuID0gYnVmZi5ieXRlTGVuZ3RoIC8gc0c7XG4gICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGJ1ZmYuc2xpY2UoaSAqIHNHLCBpICogc0cgKyBzRyk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_curve.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_curve.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WasmCurve)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine_batchconvert.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js\");\n\n\n\n\n\nclass WasmCurve {\n\n    constructor(tm, prefix, F, pGen, pGb, cofactor) {\n        this.tm = tm;\n        this.prefix = prefix;\n        this.F = F;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, F.n8*3);\n        this.tm.instance.exports[prefix + \"_zeroAffine\"](this.pOp1);\n        this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8*2);\n        this.one = this.tm.getBuff(pGen, F.n8*3);\n        this.g = this.one;\n        this.oneAffine = this.tm.getBuff(pGen, F.n8*2);\n        this.gAffine = this.oneAffine;\n        this.b = this.tm.getBuff(pGb, F.n8);\n\n        if (cofactor) {\n            this.cofactor = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toLEBuff(cofactor);\n        }\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.batchLEMtoC = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchLEMtoC\", F.n8*2, F.n8);\n        this.batchLEMtoU = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchLEMtoU\", F.n8*2, F.n8*2);\n        this.batchCtoLEM = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchCtoLEM\", F.n8, F.n8*2);\n        this.batchUtoLEM = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchUtoLEM\", F.n8*2, F.n8*2);\n        this.batchToJacobian = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchToJacobian\", F.n8*2, F.n8*3);\n        this.batchToAffine = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(tm, prefix + \"_batchToAffine\", F.n8*3, F.n8*2);\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op2bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op1Affine(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*2);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_add\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_addMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    sub(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_sub\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_subMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    neg(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_neg\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Affine(\"_negAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    double(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_double\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_doubleAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isZero(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Bool(\"_isZero\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Bool(\"_isZeroAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    timesScalar(a, s) {\n        if (!(s instanceof Uint8Array)) {\n            s = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toLEBuff(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(s));\n        }\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesScalar\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesScalarAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    timesFr(a, s) {\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesFr\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesFrAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    eq(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eq\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eqMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toAffine(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Affine(\"_toAffine\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return a;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toJacobian(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return a;\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_toJacobian\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toRprUncompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoU\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n        arr.set(res, offset);\n    }\n\n    fromRprUncompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8*2);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_UtoLEM\"](this.pOp1, this.pOp1);\n        return this.tm.getBuff(this.pOp1, this.F.n8*2);\n    }\n\n    toRprCompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoC\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8);\n        arr.set(res, offset);\n    }\n\n    fromRprCompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_CtoLEM\"](this.pOp1, this.pOp2);\n        return this.tm.getBuff(this.pOp2, this.F.n8*2);\n    }\n\n    toUncompressed(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        this.toRprUncompressed(buff, 0, a);\n        return buff;\n    }\n\n    toRprLEM(arr, offset, a) {\n        if (a.byteLength == this.F.n8*2) {\n            arr.set(a, offset);\n            return;\n        } else if (a.byteLength == this.F.n8*3) {\n            this.tm.setBuff(this.pOp1, a);\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n            const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n            arr.set(res, offset);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    fromRprLEM(arr, offset) {\n        offset = offset || 0;\n        return arr.slice(offset, offset+this.F.n8*2);\n    }\n\n    toString(a, radix) {\n        if (a.byteLength == this.F.n8*3) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n            const z = this.F.toString(a.slice(this.F.n8*2), radix);\n            return `[ ${x}, ${y}, ${z} ]`;\n        } else if (a.byteLength == this.F.n8*2) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8), radix);\n            return `[ ${x}, ${y} ]`;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isValid(a) {\n        if (this.isZero(a)) return true;\n        const F = this.F;\n        const aa = this.toAffine(a);\n        const x = aa.slice(0, this.F.n8);\n        const y = aa.slice(this.F.n8, this.F.n8*2);\n        const x3b = F.add(F.mul(F.square(x),x), this.b);\n        const y2 = F.square(y);\n        return F.eq(x3b, y2);\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        let x3b;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        } while (!F.isSquare(x3b));\n\n        P[1] = F.sqrt(x3b);\n\n        const s = F.isNegative(P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n\n        let Pbuff = new Uint8Array(this.F.n8*2);\n        Pbuff.set(P[0]);\n        Pbuff.set(P[1], this.F.n8);\n\n        if (this.cofactor) {\n            Pbuff = this.timesScalar(Pbuff, this.cofactor);\n        }\n\n        return Pbuff;\n    }\n\n\n\n    toObject(a) {\n        if (this.isZero(a)) {\n            return [\n                this.F.toObject(this.F.zero),\n                this.F.toObject(this.F.one),\n                this.F.toObject(this.F.zero),\n            ];\n        }\n        const x = this.F.toObject(a.slice(0, this.F.n8));\n        const y = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        let z;\n        if (a.byteLength == this.F.n8*3) {\n            z = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        } else {\n            z = this.F.toObject(this.F.one);\n        }\n        return [x, y, z];\n    }\n\n    fromObject(a) {\n        const x = this.F.fromObject(a[0]);\n        const y = this.F.fromObject(a[1]);\n        let z;\n        if (a.length==3) {\n            z = this.F.fromObject(a[2]);\n        } else {\n            z = this.F.one;\n        }\n        if (this.F.isZero(z, this.F.one)) {\n            return this.zeroAffine;\n        } else if (this.F.eq(z, this.F.one)) {\n            const buff = new Uint8Array(this.F.n8*2);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            return buff;\n        } else {\n            const buff = new Uint8Array(this.F.n8*3);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            buff.set(z, this.F.n8*2);\n            return buff;\n        }\n    }\n\n    e(a) {\n        if (a instanceof Uint8Array) return a;\n        return this.fromObject(a);\n    }\n\n    x(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(0, this.F.n8);\n    }\n\n    y(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(this.F.n8);\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy93YXNtX2N1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRXNDO0FBQ21COztBQUUxQzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZ0RBQWU7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsbUVBQWlCO0FBQzVDLDJCQUEyQixtRUFBaUI7QUFDNUMsMkJBQTJCLG1FQUFpQjtBQUM1QywyQkFBMkIsbUVBQWlCO0FBQzVDLCtCQUErQixtRUFBaUI7QUFDaEQsNkJBQTZCLG1FQUFpQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFlLENBQUMseUNBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFLElBQUksRUFBRSxJQUFJLEdBQUc7QUFDdkMsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxJQUFJLEdBQUc7QUFDakMsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvd2FzbV9jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0ICogYXMgU2NhbGFyIGZyb20gXCIuL3NjYWxhci5qc1wiO1xuaW1wb3J0IGJ1aWxkQmF0Y2hDb252ZXJ0IGZyb20gXCIuL2VuZ2luZV9iYXRjaGNvbnZlcnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2FzbUN1cnZlIHtcblxuICAgIGNvbnN0cnVjdG9yKHRtLCBwcmVmaXgsIEYsIHBHZW4sIHBHYiwgY29mYWN0b3IpIHtcbiAgICAgICAgdGhpcy50bSA9IHRtO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgdGhpcy5GID0gRjtcblxuICAgICAgICB0aGlzLnBPcDEgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnBPcDIgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnBPcDMgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfemVyb1wiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLnplcm8gPSB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AxLCBGLm44KjMpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfemVyb0FmZmluZVwiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLnplcm9BZmZpbmUgPSB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AxLCBGLm44KjIpO1xuICAgICAgICB0aGlzLm9uZSA9IHRoaXMudG0uZ2V0QnVmZihwR2VuLCBGLm44KjMpO1xuICAgICAgICB0aGlzLmcgPSB0aGlzLm9uZTtcbiAgICAgICAgdGhpcy5vbmVBZmZpbmUgPSB0aGlzLnRtLmdldEJ1ZmYocEdlbiwgRi5uOCoyKTtcbiAgICAgICAgdGhpcy5nQWZmaW5lID0gdGhpcy5vbmVBZmZpbmU7XG4gICAgICAgIHRoaXMuYiA9IHRoaXMudG0uZ2V0QnVmZihwR2IsIEYubjgpO1xuXG4gICAgICAgIGlmIChjb2ZhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5jb2ZhY3RvciA9IFNjYWxhci50b0xFQnVmZihjb2ZhY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5lZ29uZSA9IHRoaXMubmVnKHRoaXMub25lKTtcbiAgICAgICAgdGhpcy50d28gPSB0aGlzLmFkZCh0aGlzLm9uZSwgdGhpcy5vbmUpO1xuXG4gICAgICAgIHRoaXMuYmF0Y2hMRU10b0MgPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hMRU10b0NcIiwgRi5uOCoyLCBGLm44KTtcbiAgICAgICAgdGhpcy5iYXRjaExFTXRvVSA9IGJ1aWxkQmF0Y2hDb252ZXJ0KHRtLCBwcmVmaXggKyBcIl9iYXRjaExFTXRvVVwiLCBGLm44KjIsIEYubjgqMik7XG4gICAgICAgIHRoaXMuYmF0Y2hDdG9MRU0gPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hDdG9MRU1cIiwgRi5uOCwgRi5uOCoyKTtcbiAgICAgICAgdGhpcy5iYXRjaFV0b0xFTSA9IGJ1aWxkQmF0Y2hDb252ZXJ0KHRtLCBwcmVmaXggKyBcIl9iYXRjaFV0b0xFTVwiLCBGLm44KjIsIEYubjgqMik7XG4gICAgICAgIHRoaXMuYmF0Y2hUb0phY29iaWFuID0gYnVpbGRCYXRjaENvbnZlcnQodG0sIHByZWZpeCArIFwiX2JhdGNoVG9KYWNvYmlhblwiLCBGLm44KjIsIEYubjgqMyk7XG4gICAgICAgIHRoaXMuYmF0Y2hUb0FmZmluZSA9IGJ1aWxkQmF0Y2hDb252ZXJ0KHRtLCBwcmVmaXggKyBcIl9iYXRjaFRvQWZmaW5lXCIsIEYubjgqMywgRi5uOCoyKTtcbiAgICB9XG5cbiAgICBvcDIob3BOYW1lLCBhLCBiKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMuRi5uOCozKTtcbiAgICB9XG5cbiAgICBvcDJib29sKG9wTmFtZSwgYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHJldHVybiAhIXRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgfVxuXG4gICAgb3AxKG9wTmFtZSwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLkYubjgqMyk7XG4gICAgfVxuXG4gICAgb3AxQWZmaW5lKG9wTmFtZSwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLkYubjgqMik7XG4gICAgfVxuXG4gICAgb3AxQm9vbChvcE5hbWUsIGEpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHJldHVybiAhIXRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDMpO1xuICAgIH1cblxuICAgIGFkZChhLGIpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRcIiwgYSwgYik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRNaXhlZFwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRNaXhlZFwiLCBiLCBhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX2FkZEFmZmluZVwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3ViKGEsYikge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1YlwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1Yk1peGVkXCIsIGEsIGIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1Yk1peGVkXCIsIGIsIGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfc3ViQWZmaW5lXCIsIGEsIGIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZWcoYSkge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfbmVnXCIsIGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxQWZmaW5lKFwiX25lZ0FmZmluZVwiLCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRvdWJsZShhKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9kb3VibGVcIiwgYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfZG91YmxlQWZmaW5lXCIsIGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNaZXJvKGEpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1plcm9cIiwgYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzWmVyb0FmZmluZVwiLCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVzU2NhbGFyKGEsIHMpIHtcbiAgICAgICAgaWYgKCEocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBzID0gU2NhbGFyLnRvTEVCdWZmKFNjYWxhci5lKHMpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm5OYW1lO1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSB0aGlzLnByZWZpeCArIFwiX3RpbWVzU2NhbGFyXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSB0aGlzLnByZWZpeCArIFwiX3RpbWVzU2NhbGFyQWZmaW5lXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIHMpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbZm5OYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgcy5ieXRlTGVuZ3RoLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5GLm44KjMpO1xuICAgIH1cblxuICAgIHRpbWVzRnIoYSwgcykge1xuICAgICAgICBsZXQgZm5OYW1lO1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSB0aGlzLnByZWZpeCArIFwiX3RpbWVzRnJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IHRoaXMucHJlZml4ICsgXCJfdGltZXNGckFmZmluZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBzKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW2ZuTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLkYubjgqMyk7XG4gICAgfVxuXG4gICAgZXEoYSxiKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDJib29sKFwiX2VxXCIsIGEsIGIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDJib29sKFwiX2VxTWl4ZWRcIiwgYSwgYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDJib29sKFwiX2VxTWl4ZWRcIiwgYiwgYSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMmJvb2woXCJfZXFBZmZpbmVcIiwgYSwgYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvQWZmaW5lKGEpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxQWZmaW5lKFwiX3RvQWZmaW5lXCIsIGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b0phY29iaWFuKGEpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfdG9KYWNvYmlhblwiLCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvUnByVW5jb21wcmVzc2VkKGFyciwgb2Zmc2V0LCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl90b0FmZmluZVwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoICE9IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfTEVNdG9VXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AxKTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5GLm44KjIpO1xuICAgICAgICBhcnIuc2V0KHJlcywgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICBmcm9tUnByVW5jb21wcmVzc2VkKGFyciwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhcnIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLkYubjgqMik7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGJ1ZmYpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9VdG9MRU1cIl0odGhpcy5wT3AxLCB0aGlzLnBPcDEpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5GLm44KjIpO1xuICAgIH1cblxuICAgIHRvUnByQ29tcHJlc3NlZChhcnIsIG9mZnNldCwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfdG9BZmZpbmVcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCAhPSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX0xFTXRvQ1wiXSh0aGlzLnBPcDEsIHRoaXMucE9wMSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMuRi5uOCk7XG4gICAgICAgIGFyci5zZXQocmVzLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGZyb21ScHJDb21wcmVzc2VkKGFyciwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhcnIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLkYubjgpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBidWZmKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfQ3RvTEVNXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDIsIHRoaXMuRi5uOCoyKTtcbiAgICB9XG5cbiAgICB0b1VuY29tcHJlc3NlZChhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMik7XG4gICAgICAgIHRoaXMudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgYSk7XG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH1cblxuICAgIHRvUnByTEVNKGFyciwgb2Zmc2V0LCBhKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIGFyci5zZXQoYSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfdG9BZmZpbmVcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDEpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgYXJyLnNldChyZXMsIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmcm9tUnByTEVNKGFyciwgb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgICByZXR1cm4gYXJyLnNsaWNlKG9mZnNldCwgb2Zmc2V0K3RoaXMuRi5uOCoyKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZyhhLCByYWRpeCkge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UoMCwgdGhpcy5GLm44KSwgcmFkaXgpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpLCByYWRpeCk7XG4gICAgICAgICAgICBjb25zdCB6ID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UodGhpcy5GLm44KjIpLCByYWRpeCk7XG4gICAgICAgICAgICByZXR1cm4gYFsgJHt4fSwgJHt5fSwgJHt6fSBdYDtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSgwLCB0aGlzLkYubjgpLCByYWRpeCk7XG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UodGhpcy5GLm44KSwgcmFkaXgpO1xuICAgICAgICAgICAgcmV0dXJuIGBbICR7eH0sICR7eX0gXWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc1ZhbGlkKGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKGEpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcbiAgICAgICAgY29uc3QgYWEgPSB0aGlzLnRvQWZmaW5lKGEpO1xuICAgICAgICBjb25zdCB4ID0gYWEuc2xpY2UoMCwgdGhpcy5GLm44KTtcbiAgICAgICAgY29uc3QgeSA9IGFhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpO1xuICAgICAgICBjb25zdCB4M2IgPSBGLmFkZChGLm11bChGLnNxdWFyZSh4KSx4KSwgdGhpcy5iKTtcbiAgICAgICAgY29uc3QgeTIgPSBGLnNxdWFyZSh5KTtcbiAgICAgICAgcmV0dXJuIEYuZXEoeDNiLCB5Mik7XG4gICAgfVxuXG4gICAgZnJvbVJuZyhybmcpIHtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcbiAgICAgICAgbGV0IFAgPSBbXTtcbiAgICAgICAgbGV0IGdyZWF0ZXN0O1xuICAgICAgICBsZXQgeDNiO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBQWzBdID0gRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgICAgICBncmVhdGVzdCA9IHJuZy5uZXh0Qm9vbCgpO1xuICAgICAgICAgICAgeDNiID0gRi5hZGQoRi5tdWwoRi5zcXVhcmUoUFswXSksIFBbMF0pLCB0aGlzLmIpO1xuICAgICAgICB9IHdoaWxlICghRi5pc1NxdWFyZSh4M2IpKTtcblxuICAgICAgICBQWzFdID0gRi5zcXJ0KHgzYik7XG5cbiAgICAgICAgY29uc3QgcyA9IEYuaXNOZWdhdGl2ZShQWzFdKTtcbiAgICAgICAgaWYgKGdyZWF0ZXN0IF4gcykgUFsxXSA9IEYubmVnKFBbMV0pO1xuXG4gICAgICAgIGxldCBQYnVmZiA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCoyKTtcbiAgICAgICAgUGJ1ZmYuc2V0KFBbMF0pO1xuICAgICAgICBQYnVmZi5zZXQoUFsxXSwgdGhpcy5GLm44KTtcblxuICAgICAgICBpZiAodGhpcy5jb2ZhY3Rvcikge1xuICAgICAgICAgICAgUGJ1ZmYgPSB0aGlzLnRpbWVzU2NhbGFyKFBidWZmLCB0aGlzLmNvZmFjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQYnVmZjtcbiAgICB9XG5cblxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5GLnRvT2JqZWN0KHRoaXMuRi56ZXJvKSxcbiAgICAgICAgICAgICAgICB0aGlzLkYudG9PYmplY3QodGhpcy5GLm9uZSksXG4gICAgICAgICAgICAgICAgdGhpcy5GLnRvT2JqZWN0KHRoaXMuRi56ZXJvKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKDAsIHRoaXMuRi5uOCkpO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5GLnRvT2JqZWN0KGEuc2xpY2UodGhpcy5GLm44LCB0aGlzLkYubjgqMikpO1xuICAgICAgICBsZXQgejtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgeiA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKHRoaXMuRi5uOCoyLCB0aGlzLkYubjgqMykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeiA9IHRoaXMuRi50b09iamVjdCh0aGlzLkYub25lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgIH1cblxuICAgIGZyb21PYmplY3QoYSkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5GLmZyb21PYmplY3QoYVswXSk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLkYuZnJvbU9iamVjdChhWzFdKTtcbiAgICAgICAgbGV0IHo7XG4gICAgICAgIGlmIChhLmxlbmd0aD09Mykge1xuICAgICAgICAgICAgeiA9IHRoaXMuRi5mcm9tT2JqZWN0KGFbMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeiA9IHRoaXMuRi5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuRi5pc1plcm8oeiwgdGhpcy5GLm9uZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm9BZmZpbmU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5GLmVxKHosIHRoaXMuRi5vbmUpKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgYnVmZi5zZXQoeCk7XG4gICAgICAgICAgICBidWZmLnNldCh5LCB0aGlzLkYubjgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjMpO1xuICAgICAgICAgICAgYnVmZi5zZXQoeCk7XG4gICAgICAgICAgICBidWZmLnNldCh5LCB0aGlzLkYubjgpO1xuICAgICAgICAgICAgYnVmZi5zZXQoeiwgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlKGEpIHtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gYTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbU9iamVjdChhKTtcbiAgICB9XG5cbiAgICB4KGEpIHtcbiAgICAgICAgY29uc3QgdG1wID0gdGhpcy50b0FmZmluZShhKTtcbiAgICAgICAgcmV0dXJuIHRtcC5zbGljZSgwLCB0aGlzLkYubjgpO1xuICAgIH1cblxuICAgIHkoYSkge1xuICAgICAgICBjb25zdCB0bXAgPSB0aGlzLnRvQWZmaW5lKGEpO1xuICAgICAgICByZXR1cm4gdG1wLnNsaWNlKHRoaXMuRi5uOCk7XG4gICAgfVxuXG59XG5cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field1.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field1.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WasmField1)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/utils.js\");\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./random.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js\");\n/* harmony import */ var _engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./engine_batchconvert.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/engine_batchconvert.js\");\n/* harmony import */ var _bigbuffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bigbuffer.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/bigbuffer.js\");\n\n\n\n\n\n\n\nclass WasmField1 {\n\n    constructor(tm, prefix, n8, p) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.p = p;\n        this.n8 = n8;\n        this.type = \"F1\";\n        this.m = 1;\n\n        this.half = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.shiftRight(p, _scalar_js__WEBPACK_IMPORTED_MODULE_0__.one);\n        this.bitLength = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.bitLength(p);\n        this.mask = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.shiftLeft(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.one, this.bitLength), _scalar_js__WEBPACK_IMPORTED_MODULE_0__.one);\n\n        this.pOp1 = tm.alloc(n8);\n        this.pOp2 = tm.alloc(n8);\n        this.pOp3 = tm.alloc(n8);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = this.tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.n64 = Math.floor(n8/8);\n        this.n32 = Math.floor(n8/4);\n\n        if(this.n64*8 != this.n8) {\n            throw new Error(\"n8 must be a multiple of 8\");\n        }\n\n        this.half = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.shiftRight(this.p, _scalar_js__WEBPACK_IMPORTED_MODULE_0__.one);\n        this.nqr = this.two;\n        let r = this.exp(this.nqr, this.half);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.add(this.nqr, this.one);\n            r = this.exp(this.nqr, this.half);\n        }\n\n        this.shift = this.mul(this.nqr, this.nqr);\n        this.shiftInv = this.inv(this.shift);\n\n        this.s = 0;\n        let t = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(this.p, _scalar_js__WEBPACK_IMPORTED_MODULE_0__.one);\n\n        while ( !_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isOdd(t) ) {\n            this.s = this.s + 1;\n            t = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.shiftRight(t, _scalar_js__WEBPACK_IMPORTED_MODULE_0__.one);\n        }\n\n        this.w = [];\n        this.w[this.s] = this.exp(this.nqr, t);\n\n        for (let i= this.s-1; i>=0; i--) {\n            this.w[i] = this.square(this.w[i+1]);\n        }\n\n        if (!this.eq(this.w[0], this.one)) {\n            throw new Error(\"Error calculating roots of unity\");\n        }\n\n        this.batchToMontgomery = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(tm, prefix + \"_batchToMontgomery\", this.n8, this.n8);\n        this.batchFromMontgomery = (0,_engine_batchconvert_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(tm, prefix + \"_batchFromMontgomery\", this.n8, this.n8);\n    }\n\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toLEBuff(_scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        let ra = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.e(a, b);\n        if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isNegative(ra)) {\n            ra = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.neg(ra);\n            if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.gt(ra, this.p)) {\n                ra = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(ra, this.p);\n            }\n            ra = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.sub(this.p, ra);\n        } else {\n            if (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.gt(ra, this.p)) {\n                ra = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.mod(ra, this.p);\n            }\n        }\n        const buff = _utils_js__WEBPACK_IMPORTED_MODULE_1__.leInt2Buff(ra, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toString(a, radix) {\n        const an = this.fromMontgomery(a);\n        const s = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.fromRprLE(an, 0);\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toString(s, radix);\n    }\n\n    fromRng(rng) {\n        let v;\n        const buff = new Uint8Array(this.n8);\n        do {\n            v = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.zero;\n            for (let i=0; i<this.n64; i++) {\n                v = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.add(v,  _scalar_js__WEBPACK_IMPORTED_MODULE_0__.shiftLeft(rng.nextU64(), 64*i));\n            }\n            v = _scalar_js__WEBPACK_IMPORTED_MODULE_0__.band(v, this.mask);\n        } while (_scalar_js__WEBPACK_IMPORTED_MODULE_0__.geq(v, this.p));\n        _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toRprLE(buff, 0, v, this.n8);\n        return buff;\n    }\n\n    random() {\n        return this.fromRng((0,_random_js__WEBPACK_IMPORTED_MODULE_2__.getThreadRng)());\n    }\n\n    toObject(a) {\n        const an = this.fromMontgomery(a);\n        return _scalar_js__WEBPACK_IMPORTED_MODULE_0__.fromRprLE(an, 0);\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.n8);\n        _scalar_js__WEBPACK_IMPORTED_MODULE_0__.toRprLE(buff, 0, a, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toRprLE(buff, offset, a) {\n        buff.set(this.fromMontgomery(a), offset);\n    }\n\n    toRprBE(buff, offset, a) {\n        const buff2 = this.fromMontgomery(a);\n        for (let i=0; i<this.n8/2; i++) {\n            const aux = buff2[i];\n            buff2[i] = buff2[this.n8-1-i];\n            buff2[this.n8-1-i] = aux;\n        }\n        buff.set(buff2, offset);\n    }\n\n    fromRprLE(buff, offset) {\n        offset = offset || 0;\n        const res = buff.slice(offset, offset + this.n8);\n        return this.toMontgomery(res);\n    }\n\n    async batchInverse(buffIn) {\n        let returnArray = false;\n        const sIn = this.n8;\n        const sOut = this.n8;\n\n        if (Array.isArray(buffIn)) {\n            buffIn = _utils_js__WEBPACK_IMPORTED_MODULE_1__.array2buffer(buffIn, sIn );\n            returnArray = true;\n        } else {\n            buffIn = buffIn.slice(0, buffIn.byteLength);\n        }\n\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/this.tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<this.tm.concurrency; i++) {\n            let n;\n            if (i< this.tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: this.prefix + \"_batchInverse\", params: [\n                    {var: 0},\n                    {val: sIn},\n                    {val: n},\n                    {var: 1},\n                    {val: sOut},\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                this.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof _bigbuffer_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]) {\n            fullBuffOut = new _bigbuffer_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        if (returnArray) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.buffer2array(fullBuffOut, sOut);\n        } else {\n            return fullBuffOut;\n        }\n\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy93YXNtX2ZpZWxkMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0M7QUFDRjtBQUNPO0FBQ2M7QUFDbEI7OztBQUd4Qjs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGtEQUFpQixJQUFJLDJDQUFVO0FBQ25ELHlCQUF5QixpREFBZ0I7QUFDekMsb0JBQW9CLDJDQUFVLENBQUMsaURBQWdCLENBQUMsMkNBQVUsbUJBQW1CLDJDQUFVOztBQUV2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrREFBaUIsU0FBUywyQ0FBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiwyQ0FBVSxTQUFTLDJDQUFVOztBQUU3QyxpQkFBaUIsNkNBQVk7QUFDN0I7QUFDQSxnQkFBZ0Isa0RBQWlCLElBQUksMkNBQVU7QUFDL0M7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsbUVBQWlCO0FBQ2xELG1DQUFtQyxtRUFBaUI7QUFDcEQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWUsQ0FBQyx5Q0FBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIseUNBQVE7QUFDekIsWUFBWSxrREFBaUI7QUFDN0IsaUJBQWlCLDJDQUFVO0FBQzNCLGdCQUFnQiwwQ0FBUztBQUN6QixxQkFBcUIsMkNBQVU7QUFDL0I7QUFDQSxpQkFBaUIsMkNBQVU7QUFDM0IsVUFBVTtBQUNWLGdCQUFnQiwwQ0FBUztBQUN6QixxQkFBcUIsMkNBQVU7QUFDL0I7QUFDQTtBQUNBLHFCQUFxQixpREFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFnQjtBQUNsQyxlQUFlLGdEQUFlO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFXO0FBQzNCLDBCQUEwQixZQUFZO0FBQ3RDLG9CQUFvQiwyQ0FBVSxLQUFLLGlEQUFnQjtBQUNuRDtBQUNBLGdCQUFnQiw0Q0FBVztBQUMzQixVQUFVLE9BQU8sMkNBQVU7QUFDM0IsUUFBUSwrQ0FBYztBQUN0QjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHdEQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGlEQUFnQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBYztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbURBQWtCO0FBQ3ZDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pELGlCQUFpQixtQ0FBbUM7QUFDcEQsaUJBQWlCO0FBQ2pCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixTQUFTO0FBQzlCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixVQUFVO0FBQy9CLGtCQUFrQjtBQUNsQixpQkFBaUIseUNBQXlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEIscURBQVM7QUFDdkMsOEJBQThCLHFEQUFTO0FBQ3ZDLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbURBQWtCO0FBQ3JDLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvd2FzbV9maWVsZDEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgU2NhbGFyIGZyb20gXCIuL3NjYWxhci5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IGdldFRocmVhZFJuZyB9IGZyb20gXCIuL3JhbmRvbS5qc1wiO1xuaW1wb3J0IGJ1aWxkQmF0Y2hDb252ZXJ0IGZyb20gXCIuL2VuZ2luZV9iYXRjaGNvbnZlcnQuanNcIjtcbmltcG9ydCBCaWdCdWZmZXIgZnJvbSBcIi4vYmlnYnVmZmVyLmpzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2FzbUZpZWxkMSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0bSwgcHJlZml4LCBuOCwgcCkge1xuICAgICAgICB0aGlzLnRtID0gdG07XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuXG4gICAgICAgIHRoaXMucCA9IHA7XG4gICAgICAgIHRoaXMubjggPSBuODtcbiAgICAgICAgdGhpcy50eXBlID0gXCJGMVwiO1xuICAgICAgICB0aGlzLm0gPSAxO1xuXG4gICAgICAgIHRoaXMuaGFsZiA9IFNjYWxhci5zaGlmdFJpZ2h0KHAsIFNjYWxhci5vbmUpO1xuICAgICAgICB0aGlzLmJpdExlbmd0aCA9IFNjYWxhci5iaXRMZW5ndGgocCk7XG4gICAgICAgIHRoaXMubWFzayA9IFNjYWxhci5zdWIoU2NhbGFyLnNoaWZ0TGVmdChTY2FsYXIub25lLCB0aGlzLmJpdExlbmd0aCksIFNjYWxhci5vbmUpO1xuXG4gICAgICAgIHRoaXMucE9wMSA9IHRtLmFsbG9jKG44KTtcbiAgICAgICAgdGhpcy5wT3AyID0gdG0uYWxsb2MobjgpO1xuICAgICAgICB0aGlzLnBPcDMgPSB0bS5hbGxvYyhuOCk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1twcmVmaXggKyBcIl96ZXJvXCJdKHRoaXMucE9wMSk7XG4gICAgICAgIHRoaXMuemVybyA9IHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMubjgpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfb25lXCJdKHRoaXMucE9wMSk7XG4gICAgICAgIHRoaXMub25lID0gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5uOCk7XG5cbiAgICAgICAgdGhpcy5uZWdvbmUgPSB0aGlzLm5lZyh0aGlzLm9uZSk7XG4gICAgICAgIHRoaXMudHdvID0gdGhpcy5hZGQodGhpcy5vbmUsIHRoaXMub25lKTtcblxuICAgICAgICB0aGlzLm42NCA9IE1hdGguZmxvb3IobjgvOCk7XG4gICAgICAgIHRoaXMubjMyID0gTWF0aC5mbG9vcihuOC80KTtcblxuICAgICAgICBpZih0aGlzLm42NCo4ICE9IHRoaXMubjgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm44IG11c3QgYmUgYSBtdWx0aXBsZSBvZiA4XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYWxmID0gU2NhbGFyLnNoaWZ0UmlnaHQodGhpcy5wLCBTY2FsYXIub25lKTtcbiAgICAgICAgdGhpcy5ucXIgPSB0aGlzLnR3bztcbiAgICAgICAgbGV0IHIgPSB0aGlzLmV4cCh0aGlzLm5xciwgdGhpcy5oYWxmKTtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmVxKHIsIHRoaXMubmVnb25lKSkge1xuICAgICAgICAgICAgdGhpcy5ucXIgPSB0aGlzLmFkZCh0aGlzLm5xciwgdGhpcy5vbmUpO1xuICAgICAgICAgICAgciA9IHRoaXMuZXhwKHRoaXMubnFyLCB0aGlzLmhhbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaGlmdCA9IHRoaXMubXVsKHRoaXMubnFyLCB0aGlzLm5xcik7XG4gICAgICAgIHRoaXMuc2hpZnRJbnYgPSB0aGlzLmludih0aGlzLnNoaWZ0KTtcblxuICAgICAgICB0aGlzLnMgPSAwO1xuICAgICAgICBsZXQgdCA9IFNjYWxhci5zdWIodGhpcy5wLCBTY2FsYXIub25lKTtcblxuICAgICAgICB3aGlsZSAoICFTY2FsYXIuaXNPZGQodCkgKSB7XG4gICAgICAgICAgICB0aGlzLnMgPSB0aGlzLnMgKyAxO1xuICAgICAgICAgICAgdCA9IFNjYWxhci5zaGlmdFJpZ2h0KHQsIFNjYWxhci5vbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53ID0gW107XG4gICAgICAgIHRoaXMud1t0aGlzLnNdID0gdGhpcy5leHAodGhpcy5ucXIsIHQpO1xuXG4gICAgICAgIGZvciAobGV0IGk9IHRoaXMucy0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMud1tpXSA9IHRoaXMuc3F1YXJlKHRoaXMud1tpKzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5lcSh0aGlzLndbMF0sIHRoaXMub25lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY2FsY3VsYXRpbmcgcm9vdHMgb2YgdW5pdHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJhdGNoVG9Nb250Z29tZXJ5ID0gYnVpbGRCYXRjaENvbnZlcnQodG0sIHByZWZpeCArIFwiX2JhdGNoVG9Nb250Z29tZXJ5XCIsIHRoaXMubjgsIHRoaXMubjgpO1xuICAgICAgICB0aGlzLmJhdGNoRnJvbU1vbnRnb21lcnkgPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hGcm9tTW9udGdvbWVyeVwiLCB0aGlzLm44LCB0aGlzLm44KTtcbiAgICB9XG5cblxuICAgIG9wMihvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgb3AyQm9vbChvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyKTtcbiAgICB9XG5cbiAgICBvcDEob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIG9wMUJvb2wob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICB9XG5cbiAgICBhZGQoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRcIiwgYSwgYik7XG4gICAgfVxuXG5cbiAgICBlcShhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyQm9vbChcIl9lcVwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzWmVyb1wiLCBhKTtcbiAgICB9XG5cbiAgICBzdWIoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9zdWJcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX25lZ1wiLCBhKTtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfaW52ZXJzZVwiLCBhKTtcbiAgICB9XG5cbiAgICB0b01vbnRnb21lcnkoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfdG9Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIGZyb21Nb250Z29tZXJ5KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX2Zyb21Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIG11bChhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX211bFwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2ludmVyc2VcIl0odGhpcy5wT3AyLCB0aGlzLnBPcDIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9tdWxcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfc3F1YXJlXCIsIGEpO1xuICAgIH1cblxuICAgIGlzU3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1NxdWFyZVwiLCBhKTtcbiAgICB9XG5cbiAgICBzcXJ0KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3NxcnRcIiwgYSk7XG4gICAgfVxuXG4gICAgZXhwKGEsIGIpIHtcbiAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBiID0gU2NhbGFyLnRvTEVCdWZmKFNjYWxhci5lKGIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2V4cFwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgYi5ieXRlTGVuZ3RoLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgaXNOZWdhdGl2ZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMUJvb2woXCJfaXNOZWdhdGl2ZVwiLCBhKTtcbiAgICB9XG5cbiAgICBlKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gYTtcbiAgICAgICAgbGV0IHJhID0gU2NhbGFyLmUoYSwgYik7XG4gICAgICAgIGlmIChTY2FsYXIuaXNOZWdhdGl2ZShyYSkpIHtcbiAgICAgICAgICAgIHJhID0gU2NhbGFyLm5lZyhyYSk7XG4gICAgICAgICAgICBpZiAoU2NhbGFyLmd0KHJhLCB0aGlzLnApKSB7XG4gICAgICAgICAgICAgICAgcmEgPSBTY2FsYXIubW9kKHJhLCB0aGlzLnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmEgPSBTY2FsYXIuc3ViKHRoaXMucCwgcmEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFNjYWxhci5ndChyYSwgdGhpcy5wKSkge1xuICAgICAgICAgICAgICAgIHJhID0gU2NhbGFyLm1vZChyYSwgdGhpcy5wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmID0gdXRpbHMubGVJbnQyQnVmZihyYSwgdGhpcy5uOCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvTW9udGdvbWVyeShidWZmKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZyhhLCByYWRpeCkge1xuICAgICAgICBjb25zdCBhbiA9IHRoaXMuZnJvbU1vbnRnb21lcnkoYSk7XG4gICAgICAgIGNvbnN0IHMgPSBTY2FsYXIuZnJvbVJwckxFKGFuLCAwKTtcbiAgICAgICAgcmV0dXJuIFNjYWxhci50b1N0cmluZyhzLCByYWRpeCk7XG4gICAgfVxuXG4gICAgZnJvbVJuZyhybmcpIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLm44KTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdiA9IFNjYWxhci56ZXJvO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMubjY0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2ID0gU2NhbGFyLmFkZCh2LCAgU2NhbGFyLnNoaWZ0TGVmdChybmcubmV4dFU2NCgpLCA2NCppKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ID0gU2NhbGFyLmJhbmQodiwgdGhpcy5tYXNrKTtcbiAgICAgICAgfSB3aGlsZSAoU2NhbGFyLmdlcSh2LCB0aGlzLnApKTtcbiAgICAgICAgU2NhbGFyLnRvUnByTEUoYnVmZiwgMCwgdiwgdGhpcy5uOCk7XG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH1cblxuICAgIHJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVJuZyhnZXRUaHJlYWRSbmcoKSk7XG4gICAgfVxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICBjb25zdCBhbiA9IHRoaXMuZnJvbU1vbnRnb21lcnkoYSk7XG4gICAgICAgIHJldHVybiBTY2FsYXIuZnJvbVJwckxFKGFuLCAwKTtcbiAgICB9XG5cbiAgICBmcm9tT2JqZWN0KGEpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubjgpO1xuICAgICAgICBTY2FsYXIudG9ScHJMRShidWZmLCAwLCBhLCB0aGlzLm44KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Nb250Z29tZXJ5KGJ1ZmYpO1xuICAgIH1cblxuICAgIHRvUnByTEUoYnVmZiwgb2Zmc2V0LCBhKSB7XG4gICAgICAgIGJ1ZmYuc2V0KHRoaXMuZnJvbU1vbnRnb21lcnkoYSksIG9mZnNldCk7XG4gICAgfVxuXG4gICAgdG9ScHJCRShidWZmLCBvZmZzZXQsIGEpIHtcbiAgICAgICAgY29uc3QgYnVmZjIgPSB0aGlzLmZyb21Nb250Z29tZXJ5KGEpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5uOC8yOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF1eCA9IGJ1ZmYyW2ldO1xuICAgICAgICAgICAgYnVmZjJbaV0gPSBidWZmMlt0aGlzLm44LTEtaV07XG4gICAgICAgICAgICBidWZmMlt0aGlzLm44LTEtaV0gPSBhdXg7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZi5zZXQoYnVmZjIsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgZnJvbVJwckxFKGJ1ZmYsIG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZi5zbGljZShvZmZzZXQsIG9mZnNldCArIHRoaXMubjgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b01vbnRnb21lcnkocmVzKTtcbiAgICB9XG5cbiAgICBhc3luYyBiYXRjaEludmVyc2UoYnVmZkluKSB7XG4gICAgICAgIGxldCByZXR1cm5BcnJheSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzSW4gPSB0aGlzLm44O1xuICAgICAgICBjb25zdCBzT3V0ID0gdGhpcy5uODtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmSW4pKSB7XG4gICAgICAgICAgICBidWZmSW4gPSB1dGlscy5hcnJheTJidWZmZXIoYnVmZkluLCBzSW4gKTtcbiAgICAgICAgICAgIHJldHVybkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZJbiA9IGJ1ZmZJbi5zbGljZSgwLCBidWZmSW4uYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuUG9pbnRzID0gTWF0aC5mbG9vcihidWZmSW4uYnl0ZUxlbmd0aCAvIHNJbik7XG4gICAgICAgIGlmICggblBvaW50cyAqIHNJbiAhPT0gYnVmZkluLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnVmZmVyIHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRzUGVyQ2h1bmsgPSBNYXRoLmZsb29yKG5Qb2ludHMvdGhpcy50bS5jb25jdXJyZW5jeSk7XG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMudG0uY29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgdGhpcy50bS5jb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IHBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqcG9pbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDaHVuayA9IGJ1ZmZJbi5zbGljZShpKnBvaW50c1BlckNodW5rKnNJbiwgaSpwb2ludHNQZXJDaHVuaypzSW4gKyBuKnNJbik7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW1xuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOmJ1ZmZDaHVua30sXG4gICAgICAgICAgICAgICAge2NtZDogXCJBTExPQ1wiLCB2YXI6IDEsIGxlbjpzT3V0ICogbn0sXG4gICAgICAgICAgICAgICAge2NtZDogXCJDQUxMXCIsIGZuTmFtZTogdGhpcy5wcmVmaXggKyBcIl9iYXRjaEludmVyc2VcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBzSW59LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IHNPdXR9LFxuICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAxLCBsZW46c091dCAqIG59LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0aGlzLnRtLnF1ZXVlQWN0aW9uKHRhc2spXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgbGV0IGZ1bGxCdWZmT3V0O1xuICAgICAgICBpZiAoYnVmZkluIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dCA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzT3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dC5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVybkFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuYnVmZmVyMmFycmF5KGZ1bGxCdWZmT3V0LCBzT3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdWxsQnVmZk91dDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WasmField2)\n/* harmony export */ });\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./random.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n\n\n\n\nclass WasmField2 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F2\";\n        this.m = F.m * 2;\n        this.n8 = this.F.n8*2;\n        this.n32 = this.F.n32*2;\n        this.n64 = this.F.n64*2;\n\n        this.pOp1 = tm.alloc(F.n8*2);\n        this.pOp2 = tm.alloc(F.n8*2);\n        this.pOp3 = tm.alloc(F.n8*2);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    mul1(a,b) {\n        return this.op2(\"_mul1\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = _scalar_js__WEBPACK_IMPORTED_MODULE_1__.toLEBuff(_scalar_js__WEBPACK_IMPORTED_MODULE_1__.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 2)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const res = new Uint8Array(this.F.n8*2);\n            res.set(c1);\n            res.set(c2, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F2\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8), radix);\n        return `[${s1}, ${s2}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*2);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        return res;\n    }\n\n    random() {\n        return this.fromRng((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.getThreadRng)());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        return [c1, c2];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8);\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy93YXNtX2ZpZWxkMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkM7QUFDTDs7O0FBR3ZCOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixnREFBZSxDQUFDLHlDQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHLElBQUksR0FBRztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHdEQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvbm9kZV9tb2R1bGVzL2ZmamF2YXNjcmlwdC9zcmMvd2FzbV9maWVsZDIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VGhyZWFkUm5nIH0gZnJvbSBcIi4vcmFuZG9tLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2FzbUZpZWxkMiB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0bSwgcHJlZml4LCBGKSB7XG4gICAgICAgIHRoaXMudG0gPSB0bTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG5cbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy50eXBlID0gXCJGMlwiO1xuICAgICAgICB0aGlzLm0gPSBGLm0gKiAyO1xuICAgICAgICB0aGlzLm44ID0gdGhpcy5GLm44KjI7XG4gICAgICAgIHRoaXMubjMyID0gdGhpcy5GLm4zMioyO1xuICAgICAgICB0aGlzLm42NCA9IHRoaXMuRi5uNjQqMjtcblxuICAgICAgICB0aGlzLnBPcDEgPSB0bS5hbGxvYyhGLm44KjIpO1xuICAgICAgICB0aGlzLnBPcDIgPSB0bS5hbGxvYyhGLm44KjIpO1xuICAgICAgICB0aGlzLnBPcDMgPSB0bS5hbGxvYyhGLm44KjIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfemVyb1wiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLnplcm8gPSB0bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5uOCk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1twcmVmaXggKyBcIl9vbmVcIl0odGhpcy5wT3AxKTtcbiAgICAgICAgdGhpcy5vbmUgPSB0bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5uOCk7XG5cbiAgICAgICAgdGhpcy5uZWdvbmUgPSB0aGlzLm5lZyh0aGlzLm9uZSk7XG4gICAgICAgIHRoaXMudHdvID0gdGhpcy5hZGQodGhpcy5vbmUsIHRoaXMub25lKTtcblxuICAgIH1cblxuICAgIG9wMihvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgb3AyQm9vbChvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyKTtcbiAgICB9XG5cbiAgICBvcDEob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIG9wMUJvb2wob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICB9XG5cbiAgICBhZGQoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgZXEoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMkJvb2woXCJfZXFcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgaXNaZXJvKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1plcm9cIiwgYSk7XG4gICAgfVxuXG4gICAgc3ViKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfc3ViXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIG5lZyhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9uZWdcIiwgYSk7XG4gICAgfVxuXG4gICAgaW52KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX2ludmVyc2VcIiwgYSk7XG4gICAgfVxuXG4gICAgaXNOZWdhdGl2ZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMUJvb2woXCJfaXNOZWdhdGl2ZVwiLCBhKTtcbiAgICB9XG5cbiAgICB0b01vbnRnb21lcnkoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfdG9Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIGZyb21Nb250Z29tZXJ5KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX2Zyb21Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIG11bChhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX211bFwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBtdWwxKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfbXVsMVwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2ludmVyc2VcIl0odGhpcy5wT3AyLCB0aGlzLnBPcDIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9tdWxcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfc3F1YXJlXCIsIGEpO1xuICAgIH1cblxuICAgIGlzU3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1NxdWFyZVwiLCBhKTtcbiAgICB9XG5cbiAgICBzcXJ0KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3NxcnRcIiwgYSk7XG4gICAgfVxuXG4gICAgZXhwKGEsIGIpIHtcbiAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBiID0gU2NhbGFyLnRvTEVCdWZmKFNjYWxhci5lKGIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2V4cFwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgYi5ieXRlTGVuZ3RoLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgZShhLCBiKSB7XG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkgcmV0dXJuIGE7XG4gICAgICAgIGlmICgoQXJyYXkuaXNBcnJheShhKSkgJiYgKGEubGVuZ3RoID09IDIpKSB7XG4gICAgICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5lKGFbMF0sIGIpO1xuICAgICAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZShhWzFdLCBiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIHJlcy5zZXQoYzEpO1xuICAgICAgICAgICAgcmVzLnNldChjMiwgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgRjJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZyhhLCByYWRpeCkge1xuICAgICAgICBjb25zdCBzMSA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKDAsIHRoaXMuRi5uOCksIHJhZGl4KTtcbiAgICAgICAgY29uc3QgczIgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSh0aGlzLkYubjgpLCByYWRpeCk7XG4gICAgICAgIHJldHVybiBgWyR7czF9LCAke3MyfV1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMik7XG4gICAgICAgIHJlcy5zZXQoYzEpO1xuICAgICAgICByZXMuc2V0KGMyLCB0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVJuZyhnZXRUaHJlYWRSbmcoKSk7XG4gICAgfVxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKDAsIHRoaXMuRi5uOCkpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpKTtcbiAgICAgICAgcmV0dXJuIFtjMSwgYzJdO1xuICAgIH1cblxuICAgIGZyb21PYmplY3QoYSkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjIpO1xuICAgICAgICBjb25zdCBiMSA9IHRoaXMuRi5mcm9tT2JqZWN0KGFbMF0pO1xuICAgICAgICBjb25zdCBiMiA9IHRoaXMuRi5mcm9tT2JqZWN0KGFbMV0pO1xuICAgICAgICBidWZmLnNldChiMSk7XG4gICAgICAgIGJ1ZmYuc2V0KGIyLCB0aGlzLkYubjgpO1xuICAgICAgICByZXR1cm4gYnVmZjtcbiAgICB9XG5cbiAgICBjMShhKSB7XG4gICAgICAgIHJldHVybiBhLnNsaWNlKDAsIHRoaXMuRi5uOCk7XG4gICAgfVxuXG4gICAgYzIoYSkge1xuICAgICAgICByZXR1cm4gYS5zbGljZSh0aGlzLkYubjgpO1xuICAgIH1cblxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field3.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field3.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WasmField3)\n/* harmony export */ });\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./random.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/random.js\");\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/scalar.js\");\n\n\n\n\n\n\nclass WasmField3 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F3\";\n        this.m = F.m * 3;\n        this.n8 = this.F.n8*3;\n        this.n32 = this.F.n32*3;\n        this.n64 = this.F.n64*3;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = _scalar_js__WEBPACK_IMPORTED_MODULE_1__.toLEBuff(_scalar_js__WEBPACK_IMPORTED_MODULE_1__.e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 3)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const c3 = this.F.e(a[2], b);\n            const res = new Uint8Array(this.F.n8*3);\n            res.set(c1);\n            res.set(c2, this.F.n8);\n            res.set(c3, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F3\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n        const s3 = this.F.toString(a.slice(this.F.n8*2), radix);\n        return `[${s1}, ${s2}, ${s3}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const c3 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*3);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        res.set(c3, this.F.n8*2);\n        return res;\n    }\n\n    random() {\n        return this.fromRng((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.getThreadRng)());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        const c3 = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        return [c1, c2, c3];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*3);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        const b3 = this.F.fromObject(a[2]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        buff.set(b3, this.F.n8*2);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8, this.F.n8*2);\n    }\n\n    c3(a) {\n        return a.slice(this.F.n8*2);\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy93YXNtX2ZpZWxkMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUUyQztBQUNMOzs7QUFHdkI7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFlLENBQUMseUNBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qix3REFBWTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L3NyYy93YXNtX2ZpZWxkMy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0IHsgZ2V0VGhyZWFkUm5nIH0gZnJvbSBcIi4vcmFuZG9tLmpzXCI7XG5pbXBvcnQgKiBhcyBTY2FsYXIgZnJvbSBcIi4vc2NhbGFyLmpzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2FzbUZpZWxkMyB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0bSwgcHJlZml4LCBGKSB7XG4gICAgICAgIHRoaXMudG0gPSB0bTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG5cbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy50eXBlID0gXCJGM1wiO1xuICAgICAgICB0aGlzLm0gPSBGLm0gKiAzO1xuICAgICAgICB0aGlzLm44ID0gdGhpcy5GLm44KjM7XG4gICAgICAgIHRoaXMubjMyID0gdGhpcy5GLm4zMiozO1xuICAgICAgICB0aGlzLm42NCA9IHRoaXMuRi5uNjQqMztcblxuICAgICAgICB0aGlzLnBPcDEgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnBPcDIgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnBPcDMgPSB0bS5hbGxvYyhGLm44KjMpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfemVyb1wiXSh0aGlzLnBPcDEpO1xuICAgICAgICB0aGlzLnplcm8gPSB0bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5uOCk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1twcmVmaXggKyBcIl9vbmVcIl0odGhpcy5wT3AxKTtcbiAgICAgICAgdGhpcy5vbmUgPSB0bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5uOCk7XG5cbiAgICAgICAgdGhpcy5uZWdvbmUgPSB0aGlzLm5lZyh0aGlzLm9uZSk7XG4gICAgICAgIHRoaXMudHdvID0gdGhpcy5hZGQodGhpcy5vbmUsIHRoaXMub25lKTtcblxuICAgIH1cblxuICAgIG9wMihvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgb3AyQm9vbChvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyKTtcbiAgICB9XG5cbiAgICBvcDEob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIG9wMUJvb2wob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICB9XG5cblxuICAgIGVxKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDJCb29sKFwiX2VxXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIGlzWmVybyhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMUJvb2woXCJfaXNaZXJvXCIsIGEpO1xuICAgIH1cblxuICAgIGFkZChhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX2FkZFwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBzdWIoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9zdWJcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX25lZ1wiLCBhKTtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfaW52ZXJzZVwiLCBhKTtcbiAgICB9XG5cbiAgICBpc05lZ2F0aXZlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc05lZ2F0aXZlXCIsIGEpO1xuICAgIH1cblxuICAgIHRvTW9udGdvbWVyeShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl90b01vbnRnb21lcnlcIiwgYSk7XG4gICAgfVxuXG4gICAgZnJvbU1vbnRnb21lcnkoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfZnJvbU1vbnRnb21lcnlcIiwgYSk7XG4gICAgfVxuXG4gICAgbXVsKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfbXVsXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIGRpdihhLCBiKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfaW52ZXJzZVwiXSh0aGlzLnBPcDIsIHRoaXMucE9wMik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX211bFwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIHNxdWFyZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9zcXVhcmVcIiwgYSk7XG4gICAgfVxuXG4gICAgaXNTcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzU3F1YXJlXCIsIGEpO1xuICAgIH1cblxuICAgIHNxcnQoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfc3FydFwiLCBhKTtcbiAgICB9XG5cbiAgICBleHAoYSwgYikge1xuICAgICAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgIGIgPSBTY2FsYXIudG9MRUJ1ZmYoU2NhbGFyLmUoYikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfZXhwXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCBiLmJ5dGVMZW5ndGgsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBlKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gYTtcbiAgICAgICAgaWYgKChBcnJheS5pc0FycmF5KGEpKSAmJiAoYS5sZW5ndGggPT0gMykpIHtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmUoYVswXSwgYik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5lKGFbMV0sIGIpO1xuICAgICAgICAgICAgY29uc3QgYzMgPSB0aGlzLkYuZShhWzJdLCBiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCozKTtcbiAgICAgICAgICAgIHJlcy5zZXQoYzEpO1xuICAgICAgICAgICAgcmVzLnNldChjMiwgdGhpcy5GLm44KTtcbiAgICAgICAgICAgIHJlcy5zZXQoYzMsIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEYzXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoYSwgcmFkaXgpIHtcbiAgICAgICAgY29uc3QgczEgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSgwLCB0aGlzLkYubjgpLCByYWRpeCk7XG4gICAgICAgIGNvbnN0IHMyID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UodGhpcy5GLm44LCB0aGlzLkYubjgqMiksIHJhZGl4KTtcbiAgICAgICAgY29uc3QgczMgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSh0aGlzLkYubjgqMiksIHJhZGl4KTtcbiAgICAgICAgcmV0dXJuIGBbJHtzMX0sICR7czJ9LCAke3MzfV1gO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCBjMyA9IHRoaXMuRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCozKTtcbiAgICAgICAgcmVzLnNldChjMSk7XG4gICAgICAgIHJlcy5zZXQoYzIsIHRoaXMuRi5uOCk7XG4gICAgICAgIHJlcy5zZXQoYzMsIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICByYW5kb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21SbmcoZ2V0VGhyZWFkUm5nKCkpO1xuICAgIH1cblxuICAgIHRvT2JqZWN0KGEpIHtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYudG9PYmplY3QoYS5zbGljZSgwLCB0aGlzLkYubjgpKTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYudG9PYmplY3QoYS5zbGljZSh0aGlzLkYubjgsIHRoaXMuRi5uOCoyKSk7XG4gICAgICAgIGNvbnN0IGMzID0gdGhpcy5GLnRvT2JqZWN0KGEuc2xpY2UodGhpcy5GLm44KjIsIHRoaXMuRi5uOCozKSk7XG4gICAgICAgIHJldHVybiBbYzEsIGMyLCBjM107XG4gICAgfVxuXG4gICAgZnJvbU9iamVjdChhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMyk7XG4gICAgICAgIGNvbnN0IGIxID0gdGhpcy5GLmZyb21PYmplY3QoYVswXSk7XG4gICAgICAgIGNvbnN0IGIyID0gdGhpcy5GLmZyb21PYmplY3QoYVsxXSk7XG4gICAgICAgIGNvbnN0IGIzID0gdGhpcy5GLmZyb21PYmplY3QoYVsyXSk7XG4gICAgICAgIGJ1ZmYuc2V0KGIxKTtcbiAgICAgICAgYnVmZi5zZXQoYjIsIHRoaXMuRi5uOCk7XG4gICAgICAgIGJ1ZmYuc2V0KGIzLCB0aGlzLkYubjgqMik7XG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH1cblxuICAgIGMxKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuc2xpY2UoMCwgdGhpcy5GLm44KTtcbiAgICB9XG5cbiAgICBjMihhKSB7XG4gICAgICAgIHJldHVybiBhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpO1xuICAgIH1cblxuICAgIGMzKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuc2xpY2UodGhpcy5GLm44KjIpO1xuICAgIH1cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/src/wasm_field3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/Keccak256Transcript.js":
/*!*********************************************************!*\
  !*** ./node_modules/snarkjs/src/Keccak256Transcript.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak256Transcript: () => (/* binding */ Keccak256Transcript)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst POLYNOMIAL = 0;\nconst SCALAR = 1;\n\nclass Keccak256Transcript {\n    constructor(curve) {\n        this.G1 = curve.G1;\n        this.Fr = curve.Fr;\n\n        this.reset();\n    }\n\n    reset() {\n        this.data = [];\n    }\n\n    addPolCommitment(polynomialCommitment) {\n        this.data.push({type: POLYNOMIAL, data: polynomialCommitment});\n    }\n\n    addScalar(scalar) {\n        this.data.push({type: SCALAR, data: scalar});\n    }\n\n    getChallenge() {\n        if(0 === this.data.length) {\n            throw new Error(\"Keccak256Transcript: No data to generate a transcript\");\n        }\n\n        let nPolynomials = 0;\n        let nScalars = 0;\n\n        this.data.forEach(element => POLYNOMIAL === element.type ? nPolynomials++ : nScalars++);\n\n        let buffer = new Uint8Array(nScalars * this.Fr.n8 + nPolynomials * this.G1.F.n8 * 2);\n        let offset = 0;\n\n        for (let i = 0; i < this.data.length; i++) {\n            if (POLYNOMIAL === this.data[i].type) {\n                this.G1.toRprUncompressed(buffer, offset, this.data[i].data);\n                offset += this.G1.F.n8 * 2;\n            } else {\n                this.Fr.toRprBE(buffer, offset, this.data[i].data);\n                offset += this.Fr.n8;\n            }\n        }\n\n        const value = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprBE((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_1__.keccak_256)(buffer));\n        return this.Fr.e(value);\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvS2VjY2FrMjU2VHJhbnNjcmlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvQztBQUNVOztBQUU5QztBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDZDQUE2QztBQUNyRTs7QUFFQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnREFBTSxXQUFXLDhEQUFVO0FBQ2pEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9LZWNjYWsyNTZUcmFuc2NyaXB0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7U2NhbGFyfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQge2tlY2Nha18yNTZ9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTNcIjtcblxuY29uc3QgUE9MWU5PTUlBTCA9IDA7XG5jb25zdCBTQ0FMQVIgPSAxO1xuXG5leHBvcnQgY2xhc3MgS2VjY2FrMjU2VHJhbnNjcmlwdCB7XG4gICAgY29uc3RydWN0b3IoY3VydmUpIHtcbiAgICAgICAgdGhpcy5HMSA9IGN1cnZlLkcxO1xuICAgICAgICB0aGlzLkZyID0gY3VydmUuRnI7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG5cbiAgICBhZGRQb2xDb21taXRtZW50KHBvbHlub21pYWxDb21taXRtZW50KSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKHt0eXBlOiBQT0xZTk9NSUFMLCBkYXRhOiBwb2x5bm9taWFsQ29tbWl0bWVudH0pO1xuICAgIH1cblxuICAgIGFkZFNjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2goe3R5cGU6IFNDQUxBUiwgZGF0YTogc2NhbGFyfSk7XG4gICAgfVxuXG4gICAgZ2V0Q2hhbGxlbmdlKCkge1xuICAgICAgICBpZigwID09PSB0aGlzLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZWNjYWsyNTZUcmFuc2NyaXB0OiBObyBkYXRhIHRvIGdlbmVyYXRlIGEgdHJhbnNjcmlwdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuUG9seW5vbWlhbHMgPSAwO1xuICAgICAgICBsZXQgblNjYWxhcnMgPSAwO1xuXG4gICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGVsZW1lbnQgPT4gUE9MWU5PTUlBTCA9PT0gZWxlbWVudC50eXBlID8gblBvbHlub21pYWxzKysgOiBuU2NhbGFycysrKTtcblxuICAgICAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoblNjYWxhcnMgKiB0aGlzLkZyLm44ICsgblBvbHlub21pYWxzICogdGhpcy5HMS5GLm44ICogMik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoUE9MWU5PTUlBTCA9PT0gdGhpcy5kYXRhW2ldLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkcxLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmZlciwgb2Zmc2V0LCB0aGlzLmRhdGFbaV0uZGF0YSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuRzEuRi5uOCAqIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuRnIudG9ScHJCRShidWZmZXIsIG9mZnNldCwgdGhpcy5kYXRhW2ldLmRhdGEpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLkZyLm44O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBTY2FsYXIuZnJvbVJwckJFKGtlY2Nha18yNTYoYnVmZmVyKSk7XG4gICAgICAgIHJldHVybiB0aGlzLkZyLmUodmFsdWUpO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/Keccak256Transcript.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/bigarray.js":
/*!**********************************************!*\
  !*** ./node_modules/snarkjs/src/bigarray.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BigArray);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvYmlnYXJyYXkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9iaWdhcnJheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCBTVUJBUlJBWV9TSVpFID0gMHg0MDAwMDtcblxuY29uc3QgQmlnQXJyYXlIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gICAgICAgIGlmICghaXNOYU4ocHJvcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouZ2V0RWxlbWVudChwcm9wKTtcbiAgICAgICAgfSBlbHNlIHJldHVybiBvYmpbcHJvcF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05hTihwcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5zZXRFbGVtZW50KHByb3AsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jbGFzcyBfQmlnQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yIChpbml0U2l6ZSkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGluaXRTaXplIHx8IDA7XG4gICAgICAgIHRoaXMuYXJyID0gbmV3IEFycmF5KFNVQkFSUkFZX1NJWkUpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxpbml0U2l6ZTsgaSs9U1VCQVJSQVlfU0laRSkge1xuICAgICAgICAgICAgdGhpcy5hcnJbaS9TVUJBUlJBWV9TSVpFXSA9IG5ldyBBcnJheShNYXRoLm1pbihTVUJBUlJBWV9TSVpFLCBpbml0U2l6ZSAtIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHVzaCAoKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudCAodGhpcy5sZW5ndGgsIGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzbGljZSAoZiwgdCkge1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkodC1mKTtcbiAgICAgICAgZm9yIChsZXQgaT1mOyBpPCB0OyBpKyspIGFycltpLWZdID0gdGhpcy5nZXRFbGVtZW50KGkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBnZXRFbGVtZW50KGlkeCkge1xuICAgICAgICBpZHggPSBwYXJzZUludChpZHgpO1xuICAgICAgICBjb25zdCBpZHgxID0gTWF0aC5mbG9vcihpZHggLyBTVUJBUlJBWV9TSVpFKTtcbiAgICAgICAgY29uc3QgaWR4MiA9IGlkeCAlIFNVQkFSUkFZX1NJWkU7XG4gICAgICAgIHJldHVybiB0aGlzLmFycltpZHgxXSA/IHRoaXMuYXJyW2lkeDFdW2lkeDJdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXRFbGVtZW50KGlkeCwgdmFsdWUpIHtcbiAgICAgICAgaWR4ID0gcGFyc2VJbnQoaWR4KTtcbiAgICAgICAgY29uc3QgaWR4MSA9IE1hdGguZmxvb3IoaWR4IC8gU1VCQVJSQVlfU0laRSk7XG4gICAgICAgIGlmICghdGhpcy5hcnJbaWR4MV0pIHtcbiAgICAgICAgICAgIHRoaXMuYXJyW2lkeDFdID0gbmV3IEFycmF5KFNVQkFSUkFZX1NJWkUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkeDIgPSBpZHggJSBTVUJBUlJBWV9TSVpFO1xuICAgICAgICB0aGlzLmFycltpZHgxXVtpZHgyXSA9IHZhbHVlO1xuICAgICAgICBpZiAoaWR4ID49IHRoaXMubGVuZ3RoKSB0aGlzLmxlbmd0aCA9IGlkeCsxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgY29uc3QgbmV3QSA9IG5ldyBCaWdBcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5hcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFycltpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajx0aGlzLmFycltpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuYXJyW2ldW2pdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdBLnB1c2goaSpTVUJBUlJBWV9TSVpFK2opO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdBO1xuICAgIH1cbn1cblxuY2xhc3MgQmlnQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKCBpbml0U2l6ZSApIHtcbiAgICAgICAgY29uc3Qgb2JqID0gbmV3IF9CaWdBcnJheShpbml0U2l6ZSk7XG4gICAgICAgIGNvbnN0IGV4dE9iaiA9IG5ldyBQcm94eShvYmosIEJpZ0FycmF5SGFuZGxlcik7XG4gICAgICAgIHJldHVybiBleHRPYmo7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCaWdBcnJheTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/bigarray.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/curves.js":
/*!********************************************!*\
  !*** ./node_modules/snarkjs/src/curves.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurveFromName: () => (/* binding */ getCurveFromName),\n/* harmony export */   getCurveFromQ: () => (/* binding */ getCurveFromQ),\n/* harmony export */   getCurveFromR: () => (/* binding */ getCurveFromR)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n\n\nconst bls12381r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nasync function getCurveFromR(r, options) {\n    let curve;\n    // check that options param is defined and that options.singleThread is defined\n    let singleThread = options && options.singleThread;\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(r, bn128r)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(r, bls12381r)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromQ(q, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(q, bn128q)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(q, bls12381q)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(q)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromName(name, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvY3VydmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0U7O0FBRWhFLGtCQUFrQixnREFBTTtBQUN4QixlQUFlLGdEQUFNOztBQUVyQixrQkFBa0IsZ0RBQU07QUFDeEIsZUFBZSxnREFBTTs7QUFFZDtBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQU07QUFDZCxzQkFBc0Isd0RBQVU7QUFDaEMsTUFBTSxTQUFTLGdEQUFNO0FBQ3JCLHNCQUFzQiwyREFBYTtBQUNuQyxNQUFNO0FBQ04sZ0RBQWdELGdEQUFNLGFBQWE7QUFDbkU7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLFFBQVEsZ0RBQU07QUFDZCxzQkFBc0Isd0RBQVU7QUFDaEMsTUFBTSxTQUFTLGdEQUFNO0FBQ3JCLHNCQUFzQiwyREFBYTtBQUNuQyxNQUFNO0FBQ04sZ0RBQWdELGdEQUFNLGFBQWE7QUFDbkU7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQVU7QUFDaEMsTUFBTTtBQUNOLHNCQUFzQiwyREFBYTtBQUNuQyxNQUFNO0FBQ04sZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvY3VydmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNjYWxhciwgYnVpbGRCbjEyOCwgYnVpbGRCbHMxMjM4MX0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5jb25zdCBibHMxMjM4MXIgPSBTY2FsYXIuZShcIjczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDFcIiwgMTYpO1xuY29uc3QgYm4xMjhyID0gU2NhbGFyLmUoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODU0ODM2NDQwMDQxNjAzNDM0MzY5ODIwNDE4NjU3NTgwODQ5NTYxN1wiKTtcblxuY29uc3QgYmxzMTIzODFxID0gU2NhbGFyLmUoXCIxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJcIiwgMTYpO1xuY29uc3QgYm4xMjhxID0gU2NhbGFyLmUoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODY5NjMxMTE1NzI5NzgyMzY2MjY4OTAzNzg5NDY0NTIyNjIwODU4M1wiKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnZlRnJvbVIociwgb3B0aW9ucykge1xuICAgIGxldCBjdXJ2ZTtcbiAgICAvLyBjaGVjayB0aGF0IG9wdGlvbnMgcGFyYW0gaXMgZGVmaW5lZCBhbmQgdGhhdCBvcHRpb25zLnNpbmdsZVRocmVhZCBpcyBkZWZpbmVkXG4gICAgbGV0IHNpbmdsZVRocmVhZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaW5nbGVUaHJlYWQ7XG4gICAgaWYgKFNjYWxhci5lcShyLCBibjEyOHIpKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbjEyOChzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSBpZiAoU2NhbGFyLmVxKHIsIGJsczEyMzgxcikpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke1NjYWxhci50b1N0cmluZyhyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VydmVGcm9tUShxLCBvcHRpb25zKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIGxldCBzaW5nbGVUaHJlYWQgPSBvcHRpb25zICYmIG9wdGlvbnMuc2luZ2xlVGhyZWFkO1xuICAgIGlmIChTY2FsYXIuZXEocSwgYm4xMjhxKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQm4xMjgoc2luZ2xlVGhyZWFkKTtcbiAgICB9IGVsc2UgaWYgKFNjYWxhci5lcShxLCBibHMxMjM4MXEpKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbHMxMjM4MShzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3VydmUgbm90IHN1cHBvcnRlZDogJHtTY2FsYXIudG9TdHJpbmcocSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2ZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnZlRnJvbU5hbWUobmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBjdXJ2ZTtcbiAgICBsZXQgc2luZ2xlVGhyZWFkID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpbmdsZVRocmVhZDtcbiAgICBjb25zdCBub3JtTmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgaWYgKFtcIkJOMTI4XCIsIFwiQk4yNTRcIiwgXCJBTFRCTjEyOFwiXS5pbmRleE9mKG5vcm1OYW1lKSA+PSAwKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbjEyOChzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSBpZiAoW1wiQkxTMTIzODFcIl0uaW5kZXhPZihub3JtTmFtZSkgPj0gMCkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQmxzMTIzODEoc2luZ2xlVGhyZWFkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN1cnZlIG5vdCBzdXBwb3J0ZWQ6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuKSB7XG4gICAgICAgIHJldHVybiBuLnRvVXBwZXJDYXNlKCkubWF0Y2goL1tBLVphLXowLTldKy9nKS5qb2luKFwiXCIpO1xuICAgIH1cblxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/curves.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/fflonk.js":
/*!********************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _fflonk_export_calldata_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   exportSolidityVerifier: () => (/* reexport safe */ _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _fflonk_full_prove_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   setup: () => (/* reexport safe */ _fflonk_setup_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _fflonk_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _fflonk_setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fflonk_setup.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk_setup.js\");\n/* harmony import */ var _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fflonk_prove.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk_prove.js\");\n/* harmony import */ var _fflonk_full_prove_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fflonk_full_prove.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk_full_prove.js\");\n/* harmony import */ var _fflonk_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fflonk_verify.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk_verify.js\");\n/* harmony import */ var _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fflonk_export_solidity_verifier.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\");\n/* harmony import */ var _fflonk_export_calldata_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_export_calldata.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk_export_calldata.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFEO0FBQ0E7QUFDUztBQUNQO0FBQ2tDO0FBQ1QiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgc2V0dXAgfSBmcm9tIFwiLi9mZmxvbmtfc2V0dXAuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJvdmUgfSBmcm9tIFwiLi9mZmxvbmtfcHJvdmUuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZnVsbFByb3ZlIH0gZnJvbSBcIi4vZmZsb25rX2Z1bGxfcHJvdmUuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyaWZ5IH0gZnJvbSBcIi4vZmZsb25rX3ZlcmlmeS5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBleHBvcnRTb2xpZGl0eVZlcmlmaWVyIH0gZnJvbSBcIi4vZmZsb25rX2V4cG9ydF9zb2xpZGl0eV92ZXJpZmllci5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBleHBvcnRTb2xpZGl0eUNhbGxEYXRhIH0gZnJvbSBcIi4vZmZsb25rX2V4cG9ydF9jYWxsZGF0YS5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/fflonk.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/fflonk_constants.js":
/*!******************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ A),\n/* harmony export */   FF_T_POL_DEG_MIN: () => (/* binding */ FF_T_POL_DEG_MIN),\n/* harmony export */   ZKEY_FF_ADDITIONS_SECTION: () => (/* binding */ ZKEY_FF_ADDITIONS_SECTION),\n/* harmony export */   ZKEY_FF_A_MAP_SECTION: () => (/* binding */ ZKEY_FF_A_MAP_SECTION),\n/* harmony export */   ZKEY_FF_B_MAP_SECTION: () => (/* binding */ ZKEY_FF_B_MAP_SECTION),\n/* harmony export */   ZKEY_FF_C0_SECTION: () => (/* binding */ ZKEY_FF_C0_SECTION),\n/* harmony export */   ZKEY_FF_C_MAP_SECTION: () => (/* binding */ ZKEY_FF_C_MAP_SECTION),\n/* harmony export */   ZKEY_FF_HEADER_SECTION: () => (/* binding */ ZKEY_FF_HEADER_SECTION),\n/* harmony export */   ZKEY_FF_LAGRANGE_SECTION: () => (/* binding */ ZKEY_FF_LAGRANGE_SECTION),\n/* harmony export */   ZKEY_FF_NSECTIONS: () => (/* binding */ ZKEY_FF_NSECTIONS),\n/* harmony export */   ZKEY_FF_PTAU_SECTION: () => (/* binding */ ZKEY_FF_PTAU_SECTION),\n/* harmony export */   ZKEY_FF_QC_SECTION: () => (/* binding */ ZKEY_FF_QC_SECTION),\n/* harmony export */   ZKEY_FF_QL_SECTION: () => (/* binding */ ZKEY_FF_QL_SECTION),\n/* harmony export */   ZKEY_FF_QM_SECTION: () => (/* binding */ ZKEY_FF_QM_SECTION),\n/* harmony export */   ZKEY_FF_QO_SECTION: () => (/* binding */ ZKEY_FF_QO_SECTION),\n/* harmony export */   ZKEY_FF_QR_SECTION: () => (/* binding */ ZKEY_FF_QR_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA1_SECTION: () => (/* binding */ ZKEY_FF_SIGMA1_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA2_SECTION: () => (/* binding */ ZKEY_FF_SIGMA2_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA3_SECTION: () => (/* binding */ ZKEY_FF_SIGMA3_SECTION)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// FFlonk constants\nconst FF_T_POL_DEG_MIN = 3;\n\n// FFlonk A\nconst A = 12;\n\n// ZKEY constants\nconst ZKEY_FF_NSECTIONS = 17;\n\nconst ZKEY_FF_HEADER_SECTION = 2;\nconst ZKEY_FF_ADDITIONS_SECTION = 3;\nconst ZKEY_FF_A_MAP_SECTION = 4;\nconst ZKEY_FF_B_MAP_SECTION = 5;\nconst ZKEY_FF_C_MAP_SECTION = 6;\nconst ZKEY_FF_QL_SECTION = 7;\nconst ZKEY_FF_QR_SECTION = 8;\nconst ZKEY_FF_QM_SECTION = 9;\nconst ZKEY_FF_QO_SECTION = 10;\nconst ZKEY_FF_QC_SECTION = 11;\nconst ZKEY_FF_SIGMA1_SECTION = 12;\nconst ZKEY_FF_SIGMA2_SECTION = 13;\nconst ZKEY_FF_SIGMA3_SECTION = 14;\nconst ZKEY_FF_LAGRANGE_SECTION = 15;\nconst ZKEY_FF_PTAU_SECTION = 16;\nconst ZKEY_FF_C0_SECTION = 17;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPOztBQUVQO0FBQ087O0FBRVA7QUFDTzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIEZGbG9uayBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBGRl9UX1BPTF9ERUdfTUlOID0gMztcblxuLy8gRkZsb25rIEFcbmV4cG9ydCBjb25zdCBBID0gMTI7XG5cbi8vIFpLRVkgY29uc3RhbnRzXG5leHBvcnQgY29uc3QgWktFWV9GRl9OU0VDVElPTlMgPSAxNztcblxuZXhwb3J0IGNvbnN0IFpLRVlfRkZfSEVBREVSX1NFQ1RJT04gPSAyO1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfQURESVRJT05TX1NFQ1RJT04gPSAzO1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfQV9NQVBfU0VDVElPTiA9IDQ7XG5leHBvcnQgY29uc3QgWktFWV9GRl9CX01BUF9TRUNUSU9OID0gNTtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX0NfTUFQX1NFQ1RJT04gPSA2O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfUUxfU0VDVElPTiA9IDc7XG5leHBvcnQgY29uc3QgWktFWV9GRl9RUl9TRUNUSU9OID0gODtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX1FNX1NFQ1RJT04gPSA5O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfUU9fU0VDVElPTiA9IDEwO1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfUUNfU0VDVElPTiA9IDExO1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfU0lHTUExX1NFQ1RJT04gPSAxMjtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX1NJR01BMl9TRUNUSU9OID0gMTM7XG5leHBvcnQgY29uc3QgWktFWV9GRl9TSUdNQTNfU0VDVElPTiA9IDE0O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfTEFHUkFOR0VfU0VDVElPTiA9IDE1O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfUFRBVV9TRUNUSU9OID0gMTY7XG5leHBvcnQgY29uc3QgWktFWV9GRl9DMF9TRUNUSU9OID0gMTc7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/fflonk_constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/fflonk_export_calldata.js":
/*!************************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_export_calldata.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkExportCallData)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\" + nstr;\n    nstr = `0x${nstr}`;\n    return nstr;\n}\n\nasync function fflonkExportCallData(_pub, _proof) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName)(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i = 0; i < pub.length; i++) {\n        if (inputs !== \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.polynomials.C1[0])}, ${p256(proof.polynomials.C1[1])},` +\n    `${p256(proof.polynomials.C2[0])},${p256(proof.polynomials.C2[1])},` +\n    `${p256(proof.polynomials.W1[0])},${p256(proof.polynomials.W1[1])},` +\n    `${p256(proof.polynomials.W2[0])},${p256(proof.polynomials.W2[1])},` +\n    `${p256(proof.evaluations.ql)},${p256(proof.evaluations.qr)},${p256(proof.evaluations.qm)},` +\n    `${p256(proof.evaluations.qo)},${p256(proof.evaluations.qc)},${p256(proof.evaluations.s1)},` +\n    `${p256(proof.evaluations.s2)},${p256(proof.evaluations.s3)},${p256(proof.evaluations.a)},` +\n    `${p256(proof.evaluations.b)},${p256(proof.evaluations.c)},${p256(proof.evaluations.z)},` +\n    `${p256(proof.evaluations.zw)},${p256(proof.evaluations.t1w)},${p256(proof.evaluations.t2w)},` +\n    `${p256(proof.evaluations.inv)}],` +\n    `[${inputs}]`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9jYWxsZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU2QztBQUNWOztBQUVuQyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7O0FBRUEsd0JBQXdCLDREQUFnQjtBQUN4QztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUEsZUFBZSw4QkFBOEIsSUFBSSw4QkFBOEI7QUFDL0UsT0FBTyw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDdEUsT0FBTyw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDdEUsT0FBTyw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDdEUsT0FBTywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkI7QUFDOUYsT0FBTywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkI7QUFDOUYsT0FBTywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRywwQkFBMEI7QUFDN0YsT0FBTywwQkFBMEIsR0FBRywwQkFBMEIsR0FBRywwQkFBMEI7QUFDM0YsT0FBTywyQkFBMkIsR0FBRyw0QkFBNEIsR0FBRyw0QkFBNEI7QUFDaEcsT0FBTyw0QkFBNEI7QUFDbkMsUUFBUSxPQUFPO0FBQ2YiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9jYWxsZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQge2dldEN1cnZlRnJvbU5hbWV9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHt1dGlsc30gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5mdW5jdGlvbiBpMmhleChpKSB7XG4gICAgcmV0dXJuIChcIjBcIiArIGkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG59XG5cbmZ1bmN0aW9uIHAyNTYobikge1xuICAgIGxldCBuc3RyID0gbi50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKG5zdHIubGVuZ3RoIDwgNjQpIG5zdHIgPSBcIjBcIiArIG5zdHI7XG4gICAgbnN0ciA9IGAweCR7bnN0cn1gO1xuICAgIHJldHVybiBuc3RyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmZmxvbmtFeHBvcnRDYWxsRGF0YShfcHViLCBfcHJvb2YpIHtcbiAgICBjb25zdCBwcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpO1xuICAgIGNvbnN0IHB1YiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHViKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tTmFtZShwcm9vZi5jdXJ2ZSk7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IGlucHV0cyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlucHV0cyAhPT0gXCJcIikgaW5wdXRzID0gaW5wdXRzICsgXCIsXCI7XG4gICAgICAgIGlucHV0cyA9IGlucHV0cyArIHAyNTYocHViW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYFske3AyNTYocHJvb2YucG9seW5vbWlhbHMuQzFbMF0pfSwgJHtwMjU2KHByb29mLnBvbHlub21pYWxzLkMxWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5DMlswXSl9LCR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5DMlsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YucG9seW5vbWlhbHMuVzFbMF0pfSwke3AyNTYocHJvb2YucG9seW5vbWlhbHMuVzFbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLnBvbHlub21pYWxzLlcyWzBdKX0sJHtwMjU2KHByb29mLnBvbHlub21pYWxzLlcyWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5xbCl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5xcil9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5xbSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMucW8pfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMucWMpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuczEpfSxgICtcbiAgICBgJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnMyKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnMzKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLmEpfSxgICtcbiAgICBgJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLmIpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuYyl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy56KX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy56dyl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy50MXcpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMudDJ3KX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5pbnYpfV0sYCArXG4gICAgYFske2lucHV0c31dYDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/fflonk_export_calldata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/fflonk_export_solidity_verifier.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_export_solidity_verifier.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkExportSolidityVerifier)\n/* harmony export */ });\n/* harmony import */ var ejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ejs */ \"(ssr)/./node_modules/ejs/lib/ejs.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nconst {unstringifyBigInts, stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function fflonkExportSolidityVerifier(vk, templates, logger) {\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER STARTED\");\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_1__.getCurveFromName)(vk.curve);\n\n    // Precompute w3_2, w4_2 and w4_3\n    let w3 = fromVkey(vk.w3);\n    vk.w3_2 = toVkey(curve.Fr.square(w3));\n\n    let w4 = fromVkey(vk.w4);\n    vk.w4_2 = toVkey(curve.Fr.square(w4));\n    vk.w4_3 = toVkey(curve.Fr.mul(curve.Fr.square(w4), w4));\n\n    let w8 = fromVkey(vk.w8);\n    let acc = curve.Fr.one;\n\n    for (let i = 1; i < 8; i++) {\n        acc = curve.Fr.mul(acc, w8);\n        vk[\"w8_\" + i] = toVkey(acc);\n    }\n\n    let template = templates[vk.protocol];\n\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER FINISHED\");\n\n    return ejs__WEBPACK_IMPORTED_MODULE_0__.render(template, vk);\n\n    function fromVkey(str) {\n        const val = unstringifyBigInts(str);\n        return curve.Fr.fromObject(val);\n    }\n\n    function toVkey(val) {\n        const str = curve.Fr.toObject(val);\n        return stringifyBigInts(str);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9zb2xpZGl0eV92ZXJpZmllci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0I7QUFDdUI7QUFDVjs7QUFFbkMsT0FBTyxzQ0FBc0MsRUFBRSwrQ0FBSzs7QUFFckM7QUFDZjs7QUFFQSx3QkFBd0IsNERBQWdCOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsdUNBQVU7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9zb2xpZGl0eV92ZXJpZmllci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgZWpzIGZyb20gXCJlanNcIjtcbmltcG9ydCB7Z2V0Q3VydmVGcm9tTmFtZX0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmNvbnN0IHt1bnN0cmluZ2lmeUJpZ0ludHMsIHN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZmbG9ua0V4cG9ydFNvbGlkaXR5VmVyaWZpZXIodmssIHRlbXBsYXRlcywgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgRVhQT1JUIFNPTElESVRZIFZFUklGSUVSIFNUQVJURURcIik7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbU5hbWUodmsuY3VydmUpO1xuXG4gICAgLy8gUHJlY29tcHV0ZSB3M18yLCB3NF8yIGFuZCB3NF8zXG4gICAgbGV0IHczID0gZnJvbVZrZXkodmsudzMpO1xuICAgIHZrLnczXzIgPSB0b1ZrZXkoY3VydmUuRnIuc3F1YXJlKHczKSk7XG5cbiAgICBsZXQgdzQgPSBmcm9tVmtleSh2ay53NCk7XG4gICAgdmsudzRfMiA9IHRvVmtleShjdXJ2ZS5Gci5zcXVhcmUodzQpKTtcbiAgICB2ay53NF8zID0gdG9Wa2V5KGN1cnZlLkZyLm11bChjdXJ2ZS5Gci5zcXVhcmUodzQpLCB3NCkpO1xuXG4gICAgbGV0IHc4ID0gZnJvbVZrZXkodmsudzgpO1xuICAgIGxldCBhY2MgPSBjdXJ2ZS5Gci5vbmU7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICBhY2MgPSBjdXJ2ZS5Gci5tdWwoYWNjLCB3OCk7XG4gICAgICAgIHZrW1widzhfXCIgKyBpXSA9IHRvVmtleShhY2MpO1xuICAgIH1cblxuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1t2ay5wcm90b2NvbF07XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBFWFBPUlQgU09MSURJVFkgVkVSSUZJRVIgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4gZWpzLnJlbmRlcih0ZW1wbGF0ZSwgdmspO1xuXG4gICAgZnVuY3Rpb24gZnJvbVZrZXkoc3RyKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHVuc3RyaW5naWZ5QmlnSW50cyhzdHIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRnIuZnJvbU9iamVjdCh2YWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvVmtleSh2YWwpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gY3VydmUuRnIudG9PYmplY3QodmFsKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUJpZ0ludHMoc3RyKTtcbiAgICB9XG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/fflonk_full_prove.js":
/*!*******************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_full_prove.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkFullProve)\n/* harmony export */ });\n/* harmony import */ var _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fflonk_prove.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function fflonkFullProve(_input, wasmFilename, zkeyFilename, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {type: \"mem\"};\n\n    // Compute the witness\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFilename, wtns, wtnsCalcOptions);\n\n    // Compute the proof\n    return await (0,_fflonk_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFilename, wtns, logger, proverOptions);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2Z1bGxfcHJvdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRTRDO0FBQ0s7QUFDZDtBQUNuQyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOztBQUVuQjtBQUNmOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQSxVQUFVLDhEQUFjOztBQUV4QjtBQUNBLGlCQUFpQiw0REFBVztBQUM1QiIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfZnVsbF9wcm92ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IGZmbG9ua1Byb3ZlIGZyb20gXCIuL2ZmbG9ua19wcm92ZS5qc1wiO1xuaW1wb3J0IHd0bnNfY2FsY3VsYXRlIGZyb20gXCIuL3d0bnNfY2FsY3VsYXRlLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmZmxvbmtGdWxsUHJvdmUoX2lucHV0LCB3YXNtRmlsZW5hbWUsIHprZXlGaWxlbmFtZSwgbG9nZ2VyLCB3dG5zQ2FsY09wdGlvbnMsIHByb3Zlck9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyhfaW5wdXQpO1xuXG4gICAgY29uc3Qgd3Rucz0ge3R5cGU6IFwibWVtXCJ9O1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgd2l0bmVzc1xuICAgIGF3YWl0IHd0bnNfY2FsY3VsYXRlKGlucHV0LCB3YXNtRmlsZW5hbWUsIHd0bnMsIHd0bnNDYWxjT3B0aW9ucyk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBwcm9vZlxuICAgIHJldHVybiBhd2FpdCBmZmxvbmtQcm92ZSh6a2V5RmlsZW5hbWUsIHd0bnMsIGxvZ2dlciwgcHJvdmVyT3B0aW9ucyk7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/fflonk_full_prove.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/fflonk_prove.js":
/*!**************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_prove.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkProve)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk_constants.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(ssr)/./node_modules/snarkjs/src/Keccak256Transcript.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./proof.js */ \"(ssr)/./node_modules/snarkjs/src/proof.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(ssr)/./node_modules/snarkjs/src/polynomial/polynomial.js\");\n/* harmony import */ var _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./polynomial/evaluations.js */ \"(ssr)/./node_modules/snarkjs/src/polynomial/evaluations.js\");\n/* harmony import */ var _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./polynomial/cpolynomial.js */ \"(ssr)/./node_modules/snarkjs/src/polynomial/cpolynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst { stringifyBigInts } = ffjavascript__WEBPACK_IMPORTED_MODULE_3__.utils;\n\n\nasync function fflonkProve(zkeyFileName, witnessFileName, logger, options) {\n    if (logger) logger.info(\"FFLONK PROVER STARTED\");\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1 << 25, 1 << 23);\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, wtnsSections);\n\n    //Read zkey file\n    if (logger) logger.info(\"> Reading zkey file\");\n    const {\n        fd: fdZKey,\n        sections: zkeySections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1 << 25, 1 << 23);\n\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, zkeySections, undefined, options);\n\n    if (zkey.protocolId !== _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        throw new Error(\"zkey file is not fflonk\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.eq(zkey.r, wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness !== zkey.nVars - zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sDomain = zkey.domainSize * sFr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK PROVE SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${zkey.power}`);\n        logger.info(`  Domain size:   ${zkey.domainSize}`);\n        logger.info(`  Vars:          ${zkey.nVars}`);\n        logger.info(`  Public vars:   ${zkey.nPublic}`);\n        logger.info(`  Constraints:   ${zkey.nConstraints}`);\n        logger.info(`  Additions:     ${zkey.nAdditions}`);\n        logger.info(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.info(\"> Reading witness file data\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(zkey.nAdditions * sFr);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    // To divide prime fields the Extended Euclidean Algorithm for computing modular inverses is needed.\n    // NOTE: This is the equivalent of compute 1/denominator and then multiply it by the numerator.\n    // The Extended Euclidean Algorithm is expensive in terms of computation.\n    // For the special case where we need to do many modular inverses, there's a simple mathematical trick\n    // that allows us to compute many inverses, called Montgomery batch inversion.\n    // More info: https://vitalik.ca/general/2018/07/21/starks_part_3.html\n    // Montgomery batch inversion reduces the n inverse computations to a single one\n    // To save this (single) inverse computation on-chain, will compute it in proving time and send it to the verifier.\n    // The verifier will have to check:\n    // 1) the denominator is correct multiplying by himself non-inverted -> a * 1/a == 1\n    // 2) compute the rest of the denominators using the Montgomery batch inversion\n    // The inversions are:\n    //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n    //    denominator needed in step 10 and 11 of the verifier\n    //    denominator needed in the verifier when computing L_i^{S1}(X) and L_i^{S2}(X)\n    //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n    let toInverse = {};\n\n    let challenges = {};\n    let roots = {};\n\n    let proof = new _proof_js__WEBPACK_IMPORTED_MODULE_7__.Proof(curve, logger);\n\n    if (logger) logger.info(`> Reading Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.info(`> Reading Sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.info(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION][0].p);\n\n    if (logger) logger.info(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION][0].p + sDomain);\n\n    if (logger) logger.info(`> Reading Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n    const PTau = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(zkey.domainSize * 16 * sG1);\n    // domainSize * 9 + 18 = SRS length in the zkey saved in setup process.\n    // it corresponds to the maximum SRS length needed, specifically to commit C2\n    // notice that the reserved buffers size is zkey.domainSize * 16 * sG1 because a power of two buffer size is needed\n    // the remaining buffer not filled from SRS are set to 0\n    await fdZKey.readToBuffer(PTau, 0, (zkey.domainSize * 9 + 18) * sG1, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_PTAU_SECTION][0].p);\n\n    // START FFLONK PROVER PROTOCOL\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 1. Compute C1(X) polynomial\n    if (logger) logger.info(\"\");\n    if (logger) logger.info(\"> ROUND 1\");\n    await round1();\n\n    delete polynomials.T0;\n    delete evaluations.QL;\n    delete evaluations.QR;\n    delete evaluations.QM;\n    delete evaluations.QO;\n    delete evaluations.QC;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 2. Compute C2(X) polynomial\n    if (logger) logger.info(\"> ROUND 2\");\n    await round2();\n\n    delete buffers.A;\n    delete buffers.B;\n    delete buffers.C;\n    delete evaluations.A;\n    delete evaluations.B;\n    delete evaluations.C;\n    delete evaluations.Sigma1;\n    delete evaluations.Sigma2;\n    delete evaluations.Sigma3;\n    delete evaluations.lagrange1;\n    delete evaluations.Z;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 3. Compute opening evaluations\n    if (logger) logger.info(\"> ROUND 3\");\n    await round3();\n\n    delete polynomials.A;\n    delete polynomials.B;\n    delete polynomials.C;\n    delete polynomials.Z;\n    delete polynomials.T1;\n    delete polynomials.T2;\n    delete polynomials.Sigma1;\n    delete polynomials.Sigma2;\n    delete polynomials.Sigma3;\n    delete polynomials.QL;\n    delete polynomials.QR;\n    delete polynomials.QM;\n    delete polynomials.QC;\n    delete polynomials.QO;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 4. Compute W(X) polynomial\n    if (logger) logger.info(\"> ROUND 4\");\n    await round4();\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 5. Compute W'(X) polynomial\n    if (logger) logger.info(\"> ROUND 5\");\n    await round5();\n\n    delete polynomials.C0;\n    delete polynomials.C1;\n    delete polynomials.C2;\n    delete polynomials.R1;\n    delete polynomials.R2;\n    delete polynomials.F;\n    delete polynomials.L;\n    delete polynomials.ZT;\n    delete polynomials.ZTS2;\n    await fdZKey.close();\n    if (globalThis.gc) globalThis.gc();\n\n    proof.addEvaluation(\"inv\", getMontgomeryBatchedInverse());\n\n    // Prepare proof\n    let _proof = proof.toObjectProof();\n    _proof.protocol = \"fflonk\";\n    _proof.curve = curve.name;\n\n    // Prepare public inputs\n    let publicSignals = [];\n\n    for (let i = 1; i <= zkey.nPublic; i++) {\n        const i_sFr = i * sFr;\n\n        const pub = buffWitness.slice(i_sFr, i_sFr + sFr);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.info(\"FFLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.info(\" Computing additions\");\n        const additionsBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + sFr * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + sFr);\n            offset += sFr;\n            const factor2 = additionsBuff.slice(offset, offset + sFr);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, sFr * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o + 4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        let diff = zkey.nVars - zkey.nAdditions;\n        if (idx < diff) {\n            return buffWitness.slice(idx * sFr, idx * sFr + sFr);\n        } else if (idx < zkey.nVars) {\n            const offset = (idx - diff) * sFr;\n            return buffInternalWitness.slice(offset, offset + sFr);\n        }\n\n        return Fr.zero;\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b_1, ..., b9)  F\n        challenges.b = [];\n        for (let i = 1; i <= 9; i++) {\n            challenges.b[i] = Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.info(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute the quotient polynomial T0(X)\n        if (logger) logger.info(\"> Computing T0 polynomial\");\n        await computeT0();\n\n        // STEP 1.4 - Compute the FFT-style combination polynomial C1(X)\n        if (logger) logger.info(\"> Computing C1 polynomial\");\n        await computeC1();\n\n        // The first output of the prover is ([C1]_1)\n        if (logger) logger.info(\"> Computing C1 multi exponentiation\");\n        let commitC1 = await polynomials.C1.multiExponentiation(PTau, \"C1\");\n        proof.addPolynomial(\"C1\", commitC1);\n\n        return 0;\n\n        async function computeWirePolynomials() {\n            if (logger) logger.info(\" Reading data from zkey file\");\n            // Build A, B and C evaluations buffer from zkey and witness files\n            buffers.A = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            buffers.B = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            buffers.C = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n            // Read zkey sections and fill the buffers\n            const aMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_A_MAP_SECTION);\n            const bMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_B_MAP_SECTION);\n            const cMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_C_MAP_SECTION);\n\n            // Compute all witness from signal ids and set them to A,B & C buffers\n            for (let i = 0; i < zkey.nConstraints; i++) {\n                const i_sFr = i * sFr;\n                const offset = i * 4;\n\n                // Compute A value from a signal id\n                const signalIdA = readUInt32(aMapBuff, offset);\n                buffers.A.set(getWitness(signalIdA), i_sFr);\n\n                // Compute B value from a signal id\n                const signalIdB = readUInt32(bMapBuff, offset);\n                buffers.B.set(getWitness(signalIdB), i_sFr);\n\n                // Compute C value from a signal id\n                const signalIdC = readUInt32(cMapBuff, offset);\n                buffers.C.set(getWitness(signalIdC), i_sFr);\n            }\n\n            // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n            buffers.A.set(challenges.b[1], sDomain - 64);\n            buffers.A.set(challenges.b[2], sDomain - 32);\n            buffers.B.set(challenges.b[3], sDomain - 64);\n            buffers.B.set(challenges.b[4], sDomain - 32);\n            buffers.C.set(challenges.b[5], sDomain - 64);\n            buffers.C.set(challenges.b[6], sDomain - 32);\n\n            buffers.A = await Fr.batchToMontgomery(buffers.A);\n            buffers.B = await Fr.batchToMontgomery(buffers.B);\n            buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n            // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n            if (logger) logger.info(\" Computing A ifft\");\n            polynomials.A = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.A, curve, logger);\n            if (logger) logger.info(\" Computing B ifft\");\n            polynomials.B = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.B, curve, logger);\n            if (logger) logger.info(\" Computing C ifft\");\n            polynomials.C = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n            // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n            if (logger) logger.info(\" Computing A fft\");\n            evaluations.A = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n            if (logger) logger.info(\" Computing B fft\");\n            evaluations.B = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n            if (logger) logger.info(\" Computing C fft\");\n            evaluations.C = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n            // Check degrees\n            if (polynomials.A.degree() >= zkey.domainSize) {\n                throw new Error(\"A Polynomial is not well calculated\");\n            }\n            if (polynomials.B.degree() >= zkey.domainSize) {\n                throw new Error(\"B Polynomial is not well calculated\");\n            }\n            if (polynomials.C.degree() >= zkey.domainSize) {\n                throw new Error(\"C Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeT0() {\n            if (logger) logger.info(` Reading sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION}` +\n                `, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION}. Q selectors`);\n            // Reserve memory for Q's evaluations\n            evaluations.QL = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QR = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QM = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QO = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QC = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n            // Read Q's evaluations from zkey file\n            await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION][0].p + sDomain);\n\n            // Read Lagrange polynomials & evaluations from zkey file\n            const lagrangePolynomials = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_LAGRANGE_SECTION);\n            evaluations.lagrange1 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(lagrangePolynomials, curve, logger);\n\n            // Reserve memory for buffers T0\n            buffers.T0 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n\n            if (logger) logger.info(\" Computing T0 evaluations\");\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`      T0 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                // Get related evaluations to compute current T0 evaluation\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n\n                const ql = evaluations.QL.getEvaluation(i);\n                const qr = evaluations.QR.getEvaluation(i);\n                const qm = evaluations.QM.getEvaluation(i);\n                const qo = evaluations.QO.getEvaluation(i);\n                const qc = evaluations.QC.getEvaluation(i);\n\n                // Compute current public input\n                let pi = Fr.zero;\n                for (let j = 0; j < zkey.nPublic; j++) {\n                    const offset = (j * 5 * zkey.domainSize) + zkey.domainSize + i;\n\n                    const lPol = evaluations.lagrange1.getEvaluation(offset);\n                    const aVal = buffers.A.slice(j * sFr, (j + 1) * sFr);\n\n                    pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n                }\n\n                //T0(X) = [q_L(X)a(X) + q_R(X)b(X) + q_M(X)a(X)b(X) + q_O(X)c(X) + q_C(X) + PI(X)]  1/Z_H(X)\n                // Compute first T0(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                // expression 1 -> q_L(X)a(X)\n                const e1 = Fr.mul(a, ql);\n\n                // expression 2 -> q_R(X)b(X)\n                const e2 = Fr.mul(b, qr);\n\n                // expression 3 -> q_M(X)a(X)b(X)\n                const e3 = Fr.mul(Fr.mul(a, b), qm);\n\n                // expression 4 -> q_O(X)c(X)\n                const e4 = Fr.mul(c, qo);\n\n                // t0 = expressions 1 + expression 2 + expression 3 + expression 4 + qc + pi\n                const t0 = Fr.add(e1, Fr.add(e2, Fr.add(e3, Fr.add(e4, Fr.add(qc, pi)))));\n\n                buffers.T0.set(t0, i * sFr);\n            }\n\n            if (logger) logger.info(\"buffer T0: \" + buffers.T0.byteLength / sFr);\n\n            // Compute the coefficients of the polynomial T0(X) from buffers.T0\n            if (logger) logger.info(\" Computing T0 ifft\");\n            polynomials.T0 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T0, curve, logger);\n\n            if (logger) logger.info(\"T0 length: \" + polynomials.T0.length());\n            if (logger) logger.info(\"T0 degree: \" + polynomials.T0.degree());\n\n            // Divide the polynomial T0 by Z_H(X)\n            if (logger) logger.info(\" Computing T0 / ZH\");\n            polynomials.T0.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Check degree\n            if (polynomials.T0.degree() >= 2 * zkey.domainSize - 2) {\n                throw new Error(`T0 Polynomial is not well calculated (degree is ${polynomials.T0.degree()} and must be less than ${2 * zkey.domainSize + 2}`);\n            }\n\n            delete buffers.T0;\n        }\n\n        async function computeC1() {\n            let C1 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__.CPolynomial(4, curve, logger);\n            C1.addPolynomial(0, polynomials.A);\n            C1.addPolynomial(1, polynomials.B);\n            C1.addPolynomial(2, polynomials.C);\n            C1.addPolynomial(3, polynomials.T0);\n\n            polynomials.C1 = C1.getPolynomial();\n\n            // Check degree\n            if (polynomials.C1.degree() >= 8 * zkey.domainSize - 8) {\n                throw new Error(\"C1 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.info(\"> Computing challenges beta and gamma\");\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n\n        // Add C0 to the transcript\n        transcript.addPolCommitment(zkey.C0);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * sFr, i * sFr + sFr));\n        }\n\n        // Add C1 to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"C1\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.beta: \" + Fr.toString(challenges.beta));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n\n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.info(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute quotient polynomial T1(X) and T2(X)\n        if (logger) logger.info(\"> Computing T1 polynomial\");\n        await computeT1();\n        if (logger) logger.info(\"> Computing T2 polynomial\");\n        await computeT2();\n\n        // STEP 2.4 - Compute the FFT-style combination polynomial C2(X)\n        if (logger) logger.info(\"> Computing C2 polynomial\");\n        await computeC2();\n\n        // The second output of the prover is ([C2]_1)\n        if (logger) logger.info(\"> Computing C2 multi exponentiation\");\n        let commitC2 = await polynomials.C2.multiExponentiation(PTau, \"C2\");\n        proof.addPolynomial(\"C2\", commitC2);\n\n        return 0;\n\n        async function computeZ() {\n            if (logger) logger.info(\" Computing Z evaluations\");\n\n            let numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n            // Set the first values to 1\n            numArr.set(Fr.one, 0);\n            denArr.set(Fr.one, 0);\n\n            // Set initial omega\n            let w = Fr.one;\n            for (let i = 0; i < zkey.domainSize; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    Z evaluation ${i}/${zkey.domainSize}`);\n                const i_sFr = i * sFr;\n\n                // Z(X) := numArr / denArr\n                // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n                const betaw = Fr.mul(challenges.beta, w);\n\n                let num1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                num1 = Fr.add(num1, betaw);\n                num1 = Fr.add(num1, challenges.gamma);\n\n                let num2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                num2 = Fr.add(num2, Fr.mul(zkey.k1, betaw));\n                num2 = Fr.add(num2, challenges.gamma);\n\n                let num3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                num3 = Fr.add(num3, Fr.mul(zkey.k2, betaw));\n                num3 = Fr.add(num3, challenges.gamma);\n\n                let num = Fr.mul(num1, Fr.mul(num2, num3));\n\n                // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n                let den1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                den1 = Fr.add(den1, Fr.mul(challenges.beta, evaluations.Sigma1.getEvaluation(i * 4)));\n                den1 = Fr.add(den1, challenges.gamma);\n\n                let den2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                den2 = Fr.add(den2, Fr.mul(challenges.beta, evaluations.Sigma2.getEvaluation(i * 4)));\n                den2 = Fr.add(den2, challenges.gamma);\n\n                let den3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                den3 = Fr.add(den3, Fr.mul(challenges.beta, evaluations.Sigma3.getEvaluation(i * 4)));\n                den3 = Fr.add(den3, challenges.gamma);\n\n                let den = Fr.mul(den1, Fr.mul(den2, den3));\n\n                // Multiply current num value with the previous one saved in numArr\n                num = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), num);\n                numArr.set(num, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Multiply current den value with the previous one saved in denArr\n                den = Fr.mul(denArr.slice(i_sFr, i_sFr + sFr), den);\n                denArr.set(den, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Next omega\n                w = Fr.mul(w, Fr.w[zkey.power]);\n            }\n            // Compute the inverse of denArr to compute in the next command the\n            // division numArr/denArr by multiplying num  1/denArr\n            denArr = await Fr.batchInverse(denArr);\n\n            // TODO: Do it in assembly and in parallel\n            // Multiply numArr  denArr where denArr was inverted in the previous command\n            for (let i = 0; i < zkey.domainSize; i++) {\n                const i_sFr = i * sFr;\n\n                const z = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), denArr.slice(i_sFr, i_sFr + sFr));\n                numArr.set(z, i_sFr);\n            }\n            // From now on the values saved on numArr will be Z(X) buffer\n            buffers.Z = numArr;\n\n            if (!Fr.eq(numArr.slice(0, sFr), Fr.one)) {\n                throw new Error(\"Copy constraints does not match\");\n            }\n\n            // Compute polynomial coefficients z(X) from buffers.Z\n            if (logger) logger.info(\" Computing Z ifft\");\n            polynomials.Z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n            // Compute extended evaluations of z(X) polynomial\n            if (logger) logger.info(\" Computing Z fft\");\n            evaluations.Z = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n            // Blind z(X) polynomial coefficients with blinding scalars b\n            polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n            // Check degree\n            if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n                throw new Error(\"Z Polynomial is not well calculated\");\n            }\n\n            delete buffers.Z;\n        }\n\n        async function computeT1() {\n            if (logger) logger.info(\" Computing T1 evaluations\");\n\n            buffers.T1 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 2);\n            buffers.T1z = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 2);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 2; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T1 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n\n                const z = evaluations.Z.getEvaluation(i * 2);\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n\n                // T1(X) := (z(X) - 1)  L_1(X)\n                // Compute first T1(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                const lagrange1 = evaluations.lagrange1.getEvaluation(zkey.domainSize + i * 2);\n                let t1 = Fr.mul(Fr.sub(z, Fr.one), lagrange1);\n                let t1z = Fr.mul(zp, lagrange1);\n\n                buffers.T1.set(t1, i * sFr);\n                buffers.T1z.set(t1z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 1]);\n            }\n\n            // Compute the coefficients of the polynomial T1(X) from buffers.T1\n            if (logger) logger.info(\" Computing T1 ifft\");\n            polynomials.T1 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T1, curve, logger);\n\n            // Divide the polynomial T1 by Z_H(X)\n            polynomials.T1.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T1z(X) from buffers.T1z\n            if (logger) logger.info(\" Computing T1z ifft\");\n            polynomials.T1z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T1z, curve, logger);\n\n            // Add the polynomial T1z to T1 to get the final polynomial T1\n            polynomials.T1.add(polynomials.T1z);\n\n            // Check degree\n            if (polynomials.T1.degree() >= zkey.domainSize + 2) {\n                throw new Error(\"T1 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T1;\n            delete buffers.T1z;\n            delete polynomials.T1z;\n        }\n\n        async function computeT2() {\n            if (logger) logger.info(\" Computing T2 evaluations\");\n\n            buffers.T2 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n            buffers.T2z = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T2 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n                const omegaW = Fr.mul(omega, Fr.w[zkey.power]);\n                const omegaW2 = Fr.square(omegaW);\n\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n                const z = evaluations.Z.getEvaluation(i);\n                const zW = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n                const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omegaW2), Fr.mul(challenges.b[8], omegaW)), challenges.b[9]);\n\n                const sigma1 = evaluations.Sigma1.getEvaluation(i);\n                const sigma2 = evaluations.Sigma2.getEvaluation(i);\n                const sigma3 = evaluations.Sigma3.getEvaluation(i);\n\n                // T2(X) := [ (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                //           -(a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)]  1/Z_H(X)\n                // Compute first T2(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n\n                // expression 1 -> (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                const betaX = Fr.mul(challenges.beta, omega);\n\n                let e11 = Fr.add(a, betaX);\n                e11 = Fr.add(e11, challenges.gamma);\n\n                let e12 = Fr.add(b, Fr.mul(betaX, zkey.k1));\n                e12 = Fr.add(e12, challenges.gamma);\n\n                let e13 = Fr.add(c, Fr.mul(betaX, zkey.k2));\n                e13 = Fr.add(e13, challenges.gamma);\n\n                let e1 = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), z);\n                let e1z = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), zp);\n                // const [e1, e1z] = MulZ.mul4(e11, e12, e13, z, ap, bp, cp, zp, i % 4, Fr);\n\n                // expression 2 -> (a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)\n                let e21 = Fr.add(a, Fr.mul(challenges.beta, sigma1));\n                e21 = Fr.add(e21, challenges.gamma);\n\n                let e22 = Fr.add(b, Fr.mul(challenges.beta, sigma2));\n                e22 = Fr.add(e22, challenges.gamma);\n\n                let e23 = Fr.add(c, Fr.mul(challenges.beta, sigma3));\n                e23 = Fr.add(e23, challenges.gamma);\n\n                let e2 = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zW);\n                let e2z = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zWp);\n                // const [e2, e2z] = MulZ.mul4(e21, e22, e23, zW, ap, bp, cp, zWp, i % 4, Fr);\n\n                let t2 = Fr.sub(e1, e2);\n                let t2z = Fr.sub(e1z, e2z);\n\n                buffers.T2.set(t2, i * sFr);\n                buffers.T2z.set(t2z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 2]);\n            }\n\n            // Compute the coefficients of the polynomial T2(X) from buffers.T2\n            if (logger) logger.info(\" Computing T2 ifft\");\n            polynomials.T2 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T2, curve, logger);\n\n            // Divide the polynomial T2 by Z_H(X)\n            if (logger) logger.info(\" Computing T2 / ZH\");\n            polynomials.T2.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T2z(X) from buffers.T2z\n            if (logger) logger.info(\" Computing T2z ifft\");\n            polynomials.T2z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T2z, curve, logger);\n\n            // Add the polynomial T2z to T2 to get the final polynomial T2\n            polynomials.T2.add(polynomials.T2z);\n\n            // Check degree\n            if (polynomials.T2.degree() >= 3 * zkey.domainSize) {\n                throw new Error(\"T2 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T2;\n            delete buffers.T2z;\n            delete polynomials.T2z;\n        }\n\n        async function computeC2() {\n            let C2 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__.CPolynomial(3, curve, logger);\n            C2.addPolynomial(0, polynomials.Z);\n            C2.addPolynomial(1, polynomials.T1);\n            C2.addPolynomial(2, polynomials.T2);\n\n            polynomials.C2 = C2.getPolynomial();\n\n            // Check degree\n            if (polynomials.C2.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"C2 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round3() {\n        if (logger) logger.info(\"> Computing challenge xi\");\n        // STEP 3.1 - Compute evaluation challenge xi  S\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"C2\"));\n\n        // Obtain a xi_seeder from the transcript\n        // To force h1^4 = xi, h2^3 = xi and h_3^2 = xi\n        // we compute xi = xi_seeder^12, h1 = xi_seeder^3, h2 = xi_seeder^4 and h3 = xi_seeder^6\n        challenges.xiSeed = transcript.getChallenge();\n        const xiSeed2 = Fr.square(challenges.xiSeed);\n\n        // Compute omega8, omega4 and omega3\n        roots.w8 = [];\n        roots.w8[0] = Fr.one;\n        for (let i = 1; i < 8; i++) {\n            roots.w8[i] = Fr.mul(roots.w8[i - 1], zkey.w8);\n        }\n\n        roots.w4 = [];\n        roots.w4[0] = Fr.one;\n        for (let i = 1; i < 4; i++) {\n            roots.w4[i] = Fr.mul(roots.w4[i - 1], zkey.w4);\n        }\n\n        roots.w3 = [];\n        roots.w3[0] = Fr.one;\n        roots.w3[1] = zkey.w3;\n        roots.w3[2] = Fr.square(zkey.w3);\n\n        // Compute h0 = xiSeeder^3\n        roots.S0 = {};\n        roots.S0.h0w8 = [];\n        roots.S0.h0w8[0] = Fr.mul(xiSeed2, challenges.xiSeed);\n        for (let i = 1; i < 8; i++) {\n            roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], roots.w8[i]);\n        }\n\n        // Compute h1 = xi_seeder^6\n        roots.S1 = {};\n        roots.S1.h1w4 = [];\n        roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n        for (let i = 1; i < 4; i++) {\n            roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], roots.w4[i]);\n        }\n\n        // Compute h2 = xi_seeder^8\n        roots.S2 = {};\n        roots.S2.h2w3 = [];\n        roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n        roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], roots.w3[1]);\n        roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], roots.w3[2]);\n\n        roots.S2.h3w3 = [];\n        // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n        // So, h3 = xi_seeder^8 ^{1/3}\n        roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], zkey.wr);\n        roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], roots.w3[1]);\n        roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], roots.w3[2]);\n\n        // Compute xi = xi_seeder^24\n        challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n\n        if (logger) logger.info(\" challenges.xi: \" + Fr.toString(challenges.xi));\n\n        // Reserve memory for Q's polynomials\n        polynomials.QL = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION][0].p);\n\n        // STEP 3.2 - Compute opening evaluations and add them to the proof (third output of the prover)\n        if (logger) logger.info(\" Computing evaluations\");\n        proof.addEvaluation(\"ql\", polynomials.QL.evaluate(challenges.xi));\n        proof.addEvaluation(\"qr\", polynomials.QR.evaluate(challenges.xi));\n        proof.addEvaluation(\"qm\", polynomials.QM.evaluate(challenges.xi));\n        proof.addEvaluation(\"qo\", polynomials.QO.evaluate(challenges.xi));\n        proof.addEvaluation(\"qc\", polynomials.QC.evaluate(challenges.xi));\n        proof.addEvaluation(\"s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"s3\", polynomials.Sigma3.evaluate(challenges.xi));\n        proof.addEvaluation(\"a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"z\", polynomials.Z.evaluate(challenges.xi));\n\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        proof.addEvaluation(\"zw\", polynomials.Z.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t1w\", polynomials.T1.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t2w\", polynomials.T2.evaluate(challenges.xiw));\n    }\n\n    async function round4() {\n        if (logger) logger.info(\"> Computing challenge alpha\");\n        // STEP 4.1 - Compute challenge alpha  F\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.xiSeed);\n        transcript.addScalar(proof.getEvaluation(\"ql\"));\n        transcript.addScalar(proof.getEvaluation(\"qr\"));\n        transcript.addScalar(proof.getEvaluation(\"qm\"));\n        transcript.addScalar(proof.getEvaluation(\"qo\"));\n        transcript.addScalar(proof.getEvaluation(\"qc\"));\n        transcript.addScalar(proof.getEvaluation(\"s1\"));\n        transcript.addScalar(proof.getEvaluation(\"s2\"));\n        transcript.addScalar(proof.getEvaluation(\"s3\"));\n        transcript.addScalar(proof.getEvaluation(\"a\"));\n        transcript.addScalar(proof.getEvaluation(\"b\"));\n        transcript.addScalar(proof.getEvaluation(\"c\"));\n        transcript.addScalar(proof.getEvaluation(\"z\"));\n        transcript.addScalar(proof.getEvaluation(\"zw\"));\n        transcript.addScalar(proof.getEvaluation(\"t1w\"));\n        transcript.addScalar(proof.getEvaluation(\"t2w\"));\n        challenges.alpha = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n\n        // STEP 4.2 - Compute F(X)\n        if (logger) logger.info(\"> Reading C0 polynomial\");\n        polynomials.C0 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 8), curve, logger);\n        await fdZKey.readToBuffer(polynomials.C0.coef, 0, sDomain * 8, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_C0_SECTION][0].p);\n\n        if (logger) logger.info(\"> Computing R0 polynomial\");\n        computeR0();\n        if (logger) logger.info(\"> Computing R1 polynomial\");\n        computeR1();\n        if (logger) logger.info(\"> Computing R2 polynomial\");\n        computeR2();\n\n        if (logger) logger.info(\"> Computing F polynomial\");\n        await computeF();\n\n        // The fourth output of the prover is ([W1]_1), where W1:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W1 multi exponentiation\");\n        let commitW1 = await polynomials.F.multiExponentiation(PTau, \"W1\");\n        proof.addPolynomial(\"W1\", commitW1);\n\n        return 0;\n\n        function computeR0() {\n            // COMPUTE R0\n            // Compute the coefficients of R0(X) from 8 evaluations using lagrange interpolation. R0(X)  F_{<8}[X]\n            // We decide to use Lagrange interpolations because the R0 degree is very small (deg(R0)===7),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R0 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7]],\n                [polynomials.C0.evaluate(roots.S0.h0w8[0]), polynomials.C0.evaluate(roots.S0.h0w8[1]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[2]), polynomials.C0.evaluate(roots.S0.h0w8[3]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[4]), polynomials.C0.evaluate(roots.S0.h0w8[5]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[6]), polynomials.C0.evaluate(roots.S0.h0w8[7])], curve);\n\n            // Check the degree of r0(X) < 8\n            if (polynomials.R0.degree() > 7) {\n                throw new Error(\"R0 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR1() {\n            // COMPUTE R1\n            // Compute the coefficients of R1(X) from 4 evaluations using lagrange interpolation. R1(X)  F_{<4}[X]\n            // We decide to use Lagrange interpolations because the R1 degree is very small (deg(R1)===3),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R1 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3]],\n                [polynomials.C1.evaluate(roots.S1.h1w4[0]), polynomials.C1.evaluate(roots.S1.h1w4[1]),\n                    polynomials.C1.evaluate(roots.S1.h1w4[2]), polynomials.C1.evaluate(roots.S1.h1w4[3])], curve);\n\n            // Check the degree of r1(X) < 4\n            if (polynomials.R1.degree() > 3) {\n                throw new Error(\"R1 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR2() {\n            // COMPUTE R2\n            // Compute the coefficients of r2(X) from 6 evaluations using lagrange interpolation. r2(X)  F_{<6}[X]\n            // We decide to use Lagrange interpolations because the R2.degree is very small (deg(R2)===5),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]],\n                [polynomials.C2.evaluate(roots.S2.h2w3[0]), polynomials.C2.evaluate(roots.S2.h2w3[1]),\n                    polynomials.C2.evaluate(roots.S2.h2w3[2]), polynomials.C2.evaluate(roots.S2.h3w3[0]),\n                    polynomials.C2.evaluate(roots.S2.h3w3[1]), polynomials.C2.evaluate(roots.S2.h3w3[2])], curve);\n\n            // Check the degree of r2(X) < 6\n            if (polynomials.R2.degree() > 5) {\n                throw new Error(\"R2 Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeF() {\n            if (logger) logger.info(\" Computing F polynomial\");\n\n            // COMPUTE F(X)\n            polynomials.F = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.F.sub(polynomials.R0);\n            polynomials.F.divByZerofier(8, challenges.xi);\n\n            let f2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            f2.sub(polynomials.R1);\n            f2.mulScalar(challenges.alpha);\n            f2.divByZerofier(4, challenges.xi);\n\n            let f3 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            f3.sub(polynomials.R2);\n            f3.mulScalar(Fr.square(challenges.alpha));\n            f3.divByZerofier(3, challenges.xi);\n            f3.divByZerofier(3, challenges.xiw);\n\n            polynomials.F.add(f2);\n            polynomials.F.add(f3);\n\n            if (polynomials.F.degree() >= 9 * zkey.domainSize - 6) {\n                throw new Error(\"F Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round5() {\n        if (logger) logger.info(\"> Computing challenge y\");\n\n        // STEP 5.1 - Compute random evaluation point y  F\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"W1\"));\n\n        challenges.y = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.y: \" + Fr.toString(challenges.y));\n\n        // STEP 5.2 - Compute L(X)\n        if (logger) logger.info(\"> Computing L polynomial\");\n        await computeL();\n\n        if (logger) logger.info(\"> Computing ZTS2 polynomial\");\n        await computeZTS2();\n\n        let ZTS2Y = polynomials.ZTS2.evaluate(challenges.y);\n        ZTS2Y = Fr.inv(ZTS2Y);\n        polynomials.L.mulScalar(ZTS2Y);\n\n        const polDividend = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromCoefficientsArray([Fr.neg(challenges.y), Fr.one], curve);\n        if (logger) logger.info(\"> Computing W' = L / ZTS2 polynomial\");\n        const polRemainder = polynomials.L.divBy(polDividend);\n\n        //Check polReminder degree is equal to zero\n        if (polRemainder.degree() > 0) {\n            throw new Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${polRemainder.degree()} and should be 0`);\n        }\n\n        if (polynomials.L.degree() >= 9 * zkey.domainSize - 1) {\n            throw new Error(\"Degree of L(X)/(ZTS2(y)(X-y)) is not correct\");\n        }\n\n        // The fifth output of the prover is ([W2]_1), where W2:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W' multi exponentiation\");\n        let commitW2 = await polynomials.L.multiExponentiation(PTau, \"W2\");\n        proof.addPolynomial(\"W2\", commitW2);\n\n        return 0;\n\n        async function computeL() {\n            if (logger) logger.info(\" Computing L polynomial\");\n\n            const evalR0Y = polynomials.R0.evaluate(challenges.y);\n            const evalR1Y = polynomials.R1.evaluate(challenges.y);\n            const evalR2Y = polynomials.R2.evaluate(challenges.y);\n\n            let mulL0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n            for (let i = 1; i < 8; i++) {\n                mulL0 = Fr.mul(mulL0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n            }\n\n            let mulL1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n            for (let i = 1; i < 4; i++) {\n                mulL1 = Fr.mul(mulL1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n            }\n\n            let mulL2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n            for (let i = 1; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n            }\n            for (let i = 0; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n            }\n\n            let preL0 = Fr.mul(mulL1, mulL2);\n            let preL1 = Fr.mul(challenges.alpha, Fr.mul(mulL0, mulL2));\n            let preL2 = Fr.mul(Fr.square(challenges.alpha), Fr.mul(mulL0, mulL1));\n\n            toInverse[\"denH1\"] = mulL1;\n            toInverse[\"denH2\"] = mulL2;\n\n            // COMPUTE L(X)\n            polynomials.L = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.L.subScalar(evalR0Y);\n            polynomials.L.mulScalar(preL0);\n\n            let l2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            l2.subScalar(evalR1Y);\n            l2.mulScalar(preL1);\n\n            let l3 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            l3.subScalar(evalR2Y);\n            l3.mulScalar(preL2);\n\n            polynomials.L.add(l2);\n            polynomials.L.add(l3);\n\n            if (logger) logger.info(\"> Computing ZT polynomial\");\n            await computeZT();\n\n            const evalZTY = polynomials.ZT.evaluate(challenges.y);\n            polynomials.F.mulScalar(evalZTY);\n            polynomials.L.sub(polynomials.F);\n\n            // Check degree\n            if (polynomials.L.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"L Polynomial is not well calculated\");\n            }\n\n            delete buffers.L;\n        }\n\n        async function computeZT() {\n            polynomials.ZT = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.zerofierPolynomial(\n                [\n                    roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7],\n                    roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n\n        async function computeZTS2() {\n            polynomials.ZTS2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.zerofierPolynomial(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n    }\n\n    function getMontgomeryBatchedInverse() {\n        //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n        let xiN = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            xiN = Fr.square(xiN);\n        }\n        toInverse[\"zh\"] = Fr.sub(xiN, Fr.one);\n\n        //    denominator needed in step 10 and 11 of the verifier\n        //     toInverse.denH1 & toInverse.denH2  -> Computed in round5, computeL()\n\n        //    denominator needed in the verifier when computing L_i^{S0}(X), L_i^{S1}(X) and L_i^{S2}(X)\n        computeLiS0(toInverse, roots.S0.h0w8, challenges.y, curve);\n\n        computeLiS1(toInverse, roots.S1.h1w4, challenges.y, curve);\n\n        computeLiS2(toInverse, roots.S2.h2w3, roots.S2.h3w3, challenges.y, challenges.xi, challenges.xiw, curve);\n\n        //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n        const size = Math.max(1, zkey.nPublic);\n\n        let w = Fr.one;\n        for (let i = 0; i < size; i++) {\n            toInverse[\"Li_\" + (i + 1)] = Fr.mul(Fr.e(zkey.domainSize), Fr.sub(challenges.xi, w));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        let mulAccumulator = Fr.one;\n        for (const element of Object.values(toInverse)) {\n            if(Array.isArray(element)) {\n                for (const subElement of element) {\n                    mulAccumulator = Fr.mul(mulAccumulator, subElement);\n                }\n            } else {\n                mulAccumulator = Fr.mul(mulAccumulator, element);\n            }\n        }\n        return Fr.inv(mulAccumulator);\n\n        \n        function computeLiS0(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS0_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n            }\n        \n            return Li;\n        }\n\n        function computeLiS1(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS1_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n\n            }\n        \n            return Li;\n        }\n\n        function computeLiS2(toInverse, S2, S2p, value, xi, xiw, curve) {\n            const Fr = curve.Fr;\n        \n            const Li = [];\n        \n            const _3h2 = Fr.mul(Fr.e(3), S2[0]);\n            const xisubxiw = Fr.sub(xi, xiw);\n            let den1 = Fr.mul(_3h2, xisubxiw);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2[2 * i % 3];\n                const den3 = Fr.sub(value, S2[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1)]] = Fr.mul(den1,Fr.mul(den2, den3));\n                \n            }\n        \n            const _3h3 = Fr.mul(Fr.e(3), S2p[0]);\n            const xiwsubxi = Fr.sub(xiw, xi);\n            den1 = Fr.mul(_3h3, xiwsubxi);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2p[2 * i % 3];\n                const den3 = Fr.sub(value, S2p[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1 + 3)]] = Fr.mul(den1,Fr.mul(den2, den3));    \n            }\n        \n            return Li;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3Byb3ZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ1A7QUFDQTtBQUNXO0FBQ0M7QUFpQjFCO0FBQ2dDO0FBQzVCO0FBQ3FCO0FBQ0U7QUFDQTs7QUFFMUQsUUFBUSxtQkFBbUIsRUFBRSwrQ0FBSzs7O0FBR25CO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSw0REFBd0I7QUFDdEMsdUJBQXVCLHNEQUFvQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSw0REFBd0I7O0FBRXRDLHVCQUF1QixzREFBb0I7O0FBRTNDLDRCQUE0QixrRUFBa0I7QUFDOUM7QUFDQTs7QUFFQSxTQUFTLGdEQUFNO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxXQUFXLGFBQWEsY0FBYyxJQUFJLGdCQUFnQjtBQUN0SDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQsd0NBQXdDLFdBQVc7QUFDbkQsd0NBQXdDLGdCQUFnQjtBQUN4RCx3Q0FBd0MsV0FBVztBQUNuRCx3Q0FBd0MsYUFBYTtBQUNyRCx3Q0FBd0Msa0JBQWtCO0FBQzFELHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLDREQUF3QjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQVM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEdBQUcsYUFBYSxHQUFHO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsNENBQUs7O0FBRXpCLGlEQUFpRCwyRUFBeUIsQ0FBQztBQUMzRTs7QUFFQSxrREFBa0Qsd0VBQXNCLENBQUMsR0FBRyx3RUFBc0IsQ0FBQyxHQUFHLHdFQUFzQixDQUFDO0FBQzdIO0FBQ0EsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7O0FBRXJELGdGQUFnRix3RUFBc0I7QUFDdEcsZ0ZBQWdGLHdFQUFzQjtBQUN0RyxnRkFBZ0Ysd0VBQXNCOztBQUV0RztBQUNBLDZCQUE2QixtRUFBVyxLQUFLLG1EQUFTO0FBQ3RELDZCQUE2QixtRUFBVyxLQUFLLG1EQUFTO0FBQ3RELDZCQUE2QixtRUFBVyxLQUFLLG1EQUFTOztBQUV0RCxvRkFBb0Ysd0VBQXNCO0FBQzFHLG9GQUFvRix3RUFBc0I7QUFDMUcsb0ZBQW9GLHdFQUFzQjs7QUFFMUcsaURBQWlELHNFQUFvQixDQUFDO0FBQ3RFLHFCQUFxQixtREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixzRUFBb0I7O0FBRTFHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQjtBQUN2Qzs7QUFFQTtBQUNBLDJCQUEyQixnREFBTTtBQUNqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLDREQUF3Qix1QkFBdUIsMkVBQXlCOztBQUU1RztBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHFCQUFxQjtBQUM3Qyx1RkFBdUYsRUFBRSxHQUFHLGdCQUFnQjs7QUFFNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1EQUFTO0FBQ3JDLDRCQUE0QixtREFBUztBQUNyQyw0QkFBNEIsbURBQVM7O0FBRXJDO0FBQ0EsbUNBQW1DLDREQUF3Qix1QkFBdUIsdUVBQXFCO0FBQ3ZHLG1DQUFtQyw0REFBd0IsdUJBQXVCLHVFQUFxQjtBQUN2RyxtQ0FBbUMsNERBQXdCLHVCQUF1Qix1RUFBcUI7O0FBRXZHO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUVBQVU7QUFDNUM7QUFDQSxrQ0FBa0MsaUVBQVU7QUFDNUM7QUFDQSxrQ0FBa0MsaUVBQVU7O0FBRTVDO0FBQ0E7QUFDQSxrQ0FBa0MsbUVBQVc7QUFDN0M7QUFDQSxrQ0FBa0MsbUVBQVc7QUFDN0M7QUFDQSxrQ0FBa0MsbUVBQVc7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsb0VBQWtCLENBQUMsSUFBSSxvRUFBa0IsQ0FBQztBQUN0RyxxQkFBcUIsb0VBQWtCLENBQUMsSUFBSSxvRUFBa0IsQ0FBQyxJQUFJLG9FQUFrQixDQUFDO0FBQ3RGO0FBQ0EsaUNBQWlDLG1FQUFXLEtBQUssbURBQVM7QUFDMUQsaUNBQWlDLG1FQUFXLEtBQUssbURBQVM7QUFDMUQsaUNBQWlDLG1FQUFXLEtBQUssbURBQVM7QUFDMUQsaUNBQWlDLG1FQUFXLEtBQUssbURBQVM7QUFDMUQsaUNBQWlDLG1FQUFXLEtBQUssbURBQVM7O0FBRTFEO0FBQ0Esd0ZBQXdGLG9FQUFrQjtBQUMxRyx3RkFBd0Ysb0VBQWtCO0FBQzFHLHdGQUF3RixvRUFBa0I7QUFDMUcsd0ZBQXdGLG9FQUFrQjtBQUMxRyx3RkFBd0Ysb0VBQWtCOztBQUUxRztBQUNBLDhDQUE4Qyw0REFBd0IsdUJBQXVCLDBFQUF3QjtBQUNySCx3Q0FBd0MsbUVBQVc7O0FBRW5EO0FBQ0EsNkJBQTZCLG1EQUFTOztBQUV0QztBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQsa0dBQWtHLEVBQUUsR0FBRyxvQkFBb0I7O0FBRTNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFVOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUZBQW1GLHlCQUF5Qix3QkFBd0Isd0JBQXdCO0FBQzVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsb0VBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdFQUFtQjs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIsbURBQVM7QUFDdEMsNkJBQTZCLG1EQUFTOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQsK0ZBQStGLEVBQUUsR0FBRyxnQkFBZ0I7QUFDcEg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxpRUFBVTs7QUFFNUM7QUFDQTtBQUNBLGtDQUFrQyxtRUFBVzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLG1EQUFTO0FBQ3RDLDhCQUE4QixtREFBUzs7QUFFdkM7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQsZ0dBQWdHLEVBQUUsR0FBRyxvQkFBb0I7O0FBRXpIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFVOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsaUVBQVU7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIsbURBQVM7QUFDdEMsOEJBQThCLG1EQUFTOztBQUV2QztBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRCxnR0FBZ0csRUFBRSxHQUFHLG9CQUFvQjs7QUFFekg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxpRUFBVTs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsaUVBQVU7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsb0VBQVc7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0VBQW1CO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUzs7QUFFckQ7QUFDQSxnRkFBZ0Ysb0VBQWtCO0FBQ2xHLGdGQUFnRixvRUFBa0I7QUFDbEcsZ0ZBQWdGLG9FQUFrQjtBQUNsRyxnRkFBZ0Ysb0VBQWtCO0FBQ2xHLGdGQUFnRixvRUFBa0I7O0FBRWxHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0VBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsb0ZBQW9GLG9FQUFrQjs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZHQUE2RyxHQUFHO0FBQ2hIO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZHQUE2RyxHQUFHO0FBQ2hIO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQVU7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZHQUE2RyxHQUFHO0FBQ2hIO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsaUVBQVU7QUFDdEM7QUFDQTs7QUFFQSxxQkFBcUIsaUVBQVU7QUFDL0I7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixpRUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQix3RUFBbUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsaUVBQVU7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFLHVCQUF1QjtBQUNqRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlFQUFVO0FBQ3RDO0FBQ0E7O0FBRUEscUJBQXFCLGlFQUFVO0FBQy9CO0FBQ0E7O0FBRUEscUJBQXFCLGlFQUFVO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGlFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGlFQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzRUFBc0UsR0FBRyxVQUFVLEdBQUcsYUFBYSxHQUFHO0FBQ3RHOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3Byb3ZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIHd0bnNVdGlscyBmcm9tIFwiLi93dG5zX3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBCaWdCdWZmZXIsIFNjYWxhciwgdXRpbHMgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgeyBGRkxPTktfUFJPVE9DT0xfSUQgfSBmcm9tIFwiLi96a2V5X2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHtcbiAgICBaS0VZX0ZGX0FfTUFQX1NFQ1RJT04sXG4gICAgWktFWV9GRl9BRERJVElPTlNfU0VDVElPTixcbiAgICBaS0VZX0ZGX0JfTUFQX1NFQ1RJT04sXG4gICAgWktFWV9GRl9DMF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfQ19NQVBfU0VDVElPTixcbiAgICBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04sXG4gICAgWktFWV9GRl9QVEFVX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RQ19TRUNUSU9OLFxuICAgIFpLRVlfRkZfUUxfU0VDVElPTixcbiAgICBaS0VZX0ZGX1FNX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RT19TRUNUSU9OLFxuICAgIFpLRVlfRkZfUVJfU0VDVElPTixcbiAgICBaS0VZX0ZGX1NJR01BMV9TRUNUSU9OLFxuICAgIFpLRVlfRkZfU0lHTUEyX1NFQ1RJT04sXG4gICAgWktFWV9GRl9TSUdNQTNfU0VDVElPTixcbn0gZnJvbSBcIi4vZmZsb25rX2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgS2VjY2FrMjU2VHJhbnNjcmlwdCB9IGZyb20gXCIuL0tlY2NhazI1NlRyYW5zY3JpcHQuanNcIjtcbmltcG9ydCB7IFByb29mIH0gZnJvbSBcIi4vcHJvb2YuanNcIjtcbmltcG9ydCB7IFBvbHlub21pYWwgfSBmcm9tIFwiLi9wb2x5bm9taWFsL3BvbHlub21pYWwuanNcIjtcbmltcG9ydCB7IEV2YWx1YXRpb25zIH0gZnJvbSBcIi4vcG9seW5vbWlhbC9ldmFsdWF0aW9ucy5qc1wiO1xuaW1wb3J0IHsgQ1BvbHlub21pYWwgfSBmcm9tIFwiLi9wb2x5bm9taWFsL2Nwb2x5bm9taWFsLmpzXCI7XG5cbmNvbnN0IHsgc3RyaW5naWZ5QmlnSW50cyB9ID0gdXRpbHM7XG5cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmZsb25rUHJvdmUoemtleUZpbGVOYW1lLCB3aXRuZXNzRmlsZU5hbWUsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFBST1ZFUiBTVEFSVEVEXCIpO1xuXG4gICAgLy8gUmVhZCB3aXRuZXNzIGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyB3aXRuZXNzIGZpbGVcIik7XG4gICAgY29uc3Qge1xuICAgICAgICBmZDogZmRXdG5zLFxuICAgICAgICBzZWN0aW9uczogd3Ruc1NlY3Rpb25zXG4gICAgfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh3aXRuZXNzRmlsZU5hbWUsIFwid3Ruc1wiLCAyLCAxIDw8IDI1LCAxIDw8IDIzKTtcbiAgICBjb25zdCB3dG5zID0gYXdhaXQgd3Ruc1V0aWxzLnJlYWRIZWFkZXIoZmRXdG5zLCB3dG5zU2VjdGlvbnMpO1xuXG4gICAgLy9SZWFkIHprZXkgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIHprZXkgZmlsZVwiKTtcbiAgICBjb25zdCB7XG4gICAgICAgIGZkOiBmZFpLZXksXG4gICAgICAgIHNlY3Rpb25zOiB6a2V5U2VjdGlvbnNcbiAgICB9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHprZXlGaWxlTmFtZSwgXCJ6a2V5XCIsIDIsIDEgPDwgMjUsIDEgPDwgMjMpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkWktleSwgemtleVNlY3Rpb25zLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHprZXkucHJvdG9jb2xJZCAhPT0gRkZMT05LX1BST1RPQ09MX0lEKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgZmZsb25rXCIpO1xuICAgIH1cblxuICAgIGlmICghU2NhbGFyLmVxKHprZXkuciwgd3Rucy5xKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJ2ZSBvZiB0aGUgd2l0bmVzcyBkb2VzIG5vdCBtYXRjaCB0aGUgY3VydmUgb2YgdGhlIHByb3Zpbmcga2V5XCIpO1xuICAgIH1cblxuICAgIGlmICh3dG5zLm5XaXRuZXNzICE9PSB6a2V5Lm5WYXJzIC0gemtleS5uQWRkaXRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3aXRuZXNzIGxlbmd0aC4gQ2lyY3VpdDogJHt6a2V5Lm5WYXJzfSwgd2l0bmVzczogJHt3dG5zLm5XaXRuZXNzfSwgJHt6a2V5Lm5BZGRpdGlvbnN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSB6a2V5LmN1cnZlO1xuXG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IHNGciA9IGN1cnZlLkZyLm44O1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjggKiAyO1xuICAgIGNvbnN0IHNEb21haW4gPSB6a2V5LmRvbWFpblNpemUgKiBzRnI7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCIgIEZGTE9OSyBQUk9WRSBTRVRUSU5HU1wiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ3VydmU6ICAgICAgICAgJHtjdXJ2ZS5uYW1lfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDaXJjdWl0IHBvd2VyOiAke3prZXkucG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIERvbWFpbiBzaXplOiAgICR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBWYXJzOiAgICAgICAgICAke3prZXkublZhcnN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFB1YmxpYyB2YXJzOiAgICR7emtleS5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDb25zdHJhaW50czogICAke3prZXkubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBBZGRpdGlvbnM6ICAgICAke3prZXkubkFkZGl0aW9uc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgIH1cblxuICAgIC8vUmVhZCB3aXRuZXNzIGRhdGFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyB3aXRuZXNzIGZpbGUgZGF0YVwiKTtcbiAgICBjb25zdCBidWZmV2l0bmVzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFd0bnMsIHd0bnNTZWN0aW9ucywgMik7XG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG5cbiAgICAvLyBGaXJzdCBlbGVtZW50IGluIHBsb25rIGlzIG5vdCB1c2VkIGFuZCBjYW4gYmUgYW55IHZhbHVlLiAoQnV0IGFsd2F5cyB0aGUgc2FtZSkuXG4gICAgLy8gV2Ugc2V0IGl0IHRvIHplcm8gdG8gZ28gZmFzdGVyIGluIHRoZSBleHBvbmVudGlhdGlvbnMuXG4gICAgYnVmZldpdG5lc3Muc2V0KEZyLnplcm8sIDApO1xuICAgIGNvbnN0IGJ1ZmZJbnRlcm5hbFdpdG5lc3MgPSBuZXcgQmlnQnVmZmVyKHprZXkubkFkZGl0aW9ucyAqIHNGcik7XG5cbiAgICBsZXQgYnVmZmVycyA9IHt9O1xuICAgIGxldCBwb2x5bm9taWFscyA9IHt9O1xuICAgIGxldCBldmFsdWF0aW9ucyA9IHt9O1xuXG4gICAgLy8gVG8gZGl2aWRlIHByaW1lIGZpZWxkcyB0aGUgRXh0ZW5kZWQgRXVjbGlkZWFuIEFsZ29yaXRobSBmb3IgY29tcHV0aW5nIG1vZHVsYXIgaW52ZXJzZXMgaXMgbmVlZGVkLlxuICAgIC8vIE5PVEU6IFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgY29tcHV0ZSAxL2Rlbm9taW5hdG9yIGFuZCB0aGVuIG11bHRpcGx5IGl0IGJ5IHRoZSBudW1lcmF0b3IuXG4gICAgLy8gVGhlIEV4dGVuZGVkIEV1Y2xpZGVhbiBBbGdvcml0aG0gaXMgZXhwZW5zaXZlIGluIHRlcm1zIG9mIGNvbXB1dGF0aW9uLlxuICAgIC8vIEZvciB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gZG8gbWFueSBtb2R1bGFyIGludmVyc2VzLCB0aGVyZSdzIGEgc2ltcGxlIG1hdGhlbWF0aWNhbCB0cmlja1xuICAgIC8vIHRoYXQgYWxsb3dzIHVzIHRvIGNvbXB1dGUgbWFueSBpbnZlcnNlcywgY2FsbGVkIE1vbnRnb21lcnkgYmF0Y2ggaW52ZXJzaW9uLlxuICAgIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly92aXRhbGlrLmNhL2dlbmVyYWwvMjAxOC8wNy8yMS9zdGFya3NfcGFydF8zLmh0bWxcbiAgICAvLyBNb250Z29tZXJ5IGJhdGNoIGludmVyc2lvbiByZWR1Y2VzIHRoZSBuIGludmVyc2UgY29tcHV0YXRpb25zIHRvIGEgc2luZ2xlIG9uZVxuICAgIC8vIFRvIHNhdmUgdGhpcyAoc2luZ2xlKSBpbnZlcnNlIGNvbXB1dGF0aW9uIG9uLWNoYWluLCB3aWxsIGNvbXB1dGUgaXQgaW4gcHJvdmluZyB0aW1lIGFuZCBzZW5kIGl0IHRvIHRoZSB2ZXJpZmllci5cbiAgICAvLyBUaGUgdmVyaWZpZXIgd2lsbCBoYXZlIHRvIGNoZWNrOlxuICAgIC8vIDEpIHRoZSBkZW5vbWluYXRvciBpcyBjb3JyZWN0IG11bHRpcGx5aW5nIGJ5IGhpbXNlbGYgbm9uLWludmVydGVkIC0+IGEgKiAxL2EgPT0gMVxuICAgIC8vIDIpIGNvbXB1dGUgdGhlIHJlc3Qgb2YgdGhlIGRlbm9taW5hdG9ycyB1c2luZyB0aGUgTW9udGdvbWVyeSBiYXRjaCBpbnZlcnNpb25cbiAgICAvLyBUaGUgaW52ZXJzaW9ucyBhcmU6XG4gICAgLy8gICDCtyBkZW5vbWluYXRvciBuZWVkZWQgaW4gc3RlcCA4IGFuZCA5IG9mIHRoZSB2ZXJpZmllciB0byBtdWx0aXBseSBieSAxL1pfSCh4aSlcbiAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiBzdGVwIDEwIGFuZCAxMSBvZiB0aGUgdmVyaWZpZXJcbiAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiB0aGUgdmVyaWZpZXIgd2hlbiBjb21wdXRpbmcgTF9pXntTMX0oWCkgYW5kIExfaV57UzJ9KFgpXG4gICAgLy8gICDCtyBMX2kgaT0xIHRvIG51bSBwdWJsaWMgaW5wdXRzLCBuZWVkZWQgaW4gc3RlcCA2IGFuZCA3IG9mIHRoZSB2ZXJpZmllciB0byBjb21wdXRlIExfMSh4aSkgYW5kIFBJKHhpKVxuICAgIGxldCB0b0ludmVyc2UgPSB7fTtcblxuICAgIGxldCBjaGFsbGVuZ2VzID0ge307XG4gICAgbGV0IHJvb3RzID0ge307XG5cbiAgICBsZXQgcHJvb2YgPSBuZXcgUHJvb2YoY3VydmUsIGxvZ2dlcik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgPiBSZWFkaW5nIFNlY3Rpb24gJHtaS0VZX0ZGX0FERElUSU9OU19TRUNUSU9OfS4gQWRkaXRpb25zYCk7XG4gICAgYXdhaXQgY2FsY3VsYXRlQWRkaXRpb25zKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgPiBSZWFkaW5nIFNlY3Rpb25zICR7WktFWV9GRl9TSUdNQTFfU0VDVElPTn0sJHtaS0VZX0ZGX1NJR01BMl9TRUNUSU9OfSwke1pLRVlfRkZfU0lHTUEzX1NFQ1RJT059LiBTaWdtYTEsIFNpZ21hMiAmIFNpZ21hIDNgKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBSZWFkaW5nIFNpZ21hIHBvbHlub21pYWxzIFwiKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTEgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTIgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTMgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWExLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1NJR01BMV9TRUNUSU9OXVswXS5wKTtcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlNpZ21hMi5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTJfU0VDVElPTl1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5TaWdtYTMuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfU0lHTUEzX1NFQ1RJT05dWzBdLnApO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgUmVhZGluZyBTaWdtYSBldmFsdWF0aW9uc1wiKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTEgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgIGV2YWx1YXRpb25zLlNpZ21hMiA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgZXZhbHVhdGlvbnMuU2lnbWEzID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWExLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTFfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEyLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTJfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEzLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTNfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYD4gUmVhZGluZyBTZWN0aW9uICR7WktFWV9GRl9QVEFVX1NFQ1RJT059LiBQb3dlcnMgb2YgVGF1YCk7XG4gICAgY29uc3QgUFRhdSA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogMTYgKiBzRzEpO1xuICAgIC8vIGRvbWFpblNpemUgKiA5ICsgMTggPSBTUlMgbGVuZ3RoIGluIHRoZSB6a2V5IHNhdmVkIGluIHNldHVwIHByb2Nlc3MuXG4gICAgLy8gaXQgY29ycmVzcG9uZHMgdG8gdGhlIG1heGltdW0gU1JTIGxlbmd0aCBuZWVkZWQsIHNwZWNpZmljYWxseSB0byBjb21taXQgQzJcbiAgICAvLyBub3RpY2UgdGhhdCB0aGUgcmVzZXJ2ZWQgYnVmZmVycyBzaXplIGlzIHprZXkuZG9tYWluU2l6ZSAqIDE2ICogc0cxIGJlY2F1c2UgYSBwb3dlciBvZiB0d28gYnVmZmVyIHNpemUgaXMgbmVlZGVkXG4gICAgLy8gdGhlIHJlbWFpbmluZyBidWZmZXIgbm90IGZpbGxlZCBmcm9tIFNSUyBhcmUgc2V0IHRvIDBcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKFBUYXUsIDAsICh6a2V5LmRvbWFpblNpemUgKiA5ICsgMTgpICogc0cxLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9QVEFVX1NFQ1RJT05dWzBdLnApO1xuXG4gICAgLy8gU1RBUlQgRkZMT05LIFBST1ZFUiBQUk9UT0NPTFxuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCAxLiBDb21wdXRlIEMxKFgpIHBvbHlub21pYWxcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlwiKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgMVwiKTtcbiAgICBhd2FpdCByb3VuZDEoKTtcblxuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMDtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuUUw7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlFSO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5RTTtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuUU87XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlFDO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCAyLiBDb21wdXRlIEMyKFgpIHBvbHlub21pYWxcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgMlwiKTtcbiAgICBhd2FpdCByb3VuZDIoKTtcblxuICAgIGRlbGV0ZSBidWZmZXJzLkE7XG4gICAgZGVsZXRlIGJ1ZmZlcnMuQjtcbiAgICBkZWxldGUgYnVmZmVycy5DO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5BO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5CO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5DO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5TaWdtYTE7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlNpZ21hMjtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuU2lnbWEzO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5sYWdyYW5nZTE7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlo7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIC8vIFJPVU5EIDMuIENvbXB1dGUgb3BlbmluZyBldmFsdWF0aW9uc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBST1VORCAzXCIpO1xuICAgIGF3YWl0IHJvdW5kMygpO1xuXG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkE7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkM7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlo7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlQxO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuU2lnbWExO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5TaWdtYTI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlNpZ21hMztcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUUw7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlFSO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5RTTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUUM7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlFPO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCA0LiBDb21wdXRlIFcoWCkgcG9seW5vbWlhbFxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBST1VORCA0XCIpO1xuICAgIGF3YWl0IHJvdW5kNCgpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCA1LiBDb21wdXRlIFcnKFgpIHBvbHlub21pYWxcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgNVwiKTtcbiAgICBhd2FpdCByb3VuZDUoKTtcblxuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5DMDtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuQzE7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkMyO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5SMTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUjI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkY7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkw7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlpUO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5aVFMyO1xuICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiaW52XCIsIGdldE1vbnRnb21lcnlCYXRjaGVkSW52ZXJzZSgpKTtcblxuICAgIC8vIFByZXBhcmUgcHJvb2ZcbiAgICBsZXQgX3Byb29mID0gcHJvb2YudG9PYmplY3RQcm9vZigpO1xuICAgIF9wcm9vZi5wcm90b2NvbCA9IFwiZmZsb25rXCI7XG4gICAgX3Byb29mLmN1cnZlID0gY3VydmUubmFtZTtcblxuICAgIC8vIFByZXBhcmUgcHVibGljIGlucHV0c1xuICAgIGxldCBwdWJsaWNTaWduYWxzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBzRnI7XG5cbiAgICAgICAgY29uc3QgcHViID0gYnVmZldpdG5lc3Muc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgcHVibGljU2lnbmFscy5wdXNoKFNjYWxhci5mcm9tUnByTEUocHViKSk7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgUFJPVkVSIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvb2Y6IHN0cmluZ2lmeUJpZ0ludHMoX3Byb29mKSxcbiAgICAgICAgcHVibGljU2lnbmFsczogc3RyaW5naWZ5QmlnSW50cyhwdWJsaWNTaWduYWxzKVxuICAgIH07XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVBZGRpdGlvbnMoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBhZGRpdGlvbnNcIik7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uc0J1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfRkZfQURESVRJT05TX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIHNpemVzOiB3aXJlSWRfeCA9IDQgYnl0ZXMgKDMyIGJpdHMpLCBmYWN0b3JfeCA9IGZpZWxkIHNpemUgYml0c1xuICAgICAgICAvLyBBZGRpdGlvbiBmb3JtOiB3aXJlSWRfYSB3aXJlSWRfYiBmYWN0b3JfYSBmYWN0b3JfYiAoc2l6ZSBpcyA0ICsgNCArIHNGciArIHNGcilcbiAgICAgICAgY29uc3Qgc1N1bSA9IDggKyBzRnIgKiAyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uQWRkaXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICBhZGRpdGlvbiAke2l9LyR7emtleS5uQWRkaXRpb25zfWApO1xuXG4gICAgICAgICAgICAvLyBSZWFkIGFkZGl0aW9uIHZhbHVlc1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IGkgKiBzU3VtO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWQxID0gcmVhZFVJbnQzMihhZGRpdGlvbnNCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZDIgPSByZWFkVUludDMyKGFkZGl0aW9uc0J1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcjEgPSBhZGRpdGlvbnNCdWZmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc0ZyKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzRnI7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IyID0gYWRkaXRpb25zQnVmZi5zbGljZShvZmZzZXQsIG9mZnNldCArIHNGcik7XG5cbiAgICAgICAgICAgIC8vIEdldCB3aXRuZXNzIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB3aXRuZXNzMSA9IGdldFdpdG5lc3Moc2lnbmFsSWQxKTtcbiAgICAgICAgICAgIGNvbnN0IHdpdG5lc3MyID0gZ2V0V2l0bmVzcyhzaWduYWxJZDIpO1xuXG4gICAgICAgICAgICAvL0NhbGN1bGF0ZSBmaW5hbCByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEZyLmFkZChGci5tdWwoZmFjdG9yMSwgd2l0bmVzczEpLCBGci5tdWwoZmFjdG9yMiwgd2l0bmVzczIpKTtcblxuICAgICAgICAgICAgYnVmZkludGVybmFsV2l0bmVzcy5zZXQocmVzdWx0LCBzRnIgKiBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRVSW50MzIoYiwgbykge1xuICAgICAgICBjb25zdCBidWZmID0gYi5zbGljZShvLCBvICsgNCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBidWZmVi5nZXRVaW50MzIoMCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2l0bmVzcyhpZHgpIHtcbiAgICAgICAgbGV0IGRpZmYgPSB6a2V5Lm5WYXJzIC0gemtleS5uQWRkaXRpb25zO1xuICAgICAgICBpZiAoaWR4IDwgZGlmZikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZXaXRuZXNzLnNsaWNlKGlkeCAqIHNGciwgaWR4ICogc0ZyICsgc0ZyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpZHggPCB6a2V5Lm5WYXJzKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoaWR4IC0gZGlmZikgKiBzRnI7XG4gICAgICAgICAgICByZXR1cm4gYnVmZkludGVybmFsV2l0bmVzcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHNGcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRnIuemVybztcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDEoKSB7XG4gICAgICAgIC8vIFNURVAgMS4xIC0gR2VuZXJhdGUgcmFuZG9tIGJsaW5kaW5nIHNjYWxhcnMgKGJfMSwgLi4uLCBiOSkg4oiIIEZcbiAgICAgICAgY2hhbGxlbmdlcy5iID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDk7IGkrKykge1xuICAgICAgICAgICAgY2hhbGxlbmdlcy5iW2ldID0gRnIucmFuZG9tKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDEuMiAtIENvbXB1dGUgd2lyZSBwb2x5bm9taWFscyBhKFgpLCBiKFgpIGFuZCBjKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgQSwgQiwgQyB3aXJlIHBvbHlub21pYWxzXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlV2lyZVBvbHlub21pYWxzKCk7XG5cbiAgICAgICAgLy8gU1RFUCAxLjMgLSBDb21wdXRlIHRoZSBxdW90aWVudCBwb2x5bm9taWFsIFQwKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVDAgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVQwKCk7XG5cbiAgICAgICAgLy8gU1RFUCAxLjQgLSBDb21wdXRlIHRoZSBGRlQtc3R5bGUgY29tYmluYXRpb24gcG9seW5vbWlhbCBDMShYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEMxIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVDMSgpO1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW0MxXV8xKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEMxIG11bHRpIGV4cG9uZW50aWF0aW9uXCIpO1xuICAgICAgICBsZXQgY29tbWl0QzEgPSBhd2FpdCBwb2x5bm9taWFscy5DMS5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiQzFcIik7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJDMVwiLCBjb21taXRDMSk7XG5cbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVdpcmVQb2x5bm9taWFscygpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IFJlYWRpbmcgZGF0YSBmcm9tIHprZXkgZmlsZVwiKTtcbiAgICAgICAgICAgIC8vIEJ1aWxkIEEsIEIgYW5kIEMgZXZhbHVhdGlvbnMgYnVmZmVyIGZyb20gemtleSBhbmQgd2l0bmVzcyBmaWxlc1xuICAgICAgICAgICAgYnVmZmVycy5BID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQiA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgICAgICBidWZmZXJzLkMgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuXG4gICAgICAgICAgICAvLyBSZWFkIHprZXkgc2VjdGlvbnMgYW5kIGZpbGwgdGhlIGJ1ZmZlcnNcbiAgICAgICAgICAgIGNvbnN0IGFNYXBCdWZmID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX0ZGX0FfTUFQX1NFQ1RJT04pO1xuICAgICAgICAgICAgY29uc3QgYk1hcEJ1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfRkZfQl9NQVBfU0VDVElPTik7XG4gICAgICAgICAgICBjb25zdCBjTWFwQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9GRl9DX01BUF9TRUNUSU9OKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBhbGwgd2l0bmVzcyBmcm9tIHNpZ25hbCBpZHMgYW5kIHNldCB0aGVtIHRvIEEsQiAmIEMgYnVmZmVyc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5Db25zdHJhaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpICogc0ZyO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiA0O1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBBIHZhbHVlIGZyb20gYSBzaWduYWwgaWRcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduYWxJZEEgPSByZWFkVUludDMyKGFNYXBCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuQS5zZXQoZ2V0V2l0bmVzcyhzaWduYWxJZEEpLCBpX3NGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIEIgdmFsdWUgZnJvbSBhIHNpZ25hbCBpZFxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkQiA9IHJlYWRVSW50MzIoYk1hcEJ1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5CLnNldChnZXRXaXRuZXNzKHNpZ25hbElkQiksIGlfc0ZyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgQyB2YWx1ZSBmcm9tIGEgc2lnbmFsIGlkXG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWRDID0gcmVhZFVJbnQzMihjTWFwQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBidWZmZXJzLkMuc2V0KGdldFdpdG5lc3Moc2lnbmFsSWRDKSwgaV9zRnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCbGluZCBhKFgpLCBiKFgpIGFuZCBjKFgpIHBvbHlub21pYWxzIGNvZWZmaWNpZW50cyB3aXRoIGJsaW5kaW5nIHNjYWxhcnMgYlxuICAgICAgICAgICAgYnVmZmVycy5BLnNldChjaGFsbGVuZ2VzLmJbMV0sIHNEb21haW4gLSA2NCk7XG4gICAgICAgICAgICBidWZmZXJzLkEuc2V0KGNoYWxsZW5nZXMuYlsyXSwgc0RvbWFpbiAtIDMyKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQi5zZXQoY2hhbGxlbmdlcy5iWzNdLCBzRG9tYWluIC0gNjQpO1xuICAgICAgICAgICAgYnVmZmVycy5CLnNldChjaGFsbGVuZ2VzLmJbNF0sIHNEb21haW4gLSAzMik7XG4gICAgICAgICAgICBidWZmZXJzLkMuc2V0KGNoYWxsZW5nZXMuYls1XSwgc0RvbWFpbiAtIDY0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQy5zZXQoY2hhbGxlbmdlcy5iWzZdLCBzRG9tYWluIC0gMzIpO1xuXG4gICAgICAgICAgICBidWZmZXJzLkEgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkEpO1xuICAgICAgICAgICAgYnVmZmVycy5CID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZmVycy5CKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQyA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQyk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgd2lyZSBwb2x5bm9taWFscyBhKFgpLCBiKFgpIGFuZCBjKFgpIGZyb20gQSxCICYgQyBidWZmZXJzXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQSBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuQSA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuQSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQiBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuQiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuQiwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQyBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuQyA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuQywgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgZXh0ZW5kZWQgZXZhbHVhdGlvbnMgb2YgYShYKSwgYihYKSBhbmQgYyhYKSBwb2x5bm9taWFsc1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEEgZmZ0XCIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuQSA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkEsIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEIgZmZ0XCIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuQiA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkIsIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMgZmZ0XCIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuQyA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMsIDQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVzXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuQS5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5CLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkIgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkMuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQyBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlVDAoKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFJlYWRpbmcgc2VjdGlvbnMgJHtaS0VZX0ZGX1FMX1NFQ1RJT059LCAke1pLRVlfRkZfUVJfU0VDVElPTn1gICtcbiAgICAgICAgICAgICAgICBgLCAke1pLRVlfRkZfUU1fU0VDVElPTn0sICR7WktFWV9GRl9RT19TRUNUSU9OfSwgJHtaS0VZX0ZGX1FDX1NFQ1RJT059LiBRIHNlbGVjdG9yc2ApO1xuICAgICAgICAgICAgLy8gUmVzZXJ2ZSBtZW1vcnkgZm9yIFEncyBldmFsdWF0aW9uc1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuUUwgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuUVIgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuUU0gPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuUU8gPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuUUMgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBSZWFkIFEncyBldmFsdWF0aW9ucyBmcm9tIHprZXkgZmlsZVxuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTC5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUUxfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RUi5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUVJfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTS5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUU1fU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTy5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUU9fU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RQy5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfRkZfUUNfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuXG4gICAgICAgICAgICAvLyBSZWFkIExhZ3JhbmdlIHBvbHlub21pYWxzICYgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgICAgIGNvbnN0IGxhZ3JhbmdlUG9seW5vbWlhbHMgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfRkZfTEFHUkFOR0VfU0VDVElPTik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5sYWdyYW5nZTEgPSBuZXcgRXZhbHVhdGlvbnMobGFncmFuZ2VQb2x5bm9taWFscywgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIFJlc2VydmUgbWVtb3J5IGZvciBidWZmZXJzIFQwXG4gICAgICAgICAgICBidWZmZXJzLlQwID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMCBldmFsdWF0aW9uc1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplICogNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgICAgVDAgZXZhbHVhdGlvbiAke2l9LyR7emtleS5kb21haW5TaXplICogNH1gKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCByZWxhdGVkIGV2YWx1YXRpb25zIHRvIGNvbXB1dGUgY3VycmVudCBUMCBldmFsdWF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGV2YWx1YXRpb25zLkEuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gZXZhbHVhdGlvbnMuQi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBldmFsdWF0aW9ucy5DLmdldEV2YWx1YXRpb24oaSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBxbCA9IGV2YWx1YXRpb25zLlFMLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcXIgPSBldmFsdWF0aW9ucy5RUi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFtID0gZXZhbHVhdGlvbnMuUU0uZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxbyA9IGV2YWx1YXRpb25zLlFPLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcWMgPSBldmFsdWF0aW9ucy5RQy5nZXRFdmFsdWF0aW9uKGkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBjdXJyZW50IHB1YmxpYyBpbnB1dFxuICAgICAgICAgICAgICAgIGxldCBwaSA9IEZyLnplcm87XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB6a2V5Lm5QdWJsaWM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoaiAqIDUgKiB6a2V5LmRvbWFpblNpemUpICsgemtleS5kb21haW5TaXplICsgaTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsUG9sID0gZXZhbHVhdGlvbnMubGFncmFuZ2UxLmdldEV2YWx1YXRpb24ob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVZhbCA9IGJ1ZmZlcnMuQS5zbGljZShqICogc0ZyLCAoaiArIDEpICogc0ZyKTtcblxuICAgICAgICAgICAgICAgICAgICBwaSA9IEZyLnN1YihwaSwgRnIubXVsKGxQb2wsIGFWYWwpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL1QwKFgpID0gW3FfTChYKcK3YShYKSArIHFfUihYKcK3YihYKSArIHFfTShYKcK3YShYKcK3YihYKSArIHFfTyhYKcK3YyhYKSArIHFfQyhYKSArIFBJKFgpXSDCtyAxL1pfSChYKVxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgZmlyc3QgVDAoWCnCt1pfSChYKSwgc28gZGl2aWRlIGxhdGVyIHRoZSByZXN1bHRpbmcgcG9seW5vbWlhbCBieSBaX0goWClcbiAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIDEgLT4gcV9MKFgpwrdhKFgpXG4gICAgICAgICAgICAgICAgY29uc3QgZTEgPSBGci5tdWwoYSwgcWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiAyIC0+IHFfUihYKcK3YihYKVxuICAgICAgICAgICAgICAgIGNvbnN0IGUyID0gRnIubXVsKGIsIHFyKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gMyAtPiBxX00oWCnCt2EoWCnCt2IoWClcbiAgICAgICAgICAgICAgICBjb25zdCBlMyA9IEZyLm11bChGci5tdWwoYSwgYiksIHFtKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gNCAtPiBxX08oWCnCt2MoWClcbiAgICAgICAgICAgICAgICBjb25zdCBlNCA9IEZyLm11bChjLCBxbyk7XG5cbiAgICAgICAgICAgICAgICAvLyB0MCA9IGV4cHJlc3Npb25zIDEgKyBleHByZXNzaW9uIDIgKyBleHByZXNzaW9uIDMgKyBleHByZXNzaW9uIDQgKyBxYyArIHBpXG4gICAgICAgICAgICAgICAgY29uc3QgdDAgPSBGci5hZGQoZTEsIEZyLmFkZChlMiwgRnIuYWRkKGUzLCBGci5hZGQoZTQsIEZyLmFkZChxYywgcGkpKSkpKTtcblxuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuVDAuc2V0KHQwLCBpICogc0ZyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJidWZmZXIgVDA6IFwiICsgYnVmZmVycy5UMC5ieXRlTGVuZ3RoIC8gc0ZyKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQwKFgpIGZyb20gYnVmZmVycy5UMFxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQwIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMCA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDAsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlQwIGxlbmd0aDogXCIgKyBwb2x5bm9taWFscy5UMC5sZW5ndGgoKSk7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlQwIGRlZ3JlZTogXCIgKyBwb2x5bm9taWFscy5UMC5kZWdyZWUoKSk7XG5cbiAgICAgICAgICAgIC8vIERpdmlkZSB0aGUgcG9seW5vbWlhbCBUMCBieSBaX0goWClcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMCAvIFpIXCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDAuZGl2QnlaZXJvZmllcih6a2V5LmRvbWFpblNpemUsIEZyLm9uZSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlQwLmRlZ3JlZSgpID49IDIgKiB6a2V5LmRvbWFpblNpemUgLSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUMCBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWQgKGRlZ3JlZSBpcyAke3BvbHlub21pYWxzLlQwLmRlZ3JlZSgpfSBhbmQgbXVzdCBiZSBsZXNzIHRoYW4gJHsyICogemtleS5kb21haW5TaXplICsgMn1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuVDA7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlQzEoKSB7XG4gICAgICAgICAgICBsZXQgQzEgPSBuZXcgQ1BvbHlub21pYWwoNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBDMS5hZGRQb2x5bm9taWFsKDAsIHBvbHlub21pYWxzLkEpO1xuICAgICAgICAgICAgQzEuYWRkUG9seW5vbWlhbCgxLCBwb2x5bm9taWFscy5CKTtcbiAgICAgICAgICAgIEMxLmFkZFBvbHlub21pYWwoMiwgcG9seW5vbWlhbHMuQyk7XG4gICAgICAgICAgICBDMS5hZGRQb2x5bm9taWFsKDMsIHBvbHlub21pYWxzLlQwKTtcblxuICAgICAgICAgICAgcG9seW5vbWlhbHMuQzEgPSBDMS5nZXRQb2x5bm9taWFsKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkMxLmRlZ3JlZSgpID49IDggKiB6a2V5LmRvbWFpblNpemUgLSA4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQzEgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQyKCkge1xuICAgICAgICAvLyBTVEVQIDIuMSAtIENvbXB1dGUgcGVybXV0YXRpb24gY2hhbGxlbmdlIGJldGEgYW5kIGdhbW1hIOKIiCBGXG4gICAgICAgIC8vIENvbXB1dGUgcGVybXV0YXRpb24gY2hhbGxlbmdlIGJldGFcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBjaGFsbGVuZ2VzIGJldGEgYW5kIGdhbW1hXCIpO1xuICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuXG4gICAgICAgIC8vIEFkZCBDMCB0byB0aGUgdHJhbnNjcmlwdFxuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5DMCk7XG5cbiAgICAgICAgLy8gQWRkIEEgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoYnVmZmVycy5BLnNsaWNlKGkgKiBzRnIsIGkgKiBzRnIgKyBzRnIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBDMSB0byB0aGUgdHJhbnNjcmlwdFxuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIkMxXCIpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLmJldGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmJldGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5iZXRhKSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBwZXJtdXRhdGlvbiBjaGFsbGVuZ2UgZ2FtbWFcbiAgICAgICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmJldGEpO1xuICAgICAgICBjaGFsbGVuZ2VzLmdhbW1hID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5nYW1tYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmdhbW1hKSk7XG5cbiAgICAgICAgLy8gU1RFUCAyLjIgLSBDb21wdXRlIHBlcm11dGF0aW9uIHBvbHlub21pYWwgeihYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFogcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVooKTtcblxuICAgICAgICAvLyBTVEVQIDIuMyAtIENvbXB1dGUgcXVvdGllbnQgcG9seW5vbWlhbCBUMShYKSBhbmQgVDIoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBUMSBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlVDEoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBUMiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlVDIoKTtcblxuICAgICAgICAvLyBTVEVQIDIuNCAtIENvbXB1dGUgdGhlIEZGVC1zdHlsZSBjb21iaW5hdGlvbiBwb2x5bm9taWFsIEMyKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgQzIgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZUMyKCk7XG5cbiAgICAgICAgLy8gVGhlIHNlY29uZCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW0MyXV8xKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEMyIG11bHRpIGV4cG9uZW50aWF0aW9uXCIpO1xuICAgICAgICBsZXQgY29tbWl0QzIgPSBhd2FpdCBwb2x5bm9taWFscy5DMi5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiQzJcIik7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJDMlwiLCBjb21taXRDMik7XG5cbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVooKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgWiBldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICAgICAgbGV0IG51bUFyciA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgICAgICBsZXQgZGVuQXJyID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBmaXJzdCB2YWx1ZXMgdG8gMVxuICAgICAgICAgICAgbnVtQXJyLnNldChGci5vbmUsIDApO1xuICAgICAgICAgICAgZGVuQXJyLnNldChGci5vbmUsIDApO1xuXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCBvbWVnYVxuICAgICAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgIFogZXZhbHVhdGlvbiAke2l9LyR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIHNGcjtcblxuICAgICAgICAgICAgICAgIC8vIFooWCkgOj0gbnVtQXJyIC8gZGVuQXJyXG4gICAgICAgICAgICAgICAgLy8gbnVtQXJyIDo9IChhICsgYmV0YcK3z4kgKyBnYW1tYSkoYiArIGJldGHCt8+JwrdrMSArIGdhbW1hKShjICsgYmV0YcK3z4nCt2syICsgZ2FtbWEpXG4gICAgICAgICAgICAgICAgY29uc3QgYmV0YXcgPSBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCB3KTtcblxuICAgICAgICAgICAgICAgIGxldCBudW0xID0gYnVmZmVycy5BLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgbnVtMSA9IEZyLmFkZChudW0xLCBiZXRhdyk7XG4gICAgICAgICAgICAgICAgbnVtMSA9IEZyLmFkZChudW0xLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBudW0yID0gYnVmZmVycy5CLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgbnVtMiA9IEZyLmFkZChudW0yLCBGci5tdWwoemtleS5rMSwgYmV0YXcpKTtcbiAgICAgICAgICAgICAgICBudW0yID0gRnIuYWRkKG51bTIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG51bTMgPSBidWZmZXJzLkMuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBudW0zID0gRnIuYWRkKG51bTMsIEZyLm11bCh6a2V5LmsyLCBiZXRhdykpO1xuICAgICAgICAgICAgICAgIG51bTMgPSBGci5hZGQobnVtMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgbnVtID0gRnIubXVsKG51bTEsIEZyLm11bChudW0yLCBudW0zKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBkZW5BcnIgOj0gKGEgKyBiZXRhwrdzaWdtYTEgKyBnYW1tYSkoYiArIGJldGHCt3NpZ21hMiArIGdhbW1hKShjICsgYmV0YcK3c2lnbWEzICsgZ2FtbWEpXG4gICAgICAgICAgICAgICAgbGV0IGRlbjEgPSBidWZmZXJzLkEuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBkZW4xID0gRnIuYWRkKGRlbjEsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGV2YWx1YXRpb25zLlNpZ21hMS5nZXRFdmFsdWF0aW9uKGkgKiA0KSkpO1xuICAgICAgICAgICAgICAgIGRlbjEgPSBGci5hZGQoZGVuMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZGVuMiA9IGJ1ZmZlcnMuQi5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIGRlbjIgPSBGci5hZGQoZGVuMiwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgZXZhbHVhdGlvbnMuU2lnbWEyLmdldEV2YWx1YXRpb24oaSAqIDQpKSk7XG4gICAgICAgICAgICAgICAgZGVuMiA9IEZyLmFkZChkZW4yLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBkZW4zID0gYnVmZmVycy5DLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgZGVuMyA9IEZyLmFkZChkZW4zLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBldmFsdWF0aW9ucy5TaWdtYTMuZ2V0RXZhbHVhdGlvbihpICogNCkpKTtcbiAgICAgICAgICAgICAgICBkZW4zID0gRnIuYWRkKGRlbjMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGRlbiA9IEZyLm11bChkZW4xLCBGci5tdWwoZGVuMiwgZGVuMykpO1xuXG4gICAgICAgICAgICAgICAgLy8gTXVsdGlwbHkgY3VycmVudCBudW0gdmFsdWUgd2l0aCB0aGUgcHJldmlvdXMgb25lIHNhdmVkIGluIG51bUFyclxuICAgICAgICAgICAgICAgIG51bSA9IEZyLm11bChudW1BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKSwgbnVtKTtcbiAgICAgICAgICAgICAgICBudW1BcnIuc2V0KG51bSwgKChpICsgMSkgJSB6a2V5LmRvbWFpblNpemUpICogc0ZyKTtcblxuICAgICAgICAgICAgICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgZGVuIHZhbHVlIHdpdGggdGhlIHByZXZpb3VzIG9uZSBzYXZlZCBpbiBkZW5BcnJcbiAgICAgICAgICAgICAgICBkZW4gPSBGci5tdWwoZGVuQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGciksIGRlbik7XG4gICAgICAgICAgICAgICAgZGVuQXJyLnNldChkZW4sICgoaSArIDEpICUgemtleS5kb21haW5TaXplKSAqIHNGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBOZXh0IG9tZWdhXG4gICAgICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGludmVyc2Ugb2YgZGVuQXJyIHRvIGNvbXB1dGUgaW4gdGhlIG5leHQgY29tbWFuZCB0aGVcbiAgICAgICAgICAgIC8vIGRpdmlzaW9uIG51bUFyci9kZW5BcnIgYnkgbXVsdGlwbHlpbmcgbnVtIMK3IDEvZGVuQXJyXG4gICAgICAgICAgICBkZW5BcnIgPSBhd2FpdCBGci5iYXRjaEludmVyc2UoZGVuQXJyKTtcblxuICAgICAgICAgICAgLy8gVE9ETzogRG8gaXQgaW4gYXNzZW1ibHkgYW5kIGluIHBhcmFsbGVsXG4gICAgICAgICAgICAvLyBNdWx0aXBseSBudW1BcnIgwrcgZGVuQXJyIHdoZXJlIGRlbkFyciB3YXMgaW52ZXJ0ZWQgaW4gdGhlIHByZXZpb3VzIGNvbW1hbmRcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBzRnI7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB6ID0gRnIubXVsKG51bUFyci5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpLCBkZW5BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKSk7XG4gICAgICAgICAgICAgICAgbnVtQXJyLnNldCh6LCBpX3NGcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGcm9tIG5vdyBvbiB0aGUgdmFsdWVzIHNhdmVkIG9uIG51bUFyciB3aWxsIGJlIFooWCkgYnVmZmVyXG4gICAgICAgICAgICBidWZmZXJzLlogPSBudW1BcnI7XG5cbiAgICAgICAgICAgIGlmICghRnIuZXEobnVtQXJyLnNsaWNlKDAsIHNGciksIEZyLm9uZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3B5IGNvbnN0cmFpbnRzIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHBvbHlub21pYWwgY29lZmZpY2llbnRzIHooWCkgZnJvbSBidWZmZXJzLlpcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBaIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5aID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5aLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBleHRlbmRlZCBldmFsdWF0aW9ucyBvZiB6KFgpIHBvbHlub21pYWxcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBaIGZmdFwiKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLlogPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5aLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQmxpbmQgeihYKSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cyB3aXRoIGJsaW5kaW5nIHNjYWxhcnMgYlxuICAgICAgICAgICAgcG9seW5vbWlhbHMuWi5ibGluZENvZWZmaWNpZW50cyhbY2hhbGxlbmdlcy5iWzldLCBjaGFsbGVuZ2VzLmJbOF0sIGNoYWxsZW5nZXMuYls3XV0pO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5aLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSArIDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJaIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuWjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVUMSgpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMSBldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICAgICAgYnVmZmVycy5UMSA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDIpO1xuICAgICAgICAgICAgYnVmZmVycy5UMXogPSBuZXcgQmlnQnVmZmVyKHNEb21haW4gKiAyKTtcblxuICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgb21lZ2FcbiAgICAgICAgICAgIGxldCBvbWVnYSA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplICogMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgIFQxIGV2YWx1YXRpb24gJHtpfS8ke3prZXkuZG9tYWluU2l6ZSAqIDR9YCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvbWVnYTIgPSBGci5zcXVhcmUob21lZ2EpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IGV2YWx1YXRpb25zLlouZ2V0RXZhbHVhdGlvbihpICogMik7XG4gICAgICAgICAgICAgICAgY29uc3QgenAgPSBGci5hZGQoRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJbN10sIG9tZWdhMiksIEZyLm11bChjaGFsbGVuZ2VzLmJbOF0sIG9tZWdhKSksIGNoYWxsZW5nZXMuYls5XSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUMShYKSA6PSAoeihYKSAtIDEpIMK3IExfMShYKVxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgZmlyc3QgVDEoWCnCt1pfSChYKSwgc28gZGl2aWRlIGxhdGVyIHRoZSByZXN1bHRpbmcgcG9seW5vbWlhbCBieSBaX0goWClcbiAgICAgICAgICAgICAgICBjb25zdCBsYWdyYW5nZTEgPSBldmFsdWF0aW9ucy5sYWdyYW5nZTEuZ2V0RXZhbHVhdGlvbih6a2V5LmRvbWFpblNpemUgKyBpICogMik7XG4gICAgICAgICAgICAgICAgbGV0IHQxID0gRnIubXVsKEZyLnN1Yih6LCBGci5vbmUpLCBsYWdyYW5nZTEpO1xuICAgICAgICAgICAgICAgIGxldCB0MXogPSBGci5tdWwoenAsIGxhZ3JhbmdlMSk7XG5cbiAgICAgICAgICAgICAgICBidWZmZXJzLlQxLnNldCh0MSwgaSAqIHNGcik7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5UMXouc2V0KHQxeiwgaSAqIHNGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgb21lZ2FcbiAgICAgICAgICAgICAgICBvbWVnYSA9IEZyLm11bChvbWVnYSwgRnIud1t6a2V5LnBvd2VyICsgMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVDEoWCkgZnJvbSBidWZmZXJzLlQxXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDEgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQxID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5UMSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIERpdmlkZSB0aGUgcG9seW5vbWlhbCBUMSBieSBaX0goWClcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQxLmRpdkJ5WmVyb2ZpZXIoemtleS5kb21haW5TaXplLCBGci5vbmUpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVDF6KFgpIGZyb20gYnVmZmVycy5UMXpcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMXogaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQxeiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDF6LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBwb2x5bm9taWFsIFQxeiB0byBUMSB0byBnZXQgdGhlIGZpbmFsIHBvbHlub21pYWwgVDFcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQxLmFkZChwb2x5bm9taWFscy5UMXopO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5UMS5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUgKyAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVDEgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5UMTtcbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlQxejtcbiAgICAgICAgICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMXo7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlVDIoKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDIgZXZhbHVhdGlvbnNcIik7XG5cbiAgICAgICAgICAgIGJ1ZmZlcnMuVDIgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuVDJ6ID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIG9tZWdhXG4gICAgICAgICAgICBsZXQgb21lZ2EgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZSAqIDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICBUMiBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemUgKiA0fWApO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb21lZ2EyID0gRnIuc3F1YXJlKG9tZWdhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbWVnYVcgPSBGci5tdWwob21lZ2EsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9tZWdhVzIgPSBGci5zcXVhcmUob21lZ2FXKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBldmFsdWF0aW9ucy5BLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGV2YWx1YXRpb25zLkIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gZXZhbHVhdGlvbnMuQy5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgelcgPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oKHprZXkuZG9tYWluU2l6ZSAqIDQgKyA0ICsgaSkgJSAoemtleS5kb21haW5TaXplICogNCkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgenAgPSBGci5hZGQoRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJbN10sIG9tZWdhMiksIEZyLm11bChjaGFsbGVuZ2VzLmJbOF0sIG9tZWdhKSksIGNoYWxsZW5nZXMuYls5XSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeldwID0gRnIuYWRkKEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iWzddLCBvbWVnYVcyKSwgRnIubXVsKGNoYWxsZW5nZXMuYls4XSwgb21lZ2FXKSksIGNoYWxsZW5nZXMuYls5XSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaWdtYTEgPSBldmFsdWF0aW9ucy5TaWdtYTEuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWdtYTIgPSBldmFsdWF0aW9ucy5TaWdtYTIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWdtYTMgPSBldmFsdWF0aW9ucy5TaWdtYTMuZ2V0RXZhbHVhdGlvbihpKTtcblxuICAgICAgICAgICAgICAgIC8vIFQyKFgpIDo9IFsgKGEoWCkgKyBiZXRhwrdYICsgZ2FtbWEpKGIoWCkgKyBiZXRhwrdrMcK3WCArIGdhbW1hKShjKFgpICsgYmV0YcK3azLCt1ggKyBnYW1tYSl6KFgpXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgIC0oYShYKSArIGJldGHCt3NpZ21hMShYKSArIGdhbW1hKShiKFgpICsgYmV0YcK3c2lnbWEyKFgpICsgZ2FtbWEpKGMoWCkgKyBiZXRhwrdzaWdtYTMoWCkgKyBnYW1tYSl6KFjPiSldIMK3IDEvWl9IKFgpXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBmaXJzdCBUMihYKcK3Wl9IKFgpLCBzbyBkaXZpZGUgbGF0ZXIgdGhlIHJlc3VsdGluZyBwb2x5bm9taWFsIGJ5IFpfSChYKVxuXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiAxIC0+IChhKFgpICsgYmV0YcK3WCArIGdhbW1hKShiKFgpICsgYmV0YcK3azHCt1ggKyBnYW1tYSkoYyhYKSArIGJldGHCt2sywrdYICsgZ2FtbWEpeihYKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJldGFYID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgb21lZ2EpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUxMSA9IEZyLmFkZChhLCBiZXRhWCk7XG4gICAgICAgICAgICAgICAgZTExID0gRnIuYWRkKGUxMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTEyID0gRnIuYWRkKGIsIEZyLm11bChiZXRhWCwgemtleS5rMSkpO1xuICAgICAgICAgICAgICAgIGUxMiA9IEZyLmFkZChlMTIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUxMyA9IEZyLmFkZChjLCBGci5tdWwoYmV0YVgsIHprZXkuazIpKTtcbiAgICAgICAgICAgICAgICBlMTMgPSBGci5hZGQoZTEzLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMSA9IEZyLm11bChGci5tdWwoRnIubXVsKGUxMSwgZTEyKSwgZTEzKSwgeik7XG4gICAgICAgICAgICAgICAgbGV0IGUxeiA9IEZyLm11bChGci5tdWwoRnIubXVsKGUxMSwgZTEyKSwgZTEzKSwgenApO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IFtlMSwgZTF6XSA9IE11bFoubXVsNChlMTEsIGUxMiwgZTEzLCB6LCBhcCwgYnAsIGNwLCB6cCwgaSAlIDQsIEZyKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gMiAtPiAoYShYKSArIGJldGHCt3NpZ21hMShYKSArIGdhbW1hKShiKFgpICsgYmV0YcK3c2lnbWEyKFgpICsgZ2FtbWEpKGMoWCkgKyBiZXRhwrdzaWdtYTMoWCkgKyBnYW1tYSl6KFjPiSlcbiAgICAgICAgICAgICAgICBsZXQgZTIxID0gRnIuYWRkKGEsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHNpZ21hMSkpO1xuICAgICAgICAgICAgICAgIGUyMSA9IEZyLmFkZChlMjEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUyMiA9IEZyLmFkZChiLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBzaWdtYTIpKTtcbiAgICAgICAgICAgICAgICBlMjIgPSBGci5hZGQoZTIyLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMjMgPSBGci5hZGQoYywgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgc2lnbWEzKSk7XG4gICAgICAgICAgICAgICAgZTIzID0gRnIuYWRkKGUyMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTIgPSBGci5tdWwoRnIubXVsKEZyLm11bChlMjEsIGUyMiksIGUyMyksIHpXKTtcbiAgICAgICAgICAgICAgICBsZXQgZTJ6ID0gRnIubXVsKEZyLm11bChGci5tdWwoZTIxLCBlMjIpLCBlMjMpLCB6V3ApO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IFtlMiwgZTJ6XSA9IE11bFoubXVsNChlMjEsIGUyMiwgZTIzLCB6VywgYXAsIGJwLCBjcCwgeldwLCBpICUgNCwgRnIpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHQyID0gRnIuc3ViKGUxLCBlMik7XG4gICAgICAgICAgICAgICAgbGV0IHQyeiA9IEZyLnN1YihlMXosIGUyeik7XG5cbiAgICAgICAgICAgICAgICBidWZmZXJzLlQyLnNldCh0MiwgaSAqIHNGcik7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5UMnouc2V0KHQyeiwgaSAqIHNGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgb21lZ2FcbiAgICAgICAgICAgICAgICBvbWVnYSA9IEZyLm11bChvbWVnYSwgRnIud1t6a2V5LnBvd2VyICsgMl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVDIoWCkgZnJvbSBidWZmZXJzLlQyXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDIgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQyID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5UMiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIERpdmlkZSB0aGUgcG9seW5vbWlhbCBUMiBieSBaX0goWClcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMiAvIFpIXCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDIuZGl2QnlaZXJvZmllcih6a2V5LmRvbWFpblNpemUsIEZyLm9uZSk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcG9seW5vbWlhbCBUMnooWCkgZnJvbSBidWZmZXJzLlQyelxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQyeiBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDJ6ID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5UMnosIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHBvbHlub21pYWwgVDJ6IHRvIFQyIHRvIGdldCB0aGUgZmluYWwgcG9seW5vbWlhbCBUMlxuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDIuYWRkKHBvbHlub21pYWxzLlQyeik7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlQyLmRlZ3JlZSgpID49IDMgKiB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUMiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlQyO1xuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuVDJ6O1xuICAgICAgICAgICAgZGVsZXRlIHBvbHlub21pYWxzLlQyejtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVDMigpIHtcbiAgICAgICAgICAgIGxldCBDMiA9IG5ldyBDUG9seW5vbWlhbCgzLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIEMyLmFkZFBvbHlub21pYWwoMCwgcG9seW5vbWlhbHMuWik7XG4gICAgICAgICAgICBDMi5hZGRQb2x5bm9taWFsKDEsIHBvbHlub21pYWxzLlQxKTtcbiAgICAgICAgICAgIEMyLmFkZFBvbHlub21pYWwoMiwgcG9seW5vbWlhbHMuVDIpO1xuXG4gICAgICAgICAgICBwb2x5bm9taWFscy5DMiA9IEMyLmdldFBvbHlub21pYWwoKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuQzIuZGVncmVlKCkgPj0gOSAqIHprZXkuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkMyIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMygpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBjaGFsbGVuZ2UgeGlcIik7XG4gICAgICAgIC8vIFNURVAgMy4xIC0gQ29tcHV0ZSBldmFsdWF0aW9uIGNoYWxsZW5nZSB4aSDiiIggU1xuICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJDMlwiKSk7XG5cbiAgICAgICAgLy8gT2J0YWluIGEgeGlfc2VlZGVyIGZyb20gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgLy8gVG8gZm9yY2UgaDFeNCA9IHhpLCBoMl4zID0geGkgYW5kIGhfM14yID0geGnPiVxuICAgICAgICAvLyB3ZSBjb21wdXRlIHhpID0geGlfc2VlZGVyXjEyLCBoMSA9IHhpX3NlZWRlcl4zLCBoMiA9IHhpX3NlZWRlcl40IGFuZCBoMyA9IHhpX3NlZWRlcl42XG4gICAgICAgIGNoYWxsZW5nZXMueGlTZWVkID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgY29uc3QgeGlTZWVkMiA9IEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpU2VlZCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBvbWVnYTgsIG9tZWdhNCBhbmQgb21lZ2EzXG4gICAgICAgIHJvb3RzLnc4ID0gW107XG4gICAgICAgIHJvb3RzLnc4WzBdID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgcm9vdHMudzhbaV0gPSBGci5tdWwocm9vdHMudzhbaSAtIDFdLCB6a2V5Lnc4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3RzLnc0ID0gW107XG4gICAgICAgIHJvb3RzLnc0WzBdID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgcm9vdHMudzRbaV0gPSBGci5tdWwocm9vdHMudzRbaSAtIDFdLCB6a2V5Lnc0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3RzLnczID0gW107XG4gICAgICAgIHJvb3RzLnczWzBdID0gRnIub25lO1xuICAgICAgICByb290cy53M1sxXSA9IHprZXkudzM7XG4gICAgICAgIHJvb3RzLnczWzJdID0gRnIuc3F1YXJlKHprZXkudzMpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgaDAgPSB4aVNlZWRlcl4zXG4gICAgICAgIHJvb3RzLlMwID0ge307XG4gICAgICAgIHJvb3RzLlMwLmgwdzggPSBbXTtcbiAgICAgICAgcm9vdHMuUzAuaDB3OFswXSA9IEZyLm11bCh4aVNlZWQyLCBjaGFsbGVuZ2VzLnhpU2VlZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICByb290cy5TMC5oMHc4W2ldID0gRnIubXVsKHJvb3RzLlMwLmgwdzhbMF0sIHJvb3RzLnc4W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgaDEgPSB4aV9zZWVkZXJeNlxuICAgICAgICByb290cy5TMSA9IHt9O1xuICAgICAgICByb290cy5TMS5oMXc0ID0gW107XG4gICAgICAgIHJvb3RzLlMxLmgxdzRbMF0gPSBGci5zcXVhcmUocm9vdHMuUzAuaDB3OFswXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICByb290cy5TMS5oMXc0W2ldID0gRnIubXVsKHJvb3RzLlMxLmgxdzRbMF0sIHJvb3RzLnc0W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgaDIgPSB4aV9zZWVkZXJeOFxuICAgICAgICByb290cy5TMiA9IHt9O1xuICAgICAgICByb290cy5TMi5oMnczID0gW107XG4gICAgICAgIHJvb3RzLlMyLmgydzNbMF0gPSBGci5tdWwocm9vdHMuUzEuaDF3NFswXSwgeGlTZWVkMik7XG4gICAgICAgIHJvb3RzLlMyLmgydzNbMV0gPSBGci5tdWwocm9vdHMuUzIuaDJ3M1swXSwgcm9vdHMudzNbMV0pO1xuICAgICAgICByb290cy5TMi5oMnczWzJdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHJvb3RzLnczWzJdKTtcblxuICAgICAgICByb290cy5TMi5oM3czID0gW107XG4gICAgICAgIC8vIE11bHRpcGx5IGgzIGJ5IHRoaXJkLXJvb3Qtb21lZ2EgdG8gb2J0YWluIGhfM14zID0geGnPiVxuICAgICAgICAvLyBTbywgaDMgPSB4aV9zZWVkZXJeOCDPiV57MS8zfVxuICAgICAgICByb290cy5TMi5oM3czWzBdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHprZXkud3IpO1xuICAgICAgICByb290cy5TMi5oM3czWzFdID0gRnIubXVsKHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLnczWzFdKTtcbiAgICAgICAgcm9vdHMuUzIuaDN3M1syXSA9IEZyLm11bChyb290cy5TMi5oM3czWzBdLCByb290cy53M1syXSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB4aSA9IHhpX3NlZWRlcl4yNFxuICAgICAgICBjaGFsbGVuZ2VzLnhpID0gRnIubXVsKEZyLnNxdWFyZShyb290cy5TMi5oMnczWzBdKSwgcm9vdHMuUzIuaDJ3M1swXSk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy54aTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnhpKSk7XG5cbiAgICAgICAgLy8gUmVzZXJ2ZSBtZW1vcnkgZm9yIFEncyBwb2x5bm9taWFsc1xuICAgICAgICBwb2x5bm9taWFscy5RTCA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RUiA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RTSA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RTyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RQyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIFJlYWQgUSdzIGV2YWx1YXRpb25zIGZyb20gemtleSBmaWxlXG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUUwuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfUUxfU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUVIuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfUVJfU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUU0uY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfUU1fU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUU8uY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfUU9fU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUUMuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfUUNfU0VDVElPTl1bMF0ucCk7XG5cbiAgICAgICAgLy8gU1RFUCAzLjIgLSBDb21wdXRlIG9wZW5pbmcgZXZhbHVhdGlvbnMgYW5kIGFkZCB0aGVtIHRvIHRoZSBwcm9vZiAodGhpcmQgb3V0cHV0IG9mIHRoZSBwcm92ZXIpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBldmFsdWF0aW9uc1wiKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInFsXCIsIHBvbHlub21pYWxzLlFMLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInFyXCIsIHBvbHlub21pYWxzLlFSLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInFtXCIsIHBvbHlub21pYWxzLlFNLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInFvXCIsIHBvbHlub21pYWxzLlFPLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInFjXCIsIHBvbHlub21pYWxzLlFDLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInMxXCIsIHBvbHlub21pYWxzLlNpZ21hMS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJzMlwiLCBwb2x5bm9taWFscy5TaWdtYTIuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiczNcIiwgcG9seW5vbWlhbHMuU2lnbWEzLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImFcIiwgcG9seW5vbWlhbHMuQS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJiXCIsIHBvbHlub21pYWxzLkIuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiY1wiLCBwb2x5bm9taWFscy5DLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInpcIiwgcG9seW5vbWlhbHMuWi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG5cbiAgICAgICAgY2hhbGxlbmdlcy54aXcgPSBGci5tdWwoY2hhbGxlbmdlcy54aSwgRnIud1t6a2V5LnBvd2VyXSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJ6d1wiLCBwb2x5bm9taWFscy5aLmV2YWx1YXRlKGNoYWxsZW5nZXMueGl3KSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJ0MXdcIiwgcG9seW5vbWlhbHMuVDEuZXZhbHVhdGUoY2hhbGxlbmdlcy54aXcpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInQyd1wiLCBwb2x5bm9taWFscy5UMi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpdykpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kNCgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBjaGFsbGVuZ2UgYWxwaGFcIik7XG4gICAgICAgIC8vIFNURVAgNC4xIC0gQ29tcHV0ZSBjaGFsbGVuZ2UgYWxwaGEg4oiIIEZcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy54aVNlZWQpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwicWxcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwicXJcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwicW1cIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwicW9cIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwicWNcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiczFcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiczJcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiczNcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiYVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJiXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImNcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwielwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJ6d1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJ0MXdcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwidDJ3XCIpKTtcbiAgICAgICAgY2hhbGxlbmdlcy5hbHBoYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuYWxwaGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5hbHBoYSkpO1xuXG4gICAgICAgIC8vIFNURVAgNC4yIC0gQ29tcHV0ZSBGKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIEMwIHBvbHlub21pYWxcIik7XG4gICAgICAgIHBvbHlub21pYWxzLkMwID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogOCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLkMwLmNvZWYsIDAsIHNEb21haW4gKiA4LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9DMF9TRUNUSU9OXVswXS5wKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFIwIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbXB1dGVSMCgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFIxIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbXB1dGVSMSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFIyIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbXB1dGVSMigpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgRiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlRigpO1xuXG4gICAgICAgIC8vIFRoZSBmb3VydGggb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtXMV1fMSksIHdoZXJlIFcxOj0oZi9aX3QpKHgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVzEgbXVsdGkgZXhwb25lbnRpYXRpb25cIik7XG4gICAgICAgIGxldCBjb21taXRXMSA9IGF3YWl0IHBvbHlub21pYWxzLkYubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlcxXCIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiVzFcIiwgY29tbWl0VzEpO1xuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSMCgpIHtcbiAgICAgICAgICAgIC8vIENPTVBVVEUgUjBcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiBSMChYKSBmcm9tIDggZXZhbHVhdGlvbnMgdXNpbmcgbGFncmFuZ2UgaW50ZXJwb2xhdGlvbi4gUjAoWCkg4oiIIEZfezw4fVtYXVxuICAgICAgICAgICAgLy8gV2UgZGVjaWRlIHRvIHVzZSBMYWdyYW5nZSBpbnRlcnBvbGF0aW9ucyBiZWNhdXNlIHRoZSBSMCBkZWdyZWUgaXMgdmVyeSBzbWFsbCAoZGVnKFIwKT09PTcpLFxuICAgICAgICAgICAgLy8gYW5kIHdlIHdlcmUgbm90IGFibGUgdG8gY29tcHV0ZSBpdCB1c2luZyBjdXJyZW50IGlmZnQgaW1wbGVtZW50YXRpb24gYmVjYXVzZSB0aGUgb21lZ2EgYXJlIGRpZmZlcmVudFxuICAgICAgICAgICAgcG9seW5vbWlhbHMuUjAgPSBQb2x5bm9taWFsLmxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oXG4gICAgICAgICAgICAgICAgW3Jvb3RzLlMwLmgwdzhbMF0sIHJvb3RzLlMwLmgwdzhbMV0sIHJvb3RzLlMwLmgwdzhbMl0sIHJvb3RzLlMwLmgwdzhbM10sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMwLmgwdzhbNF0sIHJvb3RzLlMwLmgwdzhbNV0sIHJvb3RzLlMwLmgwdzhbNl0sIHJvb3RzLlMwLmgwdzhbN11dLFxuICAgICAgICAgICAgICAgIFtwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzBdKSwgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFsxXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbMl0pLCBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzNdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFs0XSksIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbNV0pLFxuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzZdKSwgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFs3XSldLCBjdXJ2ZSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBkZWdyZWUgb2YgcjAoWCkgPCA4XG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuUjAuZGVncmVlKCkgPiA3KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUjAgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVIxKCkge1xuICAgICAgICAgICAgLy8gQ09NUFVURSBSMVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIFIxKFgpIGZyb20gNCBldmFsdWF0aW9ucyB1c2luZyBsYWdyYW5nZSBpbnRlcnBvbGF0aW9uLiBSMShYKSDiiIggRl97PDR9W1hdXG4gICAgICAgICAgICAvLyBXZSBkZWNpZGUgdG8gdXNlIExhZ3JhbmdlIGludGVycG9sYXRpb25zIGJlY2F1c2UgdGhlIFIxIGRlZ3JlZSBpcyB2ZXJ5IHNtYWxsIChkZWcoUjEpPT09MyksXG4gICAgICAgICAgICAvLyBhbmQgd2Ugd2VyZSBub3QgYWJsZSB0byBjb21wdXRlIGl0IHVzaW5nIGN1cnJlbnQgaWZmdCBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIHRoZSBvbWVnYSBhcmUgZGlmZmVyZW50XG4gICAgICAgICAgICBwb2x5bm9taWFscy5SMSA9IFBvbHlub21pYWwubGFncmFuZ2VQb2x5bm9taWFsSW50ZXJwb2xhdGlvbihcbiAgICAgICAgICAgICAgICBbcm9vdHMuUzEuaDF3NFswXSwgcm9vdHMuUzEuaDF3NFsxXSwgcm9vdHMuUzEuaDF3NFsyXSwgcm9vdHMuUzEuaDF3NFszXV0sXG4gICAgICAgICAgICAgICAgW3BvbHlub21pYWxzLkMxLmV2YWx1YXRlKHJvb3RzLlMxLmgxdzRbMF0pLCBwb2x5bm9taWFscy5DMS5ldmFsdWF0ZShyb290cy5TMS5oMXc0WzFdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzEuZXZhbHVhdGUocm9vdHMuUzEuaDF3NFsyXSksIHBvbHlub21pYWxzLkMxLmV2YWx1YXRlKHJvb3RzLlMxLmgxdzRbM10pXSwgY3VydmUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgZGVncmVlIG9mIHIxKFgpIDwgNFxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlIxLmRlZ3JlZSgpID4gMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlIxIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSMigpIHtcbiAgICAgICAgICAgIC8vIENPTVBVVEUgUjJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiByMihYKSBmcm9tIDYgZXZhbHVhdGlvbnMgdXNpbmcgbGFncmFuZ2UgaW50ZXJwb2xhdGlvbi4gcjIoWCkg4oiIIEZfezw2fVtYXVxuICAgICAgICAgICAgLy8gV2UgZGVjaWRlIHRvIHVzZSBMYWdyYW5nZSBpbnRlcnBvbGF0aW9ucyBiZWNhdXNlIHRoZSBSMi5kZWdyZWUgaXMgdmVyeSBzbWFsbCAoZGVnKFIyKT09PTUpLFxuICAgICAgICAgICAgLy8gYW5kIHdlIHdlcmUgbm90IGFibGUgdG8gY29tcHV0ZSBpdCB1c2luZyBjdXJyZW50IGlmZnQgaW1wbGVtZW50YXRpb24gYmVjYXVzZSB0aGUgb21lZ2EgYXJlIGRpZmZlcmVudFxuICAgICAgICAgICAgcG9seW5vbWlhbHMuUjIgPSBQb2x5bm9taWFsLmxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oXG4gICAgICAgICAgICAgICAgW3Jvb3RzLlMyLmgydzNbMF0sIHJvb3RzLlMyLmgydzNbMV0sIHJvb3RzLlMyLmgydzNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLlMyLmgzdzNbMV0sIHJvb3RzLlMyLmgzdzNbMl1dLFxuICAgICAgICAgICAgICAgIFtwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oMnczWzBdKSwgcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDJ3M1sxXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgydzNbMl0pLCBwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oM3czWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDN3M1sxXSksIHBvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgzdzNbMl0pXSwgY3VydmUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgZGVncmVlIG9mIHIyKFgpIDwgNlxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlIyLmRlZ3JlZSgpID4gNSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlIyIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVGKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEYgcG9seW5vbWlhbFwiKTtcblxuICAgICAgICAgICAgLy8gQ09NUFVURSBGKFgpXG4gICAgICAgICAgICBwb2x5bm9taWFscy5GID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DMCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLnN1Yihwb2x5bm9taWFscy5SMCk7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLmRpdkJ5WmVyb2ZpZXIoOCwgY2hhbGxlbmdlcy54aSk7XG5cbiAgICAgICAgICAgIGxldCBmMiA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzEsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZjIuc3ViKHBvbHlub21pYWxzLlIxKTtcbiAgICAgICAgICAgIGYyLm11bFNjYWxhcihjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICAgICAgICAgIGYyLmRpdkJ5WmVyb2ZpZXIoNCwgY2hhbGxlbmdlcy54aSk7XG5cbiAgICAgICAgICAgIGxldCBmMyA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzIsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZjMuc3ViKHBvbHlub21pYWxzLlIyKTtcbiAgICAgICAgICAgIGYzLm11bFNjYWxhcihGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSkpO1xuICAgICAgICAgICAgZjMuZGl2QnlaZXJvZmllcigzLCBjaGFsbGVuZ2VzLnhpKTtcbiAgICAgICAgICAgIGYzLmRpdkJ5WmVyb2ZpZXIoMywgY2hhbGxlbmdlcy54aXcpO1xuXG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLmFkZChmMik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLmFkZChmMyk7XG5cbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5GLmRlZ3JlZSgpID49IDkgKiB6a2V5LmRvbWFpblNpemUgLSA2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDUoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIHlcIik7XG5cbiAgICAgICAgLy8gU1RFUCA1LjEgLSBDb21wdXRlIHJhbmRvbSBldmFsdWF0aW9uIHBvaW50IHkg4oiIIEZcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5hbHBoYSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiVzFcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMueSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMueTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnkpKTtcblxuICAgICAgICAvLyBTVEVQIDUuMiAtIENvbXB1dGUgTChYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEwgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZUwoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFpUUzIgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVpUUzIoKTtcblxuICAgICAgICBsZXQgWlRTMlkgPSBwb2x5bm9taWFscy5aVFMyLmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG4gICAgICAgIFpUUzJZID0gRnIuaW52KFpUUzJZKTtcbiAgICAgICAgcG9seW5vbWlhbHMuTC5tdWxTY2FsYXIoWlRTMlkpO1xuXG4gICAgICAgIGNvbnN0IHBvbERpdmlkZW5kID0gUG9seW5vbWlhbC5mcm9tQ29lZmZpY2llbnRzQXJyYXkoW0ZyLm5lZyhjaGFsbGVuZ2VzLnkpLCBGci5vbmVdLCBjdXJ2ZSk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVycgPSBMIC8gWlRTMiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb25zdCBwb2xSZW1haW5kZXIgPSBwb2x5bm9taWFscy5MLmRpdkJ5KHBvbERpdmlkZW5kKTtcblxuICAgICAgICAvL0NoZWNrIHBvbFJlbWluZGVyIGRlZ3JlZSBpcyBlcXVhbCB0byB6ZXJvXG4gICAgICAgIGlmIChwb2xSZW1haW5kZXIuZGVncmVlKCkgPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlZ3JlZSBvZiBMKFgpLyhaVFMyKHkpKFgteSkpIHJlbWFpbmRlciBpcyAke3BvbFJlbWFpbmRlci5kZWdyZWUoKX0gYW5kIHNob3VsZCBiZSAwYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9seW5vbWlhbHMuTC5kZWdyZWUoKSA+PSA5ICogemtleS5kb21haW5TaXplIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVncmVlIG9mIEwoWCkvKFpUUzIoeSkoWC15KSkgaXMgbm90IGNvcnJlY3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZmlmdGggb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtXMl1fMSksIHdoZXJlIFcyOj0oZi9aX3QpKHgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVycgbXVsdGkgZXhwb25lbnRpYXRpb25cIik7XG4gICAgICAgIGxldCBjb21taXRXMiA9IGF3YWl0IHBvbHlub21pYWxzLkwubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlcyXCIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiVzJcIiwgY29tbWl0VzIpO1xuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVMKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEwgcG9seW5vbWlhbFwiKTtcblxuICAgICAgICAgICAgY29uc3QgZXZhbFIwWSA9IHBvbHlub21pYWxzLlIwLmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG4gICAgICAgICAgICBjb25zdCBldmFsUjFZID0gcG9seW5vbWlhbHMuUjEuZXZhbHVhdGUoY2hhbGxlbmdlcy55KTtcbiAgICAgICAgICAgIGNvbnN0IGV2YWxSMlkgPSBwb2x5bm9taWFscy5SMi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xuXG4gICAgICAgICAgICBsZXQgbXVsTDAgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMC5oMHc4WzBdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbXVsTDAgPSBGci5tdWwobXVsTDAsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMwLmgwdzhbaV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG11bEwxID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzEuaDF3NFswXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIG11bEwxID0gRnIubXVsKG11bEwxLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMS5oMXc0W2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtdWxMMiA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgydzNbMF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtdWxMMiA9IEZyLm11bChtdWxMMiwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDJ3M1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtdWxMMiA9IEZyLm11bChtdWxMMiwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDN3M1tpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcHJlTDAgPSBGci5tdWwobXVsTDEsIG11bEwyKTtcbiAgICAgICAgICAgIGxldCBwcmVMMSA9IEZyLm11bChjaGFsbGVuZ2VzLmFscGhhLCBGci5tdWwobXVsTDAsIG11bEwyKSk7XG4gICAgICAgICAgICBsZXQgcHJlTDIgPSBGci5tdWwoRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpLCBGci5tdWwobXVsTDAsIG11bEwxKSk7XG5cbiAgICAgICAgICAgIHRvSW52ZXJzZVtcImRlbkgxXCJdID0gbXVsTDE7XG4gICAgICAgICAgICB0b0ludmVyc2VbXCJkZW5IMlwiXSA9IG11bEwyO1xuXG4gICAgICAgICAgICAvLyBDT01QVVRFIEwoWClcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMwLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwuc3ViU2NhbGFyKGV2YWxSMFkpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuTC5tdWxTY2FsYXIocHJlTDApO1xuXG4gICAgICAgICAgICBsZXQgbDIgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMxLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGwyLnN1YlNjYWxhcihldmFsUjFZKTtcbiAgICAgICAgICAgIGwyLm11bFNjYWxhcihwcmVMMSk7XG5cbiAgICAgICAgICAgIGxldCBsMyA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzIsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgbDMuc3ViU2NhbGFyKGV2YWxSMlkpO1xuICAgICAgICAgICAgbDMubXVsU2NhbGFyKHByZUwyKTtcblxuICAgICAgICAgICAgcG9seW5vbWlhbHMuTC5hZGQobDIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuTC5hZGQobDMpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFpUIHBvbHlub21pYWxcIik7XG4gICAgICAgICAgICBhd2FpdCBjb21wdXRlWlQoKTtcblxuICAgICAgICAgICAgY29uc3QgZXZhbFpUWSA9IHBvbHlub21pYWxzLlpULmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5GLm11bFNjYWxhcihldmFsWlRZKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwuc3ViKHBvbHlub21pYWxzLkYpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5MLmRlZ3JlZSgpID49IDkgKiB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuTDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVaVCgpIHtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlpUID0gUG9seW5vbWlhbC56ZXJvZmllclBvbHlub21pYWwoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICByb290cy5TMC5oMHc4WzBdLCByb290cy5TMC5oMHc4WzFdLCByb290cy5TMC5oMHc4WzJdLCByb290cy5TMC5oMHc4WzNdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMC5oMHc4WzRdLCByb290cy5TMC5oMHc4WzVdLCByb290cy5TMC5oMHc4WzZdLCByb290cy5TMC5oMHc4WzddLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMS5oMXc0WzBdLCByb290cy5TMS5oMXc0WzFdLCByb290cy5TMS5oMXc0WzJdLCByb290cy5TMS5oMXc0WzNdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oMnczWzBdLCByb290cy5TMi5oMnczWzFdLCByb290cy5TMi5oMnczWzJdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oM3czWzBdLCByb290cy5TMi5oM3czWzFdLCByb290cy5TMi5oM3czWzJdXSwgY3VydmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVpUUzIoKSB7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5aVFMyID0gUG9seW5vbWlhbC56ZXJvZmllclBvbHlub21pYWwoXG4gICAgICAgICAgICAgICAgW3Jvb3RzLlMxLmgxdzRbMF0sIHJvb3RzLlMxLmgxdzRbMV0sIHJvb3RzLlMxLmgxdzRbMl0sIHJvb3RzLlMxLmgxdzRbM10sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMyLmgydzNbMF0sIHJvb3RzLlMyLmgydzNbMV0sIHJvb3RzLlMyLmgydzNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLlMyLmgzdzNbMV0sIHJvb3RzLlMyLmgzdzNbMl1dLCBjdXJ2ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNb250Z29tZXJ5QmF0Y2hlZEludmVyc2UoKSB7XG4gICAgICAgIC8vICAgwrcgZGVub21pbmF0b3IgbmVlZGVkIGluIHN0ZXAgOCBhbmQgOSBvZiB0aGUgdmVyaWZpZXIgdG8gbXVsdGlwbHkgYnkgMS9aX0goeGkpXG4gICAgICAgIGxldCB4aU4gPSBjaGFsbGVuZ2VzLnhpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkucG93ZXI7IGkrKykge1xuICAgICAgICAgICAgeGlOID0gRnIuc3F1YXJlKHhpTik7XG4gICAgICAgIH1cbiAgICAgICAgdG9JbnZlcnNlW1wiemhcIl0gPSBGci5zdWIoeGlOLCBGci5vbmUpO1xuXG4gICAgICAgIC8vICAgwrcgZGVub21pbmF0b3IgbmVlZGVkIGluIHN0ZXAgMTAgYW5kIDExIG9mIHRoZSB2ZXJpZmllclxuICAgICAgICAvLyAgICAgdG9JbnZlcnNlLmRlbkgxICYgdG9JbnZlcnNlLmRlbkgyICAtPiBDb21wdXRlZCBpbiByb3VuZDUsIGNvbXB1dGVMKClcblxuICAgICAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiB0aGUgdmVyaWZpZXIgd2hlbiBjb21wdXRpbmcgTF9pXntTMH0oWCksIExfaV57UzF9KFgpIGFuZCBMX2lee1MyfShYKVxuICAgICAgICBjb21wdXRlTGlTMCh0b0ludmVyc2UsIHJvb3RzLlMwLmgwdzgsIGNoYWxsZW5nZXMueSwgY3VydmUpO1xuXG4gICAgICAgIGNvbXB1dGVMaVMxKHRvSW52ZXJzZSwgcm9vdHMuUzEuaDF3NCwgY2hhbGxlbmdlcy55LCBjdXJ2ZSk7XG5cbiAgICAgICAgY29tcHV0ZUxpUzIodG9JbnZlcnNlLCByb290cy5TMi5oMnczLCByb290cy5TMi5oM3czLCBjaGFsbGVuZ2VzLnksIGNoYWxsZW5nZXMueGksIGNoYWxsZW5nZXMueGl3LCBjdXJ2ZSk7XG5cbiAgICAgICAgLy8gICDCtyBMX2kgaT0xIHRvIG51bSBwdWJsaWMgaW5wdXRzLCBuZWVkZWQgaW4gc3RlcCA2IGFuZCA3IG9mIHRoZSB2ZXJpZmllciB0byBjb21wdXRlIExfMSh4aSkgYW5kIFBJKHhpKVxuICAgICAgICBjb25zdCBzaXplID0gTWF0aC5tYXgoMSwgemtleS5uUHVibGljKTtcblxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRvSW52ZXJzZVtcIkxpX1wiICsgKGkgKyAxKV0gPSBGci5tdWwoRnIuZSh6a2V5LmRvbWFpblNpemUpLCBGci5zdWIoY2hhbGxlbmdlcy54aSwgdykpO1xuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtdWxBY2N1bXVsYXRvciA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIE9iamVjdC52YWx1ZXModG9JbnZlcnNlKSkge1xuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViRWxlbWVudCBvZiBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG11bEFjY3VtdWxhdG9yID0gRnIubXVsKG11bEFjY3VtdWxhdG9yLCBzdWJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG11bEFjY3VtdWxhdG9yID0gRnIubXVsKG11bEFjY3VtdWxhdG9yLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnIuaW52KG11bEFjY3VtdWxhdG9yKTtcblxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUxpUzAodG9JbnZlcnNlLCByb290cywgeCwgY3VydmUpIHtcbiAgICAgICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSByb290cy5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZGVuMSA9IEZyLm11bChGci5lKGxlbiksIEZyLmV4cChyb290c1swXSwgbGVuIC0gMikpO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IExpID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWygobGVuIC0gMSkgKiBpKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih4LCByb290c1tpXSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHRvSW52ZXJzZVtbXCJMaVMwX1wiICsgKGkgKyAxKV1dID0gRnIubXVsKEZyLm11bChkZW4xLCBkZW4yKSwgZGVuMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIExpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUxpUzEodG9JbnZlcnNlLCByb290cywgeCwgY3VydmUpIHtcbiAgICAgICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSByb290cy5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZGVuMSA9IEZyLm11bChGci5lKGxlbiksIEZyLmV4cChyb290c1swXSwgbGVuIC0gMikpO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IExpID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWygobGVuIC0gMSkgKiBpKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih4LCByb290c1tpXSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHRvSW52ZXJzZVtbXCJMaVMxX1wiICsgKGkgKyAxKV1dID0gRnIubXVsKEZyLm11bChkZW4xLCBkZW4yKSwgZGVuMyk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gTGk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTGlTMih0b0ludmVyc2UsIFMyLCBTMnAsIHZhbHVlLCB4aSwgeGl3LCBjdXJ2ZSkge1xuICAgICAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBMaSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IF8zaDIgPSBGci5tdWwoRnIuZSgzKSwgUzJbMF0pO1xuICAgICAgICAgICAgY29uc3QgeGlzdWJ4aXcgPSBGci5zdWIoeGksIHhpdyk7XG4gICAgICAgICAgICBsZXQgZGVuMSA9IEZyLm11bChfM2gyLCB4aXN1Ynhpdyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjIgPSBTMlsyICogaSAlIDNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjMgPSBGci5zdWIodmFsdWUsIFMyW2ldKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgdG9JbnZlcnNlW1tcIkxpUzJfXCIgKyAoaSArIDEpXV0gPSBGci5tdWwoZGVuMSxGci5tdWwoZGVuMiwgZGVuMykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IF8zaDMgPSBGci5tdWwoRnIuZSgzKSwgUzJwWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHhpd3N1YnhpID0gRnIuc3ViKHhpdywgeGkpO1xuICAgICAgICAgICAgZGVuMSA9IEZyLm11bChfM2gzLCB4aXdzdWJ4aSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjIgPSBTMnBbMiAqIGkgJSAzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHZhbHVlLCBTMnBbaV0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICB0b0ludmVyc2VbW1wiTGlTMl9cIiArIChpICsgMSArIDMpXV0gPSBGci5tdWwoZGVuMSxGci5tdWwoZGVuMiwgZGVuMykpOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gTGk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/fflonk_prove.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/fflonk_setup.js":
/*!**************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_setup.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkSetup)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(ssr)/./node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bigarray.js */ \"(ssr)/./node_modules/snarkjs/src/bigarray.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk_constants.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zkey_constants.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plonk_equation.js */ \"(ssr)/./node_modules/snarkjs/src/plonk_equation.js\");\n/* harmony import */ var _r1cs_constraint_processor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./r1cs_constraint_processor.js */ \"(ssr)/./node_modules/snarkjs/src/r1cs_constraint_processor.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(ssr)/./node_modules/snarkjs/src/polynomial/polynomial.js\");\n/* harmony import */ var _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./polynomial/evaluations.js */ \"(ssr)/./node_modules/snarkjs/src/polynomial/evaluations.js\");\n/* harmony import */ var _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./polynomial/cpolynomial.js */ \"(ssr)/./node_modules/snarkjs/src/polynomial/cpolynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nasync function fflonkSetup(r1csFilename, ptauFilename, zkeyFilename, logger) {\n    if (logger) logger.info(\"FFLONK SETUP STARTED\");\n\n    if (globalThis.gc) globalThis.gc();\n\n    // Read PTau file\n    if (logger) logger.info(\"> Reading PTau file\");\n    const {fd: fdPTau, sections: pTauSections} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauFilename, \"ptau\", 1, 1 << 22, 1 << 24);\n    if (!pTauSections[12]) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 12 missing.\");\n    }\n\n    // Get curve defined in PTau\n    if (logger) logger.info(\"> Getting curve from PTau settings\");\n    const {curve} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, pTauSections);\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csFd)(fdR1cs, sectionsR1cs, {loadConstraints: false, loadCustomGates: true});\n\n    // Potential error checks\n    if (r1cs.prime !== curve.r) {\n        throw new Error(\"r1cs curve does not match powers of tau ceremony curve\");\n    }\n\n    // Initializations\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sG2 = curve.G2.F.n8 * 2;\n\n    let polynomials = {};\n    let evaluations = {};\n    let PTau;\n\n    let settings = {\n        nVars: r1cs.nVars,\n        nPublic: r1cs.nOutputs + r1cs.nPubInputs\n    };\n\n    const plonkConstraints = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n    let plonkAdditions = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n\n    // Process constraints inside r1cs\n    if (logger) logger.info(\"> Processing FFlonk constraints\");\n    await computeFFConstraints(curve.Fr, r1cs, logger);\n    if (globalThis.gc) globalThis.gc();\n\n    // As the t polynomial is n+5 we need at least a power of 4\n    //TODO check!!!!\n    // NOTE : plonkConstraints + 2 = #constraints + blinding coefficients for each wire polynomial\n    settings.cirPower = Math.max(_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.FF_T_POL_DEG_MIN, (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)((plonkConstraints.length + 2) - 1) + 1);\n    settings.domainSize = 2 ** settings.cirPower;\n\n    if (pTauSections[2][0].size < (settings.domainSize * 9 + 18) * sG1) {\n        throw new Error(\"Powers of Tau is not big enough for this circuit size. Section 2 too small.\");\n    }\n    if (pTauSections[3][0].size < sG2) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 3 too small.\");\n    }\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK SETUP SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${settings.cirPower}`);\n        logger.info(`  Domain size:   ${settings.domainSize}`);\n        logger.info(`  Vars:          ${settings.nVars}`);\n        logger.info(`  Public vars:   ${settings.nPublic}`);\n        logger.info(`  Constraints:   ${plonkConstraints.length}`);\n        logger.info(`  Additions:     ${plonkAdditions.length}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // Compute k1 and k2 to be used in the permutation checks\n    if (logger) logger.info(\"> computing k1 and k2\");\n    const [k1, k2] = computeK1K2();\n\n    // Compute omega 3 (w3) and omega 4 (w4) to be used in the prover and the verifier\n    // w3^3 = 1 and  w4^4 = 1\n    if (logger) logger.info(\"> computing w3\");\n    const w3 = computeW3();\n    if (logger) logger.info(\"> computing w4\");\n    const w4 = computeW4();\n    if (logger) logger.info(\"> computing w8\");\n    const w8 = computeW8();\n    if (logger) logger.info(\"> computing wr\");\n    const wr = getOmegaCubicRoot(settings.cirPower, curve.Fr);\n\n    // Write output zkey file\n    await writeZkeyFile();\n\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"FFLONK SETUP FINISHED\");\n\n    return 0;\n\n    async function computeFFConstraints(Fr, r1cs, logger) {\n        // Add public inputs and outputs\n        for (let i = 0; i < settings.nPublic; i++) {\n            plonkConstraints.push((0,_plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkConstantConstraint)(i + 1, Fr));\n        }\n\n        // Add all constraints from r1cs file\n        const r1csProcessor = new _r1cs_constraint_processor_js__WEBPACK_IMPORTED_MODULE_9__.r1csConstraintProcessor(Fr, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkConstantConstraint, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkAdditionConstraint, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkMultiplicationConstraint, logger);\n\n        const bR1cs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection(fdR1cs, sectionsR1cs, 2);\n        let bR1csPos = 0;\n        for (let i = 0; i < r1cs.nConstraints; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`    processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n            }\n            const [constraints, additions] = r1csProcessor.processR1csConstraint(settings, ...readConstraint());\n\n            plonkConstraints.push(...constraints);\n            plonkAdditions.push(...additions);\n        }\n\n        function readConstraint() {\n            const c = [];\n            c[0] = readLC();\n            c[1] = readLC();\n            c[2] = readLC();\n            return c;\n        }\n\n        function readLC() {\n            const lc = {};\n\n            const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n            bR1csPos += 4;\n            const buffUL32V = new DataView(buffUL32.buffer);\n            const nIdx = buffUL32V.getUint32(0, true);\n\n            const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n            bR1csPos += (4 + r1cs.n8) * nIdx;\n            const buffV = new DataView(buff.buffer);\n            for (let i = 0; i < nIdx; i++) {\n                const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n                const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n                lc[idx] = val;\n            }\n            return lc;\n        }\n\n        return 0;\n    }\n\n    async function writeZkeyFile() {\n        if (logger) logger.info(\"> Writing the zkey file\");\n        const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyFilename, \"zkey\", 1, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_NSECTIONS, 1 << 22, 1 << 24);\n\n        if (logger) logger.info(` Writing Section ${_zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.HEADER_ZKEY_SECTION}. Zkey Header`);\n        await writeZkeyHeader(fdZKey);\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n        await writeAdditions(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_A_MAP_SECTION}. A Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_A_MAP_SECTION, 0, \"A map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_B_MAP_SECTION}. B Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_B_MAP_SECTION, 1, \"B map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C_MAP_SECTION}. C Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C_MAP_SECTION, 2, \"C map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QL_SECTION}. QL`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QL_SECTION, 3, \"QL\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QR_SECTION}. QR`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QR_SECTION, 4, \"QR\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QM_SECTION}. QM`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QM_SECTION, 5, \"QM\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QO_SECTION}. QO`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QO_SECTION, 6, \"QO\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QC_SECTION}. QC`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QC_SECTION, 7, \"QC\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA1_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA2_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n        await writeSigma(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_LAGRANGE_SECTION}. Lagrange Polynomials`);\n        await writeLagrangePolynomials(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n        await writePtau(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C0_SECTION}. C0`);\n        await writeC0(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_HEADER_SECTION}. FFlonk Header`);\n        await writeFFlonkHeader(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(\"> Writing the zkey file finished\");\n\n        await fdZKey.close();\n    }\n\n    async function writeZkeyHeader(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.HEADER_ZKEY_SECTION);\n        await fdZKey.writeULE32(_zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.FFLONK_PROTOCOL_ID);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeAdditions(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_ADDITIONS_SECTION);\n\n        // Written values are 2 * 32 bit integers (2 * 4 bytes) + 2 field size values ( 2 * sFr bytes)\n        const buffOut = new Uint8Array(8 + 2 * sFr);\n        const buffOutV = new DataView(buffOut.buffer);\n\n        for (let i = 0; i < plonkAdditions.length; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing Additions: ${i}/${plonkAdditions.length}`);\n\n            const addition = plonkAdditions[i];\n\n            buffOutV.setUint32(0, addition[0], true);\n            buffOutV.setUint32(4, addition[1], true);\n            buffOut.set(addition[2], 8);\n            buffOut.set(addition[3], 8 + sFr);\n\n            await fdZKey.write(buffOut);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeWitnessMap(fdZKey, sectionNum, posConstraint, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            if (logger && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing witness ${name}: ${i}/${plonkConstraints.length}`);\n            }\n\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeQMap(fdZKey, sectionNum, posConstraint, name) {\n        // Compute Q from q evaluations\n        let Q = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(settings.domainSize * sFr);\n\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i * sFr);\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing ${name}: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        polynomials[name] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.fromEvaluations(Q, curve, logger);\n        evaluations[name] = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__.Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n\n        // Write Q coefficients and evaluations\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        await fdZKey.write(polynomials[name].coef);\n        await fdZKey.write(evaluations[name].eval);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeSigma(fdZKey) {\n        // Compute sigma\n        const sigma = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(sFr * settings.domainSize * 3);\n        const lastSeen = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](settings.nVars);\n        const firstPos = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](settings.nVars);\n\n        let w = Fr.one;\n        for (let i = 0; i < settings.domainSize; i++) {\n            if (i < plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], settings.domainSize + i);\n                buildSigma(plonkConstraints[i][2], settings.domainSize * 2 + i);\n            } else if (i < settings.domainSize - 2) {\n                buildSigma(0, i);\n                buildSigma(0, settings.domainSize + i);\n                buildSigma(0, settings.domainSize * 2 + i);\n            } else {\n                sigma.set(w, i * sFr);\n                sigma.set(Fr.mul(w, k1), (settings.domainSize + i) * sFr);\n                sigma.set(Fr.mul(w, k2), (settings.domainSize * 2 + i) * sFr);\n            }\n\n            w = Fr.mul(w, Fr.w[settings.cirPower]);\n\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing sigma phase1: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        for (let i = 0; i < settings.nVars; i++) {\n            if (typeof firstPos[i] !== \"undefined\") {\n                sigma.set(lastSeen[i], firstPos[i] * sFr);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing sigma phase2: ${i}/${settings.nVars}`);\n        }\n\n        if (globalThis.gc) globalThis.gc();\n\n        // Write sigma coefficients and evaluations\n        for (let i = 0; i < 3; i++) {\n            const sectionId = 0 === i ? _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA1_SECTION : 1 === i ? _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA2_SECTION : _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA3_SECTION;\n\n            let name = \"S\" + (i + 1);\n            polynomials[name] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.fromEvaluations(sigma.slice(settings.domainSize * sFr * i, settings.domainSize * sFr * (i + 1)), curve, logger);\n            evaluations[name] = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__.Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n            await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionId);\n            await fdZKey.write(polynomials[name].coef);\n            await fdZKey.write(evaluations[name].eval);\n            await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n            if (globalThis.gc) globalThis.gc();\n        }\n\n        return 0;\n\n        function buildSigma(signalId, idx) {\n            if (typeof lastSeen[signalId] === \"undefined\") {\n                firstPos[signalId] = idx;\n            } else {\n                sigma.set(lastSeen[signalId], idx * sFr);\n            }\n            let v;\n            if (idx < settings.domainSize) {\n                v = w;\n            } else if (idx < 2 * settings.domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n\n            lastSeen[signalId] = v;\n        }\n    }\n\n    async function writeLagrangePolynomials(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_LAGRANGE_SECTION);\n\n        const l = Math.max(settings.nPublic, 1);\n        for (let i = 0; i < l; i++) {\n            let buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(settings.domainSize * sFr);\n            buff.set(Fr.one, i * sFr);\n\n            await writeP4(fdZKey, buff);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writePtau(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_PTAU_SECTION);\n\n        // domainSize * 9 + 18 = maximum SRS length needed, specifically to commit C2\n        PTau = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((settings.domainSize * 9 + 18) * sG1);\n        await fdPTau.readToBuffer(PTau, 0, (settings.domainSize * 9 + 18) * sG1, pTauSections[2][0].p);\n\n        await fdZKey.write(PTau);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeC0(fdZKey) {\n        // C0(X) := QL(X^8) + X  QR(X^8) + X^2  QO(X^8) + X^3  QM(X^8) + X^4  QC(X^8)\n        //            + X^5  SIGMA1(X^8) + X^6  SIGMA2(X^8) + X^7  SIGMA3(X^8)\n        let C0 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_12__.CPolynomial(8, curve, logger);\n        C0.addPolynomial(0, polynomials.QL);\n        C0.addPolynomial(1, polynomials.QR);\n        C0.addPolynomial(2, polynomials.QO);\n        C0.addPolynomial(3, polynomials.QM);\n        C0.addPolynomial(4, polynomials.QC);\n        C0.addPolynomial(5, polynomials.S1);\n        C0.addPolynomial(6, polynomials.S2);\n        C0.addPolynomial(7, polynomials.S3);\n\n        polynomials.C0 = C0.getPolynomial();\n\n        // Check degree\n        if (polynomials.C0.degree() >= 8 * settings.domainSize) {\n            throw new Error(\"C0 Polynomial is not well calculated\");\n        }\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C0_SECTION);\n        await fdZKey.write(polynomials.C0.coef);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeFFlonkHeader(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_HEADER_SECTION);\n\n        const primeQ = curve.q;\n        const n8q = (Math.floor((ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n\n        const primeR = curve.r;\n        const n8r = (Math.floor((ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8r);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n\n        // Total number of r1cs vars\n        await fdZKey.writeULE32(settings.nVars);\n        // Total number of r1cs public vars = outputs + public inputs\n        await fdZKey.writeULE32(settings.nPublic);\n        await fdZKey.writeULE32(settings.domainSize);\n        await fdZKey.writeULE32(plonkAdditions.length);\n        await fdZKey.writeULE32(plonkConstraints.length);\n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(w3);\n        await fdZKey.write(w4);\n        await fdZKey.write(w8);\n        await fdZKey.write(wr);\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, pTauSections[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        let commitC0 = await polynomials.C0.multiExponentiation(PTau, \"C0\");\n        await fdZKey.write(commitC0);\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeP4(fdZKey, buff) {\n        const [coefficients, evaluations4] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.to4T(buff, settings.domainSize, [], Fr);\n        await fdZKey.write(coefficients);\n        await fdZKey.write(evaluations4);\n\n        return [coefficients, evaluations4];\n    }\n\n    function computeK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], settings.cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], settings.cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize = 2 ** pow;\n            let w = Fr.one;\n            for (let i = 0; i < domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j = 0; j < kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n\n    function computeW3() {\n        let generator = Fr.e(31624);\n\n        // Exponent is order(r - 1) / 3\n        let orderRsub1 = 3648040478639879203707734290876212514758060733402672390616367364429301415936n;\n        let exponent = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.div(orderRsub1, ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.e(3));\n\n        return Fr.exp(generator, exponent);\n    }\n\n    function computeW4() {\n        return Fr.w[2];\n    }\n\n    function computeW8() {\n        return Fr.w[3];\n    }\n\n    function getOmegaCubicRoot(power, Fr) {\n        // Hardcorded 3th-root of Fr.w[28]\n        const firstRoot = Fr.e(467799165886069610036046866799264026481344299079011762026774533774345988080n);\n\n        return Fr.exp(firstRoot, 2 ** (28 - power));\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3NldHVwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDWTtBQUNpRTtBQUNsRjtBQUNnQjtBQUNWO0FBb0JOO0FBQzZDO0FBSy9DO0FBQzBDO0FBQ2pCO0FBQ0Y7QUFDSTtBQUNBOzs7QUFHekM7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvQ0FBb0MsUUFBUSxnRUFBVztBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTyxRQUFRLGlFQUFvQjs7QUFFOUM7QUFDQTtBQUNBLFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7QUFDbEUsdUJBQXVCLG9EQUFVLHdCQUF3Qiw4Q0FBOEM7O0FBRXZHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsb0RBQVE7QUFDekMsNkJBQTZCLG9EQUFROztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0VBQWdCLEVBQUUsOENBQUk7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25ELHdDQUF3QyxrQkFBa0I7QUFDMUQsd0NBQXdDLG9CQUFvQjtBQUM1RCx3Q0FBd0MsZUFBZTtBQUN2RCx3Q0FBd0MsaUJBQWlCO0FBQ3pELHdDQUF3Qyx3QkFBd0I7QUFDaEUsd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUMsa0NBQWtDLCtFQUEyQjtBQUM3RDs7QUFFQTtBQUNBLGtDQUFrQyxrRkFBdUIsS0FBSywyRUFBMkIsRUFBRSwyRUFBMkIsRUFBRSxpRkFBaUM7O0FBRXpKLDRCQUE0Qiw0REFBd0I7QUFDcEQ7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0EsK0RBQStELEVBQUUsR0FBRyxrQkFBa0I7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGtFQUFhLDBCQUEwQixtRUFBaUI7O0FBRXJGLHVEQUF1RCxtRUFBbUIsQ0FBQztBQUMzRTs7QUFFQSx1REFBdUQsMkVBQXlCLENBQUM7QUFDakY7QUFDQTs7QUFFQSx1REFBdUQsdUVBQXFCLENBQUM7QUFDN0Usc0NBQXNDLHVFQUFxQjtBQUMzRDs7QUFFQSx1REFBdUQsdUVBQXFCLENBQUM7QUFDN0Usc0NBQXNDLHVFQUFxQjtBQUMzRDs7QUFFQSx1REFBdUQsdUVBQXFCLENBQUM7QUFDN0Usc0NBQXNDLHVFQUFxQjtBQUMzRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx1REFBdUQsb0VBQWtCLENBQUM7QUFDMUUsZ0NBQWdDLG9FQUFrQjtBQUNsRDs7QUFFQSx3REFBd0Qsd0VBQXNCLENBQUMsR0FBRyx3RUFBc0IsQ0FBQyxHQUFHLHdFQUFzQixDQUFDO0FBQ25JO0FBQ0E7O0FBRUEsdURBQXVELDBFQUF3QixDQUFDO0FBQ2hGO0FBQ0E7O0FBRUEsdURBQXVELHNFQUFvQixDQUFDO0FBQzVFO0FBQ0E7O0FBRUEsdURBQXVELG9FQUFrQixDQUFDO0FBQzFFO0FBQ0E7O0FBRUEsdURBQXVELHdFQUFzQixDQUFDO0FBQzlFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsbUVBQW1CO0FBQzNELGdDQUFnQyxrRUFBa0I7QUFDbEQsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsMkVBQXlCOztBQUVqRTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDJCQUEyQjtBQUNuRCxxR0FBcUcsRUFBRSxHQUFHLHNCQUFzQjs7QUFFaEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQix3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0EscURBQXFELEtBQUssSUFBSSxFQUFFLEdBQUcsd0JBQXdCO0FBQzNGOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVM7O0FBRTdCLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBLDZDQUE2QyxLQUFLLElBQUksRUFBRSxHQUFHLHdCQUF3QjtBQUNuRjtBQUNBOztBQUVBLGtDQUFrQyxrRUFBVTtBQUM1QyxrQ0FBa0Msb0VBQVc7O0FBRTdDO0FBQ0EsY0FBYyxzRUFBaUI7QUFDL0I7QUFDQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixtREFBUztBQUNuQyw2QkFBNkIsb0RBQVE7QUFDckMsNkJBQTZCLG9EQUFROztBQUVyQztBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkRBQTJELEVBQUUsR0FBRyx3QkFBd0I7QUFDeEY7QUFDQTs7QUFFQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLEVBQUUsR0FBRyxlQUFlO0FBQzVIOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0Isd0NBQXdDLHdFQUFzQixhQUFhLHdFQUFzQixHQUFHLHdFQUFzQjs7QUFFMUg7QUFDQSxzQ0FBc0Msa0VBQVU7QUFDaEQsc0NBQXNDLG9FQUFXO0FBQ2pELGtCQUFrQixzRUFBaUI7QUFDbkM7QUFDQTtBQUNBLGtCQUFrQixvRUFBZTs7QUFFakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsMEVBQXdCOztBQUVoRTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLDJCQUEyQixtREFBUztBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsc0VBQW9COztBQUU1RDtBQUNBLG1CQUFtQixtREFBUztBQUM1Qjs7QUFFQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxzRUFBaUIsU0FBUyxvRUFBa0I7QUFDMUQ7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0EsY0FBYyxzRUFBaUIsU0FBUyx3RUFBc0I7O0FBRTlEO0FBQ0EsaUNBQWlDLGdEQUFNO0FBQ3ZDO0FBQ0EsY0FBYyxnRUFBVzs7QUFFekI7QUFDQSxpQ0FBaUMsZ0RBQU07QUFDdkM7QUFDQSxjQUFjLGdFQUFXOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQSxtREFBbUQsa0VBQVU7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQU0saUJBQWlCLGdEQUFNOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfc2V0dXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHtyZWFkUjFjc0ZkfSBmcm9tIFwicjFjc2ZpbGVcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQge2NyZWF0ZUJpbkZpbGUsIGVuZFdyaXRlU2VjdGlvbiwgcmVhZEJpbkZpbGUsIHN0YXJ0V3JpdGVTZWN0aW9uLCB3cml0ZUJpZ0ludCx9IGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQge2xvZzJ9IGZyb20gXCIuL21pc2MuanNcIjtcbmltcG9ydCB7QmlnQnVmZmVyLCBTY2FsYXJ9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCBCaWdBcnJheSBmcm9tIFwiLi9iaWdhcnJheS5qc1wiO1xuaW1wb3J0IHtcbiAgICBaS0VZX0ZGX0hFQURFUl9TRUNUSU9OLFxuICAgIFpLRVlfRkZfQURESVRJT05TX1NFQ1RJT04sXG4gICAgWktFWV9GRl9BX01BUF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfQl9NQVBfU0VDVElPTixcbiAgICBaS0VZX0ZGX0NfTUFQX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RTF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfUVJfU0VDVElPTixcbiAgICBaS0VZX0ZGX1FNX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RT19TRUNUSU9OLFxuICAgIFpLRVlfRkZfUUNfU0VDVElPTixcbiAgICBaS0VZX0ZGX1NJR01BMV9TRUNUSU9OLFxuICAgIFpLRVlfRkZfU0lHTUEyX1NFQ1RJT04sXG4gICAgWktFWV9GRl9TSUdNQTNfU0VDVElPTixcbiAgICBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04sXG4gICAgWktFWV9GRl9QVEFVX1NFQ1RJT04sXG4gICAgRkZfVF9QT0xfREVHX01JTixcbiAgICBaS0VZX0ZGX05TRUNUSU9OUyxcbiAgICBaS0VZX0ZGX0MwX1NFQ1RJT04sXG59IGZyb20gXCIuL2ZmbG9ua19jb25zdGFudHMuanNcIjtcbmltcG9ydCB7RkZMT05LX1BST1RPQ09MX0lELCBIRUFERVJfWktFWV9TRUNUSU9OfSBmcm9tIFwiLi96a2V5X2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHtcbiAgICBnZXRGRmxvbmtBZGRpdGlvbkNvbnN0cmFpbnQsXG4gICAgZ2V0RkZsb25rQ29uc3RhbnRDb25zdHJhaW50LFxuICAgIGdldEZGbG9ua011bHRpcGxpY2F0aW9uQ29uc3RyYWludFxufSBmcm9tIFwiLi9wbG9ua19lcXVhdGlvbi5qc1wiO1xuaW1wb3J0IHtyMWNzQ29uc3RyYWludFByb2Nlc3Nvcn0gZnJvbSBcIi4vcjFjc19jb25zdHJhaW50X3Byb2Nlc3Nvci5qc1wiO1xuaW1wb3J0IHtQb2x5bm9taWFsfSBmcm9tIFwiLi9wb2x5bm9taWFsL3BvbHlub21pYWwuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0IHtFdmFsdWF0aW9uc30gZnJvbSBcIi4vcG9seW5vbWlhbC9ldmFsdWF0aW9ucy5qc1wiO1xuaW1wb3J0IHtDUG9seW5vbWlhbH0gZnJvbSBcIi4vcG9seW5vbWlhbC9jcG9seW5vbWlhbC5qc1wiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZmbG9ua1NldHVwKHIxY3NGaWxlbmFtZSwgcHRhdUZpbGVuYW1lLCB6a2V5RmlsZW5hbWUsIGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFNFVFVQIFNUQVJURURcIik7XG5cbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUmVhZCBQVGF1IGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyBQVGF1IGZpbGVcIik7XG4gICAgY29uc3Qge2ZkOiBmZFBUYXUsIHNlY3Rpb25zOiBwVGF1U2VjdGlvbnN9ID0gYXdhaXQgcmVhZEJpbkZpbGUocHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSwgMSA8PCAyMiwgMSA8PCAyNCk7XG4gICAgaWYgKCFwVGF1U2VjdGlvbnNbMTJdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VycyBvZiBUYXUgaXMgbm90IHdlbGwgcHJlcGFyZWQuIFNlY3Rpb24gMTIgbWlzc2luZy5cIik7XG4gICAgfVxuXG4gICAgLy8gR2V0IGN1cnZlIGRlZmluZWQgaW4gUFRhdVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBHZXR0aW5nIGN1cnZlIGZyb20gUFRhdSBzZXR0aW5nc1wiKTtcbiAgICBjb25zdCB7Y3VydmV9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRQVGF1LCBwVGF1U2VjdGlvbnMpO1xuXG4gICAgLy8gUmVhZCByMWNzIGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyByMWNzIGZpbGVcIik7XG4gICAgY29uc3Qge2ZkOiBmZFIxY3MsIHNlY3Rpb25zOiBzZWN0aW9uc1IxY3N9ID0gYXdhaXQgcmVhZEJpbkZpbGUocjFjc0ZpbGVuYW1lLCBcInIxY3NcIiwgMSwgMSA8PCAyMiwgMSA8PCAyNCk7XG4gICAgY29uc3QgcjFjcyA9IGF3YWl0IHJlYWRSMWNzRmQoZmRSMWNzLCBzZWN0aW9uc1IxY3MsIHtsb2FkQ29uc3RyYWludHM6IGZhbHNlLCBsb2FkQ3VzdG9tR2F0ZXM6IHRydWV9KTtcblxuICAgIC8vIFBvdGVudGlhbCBlcnJvciBjaGVja3NcbiAgICBpZiAocjFjcy5wcmltZSAhPT0gY3VydmUucikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyMWNzIGN1cnZlIGRvZXMgbm90IG1hdGNoIHBvd2VycyBvZiB0YXUgY2VyZW1vbnkgY3VydmVcIik7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6YXRpb25zXG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IHNGciA9IGN1cnZlLkZyLm44O1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjggKiAyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjggKiAyO1xuXG4gICAgbGV0IHBvbHlub21pYWxzID0ge307XG4gICAgbGV0IGV2YWx1YXRpb25zID0ge307XG4gICAgbGV0IFBUYXU7XG5cbiAgICBsZXQgc2V0dGluZ3MgPSB7XG4gICAgICAgIG5WYXJzOiByMWNzLm5WYXJzLFxuICAgICAgICBuUHVibGljOiByMWNzLm5PdXRwdXRzICsgcjFjcy5uUHViSW5wdXRzXG4gICAgfTtcblxuICAgIGNvbnN0IHBsb25rQ29uc3RyYWludHMgPSBuZXcgQmlnQXJyYXkoKTtcbiAgICBsZXQgcGxvbmtBZGRpdGlvbnMgPSBuZXcgQmlnQXJyYXkoKTtcblxuICAgIC8vIFByb2Nlc3MgY29uc3RyYWludHMgaW5zaWRlIHIxY3NcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUHJvY2Vzc2luZyBGRmxvbmsgY29uc3RyYWludHNcIik7XG4gICAgYXdhaXQgY29tcHV0ZUZGQ29uc3RyYWludHMoY3VydmUuRnIsIHIxY3MsIGxvZ2dlcik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIC8vIEFzIHRoZSB0IHBvbHlub21pYWwgaXMgbis1IHdlIG5lZWQgYXQgbGVhc3QgYSBwb3dlciBvZiA0XG4gICAgLy9UT0RPIGNoZWNrISEhIVxuICAgIC8vIE5PVEUgOiBwbG9ua0NvbnN0cmFpbnRzICsgMiA9ICNjb25zdHJhaW50cyArIGJsaW5kaW5nIGNvZWZmaWNpZW50cyBmb3IgZWFjaCB3aXJlIHBvbHlub21pYWxcbiAgICBzZXR0aW5ncy5jaXJQb3dlciA9IE1hdGgubWF4KEZGX1RfUE9MX0RFR19NSU4sIGxvZzIoKHBsb25rQ29uc3RyYWludHMubGVuZ3RoICsgMikgLSAxKSArIDEpO1xuICAgIHNldHRpbmdzLmRvbWFpblNpemUgPSAyICoqIHNldHRpbmdzLmNpclBvd2VyO1xuXG4gICAgaWYgKHBUYXVTZWN0aW9uc1syXVswXS5zaXplIDwgKHNldHRpbmdzLmRvbWFpblNpemUgKiA5ICsgMTgpICogc0cxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VycyBvZiBUYXUgaXMgbm90IGJpZyBlbm91Z2ggZm9yIHRoaXMgY2lyY3VpdCBzaXplLiBTZWN0aW9uIDIgdG9vIHNtYWxsLlwiKTtcbiAgICB9XG4gICAgaWYgKHBUYXVTZWN0aW9uc1szXVswXS5zaXplIDwgc0cyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VycyBvZiBUYXUgaXMgbm90IHdlbGwgcHJlcGFyZWQuIFNlY3Rpb24gMyB0b28gc21hbGwuXCIpO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIiAgRkZMT05LIFNFVFVQIFNFVFRJTkdTXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXJ2ZTogICAgICAgICAke2N1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENpcmN1aXQgcG93ZXI6ICR7c2V0dGluZ3MuY2lyUG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIERvbWFpbiBzaXplOiAgICR7c2V0dGluZ3MuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgVmFyczogICAgICAgICAgJHtzZXR0aW5ncy5uVmFyc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHVibGljIHZhcnM6ICAgJHtzZXR0aW5ncy5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDb25zdHJhaW50czogICAke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBBZGRpdGlvbnM6ICAgICAke3Bsb25rQWRkaXRpb25zLmxlbmd0aH1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgazEgYW5kIGsyIHRvIGJlIHVzZWQgaW4gdGhlIHBlcm11dGF0aW9uIGNoZWNrc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBjb21wdXRpbmcgazEgYW5kIGsyXCIpO1xuICAgIGNvbnN0IFtrMSwgazJdID0gY29tcHV0ZUsxSzIoKTtcblxuICAgIC8vIENvbXB1dGUgb21lZ2EgMyAodzMpIGFuZCBvbWVnYSA0ICh3NCkgdG8gYmUgdXNlZCBpbiB0aGUgcHJvdmVyIGFuZCB0aGUgdmVyaWZpZXJcbiAgICAvLyB3M14zID0gMSBhbmQgIHc0XjQgPSAxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyB3M1wiKTtcbiAgICBjb25zdCB3MyA9IGNvbXB1dGVXMygpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBjb21wdXRpbmcgdzRcIik7XG4gICAgY29uc3QgdzQgPSBjb21wdXRlVzQoKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gY29tcHV0aW5nIHc4XCIpO1xuICAgIGNvbnN0IHc4ID0gY29tcHV0ZVc4KCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyB3clwiKTtcbiAgICBjb25zdCB3ciA9IGdldE9tZWdhQ3ViaWNSb290KHNldHRpbmdzLmNpclBvd2VyLCBjdXJ2ZS5Gcik7XG5cbiAgICAvLyBXcml0ZSBvdXRwdXQgemtleSBmaWxlXG4gICAgYXdhaXQgd3JpdGVaa2V5RmlsZSgpO1xuXG4gICAgYXdhaXQgZmRSMWNzLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRQVGF1LmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBTRVRVUCBGSU5JU0hFRFwiKTtcblxuICAgIHJldHVybiAwO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUZGQ29uc3RyYWludHMoRnIsIHIxY3MsIGxvZ2dlcikge1xuICAgICAgICAvLyBBZGQgcHVibGljIGlucHV0cyBhbmQgb3V0cHV0c1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLm5QdWJsaWM7IGkrKykge1xuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKGdldEZGbG9ua0NvbnN0YW50Q29uc3RyYWludChpICsgMSwgRnIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBhbGwgY29uc3RyYWludHMgZnJvbSByMWNzIGZpbGVcbiAgICAgICAgY29uc3QgcjFjc1Byb2Nlc3NvciA9IG5ldyByMWNzQ29uc3RyYWludFByb2Nlc3NvcihGciwgZ2V0RkZsb25rQ29uc3RhbnRDb25zdHJhaW50LCBnZXRGRmxvbmtBZGRpdGlvbkNvbnN0cmFpbnQsIGdldEZGbG9ua011bHRpcGxpY2F0aW9uQ29uc3RyYWludCwgbG9nZ2VyKTtcblxuICAgICAgICBjb25zdCBiUjFjcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFIxY3MsIHNlY3Rpb25zUjFjcywgMik7XG4gICAgICAgIGxldCBiUjFjc1BvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjFjcy5uQ29uc3RyYWludHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhgICAgIHByb2Nlc3NpbmcgcjFjcyBjb25zdHJhaW50cyAke2l9LyR7cjFjcy5uQ29uc3RyYWludHN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbY29uc3RyYWludHMsIGFkZGl0aW9uc10gPSByMWNzUHJvY2Vzc29yLnByb2Nlc3NSMWNzQ29uc3RyYWludChzZXR0aW5ncywgLi4ucmVhZENvbnN0cmFpbnQoKSk7XG5cbiAgICAgICAgICAgIHBsb25rQ29uc3RyYWludHMucHVzaCguLi5jb25zdHJhaW50cyk7XG4gICAgICAgICAgICBwbG9ua0FkZGl0aW9ucy5wdXNoKC4uLmFkZGl0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkQ29uc3RyYWludCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBbXTtcbiAgICAgICAgICAgIGNbMF0gPSByZWFkTEMoKTtcbiAgICAgICAgICAgIGNbMV0gPSByZWFkTEMoKTtcbiAgICAgICAgICAgIGNbMl0gPSByZWFkTEMoKTtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZExDKCkge1xuICAgICAgICAgICAgY29uc3QgbGMgPSB7fTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZlVMMzIgPSBiUjFjcy5zbGljZShiUjFjc1BvcywgYlIxY3NQb3MgKyA0KTtcbiAgICAgICAgICAgIGJSMWNzUG9zICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBidWZmVUwzMlYgPSBuZXcgRGF0YVZpZXcoYnVmZlVMMzIuYnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IG5JZHggPSBidWZmVUwzMlYuZ2V0VWludDMyKDAsIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmID0gYlIxY3Muc2xpY2UoYlIxY3NQb3MsIGJSMWNzUG9zICsgKDQgKyByMWNzLm44KSAqIG5JZHgpO1xuICAgICAgICAgICAgYlIxY3NQb3MgKz0gKDQgKyByMWNzLm44KSAqIG5JZHg7XG4gICAgICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5JZHg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGJ1ZmZWLmdldFVpbnQzMihpICogKDQgKyByMWNzLm44KSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gcjFjcy5GLmZyb21ScHJMRShidWZmLCBpICogKDQgKyByMWNzLm44KSArIDQpO1xuICAgICAgICAgICAgICAgIGxjW2lkeF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVprZXlGaWxlKCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gV3JpdGluZyB0aGUgemtleSBmaWxlXCIpO1xuICAgICAgICBjb25zdCBmZFpLZXkgPSBhd2FpdCBjcmVhdGVCaW5GaWxlKHprZXlGaWxlbmFtZSwgXCJ6a2V5XCIsIDEsIFpLRVlfRkZfTlNFQ1RJT05TLCAxIDw8IDIyLCAxIDw8IDI0KTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke0hFQURFUl9aS0VZX1NFQ1RJT059LiBaa2V5IEhlYWRlcmApO1xuICAgICAgICBhd2FpdCB3cml0ZVprZXlIZWFkZXIoZmRaS2V5KTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfQURESVRJT05TX1NFQ1RJT059LiBBZGRpdGlvbnNgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVBZGRpdGlvbnMoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfQV9NQVBfU0VDVElPTn0uIEEgTWFwYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcChmZFpLZXksIFpLRVlfRkZfQV9NQVBfU0VDVElPTiwgMCwgXCJBIG1hcFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfQl9NQVBfU0VDVElPTn0uIEIgTWFwYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcChmZFpLZXksIFpLRVlfRkZfQl9NQVBfU0VDVElPTiwgMSwgXCJCIG1hcFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfQ19NQVBfU0VDVElPTn0uIEMgTWFwYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlV2l0bmVzc01hcChmZFpLZXksIFpLRVlfRkZfQ19NQVBfU0VDVElPTiwgMiwgXCJDIG1hcFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUUxfU0VDVElPTn0uIFFMYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUU1hcChmZFpLZXksIFpLRVlfRkZfUUxfU0VDVElPTiwgMywgXCJRTFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUVJfU0VDVElPTn0uIFFSYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUU1hcChmZFpLZXksIFpLRVlfRkZfUVJfU0VDVElPTiwgNCwgXCJRUlwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUU1fU0VDVElPTn0uIFFNYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUU1hcChmZFpLZXksIFpLRVlfRkZfUU1fU0VDVElPTiwgNSwgXCJRTVwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUU9fU0VDVElPTn0uIFFPYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUU1hcChmZFpLZXksIFpLRVlfRkZfUU9fU0VDVElPTiwgNiwgXCJRT1wiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUUNfU0VDVElPTn0uIFFDYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUU1hcChmZFpLZXksIFpLRVlfRkZfUUNfU0VDVElPTiwgNywgXCJRQ1wiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbnMgJHtaS0VZX0ZGX1NJR01BMV9TRUNUSU9OfSwke1pLRVlfRkZfU0lHTUEyX1NFQ1RJT059LCR7WktFWV9GRl9TSUdNQTNfU0VDVElPTn0uIFNpZ21hMSwgU2lnbWEyICYgU2lnbWEgM2ApO1xuICAgICAgICBhd2FpdCB3cml0ZVNpZ21hKGZkWktleSk7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYMK3wrfCtyBXcml0aW5nIFNlY3Rpb24gJHtaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT059LiBMYWdyYW5nZSBQb2x5bm9taWFsc2ApO1xuICAgICAgICBhd2FpdCB3cml0ZUxhZ3JhbmdlUG9seW5vbWlhbHMoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfUFRBVV9TRUNUSU9OfS4gUG93ZXJzIG9mIFRhdWApO1xuICAgICAgICBhd2FpdCB3cml0ZVB0YXUoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfQzBfU0VDVElPTn0uIEMwYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlQzAoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfSEVBREVSX1NFQ1RJT059LiBGRmxvbmsgSGVhZGVyYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlRkZsb25rSGVhZGVyKGZkWktleSk7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFdyaXRpbmcgdGhlIHprZXkgZmlsZSBmaW5pc2hlZFwiKTtcblxuICAgICAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVprZXlIZWFkZXIoZmRaS2V5KSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgSEVBREVSX1pLRVlfU0VDVElPTik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKEZGTE9OS19QUk9UT0NPTF9JRCk7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlQWRkaXRpb25zKGZkWktleSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIFpLRVlfRkZfQURESVRJT05TX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIFdyaXR0ZW4gdmFsdWVzIGFyZSAyICogMzIgYml0IGludGVnZXJzICgyICogNCBieXRlcykgKyAyIGZpZWxkIHNpemUgdmFsdWVzICggMiAqIHNGciBieXRlcylcbiAgICAgICAgY29uc3QgYnVmZk91dCA9IG5ldyBVaW50OEFycmF5KDggKyAyICogc0ZyKTtcbiAgICAgICAgY29uc3QgYnVmZk91dFYgPSBuZXcgRGF0YVZpZXcoYnVmZk91dC5idWZmZXIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxvbmtBZGRpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgICAgd3JpdGluZyBBZGRpdGlvbnM6ICR7aX0vJHtwbG9ua0FkZGl0aW9ucy5sZW5ndGh9YCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uID0gcGxvbmtBZGRpdGlvbnNbaV07XG5cbiAgICAgICAgICAgIGJ1ZmZPdXRWLnNldFVpbnQzMigwLCBhZGRpdGlvblswXSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmT3V0Vi5zZXRVaW50MzIoNCwgYWRkaXRpb25bMV0sIHRydWUpO1xuICAgICAgICAgICAgYnVmZk91dC5zZXQoYWRkaXRpb25bMl0sIDgpO1xuICAgICAgICAgICAgYnVmZk91dC5zZXQoYWRkaXRpb25bM10sIDggKyBzRnIpO1xuXG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYnVmZk91dCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgc2VjdGlvbk51bSwgcG9zQ29uc3RyYWludCwgbmFtZSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsb25rQ29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKGkgIT09IDApICYmIChpICUgNTAwMDAwID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGAgICAgICB3cml0aW5nIHdpdG5lc3MgJHtuYW1lfTogJHtpfS8ke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihwbG9ua0NvbnN0cmFpbnRzW2ldW3Bvc0NvbnN0cmFpbnRdKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVFNYXAoZmRaS2V5LCBzZWN0aW9uTnVtLCBwb3NDb25zdHJhaW50LCBuYW1lKSB7XG4gICAgICAgIC8vIENvbXB1dGUgUSBmcm9tIHEgZXZhbHVhdGlvbnNcbiAgICAgICAgbGV0IFEgPSBuZXcgQmlnQnVmZmVyKHNldHRpbmdzLmRvbWFpblNpemUgKiBzRnIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgUS5zZXQocGxvbmtDb25zdHJhaW50c1tpXVtwb3NDb25zdHJhaW50XSwgaSAqIHNGcik7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGkgIT09IDApICYmIChpICUgNTAwMDAwID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGAgICAgICB3cml0aW5nICR7bmFtZX06ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvbHlub21pYWxzW25hbWVdID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoUSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zW25hbWVdID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHNbbmFtZV0sIDQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIFdyaXRlIFEgY29lZmZpY2llbnRzIGFuZCBldmFsdWF0aW9uc1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUocG9seW5vbWlhbHNbbmFtZV0uY29lZik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShldmFsdWF0aW9uc1tuYW1lXS5ldmFsKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVTaWdtYShmZFpLZXkpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBzaWdtYVxuICAgICAgICBjb25zdCBzaWdtYSA9IG5ldyBCaWdCdWZmZXIoc0ZyICogc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDMpO1xuICAgICAgICBjb25zdCBsYXN0U2VlbiA9IG5ldyBCaWdBcnJheShzZXR0aW5ncy5uVmFycyk7XG4gICAgICAgIGNvbnN0IGZpcnN0UG9zID0gbmV3IEJpZ0FycmF5KHNldHRpbmdzLm5WYXJzKTtcblxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgcGxvbmtDb25zdHJhaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKHBsb25rQ29uc3RyYWludHNbaV1bMF0sIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsxXSwgc2V0dGluZ3MuZG9tYWluU2l6ZSArIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsyXSwgc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDIgKyBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IHNldHRpbmdzLmRvbWFpblNpemUgLSAyKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIHNldHRpbmdzLmRvbWFpblNpemUgKyBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIHNldHRpbmdzLmRvbWFpblNpemUgKiAyICsgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldCh3LCBpICogc0ZyKTtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQoRnIubXVsKHcsIGsxKSwgKHNldHRpbmdzLmRvbWFpblNpemUgKyBpKSAqIHNGcik7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KEZyLm11bCh3LCBrMiksIChzZXR0aW5ncy5kb21haW5TaXplICogMiArIGkpICogc0ZyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3NldHRpbmdzLmNpclBvd2VyXSk7XG5cbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCAgICAgIHdyaXRpbmcgc2lnbWEgcGhhc2UxOiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLm5WYXJzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlyc3RQb3NbaV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQobGFzdFNlZW5baV0sIGZpcnN0UG9zW2ldICogc0ZyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgbm90IHVzZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWYXJpYWJsZSBub3QgdXNlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgICAgd3JpdGluZyBzaWdtYSBwaGFzZTI6ICR7aX0vJHtzZXR0aW5ncy5uVmFyc31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAgICAgLy8gV3JpdGUgc2lnbWEgY29lZmZpY2llbnRzIGFuZCBldmFsdWF0aW9uc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvbklkID0gMCA9PT0gaSA/IFpLRVlfRkZfU0lHTUExX1NFQ1RJT04gOiAxID09PSBpID8gWktFWV9GRl9TSUdNQTJfU0VDVElPTiA6IFpLRVlfRkZfU0lHTUEzX1NFQ1RJT047XG5cbiAgICAgICAgICAgIGxldCBuYW1lID0gXCJTXCIgKyAoaSArIDEpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHNbbmFtZV0gPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhzaWdtYS5zbGljZShzZXR0aW5ncy5kb21haW5TaXplICogc0ZyICogaSwgc2V0dGluZ3MuZG9tYWluU2l6ZSAqIHNGciAqIChpICsgMSkpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zW25hbWVdID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHNbbmFtZV0sIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uSWQpO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHBvbHlub21pYWxzW25hbWVdLmNvZWYpO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGV2YWx1YXRpb25zW25hbWVdLmV2YWwpO1xuICAgICAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAgICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBmdW5jdGlvbiBidWlsZFNpZ21hKHNpZ25hbElkLCBpZHgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdFNlZW5bc2lnbmFsSWRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RQb3Nbc2lnbmFsSWRdID0gaWR4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQobGFzdFNlZW5bc2lnbmFsSWRdLCBpZHggKiBzRnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHY7XG4gICAgICAgICAgICBpZiAoaWR4IDwgc2V0dGluZ3MuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHYgPSB3O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZHggPCAyICogc2V0dGluZ3MuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHYgPSBGci5tdWwodywgazEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ID0gRnIubXVsKHcsIGsyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdFNlZW5bc2lnbmFsSWRdID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlTGFncmFuZ2VQb2x5bm9taWFscyhmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04pO1xuXG4gICAgICAgIGNvbnN0IGwgPSBNYXRoLm1heChzZXR0aW5ncy5uUHVibGljLCAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBidWZmID0gbmV3IEJpZ0J1ZmZlcihzZXR0aW5ncy5kb21haW5TaXplICogc0ZyKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KEZyLm9uZSwgaSAqIHNGcik7XG5cbiAgICAgICAgICAgIGF3YWl0IHdyaXRlUDQoZmRaS2V5LCBidWZmKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVB0YXUoZmRaS2V5KSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgWktFWV9GRl9QVEFVX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIGRvbWFpblNpemUgKiA5ICsgMTggPSBtYXhpbXVtIFNSUyBsZW5ndGggbmVlZGVkLCBzcGVjaWZpY2FsbHkgdG8gY29tbWl0IEMyXG4gICAgICAgIFBUYXUgPSBuZXcgQmlnQnVmZmVyKChzZXR0aW5ncy5kb21haW5TaXplICogOSArIDE4KSAqIHNHMSk7XG4gICAgICAgIGF3YWl0IGZkUFRhdS5yZWFkVG9CdWZmZXIoUFRhdSwgMCwgKHNldHRpbmdzLmRvbWFpblNpemUgKiA5ICsgMTgpICogc0cxLCBwVGF1U2VjdGlvbnNbMl1bMF0ucCk7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKFBUYXUpO1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUMwKGZkWktleSkge1xuICAgICAgICAvLyBDMChYKSA6PSBRTChYXjgpICsgWCDCtyBRUihYXjgpICsgWF4yIMK3IFFPKFheOCkgKyBYXjMgwrcgUU0oWF44KSArIFheNCDCtyBRQyhYXjgpXG4gICAgICAgIC8vICAgICAgICAgICAgKyBYXjUgwrcgU0lHTUExKFheOCkgKyBYXjYgwrcgU0lHTUEyKFheOCkgKyBYXjcgwrcgU0lHTUEzKFheOClcbiAgICAgICAgbGV0IEMwID0gbmV3IENQb2x5bm9taWFsKDgsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDAsIHBvbHlub21pYWxzLlFMKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCgxLCBwb2x5bm9taWFscy5RUik7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoMiwgcG9seW5vbWlhbHMuUU8pO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDMsIHBvbHlub21pYWxzLlFNKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCg0LCBwb2x5bm9taWFscy5RQyk7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoNSwgcG9seW5vbWlhbHMuUzEpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDYsIHBvbHlub21pYWxzLlMyKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCg3LCBwb2x5bm9taWFscy5TMyk7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuQzAgPSBDMC5nZXRQb2x5bm9taWFsKCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgIGlmIChwb2x5bm9taWFscy5DMC5kZWdyZWUoKSA+PSA4ICogc2V0dGluZ3MuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQzAgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBaS0VZX0ZGX0MwX1NFQ1RJT04pO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUocG9seW5vbWlhbHMuQzAuY29lZik7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRkZsb25rSGVhZGVyKGZkWktleSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIFpLRVlfRkZfSEVBREVSX1NFQ1RJT04pO1xuXG4gICAgICAgIGNvbnN0IHByaW1lUSA9IGN1cnZlLnE7XG4gICAgICAgIGNvbnN0IG44cSA9IChNYXRoLmZsb29yKChTY2FsYXIuYml0TGVuZ3RoKHByaW1lUSkgLSAxKSAvIDY0KSArIDEpICogODtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhxKTtcbiAgICAgICAgYXdhaXQgd3JpdGVCaWdJbnQoZmRaS2V5LCBwcmltZVEsIG44cSk7XG5cbiAgICAgICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICAgICAgY29uc3QgbjhyID0gKE1hdGguZmxvb3IoKFNjYWxhci5iaXRMZW5ndGgocHJpbWVSKSAtIDEpIC8gNjQpICsgMSkgKiA4O1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHIpO1xuICAgICAgICBhd2FpdCB3cml0ZUJpZ0ludChmZFpLZXksIHByaW1lUiwgbjhyKTtcblxuICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcjFjcyB2YXJzXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHNldHRpbmdzLm5WYXJzKTtcbiAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIHIxY3MgcHVibGljIHZhcnMgPSBvdXRwdXRzICsgcHVibGljIGlucHV0c1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihzZXR0aW5ncy5uUHVibGljKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoc2V0dGluZ3MuZG9tYWluU2l6ZSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQWRkaXRpb25zLmxlbmd0aCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQ29uc3RyYWludHMubGVuZ3RoKTtcblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoazEpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoazIpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3Myk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3NCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3OCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3cik7XG5cbiAgICAgICAgbGV0IGJYXzI7XG4gICAgICAgIGJYXzIgPSBhd2FpdCBmZFBUYXUucmVhZChzRzIsIHBUYXVTZWN0aW9uc1szXVswXS5wICsgc0cyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJYXzIpO1xuXG4gICAgICAgIGxldCBjb21taXRDMCA9IGF3YWl0IHBvbHlub21pYWxzLkMwLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJDMFwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGNvbW1pdEMwKTtcblxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVA0KGZkWktleSwgYnVmZikge1xuICAgICAgICBjb25zdCBbY29lZmZpY2llbnRzLCBldmFsdWF0aW9uczRdID0gYXdhaXQgUG9seW5vbWlhbC50bzRUKGJ1ZmYsIHNldHRpbmdzLmRvbWFpblNpemUsIFtdLCBGcik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShjb2VmZmljaWVudHMpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoZXZhbHVhdGlvbnM0KTtcblxuICAgICAgICByZXR1cm4gW2NvZWZmaWNpZW50cywgZXZhbHVhdGlvbnM0XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlSzFLMigpIHtcbiAgICAgICAgbGV0IGsxID0gRnIudHdvO1xuICAgICAgICB3aGlsZSAoaXNJbmNsdWRlZChrMSwgW10sIHNldHRpbmdzLmNpclBvd2VyKSkgRnIuYWRkKGsxLCBGci5vbmUpO1xuICAgICAgICBsZXQgazIgPSBGci5hZGQoazEsIEZyLm9uZSk7XG4gICAgICAgIHdoaWxlIChpc0luY2x1ZGVkKGsyLCBbazFdLCBzZXR0aW5ncy5jaXJQb3dlcikpIEZyLmFkZChrMiwgRnIub25lKTtcbiAgICAgICAgcmV0dXJuIFtrMSwgazJdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzSW5jbHVkZWQoaywga0FyciwgcG93KSB7XG4gICAgICAgICAgICBjb25zdCBkb21haW5TaXplID0gMiAqKiBwb3c7XG4gICAgICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZyLmVxKGssIHcpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtBcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEZyLmVxKGssIEZyLm11bChrQXJyW2pdLCB3KSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbcG93XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlVzMoKSB7XG4gICAgICAgIGxldCBnZW5lcmF0b3IgPSBGci5lKDMxNjI0KTtcblxuICAgICAgICAvLyBFeHBvbmVudCBpcyBvcmRlcihyIC0gMSkgLyAzXG4gICAgICAgIGxldCBvcmRlclJzdWIxID0gMzY0ODA0MDQ3ODYzOTg3OTIwMzcwNzczNDI5MDg3NjIxMjUxNDc1ODA2MDczMzQwMjY3MjM5MDYxNjM2NzM2NDQyOTMwMTQxNTkzNm47XG4gICAgICAgIGxldCBleHBvbmVudCA9IFNjYWxhci5kaXYob3JkZXJSc3ViMSwgU2NhbGFyLmUoMykpO1xuXG4gICAgICAgIHJldHVybiBGci5leHAoZ2VuZXJhdG9yLCBleHBvbmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVc0KCkge1xuICAgICAgICByZXR1cm4gRnIud1syXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlVzgoKSB7XG4gICAgICAgIHJldHVybiBGci53WzNdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE9tZWdhQ3ViaWNSb290KHBvd2VyLCBGcikge1xuICAgICAgICAvLyBIYXJkY29yZGVkIDN0aC1yb290IG9mIEZyLndbMjhdXG4gICAgICAgIGNvbnN0IGZpcnN0Um9vdCA9IEZyLmUoNDY3Nzk5MTY1ODg2MDY5NjEwMDM2MDQ2ODY2Nzk5MjY0MDI2NDgxMzQ0Mjk5MDc5MDExNzYyMDI2Nzc0NTMzNzc0MzQ1OTg4MDgwbik7XG5cbiAgICAgICAgcmV0dXJuIEZyLmV4cChmaXJzdFJvb3QsIDIgKiogKDI4IC0gcG93ZXIpKTtcbiAgICB9XG59XG5cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/fflonk_setup.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/fflonk_verify.js":
/*!***************************************************!*\
  !*** ./node_modules/snarkjs/src/fflonk_verify.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeLagrangeLiS2: () => (/* binding */ computeLagrangeLiS2),\n/* harmony export */   computeLagrangeLiSi: () => (/* binding */ computeLagrangeLiSi),\n/* harmony export */   \"default\": () => (/* binding */ fflonkVerify)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proof.js */ \"(ssr)/./node_modules/snarkjs/src/proof.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(ssr)/./node_modules/snarkjs/src/Keccak256Transcript.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst { unstringifyBigInts } = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nasync function fflonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    if (logger) logger.info(\"FFLONK VERIFIER STARTED\");\n\n    _vk_verifier = unstringifyBigInts(_vk_verifier);\n    _proof = unstringifyBigInts(_proof);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName(_vk_verifier.curve);\n\n    const vk = fromObjectVk(curve, _vk_verifier);\n\n    // TODO ??? Compute wr^3 and check if it matches with w\n\n    const proof = new _proof_js__WEBPACK_IMPORTED_MODULE_2__.Proof(curve, logger);\n    proof.fromObjectProof(_proof);\n\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    if (publicSignals.length !== vk.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const Fr = curve.Fr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK VERIFY SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${vk.power}`);\n        logger.info(`  Domain size:   ${2 ** vk.power}`);\n        logger.info(`  Public vars:   ${vk.nPublic}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // STEP 1 - Validate that all polynomial commitments  G_1\n    if (logger) logger.info(\"> Checking commitments belong to G1\");\n    if (!commitmentsBelongToG1(curve, proof, vk)) {\n        if (logger) logger.error(\"Proof commitments are not valid\");\n        return false;\n    }\n\n    // STEP 2 - Validate that all evaluations  F\n    if (logger) logger.info(\"> Checking evaluations belong to F\");\n    if (!evaluationsAreValid(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid.\");\n        return false;\n    }\n\n    // STEP 3 - Validate that w_i  F for i  [l]\n    if (logger) logger.info(\"> Checking public inputs belong to F\");\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    // STEP 4 - Compute the challenges: beta, gamma, xi, alpha and y  F\n    // as in prover description, from the common preprocessed inputs, public inputs and elements of _SNARK\n    if (logger) logger.info(\"> Computing challenges\");\n    const { challenges, roots } = computeChallenges(curve, proof, vk, publicSignals, logger);\n\n    // STEP 5 - Compute the zero polynomial evaluation Z_H(xi) = xi^n - 1\n    if (logger) logger.info(\"> Computing Zero polynomial evaluation Z_H(xi)\");\n    challenges.zh = Fr.sub(challenges.xiN, Fr.one);\n    challenges.invzh = Fr.inv(challenges.zh);\n\n    // STEP 6 - Compute the lagrange polynomial evaluation L_1(xi)\n    if (logger) logger.info(\"> Computing Lagrange evaluations\");\n    const lagrangeEvals = await computeLagrangeEvaluations(curve, challenges, vk);\n\n    // STEP 7 - Compute public input evaluation PI(xi)\n    if (logger) logger.info(\"> Computing polynomial identities PI(X)\");\n    const pi = calculatePI(curve, publicSignals, lagrangeEvals);\n\n    // STEP 8 - Compute polynomial r0  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r0(y)\");\n    const r0 = computeR0(proof, challenges, roots, curve, logger);\n\n    // STEP 9 - Compute polynomial r1  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r1(y)\");\n    const r1 = computeR1(proof, challenges, roots, pi, curve, logger);\n\n    // STEP 9 - Compute polynomial r2  F_{<6}[X]\n    if (logger) logger.info(\"> Computing r2(y)\");\n    const r2 = computeR2(proof, challenges, roots, lagrangeEvals[1], vk, curve, logger);\n\n    if (logger) logger.info(\"> Computing F\");\n    const F = computeF(curve, proof, vk, challenges, roots);\n\n    if (logger) logger.info(\"> Computing E\");\n    const E = computeE(curve, proof, challenges, vk, r0, r1, r2);\n\n    if (logger) logger.info(\"> Computing J\");\n    const J = computeJ(curve, proof, challenges);\n\n    if (logger) logger.info(\"> Validate all evaluations with a pairing\");\n    const res = await isValidPairing(curve, proof, challenges, vk, F, E, J);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"PROOF VERIFIED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    if (logger) logger.info(\"FFLONK VERIFIER FINISHED\");\n\n    return res;\n\n}\n\nfunction fromObjectVk(curve, vk) {\n    const res = vk;\n    res.k1 = curve.Fr.fromObject(vk.k1);\n    res.k2 = curve.Fr.fromObject(vk.k2);\n    res.w = curve.Fr.fromObject(vk.w);\n    // res.wW = curve.Fr.fromObject(vk.wW);\n    res.w3 = curve.Fr.fromObject(vk.w3);\n    res.w4 = curve.Fr.fromObject(vk.w4);\n    res.w8 = curve.Fr.fromObject(vk.w8);\n    res.wr = curve.Fr.fromObject(vk.wr);\n    res.X_2 = curve.G2.fromObject(vk.X_2);\n    res.C0 = curve.G1.fromObject(vk.C0);\n    return res;\n}\n\nfunction commitmentsBelongToG1(curve, proof, vk) {\n    const G1 = curve.G1;\n    return G1.isValid(proof.polynomials.C1)\n        && G1.isValid(proof.polynomials.C2)\n        && G1.isValid(proof.polynomials.W1)\n        && G1.isValid(proof.polynomials.W2)\n        && G1.isValid(vk.C0);\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.geq(value, 0) && ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid(curve, evaluation) {\n    return checkValueBelongToField(curve, ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid(curve, proof) {\n    return checkEvaluationIsValid(curve, proof.evaluations.ql)\n        && checkEvaluationIsValid(curve, proof.evaluations.qr)\n        && checkEvaluationIsValid(curve, proof.evaluations.qm)\n        && checkEvaluationIsValid(curve, proof.evaluations.qo)\n        && checkEvaluationIsValid(curve, proof.evaluations.qc)\n        && checkEvaluationIsValid(curve, proof.evaluations.s1)\n        && checkEvaluationIsValid(curve, proof.evaluations.s2)\n        && checkEvaluationIsValid(curve, proof.evaluations.s3)\n        && checkEvaluationIsValid(curve, proof.evaluations.a)\n        && checkEvaluationIsValid(curve, proof.evaluations.b)\n        && checkEvaluationIsValid(curve, proof.evaluations.c)\n        && checkEvaluationIsValid(curve, proof.evaluations.z)\n        && checkEvaluationIsValid(curve, proof.evaluations.zw)\n        && checkEvaluationIsValid(curve, proof.evaluations.t1w)\n        && checkEvaluationIsValid(curve, proof.evaluations.t2w);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction computeChallenges(curve, proof, vk, publicSignals, logger) {\n    const Fr = curve.Fr;\n\n    const challenges = {};\n    const roots = {};\n    const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_3__.Keccak256Transcript(curve);\n\n    // Add C0 to the transcript\n    transcript.addPolCommitment(vk.C0);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.polynomials.C1);\n    challenges.beta = transcript.getChallenge();\n    transcript.reset();\n\n    transcript.addScalar(challenges.beta);\n    challenges.gamma = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.gamma);\n    transcript.addPolCommitment(proof.polynomials.C2);\n    const xiSeed = transcript.getChallenge();\n    const xiSeed2 = Fr.square(xiSeed);\n\n    let w8 = [];\n    w8[1] = vk.w8;\n    w8[2] = Fr.square(vk.w8);\n    w8[3] = Fr.mul(w8[2], vk.w8);\n    w8[4] = Fr.mul(w8[3], vk.w8);\n    w8[5] = Fr.mul(w8[4], vk.w8);\n    w8[6] = Fr.mul(w8[5], vk.w8);\n    w8[7] = Fr.mul(w8[6], vk.w8);\n    let w4 = [];\n    w4[1] = vk.w4;\n    w4[2] = Fr.square(vk.w4);\n    w4[3] = Fr.mul(w4[2], vk.w4);\n    let w3 = [];\n    w3[1] = vk.w3;\n    w3[2] = Fr.square(vk.w3);\n\n    // const w4_2 = Fr.square(vk.w4);\n    // const w4_3 = Fr.mul(w4_2, vk.w4);\n    // const w3_2 = Fr.square(vk.w3);\n\n    // Compute h0 = xiSeeder^3\n    roots.S0 = {};\n    roots.S0.h0w8 = [];\n    roots.S0.h0w8[0] = Fr.mul(xiSeed2, xiSeed);\n    for (let i = 1; i < 8; i++) {\n        roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], w8[i]);\n    }\n\n    // Compute h1 = xi_seeder^6\n    roots.S1 = {};\n    roots.S1.h1w4 = [];\n    roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n    for (let i = 1; i < 4; i++) {\n        roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], w4[i]);\n    }\n\n    // Compute h2 = xi_seeder^8\n    roots.S2 = {};\n    roots.S2.h2w3 = [];\n    roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n    roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], w3[1]);\n    roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], w3[2]);\n\n    roots.S2.h3w3 = [];\n    // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n    // So, h3 = xi_seeder^8 ^{1/3}\n    roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], vk.wr);\n    roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], w3[1]);\n    roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], w3[2]);\n\n    // Compute xi = xi_seeder^12\n    challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n    challenges.xiw = Fr.mul(challenges.xi, Fr.w[vk.power]);\n\n    challenges.xiN = challenges.xi;\n    vk.domainSize = 1;\n    for (let i = 0; i < vk.power; i++) {\n        challenges.xiN = Fr.square(challenges.xiN);\n        vk.domainSize *= 2;\n    }\n\n    transcript.reset();\n    transcript.addScalar(xiSeed);\n    transcript.addScalar(proof.evaluations.ql);\n    transcript.addScalar(proof.evaluations.qr);\n    transcript.addScalar(proof.evaluations.qm);\n    transcript.addScalar(proof.evaluations.qo);\n    transcript.addScalar(proof.evaluations.qc);\n    transcript.addScalar(proof.evaluations.s1);\n    transcript.addScalar(proof.evaluations.s2);\n    transcript.addScalar(proof.evaluations.s3);\n    transcript.addScalar(proof.evaluations.a);\n    transcript.addScalar(proof.evaluations.b);\n    transcript.addScalar(proof.evaluations.c);\n    transcript.addScalar(proof.evaluations.z);\n    transcript.addScalar(proof.evaluations.zw);\n    transcript.addScalar(proof.evaluations.t1w);\n    transcript.addScalar(proof.evaluations.t2w);\n    challenges.alpha = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.alpha);\n    transcript.addPolCommitment(proof.polynomials.W1);\n    challenges.y = transcript.getChallenge();\n\n    if (logger) {\n        logger.info(\" challenges.beta:  \" + Fr.toString(challenges.beta));\n        logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n        logger.info(\" challenges.xi:    \" + Fr.toString(challenges.xi));\n        logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n        logger.info(\" challenges.y:     \" + Fr.toString(challenges.y));\n    }\n\n    return { challenges: challenges, roots: roots };\n}\n\nasync function computeLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    const size = Math.max(1, vk.nPublic);\n    const numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.BigBuffer(size * Fr.n8);\n    let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.BigBuffer(size * Fr.n8);\n\n    let w = Fr.one;\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        numArr.set(Fr.mul(w, challenges.zh), i_sFr);\n        denArr.set(Fr.mul(Fr.e(vk.domainSize), Fr.sub(challenges.xi, w)), i_sFr);\n        w = Fr.mul(w, vk.w);\n    }\n\n    denArr = await Fr.batchInverse(denArr);\n\n    let L = [];\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        L[i + 1] = Fr.mul(numArr.slice(i_sFr, i_sFr + Fr.n8), denArr.slice(i_sFr, i_sFr + Fr.n8));\n    }\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, lagrangeEvals) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i = 0; i < publicSignals.length; i++) {\n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, lagrangeEvals[i + 1]));\n    }\n    return pi;\n}\n\nfunction computeR0(proof, challenges, roots, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S0.h0w8, challenges.y, challenges.xi, curve);\n\n    // r0(y) = _1^8 C_0(h_0 _8^{i-1}) L_i(y). To this end we need to compute\n\n    // Compute the 8 C0 values\n    if (logger) logger.info(\" Computing r0(y)\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 8; i++) {\n        let coefValues = [];\n        coefValues[1] = roots.S0.h0w8[i];\n        for (let j = 2; j < 8; j++) {\n            coefValues[j] = Fr.mul(coefValues[j - 1], roots.S0.h0w8[i]);\n        }\n\n        let c0 = Fr.add(proof.evaluations.ql, Fr.mul(proof.evaluations.qr, coefValues[1]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qo, coefValues[2]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qm, coefValues[3]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qc, coefValues[4]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s1, coefValues[5]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s2, coefValues[6]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s3, coefValues[7]));\n\n        res = Fr.add(res, Fr.mul(c0, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR1(proof, challenges, roots, pi, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S1.h1w4, challenges.y, challenges.xi, curve);\n\n    // r1(y) = _1^4 C_1(h_1 _4^{i-1}) L_i(y). To this end we need to compute\n    // Z1 = {C1(h_1}, C1(h_1 _4), C1(h_1 _4^2), C1(h_1 _4^3)}\n    // where C_1(h_1 _4^{i-1}) = eval.a + h_1 _4^i eval.b + (h_1 _4^i)^2 eval.c + (h_1 _4^i)^3 T0(xi),\n    // where T0(xi) = [ qLa + qRb + qMab + qOc + qC + PI(xi) ] / Z_H(xi)\n\n    // Compute T0(xi)\n    if (logger) logger.info(\" Computing T0(xi)\");\n    let t0 = Fr.mul(proof.evaluations.ql, proof.evaluations.a);\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qr, proof.evaluations.b));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qm, Fr.mul(proof.evaluations.a, proof.evaluations.b)));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qo, proof.evaluations.c));\n    t0 = Fr.add(t0, proof.evaluations.qc);\n    t0 = Fr.add(t0, pi);\n    t0 = Fr.mul(t0, challenges.invzh);\n\n    // Compute the 4 C1 values\n    if (logger) logger.info(\" Computing C1(h_1_4^i) values\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 4; i++) {\n        let c1 = proof.evaluations.a;\n        c1 = Fr.add(c1, Fr.mul(roots.S1.h1w4[i], proof.evaluations.b));\n        const h1w4Squared = Fr.square(roots.S1.h1w4[i]);\n        c1 = Fr.add(c1, Fr.mul(h1w4Squared, proof.evaluations.c));\n        c1 = Fr.add(c1, Fr.mul(Fr.mul(h1w4Squared, roots.S1.h1w4[i]), t0));\n\n        res = Fr.add(res, Fr.mul(c1, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR2(proof, challenges, roots, lagrange1, vk, curve, logger) {\n    const Fr = curve.Fr;\n\n    const LiS2 = computeLagrangeLiS2([roots.S2.h2w3, roots.S2.h3w3], challenges.y, challenges.xi, challenges.xiw, curve);\n\n    // r2(y) = _1^3 C_2(h_2 _3^{i-1}) L_i(y) + _1^3 C_2(h_3 _3^{i-1}) L_{i+3}(y). To this end we need to compute\n    // Z2 = {[C2(h_2}, C2(h_2 _3), C2(h_2 _3^2)], [C2(h_3}, C2(h_3 _3), C2(h_3 _3^2)]}\n    // where C_2(h_2 _3^{i-1}) = eval.z + h_2 _2^i T1(xi) + (h_2 _3^i)^2 T2(xi),\n    // where C_2(h_3 _3^{i-1}) = eval.z + h_3 _2^i T1(xi) + (h_3 _3^i)^2 T2(xi),\n    // where T1(xi) = [ L_1(xi)(z-1)] / Z_H(xi)\n    // and T2(xi) = [  (a + betaxi + gamma)(b + betaxik1 + gamma)(c + betaxik2 + gamma)z\n    //               - (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)z  ] / Z_H(xi)\n\n    // Compute T1(xi)\n    if (logger) logger.info(\" Computing T1(xi)\");\n    let t1 = Fr.sub(proof.evaluations.z, Fr.one);\n    t1 = Fr.mul(t1, lagrange1);\n    t1 = Fr.mul(t1, challenges.invzh);\n\n    // Compute T2(xi)\n    if (logger) logger.info(\" Computing T2(xi)\");\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n    const t211 = Fr.add(proof.evaluations.a, Fr.add(betaxi, challenges.gamma));\n    const t212 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(betaxi, vk.k1), challenges.gamma));\n    const t213 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(betaxi, vk.k2), challenges.gamma));\n    const t21 = Fr.mul(t211, Fr.mul(t212, Fr.mul(t213, proof.evaluations.z)));\n\n    const t221 = Fr.add(proof.evaluations.a, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s1), challenges.gamma));\n    const t222 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s2), challenges.gamma));\n    const t223 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s3), challenges.gamma));\n    const t22 = Fr.mul(t221, Fr.mul(t222, Fr.mul(t223, proof.evaluations.zw)));\n\n    let t2 = Fr.sub(t21, t22);\n    t2 = Fr.mul(t2, challenges.invzh);\n\n    // Compute the 6 C2 values\n    if (logger) logger.info(\" Computing C2(h_2_3^i) values\");\n    let res = Fr.zero;\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.z, Fr.mul(roots.S2.h2w3[i], t1));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h2w3[i]), t2));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i]));\n    }\n\n    if (logger) logger.info(\" Computing C2(h_3_3^i) values\");\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.zw, Fr.mul(roots.S2.h3w3[i], proof.evaluations.t1w));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h3w3[i]), proof.evaluations.t2w));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i + 3]));\n    }\n\n    return res;\n}\n\nfunction computeF(curve, proof, vk, challenges, roots) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let mulH0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n    for (let i = 1; i < 8; i++) {\n        mulH0 = Fr.mul(mulH0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n    }\n\n    challenges.temp = mulH0;\n\n    let mulH1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n    for (let i = 1; i < 4; i++) {\n        mulH1 = Fr.mul(mulH1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n    }\n\n    let mulH2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n    for (let i = 1; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n    }\n    for (let i = 0; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n    }\n\n    challenges.quotient1 = Fr.mul(challenges.alpha, Fr.div(mulH0, mulH1));\n    challenges.quotient2 = Fr.mul(Fr.square(challenges.alpha), Fr.div(mulH0, mulH2));\n\n    let F2 = G1.timesFr(proof.polynomials.C1, challenges.quotient1);\n    let F3 = G1.timesFr(proof.polynomials.C2, challenges.quotient2);\n\n    return G1.add(vk.C0, G1.add(F2, F3));\n}\n\nfunction computeE(curve, proof, challenges, vk, r0, r1, r2) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let E2 = Fr.mul(r1, challenges.quotient1);\n    let E3 = Fr.mul(r2, challenges.quotient2);\n\n    return G1.timesFr(G1.one, Fr.add(r0, Fr.add(E2, E3)));\n}\n\nfunction computeJ(curve, proof, challenges) {\n    const G1 = curve.G1;\n\n    return G1.timesFr(proof.polynomials.W1, challenges.temp);\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, F, E, J) {\n    const G1 = curve.G1;\n\n    let A1 = G1.timesFr(proof.polynomials.W2, challenges.y);\n    A1 = G1.add(G1.sub(G1.sub(F, E), J), A1);\n    const A2 = curve.G2.one;\n\n    const B1 = proof.polynomials.W2;\n    const B2 = vk.X_2;\n\n    return await curve.pairingEq(G1.neg(A1), A2, B1, B2);\n}\n\n\nfunction computeLagrangeLiSi(roots, x, xi, curve) {\n    const Fr = curve.Fr;\n    const len = roots.length;\n\n    const num = Fr.sub(Fr.exp(x, len), xi);\n    const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n\n    const Li = [];\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[((len - 1) * i) % len];\n        const den3 = Fr.sub(x, roots[i]);\n\n        Li[i] = Fr.div(num, Fr.mul(Fr.mul(den1, den2), den3));\n    }\n\n    return Li;\n}\n\nfunction computeLagrangeLiS2(roots, value, xi0, xi1, curve) {\n    const Fr = curve.Fr;\n\n    const Li = [];\n\n    const len = roots[0].length;\n    const n = len * roots.length;\n\n    const num1 = Fr.exp(value, n);\n    const num2 = Fr.mul(Fr.add(xi0, xi1), Fr.exp(value, len));\n    const num3 = Fr.mul(xi0, xi1);\n    const num = Fr.add(Fr.sub(num1, num2), num3);\n\n    let den1 = Fr.mul(Fr.mul(Fr.e(len), roots[0][0]), Fr.sub(xi0, xi1));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[0][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[0][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i] = Fr.div(num, den);\n    }\n\n    den1 = Fr.mul(Fr.mul(Fr.e(len), roots[1][0]), Fr.sub(xi1, xi0));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[1][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[1][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i + len] = Fr.div(num, den);\n    }\n\n    return Li;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3ZlcmlmeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0M7QUFDVTtBQUNiO0FBQzRCO0FBQ3pCOztBQUV0QyxRQUFRLHFCQUFxQixFQUFFLCtDQUFLOztBQUVyQjtBQUNmOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLHdEQUF1Qjs7QUFFL0M7O0FBRUE7O0FBRUEsc0JBQXNCLDRDQUFLO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25ELHdDQUF3QyxTQUFTO0FBQ2pELHdDQUF3QyxjQUFjO0FBQ3RELHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTs7QUFFQSwyQ0FBMkMsR0FBRztBQUM5QztBQUNBOztBQUVBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0RBQU0sa0JBQWtCLGdEQUFNO0FBQ3pDOztBQUVBO0FBQ0EsMENBQTBDLGdEQUFNO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsd0VBQW1COztBQUU5QztBQUNBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1EQUFTO0FBQ2hDLHFCQUFxQixtREFBUzs7QUFFOUI7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLElBQUk7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsSUFBSTtBQUN0QyxhQUFhLE9BQU87QUFDcEIsMEJBQTBCLElBQUk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtDQUFrQyxJQUFJLDhCQUE4QixJQUFJLEtBQUssSUFBSTtBQUNqRixhQUFhLFFBQVEsdUNBQXVDO0FBQzVELDBCQUEwQixJQUFJO0FBQzlCLDBCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3ZlcmlmeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBjdXJ2ZXMgZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgeyBCaWdCdWZmZXIsIHV0aWxzIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0IHsgUHJvb2YgfSBmcm9tIFwiLi9wcm9vZi5qc1wiO1xuaW1wb3J0IHsgS2VjY2FrMjU2VHJhbnNjcmlwdCB9IGZyb20gXCIuL0tlY2NhazI1NlRyYW5zY3JpcHQuanNcIjtcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuY29uc3QgeyB1bnN0cmluZ2lmeUJpZ0ludHMgfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmZmxvbmtWZXJpZnkoX3ZrX3ZlcmlmaWVyLCBfcHVibGljU2lnbmFscywgX3Byb29mLCBsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBWRVJJRklFUiBTVEFSVEVEXCIpO1xuXG4gICAgX3ZrX3ZlcmlmaWVyID0gdW5zdHJpbmdpZnlCaWdJbnRzKF92a192ZXJpZmllcik7XG4gICAgX3Byb29mID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wcm9vZik7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGN1cnZlcy5nZXRDdXJ2ZUZyb21OYW1lKF92a192ZXJpZmllci5jdXJ2ZSk7XG5cbiAgICBjb25zdCB2ayA9IGZyb21PYmplY3RWayhjdXJ2ZSwgX3ZrX3ZlcmlmaWVyKTtcblxuICAgIC8vIFRPRE8gPz8/IENvbXB1dGUgd3JeMyBhbmQgY2hlY2sgaWYgaXQgbWF0Y2hlcyB3aXRoIHdcblxuICAgIGNvbnN0IHByb29mID0gbmV3IFByb29mKGN1cnZlLCBsb2dnZXIpO1xuICAgIHByb29mLmZyb21PYmplY3RQcm9vZihfcHJvb2YpO1xuXG4gICAgY29uc3QgcHVibGljU2lnbmFscyA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHVibGljU2lnbmFscyk7XG5cbiAgICBpZiAocHVibGljU2lnbmFscy5sZW5ndGggIT09IHZrLm5QdWJsaWMpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTnVtYmVyIG9mIHB1YmxpYyBzaWduYWxzIGRvZXMgbm90IG1hdGNoIHdpdGggdmtcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiICBGRkxPTksgVkVSSUZZIFNFVFRJTkdTXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXJ2ZTogICAgICAgICAke2N1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENpcmN1aXQgcG93ZXI6ICR7dmsucG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIERvbWFpbiBzaXplOiAgICR7MiAqKiB2ay5wb3dlcn1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHVibGljIHZhcnM6ICAgJHt2ay5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgLy8gU1RFUCAxIC0gVmFsaWRhdGUgdGhhdCBhbGwgcG9seW5vbWlhbCBjb21taXRtZW50cyDiiIggR18xXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENoZWNraW5nIGNvbW1pdG1lbnRzIGJlbG9uZyB0byBHMVwiKTtcbiAgICBpZiAoIWNvbW1pdG1lbnRzQmVsb25nVG9HMShjdXJ2ZSwgcHJvb2YsIHZrKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQcm9vZiBjb21taXRtZW50cyBhcmUgbm90IHZhbGlkXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU1RFUCAyIC0gVmFsaWRhdGUgdGhhdCBhbGwgZXZhbHVhdGlvbnMg4oiIIEZcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ2hlY2tpbmcgZXZhbHVhdGlvbnMgYmVsb25nIHRvIEZcIik7XG4gICAgaWYgKCFldmFsdWF0aW9uc0FyZVZhbGlkKGN1cnZlLCBwcm9vZikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUHJvb2YgZXZhbHVhdGlvbnMgYXJlIG5vdCB2YWxpZC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTVEVQIDMgLSBWYWxpZGF0ZSB0aGF0IHdfaSDiiIggRiBmb3IgaSDiiIggW2xdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENoZWNraW5nIHB1YmxpYyBpbnB1dHMgYmVsb25nIHRvIEZcIik7XG4gICAgaWYgKCFwdWJsaWNJbnB1dHNBcmVWYWxpZChjdXJ2ZSwgcHVibGljU2lnbmFscykpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUHVibGljIGlucHV0cyBhcmUgbm90IHZhbGlkLlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNURVAgNCAtIENvbXB1dGUgdGhlIGNoYWxsZW5nZXM6IGJldGEsIGdhbW1hLCB4aSwgYWxwaGEgYW5kIHkg4oiIIEZcbiAgICAvLyBhcyBpbiBwcm92ZXIgZGVzY3JpcHRpb24sIGZyb20gdGhlIGNvbW1vbiBwcmVwcm9jZXNzZWQgaW5wdXRzLCBwdWJsaWMgaW5wdXRzIGFuZCBlbGVtZW50cyBvZiDPgF9TTkFSS1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlc1wiKTtcbiAgICBjb25zdCB7IGNoYWxsZW5nZXMsIHJvb3RzIH0gPSBjb21wdXRlQ2hhbGxlbmdlcyhjdXJ2ZSwgcHJvb2YsIHZrLCBwdWJsaWNTaWduYWxzLCBsb2dnZXIpO1xuXG4gICAgLy8gU1RFUCA1IC0gQ29tcHV0ZSB0aGUgemVybyBwb2x5bm9taWFsIGV2YWx1YXRpb24gWl9IKHhpKSA9IHhpXm4gLSAxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBaZXJvIHBvbHlub21pYWwgZXZhbHVhdGlvbiBaX0goeGkpXCIpO1xuICAgIGNoYWxsZW5nZXMuemggPSBGci5zdWIoY2hhbGxlbmdlcy54aU4sIEZyLm9uZSk7XG4gICAgY2hhbGxlbmdlcy5pbnZ6aCA9IEZyLmludihjaGFsbGVuZ2VzLnpoKTtcblxuICAgIC8vIFNURVAgNiAtIENvbXB1dGUgdGhlIGxhZ3JhbmdlIHBvbHlub21pYWwgZXZhbHVhdGlvbiBMXzEoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBMYWdyYW5nZSBldmFsdWF0aW9uc1wiKTtcbiAgICBjb25zdCBsYWdyYW5nZUV2YWxzID0gYXdhaXQgY29tcHV0ZUxhZ3JhbmdlRXZhbHVhdGlvbnMoY3VydmUsIGNoYWxsZW5nZXMsIHZrKTtcblxuICAgIC8vIFNURVAgNyAtIENvbXB1dGUgcHVibGljIGlucHV0IGV2YWx1YXRpb24gUEkoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBwb2x5bm9taWFsIGlkZW50aXRpZXMgUEkoWClcIik7XG4gICAgY29uc3QgcGkgPSBjYWxjdWxhdGVQSShjdXJ2ZSwgcHVibGljU2lnbmFscywgbGFncmFuZ2VFdmFscyk7XG5cbiAgICAvLyBTVEVQIDggLSBDb21wdXRlIHBvbHlub21pYWwgcjAg4oiIIEZfezw0fVtYXVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgcjAoeSlcIik7XG4gICAgY29uc3QgcjAgPSBjb21wdXRlUjAocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIC8vIFNURVAgOSAtIENvbXB1dGUgcG9seW5vbWlhbCByMSDiiIggRl97PDR9W1hdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyByMSh5KVwiKTtcbiAgICBjb25zdCByMSA9IGNvbXB1dGVSMShwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIHBpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIC8vIFNURVAgOSAtIENvbXB1dGUgcG9seW5vbWlhbCByMiDiiIggRl97PDZ9W1hdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyByMih5KVwiKTtcbiAgICBjb25zdCByMiA9IGNvbXB1dGVSMihwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIGxhZ3JhbmdlRXZhbHNbMV0sIHZrLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgRlwiKTtcbiAgICBjb25zdCBGID0gY29tcHV0ZUYoY3VydmUsIHByb29mLCB2aywgY2hhbGxlbmdlcywgcm9vdHMpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBFXCIpO1xuICAgIGNvbnN0IEUgPSBjb21wdXRlRShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrLCByMCwgcjEsIHIyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgSlwiKTtcbiAgICBjb25zdCBKID0gY29tcHV0ZUooY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBWYWxpZGF0ZSBhbGwgZXZhbHVhdGlvbnMgd2l0aCBhIHBhaXJpbmdcIik7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaXNWYWxpZFBhaXJpbmcoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRiwgRSwgSik7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiUFJPT0YgVkVSSUZJRUQgU1VDQ0VTU0ZVTExZXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJJbnZhbGlkIFByb29mXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgVkVSSUZJRVIgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4gcmVzO1xuXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3RWayhjdXJ2ZSwgdmspIHtcbiAgICBjb25zdCByZXMgPSB2aztcbiAgICByZXMuazEgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLmsxKTtcbiAgICByZXMuazIgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLmsyKTtcbiAgICByZXMudyA9IGN1cnZlLkZyLmZyb21PYmplY3Qodmsudyk7XG4gICAgLy8gcmVzLndXID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53Vyk7XG4gICAgcmVzLnczID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53Myk7XG4gICAgcmVzLnc0ID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53NCk7XG4gICAgcmVzLnc4ID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53OCk7XG4gICAgcmVzLndyID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53cik7XG4gICAgcmVzLlhfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmsuWF8yKTtcbiAgICByZXMuQzAgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrLkMwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb21taXRtZW50c0JlbG9uZ1RvRzEoY3VydmUsIHByb29mLCB2aykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgcmV0dXJuIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuQzEpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuQzIpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuVzEpXG4gICAgICAgICYmIEcxLmlzVmFsaWQocHJvb2YucG9seW5vbWlhbHMuVzIpXG4gICAgICAgICYmIEcxLmlzVmFsaWQodmsuQzApO1xufVxuXG5mdW5jdGlvbiBjaGVja1ZhbHVlQmVsb25nVG9GaWVsZChjdXJ2ZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gU2NhbGFyLmdlcSh2YWx1ZSwgMCkgJiYgU2NhbGFyLmx0KHZhbHVlLCBjdXJ2ZS5yKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgZXZhbHVhdGlvbikge1xuICAgIHJldHVybiBjaGVja1ZhbHVlQmVsb25nVG9GaWVsZChjdXJ2ZSwgU2NhbGFyLmZyb21ScHJMRShldmFsdWF0aW9uKSk7XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRpb25zQXJlVmFsaWQoY3VydmUsIHByb29mKSB7XG4gICAgcmV0dXJuIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnFsKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5xcilcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMucW0pXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnFvKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5xYylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuczEpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnMyKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5zMylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuYSlcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuYilcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuYylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMueilcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuencpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnQxdylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMudDJ3KTtcbn1cblxuZnVuY3Rpb24gcHVibGljSW5wdXRzQXJlVmFsaWQoY3VydmUsIHB1YmxpY0lucHV0cykge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwdWJsaWNJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoIWNoZWNrVmFsdWVCZWxvbmdUb0ZpZWxkKGN1cnZlLCBwdWJsaWNJbnB1dHNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaGFsbGVuZ2VzKGN1cnZlLCBwcm9vZiwgdmssIHB1YmxpY1NpZ25hbHMsIGxvZ2dlcikge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBjaGFsbGVuZ2VzID0ge307XG4gICAgY29uc3Qgcm9vdHMgPSB7fTtcbiAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuXG4gICAgLy8gQWRkIEMwIHRvIHRoZSB0cmFuc2NyaXB0XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLkMwKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVibGljU2lnbmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihGci5lKHB1YmxpY1NpZ25hbHNbaV0pKTtcbiAgICB9XG5cbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YucG9seW5vbWlhbHMuQzEpO1xuICAgIGNoYWxsZW5nZXMuYmV0YSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuXG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5iZXRhKTtcbiAgICBjaGFsbGVuZ2VzLmdhbW1hID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YucG9seW5vbWlhbHMuQzIpO1xuICAgIGNvbnN0IHhpU2VlZCA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgY29uc3QgeGlTZWVkMiA9IEZyLnNxdWFyZSh4aVNlZWQpO1xuXG4gICAgbGV0IHc4ID0gW107XG4gICAgdzhbMV0gPSB2ay53ODtcbiAgICB3OFsyXSA9IEZyLnNxdWFyZSh2ay53OCk7XG4gICAgdzhbM10gPSBGci5tdWwodzhbMl0sIHZrLnc4KTtcbiAgICB3OFs0XSA9IEZyLm11bCh3OFszXSwgdmsudzgpO1xuICAgIHc4WzVdID0gRnIubXVsKHc4WzRdLCB2ay53OCk7XG4gICAgdzhbNl0gPSBGci5tdWwodzhbNV0sIHZrLnc4KTtcbiAgICB3OFs3XSA9IEZyLm11bCh3OFs2XSwgdmsudzgpO1xuICAgIGxldCB3NCA9IFtdO1xuICAgIHc0WzFdID0gdmsudzQ7XG4gICAgdzRbMl0gPSBGci5zcXVhcmUodmsudzQpO1xuICAgIHc0WzNdID0gRnIubXVsKHc0WzJdLCB2ay53NCk7XG4gICAgbGV0IHczID0gW107XG4gICAgdzNbMV0gPSB2ay53MztcbiAgICB3M1syXSA9IEZyLnNxdWFyZSh2ay53Myk7XG5cbiAgICAvLyBjb25zdCB3NF8yID0gRnIuc3F1YXJlKHZrLnc0KTtcbiAgICAvLyBjb25zdCB3NF8zID0gRnIubXVsKHc0XzIsIHZrLnc0KTtcbiAgICAvLyBjb25zdCB3M18yID0gRnIuc3F1YXJlKHZrLnczKTtcblxuICAgIC8vIENvbXB1dGUgaDAgPSB4aVNlZWRlcl4zXG4gICAgcm9vdHMuUzAgPSB7fTtcbiAgICByb290cy5TMC5oMHc4ID0gW107XG4gICAgcm9vdHMuUzAuaDB3OFswXSA9IEZyLm11bCh4aVNlZWQyLCB4aVNlZWQpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIHJvb3RzLlMwLmgwdzhbaV0gPSBGci5tdWwocm9vdHMuUzAuaDB3OFswXSwgdzhbaV0pO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgaDEgPSB4aV9zZWVkZXJeNlxuICAgIHJvb3RzLlMxID0ge307XG4gICAgcm9vdHMuUzEuaDF3NCA9IFtdO1xuICAgIHJvb3RzLlMxLmgxdzRbMF0gPSBGci5zcXVhcmUocm9vdHMuUzAuaDB3OFswXSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgcm9vdHMuUzEuaDF3NFtpXSA9IEZyLm11bChyb290cy5TMS5oMXc0WzBdLCB3NFtpXSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBoMiA9IHhpX3NlZWRlcl44XG4gICAgcm9vdHMuUzIgPSB7fTtcbiAgICByb290cy5TMi5oMnczID0gW107XG4gICAgcm9vdHMuUzIuaDJ3M1swXSA9IEZyLm11bChyb290cy5TMS5oMXc0WzBdLCB4aVNlZWQyKTtcbiAgICByb290cy5TMi5oMnczWzFdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHczWzFdKTtcbiAgICByb290cy5TMi5oMnczWzJdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHczWzJdKTtcblxuICAgIHJvb3RzLlMyLmgzdzMgPSBbXTtcbiAgICAvLyBNdWx0aXBseSBoMyBieSB0aGlyZC1yb290LW9tZWdhIHRvIG9idGFpbiBoXzNeMyA9IHhpz4lcbiAgICAvLyBTbywgaDMgPSB4aV9zZWVkZXJeOCDPiV57MS8zfVxuICAgIHJvb3RzLlMyLmgzdzNbMF0gPSBGci5tdWwocm9vdHMuUzIuaDJ3M1swXSwgdmsud3IpO1xuICAgIHJvb3RzLlMyLmgzdzNbMV0gPSBGci5tdWwocm9vdHMuUzIuaDN3M1swXSwgdzNbMV0pO1xuICAgIHJvb3RzLlMyLmgzdzNbMl0gPSBGci5tdWwocm9vdHMuUzIuaDN3M1swXSwgdzNbMl0pO1xuXG4gICAgLy8gQ29tcHV0ZSB4aSA9IHhpX3NlZWRlcl4xMlxuICAgIGNoYWxsZW5nZXMueGkgPSBGci5tdWwoRnIuc3F1YXJlKHJvb3RzLlMyLmgydzNbMF0pLCByb290cy5TMi5oMnczWzBdKTtcbiAgICBjaGFsbGVuZ2VzLnhpdyA9IEZyLm11bChjaGFsbGVuZ2VzLnhpLCBGci53W3ZrLnBvd2VyXSk7XG5cbiAgICBjaGFsbGVuZ2VzLnhpTiA9IGNoYWxsZW5nZXMueGk7XG4gICAgdmsuZG9tYWluU2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ay5wb3dlcjsgaSsrKSB7XG4gICAgICAgIGNoYWxsZW5nZXMueGlOID0gRnIuc3F1YXJlKGNoYWxsZW5nZXMueGlOKTtcbiAgICAgICAgdmsuZG9tYWluU2l6ZSAqPSAyO1xuICAgIH1cblxuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcih4aVNlZWQpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnFsKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5xcik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMucW0pO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnFvKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5xYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuczEpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnMyKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5zMyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuYSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuYik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMueik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuencpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnQxdyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMudDJ3KTtcbiAgICBjaGFsbGVuZ2VzLmFscGhhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YucG9seW5vbWlhbHMuVzEpO1xuICAgIGNoYWxsZW5nZXMueSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuYmV0YTogIFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5iZXRhKSk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuZ2FtbWE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLnhpOiAgICBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5hbHBoYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmFscGhhKSk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMueTogICAgIFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy55KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY2hhbGxlbmdlczogY2hhbGxlbmdlcywgcm9vdHM6IHJvb3RzIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2aykge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgoMSwgdmsublB1YmxpYyk7XG4gICAgY29uc3QgbnVtQXJyID0gbmV3IEJpZ0J1ZmZlcihzaXplICogRnIubjgpO1xuICAgIGxldCBkZW5BcnIgPSBuZXcgQmlnQnVmZmVyKHNpemUgKiBGci5uOCk7XG5cbiAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBGci5uODtcbiAgICAgICAgbnVtQXJyLnNldChGci5tdWwodywgY2hhbGxlbmdlcy56aCksIGlfc0ZyKTtcbiAgICAgICAgZGVuQXJyLnNldChGci5tdWwoRnIuZSh2ay5kb21haW5TaXplKSwgRnIuc3ViKGNoYWxsZW5nZXMueGksIHcpKSwgaV9zRnIpO1xuICAgICAgICB3ID0gRnIubXVsKHcsIHZrLncpO1xuICAgIH1cblxuICAgIGRlbkFyciA9IGF3YWl0IEZyLmJhdGNoSW52ZXJzZShkZW5BcnIpO1xuXG4gICAgbGV0IEwgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBGci5uODtcbiAgICAgICAgTFtpICsgMV0gPSBGci5tdWwobnVtQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIEZyLm44KSwgZGVuQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIEZyLm44KSk7XG4gICAgfVxuICAgIHJldHVybiBMO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQSShjdXJ2ZSwgcHVibGljU2lnbmFscywgbGFncmFuZ2VFdmFscykge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgcGkgPSBGci56ZXJvO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVibGljU2lnbmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB3ID0gRnIuZShwdWJsaWNTaWduYWxzW2ldKTtcbiAgICAgICAgcGkgPSBGci5zdWIocGksIEZyLm11bCh3LCBsYWdyYW5nZUV2YWxzW2kgKyAxXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVSMChwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIGN1cnZlLCBsb2dnZXIpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3QgTGkgPSBjb21wdXRlTGFncmFuZ2VMaVNpKHJvb3RzLlMwLmgwdzgsIGNoYWxsZW5nZXMueSwgY2hhbGxlbmdlcy54aSwgY3VydmUpO1xuXG4gICAgLy8gcjAoeSkgPSDiiJFfMV44IENfMChoXzAgz4lfOF57aS0xfSkgTF9pKHkpLiBUbyB0aGlzIGVuZCB3ZSBuZWVkIHRvIGNvbXB1dGVcblxuICAgIC8vIENvbXB1dGUgdGhlIDggQzAgdmFsdWVzXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIHIwKHkpXCIpO1xuXG4gICAgbGV0IHJlcyA9IEZyLnplcm87XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgbGV0IGNvZWZWYWx1ZXMgPSBbXTtcbiAgICAgICAgY29lZlZhbHVlc1sxXSA9IHJvb3RzLlMwLmgwdzhbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAyOyBqIDwgODsgaisrKSB7XG4gICAgICAgICAgICBjb2VmVmFsdWVzW2pdID0gRnIubXVsKGNvZWZWYWx1ZXNbaiAtIDFdLCByb290cy5TMC5oMHc4W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjMCA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5xbCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFyLCBjb2VmVmFsdWVzWzFdKSk7XG4gICAgICAgIGMwID0gRnIuYWRkKGMwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucW8sIGNvZWZWYWx1ZXNbMl0pKTtcbiAgICAgICAgYzAgPSBGci5hZGQoYzAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xbSwgY29lZlZhbHVlc1szXSkpO1xuICAgICAgICBjMCA9IEZyLmFkZChjMCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFjLCBjb2VmVmFsdWVzWzRdKSk7XG4gICAgICAgIGMwID0gRnIuYWRkKGMwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMuczEsIGNvZWZWYWx1ZXNbNV0pKTtcbiAgICAgICAgYzAgPSBGci5hZGQoYzAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5zMiwgY29lZlZhbHVlc1s2XSkpO1xuICAgICAgICBjMCA9IEZyLmFkZChjMCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnMzLCBjb2VmVmFsdWVzWzddKSk7XG5cbiAgICAgICAgcmVzID0gRnIuYWRkKHJlcywgRnIubXVsKGMwLCBMaVtpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVSMShwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIHBpLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IExpID0gY29tcHV0ZUxhZ3JhbmdlTGlTaShyb290cy5TMS5oMXc0LCBjaGFsbGVuZ2VzLnksIGNoYWxsZW5nZXMueGksIGN1cnZlKTtcblxuICAgIC8vIHIxKHkpID0g4oiRXzFeNCBDXzEoaF8xIM+JXzRee2ktMX0pIExfaSh5KS4gVG8gdGhpcyBlbmQgd2UgbmVlZCB0byBjb21wdXRlXG4gICAgLy8gWjEgPSB7QzEoaF8xfSwgQzEoaF8xIM+JXzQpLCBDMShoXzEgz4lfNF4yKSwgQzEoaF8xIM+JXzReMyl9XG4gICAgLy8gd2hlcmUgQ18xKGhfMSDPiV80XntpLTF9KSA9IGV2YWwuYSArIGhfMSDPiV80XmkgZXZhbC5iICsgKGhfMSDPiV80XmkpXjIgZXZhbC5jICsgKGhfMSDPiV80XmkpXjMgVDAoeGkpLFxuICAgIC8vIHdoZXJlIFQwKHhpKSA9IFsgcUzCt2EgKyBxUsK3YiArIHFNwrdhwrdiICsgcU/Ct2MgKyBxQyArIFBJKHhpKSBdIC8gWl9IKHhpKVxuXG4gICAgLy8gQ29tcHV0ZSBUMCh4aSlcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDAoeGkpXCIpO1xuICAgIGxldCB0MCA9IEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xbCwgcHJvb2YuZXZhbHVhdGlvbnMuYSk7XG4gICAgdDAgPSBGci5hZGQodDAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xciwgcHJvb2YuZXZhbHVhdGlvbnMuYikpO1xuICAgIHQwID0gRnIuYWRkKHQwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucW0sIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5hLCBwcm9vZi5ldmFsdWF0aW9ucy5iKSkpO1xuICAgIHQwID0gRnIuYWRkKHQwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucW8sIHByb29mLmV2YWx1YXRpb25zLmMpKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgcHJvb2YuZXZhbHVhdGlvbnMucWMpO1xuICAgIHQwID0gRnIuYWRkKHQwLCBwaSk7XG4gICAgdDAgPSBGci5tdWwodDAsIGNoYWxsZW5nZXMuaW52emgpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgNCBDMSB2YWx1ZXNcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQzEoaF8xz4lfNF5pKSB2YWx1ZXNcIik7XG5cbiAgICBsZXQgcmVzID0gRnIuemVybztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBsZXQgYzEgPSBwcm9vZi5ldmFsdWF0aW9ucy5hO1xuICAgICAgICBjMSA9IEZyLmFkZChjMSwgRnIubXVsKHJvb3RzLlMxLmgxdzRbaV0sIHByb29mLmV2YWx1YXRpb25zLmIpKTtcbiAgICAgICAgY29uc3QgaDF3NFNxdWFyZWQgPSBGci5zcXVhcmUocm9vdHMuUzEuaDF3NFtpXSk7XG4gICAgICAgIGMxID0gRnIuYWRkKGMxLCBGci5tdWwoaDF3NFNxdWFyZWQsIHByb29mLmV2YWx1YXRpb25zLmMpKTtcbiAgICAgICAgYzEgPSBGci5hZGQoYzEsIEZyLm11bChGci5tdWwoaDF3NFNxdWFyZWQsIHJvb3RzLlMxLmgxdzRbaV0pLCB0MCkpO1xuXG4gICAgICAgIHJlcyA9IEZyLmFkZChyZXMsIEZyLm11bChjMSwgTGlbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlUjIocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBsYWdyYW5nZTEsIHZrLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IExpUzIgPSBjb21wdXRlTGFncmFuZ2VMaVMyKFtyb290cy5TMi5oMnczLCByb290cy5TMi5oM3czXSwgY2hhbGxlbmdlcy55LCBjaGFsbGVuZ2VzLnhpLCBjaGFsbGVuZ2VzLnhpdywgY3VydmUpO1xuXG4gICAgLy8gcjIoeSkgPSDiiJFfMV4zIENfMihoXzIgz4lfM157aS0xfSkgTF9pKHkpICsg4oiRXzFeMyBDXzIoaF8zIM+JXzNee2ktMX0pIExfe2krM30oeSkuIFRvIHRoaXMgZW5kIHdlIG5lZWQgdG8gY29tcHV0ZVxuICAgIC8vIFoyID0ge1tDMihoXzJ9LCBDMihoXzIgz4lfMyksIEMyKGhfMiDPiV8zXjIpXSwgW0MyKGhfM30sIEMyKGhfMyDPiV8zKSwgQzIoaF8zIM+JXzNeMildfVxuICAgIC8vIHdoZXJlIENfMihoXzIgz4lfM157aS0xfSkgPSBldmFsLnogKyBoXzIgz4lfMl5pIFQxKHhpKSArIChoXzIgz4lfM15pKV4yIFQyKHhpKSxcbiAgICAvLyB3aGVyZSBDXzIoaF8zIM+JXzNee2ktMX0pID0gZXZhbC56ICsgaF8zIM+JXzJeaSBUMSh4aSkgKyAoaF8zIM+JXzNeaSleMiBUMih4aSksXG4gICAgLy8gd2hlcmUgVDEoeGkpID0gWyBMXzEoeGkpKHotMSldIC8gWl9IKHhpKVxuICAgIC8vIGFuZCBUMih4aSkgPSBbICAoYSArIGJldGHCt3hpICsgZ2FtbWEpKGIgKyBiZXRhwrd4acK3azEgKyBnYW1tYSkoYyArIGJldGHCt3hpwrdrMiArIGdhbW1hKXpcbiAgICAvLyAgICAgICAgICAgICAgIC0gKGEgKyBiZXRhwrdzaWdtYTEgKyBnYW1tYSkoYiArIGJldGHCt3NpZ21hMiArIGdhbW1hKShjICsgYmV0YcK3c2lnbWEzICsgZ2FtbWEpes+JICBdIC8gWl9IKHhpKVxuXG4gICAgLy8gQ29tcHV0ZSBUMSh4aSlcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDEoeGkpXCIpO1xuICAgIGxldCB0MSA9IEZyLnN1Yihwcm9vZi5ldmFsdWF0aW9ucy56LCBGci5vbmUpO1xuICAgIHQxID0gRnIubXVsKHQxLCBsYWdyYW5nZTEpO1xuICAgIHQxID0gRnIubXVsKHQxLCBjaGFsbGVuZ2VzLmludnpoKTtcblxuICAgIC8vIENvbXB1dGUgVDIoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQyKHhpKVwiKTtcbiAgICBjb25zdCBiZXRheGkgPSBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBjaGFsbGVuZ2VzLnhpKTtcbiAgICBjb25zdCB0MjExID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmEsIEZyLmFkZChiZXRheGksIGNoYWxsZW5nZXMuZ2FtbWEpKTtcbiAgICBjb25zdCB0MjEyID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmIsIEZyLmFkZChGci5tdWwoYmV0YXhpLCB2ay5rMSksIGNoYWxsZW5nZXMuZ2FtbWEpKTtcbiAgICBjb25zdCB0MjEzID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmMsIEZyLmFkZChGci5tdWwoYmV0YXhpLCB2ay5rMiksIGNoYWxsZW5nZXMuZ2FtbWEpKTtcbiAgICBjb25zdCB0MjEgPSBGci5tdWwodDIxMSwgRnIubXVsKHQyMTIsIEZyLm11bCh0MjEzLCBwcm9vZi5ldmFsdWF0aW9ucy56KSkpO1xuXG4gICAgY29uc3QgdDIyMSA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5hLCBGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbHVhdGlvbnMuczEpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIyMiA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5iLCBGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbHVhdGlvbnMuczIpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIyMyA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5jLCBGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbHVhdGlvbnMuczMpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIyID0gRnIubXVsKHQyMjEsIEZyLm11bCh0MjIyLCBGci5tdWwodDIyMywgcHJvb2YuZXZhbHVhdGlvbnMuencpKSk7XG5cbiAgICBsZXQgdDIgPSBGci5zdWIodDIxLCB0MjIpO1xuICAgIHQyID0gRnIubXVsKHQyLCBjaGFsbGVuZ2VzLmludnpoKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIDYgQzIgdmFsdWVzXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMyKGhfMs+JXzNeaSkgdmFsdWVzXCIpO1xuICAgIGxldCByZXMgPSBGci56ZXJvO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGxldCBjMiA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy56LCBGci5tdWwocm9vdHMuUzIuaDJ3M1tpXSwgdDEpKTtcbiAgICAgICAgYzIgPSBGci5hZGQoYzIsIEZyLm11bChGci5zcXVhcmUocm9vdHMuUzIuaDJ3M1tpXSksIHQyKSk7XG5cbiAgICAgICAgcmVzID0gRnIuYWRkKHJlcywgRnIubXVsKGMyLCBMaVMyW2ldKSk7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMyKGhfM8+JXzNeaSkgdmFsdWVzXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGxldCBjMiA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy56dywgRnIubXVsKHJvb3RzLlMyLmgzdzNbaV0sIHByb29mLmV2YWx1YXRpb25zLnQxdykpO1xuICAgICAgICBjMiA9IEZyLmFkZChjMiwgRnIubXVsKEZyLnNxdWFyZShyb290cy5TMi5oM3czW2ldKSwgcHJvb2YuZXZhbHVhdGlvbnMudDJ3KSk7XG5cbiAgICAgICAgcmVzID0gRnIuYWRkKHJlcywgRnIubXVsKGMyLCBMaVMyW2kgKyAzXSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVGKGN1cnZlLCBwcm9vZiwgdmssIGNoYWxsZW5nZXMsIHJvb3RzKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IG11bEgwID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzAuaDB3OFswXSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgbXVsSDAgPSBGci5tdWwobXVsSDAsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMwLmgwdzhbaV0pKTtcbiAgICB9XG5cbiAgICBjaGFsbGVuZ2VzLnRlbXAgPSBtdWxIMDtcblxuICAgIGxldCBtdWxIMSA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMxLmgxdzRbMF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIG11bEgxID0gRnIubXVsKG11bEgxLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMS5oMXc0W2ldKSk7XG4gICAgfVxuXG4gICAgbGV0IG11bEgyID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDJ3M1swXSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgbXVsSDIgPSBGci5tdWwobXVsSDIsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgydzNbaV0pKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgbXVsSDIgPSBGci5tdWwobXVsSDIsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgzdzNbaV0pKTtcbiAgICB9XG5cbiAgICBjaGFsbGVuZ2VzLnF1b3RpZW50MSA9IEZyLm11bChjaGFsbGVuZ2VzLmFscGhhLCBGci5kaXYobXVsSDAsIG11bEgxKSk7XG4gICAgY2hhbGxlbmdlcy5xdW90aWVudDIgPSBGci5tdWwoRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpLCBGci5kaXYobXVsSDAsIG11bEgyKSk7XG5cbiAgICBsZXQgRjIgPSBHMS50aW1lc0ZyKHByb29mLnBvbHlub21pYWxzLkMxLCBjaGFsbGVuZ2VzLnF1b3RpZW50MSk7XG4gICAgbGV0IEYzID0gRzEudGltZXNGcihwcm9vZi5wb2x5bm9taWFscy5DMiwgY2hhbGxlbmdlcy5xdW90aWVudDIpO1xuXG4gICAgcmV0dXJuIEcxLmFkZCh2ay5DMCwgRzEuYWRkKEYyLCBGMykpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrLCByMCwgcjEsIHIyKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IEUyID0gRnIubXVsKHIxLCBjaGFsbGVuZ2VzLnF1b3RpZW50MSk7XG4gICAgbGV0IEUzID0gRnIubXVsKHIyLCBjaGFsbGVuZ2VzLnF1b3RpZW50Mik7XG5cbiAgICByZXR1cm4gRzEudGltZXNGcihHMS5vbmUsIEZyLmFkZChyMCwgRnIuYWRkKEUyLCBFMykpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUooY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcblxuICAgIHJldHVybiBHMS50aW1lc0ZyKHByb29mLnBvbHlub21pYWxzLlcxLCBjaGFsbGVuZ2VzLnRlbXApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpc1ZhbGlkUGFpcmluZyhjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrLCBGLCBFLCBKKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcblxuICAgIGxldCBBMSA9IEcxLnRpbWVzRnIocHJvb2YucG9seW5vbWlhbHMuVzIsIGNoYWxsZW5nZXMueSk7XG4gICAgQTEgPSBHMS5hZGQoRzEuc3ViKEcxLnN1YihGLCBFKSwgSiksIEExKTtcbiAgICBjb25zdCBBMiA9IGN1cnZlLkcyLm9uZTtcblxuICAgIGNvbnN0IEIxID0gcHJvb2YucG9seW5vbWlhbHMuVzI7XG4gICAgY29uc3QgQjIgPSB2ay5YXzI7XG5cbiAgICByZXR1cm4gYXdhaXQgY3VydmUucGFpcmluZ0VxKEcxLm5lZyhBMSksIEEyLCBCMSwgQjIpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlTGFncmFuZ2VMaVNpKHJvb3RzLCB4LCB4aSwgY3VydmUpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IGxlbiA9IHJvb3RzLmxlbmd0aDtcblxuICAgIGNvbnN0IG51bSA9IEZyLnN1YihGci5leHAoeCwgbGVuKSwgeGkpO1xuICAgIGNvbnN0IGRlbjEgPSBGci5tdWwoRnIuZShsZW4pLCBGci5leHAocm9vdHNbMF0sIGxlbiAtIDIpKTtcblxuICAgIGNvbnN0IExpID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBkZW4yID0gcm9vdHNbKChsZW4gLSAxKSAqIGkpICUgbGVuXTtcbiAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih4LCByb290c1tpXSk7XG5cbiAgICAgICAgTGlbaV0gPSBGci5kaXYobnVtLCBGci5tdWwoRnIubXVsKGRlbjEsIGRlbjIpLCBkZW4zKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIExpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUxhZ3JhbmdlTGlTMihyb290cywgdmFsdWUsIHhpMCwgeGkxLCBjdXJ2ZSkge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBMaSA9IFtdO1xuXG4gICAgY29uc3QgbGVuID0gcm9vdHNbMF0ubGVuZ3RoO1xuICAgIGNvbnN0IG4gPSBsZW4gKiByb290cy5sZW5ndGg7XG5cbiAgICBjb25zdCBudW0xID0gRnIuZXhwKHZhbHVlLCBuKTtcbiAgICBjb25zdCBudW0yID0gRnIubXVsKEZyLmFkZCh4aTAsIHhpMSksIEZyLmV4cCh2YWx1ZSwgbGVuKSk7XG4gICAgY29uc3QgbnVtMyA9IEZyLm11bCh4aTAsIHhpMSk7XG4gICAgY29uc3QgbnVtID0gRnIuYWRkKEZyLnN1YihudW0xLCBudW0yKSwgbnVtMyk7XG5cbiAgICBsZXQgZGVuMSA9IEZyLm11bChGci5tdWwoRnIuZShsZW4pLCByb290c1swXVswXSksIEZyLnN1Yih4aTAsIHhpMSkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWzBdWyhsZW4gLSAxKSAqIGkgJSBsZW5dO1xuICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHZhbHVlLCByb290c1swXVtpXSk7XG5cbiAgICAgICAgY29uc3QgZGVuID0gRnIubXVsKGRlbjEsRnIubXVsKGRlbjIsIGRlbjMpKTtcblxuICAgICAgICBMaVtpXSA9IEZyLmRpdihudW0sIGRlbik7XG4gICAgfVxuXG4gICAgZGVuMSA9IEZyLm11bChGci5tdWwoRnIuZShsZW4pLCByb290c1sxXVswXSksIEZyLnN1Yih4aTEsIHhpMCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWzFdWyhsZW4gLSAxKSAqIGkgJSBsZW5dO1xuICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHZhbHVlLCByb290c1sxXVtpXSk7XG5cbiAgICAgICAgY29uc3QgZGVuID0gRnIubXVsKGRlbjEsRnIubXVsKGRlbjIsIGRlbjMpKTtcblxuICAgICAgICBMaVtpICsgbGVuXSA9IEZyLmRpdihudW0sIGRlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIExpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/fflonk_verify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/groth16.js":
/*!*********************************************!*\
  !*** ./node_modules/snarkjs/src/groth16.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _groth16_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _groth16_fullprove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _groth16_prove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _groth16_verify_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _groth16_fullprove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./groth16_fullprove.js */ \"(ssr)/./node_modules/snarkjs/src/groth16_fullprove.js\");\n/* harmony import */ var _groth16_prove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./groth16_prove.js */ \"(ssr)/./node_modules/snarkjs/src/groth16_prove.js\");\n/* harmony import */ var _groth16_verify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./groth16_verify.js */ \"(ssr)/./node_modules/snarkjs/src/groth16_verify.js\");\n/* harmony import */ var _groth16_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./groth16_exportsoliditycalldata.js */ \"(ssr)/./node_modules/snarkjs/src/groth16_exportsoliditycalldata.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRTREO0FBQ1I7QUFDRTtBQUNnQyIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9ncm90aDE2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBmdWxsUHJvdmV9IGZyb20gXCIuL2dyb3RoMTZfZnVsbHByb3ZlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcHJvdmV9IGZyb20gXCIuL2dyb3RoMTZfcHJvdmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB2ZXJpZnl9IGZyb20gXCIuL2dyb3RoMTZfdmVyaWZ5LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0U29saWRpdHlDYWxsRGF0YX0gZnJvbSBcIi4vZ3JvdGgxNl9leHBvcnRzb2xpZGl0eWNhbGxkYXRhLmpzXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/groth16.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/groth16_exportsoliditycalldata.js":
/*!********************************************************************!*\
  !*** ./node_modules/snarkjs/src/groth16_exportsoliditycalldata.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16ExportSolidityCallData)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function groth16ExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    let S;\n    S=`[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` +\n        `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` +\n        `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9leHBvcnRzb2xpZGl0eWNhbGxkYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUN3QztBQUN4QyxRQUFRLG9CQUFvQixFQUFFLCtDQUFLOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBOztBQUVlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsb0JBQW9CLElBQUksb0JBQW9CO0FBQ3RELGFBQWEsdUJBQXVCLElBQUksdUJBQXVCLEtBQUssdUJBQXVCLElBQUksdUJBQXVCO0FBQ3RILFlBQVksb0JBQW9CLElBQUksb0JBQW9CO0FBQ3hELFlBQVksT0FBTzs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9ncm90aDE2X2V4cG9ydHNvbGlkaXR5Y2FsbGRhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3QgeyB1bnN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmZ1bmN0aW9uIHAyNTYobikge1xuICAgIGxldCBuc3RyID0gbi50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKG5zdHIubGVuZ3RoIDwgNjQpIG5zdHIgPSBcIjBcIituc3RyO1xuICAgIG5zdHIgPSBgXCIweCR7bnN0cn1cImA7XG4gICAgcmV0dXJuIG5zdHI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGdyb3RoMTZFeHBvcnRTb2xpZGl0eUNhbGxEYXRhKF9wcm9vZiwgX3B1Yikge1xuICAgIGNvbnN0IHByb29mID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wcm9vZik7XG4gICAgY29uc3QgcHViID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wdWIpO1xuXG4gICAgbGV0IGlucHV0cyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaT0wOyBpPHB1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRzICE9IFwiXCIpIGlucHV0cyA9IGlucHV0cyArIFwiLFwiO1xuICAgICAgICBpbnB1dHMgPSBpbnB1dHMgKyBwMjU2KHB1YltpXSk7XG4gICAgfVxuXG4gICAgbGV0IFM7XG4gICAgUz1gWyR7cDI1Nihwcm9vZi5waV9hWzBdKX0sICR7cDI1Nihwcm9vZi5waV9hWzFdKX1dLGAgK1xuICAgICAgICBgW1ske3AyNTYocHJvb2YucGlfYlswXVsxXSl9LCAke3AyNTYocHJvb2YucGlfYlswXVswXSl9XSxbJHtwMjU2KHByb29mLnBpX2JbMV1bMV0pfSwgJHtwMjU2KHByb29mLnBpX2JbMV1bMF0pfV1dLGAgK1xuICAgICAgICBgWyR7cDI1Nihwcm9vZi5waV9jWzBdKX0sICR7cDI1Nihwcm9vZi5waV9jWzFdKX1dLGAgK1xuICAgICAgICBgWyR7aW5wdXRzfV1gO1xuXG4gICAgcmV0dXJuIFM7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/groth16_exportsoliditycalldata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/groth16_fullprove.js":
/*!*******************************************************!*\
  !*** ./node_modules/snarkjs/src/groth16_fullprove.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16FullProve)\n/* harmony export */ });\n/* harmony import */ var _groth16_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./groth16_prove.js */ \"(ssr)/./node_modules/snarkjs/src/groth16_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function groth16FullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFile, wtns, wtnsCalcOptions);\n    return await (0,_groth16_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFileName, wtns, logger, proverOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9mdWxscHJvdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRStDO0FBQ0U7QUFDZDtBQUNuQyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOztBQUVuQjtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOERBQWM7QUFDeEIsaUJBQWlCLDZEQUFhO0FBQzlCIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2dyb3RoMTZfZnVsbHByb3ZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBncm90aDE2X3Byb3ZlIGZyb20gXCIuL2dyb3RoMTZfcHJvdmUuanNcIjtcbmltcG9ydCB3dG5zX2NhbGN1bGF0ZSBmcm9tIFwiLi93dG5zX2NhbGN1bGF0ZS5qc1wiO1xuaW1wb3J0IHt1dGlsc30gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ3JvdGgxNkZ1bGxQcm92ZShfaW5wdXQsIHdhc21GaWxlLCB6a2V5RmlsZU5hbWUsIGxvZ2dlciwgd3Ruc0NhbGNPcHRpb25zLCBwcm92ZXJPcHRpb25zKSB7XG4gICAgY29uc3QgaW5wdXQgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX2lucHV0KTtcblxuICAgIGNvbnN0IHd0bnM9IHtcbiAgICAgICAgdHlwZTogXCJtZW1cIlxuICAgIH07XG4gICAgYXdhaXQgd3Ruc19jYWxjdWxhdGUoaW5wdXQsIHdhc21GaWxlLCB3dG5zLCB3dG5zQ2FsY09wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCBncm90aDE2X3Byb3ZlKHprZXlGaWxlTmFtZSwgd3RucywgbG9nZ2VyLCBwcm92ZXJPcHRpb25zKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/groth16_fullprove.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/groth16_prove.js":
/*!***************************************************!*\
  !*** ./node_modules/snarkjs/src/groth16_prove.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16Prove)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_5__.utils;\n\nasync function groth16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, sectionsWtns);\n\n    const {fd: fdZKey, sections: sectionsZKey} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, sectionsZKey, undefined, options);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);\n    }\n\n    const curve = zkey.curve;\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    const power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_4__.log2)(zkey.domainSize);\n\n    if (logger) logger.debug(\"Reading Wtns\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, sectionsWtns, 2);\n    if (logger) logger.debug(\"Reading Coeffs\");\n    const buffCoeffs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 4);\n\n    if (logger) logger.debug(\"Building ABC\");\n    const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve, zkey, buffWitness, buffCoeffs, logger);\n\n    const inc = power == Fr.s ? curve.Fr.shift : curve.Fr.w[power+1];\n\n    const buffA = await Fr.ifft(buffA_T, \"\", \"\", logger, \"IFFT_A\");\n    const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);\n    const buffAodd_T = await Fr.fft(buffAodd, \"\", \"\", logger, \"FFT_A\");\n\n    const buffB = await Fr.ifft(buffB_T, \"\", \"\", logger, \"IFFT_B\");\n    const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);\n    const buffBodd_T = await Fr.fft(buffBodd, \"\", \"\", logger, \"FFT_B\");\n\n    const buffC = await Fr.ifft(buffC_T, \"\", \"\", logger, \"IFFT_C\");\n    const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);\n    const buffCodd_T = await Fr.fft(buffCodd, \"\", \"\", logger, \"FFT_C\");\n\n    if (logger) logger.debug(\"Join ABC\");\n    const buffPodd_T = await joinABC(curve, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);\n\n    let proof = {};\n\n    if (logger) logger.debug(\"Reading A Points\");\n    const buffBasesA = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 5);\n    proof.pi_a = await curve.G1.multiExpAffine(buffBasesA, buffWitness, logger, \"multiexp A\");\n\n    if (logger) logger.debug(\"Reading B1 Points\");\n    const buffBasesB1 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 6);\n    let pib1 = await curve.G1.multiExpAffine(buffBasesB1, buffWitness, logger, \"multiexp B1\");\n\n    if (logger) logger.debug(\"Reading B2 Points\");\n    const buffBasesB2 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 7);\n    proof.pi_b = await curve.G2.multiExpAffine(buffBasesB2, buffWitness, logger, \"multiexp B2\");\n\n    if (logger) logger.debug(\"Reading C Points\");\n    const buffBasesC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 8);\n    proof.pi_c = await curve.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic+1)*curve.Fr.n8), logger, \"multiexp C\");\n\n    if (logger) logger.debug(\"Reading H Points\");\n    const buffBasesH = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 9);\n    const resH = await curve.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, \"multiexp H\");\n\n    const r = curve.Fr.random();\n    const s = curve.Fr.random();\n\n    proof.pi_a  = G1.add( proof.pi_a, zkey.vk_alpha_1 );\n    proof.pi_a  = G1.add( proof.pi_a, G1.timesFr( zkey.vk_delta_1, r ));\n\n    proof.pi_b  = G2.add( proof.pi_b, zkey.vk_beta_2 );\n    proof.pi_b  = G2.add( proof.pi_b, G2.timesFr( zkey.vk_delta_2, s ));\n\n    pib1 = G1.add( pib1, zkey.vk_beta_1 );\n    pib1 = G1.add( pib1, G1.timesFr( zkey.vk_delta_1, s ));\n\n    proof.pi_c = G1.add(proof.pi_c, resH);\n\n\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( proof.pi_a, s ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( pib1, r ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( zkey.vk_delta_1, Fr.neg(Fr.mul(r,s) )));\n\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const b = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.fromRprLE(b));\n    }\n\n    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));\n    proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));\n    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));\n\n    proof.protocol = \"groth16\";\n    proof.curve = curve.name;\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    proof = stringifyBigInts(proof);\n    publicSignals = stringifyBigInts(publicSignals);\n\n    return {proof, publicSignals};\n}\n\n\nasync function buildABC1(curve, zkey, witness, coeffs, logger) {\n    const n8 = curve.Fr.n8;\n    const sCoef = 4*3 + zkey.n8r;\n    const nCoef = (coeffs.byteLength-4) / sCoef;\n\n    const outBuffA = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n    const outBuffB = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n    const outBuffC = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n\n    const outBuf = [ outBuffA, outBuffB ];\n    for (let i=0; i<nCoef; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP AB: ${i}/${nCoef}`);\n        const buffCoef = coeffs.slice(4+i*sCoef, 4+i*sCoef+sCoef);\n        const buffCoefV = new DataView(buffCoef.buffer);\n        const m= buffCoefV.getUint32(0, true);\n        const c= buffCoefV.getUint32(4, true);\n        const s= buffCoefV.getUint32(8, true);\n        const coef = buffCoef.slice(12, 12+n8);\n        outBuf[m].set(\n            curve.Fr.add(\n                outBuf[m].slice(c*n8, c*n8+n8),\n                curve.Fr.mul(coef, witness.slice(s*n8, s*n8+n8))\n            ),\n            c*n8\n        );\n    }\n\n    for (let i=0; i<zkey.domainSize; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP C: ${i}/${zkey.domainSize}`);\n        outBuffC.set(\n            curve.Fr.mul(\n                outBuffA.slice(i*n8, i*n8+n8),\n                outBuffB.slice(i*n8, i*n8+n8),\n            ),\n            i*n8\n        );\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n}\n\n/*\nasync function buildABC(curve, zkey, witness, coeffs, logger) {\n    const concurrency = curve.tm.concurrency;\n    const sCoef = 4*3 + zkey.n8r;\n\n    let getUint32;\n\n    if (coeffs instanceof BigBuffer) {\n        const coeffsDV = [];\n        const PAGE_LEN = coeffs.buffers[0].length;\n        for (let i=0; i< coeffs.buffers.length; i++) {\n            coeffsDV.push(new DataView(coeffs.buffers[i].buffer));\n        }\n        getUint32 = function (pos) {\n            return coeffsDV[Math.floor(pos/PAGE_LEN)].getUint32(pos % PAGE_LEN, true);\n        };\n    } else {\n        const coeffsDV = new DataView(coeffs.buffer, coeffs.byteOffset, coeffs.byteLength);\n        getUint32 = function (pos) {\n            return coeffsDV.getUint32(pos, true);\n        };\n    }\n\n    const elementsPerChunk = Math.floor(zkey.domainSize/concurrency);\n    const promises = [];\n\n    const cutPoints = [];\n    for (let i=0; i<concurrency; i++) {\n        cutPoints.push( getCutPoint( Math.floor(i*elementsPerChunk) ));\n    }\n    cutPoints.push(coeffs.byteLength);\n\n    const chunkSize = 2**26;\n    for (let s=0 ; s<zkey.nVars ; s+= chunkSize) {\n        if (logger) logger.debug(`QAP ${s}: ${s}/${zkey.nVars}`);\n        const ns= Math.min(zkey.nVars-s, chunkSize );\n\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = elementsPerChunk;\n            } else {\n                n = zkey.domainSize - i*elementsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: coeffs.slice(cutPoints[i], cutPoints[i+1])});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: witness.slice(s*curve.Fr.n8, (s+ns)*curve.Fr.n8)});\n            task.push({cmd: \"ALLOC\", var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 4, len: n*curve.Fr.n8});\n            task.push({cmd: \"CALL\", fnName: \"qap_buildABC\", params:[\n                {var: 0},\n                {val: (cutPoints[i+1] - cutPoints[i])/sCoef},\n                {var: 1},\n                {var: 2},\n                {var: 3},\n                {var: 4},\n                {val: i*elementsPerChunk},\n                {val: n},\n                {val: s},\n                {val: ns}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 1, var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 2, var: 4, len: n*curve.Fr.n8});\n            promises.push(curve.tm.queueAction(task));\n        }\n    }\n\n    let result = await Promise.all(promises);\n\n    const nGroups = result.length / concurrency;\n    if (nGroups>1) {\n        const promises2 = [];\n        for (let i=0; i<concurrency; i++) {\n            const task=[];\n            task.push({cmd: \"ALLOC\", var: 0, len: result[i][0].byteLength});\n            task.push({cmd: \"ALLOC\", var: 1, len: result[i][0].byteLength});\n            for (let m=0; m<3; m++) {\n                task.push({cmd: \"SET\", var: 0, buff: result[i][m]});\n                for (let s=1; s<nGroups; s++) {\n                    task.push({cmd: \"SET\", var: 1, buff: result[s*concurrency + i][m]});\n                    task.push({cmd: \"CALL\", fnName: \"qap_batchAdd\", params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: result[i][m].length/curve.Fr.n8},\n                        {var: 0}\n                    ]});\n                }\n                task.push({cmd: \"GET\", out: m, var: 0, len: result[i][m].length});\n            }\n            promises2.push(curve.tm.queueAction(task));\n        }\n        result = await Promise.all(promises2);\n    }\n\n    const outBuffA = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuffA.set(result[i][0], p);\n        outBuffB.set(result[i][1], p);\n        outBuffC.set(result[i][2], p);\n        p += result[i][0].byteLength;\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n    function getCutPoint(v) {\n        let m = 0;\n        let n = getUint32(0);\n        while (m < n) {\n            var k = Math.floor((n + m) / 2);\n            const va = getUint32(4 + k*sCoef + 4);\n            if (va > v) {\n                n = k - 1;\n            } else if (va < v) {\n                m = k + 1;\n            } else {\n                n = k;\n            }\n        }\n        return 4 + m*sCoef;\n    }\n}\n*/\n\nasync function joinABC(curve, zkey, a, b, c, logger) {\n    const MAX_CHUNK_SIZE = 1 << 22;\n\n    const n8 = curve.Fr.n8;\n    const nElements = Math.floor(a.byteLength / curve.Fr.n8);\n\n    const promises = [];\n\n    for (let i=0; i<nElements; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`JoinABC: ${i}/${nElements}`);\n        const n= Math.min(nElements - i, MAX_CHUNK_SIZE);\n\n        const task = [];\n\n        const aChunk = a.slice(i*n8, (i + n)*n8 );\n        const bChunk = b.slice(i*n8, (i + n)*n8 );\n        const cChunk = c.slice(i*n8, (i + n)*n8 );\n\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: aChunk});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: bChunk});\n        task.push({cmd: \"ALLOCSET\", var: 2, buff: cChunk});\n        task.push({cmd: \"ALLOC\", var: 3, len: n*n8});\n        task.push({cmd: \"CALL\", fnName: \"qap_joinABC\", params:[\n            {var: 0},\n            {var: 1},\n            {var: 2},\n            {val: n},\n            {var: 3},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"frm_batchFromMontgomery\", params:[\n            {var: 3},\n            {val: n},\n            {var: 3}\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 3, len: n*n8});\n        promises.push(curve.tm.queueAction(task));\n    }\n\n    const result = await Promise.all(promises);\n\n    let outBuff;\n    if (a instanceof ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer) {\n        outBuff = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(a.byteLength);\n    } else {\n        outBuff = new Uint8Array(a.byteLength);\n    }\n\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuff.set(result[i][0], p);\n        p += result[i][0].byteLength;\n    }\n\n    return outBuff;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9wcm92ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDUDtBQUNBO0FBQ1c7QUFDdkI7QUFDdUI7QUFDeEQsT0FBTyxrQkFBa0IsRUFBRSwrQ0FBSzs7QUFFakI7QUFDZixXQUFXLG9DQUFvQyxRQUFRLDREQUF3Qjs7QUFFL0UsdUJBQXVCLHNEQUFvQjs7QUFFM0MsV0FBVyxvQ0FBb0MsUUFBUSw0REFBd0I7O0FBRS9FLHVCQUF1QixzREFBb0I7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGdEQUFNO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxXQUFXLGFBQWEsY0FBYztBQUNsRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsOENBQUk7O0FBRXRCO0FBQ0EsOEJBQThCLDREQUF3QjtBQUN0RDtBQUNBLDZCQUE2Qiw0REFBd0I7O0FBRXJEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2Qiw0REFBd0I7QUFDckQ7O0FBRUE7QUFDQSw4QkFBOEIsNERBQXdCO0FBQ3REOztBQUVBO0FBQ0EsOEJBQThCLDREQUF3QjtBQUN0RDs7QUFFQTtBQUNBLDZCQUE2Qiw0REFBd0I7QUFDckQ7O0FBRUE7QUFDQSw2QkFBNkIsNERBQXdCO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLDJCQUEyQixnREFBTTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsbURBQVM7QUFDbEMseUJBQXlCLG1EQUFTO0FBQ2xDLHlCQUF5QixtREFBUzs7QUFFbEM7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixnRUFBZ0UsRUFBRSxHQUFHLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDLCtEQUErRCxFQUFFLEdBQUcsZ0JBQWdCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLHdDQUF3QyxFQUFFLElBQUksRUFBRSxHQUFHLFdBQVc7QUFDOUQ7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsMEVBQTBFO0FBQ2pHLHVCQUF1QixnRkFBZ0Y7QUFDdkcsdUJBQXVCLHlDQUF5QztBQUNoRSx1QkFBdUIseUNBQXlDO0FBQ2hFLHVCQUF1Qix5Q0FBeUM7QUFDaEUsdUJBQXVCO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQiwyQ0FBMkM7QUFDNUQsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLHdCQUF3QjtBQUN6QyxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUI7QUFDakIsY0FBYztBQUNkLHVCQUF1QiwrQ0FBK0M7QUFDdEUsdUJBQXVCLCtDQUErQztBQUN0RSx1QkFBdUIsK0NBQStDO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBLHVCQUF1QixtREFBbUQ7QUFDMUUsdUJBQXVCLG1EQUFtRDtBQUMxRSwwQkFBMEIsS0FBSztBQUMvQiwyQkFBMkIsdUNBQXVDO0FBQ2xFLDhCQUE4QixXQUFXO0FBQ3pDLCtCQUErQix1REFBdUQ7QUFDdEYsK0JBQStCO0FBQy9CLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixxQ0FBcUM7QUFDOUQseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBLDJCQUEyQixxREFBcUQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQiw2Q0FBNkMsRUFBRSxHQUFHLFVBQVU7QUFDNUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQ0FBc0M7QUFDekQsbUJBQW1CLHNDQUFzQztBQUN6RCxtQkFBbUIsc0NBQXNDO0FBQ3pELG1CQUFtQixnQ0FBZ0M7QUFDbkQsbUJBQW1CO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsVUFBVTtBQUNWLG1CQUFtQjtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWE7QUFDYixVQUFVO0FBQ1YsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLG1EQUFTO0FBQzlCLHNCQUFzQixtREFBUztBQUMvQixNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9wcm92ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHprZXlVdGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyB3dG5zVXRpbHMgZnJvbSBcIi4vd3Ruc191dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSBhcyBnZXRDdXJ2ZSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHsgbG9nMiB9IGZyb20gXCIuL21pc2MuanNcIjtcbmltcG9ydCB7IFNjYWxhciwgdXRpbHMsIEJpZ0J1ZmZlciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHtzdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBncm90aDE2UHJvdmUoemtleUZpbGVOYW1lLCB3aXRuZXNzRmlsZU5hbWUsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtmZDogZmRXdG5zLCBzZWN0aW9uczogc2VjdGlvbnNXdG5zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh3aXRuZXNzRmlsZU5hbWUsIFwid3Ruc1wiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgY29uc3Qgd3RucyA9IGF3YWl0IHd0bnNVdGlscy5yZWFkSGVhZGVyKGZkV3Rucywgc2VjdGlvbnNXdG5zKTtcblxuICAgIGNvbnN0IHtmZDogZmRaS2V5LCBzZWN0aW9uczogc2VjdGlvbnNaS2V5fSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkWktleSwgc2VjdGlvbnNaS2V5LCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHprZXkucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGlmICghU2NhbGFyLmVxKHprZXkuciwgIHd0bnMucSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VydmUgb2YgdGhlIHdpdG5lc3MgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnZlIG9mIHRoZSBwcm92aW5nIGtleVwiKTtcbiAgICB9XG5cbiAgICBpZiAod3Rucy5uV2l0bmVzcyAhPSB6a2V5Lm5WYXJzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3aXRuZXNzIGxlbmd0aC4gQ2lyY3VpdDogJHt6a2V5Lm5WYXJzfSwgd2l0bmVzczogJHt3dG5zLm5XaXRuZXNzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gemtleS5jdXJ2ZTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRzIgPSBjdXJ2ZS5HMjtcblxuICAgIGNvbnN0IHBvd2VyID0gbG9nMih6a2V5LmRvbWFpblNpemUpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiUmVhZGluZyBXdG5zXCIpO1xuICAgIGNvbnN0IGJ1ZmZXaXRuZXNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkV3Rucywgc2VjdGlvbnNXdG5zLCAyKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIENvZWZmc1wiKTtcbiAgICBjb25zdCBidWZmQ29lZmZzID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA0KTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkJ1aWxkaW5nIEFCQ1wiKTtcbiAgICBjb25zdCBbYnVmZkFfVCwgYnVmZkJfVCwgYnVmZkNfVF0gPSBhd2FpdCBidWlsZEFCQzEoY3VydmUsIHprZXksIGJ1ZmZXaXRuZXNzLCBidWZmQ29lZmZzLCBsb2dnZXIpO1xuXG4gICAgY29uc3QgaW5jID0gcG93ZXIgPT0gRnIucyA/IGN1cnZlLkZyLnNoaWZ0IDogY3VydmUuRnIud1twb3dlcisxXTtcblxuICAgIGNvbnN0IGJ1ZmZBID0gYXdhaXQgRnIuaWZmdChidWZmQV9ULCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiSUZGVF9BXCIpO1xuICAgIGNvbnN0IGJ1ZmZBb2RkID0gYXdhaXQgRnIuYmF0Y2hBcHBseUtleShidWZmQSwgRnIuZSgxKSwgaW5jKTtcbiAgICBjb25zdCBidWZmQW9kZF9UID0gYXdhaXQgRnIuZmZ0KGJ1ZmZBb2RkLCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiRkZUX0FcIik7XG5cbiAgICBjb25zdCBidWZmQiA9IGF3YWl0IEZyLmlmZnQoYnVmZkJfVCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIklGRlRfQlwiKTtcbiAgICBjb25zdCBidWZmQm9kZCA9IGF3YWl0IEZyLmJhdGNoQXBwbHlLZXkoYnVmZkIsIEZyLmUoMSksIGluYyk7XG4gICAgY29uc3QgYnVmZkJvZGRfVCA9IGF3YWl0IEZyLmZmdChidWZmQm9kZCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIkZGVF9CXCIpO1xuXG4gICAgY29uc3QgYnVmZkMgPSBhd2FpdCBGci5pZmZ0KGJ1ZmZDX1QsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJJRkZUX0NcIik7XG4gICAgY29uc3QgYnVmZkNvZGQgPSBhd2FpdCBGci5iYXRjaEFwcGx5S2V5KGJ1ZmZDLCBGci5lKDEpLCBpbmMpO1xuICAgIGNvbnN0IGJ1ZmZDb2RkX1QgPSBhd2FpdCBGci5mZnQoYnVmZkNvZGQsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJGRlRfQ1wiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkpvaW4gQUJDXCIpO1xuICAgIGNvbnN0IGJ1ZmZQb2RkX1QgPSBhd2FpdCBqb2luQUJDKGN1cnZlLCB6a2V5LCBidWZmQW9kZF9ULCBidWZmQm9kZF9ULCBidWZmQ29kZF9ULCBsb2dnZXIpO1xuXG4gICAgbGV0IHByb29mID0ge307XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEEgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0EgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDUpO1xuICAgIHByb29mLnBpX2EgPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShidWZmQmFzZXNBLCBidWZmV2l0bmVzcywgbG9nZ2VyLCBcIm11bHRpZXhwIEFcIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEIxIFBvaW50c1wiKTtcbiAgICBjb25zdCBidWZmQmFzZXNCMSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNik7XG4gICAgbGV0IHBpYjEgPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShidWZmQmFzZXNCMSwgYnVmZldpdG5lc3MsIGxvZ2dlciwgXCJtdWx0aWV4cCBCMVwiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQjIgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0IyID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA3KTtcbiAgICBwcm9vZi5waV9iID0gYXdhaXQgY3VydmUuRzIubXVsdGlFeHBBZmZpbmUoYnVmZkJhc2VzQjIsIGJ1ZmZXaXRuZXNzLCBsb2dnZXIsIFwibXVsdGlleHAgQjJcIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEMgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDgpO1xuICAgIHByb29mLnBpX2MgPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShidWZmQmFzZXNDLCBidWZmV2l0bmVzcy5zbGljZSgoemtleS5uUHVibGljKzEpKmN1cnZlLkZyLm44KSwgbG9nZ2VyLCBcIm11bHRpZXhwIENcIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEggUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0ggPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDkpO1xuICAgIGNvbnN0IHJlc0ggPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShidWZmQmFzZXNILCBidWZmUG9kZF9ULCBsb2dnZXIsIFwibXVsdGlleHAgSFwiKTtcblxuICAgIGNvbnN0IHIgPSBjdXJ2ZS5Gci5yYW5kb20oKTtcbiAgICBjb25zdCBzID0gY3VydmUuRnIucmFuZG9tKCk7XG5cbiAgICBwcm9vZi5waV9hICA9IEcxLmFkZCggcHJvb2YucGlfYSwgemtleS52a19hbHBoYV8xICk7XG4gICAgcHJvb2YucGlfYSAgPSBHMS5hZGQoIHByb29mLnBpX2EsIEcxLnRpbWVzRnIoIHprZXkudmtfZGVsdGFfMSwgciApKTtcblxuICAgIHByb29mLnBpX2IgID0gRzIuYWRkKCBwcm9vZi5waV9iLCB6a2V5LnZrX2JldGFfMiApO1xuICAgIHByb29mLnBpX2IgID0gRzIuYWRkKCBwcm9vZi5waV9iLCBHMi50aW1lc0ZyKCB6a2V5LnZrX2RlbHRhXzIsIHMgKSk7XG5cbiAgICBwaWIxID0gRzEuYWRkKCBwaWIxLCB6a2V5LnZrX2JldGFfMSApO1xuICAgIHBpYjEgPSBHMS5hZGQoIHBpYjEsIEcxLnRpbWVzRnIoIHprZXkudmtfZGVsdGFfMSwgcyApKTtcblxuICAgIHByb29mLnBpX2MgPSBHMS5hZGQocHJvb2YucGlfYywgcmVzSCk7XG5cblxuICAgIHByb29mLnBpX2MgID0gRzEuYWRkKCBwcm9vZi5waV9jLCBHMS50aW1lc0ZyKCBwcm9vZi5waV9hLCBzICkpO1xuICAgIHByb29mLnBpX2MgID0gRzEuYWRkKCBwcm9vZi5waV9jLCBHMS50aW1lc0ZyKCBwaWIxLCByICkpO1xuICAgIHByb29mLnBpX2MgID0gRzEuYWRkKCBwcm9vZi5waV9jLCBHMS50aW1lc0ZyKCB6a2V5LnZrX2RlbHRhXzEsIEZyLm5lZyhGci5tdWwocixzKSApKSk7XG5cblxuICAgIGxldCBwdWJsaWNTaWduYWxzID0gW107XG5cbiAgICBmb3IgKGxldCBpPTE7IGk8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBiID0gYnVmZldpdG5lc3Muc2xpY2UoaSpGci5uOCwgaSpGci5uOCtGci5uOCk7XG4gICAgICAgIHB1YmxpY1NpZ25hbHMucHVzaChTY2FsYXIuZnJvbVJwckxFKGIpKTtcbiAgICB9XG5cbiAgICBwcm9vZi5waV9hID0gRzEudG9PYmplY3QoRzEudG9BZmZpbmUocHJvb2YucGlfYSkpO1xuICAgIHByb29mLnBpX2IgPSBHMi50b09iamVjdChHMi50b0FmZmluZShwcm9vZi5waV9iKSk7XG4gICAgcHJvb2YucGlfYyA9IEcxLnRvT2JqZWN0KEcxLnRvQWZmaW5lKHByb29mLnBpX2MpKTtcblxuICAgIHByb29mLnByb3RvY29sID0gXCJncm90aDE2XCI7XG4gICAgcHJvb2YuY3VydmUgPSBjdXJ2ZS5uYW1lO1xuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG5cbiAgICBwcm9vZiA9IHN0cmluZ2lmeUJpZ0ludHMocHJvb2YpO1xuICAgIHB1YmxpY1NpZ25hbHMgPSBzdHJpbmdpZnlCaWdJbnRzKHB1YmxpY1NpZ25hbHMpO1xuXG4gICAgcmV0dXJuIHtwcm9vZiwgcHVibGljU2lnbmFsc307XG59XG5cblxuYXN5bmMgZnVuY3Rpb24gYnVpbGRBQkMxKGN1cnZlLCB6a2V5LCB3aXRuZXNzLCBjb2VmZnMsIGxvZ2dlcikge1xuICAgIGNvbnN0IG44ID0gY3VydmUuRnIubjg7XG4gICAgY29uc3Qgc0NvZWYgPSA0KjMgKyB6a2V5Lm44cjtcbiAgICBjb25zdCBuQ29lZiA9IChjb2VmZnMuYnl0ZUxlbmd0aC00KSAvIHNDb2VmO1xuXG4gICAgY29uc3Qgb3V0QnVmZkEgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIG44KTtcbiAgICBjb25zdCBvdXRCdWZmQiA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogbjgpO1xuICAgIGNvbnN0IG91dEJ1ZmZDID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBuOCk7XG5cbiAgICBjb25zdCBvdXRCdWYgPSBbIG91dEJ1ZmZBLCBvdXRCdWZmQiBdO1xuICAgIGZvciAobGV0IGk9MDsgaTxuQ29lZjsgaSsrKSB7XG4gICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGBRQVAgQUI6ICR7aX0vJHtuQ29lZn1gKTtcbiAgICAgICAgY29uc3QgYnVmZkNvZWYgPSBjb2VmZnMuc2xpY2UoNCtpKnNDb2VmLCA0K2kqc0NvZWYrc0NvZWYpO1xuICAgICAgICBjb25zdCBidWZmQ29lZlYgPSBuZXcgRGF0YVZpZXcoYnVmZkNvZWYuYnVmZmVyKTtcbiAgICAgICAgY29uc3QgbT0gYnVmZkNvZWZWLmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICAgICAgY29uc3QgYz0gYnVmZkNvZWZWLmdldFVpbnQzMig0LCB0cnVlKTtcbiAgICAgICAgY29uc3Qgcz0gYnVmZkNvZWZWLmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgICAgY29uc3QgY29lZiA9IGJ1ZmZDb2VmLnNsaWNlKDEyLCAxMituOCk7XG4gICAgICAgIG91dEJ1ZlttXS5zZXQoXG4gICAgICAgICAgICBjdXJ2ZS5Gci5hZGQoXG4gICAgICAgICAgICAgICAgb3V0QnVmW21dLnNsaWNlKGMqbjgsIGMqbjgrbjgpLFxuICAgICAgICAgICAgICAgIGN1cnZlLkZyLm11bChjb2VmLCB3aXRuZXNzLnNsaWNlKHMqbjgsIHMqbjgrbjgpKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMqbjhcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYFFBUCBDOiAke2l9LyR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICBvdXRCdWZmQy5zZXQoXG4gICAgICAgICAgICBjdXJ2ZS5Gci5tdWwoXG4gICAgICAgICAgICAgICAgb3V0QnVmZkEuc2xpY2UoaSpuOCwgaSpuOCtuOCksXG4gICAgICAgICAgICAgICAgb3V0QnVmZkIuc2xpY2UoaSpuOCwgaSpuOCtuOCksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgaSpuOFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBbb3V0QnVmZkEsIG91dEJ1ZmZCLCBvdXRCdWZmQ107XG5cbn1cblxuLypcbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkQUJDKGN1cnZlLCB6a2V5LCB3aXRuZXNzLCBjb2VmZnMsIGxvZ2dlcikge1xuICAgIGNvbnN0IGNvbmN1cnJlbmN5ID0gY3VydmUudG0uY29uY3VycmVuY3k7XG4gICAgY29uc3Qgc0NvZWYgPSA0KjMgKyB6a2V5Lm44cjtcblxuICAgIGxldCBnZXRVaW50MzI7XG5cbiAgICBpZiAoY29lZmZzIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGNvZWZmc0RWID0gW107XG4gICAgICAgIGNvbnN0IFBBR0VfTEVOID0gY29lZmZzLmJ1ZmZlcnNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IGNvZWZmcy5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2VmZnNEVi5wdXNoKG5ldyBEYXRhVmlldyhjb2VmZnMuYnVmZmVyc1tpXS5idWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRVaW50MzIgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gY29lZmZzRFZbTWF0aC5mbG9vcihwb3MvUEFHRV9MRU4pXS5nZXRVaW50MzIocG9zICUgUEFHRV9MRU4sIHRydWUpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvZWZmc0RWID0gbmV3IERhdGFWaWV3KGNvZWZmcy5idWZmZXIsIGNvZWZmcy5ieXRlT2Zmc2V0LCBjb2VmZnMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGdldFVpbnQzMiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2VmZnNEVi5nZXRVaW50MzIocG9zLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50c1BlckNodW5rID0gTWF0aC5mbG9vcih6a2V5LmRvbWFpblNpemUvY29uY3VycmVuY3kpO1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICBjb25zdCBjdXRQb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICBjdXRQb2ludHMucHVzaCggZ2V0Q3V0UG9pbnQoIE1hdGguZmxvb3IoaSplbGVtZW50c1BlckNodW5rKSApKTtcbiAgICB9XG4gICAgY3V0UG9pbnRzLnB1c2goY29lZmZzLmJ5dGVMZW5ndGgpO1xuXG4gICAgY29uc3QgY2h1bmtTaXplID0gMioqMjY7XG4gICAgZm9yIChsZXQgcz0wIDsgczx6a2V5Lm5WYXJzIDsgcys9IGNodW5rU2l6ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYFFBUCAke3N9OiAke3N9LyR7emtleS5uVmFyc31gKTtcbiAgICAgICAgY29uc3QgbnM9IE1hdGgubWluKHprZXkublZhcnMtcywgY2h1bmtTaXplICk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGk8IGNvbmN1cnJlbmN5LTEpIHtcbiAgICAgICAgICAgICAgICBuID0gZWxlbWVudHNQZXJDaHVuaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IHprZXkuZG9tYWluU2l6ZSAtIGkqZWxlbWVudHNQZXJDaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuPT0wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGNvZWZmcy5zbGljZShjdXRQb2ludHNbaV0sIGN1dFBvaW50c1tpKzFdKX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiB3aXRuZXNzLnNsaWNlKHMqY3VydmUuRnIubjgsIChzK25zKSpjdXJ2ZS5Gci5uOCl9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMiwgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDMsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiA0LCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcInFhcF9idWlsZEFCQ1wiLCBwYXJhbXM6W1xuICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgIHt2YWw6IChjdXRQb2ludHNbaSsxXSAtIGN1dFBvaW50c1tpXSkvc0NvZWZ9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDR9LFxuICAgICAgICAgICAgICAgIHt2YWw6IGkqZWxlbWVudHNQZXJDaHVua30sXG4gICAgICAgICAgICAgICAge3ZhbDogbn0sXG4gICAgICAgICAgICAgICAge3ZhbDogc30sXG4gICAgICAgICAgICAgICAge3ZhbDogbnN9XG4gICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDIsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMSwgdmFyOiAzLCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDIsIHZhcjogNCwgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICBjb25zdCBuR3JvdXBzID0gcmVzdWx0Lmxlbmd0aCAvIGNvbmN1cnJlbmN5O1xuICAgIGlmIChuR3JvdXBzPjEpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMyID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrPVtdO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAwLCBsZW46IHJlc3VsdFtpXVswXS5ieXRlTGVuZ3RofSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDEsIGxlbjogcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGh9KTtcbiAgICAgICAgICAgIGZvciAobGV0IG09MDsgbTwzOyBtKyspIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJTRVRcIiwgdmFyOiAwLCBidWZmOiByZXN1bHRbaV1bbV19KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzPTE7IHM8bkdyb3VwczsgcysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIlNFVFwiLCB2YXI6IDEsIGJ1ZmY6IHJlc3VsdFtzKmNvbmN1cnJlbmN5ICsgaV1bbV19KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwicWFwX2JhdGNoQWRkXCIsIHBhcmFtczpbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogcmVzdWx0W2ldW21dLmxlbmd0aC9jdXJ2ZS5Gci5uOH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfVxuICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IG0sIHZhcjogMCwgbGVuOiByZXN1bHRbaV1bbV0ubGVuZ3RofSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlczIucHVzaChjdXJ2ZS50bS5xdWV1ZUFjdGlvbih0YXNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMyKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRCdWZmQSA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogY3VydmUuRnIubjgpO1xuICAgIGNvbnN0IG91dEJ1ZmZCID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBjdXJ2ZS5Gci5uOCk7XG4gICAgY29uc3Qgb3V0QnVmZkMgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIGN1cnZlLkZyLm44KTtcbiAgICBsZXQgcD0wO1xuICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0QnVmZkEuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgIG91dEJ1ZmZCLnNldChyZXN1bHRbaV1bMV0sIHApO1xuICAgICAgICBvdXRCdWZmQy5zZXQocmVzdWx0W2ldWzJdLCBwKTtcbiAgICAgICAgcCArPSByZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gW291dEJ1ZmZBLCBvdXRCdWZmQiwgb3V0QnVmZkNdO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q3V0UG9pbnQodikge1xuICAgICAgICBsZXQgbSA9IDA7XG4gICAgICAgIGxldCBuID0gZ2V0VWludDMyKDApO1xuICAgICAgICB3aGlsZSAobSA8IG4pIHtcbiAgICAgICAgICAgIHZhciBrID0gTWF0aC5mbG9vcigobiArIG0pIC8gMik7XG4gICAgICAgICAgICBjb25zdCB2YSA9IGdldFVpbnQzMig0ICsgaypzQ29lZiArIDQpO1xuICAgICAgICAgICAgaWYgKHZhID4gdikge1xuICAgICAgICAgICAgICAgIG4gPSBrIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmEgPCB2KSB7XG4gICAgICAgICAgICAgICAgbSA9IGsgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gNCArIG0qc0NvZWY7XG4gICAgfVxufVxuKi9cblxuYXN5bmMgZnVuY3Rpb24gam9pbkFCQyhjdXJ2ZSwgemtleSwgYSwgYiwgYywgbG9nZ2VyKSB7XG4gICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxIDw8IDIyO1xuXG4gICAgY29uc3QgbjggPSBjdXJ2ZS5Gci5uODtcbiAgICBjb25zdCBuRWxlbWVudHMgPSBNYXRoLmZsb29yKGEuYnl0ZUxlbmd0aCAvIGN1cnZlLkZyLm44KTtcblxuICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8bkVsZW1lbnRzOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSm9pbkFCQzogJHtpfS8ke25FbGVtZW50c31gKTtcbiAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4obkVsZW1lbnRzIC0gaSwgTUFYX0NIVU5LX1NJWkUpO1xuXG4gICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcblxuICAgICAgICBjb25zdCBhQ2h1bmsgPSBhLnNsaWNlKGkqbjgsIChpICsgbikqbjggKTtcbiAgICAgICAgY29uc3QgYkNodW5rID0gYi5zbGljZShpKm44LCAoaSArIG4pKm44ICk7XG4gICAgICAgIGNvbnN0IGNDaHVuayA9IGMuc2xpY2UoaSpuOCwgKGkgKyBuKSpuOCApO1xuXG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYUNodW5rfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYkNodW5rfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMiwgYnVmZjogY0NodW5rfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMywgbGVuOiBuKm44fSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcInFhcF9qb2luQUJDXCIsIHBhcmFtczpbXG4gICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcImZybV9iYXRjaEZyb21Nb250Z29tZXJ5XCIsIHBhcmFtczpbXG4gICAgICAgICAgICB7dmFyOiAzfSxcbiAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAge3ZhcjogM31cbiAgICAgICAgXX0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDMsIGxlbjogbipuOH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICBsZXQgb3V0QnVmZjtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIEJpZ0J1ZmZlcikge1xuICAgICAgICBvdXRCdWZmID0gbmV3IEJpZ0J1ZmZlcihhLmJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dEJ1ZmYgPSBuZXcgVWludDhBcnJheShhLmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIGxldCBwPTA7XG4gICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRCdWZmLnNldChyZXN1bHRbaV1bMF0sIHApO1xuICAgICAgICBwICs9IHJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRCdWZmO1xufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/groth16_prove.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/groth16_verify.js":
/*!****************************************************!*\
  !*** ./node_modules/snarkjs/src/groth16_verify.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16Verify)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2016/260.pdf */\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {\n/*\n    let cpub = vk_verifier.IC[0];\n    for (let s= 0; s< vk_verifier.nPublic; s++) {\n        cpub  = G1.add( cpub, G1.timesScalar( vk_verifier.IC[s+1], publicSignals[s]));\n    }\n*/\n\n    const vk_verifier = unstringifyBigInts(_vk_verifier);\n    const proof = unstringifyBigInts(_proof);\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_1__.getCurveFromName(vk_verifier.curve);\n\n    const IC0 = curve.G1.fromObject(vk_verifier.IC[0]);\n    const IC = new Uint8Array(curve.G1.F.n8*2 * publicSignals.length);\n    const w = new Uint8Array(curve.Fr.n8 * publicSignals.length);\n\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    for (let i=0; i<publicSignals.length; i++) {\n        const buffP = curve.G1.fromObject(vk_verifier.IC[i+1]);\n        IC.set(buffP, i*curve.G1.F.n8*2);\n        ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(w, curve.Fr.n8*i, publicSignals[i], curve.Fr.n8);\n    }\n\n    let cpub = await curve.G1.multiExpAffine(IC, w);\n    cpub = curve.G1.add(cpub, IC0);\n\n    const pi_a = curve.G1.fromObject(proof.pi_a);\n    const pi_b = curve.G2.fromObject(proof.pi_b);\n    const pi_c = curve.G1.fromObject(proof.pi_c);\n\n    if (!isWellConstructed(curve, {pi_a, pi_b, pi_c})) {\n        if(logger) logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    const vk_gamma_2 = curve.G2.fromObject(vk_verifier.vk_gamma_2);\n    const vk_delta_2 = curve.G2.fromObject(vk_verifier.vk_delta_2);\n    const vk_alpha_1 = curve.G1.fromObject(vk_verifier.vk_alpha_1);\n    const vk_beta_2 = curve.G2.fromObject(vk_verifier.vk_beta_2);\n\n    const res = await curve.pairingEq(\n        curve.G1.neg(pi_a) , pi_b,\n        cpub , vk_gamma_2,\n        pi_c , vk_delta_2,\n\n        vk_alpha_1, vk_beta_2\n    );\n\n    if (! res) {\n        if (logger) logger.error(\"Invalid proof\");\n        return false;\n    }\n\n    if (logger) logger.info(\"OK!\");\n    return true;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    return G1.isValid(proof.pi_a)\n        && G2.isValid(proof.pi_b)\n        && G1.isValid(proof.pi_c);\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.geq(value, 0) && ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.lt(value, curve.r);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl92ZXJpZnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzQztBQUNBO0FBQ0U7QUFDeEMsT0FBTyxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFbkI7QUFDZjtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix3REFBdUI7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQSxRQUFRLGdEQUFNO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnREFBTSxrQkFBa0IsZ0RBQU07QUFDekM7O0FBRUE7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9ncm90aDE2X3ZlcmlmeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGlzIHBhcGVyOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE2LzI2MC5wZGYgKi9cbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCAqIGFzIGN1cnZlcyBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ3JvdGgxNlZlcmlmeShfdmtfdmVyaWZpZXIsIF9wdWJsaWNTaWduYWxzLCBfcHJvb2YsIGxvZ2dlcikge1xuLypcbiAgICBsZXQgY3B1YiA9IHZrX3ZlcmlmaWVyLklDWzBdO1xuICAgIGZvciAobGV0IHM9IDA7IHM8IHZrX3ZlcmlmaWVyLm5QdWJsaWM7IHMrKykge1xuICAgICAgICBjcHViICA9IEcxLmFkZCggY3B1YiwgRzEudGltZXNTY2FsYXIoIHZrX3ZlcmlmaWVyLklDW3MrMV0sIHB1YmxpY1NpZ25hbHNbc10pKTtcbiAgICB9XG4qL1xuXG4gICAgY29uc3QgdmtfdmVyaWZpZXIgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3ZrX3ZlcmlmaWVyKTtcbiAgICBjb25zdCBwcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpO1xuICAgIGNvbnN0IHB1YmxpY1NpZ25hbHMgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3B1YmxpY1NpZ25hbHMpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBjdXJ2ZXMuZ2V0Q3VydmVGcm9tTmFtZSh2a192ZXJpZmllci5jdXJ2ZSk7XG5cbiAgICBjb25zdCBJQzAgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrX3ZlcmlmaWVyLklDWzBdKTtcbiAgICBjb25zdCBJQyA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcxLkYubjgqMiAqIHB1YmxpY1NpZ25hbHMubGVuZ3RoKTtcbiAgICBjb25zdCB3ID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRnIubjggKiBwdWJsaWNTaWduYWxzLmxlbmd0aCk7XG5cbiAgICBpZiAoIXB1YmxpY0lucHV0c0FyZVZhbGlkKGN1cnZlLCBwdWJsaWNTaWduYWxzKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQdWJsaWMgaW5wdXRzIGFyZSBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaT0wOyBpPHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmZlAgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrX3ZlcmlmaWVyLklDW2krMV0pO1xuICAgICAgICBJQy5zZXQoYnVmZlAsIGkqY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgU2NhbGFyLnRvUnByTEUodywgY3VydmUuRnIubjgqaSwgcHVibGljU2lnbmFsc1tpXSwgY3VydmUuRnIubjgpO1xuICAgIH1cblxuICAgIGxldCBjcHViID0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoSUMsIHcpO1xuICAgIGNwdWIgPSBjdXJ2ZS5HMS5hZGQoY3B1YiwgSUMwKTtcblxuICAgIGNvbnN0IHBpX2EgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHByb29mLnBpX2EpO1xuICAgIGNvbnN0IHBpX2IgPSBjdXJ2ZS5HMi5mcm9tT2JqZWN0KHByb29mLnBpX2IpO1xuICAgIGNvbnN0IHBpX2MgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHByb29mLnBpX2MpO1xuXG4gICAgaWYgKCFpc1dlbGxDb25zdHJ1Y3RlZChjdXJ2ZSwge3BpX2EsIHBpX2IsIHBpX2N9KSkge1xuICAgICAgICBpZihsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlByb29mIGNvbW1pdG1lbnRzIGFyZSBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmtfZ2FtbWFfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfZ2FtbWFfMik7XG4gICAgY29uc3QgdmtfZGVsdGFfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfZGVsdGFfMik7XG4gICAgY29uc3QgdmtfYWxwaGFfMSA9IGN1cnZlLkcxLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfYWxwaGFfMSk7XG4gICAgY29uc3QgdmtfYmV0YV8yID0gY3VydmUuRzIuZnJvbU9iamVjdCh2a192ZXJpZmllci52a19iZXRhXzIpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUucGFpcmluZ0VxKFxuICAgICAgICBjdXJ2ZS5HMS5uZWcocGlfYSkgLCBwaV9iLFxuICAgICAgICBjcHViICwgdmtfZ2FtbWFfMixcbiAgICAgICAgcGlfYyAsIHZrX2RlbHRhXzIsXG5cbiAgICAgICAgdmtfYWxwaGFfMSwgdmtfYmV0YV8yXG4gICAgKTtcblxuICAgIGlmICghIHJlcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHByb29mXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJPSyFcIik7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzV2VsbENvbnN0cnVjdGVkKGN1cnZlLCBwcm9vZikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRzIgPSBjdXJ2ZS5HMjtcblxuICAgIHJldHVybiBHMS5pc1ZhbGlkKHByb29mLnBpX2EpXG4gICAgICAgICYmIEcyLmlzVmFsaWQocHJvb2YucGlfYilcbiAgICAgICAgJiYgRzEuaXNWYWxpZChwcm9vZi5waV9jKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tWYWx1ZUJlbG9uZ1RvRmllbGQoY3VydmUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFNjYWxhci5nZXEodmFsdWUsIDApICYmIFNjYWxhci5sdCh2YWx1ZSwgY3VydmUucik7XG59XG5cbmZ1bmN0aW9uIHB1YmxpY0lucHV0c0FyZVZhbGlkKGN1cnZlLCBwdWJsaWNJbnB1dHMpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHVibGljSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKCFjaGVja1ZhbHVlQmVsb25nVG9GaWVsZChjdXJ2ZSwgcHVibGljSW5wdXRzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/groth16_verify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/keypair.js":
/*!*********************************************!*\
  !*** ./node_modules/snarkjs/src/keypair.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeltaKey: () => (/* binding */ createDeltaKey),\n/* harmony export */   createPTauKey: () => (/* binding */ createPTauKey),\n/* harmony export */   getG2sp: () => (/* binding */ getG2sp),\n/* harmony export */   hashToG2: () => (/* binding */ hashToG2)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nfunction hashToG2(curve, hash) {\n    const hashV = new DataView(hash.buffer, hash.byteOffset, hash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = hashV.getUint32(i*4);\n    }\n\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.ChaCha(seed);\n\n    const g2_sp = curve.G2.fromRng(rng);\n\n    return g2_sp;\n}\n\nfunction getG2sp(curve, persinalization, challenge, g1s, g1sx) {\n\n    const h = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_1__.blake2b.create({ dkLen: 64 });\n    const b1 = new Uint8Array([persinalization]);\n    h.update(b1);\n    h.update(challenge);\n    const b3 = curve.G1.toUncompressed(g1s);\n    h.update( b3);\n    const b4 = curve.G1.toUncompressed(g1sx);\n    h.update( b4);\n    const hash =h.digest();\n\n    return hashToG2(curve, hash);\n}\n\nfunction calculatePubKey(k, curve, personalization, challengeHash, rng ) {\n    k.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    k.g1_sx = curve.G1.toAffine(curve.G1.timesFr(k.g1_s, k.prvKey));\n    k.g2_sp = curve.G2.toAffine(getG2sp(curve, personalization, challengeHash, k.g1_s, k.g1_sx));\n    k.g2_spx = curve.G2.toAffine(curve.G2.timesFr(k.g2_sp, k.prvKey));\n    return k;\n}\n\nfunction createPTauKey(curve, challengeHash, rng) {\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n    key.tau.prvKey = curve.Fr.fromRng(rng);\n    key.alpha.prvKey = curve.Fr.fromRng(rng);\n    key.beta.prvKey = curve.Fr.fromRng(rng);\n    calculatePubKey(key.tau, curve, 0, challengeHash, rng);\n    calculatePubKey(key.alpha, curve, 1, challengeHash, rng);\n    calculatePubKey(key.beta, curve, 2, challengeHash, rng);\n    return key;\n}\n\nfunction createDeltaKey(curve, transcript, rng) {\n    const delta = {};\n    delta.prvKey = curve.Fr.fromRng(rng);\n    delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    delta.g1_sx = curve.G1.toAffine(curve.G1.timesScalar(delta.g1_s, delta.prvKey));\n    delta.g2_sp = hashToG2(curve, transcript);\n    delta.g2_spx = curve.G2.toAffine(curve.G2.timesScalar(delta.g2_sp, delta.prvKey));\n    return delta;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMva2V5cGFpci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVnRDs7QUFFVjs7QUFFL0I7QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTs7QUFFQSxvQkFBb0IsZ0RBQU07O0FBRTFCOztBQUVBO0FBQ0E7O0FBRU87O0FBRVAsY0FBYywwREFBTyxVQUFVLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9rZXlwYWlyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5cbmltcG9ydCB7IENoYUNoYSB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb0cyKGN1cnZlLCBoYXNoKSB7XG4gICAgY29uc3QgaGFzaFYgPSBuZXcgRGF0YVZpZXcoaGFzaC5idWZmZXIsIGhhc2guYnl0ZU9mZnNldCwgaGFzaC5ieXRlTGVuZ3RoKTtcbiAgICBjb25zdCBzZWVkID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPDg7IGkrKykge1xuICAgICAgICBzZWVkW2ldID0gaGFzaFYuZ2V0VWludDMyKGkqNCk7XG4gICAgfVxuXG4gICAgY29uc3Qgcm5nID0gbmV3IENoYUNoYShzZWVkKTtcblxuICAgIGNvbnN0IGcyX3NwID0gY3VydmUuRzIuZnJvbVJuZyhybmcpO1xuXG4gICAgcmV0dXJuIGcyX3NwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RzJzcChjdXJ2ZSwgcGVyc2luYWxpemF0aW9uLCBjaGFsbGVuZ2UsIGcxcywgZzFzeCkge1xuXG4gICAgY29uc3QgaCA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIGNvbnN0IGIxID0gbmV3IFVpbnQ4QXJyYXkoW3BlcnNpbmFsaXphdGlvbl0pO1xuICAgIGgudXBkYXRlKGIxKTtcbiAgICBoLnVwZGF0ZShjaGFsbGVuZ2UpO1xuICAgIGNvbnN0IGIzID0gY3VydmUuRzEudG9VbmNvbXByZXNzZWQoZzFzKTtcbiAgICBoLnVwZGF0ZSggYjMpO1xuICAgIGNvbnN0IGI0ID0gY3VydmUuRzEudG9VbmNvbXByZXNzZWQoZzFzeCk7XG4gICAgaC51cGRhdGUoIGI0KTtcbiAgICBjb25zdCBoYXNoID1oLmRpZ2VzdCgpO1xuXG4gICAgcmV0dXJuIGhhc2hUb0cyKGN1cnZlLCBoYXNoKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUHViS2V5KGssIGN1cnZlLCBwZXJzb25hbGl6YXRpb24sIGNoYWxsZW5nZUhhc2gsIHJuZyApIHtcbiAgICBrLmcxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgIGsuZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGsuZzFfcywgay5wcnZLZXkpKTtcbiAgICBrLmcyX3NwID0gY3VydmUuRzIudG9BZmZpbmUoZ2V0RzJzcChjdXJ2ZSwgcGVyc29uYWxpemF0aW9uLCBjaGFsbGVuZ2VIYXNoLCBrLmcxX3MsIGsuZzFfc3gpKTtcbiAgICBrLmcyX3NweCA9IGN1cnZlLkcyLnRvQWZmaW5lKGN1cnZlLkcyLnRpbWVzRnIoay5nMl9zcCwgay5wcnZLZXkpKTtcbiAgICByZXR1cm4gaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBUYXVLZXkoY3VydmUsIGNoYWxsZW5nZUhhc2gsIHJuZykge1xuICAgIGNvbnN0IGtleSA9IHtcbiAgICAgICAgdGF1OiB7fSxcbiAgICAgICAgYWxwaGE6IHt9LFxuICAgICAgICBiZXRhOiB7fVxuICAgIH07XG4gICAga2V5LnRhdS5wcnZLZXkgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAga2V5LmFscGhhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBrZXkuYmV0YS5wcnZLZXkgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAgY2FsY3VsYXRlUHViS2V5KGtleS50YXUsIGN1cnZlLCAwLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuICAgIGNhbGN1bGF0ZVB1YktleShrZXkuYWxwaGEsIGN1cnZlLCAxLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuICAgIGNhbGN1bGF0ZVB1YktleShrZXkuYmV0YSwgY3VydmUsIDIsIGNoYWxsZW5nZUhhc2gsIHJuZyk7XG4gICAgcmV0dXJuIGtleTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlbHRhS2V5KGN1cnZlLCB0cmFuc2NyaXB0LCBybmcpIHtcbiAgICBjb25zdCBkZWx0YSA9IHt9O1xuICAgIGRlbHRhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBkZWx0YS5nMV9zID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEuZnJvbVJuZyhybmcpKTtcbiAgICBkZWx0YS5nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzU2NhbGFyKGRlbHRhLmcxX3MsIGRlbHRhLnBydktleSkpO1xuICAgIGRlbHRhLmcyX3NwID0gaGFzaFRvRzIoY3VydmUsIHRyYW5zY3JpcHQpO1xuICAgIGRlbHRhLmcyX3NweCA9IGN1cnZlLkcyLnRvQWZmaW5lKGN1cnZlLkcyLnRpbWVzU2NhbGFyKGRlbHRhLmcyX3NwLCBkZWx0YS5wcnZLZXkpKTtcbiAgICByZXR1cm4gZGVsdGE7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/keypair.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/loadsyms.js":
/*!**********************************************!*\
  !*** ./node_modules/snarkjs/src/loadsyms.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loadSymbols)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/src/fastfile.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nasync function loadSymbols(symFileName) {\n    const sym = {\n        labelIdx2Name: [ \"one\" ],\n        varIdx2Name: [ \"one\" ],\n        componentIdx2Name: []\n    };\n    const fd = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(symFileName);\n    const buff = await fd.read(fd.totalSize);\n    const symsStr = new TextDecoder(\"utf-8\").decode(buff);\n    const lines = symsStr.split(\"\\n\");\n    for (let i=0; i<lines.length; i++) {\n        const arr = lines[i].split(\",\");\n        if (arr.length!=4) continue;\n        if (sym.varIdx2Name[arr[1]]) {\n            sym.varIdx2Name[arr[1]] += \"|\" + arr[3];\n        } else {\n            sym.varIdx2Name[arr[1]] = arr[3];\n        }\n        sym.labelIdx2Name[arr[0]] = arr[3];\n        if (!sym.componentIdx2Name[arr[2]]) {\n            sym.componentIdx2Name[arr[2]] = extractComponent(arr[3]);\n        }\n    }\n\n    await fd.close();\n\n    return sym;\n\n    function extractComponent(name) {\n        const arr = name.split(\".\");\n        arr.pop(); // Remove the lasr element\n        return arr.join(\".\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbG9hZHN5bXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVxQzs7QUFFdEI7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtEQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2xvYWRzeW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBsb2FkU3ltYm9scyhzeW1GaWxlTmFtZSkge1xuICAgIGNvbnN0IHN5bSA9IHtcbiAgICAgICAgbGFiZWxJZHgyTmFtZTogWyBcIm9uZVwiIF0sXG4gICAgICAgIHZhcklkeDJOYW1lOiBbIFwib25lXCIgXSxcbiAgICAgICAgY29tcG9uZW50SWR4Mk5hbWU6IFtdXG4gICAgfTtcbiAgICBjb25zdCBmZCA9IGF3YWl0IGZhc3RGaWxlLnJlYWRFeGlzdGluZyhzeW1GaWxlTmFtZSk7XG4gICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoZmQudG90YWxTaXplKTtcbiAgICBjb25zdCBzeW1zU3RyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIikuZGVjb2RlKGJ1ZmYpO1xuICAgIGNvbnN0IGxpbmVzID0gc3ltc1N0ci5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gbGluZXNbaV0uc3BsaXQoXCIsXCIpO1xuICAgICAgICBpZiAoYXJyLmxlbmd0aCE9NCkgY29udGludWU7XG4gICAgICAgIGlmIChzeW0udmFySWR4Mk5hbWVbYXJyWzFdXSkge1xuICAgICAgICAgICAgc3ltLnZhcklkeDJOYW1lW2FyclsxXV0gKz0gXCJ8XCIgKyBhcnJbM107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzeW0udmFySWR4Mk5hbWVbYXJyWzFdXSA9IGFyclszXTtcbiAgICAgICAgfVxuICAgICAgICBzeW0ubGFiZWxJZHgyTmFtZVthcnJbMF1dID0gYXJyWzNdO1xuICAgICAgICBpZiAoIXN5bS5jb21wb25lbnRJZHgyTmFtZVthcnJbMl1dKSB7XG4gICAgICAgICAgICBzeW0uY29tcG9uZW50SWR4Mk5hbWVbYXJyWzJdXSA9IGV4dHJhY3RDb21wb25lbnQoYXJyWzNdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gc3ltO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdENvbXBvbmVudChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICAgICAgICBhcnIucG9wKCk7IC8vIFJlbW92ZSB0aGUgbGFzciBlbGVtZW50XG4gICAgICAgIHJldHVybiBhcnIuam9pbihcIi5cIik7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/loadsyms.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/misc.js":
/*!******************************************!*\
  !*** ./node_modules/snarkjs/src/misc.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   askEntropy: () => (/* binding */ askEntropy),\n/* harmony export */   bitReverse: () => (/* binding */ bitReverse),\n/* harmony export */   byteArray2hex: () => (/* binding */ byteArray2hex),\n/* harmony export */   cloneHasher: () => (/* binding */ cloneHasher),\n/* harmony export */   formatHash: () => (/* binding */ formatHash),\n/* harmony export */   fromPartialHash: () => (/* binding */ fromPartialHash),\n/* harmony export */   getRandomBytes: () => (/* binding */ getRandomBytes),\n/* harmony export */   getRandomRng: () => (/* binding */ getRandomRng),\n/* harmony export */   hashIsEqual: () => (/* binding */ hashIsEqual),\n/* harmony export */   hex2ByteArray: () => (/* binding */ hex2ByteArray),\n/* harmony export */   log2: () => (/* binding */ log2),\n/* harmony export */   readUInt32BE: () => (/* binding */ readUInt32BE),\n/* harmony export */   rngFromBeaconParams: () => (/* binding */ rngFromBeaconParams),\n/* harmony export */   sameRatio: () => (/* binding */ sameRatio),\n/* harmony export */   sha256digest: () => (/* binding */ sha256digest),\n/* harmony export */   stringifyBigIntsWithField: () => (/* binding */ stringifyBigIntsWithField),\n/* harmony export */   toPartialHash: () => (/* binding */ toPartialHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! readline */ \"readline\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* global window */\n\n\n\n\n\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction bitReverse(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction formatHash(b, title) {\n    const a = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    let S = \"\";\n    for (let i=0; i<4; i++) {\n        if (i>0) S += \"\\n\";\n        S += \"\\t\\t\";\n        for (let j=0; j<4; j++) {\n            if (j>0) S += \" \";\n            S += a.getUint32(i*16+j*4).toString(16).padStart(8, \"0\");\n        }\n    }\n    if (title) S = title + \"\\n\" + S;\n    return S;\n}\n\nfunction hashIsEqual(h1, h2) {\n    if (h1.byteLength != h2.byteLength) return false;\n    var dv1 = new Int8Array(h1);\n    var dv2 = new Int8Array(h2);\n    for (var i = 0 ; i != h1.byteLength ; i++)\n    {\n        if (dv1[i] != dv2[i]) return false;\n    }\n    return true;\n}\n\nfunction cloneHasher(h) {\n    return h.clone();\n}\n\nfunction fromPartialHash(partial) {\n    // NOTE: this is unsafe and uses internal API\n    const buf = partial.subarray(0, 128);\n    const rest = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.u32)(partial.subarray(128));\n    const res = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n    res.buffer.set(buf);\n    (res.v0l = rest[0] | 0), (res.v0h = rest[1] | 0);\n    (res.v1l = rest[2] | 0), (res.v1h = rest[3] | 0);\n    (res.v2l = rest[4] | 0), (res.v2h = rest[5] | 0);\n    (res.v3l = rest[6] | 0), (res.v3h = rest[7] | 0);\n    (res.v4l = rest[8] | 0), (res.v4h = rest[9] | 0);\n    (res.v5l = rest[10] | 0), (res.v5h = rest[11] | 0);\n    (res.v6l = rest[12] | 0), (res.v6h = rest[13] | 0);\n    (res.v7l = rest[14] | 0), (res.v7h = rest[15] | 0);\n    const shift = 2 ** 32;\n    const len = rest[16] + rest[17] * shift;\n    const pos = rest[18] + rest[19] * shift;\n    res.length = len + pos;\n    res.pos = pos;\n    return res;\n}\n\nfunction toPartialHash(hash){\n    // NOTE: this is unsafe and uses internal API\n    const res = new Uint8Array(216);\n    const res32 = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.u32)(res.subarray(128));\n    res.set(hash.buffer);\n    (res32[0] = hash.v0l), (res32[1] = hash.v0h);\n    (res32[2] = hash.v1l), (res32[3] = hash.v1h);\n    (res32[4] = hash.v2l), (res32[5] = hash.v2h);\n    (res32[6] = hash.v3l), (res32[7] = hash.v3h);\n    (res32[8] = hash.v4l), (res32[9] = hash.v4h);\n    (res32[10] = hash.v5l), (res32[11] = hash.v5h);\n    (res32[12] = hash.v6l), (res32[13] = hash.v6h);\n    (res32[14] = hash.v7l), (res32[15] = hash.v7h);\n    res32[18] = hash.pos;\n    res32[16] = hash.length-hash.pos;\n    return res;\n}\n\nasync function sameRatio(curve, g1s, g1sx, g2s, g2sx) {\n    if (curve.G1.isZero(g1s)) return false;\n    if (curve.G1.isZero(g1sx)) return false;\n    if (curve.G2.isZero(g2s)) return false;\n    if (curve.G2.isZero(g2sx)) return false;\n    // return curve.F12.eq(curve.pairing(g1s, g2sx), curve.pairing(g1sx, g2s));\n    const res = await curve.pairingEq(g1s, g2sx, curve.G1.neg(g1sx), g2s);\n    return res;\n}\n\n\nfunction askEntropy() {\n    if (false) {} else {\n        const rl = readline__WEBPACK_IMPORTED_MODULE_0__.createInterface({\n            input: process.stdin,\n            output: process.stdout\n        });\n\n        return new Promise((resolve) => {\n            rl.question(\"Enter a random text. (Entropy): \", (input) => resolve(input) );\n        });\n    }\n}\n\nfunction getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (false) {} else { // NodeJS\n        crypto__WEBPACK_IMPORTED_MODULE_2__.randomFillSync(array);\n    }\n    return array;\n}\n\nasync function sha256digest(data) {\n    if (false) {} else { // NodeJS\n        return crypto__WEBPACK_IMPORTED_MODULE_2__.createHash(\"sha256\").update(data).digest();\n    }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n */\nfunction readUInt32BE(data, offset) {\n    return new DataView(data.buffer).getUint32(offset, false);\n}\n\nasync function getRandomRng(entropy) {\n    // Generate a random Rng\n    while (!entropy) {\n        entropy = await askEntropy();\n    }\n    const hasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create(64);\n    hasher.update(getRandomBytes(64));\n    const enc = new TextEncoder(); // always utf-8\n    hasher.update(enc.encode(entropy));\n    const hash = hasher.digest();\n\n    const seed = [];\n    for (let i=0;i<8;i++) {\n        seed[i] = readUInt32BE(hash, i*4);\n    }\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.ChaCha(seed);\n    return rng;\n}\n\nasync function rngFromBeaconParams(beaconHash, numIterationsExp) {\n    let nIterationsInner;\n    let nIterationsOuter;\n    if (numIterationsExp<32) {\n        nIterationsInner = (1 << numIterationsExp) >>> 0;\n        nIterationsOuter = 1;\n    } else {\n        nIterationsInner = 0x100000000;\n        nIterationsOuter = (1 << (numIterationsExp-32)) >>> 0;\n    }\n\n    let curHash = beaconHash;\n    for (let i=0; i<nIterationsOuter; i++) {\n        for (let j=0; j<nIterationsInner; j++) {\n            curHash = await sha256digest(curHash);\n        }\n    }\n\n    const curHashV = new DataView(curHash.buffer, curHash.byteOffset, curHash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = curHashV.getUint32(i*4, false);\n    }\n\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.ChaCha(seed);\n\n    return rng;\n}\n\nfunction hex2ByteArray(s) {\n    if (s instanceof Uint8Array) return s;\n    if (s.slice(0,2) == \"0x\") s= s.slice(2);\n    return new Uint8Array(s.match(/[\\da-f]{2}/gi).map(function (h) {\n        return parseInt(h, 16);\n    }));\n}\n\nfunction byteArray2hex(byteArray) {\n    return Array.prototype.map.call(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nfunction stringifyBigIntsWithField(Fr, o) {\n    if (o instanceof Uint8Array)  {\n        return Fr.toString(o);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigIntsWithField.bind(null, Fr));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach( (k) => {\n            res[k] = stringifyBigIntsWithField(Fr, o[k]);\n        });\n        return res;\n    } else if ((typeof(o) == \"bigint\") || o.eq !== undefined)  {\n        return o.toString(10);\n    } else {\n        return o;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbWlzYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnRDtBQUNOO0FBQ1Y7QUFDTTtBQUNWOztBQUU1QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQUc7QUFDcEIsZ0JBQWdCLDBEQUFPLFVBQVUsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQLFFBQVEsS0FBZSxFQUFFLEVBRXBCLENBQUM7QUFDTixtQkFBbUIscURBQXdCO0FBQzNDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsUUFBUSxLQUFlLEVBQUUsRUFFcEIsQ0FBQyxPQUFPO0FBQ2IsUUFBUSxrREFBcUI7QUFDN0I7QUFDQTtBQUNBOztBQUVPO0FBQ1AsUUFBUSxLQUFlLEVBQUUsRUFHcEIsQ0FBQyxPQUFPO0FBQ2IsZUFBZSw4Q0FBaUI7QUFDaEM7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBTztBQUMxQjtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBLG9CQUFvQixnREFBTTtBQUMxQjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBOztBQUVBLG9CQUFvQixnREFBTTs7QUFFMUI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBLEtBQUs7QUFDTDs7QUFFTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9taXNjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgeyB1MzIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHJlYWRsaW5lIGZyb20gXCJyZWFkbGluZVwiO1xuaW1wb3J0IHsgQ2hhQ2hhIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5cbmNvbnN0IF9yZXZUYWJsZSA9IFtdO1xuZm9yIChsZXQgaT0wOyBpPDI1NjsgaSsrKSB7XG4gICAgX3JldlRhYmxlW2ldID0gX3JldlNsb3coaSwgOCk7XG59XG5cbmZ1bmN0aW9uIF9yZXZTbG93KGlkeCwgYml0cykge1xuICAgIGxldCByZXMgPTA7XG4gICAgbGV0IGEgPSBpZHg7XG4gICAgZm9yIChsZXQgaT0wOyBpPGJpdHM7IGkrKykge1xuICAgICAgICByZXMgPDw9IDE7XG4gICAgICAgIHJlcyA9IHJlcyB8IChhICYxKTtcbiAgICAgICAgYSA+Pj0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0UmV2ZXJzZShpZHgsIGJpdHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBfcmV2VGFibGVbaWR4ID4+PiAyNF0gfFxuICAgICAgICAoX3JldlRhYmxlWyhpZHggPj4+IDE2KSAmIDB4RkZdIDw8IDgpIHxcbiAgICAgICAgKF9yZXZUYWJsZVsoaWR4ID4+PiA4KSAmIDB4RkZdIDw8IDE2KSB8XG4gICAgICAgIChfcmV2VGFibGVbaWR4ICYgMHhGRl0gPDwgMjQpXG4gICAgKSA+Pj4gKDMyLWJpdHMpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBsb2cyKCBWIClcbntcbiAgICByZXR1cm4oICggKCBWICYgMHhGRkZGMDAwMCApICE9PSAwID8gKCBWICY9IDB4RkZGRjAwMDAsIDE2ICkgOiAwICkgfCAoICggViAmIDB4RkYwMEZGMDAgKSAhPT0gMCA/ICggViAmPSAweEZGMDBGRjAwLCA4ICkgOiAwICkgfCAoICggViAmIDB4RjBGMEYwRjAgKSAhPT0gMCA/ICggViAmPSAweEYwRjBGMEYwLCA0ICkgOiAwICkgfCAoICggViAmIDB4Q0NDQ0NDQ0MgKSAhPT0gMCA/ICggViAmPSAweENDQ0NDQ0NDLCAyICkgOiAwICkgfCAoICggViAmIDB4QUFBQUFBQUEgKSAhPT0gMCApICk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEhhc2goYiwgdGl0bGUpIHtcbiAgICBjb25zdCBhID0gbmV3IERhdGFWaWV3KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgbGV0IFMgPSBcIlwiO1xuICAgIGZvciAobGV0IGk9MDsgaTw0OyBpKyspIHtcbiAgICAgICAgaWYgKGk+MCkgUyArPSBcIlxcblwiO1xuICAgICAgICBTICs9IFwiXFx0XFx0XCI7XG4gICAgICAgIGZvciAobGV0IGo9MDsgajw0OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqPjApIFMgKz0gXCIgXCI7XG4gICAgICAgICAgICBTICs9IGEuZ2V0VWludDMyKGkqMTYraio0KS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aXRsZSkgUyA9IHRpdGxlICsgXCJcXG5cIiArIFM7XG4gICAgcmV0dXJuIFM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNoSXNFcXVhbChoMSwgaDIpIHtcbiAgICBpZiAoaDEuYnl0ZUxlbmd0aCAhPSBoMi5ieXRlTGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGR2MSA9IG5ldyBJbnQ4QXJyYXkoaDEpO1xuICAgIHZhciBkdjIgPSBuZXcgSW50OEFycmF5KGgyKTtcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgIT0gaDEuYnl0ZUxlbmd0aCA7IGkrKylcbiAgICB7XG4gICAgICAgIGlmIChkdjFbaV0gIT0gZHYyW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVIYXNoZXIoaCkge1xuICAgIHJldHVybiBoLmNsb25lKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUGFydGlhbEhhc2gocGFydGlhbCkge1xuICAgIC8vIE5PVEU6IHRoaXMgaXMgdW5zYWZlIGFuZCB1c2VzIGludGVybmFsIEFQSVxuICAgIGNvbnN0IGJ1ZiA9IHBhcnRpYWwuc3ViYXJyYXkoMCwgMTI4KTtcbiAgICBjb25zdCByZXN0ID0gdTMyKHBhcnRpYWwuc3ViYXJyYXkoMTI4KSk7XG4gICAgY29uc3QgcmVzID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgcmVzLmJ1ZmZlci5zZXQoYnVmKTtcbiAgICAocmVzLnYwbCA9IHJlc3RbMF0gfCAwKSwgKHJlcy52MGggPSByZXN0WzFdIHwgMCk7XG4gICAgKHJlcy52MWwgPSByZXN0WzJdIHwgMCksIChyZXMudjFoID0gcmVzdFszXSB8IDApO1xuICAgIChyZXMudjJsID0gcmVzdFs0XSB8IDApLCAocmVzLnYyaCA9IHJlc3RbNV0gfCAwKTtcbiAgICAocmVzLnYzbCA9IHJlc3RbNl0gfCAwKSwgKHJlcy52M2ggPSByZXN0WzddIHwgMCk7XG4gICAgKHJlcy52NGwgPSByZXN0WzhdIHwgMCksIChyZXMudjRoID0gcmVzdFs5XSB8IDApO1xuICAgIChyZXMudjVsID0gcmVzdFsxMF0gfCAwKSwgKHJlcy52NWggPSByZXN0WzExXSB8IDApO1xuICAgIChyZXMudjZsID0gcmVzdFsxMl0gfCAwKSwgKHJlcy52NmggPSByZXN0WzEzXSB8IDApO1xuICAgIChyZXMudjdsID0gcmVzdFsxNF0gfCAwKSwgKHJlcy52N2ggPSByZXN0WzE1XSB8IDApO1xuICAgIGNvbnN0IHNoaWZ0ID0gMiAqKiAzMjtcbiAgICBjb25zdCBsZW4gPSByZXN0WzE2XSArIHJlc3RbMTddICogc2hpZnQ7XG4gICAgY29uc3QgcG9zID0gcmVzdFsxOF0gKyByZXN0WzE5XSAqIHNoaWZ0O1xuICAgIHJlcy5sZW5ndGggPSBsZW4gKyBwb3M7XG4gICAgcmVzLnBvcyA9IHBvcztcbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9QYXJ0aWFsSGFzaChoYXNoKXtcbiAgICAvLyBOT1RFOiB0aGlzIGlzIHVuc2FmZSBhbmQgdXNlcyBpbnRlcm5hbCBBUElcbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheSgyMTYpO1xuICAgIGNvbnN0IHJlczMyID0gdTMyKHJlcy5zdWJhcnJheSgxMjgpKTtcbiAgICByZXMuc2V0KGhhc2guYnVmZmVyKTtcbiAgICAocmVzMzJbMF0gPSBoYXNoLnYwbCksIChyZXMzMlsxXSA9IGhhc2gudjBoKTtcbiAgICAocmVzMzJbMl0gPSBoYXNoLnYxbCksIChyZXMzMlszXSA9IGhhc2gudjFoKTtcbiAgICAocmVzMzJbNF0gPSBoYXNoLnYybCksIChyZXMzMls1XSA9IGhhc2gudjJoKTtcbiAgICAocmVzMzJbNl0gPSBoYXNoLnYzbCksIChyZXMzMls3XSA9IGhhc2gudjNoKTtcbiAgICAocmVzMzJbOF0gPSBoYXNoLnY0bCksIChyZXMzMls5XSA9IGhhc2gudjRoKTtcbiAgICAocmVzMzJbMTBdID0gaGFzaC52NWwpLCAocmVzMzJbMTFdID0gaGFzaC52NWgpO1xuICAgIChyZXMzMlsxMl0gPSBoYXNoLnY2bCksIChyZXMzMlsxM10gPSBoYXNoLnY2aCk7XG4gICAgKHJlczMyWzE0XSA9IGhhc2gudjdsKSwgKHJlczMyWzE1XSA9IGhhc2gudjdoKTtcbiAgICByZXMzMlsxOF0gPSBoYXNoLnBvcztcbiAgICByZXMzMlsxNl0gPSBoYXNoLmxlbmd0aC1oYXNoLnBvcztcbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2FtZVJhdGlvKGN1cnZlLCBnMXMsIGcxc3gsIGcycywgZzJzeCkge1xuICAgIGlmIChjdXJ2ZS5HMS5pc1plcm8oZzFzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjdXJ2ZS5HMS5pc1plcm8oZzFzeCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY3VydmUuRzIuaXNaZXJvKGcycykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY3VydmUuRzIuaXNaZXJvKGcyc3gpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGN1cnZlLkYxMi5lcShjdXJ2ZS5wYWlyaW5nKGcxcywgZzJzeCksIGN1cnZlLnBhaXJpbmcoZzFzeCwgZzJzKSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUucGFpcmluZ0VxKGcxcywgZzJzeCwgY3VydmUuRzEubmVnKGcxc3gpLCBnMnMpO1xuICAgIHJldHVybiByZXM7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFza0VudHJvcHkoKSB7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICAgICAgICByZXR1cm4gd2luZG93LnByb21wdChcIkVudGVyIGEgcmFuZG9tIHRleHQuIChFbnRyb3B5KTogXCIsIFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJsID0gcmVhZGxpbmUuY3JlYXRlSW50ZXJmYWNlKHtcbiAgICAgICAgICAgIGlucHV0OiBwcm9jZXNzLnN0ZGluLFxuICAgICAgICAgICAgb3V0cHV0OiBwcm9jZXNzLnN0ZG91dFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJsLnF1ZXN0aW9uKFwiRW50ZXIgYSByYW5kb20gdGV4dC4gKEVudHJvcHkpOiBcIiwgKGlucHV0KSA9PiByZXNvbHZlKGlucHV0KSApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhuKSB7XG4gICAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3NlcikgeyAvLyBTdXBwb3J0ZWRcbiAgICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICB9IGVsc2UgeyAvLyBOb2RlSlNcbiAgICAgICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2hhMjU2ZGlnZXN0KGRhdGEpIHtcbiAgICBpZiAocHJvY2Vzcy5icm93c2VyKSB7IC8vIFN1cHBvcnRlZFxuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTI1NlwiLCBkYXRhLmJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIH0gZWxzZSB7IC8vIE5vZGVKU1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVSW50MzJCRShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyKS5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSYW5kb21SbmcoZW50cm9weSkge1xuICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIFJuZ1xuICAgIHdoaWxlICghZW50cm9weSkge1xuICAgICAgICBlbnRyb3B5ID0gYXdhaXQgYXNrRW50cm9weSgpO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSg2NCk7XG4gICAgaGFzaGVyLnVwZGF0ZShnZXRSYW5kb21CeXRlcyg2NCkpO1xuICAgIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpOyAvLyBhbHdheXMgdXRmLThcbiAgICBoYXNoZXIudXBkYXRlKGVuYy5lbmNvZGUoZW50cm9weSkpO1xuICAgIGNvbnN0IGhhc2ggPSBoYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBjb25zdCBzZWVkID0gW107XG4gICAgZm9yIChsZXQgaT0wO2k8ODtpKyspIHtcbiAgICAgICAgc2VlZFtpXSA9IHJlYWRVSW50MzJCRShoYXNoLCBpKjQpO1xuICAgIH1cbiAgICBjb25zdCBybmcgPSBuZXcgQ2hhQ2hhKHNlZWQpO1xuICAgIHJldHVybiBybmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBybmdGcm9tQmVhY29uUGFyYW1zKGJlYWNvbkhhc2gsIG51bUl0ZXJhdGlvbnNFeHApIHtcbiAgICBsZXQgbkl0ZXJhdGlvbnNJbm5lcjtcbiAgICBsZXQgbkl0ZXJhdGlvbnNPdXRlcjtcbiAgICBpZiAobnVtSXRlcmF0aW9uc0V4cDwzMikge1xuICAgICAgICBuSXRlcmF0aW9uc0lubmVyID0gKDEgPDwgbnVtSXRlcmF0aW9uc0V4cCkgPj4+IDA7XG4gICAgICAgIG5JdGVyYXRpb25zT3V0ZXIgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5JdGVyYXRpb25zSW5uZXIgPSAweDEwMDAwMDAwMDtcbiAgICAgICAgbkl0ZXJhdGlvbnNPdXRlciA9ICgxIDw8IChudW1JdGVyYXRpb25zRXhwLTMyKSkgPj4+IDA7XG4gICAgfVxuXG4gICAgbGV0IGN1ckhhc2ggPSBiZWFjb25IYXNoO1xuICAgIGZvciAobGV0IGk9MDsgaTxuSXRlcmF0aW9uc091dGVyOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5JdGVyYXRpb25zSW5uZXI7IGorKykge1xuICAgICAgICAgICAgY3VySGFzaCA9IGF3YWl0IHNoYTI1NmRpZ2VzdChjdXJIYXNoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGN1ckhhc2hWID0gbmV3IERhdGFWaWV3KGN1ckhhc2guYnVmZmVyLCBjdXJIYXNoLmJ5dGVPZmZzZXQsIGN1ckhhc2guYnl0ZUxlbmd0aCk7XG4gICAgY29uc3Qgc2VlZCA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTw4OyBpKyspIHtcbiAgICAgICAgc2VlZFtpXSA9IGN1ckhhc2hWLmdldFVpbnQzMihpKjQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBybmcgPSBuZXcgQ2hhQ2hhKHNlZWQpO1xuXG4gICAgcmV0dXJuIHJuZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhleDJCeXRlQXJyYXkocykge1xuICAgIGlmIChzIGluc3RhbmNlb2YgVWludDhBcnJheSkgcmV0dXJuIHM7XG4gICAgaWYgKHMuc2xpY2UoMCwyKSA9PSBcIjB4XCIpIHM9IHMuc2xpY2UoMik7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHMubWF0Y2goL1tcXGRhLWZdezJ9L2dpKS5tYXAoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGgsIDE2KTtcbiAgICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBieXRlQXJyYXkyaGV4KGJ5dGVBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYnl0ZUFycmF5LCBmdW5jdGlvbihieXRlKSB7XG4gICAgICAgIHJldHVybiAoXCIwXCIgKyAoYnl0ZSAmIDB4RkYpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkKEZyLCBvKSB7XG4gICAgaWYgKG8gaW5zdGFuY2VvZiBVaW50OEFycmF5KSAge1xuICAgICAgICByZXR1cm4gRnIudG9TdHJpbmcobyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgICAgIHJldHVybiBvLm1hcChzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkLmJpbmQobnVsbCwgRnIpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKCAoaykgPT4ge1xuICAgICAgICAgICAgcmVzW2tdID0gc3RyaW5naWZ5QmlnSW50c1dpdGhGaWVsZChGciwgb1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZihvKSA9PSBcImJpZ2ludFwiKSB8fCBvLmVxICE9PSB1bmRlZmluZWQpICB7XG4gICAgICAgIHJldHVybiBvLnRvU3RyaW5nKDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/mpc_applykey.js":
/*!**************************************************!*\
  !*** ./node_modules/snarkjs/src/mpc_applykey.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyKeyToChallengeSection: () => (/* binding */ applyKeyToChallengeSection),\n/* harmony export */   applyKeyToSection: () => (/* binding */ applyKeyToSection)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n/*\n    This function creates a new section in the fdTo file with id idSection.\n    It multiplies the points in fdFrom by first, first*inc, first*inc^2, ....\n    nPoint Times.\n    It also updates the newChallengeHasher with the new points\n*/\n\nasync function applyKeyToSection(fdOld, sections, fdNew, idSection, curve, groupName, first, inc, sectionName, logger) {\n    const MAX_CHUNK_SIZE = 1 << 16;\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const nPoints = sections[idSection][0].size / sG;\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections,idSection );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, idSection);\n\n    let t = first;\n    for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`Applying key: ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints - i, MAX_CHUNK_SIZE);\n        let buff;\n        buff = await fdOld.read(n*sG);\n        buff = await G.batchApplyKey(buff, t, inc);\n        await fdNew.write(buff);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld);\n}\n\n\n\nasync function applyKeyToChallengeSection(fdOld, fdNew, responseHasher, curve, groupName, nPoints, first, inc, formatOut, sectionName, logger) {\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n    let t = first;\n    for (let i=0 ; i<nPoints ; i+= chunkSize) {\n        if (logger) logger.debug(`Applying key ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints-i, chunkSize );\n        const buffInU = await fdOld.read(n * sG);\n        const buffInLEM = await G.batchUtoLEM(buffInU);\n        const buffOutLEM = await G.batchApplyKey(buffInLEM, t, inc);\n        let buffOut;\n        if (formatOut == \"COMPRESSED\") {\n            buffOut = await G.batchLEMtoC(buffOutLEM);\n        } else {\n            buffOut = await G.batchLEMtoU(buffOutLEM);\n        }\n\n        if (responseHasher) responseHasher.update(buffOut);\n        await fdNew.write(buffOut);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbXBjX2FwcGx5a2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHVFQUFtQztBQUM3QyxVQUFVLGtFQUE4Qjs7QUFFeEM7QUFDQSxrQkFBa0IsV0FBVztBQUM3QixrREFBa0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0VBQTRCO0FBQ3RDLFVBQVUsK0RBQTJCO0FBQ3JDOzs7O0FBSU87QUFDUDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0IsaURBQWlELFlBQVksSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbXBjX2FwcGx5a2V5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuXG4vKlxuICAgIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIG5ldyBzZWN0aW9uIGluIHRoZSBmZFRvIGZpbGUgd2l0aCBpZCBpZFNlY3Rpb24uXG4gICAgSXQgbXVsdGlwbGllcyB0aGUgcG9pbnRzIGluIGZkRnJvbSBieSBmaXJzdCwgZmlyc3QqaW5jLCBmaXJzdCppbmNeMiwgLi4uLlxuICAgIG5Qb2ludCBUaW1lcy5cbiAgICBJdCBhbHNvIHVwZGF0ZXMgdGhlIG5ld0NoYWxsZW5nZUhhc2hlciB3aXRoIHRoZSBuZXcgcG9pbnRzXG4qL1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgaWRTZWN0aW9uLCBjdXJ2ZSwgZ3JvdXBOYW1lLCBmaXJzdCwgaW5jLCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxIDw8IDE2O1xuICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgY29uc3QgblBvaW50cyA9IHNlY3Rpb25zW2lkU2VjdGlvbl1bMF0uc2l6ZSAvIHNHO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLGlkU2VjdGlvbiApO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgaWRTZWN0aW9uKTtcblxuICAgIGxldCB0ID0gZmlyc3Q7XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBBcHBseWluZyBrZXk6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4oblBvaW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgIGJ1ZmYgPSBhd2FpdCBmZE9sZC5yZWFkKG4qc0cpO1xuICAgICAgICBidWZmID0gYXdhaXQgRy5iYXRjaEFwcGx5S2V5KGJ1ZmYsIHQsIGluYyk7XG4gICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuICAgICAgICB0ID0gY3VydmUuRnIubXVsKHQsIGN1cnZlLkZyLmV4cChpbmMsIG4pKTtcbiAgICB9XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmRPbGQpO1xufVxuXG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkT2xkLCBmZE5ldywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBncm91cE5hbWUsIG5Qb2ludHMsIGZpcnN0LCBpbmMsIGZvcm1hdE91dCwgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5mbG9vcigoMTw8MjApIC8gc0cpOyAgIC8vIDEyOE1iIGNodW5rc1xuICAgIGxldCB0ID0gZmlyc3Q7XG4gICAgZm9yIChsZXQgaT0wIDsgaTxuUG9pbnRzIDsgaSs9IGNodW5rU2l6ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEFwcGx5aW5nIGtleSAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgIGNvbnN0IG49IE1hdGgubWluKG5Qb2ludHMtaSwgY2h1bmtTaXplICk7XG4gICAgICAgIGNvbnN0IGJ1ZmZJblUgPSBhd2FpdCBmZE9sZC5yZWFkKG4gKiBzRyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZJbkxFTSA9IGF3YWl0IEcuYmF0Y2hVdG9MRU0oYnVmZkluVSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZPdXRMRU0gPSBhd2FpdCBHLmJhdGNoQXBwbHlLZXkoYnVmZkluTEVNLCB0LCBpbmMpO1xuICAgICAgICBsZXQgYnVmZk91dDtcbiAgICAgICAgaWYgKGZvcm1hdE91dCA9PSBcIkNPTVBSRVNTRURcIikge1xuICAgICAgICAgICAgYnVmZk91dCA9IGF3YWl0IEcuYmF0Y2hMRU10b0MoYnVmZk91dExFTSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gYXdhaXQgRy5iYXRjaExFTXRvVShidWZmT3V0TEVNKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwb25zZUhhc2hlcikgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGJ1ZmZPdXQpO1xuICAgICAgICBhd2FpdCBmZE5ldy53cml0ZShidWZmT3V0KTtcbiAgICAgICAgdCA9IGN1cnZlLkZyLm11bCh0LCBjdXJ2ZS5Gci5leHAoaW5jLCBuKSk7XG4gICAgfVxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/mpc_applykey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/mul_z.js":
/*!*******************************************!*\
  !*** ./node_modules/snarkjs/src/mul_z.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MulZ: () => (/* binding */ MulZ)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass MulZ {\n    static getZ1(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(-1), Fr.w[2]),\n            Fr.e(-2),\n            Fr.sub(Fr.e(-1), Fr.w[2]),\n        ];\n    }\n\n    static getZ2(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n            Fr.e(4),\n            Fr.sub(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n        ];\n    }\n\n    static getZ3(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n            Fr.e(-8),\n            Fr.sub(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n        ];\n\n    }\n\n    static mul2(a, b, ap, bp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = a_b;\n\n        let a0 = Fr.add(a_bp, ap_b);\n\n        let a1 = ap_bp;\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n        }\n\n        return [r, rz];\n    }\n\n    static mul3(a, b, c, ap, bp, cp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = Fr.mul(a_b, c);\n\n        let a0 = Fr.mul(ap_b, c);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp));\n\n        let a1 = Fr.mul(ap_bp, c);\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp));\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp));\n\n        rz = a0;\n        if (p) {\n            const a2 = Fr.mul(ap_bp, cp);\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n        }\n\n        return [r, rz];\n    }\n\n    static mul4(a, b, c, d, ap, bp, cp, dp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        const Z3 = this.getZ3(Fr);\n\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        const c_d = Fr.mul(c, d);\n        const c_dp = Fr.mul(c, dp);\n        const cp_d = Fr.mul(cp, d);\n        const cp_dp = Fr.mul(cp, dp);\n\n        r = Fr.mul(a_b, c_d);\n\n        let a0 = Fr.mul(ap_b, c_d);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, c_dp));\n\n        let a1 = Fr.mul(ap_bp, c_d);\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp_d));\n        a1 = Fr.add(a1, Fr.mul(ap_b, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp_d));\n        a1 = Fr.add(a1, Fr.mul(a_bp, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_b, cp_dp));\n\n        let a2 = Fr.mul(a_bp, cp_dp);\n        a2 = Fr.add(a2, Fr.mul(ap_b, cp_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, c_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, cp_d));\n\n        let a3 = Fr.mul(ap_bp, cp_dp);\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n            rz = Fr.add(rz, Fr.mul(Z3[p], a3));\n        }\n\n        return [r, rz];\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbXVsX3ouanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9tdWxfei5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgY2xhc3MgTXVsWiB7XG4gICAgc3RhdGljIGdldFoxKEZyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBGci56ZXJvLFxuICAgICAgICAgICAgRnIuYWRkKEZyLmUoLTEpLCBGci53WzJdKSxcbiAgICAgICAgICAgIEZyLmUoLTIpLFxuICAgICAgICAgICAgRnIuc3ViKEZyLmUoLTEpLCBGci53WzJdKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0WjIoRnIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEZyLnplcm8sXG4gICAgICAgICAgICBGci5hZGQoRnIuemVybywgRnIubXVsKEZyLmUoLTIpLCBGci53WzJdKSksXG4gICAgICAgICAgICBGci5lKDQpLFxuICAgICAgICAgICAgRnIuc3ViKEZyLnplcm8sIEZyLm11bChGci5lKC0yKSwgRnIud1syXSkpLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRaMyhGcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgRnIuemVybyxcbiAgICAgICAgICAgIEZyLmFkZChGci5lKDIpLCBGci5tdWwoRnIuZSgyKSwgRnIud1syXSkpLFxuICAgICAgICAgICAgRnIuZSgtOCksXG4gICAgICAgICAgICBGci5zdWIoRnIuZSgyKSwgRnIubXVsKEZyLmUoMiksIEZyLndbMl0pKSxcbiAgICAgICAgXTtcblxuICAgIH1cblxuICAgIHN0YXRpYyBtdWwyKGEsIGIsIGFwLCBicCwgcCwgRnIpIHtcbiAgICAgICAgY29uc3QgWjEgPSB0aGlzLmdldFoxKEZyKTtcbiAgICAgICAgbGV0IHIsIHJ6O1xuXG4gICAgICAgIGNvbnN0IGFfYiA9IEZyLm11bChhLCBiKTtcbiAgICAgICAgY29uc3QgYV9icCA9IEZyLm11bChhLCBicCk7XG4gICAgICAgIGNvbnN0IGFwX2IgPSBGci5tdWwoYXAsIGIpO1xuICAgICAgICBjb25zdCBhcF9icCA9IEZyLm11bChhcCwgYnApO1xuXG4gICAgICAgIHIgPSBhX2I7XG5cbiAgICAgICAgbGV0IGEwID0gRnIuYWRkKGFfYnAsIGFwX2IpO1xuXG4gICAgICAgIGxldCBhMSA9IGFwX2JwO1xuXG4gICAgICAgIHJ6ID0gYTA7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICByeiA9IEZyLmFkZChyeiwgRnIubXVsKFoxW3BdLCBhMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtyLCByel07XG4gICAgfVxuXG4gICAgc3RhdGljIG11bDMoYSwgYiwgYywgYXAsIGJwLCBjcCwgcCwgRnIpIHtcbiAgICAgICAgY29uc3QgWjEgPSB0aGlzLmdldFoxKEZyKTtcbiAgICAgICAgY29uc3QgWjIgPSB0aGlzLmdldFoyKEZyKTtcbiAgICAgICAgbGV0IHIsIHJ6O1xuXG4gICAgICAgIGNvbnN0IGFfYiA9IEZyLm11bChhLCBiKTtcbiAgICAgICAgY29uc3QgYV9icCA9IEZyLm11bChhLCBicCk7XG4gICAgICAgIGNvbnN0IGFwX2IgPSBGci5tdWwoYXAsIGIpO1xuICAgICAgICBjb25zdCBhcF9icCA9IEZyLm11bChhcCwgYnApO1xuXG4gICAgICAgIHIgPSBGci5tdWwoYV9iLCBjKTtcblxuICAgICAgICBsZXQgYTAgPSBGci5tdWwoYXBfYiwgYyk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9icCwgYykpO1xuICAgICAgICBhMCA9IEZyLmFkZChhMCwgRnIubXVsKGFfYiwgY3ApKTtcblxuICAgICAgICBsZXQgYTEgPSBGci5tdWwoYXBfYnAsIGMpO1xuICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFfYnAsIGNwKSk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYXBfYiwgY3ApKTtcblxuICAgICAgICByeiA9IGEwO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgY29uc3QgYTIgPSBGci5tdWwoYXBfYnAsIGNwKTtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjFbcF0sIGExKSk7XG4gICAgICAgICAgICByeiA9IEZyLmFkZChyeiwgRnIubXVsKFoyW3BdLCBhMikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtyLCByel07XG4gICAgfVxuXG4gICAgc3RhdGljIG11bDQoYSwgYiwgYywgZCwgYXAsIGJwLCBjcCwgZHAsIHAsIEZyKSB7XG4gICAgICAgIGNvbnN0IFoxID0gdGhpcy5nZXRaMShGcik7XG4gICAgICAgIGNvbnN0IFoyID0gdGhpcy5nZXRaMihGcik7XG4gICAgICAgIGNvbnN0IFozID0gdGhpcy5nZXRaMyhGcik7XG5cbiAgICAgICAgbGV0IHIsIHJ6O1xuXG4gICAgICAgIGNvbnN0IGFfYiA9IEZyLm11bChhLCBiKTtcbiAgICAgICAgY29uc3QgYV9icCA9IEZyLm11bChhLCBicCk7XG4gICAgICAgIGNvbnN0IGFwX2IgPSBGci5tdWwoYXAsIGIpO1xuICAgICAgICBjb25zdCBhcF9icCA9IEZyLm11bChhcCwgYnApO1xuXG4gICAgICAgIGNvbnN0IGNfZCA9IEZyLm11bChjLCBkKTtcbiAgICAgICAgY29uc3QgY19kcCA9IEZyLm11bChjLCBkcCk7XG4gICAgICAgIGNvbnN0IGNwX2QgPSBGci5tdWwoY3AsIGQpO1xuICAgICAgICBjb25zdCBjcF9kcCA9IEZyLm11bChjcCwgZHApO1xuXG4gICAgICAgIHIgPSBGci5tdWwoYV9iLCBjX2QpO1xuXG4gICAgICAgIGxldCBhMCA9IEZyLm11bChhcF9iLCBjX2QpO1xuICAgICAgICBhMCA9IEZyLmFkZChhMCwgRnIubXVsKGFfYnAsIGNfZCkpO1xuICAgICAgICBhMCA9IEZyLmFkZChhMCwgRnIubXVsKGFfYiwgY3BfZCkpO1xuICAgICAgICBhMCA9IEZyLmFkZChhMCwgRnIubXVsKGFfYiwgY19kcCkpO1xuXG4gICAgICAgIGxldCBhMSA9IEZyLm11bChhcF9icCwgY19kKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhcF9iLCBjcF9kKSk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYXBfYiwgY19kcCkpO1xuICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFfYnAsIGNwX2QpKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhX2JwLCBjX2RwKSk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYV9iLCBjcF9kcCkpO1xuXG4gICAgICAgIGxldCBhMiA9IEZyLm11bChhX2JwLCBjcF9kcCk7XG4gICAgICAgIGEyID0gRnIuYWRkKGEyLCBGci5tdWwoYXBfYiwgY3BfZHApKTtcbiAgICAgICAgYTIgPSBGci5hZGQoYTIsIEZyLm11bChhcF9icCwgY19kcCkpO1xuICAgICAgICBhMiA9IEZyLmFkZChhMiwgRnIubXVsKGFwX2JwLCBjcF9kKSk7XG5cbiAgICAgICAgbGV0IGEzID0gRnIubXVsKGFwX2JwLCBjcF9kcCk7XG5cbiAgICAgICAgcnogPSBhMDtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjFbcF0sIGExKSk7XG4gICAgICAgICAgICByeiA9IEZyLmFkZChyeiwgRnIubXVsKFoyW3BdLCBhMikpO1xuICAgICAgICAgICAgcnogPSBGci5hZGQocnosIEZyLm11bChaM1twXSwgYTMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbciwgcnpdO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/mul_z.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/plonk.js":
/*!*******************************************!*\
  !*** ./node_modules/snarkjs/src/plonk.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _plonk_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _plonk_fullprove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _plonk_prove_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   setup: () => (/* reexport safe */ _plonk_setup_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _plonk_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _plonk_setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plonk_setup.js */ \"(ssr)/./node_modules/snarkjs/src/plonk_setup.js\");\n/* harmony import */ var _plonk_fullprove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plonk_fullprove.js */ \"(ssr)/./node_modules/snarkjs/src/plonk_fullprove.js\");\n/* harmony import */ var _plonk_prove_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plonk_prove.js */ \"(ssr)/./node_modules/snarkjs/src/plonk_prove.js\");\n/* harmony import */ var _plonk_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plonk_verify.js */ \"(ssr)/./node_modules/snarkjs/src/plonk_verify.js\");\n/* harmony import */ var _plonk_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plonk_exportsoliditycalldata.js */ \"(ssr)/./node_modules/snarkjs/src/plonk_exportsoliditycalldata.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// ZKEY constants\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDa0Q7QUFDUTtBQUNSO0FBQ0U7QUFDZ0MiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLy8gWktFWSBjb25zdGFudHNcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzZXR1cH0gZnJvbSBcIi4vcGxvbmtfc2V0dXAuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBmdWxsUHJvdmV9IGZyb20gXCIuL3Bsb25rX2Z1bGxwcm92ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHByb3ZlfSBmcm9tIFwiLi9wbG9ua19wcm92ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZlcmlmeX0gZnJvbSBcIi4vcGxvbmtfdmVyaWZ5LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0U29saWRpdHlDYWxsRGF0YX0gZnJvbSBcIi4vcGxvbmtfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/plonk.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/plonk_constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZKEY_PL_ADDITIONS_SECTION: () => (/* binding */ ZKEY_PL_ADDITIONS_SECTION),\n/* harmony export */   ZKEY_PL_A_MAP_SECTION: () => (/* binding */ ZKEY_PL_A_MAP_SECTION),\n/* harmony export */   ZKEY_PL_B_MAP_SECTION: () => (/* binding */ ZKEY_PL_B_MAP_SECTION),\n/* harmony export */   ZKEY_PL_C_MAP_SECTION: () => (/* binding */ ZKEY_PL_C_MAP_SECTION),\n/* harmony export */   ZKEY_PL_HEADER_SECTION: () => (/* binding */ ZKEY_PL_HEADER_SECTION),\n/* harmony export */   ZKEY_PL_LAGRANGE_SECTION: () => (/* binding */ ZKEY_PL_LAGRANGE_SECTION),\n/* harmony export */   ZKEY_PL_NSECTIONS: () => (/* binding */ ZKEY_PL_NSECTIONS),\n/* harmony export */   ZKEY_PL_PTAU_SECTION: () => (/* binding */ ZKEY_PL_PTAU_SECTION),\n/* harmony export */   ZKEY_PL_QC_SECTION: () => (/* binding */ ZKEY_PL_QC_SECTION),\n/* harmony export */   ZKEY_PL_QL_SECTION: () => (/* binding */ ZKEY_PL_QL_SECTION),\n/* harmony export */   ZKEY_PL_QM_SECTION: () => (/* binding */ ZKEY_PL_QM_SECTION),\n/* harmony export */   ZKEY_PL_QO_SECTION: () => (/* binding */ ZKEY_PL_QO_SECTION),\n/* harmony export */   ZKEY_PL_QR_SECTION: () => (/* binding */ ZKEY_PL_QR_SECTION),\n/* harmony export */   ZKEY_PL_SIGMA_SECTION: () => (/* binding */ ZKEY_PL_SIGMA_SECTION)\n/* harmony export */ });\nconst ZKEY_PL_NSECTIONS = 13;\n\nconst ZKEY_PL_HEADER_SECTION = 2;\nconst ZKEY_PL_ADDITIONS_SECTION = 3;\nconst ZKEY_PL_A_MAP_SECTION = 4;\nconst ZKEY_PL_B_MAP_SECTION = 5;\nconst ZKEY_PL_C_MAP_SECTION = 6;\nconst ZKEY_PL_QM_SECTION = 7;\nconst ZKEY_PL_QL_SECTION = 8;\nconst ZKEY_PL_QR_SECTION = 9;\nconst ZKEY_PL_QO_SECTION = 10;\nconst ZKEY_PL_QC_SECTION = 11;\nconst ZKEY_PL_SIGMA_SECTION = 12;\nconst ZKEY_PL_LAGRANGE_SECTION = 13;\nconst ZKEY_PL_PTAU_SECTION = 14;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU87O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBaS0VZX1BMX05TRUNUSU9OUyA9IDEzO1xuXG5leHBvcnQgY29uc3QgWktFWV9QTF9IRUFERVJfU0VDVElPTiA9IDI7XG5leHBvcnQgY29uc3QgWktFWV9QTF9BRERJVElPTlNfU0VDVElPTiA9IDM7XG5leHBvcnQgY29uc3QgWktFWV9QTF9BX01BUF9TRUNUSU9OID0gNDtcbmV4cG9ydCBjb25zdCBaS0VZX1BMX0JfTUFQX1NFQ1RJT04gPSA1O1xuZXhwb3J0IGNvbnN0IFpLRVlfUExfQ19NQVBfU0VDVElPTiA9IDY7XG5leHBvcnQgY29uc3QgWktFWV9QTF9RTV9TRUNUSU9OID0gNztcbmV4cG9ydCBjb25zdCBaS0VZX1BMX1FMX1NFQ1RJT04gPSA4O1xuZXhwb3J0IGNvbnN0IFpLRVlfUExfUVJfU0VDVElPTiA9IDk7XG5leHBvcnQgY29uc3QgWktFWV9QTF9RT19TRUNUSU9OID0gMTA7XG5leHBvcnQgY29uc3QgWktFWV9QTF9RQ19TRUNUSU9OID0gMTE7XG5leHBvcnQgY29uc3QgWktFWV9QTF9TSUdNQV9TRUNUSU9OID0gMTI7XG5leHBvcnQgY29uc3QgWktFWV9QTF9MQUdSQU5HRV9TRUNUSU9OID0gMTM7XG5leHBvcnQgY29uc3QgWktFWV9QTF9QVEFVX1NFQ1RJT04gPSAxNDtcblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/plonk_constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/plonk_equation.js":
/*!****************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_equation.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFFlonkAdditionConstraint: () => (/* binding */ getFFlonkAdditionConstraint),\n/* harmony export */   getFFlonkConstantConstraint: () => (/* binding */ getFFlonkConstantConstraint),\n/* harmony export */   getFFlonkMultiplicationConstraint: () => (/* binding */ getFFlonkMultiplicationConstraint)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// We export to zkey the signals and values of the a, b, c, ql, qr, qm, qo and qc\n\n// a, b and c are signals id (32-bit integers)\n// ql, qr, qm, qo and qc are field values\n\nfunction getFFlonkConstantConstraint(signal1, Fr) {\n    return [signal1, 0, 0, Fr.one, Fr.zero, Fr.zero, Fr.zero, Fr.zero];\n}\n\nfunction getFFlonkAdditionConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n\nfunction getFFlonkMultiplicationConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc, Fr) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZXF1YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX2VxdWF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIFdlIGV4cG9ydCB0byB6a2V5IHRoZSBzaWduYWxzIGFuZCB2YWx1ZXMgb2YgdGhlIGEsIGIsIGMsIHFsLCBxciwgcW0sIHFvIGFuZCBxY1xuXG4vLyBhLCBiIGFuZCBjIGFyZSBzaWduYWxzIGlkICgzMi1iaXQgaW50ZWdlcnMpXG4vLyBxbCwgcXIsIHFtLCBxbyBhbmQgcWMgYXJlIGZpZWxkIHZhbHVlc1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RkZsb25rQ29uc3RhbnRDb25zdHJhaW50KHNpZ25hbDEsIEZyKSB7XG4gICAgcmV0dXJuIFtzaWduYWwxLCAwLCAwLCBGci5vbmUsIEZyLnplcm8sIEZyLnplcm8sIEZyLnplcm8sIEZyLnplcm9dO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RkZsb25rQWRkaXRpb25Db25zdHJhaW50KHNpZ25hbDEsIHNpZ25hbDIsIHNpZ25hbE91dCwgcWwsIHFyLCBxbSwgcW8sIHFjKSB7XG4gICAgcmV0dXJuIFtzaWduYWwxLCBzaWduYWwyLCBzaWduYWxPdXQsIHFsLCBxciwgcW0sIHFvLCBxY107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGRmxvbmtNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoc2lnbmFsMSwgc2lnbmFsMiwgc2lnbmFsT3V0LCBxbCwgcXIsIHFtLCBxbywgcWMsIEZyKSB7XG4gICAgcmV0dXJuIFtzaWduYWwxLCBzaWduYWwyLCBzaWduYWxPdXQsIHFsLCBxciwgcW0sIHFvLCBxY107XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/plonk_equation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/plonk_exportsoliditycalldata.js":
/*!******************************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_exportsoliditycalldata.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkExportSolidityCallData)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function plonkExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName)(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.A[0])}, ${p256(proof.A[1])},` +\n    `${p256(proof.B[0])},${p256(proof.B[1])},` +\n    `${p256(proof.C[0])},${p256(proof.C[1])},` +\n    `${p256(proof.Z[0])},${p256(proof.Z[1])},` +\n    `${p256(proof.T1[0])},${p256(proof.T1[1])},` +\n    `${p256(proof.T2[0])},${p256(proof.T2[1])},` +\n    `${p256(proof.T3[0])},${p256(proof.T3[1])},` +\n    `${p256(proof.Wxi[0])},${p256(proof.Wxi[1])},` +\n    `${p256(proof.Wxiw[0])},${p256(proof.Wxiw[1])},` +\n    `${p256(proof.eval_a)},` + \n    `${p256(proof.eval_b)},` + \n    `${p256(proof.eval_c)},` + \n    `${p256(proof.eval_s1)},` + \n    `${p256(proof.eval_s2)},` + \n    `${p256(proof.eval_zw)}]` + \n    `[${inputs}]`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUrQztBQUNQO0FBQ3hDLFFBQVEsb0JBQW9CLEVBQUUsK0NBQUs7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBOztBQUVlO0FBQ2Y7QUFDQTs7QUFFQSx3QkFBd0IsNERBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7O0FBRUEsZUFBZSxpQkFBaUIsSUFBSSxpQkFBaUI7QUFDckQsT0FBTyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDNUMsT0FBTyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDNUMsT0FBTyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDNUMsT0FBTyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDOUMsT0FBTyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDOUMsT0FBTyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDOUMsT0FBTyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDaEQsT0FBTyxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDbEQsT0FBTyxtQkFBbUI7QUFDMUIsT0FBTyxtQkFBbUI7QUFDMUIsT0FBTyxtQkFBbUI7QUFDMUIsT0FBTyxvQkFBb0I7QUFDM0IsT0FBTyxvQkFBb0I7QUFDM0IsT0FBTyxvQkFBb0I7QUFDM0IsUUFBUSxPQUFPO0FBQ2YiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21OYW1lIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgeyAgdXRpbHMgfSAgIGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHsgdW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5mdW5jdGlvbiBpMmhleChpKSB7XG4gICAgcmV0dXJuIChcIjBcIiArIGkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG59XG5cbmZ1bmN0aW9uIHAyNTYobikge1xuICAgIGxldCBuc3RyID0gbi50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKG5zdHIubGVuZ3RoIDwgNjQpIG5zdHIgPSBcIjBcIituc3RyO1xuICAgIG5zdHIgPSBgXCIweCR7bnN0cn1cImA7XG4gICAgcmV0dXJuIG5zdHI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBsb25rRXhwb3J0U29saWRpdHlDYWxsRGF0YShfcHJvb2YsIF9wdWIpIHtcbiAgICBjb25zdCBwcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpO1xuICAgIGNvbnN0IHB1YiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHViKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tTmFtZShwcm9vZi5jdXJ2ZSk7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IGlucHV0cyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaT0wOyBpPHB1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRzICE9IFwiXCIpIGlucHV0cyA9IGlucHV0cyArIFwiLFwiO1xuICAgICAgICBpbnB1dHMgPSBpbnB1dHMgKyBwMjU2KHB1YltpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBbJHtwMjU2KHByb29mLkFbMF0pfSwgJHtwMjU2KHByb29mLkFbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLkJbMF0pfSwke3AyNTYocHJvb2YuQlsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuQ1swXSl9LCR7cDI1Nihwcm9vZi5DWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5aWzBdKX0sJHtwMjU2KHByb29mLlpbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLlQxWzBdKX0sJHtwMjU2KHByb29mLlQxWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5UMlswXSl9LCR7cDI1Nihwcm9vZi5UMlsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuVDNbMF0pfSwke3AyNTYocHJvb2YuVDNbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLld4aVswXSl9LCR7cDI1Nihwcm9vZi5XeGlbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLld4aXdbMF0pfSwke3AyNTYocHJvb2YuV3hpd1sxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuZXZhbF9hKX0sYCArIFxuICAgIGAke3AyNTYocHJvb2YuZXZhbF9iKX0sYCArIFxuICAgIGAke3AyNTYocHJvb2YuZXZhbF9jKX0sYCArIFxuICAgIGAke3AyNTYocHJvb2YuZXZhbF9zMSl9LGAgKyBcbiAgICBgJHtwMjU2KHByb29mLmV2YWxfczIpfSxgICsgXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsX3p3KX1dYCArIFxuICAgIGBbJHtpbnB1dHN9XWA7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/plonk_exportsoliditycalldata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/plonk_fullprove.js":
/*!*****************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_fullprove.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkFullProve)\n/* harmony export */ });\n/* harmony import */ var _plonk_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plonk_prove.js */ \"(ssr)/./node_modules/snarkjs/src/plonk_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function plonkFullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFile, wtns, wtnsCalcOptions);\n    return await (0,_plonk_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFileName, wtns, logger, proverOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZnVsbHByb3ZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUyQztBQUNNO0FBQ2Q7QUFDbkMsT0FBTyxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFbkI7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhEQUFjO0FBQ3hCLGlCQUFpQiwyREFBVztBQUM1QiIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wbG9ua19mdWxscHJvdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHBsb25rX3Byb3ZlIGZyb20gXCIuL3Bsb25rX3Byb3ZlLmpzXCI7XG5pbXBvcnQgd3Ruc19jYWxjdWxhdGUgZnJvbSBcIi4vd3Ruc19jYWxjdWxhdGUuanNcIjtcbmltcG9ydCB7dXRpbHN9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHt1bnN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBsb25rRnVsbFByb3ZlKF9pbnB1dCwgd2FzbUZpbGUsIHprZXlGaWxlTmFtZSwgbG9nZ2VyLCB3dG5zQ2FsY09wdGlvbnMsIHByb3Zlck9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyhfaW5wdXQpO1xuXG4gICAgY29uc3Qgd3Rucz0ge1xuICAgICAgICB0eXBlOiBcIm1lbVwiXG4gICAgfTtcbiAgICBhd2FpdCB3dG5zX2NhbGN1bGF0ZShpbnB1dCwgd2FzbUZpbGUsIHd0bnMsIHd0bnNDYWxjT3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHBsb25rX3Byb3ZlKHprZXlGaWxlTmFtZSwgd3RucywgbG9nZ2VyLCBwcm92ZXJPcHRpb25zKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/plonk_fullprove.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/plonk_prove.js":
/*!*************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_prove.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonk16Prove)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proof.js */ \"(ssr)/./node_modules/snarkjs/src/proof.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(ssr)/./node_modules/snarkjs/src/Keccak256Transcript.js\");\n/* harmony import */ var _mul_z_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mul_z.js */ \"(ssr)/./node_modules/snarkjs/src/mul_z.js\");\n/* harmony import */ var _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plonk_constants.js */ \"(ssr)/./node_modules/snarkjs/src/plonk_constants.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(ssr)/./node_modules/snarkjs/src/polynomial/polynomial.js\");\n/* harmony import */ var _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./polynomial/evaluations.js */ \"(ssr)/./node_modules/snarkjs/src/polynomial/evaluations.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf section 8.4 */\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_3__.utils;\n\n\n\n\n\n\n    \nasync function plonk16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    // Read witness file\n    if (logger) logger.debug(\"> Reading witness file\");\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, sectionsWtns);\n\n    // Read zkey file\n    if (logger) logger.debug(\"> Reading zkey file\");\n    const {fd: fdZKey, sections: zkeySections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, zkeySections, undefined, options);\n    if (zkey.protocol != \"plonk\") {\n        throw new Error(\"zkey file is not plonk\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars -zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n    const sDomain = zkey.domainSize * n8r;\n\n    if (logger) {\n        logger.debug(\"----------------------------\");\n        logger.debug(\"  PLONK PROVE SETTINGS\");\n        logger.debug(`  Curve:         ${curve.name}`);\n        logger.debug(`  Circuit power: ${zkey.power}`);\n        logger.debug(`  Domain size:   ${zkey.domainSize}`);\n        logger.debug(`  Vars:          ${zkey.nVars}`);\n        logger.debug(`  Public vars:   ${zkey.nPublic}`);\n        logger.debug(`  Constraints:   ${zkey.nConstraints}`);\n        logger.debug(`  Additions:     ${zkey.nAdditions}`);\n        logger.debug(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.debug(\"> Reading witness file data\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, sectionsWtns, 2);\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(n8r*zkey.nAdditions);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    let challenges = {};\n    let proof = new _proof_js__WEBPACK_IMPORTED_MODULE_4__.Proof(curve, logger);\n    const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_5__.Keccak256Transcript(curve);\n\n    if (logger) logger.debug(`> Reading Section ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.debug(`> Reading Section ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.debug(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 5 * sDomain);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 10 * sDomain);\n\n    if (logger) logger.debug(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 6 * sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 11 * sDomain);\n\n    if (logger) logger.debug(`> Reading Section ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_PTAU_SECTION}. Powers of Tau`);\n    const PTau = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_PTAU_SECTION);\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const pub = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.debug(\"\");\n    if (logger) logger.debug(\"> ROUND 1\");\n    await round1();\n\n    if (logger) logger.debug(\"> ROUND 2\");\n    await round2();\n\n    if (logger) logger.debug(\"> ROUND 3\");\n    await round3();\n\n    if (logger) logger.debug(\"> ROUND 4\");\n    await round4();\n\n    if (logger) logger.debug(\"> ROUND 5\");\n    await round5();\n\n    ///////////////////////\n    // Final adjustments //\n    ///////////////////////\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    // Prepare proof\n    let _proof = proof.toObjectProof(false);\n    _proof.protocol = \"plonk\";\n    _proof.curve = curve.name;\n    \n    if (logger) logger.debug(\"PLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.debug(\" Computing additions\");\n        const additionsBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + n8r * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.debug(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + n8r);\n            offset += n8r;\n            const factor2 = additionsBuff.slice(offset, offset + n8r);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, n8r * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o+4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        if (idx < zkey.nVars-zkey.nAdditions) {\n            return buffWitness.slice(idx*n8r, idx*n8r+n8r);\n        } else if (idx < zkey.nVars) {\n            return buffInternalWitness.slice((idx - (zkey.nVars-zkey.nAdditions))*n8r, (idx-(zkey.nVars-zkey.nAdditions))*n8r + n8r);\n        } else {\n            return curve.Fr.zero;\n        }\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b1, ..., b11)  F\n        challenges.b = [];\n        for (let i=1; i<=11; i++) {\n            challenges.b[i] = curve.Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.debug(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute [a]_1, [b]_1, [c]_1\n        if (logger) logger.debug(\"> Computing A, B, C MSM\");\n        let commitA = await polynomials.A.multiExponentiation(PTau, \"A\");\n        let commitB = await polynomials.B.multiExponentiation(PTau, \"B\");\n        let commitC = await polynomials.C.multiExponentiation(PTau, \"C\");\n\n        // First output of the prover is ([A]_1, [B]_1, [C]_1)\n        proof.addPolynomial(\"A\", commitA);\n        proof.addPolynomial(\"B\", commitB);\n        proof.addPolynomial(\"C\", commitC);\n\n        return 0;\n    }\n\n    async function computeWirePolynomials() {\n        if (logger) logger.debug(\" Reading data from zkey file\");\n\n        // Build A, B and C evaluations buffer from zkey and witness files\n        buffers.A = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n        buffers.B = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n        buffers.C = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n        // Read zkey file to the buffers\n        const aMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_A_MAP_SECTION);\n        const bMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_B_MAP_SECTION);\n        const cMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_C_MAP_SECTION);\n\n        // Compute all witness from signal ids and set them to A,B & C buffers\n        for (let i = 0; i < zkey.nConstraints; i++) {\n            const i_sFr = i * n8r;\n            const offset = i * 4;\n\n            // Compute A value from a signal id\n            const signalIdA = readUInt32(aMapBuff, offset);\n            buffers.A.set(getWitness(signalIdA), i_sFr);\n\n            // Compute B value from a signal id\n            const signalIdB = readUInt32(bMapBuff, offset);\n            buffers.B.set(getWitness(signalIdB), i_sFr);\n\n            // Compute C value from a signal id\n            const signalIdC = readUInt32(cMapBuff, offset);\n            buffers.C.set(getWitness(signalIdC), i_sFr);\n        }\n\n        buffers.A = await Fr.batchToMontgomery(buffers.A);\n        buffers.B = await Fr.batchToMontgomery(buffers.B);\n        buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n        // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n        if (logger) logger.debug(\" Computing A ifft\");\n        polynomials.A = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.A, curve, logger);\n        if (logger) logger.debug(\" Computing B ifft\");\n        polynomials.B = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.B, curve, logger);\n        if (logger) logger.debug(\" Computing C ifft\");\n        polynomials.C = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n        // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n        if (logger) logger.debug(\" Computing A fft\");\n        evaluations.A = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n        if (logger) logger.debug(\" Computing B fft\");\n        evaluations.B = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n        if (logger) logger.debug(\" Computing C fft\");\n        evaluations.C = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n        // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n        polynomials.A.blindCoefficients([challenges.b[2], challenges.b[1]]);\n        polynomials.B.blindCoefficients([challenges.b[4], challenges.b[3]]);\n        polynomials.C.blindCoefficients([challenges.b[6], challenges.b[5]]);\n\n        // Check degrees\n        if (polynomials.A.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"A Polynomial is not well calculated\");\n        }\n        if (polynomials.B.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"B Polynomial is not well calculated\");\n        }\n        if (polynomials.C.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"C Polynomial is not well calculated\");\n        }        \n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.debug(\"> Computing challenges beta and gamma\");\n        transcript.reset();\n\n        transcript.addPolCommitment(zkey.Qm);\n        transcript.addPolCommitment(zkey.Ql);\n        transcript.addPolCommitment(zkey.Qr);\n        transcript.addPolCommitment(zkey.Qo);\n        transcript.addPolCommitment(zkey.Qc);\n        transcript.addPolCommitment(zkey.S1);\n        transcript.addPolCommitment(zkey.S2);\n        transcript.addPolCommitment(zkey.S3);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * n8r, i * n8r + n8r));\n        }\n\n        // Add A, B, C to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"A\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"B\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"C\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.beta: \" + Fr.toString(challenges.beta, 16));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.gamma: \" + Fr.toString(challenges.gamma, 16));\n    \n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.debug(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute permutation [z]_1\n        if (logger) logger.debug(\"> Computing Z MSM\");\n        let commitZ = await polynomials.Z.multiExponentiation(PTau, \"Z\");\n\n        // Second output of the prover is ([Z]_1)\n        proof.addPolynomial(\"Z\", commitZ);\n    }\n\n    async function computeZ() {\n        if (logger) logger.debug(\" Computing Z evaluations\");\n\n        let numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n        let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n        // Set the first values to 1\n        numArr.set(Fr.one, 0);\n        denArr.set(Fr.one, 0);\n\n        // Set initial omega\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_n8r = i * n8r;\n            \n            const a = buffers.A.slice(i_n8r, i_n8r + n8r);\n            const b = buffers.B.slice(i_n8r, i_n8r + n8r);\n            const c = buffers.C.slice(i_n8r, i_n8r + n8r);\n\n            // Z(X) := numArr / denArr\n            // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n            const betaw = Fr.mul(challenges.beta, w);\n\n            let n1 = Fr.add(a, betaw);\n            n1 = Fr.add(n1, challenges.gamma);\n\n            let n2 = Fr.add(b, Fr.mul(zkey.k1, betaw));\n            n2 = Fr.add(n2, challenges.gamma);\n\n            let n3 = Fr.add(c, Fr.mul(zkey.k2, betaw));\n            n3 = Fr.add(n3, challenges.gamma);\n\n            let num = Fr.mul(n1, Fr.mul(n2, n3));\n\n            // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n            let d1 = Fr.add(a, Fr.mul(evaluations.Sigma1.getEvaluation(i * 4), challenges.beta));\n            d1 = Fr.add(d1, challenges.gamma);\n\n            let d2 = Fr.add(b, Fr.mul(evaluations.Sigma2.getEvaluation(i * 4), challenges.beta));\n            d2 = Fr.add(d2, challenges.gamma);\n\n            let d3 = Fr.add(c, Fr.mul(evaluations.Sigma3.getEvaluation(i * 4), challenges.beta));\n            d3 = Fr.add(d3, challenges.gamma);\n\n            let den = Fr.mul(d1, Fr.mul(d2, d3));\n\n            // Multiply current num value with the previous one saved in numArr\n            num = Fr.mul(numArr.slice(i_n8r, i_n8r + n8r), num);\n            numArr.set(num, ((i + 1) % zkey.domainSize) * n8r);\n\n            // Multiply current den value with the previous one saved in denArr\n            den = Fr.mul(denArr.slice(i_n8r, i_n8r + n8r), den);\n            denArr.set(den, ((i + 1) % zkey.domainSize) * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        // Compute the inverse of denArr to compute in the next command the\n        // division numArr/denArr by multiplying num  1/denArr\n        denArr = await Fr.batchInverse(denArr);\n\n        // TODO: Do it in assembly and in parallel\n        // Multiply numArr  denArr where denArr was inverted in the previous command\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_sFr = i * n8r;\n\n            const z = Fr.mul(numArr.slice(i_sFr, i_sFr + n8r), denArr.slice(i_sFr, i_sFr + n8r));\n            numArr.set(z, i_sFr);\n        }\n\n        // From now on the values saved on numArr will be Z(X) buffer\n        buffers.Z = numArr;\n\n        if (!Fr.eq(numArr.slice(0, n8r), Fr.one)) {\n            throw new Error(\"Copy constraints does not match\");\n        }\n\n        // Compute polynomial coefficients z(X) from buffers.Z\n        if (logger) logger.debug(\" Computing Z ifft\");\n        polynomials.Z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n        // Compute extended evaluations of z(X) polynomial\n        if (logger) logger.debug(\" Computing Z fft\");\n        evaluations.Z = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n        // Blind z(X) polynomial coefficients with blinding scalars b\n        polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n        // Check degree\n        if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n            throw new Error(\"Z Polynomial is not well calculated\");\n        }\n\n        delete buffers.Z;\n    }\n\n    async function round3() {\n        if (logger) logger.debug(\"> Computing challenge alpha\");\n\n        // STEP 3.1 - Compute evaluation challenge alpha  F\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"Z\"));\n\n        challenges.alpha = transcript.getChallenge();\n        challenges.alpha2 = Fr.square(challenges.alpha);\n        if (logger) logger.debug(\" challenges.alpha: \" + Fr.toString(challenges.alpha, 16));\n\n        // Compute quotient polynomial T(X)\n        if (logger) logger.debug(\"> Computing T polynomial\");\n        await computeT();\n\n        // Compute [T1]_1, [T2]_1, [T3]_1\n        if (logger) logger.debug(\"> Computing T MSM\");\n        let commitT1 = await polynomials.T1.multiExponentiation(PTau, \"T1\");\n        let commitT2 = await polynomials.T2.multiExponentiation(PTau, \"T2\");\n        let commitT3 = await polynomials.T3.multiExponentiation(PTau, \"T3\");\n\n        // Third output of the prover is ([T1]_1, [T2]_1, [T3]_1)\n        proof.addPolynomial(\"T1\", commitT1);\n        proof.addPolynomial(\"T2\", commitT2);\n        proof.addPolynomial(\"T3\", commitT3);        \n    }\n\n    async function computeT() {\n        if (logger)\n            logger.debug(` Reading sections ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QL_SECTION}, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QR_SECTION}` +\n                `, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QM_SECTION}, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QO_SECTION}, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QC_SECTION}. Q selectors`);\n        // Reserve memory for Q's evaluations\n        evaluations.QL = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QR = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QM = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QO = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QC = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QL_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QR_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QM_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QO_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QC_SECTION][0].p + sDomain);\n\n        // Read Lagrange polynomials & evaluations from zkey file\n        evaluations.Lagrange = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4 * zkey.nPublic), curve, logger);\n\n        for (let i = 0; i < zkey.nPublic; i++) {\n            await fdZKey.readToBuffer(evaluations.Lagrange.eval, i * sDomain * 4, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_LAGRANGE_SECTION][0].p + i * 5 * sDomain + sDomain);\n        }\n\n        buffers.T = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n        buffers.Tz = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n\n        if (logger) logger.debug(\" Computing T evaluations\");\n\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize * 4; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0))\n                logger.debug(`      T evaluation ${i}/${zkey.domainSize * 4}`);\n\n            const a = evaluations.A.getEvaluation(i);\n            const b = evaluations.B.getEvaluation(i);\n            const c = evaluations.C.getEvaluation(i);\n            const z = evaluations.Z.getEvaluation(i);\n            const zw = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n            const qm = evaluations.QM.getEvaluation(i);\n            const ql = evaluations.QL.getEvaluation(i);\n            const qr = evaluations.QR.getEvaluation(i);\n            const qo = evaluations.QO.getEvaluation(i);\n            const qc = evaluations.QC.getEvaluation(i);\n            const s1 = evaluations.Sigma1.getEvaluation(i);\n            const s2 = evaluations.Sigma2.getEvaluation(i);\n            const s3 = evaluations.Sigma3.getEvaluation(i);\n\n            const ap = Fr.add(challenges.b[2], Fr.mul(challenges.b[1], w));\n            const bp = Fr.add(challenges.b[4], Fr.mul(challenges.b[3], w));\n            const cp = Fr.add(challenges.b[6], Fr.mul(challenges.b[5], w));\n\n            const w2 = Fr.square(w);\n            const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], w2), Fr.mul(challenges.b[8], w)), challenges.b[9]);\n            const wW = Fr.mul(w, Fr.w[zkey.power]);\n            const wW2 = Fr.square(wW);\n            const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], wW2), Fr.mul(challenges.b[8], wW)), challenges.b[9]);\n\n            let pi = Fr.zero;\n            for (let j = 0; j < zkey.nPublic; j++) {\n                const offset = (j * 4 * zkey.domainSize) + i;\n\n                const lPol = evaluations.Lagrange.getEvaluation(offset);\n                const aVal = buffers.A.slice(j * n8r, (j + 1) * n8r);\n\n                pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n            }\n\n            // e1 := a(X)b(X)qM(X) + a(X)qL(X) + b(X)qR(X) + c(X)qO(X) + PI(X) + qC(X)\n            let [e1, e1z] = _mul_z_js__WEBPACK_IMPORTED_MODULE_6__.MulZ.mul2(a, b, ap, bp, i % 4, Fr);\n            e1 = Fr.mul(e1, qm);\n            e1z = Fr.mul(e1z, qm);\n\n            e1 = Fr.add(e1, Fr.mul(a, ql));\n            e1z = Fr.add(e1z, Fr.mul(ap, ql));\n\n            e1 = Fr.add(e1, Fr.mul(b, qr));\n            e1z = Fr.add(e1z, Fr.mul(bp, qr));\n\n            e1 = Fr.add(e1, Fr.mul(c, qo));\n            e1z = Fr.add(e1z, Fr.mul(cp, qo));\n\n            e1 = Fr.add(e1, pi);\n            e1 = Fr.add(e1, qc);\n\n            // e2 := [(a(X) + X + )(b(X) + k1X + )(c(X) + k2X + )z(X)]\n            const betaw = Fr.mul(challenges.beta, w);\n            let e2a = a;\n            e2a = Fr.add(e2a, betaw);\n            e2a = Fr.add(e2a, challenges.gamma);\n\n            let e2b = b;\n            e2b = Fr.add(e2b, Fr.mul(betaw, zkey.k1));\n            e2b = Fr.add(e2b, challenges.gamma);\n\n            let e2c = c;\n            e2c = Fr.add(e2c, Fr.mul(betaw, zkey.k2));\n            e2c = Fr.add(e2c, challenges.gamma);\n\n            let e2d = z;\n\n            let [e2, e2z] = _mul_z_js__WEBPACK_IMPORTED_MODULE_6__.MulZ.mul4(e2a, e2b, e2c, e2d, ap, bp, cp, zp, i % 4, Fr);\n            e2 = Fr.mul(e2, challenges.alpha);\n            e2z = Fr.mul(e2z, challenges.alpha);\n\n            // e3 := [(a(X) + S1(X) + )(b(X) + S2(X) + )(c(X) + S3(X) + )z(X)]\n            let e3a = a;\n            e3a = Fr.add(e3a, Fr.mul(challenges.beta, s1));\n            e3a = Fr.add(e3a, challenges.gamma);\n\n            let e3b = b;\n            e3b = Fr.add(e3b, Fr.mul(challenges.beta, s2));\n            e3b = Fr.add(e3b, challenges.gamma);\n\n            let e3c = c;\n            e3c = Fr.add(e3c, Fr.mul(challenges.beta, s3));\n            e3c = Fr.add(e3c, challenges.gamma);\n\n            let e3d = zw;\n            let [e3, e3z] = _mul_z_js__WEBPACK_IMPORTED_MODULE_6__.MulZ.mul4(e3a, e3b, e3c, e3d, ap, bp, cp, zWp, i % 4, Fr);\n\n            e3 = Fr.mul(e3, challenges.alpha);\n            e3z = Fr.mul(e3z, challenges.alpha);\n\n            // e4 := ^2(z(X)1)L1(X)\n            let e4 = Fr.sub(z, Fr.one);\n            e4 = Fr.mul(e4, evaluations.Lagrange.getEvaluation(i));\n            e4 = Fr.mul(e4, challenges.alpha2);\n\n            let e4z = Fr.mul(zp, evaluations.Lagrange.getEvaluation(i));\n            e4z = Fr.mul(e4z, challenges.alpha2);\n\n\n            let t = Fr.add(Fr.sub(Fr.add(e1, e2), e3), e4);\n            let tz = Fr.add(Fr.sub(Fr.add(e1z, e2z), e3z), e4z);\n\n            buffers.T.set(t, i * n8r);\n            buffers.Tz.set(tz, i * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power + 2]);\n        }\n\n        // Compute the coefficients of the polynomial T0(X) from buffers.T0\n        if (logger)\n            logger.debug(\" Computing T ifft\");\n        polynomials.T = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T, curve, logger);\n\n        // Divide the polynomial T0 by Z_H(X)\n        if (logger)\n            logger.debug(\" Computing T / ZH\");\n        polynomials.T.divZh(zkey.domainSize, 4);\n\n        // Compute the coefficients of the polynomial Tz(X) from buffers.Tz\n        if (logger)\n            logger.debug(\" Computing Tz ifft\");\n        polynomials.Tz = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.Tz, curve, logger);\n\n        // Add the polynomial T1z to T1 to get the final polynomial T1\n        polynomials.T.add(polynomials.Tz);\n\n        // Check degree\n        if (polynomials.T.degree() >= zkey.domainSize * 3 + 6) {\n            throw new Error(\"T Polynomial is not well calculated\");\n        }\n\n        // t(x) has degree 3n + 5, we are going to split t(x) into three smaller polynomials:\n        // T1' and T2'  with a degree < n and T3' with a degree n+5\n        // such that t(x) = T1'(X) + X^n T2'(X) + X^{2n} T3'(X)\n        // To randomize the parts we use blinding scalars b_10 and b_11 in a way that doesn't change t(X):\n        // T1(X) = T1'(X) + b_10 X^n\n        // T2(X) = T2'(X) - b_10 + b_11 X^n\n        // T3(X) = T3'(X) - b_11\n        // such that\n        // t(X) = T1(X) + X^n T2(X) + X^2n T3(X)\n        if (logger) logger.debug(\" Computing T1, T2, T3 polynomials\");\n        polynomials.T1 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T2 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T3 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.T1.coef.set(polynomials.T.coef.slice(0, sDomain), 0);\n        polynomials.T2.coef.set(polynomials.T.coef.slice(sDomain, sDomain * 2), 0);\n        polynomials.T3.coef.set(polynomials.T.coef.slice(sDomain * 2, sDomain * 3 + 6 * n8r), 0);\n\n        // Add blinding scalar b_10 as a new coefficient n\n        polynomials.T1.setCoef(zkey.domainSize, challenges.b[10]);\n\n        // compute t_mid(X)\n        // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        const lowestMid = Fr.sub(polynomials.T2.getCoef(0), challenges.b[10]);\n        polynomials.T2.setCoef(0, lowestMid);\n        polynomials.T2.setCoef(zkey.domainSize, challenges.b[11]);\n\n        // compute t_high(X)\n        //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        const lowestHigh = Fr.sub(polynomials.T3.getCoef(0), challenges.b[11]);\n        polynomials.T3.setCoef(0, lowestHigh);\n    }\n\n    async function round4() {\n        if (logger) logger.debug(\"> Computing challenge xi\");\n\n        // STEP 4.1 - Compute evaluation challenge xi  F\n        transcript.reset();\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"T1\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T2\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T3\"));\n\n        challenges.xi = transcript.getChallenge();\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        \n        if (logger) logger.debug(\" challenges.xi: \" + Fr.toString(challenges.xi, 16));  \n\n        // Fourth output of the prover is ( a(xi), b(xi), c(xi), s1(xi), s2(xi), z(xiw) )\n        proof.addEvaluation(\"eval_a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_zw\", polynomials.Z.evaluate(challenges.xiw));\n    }\n\n    async function round5() {\n        if (logger) logger.debug(\"> Computing challenge v\");\n        \n        // STEP 5.1 - Compute evaluation challenge v  F\n        transcript.reset();\n        transcript.addScalar(challenges.xi);\n        transcript.addScalar(proof.getEvaluation(\"eval_a\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_b\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_c\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s1\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s2\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_zw\"));\n\n        challenges.v = [];\n        challenges.v[1] = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.v: \" + Fr.toString(challenges.v[1], 16));\n\n        for (let i = 2; i < 6; i++) {\n            challenges.v[i] = Fr.mul(challenges.v[i - 1], challenges.v[1]);\n        }\n\n        // STEP 5.2 Compute linearisation polynomial r(X)\n        if (logger) logger.debug(\"> Computing linearisation polynomial R(X)\");\n        await computeR();\n\n        //STEP 5.3 Compute opening proof polynomial Wxi(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxi(X) polynomial\");\n        computeWxi();\n\n        //STEP 5.4 Compute opening proof polynomial Wxiw(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxiw(X) polynomial\");\n        computeWxiw();\n\n        if (logger) logger.debug(\"> Computing Wxi, Wxiw MSM\");\n        let commitWxi = await polynomials.Wxi.multiExponentiation(PTau, \"Wxi\");\n        let commitWxiw = await polynomials.Wxiw.multiExponentiation(PTau, \"Wxiw\");\n\n        // Fifth output of the prover is ([Wxi]_1, [Wxiw]_1)\n        proof.addPolynomial(\"Wxi\", commitWxi);\n        proof.addPolynomial(\"Wxiw\", commitWxiw);\n    }\n\n    async function computeR() {\n        const Fr = curve.Fr;\n    \n        // Reserve memory for Q's polynomials\n        polynomials.QL = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QC_SECTION][0].p);   \n        \n        challenges.xin = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            challenges.xin = Fr.square(challenges.xin);\n        }\n\n        challenges.zh = Fr.sub(challenges.xin, Fr.one);\n\n        const L = [];\n\n        const n = Fr.e(zkey.domainSize);\n        let w = Fr.one;\n        for (let i = 1; i <= Math.max(1, zkey.nPublic); i++) {\n            L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        const eval_l1 = Fr.div(\n            Fr.sub(challenges.xin, Fr.one),\n            Fr.mul(n, Fr.sub(challenges.xi, Fr.one))\n        );\n\n        if (logger) {\n            logger.debug(\"Lagrange Evaluations: \");\n            for (let i=1; i<L.length; i++) {\n                logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));    \n            }\n        }\n\n        let eval_pi = Fr.zero;\n        for (let i=0; i<publicSignals.length; i++) {\n            const w = Fr.e(publicSignals[i]);\n            eval_pi = Fr.sub(eval_pi, Fr.mul(w, L[i+1]));\n        }\n\n        if (logger) logger.debug(\"PI: \" + Fr.toString(eval_pi, 16));\n\n        // Compute constant parts of R(X)\n        const coef_ab = Fr.mul(proof.evaluations.eval_a, proof.evaluations.eval_b);\n\n        let e2a = proof.evaluations.eval_a;\n        const betaxi = Fr.mul(challenges.beta, challenges.xi);\n        e2a = Fr.add(e2a, betaxi);\n        e2a = Fr.add(e2a, challenges.gamma);\n\n        let e2b = proof.evaluations.eval_b;\n        e2b = Fr.add(e2b, Fr.mul(betaxi, zkey.k1));\n        e2b = Fr.add(e2b, challenges.gamma);\n\n        let e2c = proof.evaluations.eval_c;\n        e2c = Fr.add(e2c, Fr.mul(betaxi, zkey.k2));\n        e2c = Fr.add(e2c, challenges.gamma);\n\n        const e2 = Fr.mul(Fr.mul(Fr.mul(e2a, e2b), e2c), challenges.alpha);\n\n        let e3a = proof.evaluations.eval_a;\n        e3a = Fr.add(e3a, Fr.mul(challenges.beta, proof.evaluations.eval_s1));\n        e3a = Fr.add(e3a, challenges.gamma);\n\n        let e3b = proof.evaluations.eval_b;\n        e3b = Fr.add(e3b, Fr.mul(challenges.beta, proof.evaluations.eval_s2));\n        e3b = Fr.add(e3b, challenges.gamma);\n\n        let e3 = Fr.mul(e3a, e3b);\n        e3 = Fr.mul(e3, proof.evaluations.eval_zw);\n        e3 = Fr.mul(e3, challenges.alpha);\n\n        const e4 = Fr.mul(eval_l1, challenges.alpha2);\n\n        polynomials.R = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.R.add(polynomials.QM, coef_ab);\n        polynomials.R.add(polynomials.QL, proof.evaluations.eval_a);\n        polynomials.R.add(polynomials.QR, proof.evaluations.eval_b);\n        polynomials.R.add(polynomials.QO, proof.evaluations.eval_c);\n        polynomials.R.add(polynomials.QC);\n        polynomials.R.add(polynomials.Z, e2);\n        polynomials.R.sub(polynomials.Sigma3, Fr.mul(e3, challenges.beta));\n        polynomials.R.add(polynomials.Z, e4);\n\n        let tmp = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.T3, curve, logger);\n        tmp.mulScalar(Fr.square(challenges.xin));\n        tmp.add(polynomials.T2, challenges.xin);\n        tmp.add(polynomials.T1);\n        tmp.mulScalar(challenges.zh);\n\n        polynomials.R.sub(tmp);\n\n        let r0 = Fr.sub(eval_pi, Fr.mul(e3, Fr.add(proof.evaluations.eval_c, challenges.gamma)));\n        r0 = Fr.sub(r0, e4);\n\n        if (logger) logger.debug(\"r0: \" + Fr.toString(r0, 16));\n\n        polynomials.R.addScalar(r0);\n    }\n\n    function computeWxi() {\n        polynomials.Wxi = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain + 6 * n8r), curve, logger);\n\n        polynomials.Wxi.add(polynomials.R);\n        polynomials.Wxi.add(polynomials.A, challenges.v[1]);\n        polynomials.Wxi.add(polynomials.B, challenges.v[2]);\n        polynomials.Wxi.add(polynomials.C, challenges.v[3]);\n        polynomials.Wxi.add(polynomials.Sigma1, challenges.v[4]);\n        polynomials.Wxi.add(polynomials.Sigma2, challenges.v[5]);\n\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[1], proof.evaluations.eval_a));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[2], proof.evaluations.eval_b));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[3], proof.evaluations.eval_c));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[4], proof.evaluations.eval_s1));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[5], proof.evaluations.eval_s2));\n\n        polynomials.Wxi.divByZerofier(1, challenges.xi);\n    }\n\n    async function computeWxiw() {\n        polynomials.Wxiw = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.Z, curve, logger);\n        polynomials.Wxiw.subScalar(proof.evaluations.eval_zw);\n\n        polynomials.Wxiw.divByZerofier(1, challenges.xiw);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfcHJvdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVvRDtBQUNQO0FBQ0E7QUFDVztBQUN4RCxPQUFPLGtCQUFrQixFQUFFLCtDQUFLO0FBQ0c7QUFDNEI7QUFDN0I7QUFjSjtBQUMwQjtBQUNFO0FBQzFEO0FBQ2U7QUFDZixXQUFXLG9DQUFvQyxRQUFRLDREQUF3Qjs7QUFFL0U7QUFDQTtBQUNBLHVCQUF1QixzREFBb0I7O0FBRTNDO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQyxRQUFRLDREQUF3Qjs7QUFFL0UsdUJBQXVCLHNEQUFvQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUEsU0FBUyxnREFBTTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsV0FBVyxhQUFhLGNBQWMsSUFBSSxnQkFBZ0I7QUFDdEg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BELHlDQUF5QyxXQUFXO0FBQ3BELHlDQUF5QyxnQkFBZ0I7QUFDekQseUNBQXlDLFdBQVc7QUFDcEQseUNBQXlDLGFBQWE7QUFDdEQseUNBQXlDLGtCQUFrQjtBQUMzRCx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qiw0REFBd0I7O0FBRXREO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBUzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDRDQUFLO0FBQ3pCLDJCQUEyQix3RUFBbUI7O0FBRTlDLGtEQUFrRCwwRUFBeUIsQ0FBQztBQUM1RTs7QUFFQSxrREFBa0Qsc0VBQXFCLENBQUM7QUFDeEU7QUFDQSw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUzs7QUFFckQsZ0ZBQWdGLHNFQUFxQjtBQUNyRyxnRkFBZ0Ysc0VBQXFCO0FBQ3JHLGdGQUFnRixzRUFBcUI7O0FBRXJHO0FBQ0EsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7QUFDdEQsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7QUFDdEQsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7O0FBRXRELG9GQUFvRixzRUFBcUI7QUFDekcsb0ZBQW9GLHNFQUFxQjtBQUN6RyxvRkFBb0Ysc0VBQXFCOztBQUV6RyxrREFBa0QscUVBQW9CLENBQUM7QUFDdkUsdUJBQXVCLDREQUF3Qix1QkFBdUIscUVBQW9COztBQUUxRjs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0EsMkJBQTJCLGdEQUFNO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLDREQUF3Qix1QkFBdUIsMEVBQXlCOztBQUU1RztBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHFCQUFxQjtBQUM3Qyx3RkFBd0YsRUFBRSxHQUFHLGdCQUFnQjs7QUFFN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsbURBQVM7QUFDakMsd0JBQXdCLG1EQUFTO0FBQ2pDLHdCQUF3QixtREFBUzs7QUFFakM7QUFDQSwrQkFBK0IsNERBQXdCLHVCQUF1QixzRUFBcUI7QUFDbkcsK0JBQStCLDREQUF3Qix1QkFBdUIsc0VBQXFCO0FBQ25HLCtCQUErQiw0REFBd0IsdUJBQXVCLHNFQUFxQjs7QUFFbkc7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixpRUFBVTtBQUN4QztBQUNBLDhCQUE4QixpRUFBVTtBQUN4QztBQUNBLDhCQUE4QixpRUFBVTs7QUFFeEM7QUFDQTtBQUNBLDhCQUE4QixtRUFBVztBQUN6QztBQUNBLDhCQUE4QixtRUFBVztBQUN6QztBQUNBLDhCQUE4QixtRUFBVzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixtREFBUztBQUNsQyx5QkFBeUIsbURBQVM7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsaUVBQVU7O0FBRXhDO0FBQ0E7QUFDQSw4QkFBOEIsbUVBQVc7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxtRUFBa0IsQ0FBQyxJQUFJLG1FQUFrQixDQUFDO0FBQzNGLHFCQUFxQixtRUFBa0IsQ0FBQyxJQUFJLG1FQUFrQixDQUFDLElBQUksbUVBQWtCLENBQUM7QUFDdEY7QUFDQSw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUztBQUN0RCw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUztBQUN0RCw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUztBQUN0RCw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUztBQUN0RCw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUzs7QUFFdEQ7QUFDQSxvRkFBb0YsbUVBQWtCO0FBQ3RHLG9GQUFvRixtRUFBa0I7QUFDdEcsb0ZBQW9GLG1FQUFrQjtBQUN0RyxvRkFBb0YsbUVBQWtCO0FBQ3RHLG9GQUFvRixtRUFBa0I7O0FBRXRHO0FBQ0EsbUNBQW1DLG1FQUFXLEtBQUssbURBQVM7O0FBRTVELHdCQUF3QixrQkFBa0I7QUFDMUMsNEdBQTRHLHlFQUF3QjtBQUNwSTs7QUFFQSx3QkFBd0IsbURBQVM7QUFDakMseUJBQXlCLG1EQUFTOztBQUVsQzs7QUFFQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQSxtREFBbUQsRUFBRSxHQUFHLG9CQUFvQjs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsMkNBQUk7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsMkNBQUk7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDJDQUFJOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpRUFBVTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFVOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7O0FBRXJEO0FBQ0EsZ0ZBQWdGLG1FQUFrQjtBQUNsRyxnRkFBZ0YsbUVBQWtCO0FBQ2xHLGdGQUFnRixtRUFBa0I7QUFDbEcsZ0ZBQWdGLG1FQUFrQjtBQUNsRyxnRkFBZ0YsbUVBQWtCO0FBQ2xHO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QyxpQ0FBaUMsRUFBRTtBQUNuQztBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixpRUFBVSxLQUFLLG1EQUFTOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpRUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsaUVBQVUsS0FBSyxtREFBUzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixpRUFBVTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfcHJvdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMSAwa2ltcyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLyogSW1wbGVtZW50YXRpb24gb2YgdGhpcyBwYXBlcjogaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxOS85NTMucGRmIHNlY3Rpb24gOC40ICovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIHd0bnNVdGlscyBmcm9tIFwiLi93dG5zX3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBTY2FsYXIsIHV0aWxzLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5jb25zdCB7c3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcbmltcG9ydCB7IFByb29mIH0gZnJvbSBcIi4vcHJvb2YuanNcIjtcbmltcG9ydCB7IEtlY2NhazI1NlRyYW5zY3JpcHQgfSBmcm9tIFwiLi9LZWNjYWsyNTZUcmFuc2NyaXB0LmpzXCI7XG5pbXBvcnQgeyBNdWxaIH0gZnJvbSBcIi4vbXVsX3ouanNcIjtcbmltcG9ydCB7ICBaS0VZX1BMX0hFQURFUl9TRUNUSU9OLFxuICAgIFpLRVlfUExfQURESVRJT05TX1NFQ1RJT04sXG4gICAgWktFWV9QTF9BX01BUF9TRUNUSU9OLFxuICAgIFpLRVlfUExfQl9NQVBfU0VDVElPTixcbiAgICBaS0VZX1BMX0NfTUFQX1NFQ1RJT04sXG4gICAgWktFWV9QTF9RTV9TRUNUSU9OLFxuICAgIFpLRVlfUExfUUxfU0VDVElPTixcbiAgICBaS0VZX1BMX1FSX1NFQ1RJT04sXG4gICAgWktFWV9QTF9RT19TRUNUSU9OLFxuICAgIFpLRVlfUExfUUNfU0VDVElPTixcbiAgICBaS0VZX1BMX1NJR01BX1NFQ1RJT04sXG4gICAgWktFWV9QTF9MQUdSQU5HRV9TRUNUSU9OLFxuICAgIFpLRVlfUExfUFRBVV9TRUNUSU9OLFxufSBmcm9tIFwiLi9wbG9ua19jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IFBvbHlub21pYWwgfSBmcm9tIFwiLi9wb2x5bm9taWFsL3BvbHlub21pYWwuanNcIjtcbmltcG9ydCB7IEV2YWx1YXRpb25zIH0gZnJvbSBcIi4vcG9seW5vbWlhbC9ldmFsdWF0aW9ucy5qc1wiO1xuICAgIFxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGxvbmsxNlByb3ZlKHprZXlGaWxlTmFtZSwgd2l0bmVzc0ZpbGVOYW1lLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7ZmQ6IGZkV3Rucywgc2VjdGlvbnM6IHNlY3Rpb25zV3Ruc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUod2l0bmVzc0ZpbGVOYW1lLCBcInd0bnNcIiwgMiwgMTw8MjUsIDE8PDIzKTtcblxuICAgIC8vIFJlYWQgd2l0bmVzcyBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBSZWFkaW5nIHdpdG5lc3MgZmlsZVwiKTtcbiAgICBjb25zdCB3dG5zID0gYXdhaXQgd3Ruc1V0aWxzLnJlYWRIZWFkZXIoZmRXdG5zLCBzZWN0aW9uc1d0bnMpO1xuXG4gICAgLy8gUmVhZCB6a2V5IGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJlYWRpbmcgemtleSBmaWxlXCIpO1xuICAgIGNvbnN0IHtmZDogZmRaS2V5LCBzZWN0aW9uczogemtleVNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkWktleSwgemtleVNlY3Rpb25zLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIGlmICh6a2V5LnByb3RvY29sICE9IFwicGxvbmtcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IHBsb25rXCIpO1xuICAgIH1cblxuICAgIGlmICghU2NhbGFyLmVxKHprZXkuciwgIHd0bnMucSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VydmUgb2YgdGhlIHdpdG5lc3MgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnZlIG9mIHRoZSBwcm92aW5nIGtleVwiKTtcbiAgICB9XG5cbiAgICBpZiAod3Rucy5uV2l0bmVzcyAhPSB6a2V5Lm5WYXJzIC16a2V5Lm5BZGRpdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHdpdG5lc3MgbGVuZ3RoLiBDaXJjdWl0OiAke3prZXkublZhcnN9LCB3aXRuZXNzOiAke3d0bnMubldpdG5lc3N9LCAke3prZXkubkFkZGl0aW9uc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJ2ZSA9IHprZXkuY3VydmU7XG5cbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IG44ciA9IGN1cnZlLkZyLm44O1xuICAgIGNvbnN0IHNEb21haW4gPSB6a2V5LmRvbWFpblNpemUgKiBuOHI7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIiAgUExPTksgUFJPVkUgU0VUVElOR1NcIik7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgICBDdXJ2ZTogICAgICAgICAke2N1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgICBDaXJjdWl0IHBvd2VyOiAke3prZXkucG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgICBEb21haW4gc2l6ZTogICAke3prZXkuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIFZhcnM6ICAgICAgICAgICR7emtleS5uVmFyc31gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIFB1YmxpYyB2YXJzOiAgICR7emtleS5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoYCAgQ29uc3RyYWludHM6ICAgJHt6a2V5Lm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIEFkZGl0aW9uczogICAgICR7emtleS5uQWRkaXRpb25zfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgIH1cblxuICAgIC8vUmVhZCB3aXRuZXNzIGRhdGFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJlYWRpbmcgd2l0bmVzcyBmaWxlIGRhdGFcIik7XG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRXdG5zLCBzZWN0aW9uc1d0bnMsIDIpO1xuXG4gICAgLy8gRmlyc3QgZWxlbWVudCBpbiBwbG9uayBpcyBub3QgdXNlZCBhbmQgY2FuIGJlIGFueSB2YWx1ZS4gKEJ1dCBhbHdheXMgdGhlIHNhbWUpLlxuICAgIC8vIFdlIHNldCBpdCB0byB6ZXJvIHRvIGdvIGZhc3RlciBpbiB0aGUgZXhwb25lbnRpYXRpb25zLlxuICAgIGJ1ZmZXaXRuZXNzLnNldChGci56ZXJvLCAwKTtcbiAgICBjb25zdCBidWZmSW50ZXJuYWxXaXRuZXNzID0gbmV3IEJpZ0J1ZmZlcihuOHIqemtleS5uQWRkaXRpb25zKTtcblxuICAgIGxldCBidWZmZXJzID0ge307XG4gICAgbGV0IHBvbHlub21pYWxzID0ge307XG4gICAgbGV0IGV2YWx1YXRpb25zID0ge307XG5cbiAgICBsZXQgY2hhbGxlbmdlcyA9IHt9O1xuICAgIGxldCBwcm9vZiA9IG5ldyBQcm9vZihjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGA+IFJlYWRpbmcgU2VjdGlvbiAke1pLRVlfUExfQURESVRJT05TX1NFQ1RJT059LiBBZGRpdGlvbnNgKTtcbiAgICBhd2FpdCBjYWxjdWxhdGVBZGRpdGlvbnMoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgPiBSZWFkaW5nIFNlY3Rpb24gJHtaS0VZX1BMX1NJR01BX1NFQ1RJT059LiBTaWdtYTEsIFNpZ21hMiAmIFNpZ21hIDNgKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgUmVhZGluZyBTaWdtYSBwb2x5bm9taWFscyBcIik7XG4gICAgcG9seW5vbWlhbHMuU2lnbWExID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgcG9seW5vbWlhbHMuU2lnbWEyID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgcG9seW5vbWlhbHMuU2lnbWEzID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlNpZ21hMS5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9TSUdNQV9TRUNUSU9OXVswXS5wKTtcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlNpZ21hMi5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9TSUdNQV9TRUNUSU9OXVswXS5wICsgNSAqIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWEzLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnAgKyAxMCAqIHNEb21haW4pO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IFJlYWRpbmcgU2lnbWEgZXZhbHVhdGlvbnNcIik7XG4gICAgZXZhbHVhdGlvbnMuU2lnbWExID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTIgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgIGV2YWx1YXRpb25zLlNpZ21hMyA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlNpZ21hMS5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfU0lHTUFfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEyLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9TSUdNQV9TRUNUSU9OXVswXS5wICsgNiAqIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEzLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9TSUdNQV9TRUNUSU9OXVswXS5wICsgMTEgKiBzRG9tYWluKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgPiBSZWFkaW5nIFNlY3Rpb24gJHtaS0VZX1BMX1BUQVVfU0VDVElPTn0uIFBvd2VycyBvZiBUYXVgKTtcbiAgICBjb25zdCBQVGF1ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX1BMX1BUQVVfU0VDVElPTik7XG5cbiAgICBsZXQgcHVibGljU2lnbmFscyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaT0xOyBpPD0gemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHViID0gYnVmZldpdG5lc3Muc2xpY2UoaSpGci5uOCwgaSpGci5uOCtGci5uOCk7XG4gICAgICAgIHB1YmxpY1NpZ25hbHMucHVzaChTY2FsYXIuZnJvbVJwckxFKHB1YikpO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlwiKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJPVU5EIDFcIik7XG4gICAgYXdhaXQgcm91bmQxKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJPVU5EIDJcIik7XG4gICAgYXdhaXQgcm91bmQyKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJPVU5EIDNcIik7XG4gICAgYXdhaXQgcm91bmQzKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJPVU5EIDRcIik7XG4gICAgYXdhaXQgcm91bmQ0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJPVU5EIDVcIik7XG4gICAgYXdhaXQgcm91bmQ1KCk7XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEZpbmFsIGFkanVzdG1lbnRzIC8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIGF3YWl0IGZkV3Rucy5jbG9zZSgpO1xuXG4gICAgLy8gUHJlcGFyZSBwcm9vZlxuICAgIGxldCBfcHJvb2YgPSBwcm9vZi50b09iamVjdFByb29mKGZhbHNlKTtcbiAgICBfcHJvb2YucHJvdG9jb2wgPSBcInBsb25rXCI7XG4gICAgX3Byb29mLmN1cnZlID0gY3VydmUubmFtZTtcbiAgICBcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJQTE9OSyBQUk9WRVIgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9vZjogc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpLFxuICAgICAgICBwdWJsaWNTaWduYWxzOiBzdHJpbmdpZnlCaWdJbnRzKHB1YmxpY1NpZ25hbHMpXG4gICAgfTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZUFkZGl0aW9ucygpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBhZGRpdGlvbnNcIik7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uc0J1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfUExfQURESVRJT05TX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIHNpemVzOiB3aXJlSWRfeCA9IDQgYnl0ZXMgKDMyIGJpdHMpLCBmYWN0b3JfeCA9IGZpZWxkIHNpemUgYml0c1xuICAgICAgICAvLyBBZGRpdGlvbiBmb3JtOiB3aXJlSWRfYSB3aXJlSWRfYiBmYWN0b3JfYSBmYWN0b3JfYiAoc2l6ZSBpcyA0ICsgNCArIHNGciArIHNGcilcbiAgICAgICAgY29uc3Qgc1N1bSA9IDggKyBuOHIgKiAyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uQWRkaXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmRlYnVnKGAgICAgYWRkaXRpb24gJHtpfS8ke3prZXkubkFkZGl0aW9uc31gKTtcblxuICAgICAgICAgICAgLy8gUmVhZCBhZGRpdGlvbiB2YWx1ZXNcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpICogc1N1bTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkMSA9IHJlYWRVSW50MzIoYWRkaXRpb25zQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWQyID0gcmVhZFVJbnQzMihhZGRpdGlvbnNCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IxID0gYWRkaXRpb25zQnVmZi5zbGljZShvZmZzZXQsIG9mZnNldCArIG44cik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbjhyO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yMiA9IGFkZGl0aW9uc0J1ZmYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBuOHIpO1xuXG4gICAgICAgICAgICAvLyBHZXQgd2l0bmVzcyB2YWx1ZVxuICAgICAgICAgICAgY29uc3Qgd2l0bmVzczEgPSBnZXRXaXRuZXNzKHNpZ25hbElkMSk7XG4gICAgICAgICAgICBjb25zdCB3aXRuZXNzMiA9IGdldFdpdG5lc3Moc2lnbmFsSWQyKTtcblxuICAgICAgICAgICAgLy9DYWxjdWxhdGUgZmluYWwgcmVzdWx0XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBGci5hZGQoRnIubXVsKGZhY3RvcjEsIHdpdG5lc3MxKSwgRnIubXVsKGZhY3RvcjIsIHdpdG5lc3MyKSk7XG5cbiAgICAgICAgICAgIGJ1ZmZJbnRlcm5hbFdpdG5lc3Muc2V0KHJlc3VsdCwgbjhyICogaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkVUludDMyKGIsIG8pIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGIuc2xpY2Uobywgbys0KTtcbiAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIsIGJ1ZmYuYnl0ZU9mZnNldCwgYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZWLmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaXRuZXNzKGlkeCkge1xuICAgICAgICBpZiAoaWR4IDwgemtleS5uVmFycy16a2V5Lm5BZGRpdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmV2l0bmVzcy5zbGljZShpZHgqbjhyLCBpZHgqbjhyK244cik7XG4gICAgICAgIH0gZWxzZSBpZiAoaWR4IDwgemtleS5uVmFycykge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZJbnRlcm5hbFdpdG5lc3Muc2xpY2UoKGlkeCAtICh6a2V5Lm5WYXJzLXprZXkubkFkZGl0aW9ucykpKm44ciwgKGlkeC0oemtleS5uVmFycy16a2V5Lm5BZGRpdGlvbnMpKSpuOHIgKyBuOHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnZlLkZyLnplcm87XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDEoKSB7XG4gICAgICAgIC8vIFNURVAgMS4xIC0gR2VuZXJhdGUgcmFuZG9tIGJsaW5kaW5nIHNjYWxhcnMgKGIxLCAuLi4sIGIxMSkg4oiIIEZcbiAgICAgICAgY2hhbGxlbmdlcy5iID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MTsgaTw9MTE7IGkrKykge1xuICAgICAgICAgICAgY2hhbGxlbmdlcy5iW2ldID0gY3VydmUuRnIucmFuZG9tKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDEuMiAtIENvbXB1dGUgd2lyZSBwb2x5bm9taWFscyBhKFgpLCBiKFgpIGFuZCBjKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIEEsIEIsIEMgd2lyZSBwb2x5bm9taWFsc1wiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVdpcmVQb2x5bm9taWFscygpO1xuXG4gICAgICAgIC8vIFNURVAgMS4zIC0gQ29tcHV0ZSBbYV1fMSwgW2JdXzEsIFtjXV8xXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIEEsIEIsIEMgTVNNXCIpO1xuICAgICAgICBsZXQgY29tbWl0QSA9IGF3YWl0IHBvbHlub21pYWxzLkEubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIkFcIik7XG4gICAgICAgIGxldCBjb21taXRCID0gYXdhaXQgcG9seW5vbWlhbHMuQi5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiQlwiKTtcbiAgICAgICAgbGV0IGNvbW1pdEMgPSBhd2FpdCBwb2x5bm9taWFscy5DLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJDXCIpO1xuXG4gICAgICAgIC8vIEZpcnN0IG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbQV1fMSwgW0JdXzEsIFtDXV8xKVxuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiQVwiLCBjb21taXRBKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIkJcIiwgY29tbWl0Qik7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJDXCIsIGNvbW1pdEMpO1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVXaXJlUG9seW5vbWlhbHMoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBSZWFkaW5nIGRhdGEgZnJvbSB6a2V5IGZpbGVcIik7XG5cbiAgICAgICAgLy8gQnVpbGQgQSwgQiBhbmQgQyBldmFsdWF0aW9ucyBidWZmZXIgZnJvbSB6a2V5IGFuZCB3aXRuZXNzIGZpbGVzXG4gICAgICAgIGJ1ZmZlcnMuQSA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgIGJ1ZmZlcnMuQiA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgIGJ1ZmZlcnMuQyA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG5cbiAgICAgICAgLy8gUmVhZCB6a2V5IGZpbGUgdG8gdGhlIGJ1ZmZlcnNcbiAgICAgICAgY29uc3QgYU1hcEJ1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfUExfQV9NQVBfU0VDVElPTik7XG4gICAgICAgIGNvbnN0IGJNYXBCdWZmID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX1BMX0JfTUFQX1NFQ1RJT04pO1xuICAgICAgICBjb25zdCBjTWFwQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9QTF9DX01BUF9TRUNUSU9OKTtcblxuICAgICAgICAvLyBDb21wdXRlIGFsbCB3aXRuZXNzIGZyb20gc2lnbmFsIGlkcyBhbmQgc2V0IHRoZW0gdG8gQSxCICYgQyBidWZmZXJzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uQ29uc3RyYWludHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpICogbjhyO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDQ7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgQSB2YWx1ZSBmcm9tIGEgc2lnbmFsIGlkXG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZEEgPSByZWFkVUludDMyKGFNYXBCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgYnVmZmVycy5BLnNldChnZXRXaXRuZXNzKHNpZ25hbElkQSksIGlfc0ZyKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBCIHZhbHVlIGZyb20gYSBzaWduYWwgaWRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkQiA9IHJlYWRVSW50MzIoYk1hcEJ1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBidWZmZXJzLkIuc2V0KGdldFdpdG5lc3Moc2lnbmFsSWRCKSwgaV9zRnIpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIEMgdmFsdWUgZnJvbSBhIHNpZ25hbCBpZFxuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWRDID0gcmVhZFVJbnQzMihjTWFwQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQy5zZXQoZ2V0V2l0bmVzcyhzaWduYWxJZEMpLCBpX3NGcik7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXJzLkEgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkEpO1xuICAgICAgICBidWZmZXJzLkIgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkIpO1xuICAgICAgICBidWZmZXJzLkMgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkMpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgd2lyZSBwb2x5bm9taWFscyBhKFgpLCBiKFgpIGFuZCBjKFgpIGZyb20gQSxCICYgQyBidWZmZXJzXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgQSBpZmZ0XCIpO1xuICAgICAgICBwb2x5bm9taWFscy5BID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5BLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBCIGlmZnRcIik7XG4gICAgICAgIHBvbHlub21pYWxzLkIgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLkIsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIEMgaWZmdFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuQyA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuQywgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBleHRlbmRlZCBldmFsdWF0aW9ucyBvZiBhKFgpLCBiKFgpIGFuZCBjKFgpIHBvbHlub21pYWxzXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgQSBmZnRcIik7XG4gICAgICAgIGV2YWx1YXRpb25zLkEgPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5BLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBCIGZmdFwiKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuQiA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkIsIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIEMgZmZ0XCIpO1xuICAgICAgICBldmFsdWF0aW9ucy5DID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQywgNCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gQmxpbmQgYShYKSwgYihYKSBhbmQgYyhYKSBwb2x5bm9taWFscyBjb2VmZmljaWVudHMgd2l0aCBibGluZGluZyBzY2FsYXJzIGJcbiAgICAgICAgcG9seW5vbWlhbHMuQS5ibGluZENvZWZmaWNpZW50cyhbY2hhbGxlbmdlcy5iWzJdLCBjaGFsbGVuZ2VzLmJbMV1dKTtcbiAgICAgICAgcG9seW5vbWlhbHMuQi5ibGluZENvZWZmaWNpZW50cyhbY2hhbGxlbmdlcy5iWzRdLCBjaGFsbGVuZ2VzLmJbM11dKTtcbiAgICAgICAgcG9seW5vbWlhbHMuQy5ibGluZENvZWZmaWNpZW50cyhbY2hhbGxlbmdlcy5iWzZdLCBjaGFsbGVuZ2VzLmJbNV1dKTtcblxuICAgICAgICAvLyBDaGVjayBkZWdyZWVzXG4gICAgICAgIGlmIChwb2x5bm9taWFscy5BLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSArIDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2x5bm9taWFscy5CLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSArIDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkIgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2x5bm9taWFscy5DLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSArIDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkMgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9ICAgICAgICBcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDIoKSB7XG4gICAgICAgIC8vIFNURVAgMi4xIC0gQ29tcHV0ZSBwZXJtdXRhdGlvbiBjaGFsbGVuZ2UgYmV0YSBhbmQgZ2FtbWEg4oiIIEZcbiAgICAgICAgLy8gQ29tcHV0ZSBwZXJtdXRhdGlvbiBjaGFsbGVuZ2UgYmV0YVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBjaGFsbGVuZ2VzIGJldGEgYW5kIGdhbW1hXCIpO1xuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG5cbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUW0pO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5RbCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlFyKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUW8pO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5RYyk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlMxKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUzIpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5TMyk7XG5cbiAgICAgICAgLy8gQWRkIEEgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoYnVmZmVycy5BLnNsaWNlKGkgKiBuOHIsIGkgKiBuOHIgKyBuOHIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBBLCBCLCBDIHRvIHRoZSB0cmFuc2NyaXB0XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiQVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiQlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiQ1wiKSk7XG5cbiAgICAgICAgY2hhbGxlbmdlcy5iZXRhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IGNoYWxsZW5nZXMuYmV0YTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmJldGEsIDE2KSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBwZXJtdXRhdGlvbiBjaGFsbGVuZ2UgZ2FtbWFcbiAgICAgICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmJldGEpO1xuICAgICAgICBjaGFsbGVuZ2VzLmdhbW1hID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IGNoYWxsZW5nZXMuZ2FtbWE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5nYW1tYSwgMTYpKTtcbiAgICBcbiAgICAgICAgLy8gU1RFUCAyLjIgLSBDb21wdXRlIHBlcm11dGF0aW9uIHBvbHlub21pYWwgeihYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBaIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVaKCk7XG5cbiAgICAgICAgLy8gU1RFUCAyLjMgLSBDb21wdXRlIHBlcm11dGF0aW9uIFt6XV8xXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIFogTVNNXCIpO1xuICAgICAgICBsZXQgY29tbWl0WiA9IGF3YWl0IHBvbHlub21pYWxzLloubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlpcIik7XG5cbiAgICAgICAgLy8gU2Vjb25kIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbWl1fMSlcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlpcIiwgY29tbWl0Wik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVooKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgWiBldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICBsZXQgbnVtQXJyID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcbiAgICAgICAgbGV0IGRlbkFyciA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBmaXJzdCB2YWx1ZXMgdG8gMVxuICAgICAgICBudW1BcnIuc2V0KEZyLm9uZSwgMCk7XG4gICAgICAgIGRlbkFyci5zZXQoRnIub25lLCAwKTtcblxuICAgICAgICAvLyBTZXQgaW5pdGlhbCBvbWVnYVxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9uOHIgPSBpICogbjhyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBhID0gYnVmZmVycy5BLnNsaWNlKGlfbjhyLCBpX244ciArIG44cik7XG4gICAgICAgICAgICBjb25zdCBiID0gYnVmZmVycy5CLnNsaWNlKGlfbjhyLCBpX244ciArIG44cik7XG4gICAgICAgICAgICBjb25zdCBjID0gYnVmZmVycy5DLnNsaWNlKGlfbjhyLCBpX244ciArIG44cik7XG5cbiAgICAgICAgICAgIC8vIFooWCkgOj0gbnVtQXJyIC8gZGVuQXJyXG4gICAgICAgICAgICAvLyBudW1BcnIgOj0gKGEgKyBiZXRhwrfPiSArIGdhbW1hKShiICsgYmV0YcK3z4nCt2sxICsgZ2FtbWEpKGMgKyBiZXRhwrfPicK3azIgKyBnYW1tYSlcbiAgICAgICAgICAgIGNvbnN0IGJldGF3ID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgdyk7XG5cbiAgICAgICAgICAgIGxldCBuMSA9IEZyLmFkZChhLCBiZXRhdyk7XG4gICAgICAgICAgICBuMSA9IEZyLmFkZChuMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBuMiA9IEZyLmFkZChiLCBGci5tdWwoemtleS5rMSwgYmV0YXcpKTtcbiAgICAgICAgICAgIG4yID0gRnIuYWRkKG4yLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IG4zID0gRnIuYWRkKGMsIEZyLm11bCh6a2V5LmsyLCBiZXRhdykpO1xuICAgICAgICAgICAgbjMgPSBGci5hZGQobjMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgbnVtID0gRnIubXVsKG4xLCBGci5tdWwobjIsIG4zKSk7XG5cbiAgICAgICAgICAgIC8vIGRlbkFyciA6PSAoYSArIGJldGHCt3NpZ21hMSArIGdhbW1hKShiICsgYmV0YcK3c2lnbWEyICsgZ2FtbWEpKGMgKyBiZXRhwrdzaWdtYTMgKyBnYW1tYSlcbiAgICAgICAgICAgIGxldCBkMSA9IEZyLmFkZChhLCBGci5tdWwoZXZhbHVhdGlvbnMuU2lnbWExLmdldEV2YWx1YXRpb24oaSAqIDQpLCBjaGFsbGVuZ2VzLmJldGEpKTtcbiAgICAgICAgICAgIGQxID0gRnIuYWRkKGQxLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGQyID0gRnIuYWRkKGIsIEZyLm11bChldmFsdWF0aW9ucy5TaWdtYTIuZ2V0RXZhbHVhdGlvbihpICogNCksIGNoYWxsZW5nZXMuYmV0YSkpO1xuICAgICAgICAgICAgZDIgPSBGci5hZGQoZDIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZDMgPSBGci5hZGQoYywgRnIubXVsKGV2YWx1YXRpb25zLlNpZ21hMy5nZXRFdmFsdWF0aW9uKGkgKiA0KSwgY2hhbGxlbmdlcy5iZXRhKSk7XG4gICAgICAgICAgICBkMyA9IEZyLmFkZChkMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBkZW4gPSBGci5tdWwoZDEsIEZyLm11bChkMiwgZDMpKTtcblxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgY3VycmVudCBudW0gdmFsdWUgd2l0aCB0aGUgcHJldmlvdXMgb25lIHNhdmVkIGluIG51bUFyclxuICAgICAgICAgICAgbnVtID0gRnIubXVsKG51bUFyci5zbGljZShpX244ciwgaV9uOHIgKyBuOHIpLCBudW0pO1xuICAgICAgICAgICAgbnVtQXJyLnNldChudW0sICgoaSArIDEpICUgemtleS5kb21haW5TaXplKSAqIG44cik7XG5cbiAgICAgICAgICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgZGVuIHZhbHVlIHdpdGggdGhlIHByZXZpb3VzIG9uZSBzYXZlZCBpbiBkZW5BcnJcbiAgICAgICAgICAgIGRlbiA9IEZyLm11bChkZW5BcnIuc2xpY2UoaV9uOHIsIGlfbjhyICsgbjhyKSwgZGVuKTtcbiAgICAgICAgICAgIGRlbkFyci5zZXQoZGVuLCAoKGkgKyAxKSAlIHprZXkuZG9tYWluU2l6ZSkgKiBuOHIpO1xuXG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBkZW5BcnIgdG8gY29tcHV0ZSBpbiB0aGUgbmV4dCBjb21tYW5kIHRoZVxuICAgICAgICAvLyBkaXZpc2lvbiBudW1BcnIvZGVuQXJyIGJ5IG11bHRpcGx5aW5nIG51bSDCtyAxL2RlbkFyclxuICAgICAgICBkZW5BcnIgPSBhd2FpdCBGci5iYXRjaEludmVyc2UoZGVuQXJyKTtcblxuICAgICAgICAvLyBUT0RPOiBEbyBpdCBpbiBhc3NlbWJseSBhbmQgaW4gcGFyYWxsZWxcbiAgICAgICAgLy8gTXVsdGlwbHkgbnVtQXJyIMK3IGRlbkFyciB3aGVyZSBkZW5BcnIgd2FzIGludmVydGVkIGluIHRoZSBwcmV2aW91cyBjb21tYW5kXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIG44cjtcblxuICAgICAgICAgICAgY29uc3QgeiA9IEZyLm11bChudW1BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgbjhyKSwgZGVuQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIG44cikpO1xuICAgICAgICAgICAgbnVtQXJyLnNldCh6LCBpX3NGcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGcm9tIG5vdyBvbiB0aGUgdmFsdWVzIHNhdmVkIG9uIG51bUFyciB3aWxsIGJlIFooWCkgYnVmZmVyXG4gICAgICAgIGJ1ZmZlcnMuWiA9IG51bUFycjtcblxuICAgICAgICBpZiAoIUZyLmVxKG51bUFyci5zbGljZSgwLCBuOHIpLCBGci5vbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3B5IGNvbnN0cmFpbnRzIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cyB6KFgpIGZyb20gYnVmZmVycy5aXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgWiBpZmZ0XCIpO1xuICAgICAgICBwb2x5bm9taWFscy5aID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5aLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBDb21wdXRlIGV4dGVuZGVkIGV2YWx1YXRpb25zIG9mIHooWCkgcG9seW5vbWlhbFxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIFogZmZ0XCIpO1xuICAgICAgICBldmFsdWF0aW9ucy5aID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuWiwgNCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gQmxpbmQgeihYKSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cyB3aXRoIGJsaW5kaW5nIHNjYWxhcnMgYlxuICAgICAgICBwb2x5bm9taWFscy5aLmJsaW5kQ29lZmZpY2llbnRzKFtjaGFsbGVuZ2VzLmJbOV0sIGNoYWxsZW5nZXMuYls4XSwgY2hhbGxlbmdlcy5iWzddXSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgIGlmIChwb2x5bm9taWFscy5aLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSArIDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlogUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuWjtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDMoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZSBhbHBoYVwiKTtcblxuICAgICAgICAvLyBTVEVQIDMuMSAtIENvbXB1dGUgZXZhbHVhdGlvbiBjaGFsbGVuZ2UgYWxwaGEg4oiIIEZcbiAgICAgICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmJldGEpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJaXCIpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLmFscGhhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgY2hhbGxlbmdlcy5hbHBoYTIgPSBGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmFscGhhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYWxwaGEsIDE2KSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBxdW90aWVudCBwb2x5bm9taWFsIFQoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgVCBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlVCgpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgW1QxXV8xLCBbVDJdXzEsIFtUM11fMVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBUIE1TTVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFQxID0gYXdhaXQgcG9seW5vbWlhbHMuVDEubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlQxXCIpO1xuICAgICAgICBsZXQgY29tbWl0VDIgPSBhd2FpdCBwb2x5bm9taWFscy5UMi5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiVDJcIik7XG4gICAgICAgIGxldCBjb21taXRUMyA9IGF3YWl0IHBvbHlub21pYWxzLlQzLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJUM1wiKTtcblxuICAgICAgICAvLyBUaGlyZCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW1QxXV8xLCBbVDJdXzEsIFtUM11fMSlcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlQxXCIsIGNvbW1pdFQxKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlQyXCIsIGNvbW1pdFQyKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlQzXCIsIGNvbW1pdFQzKTsgICAgICAgIFxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVUKCkge1xuICAgICAgICBpZiAobG9nZ2VyKVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGDCt8K3wrcgUmVhZGluZyBzZWN0aW9ucyAke1pLRVlfUExfUUxfU0VDVElPTn0sICR7WktFWV9QTF9RUl9TRUNUSU9OfWAgK1xuICAgICAgICAgICAgICAgIGAsICR7WktFWV9QTF9RTV9TRUNUSU9OfSwgJHtaS0VZX1BMX1FPX1NFQ1RJT059LCAke1pLRVlfUExfUUNfU0VDVElPTn0uIFEgc2VsZWN0b3JzYCk7XG4gICAgICAgIC8vIFJlc2VydmUgbWVtb3J5IGZvciBRJ3MgZXZhbHVhdGlvbnNcbiAgICAgICAgZXZhbHVhdGlvbnMuUUwgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBldmFsdWF0aW9ucy5RUiA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zLlFNID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuUU8gPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBldmFsdWF0aW9ucy5RQyA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gUmVhZCBRJ3MgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTC5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfUUxfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFSLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RUl9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUU0uZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1FNX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTy5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfUU9fU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFDLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RQ19TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG5cbiAgICAgICAgLy8gUmVhZCBMYWdyYW5nZSBwb2x5bm9taWFscyAmIGV2YWx1YXRpb25zIGZyb20gemtleSBmaWxlXG4gICAgICAgIGV2YWx1YXRpb25zLkxhZ3JhbmdlID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQgKiB6a2V5Lm5QdWJsaWMpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLkxhZ3JhbmdlLmV2YWwsIGkgKiBzRG9tYWluICogNCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX0xBR1JBTkdFX1NFQ1RJT05dWzBdLnAgKyBpICogNSAqIHNEb21haW4gKyBzRG9tYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlcnMuVCA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpO1xuICAgICAgICBidWZmZXJzLlR6ID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBUIGV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZSAqIDQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKVxuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgICAgICAgVCBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemUgKiA0fWApO1xuXG4gICAgICAgICAgICBjb25zdCBhID0gZXZhbHVhdGlvbnMuQS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgYiA9IGV2YWx1YXRpb25zLkIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBldmFsdWF0aW9ucy5DLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCB6ID0gZXZhbHVhdGlvbnMuWi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgencgPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oKHprZXkuZG9tYWluU2l6ZSAqIDQgKyA0ICsgaSkgJSAoemtleS5kb21haW5TaXplICogNCkpO1xuXG4gICAgICAgICAgICBjb25zdCBxbSA9IGV2YWx1YXRpb25zLlFNLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxbCA9IGV2YWx1YXRpb25zLlFMLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxciA9IGV2YWx1YXRpb25zLlFSLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxbyA9IGV2YWx1YXRpb25zLlFPLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBxYyA9IGV2YWx1YXRpb25zLlFDLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IGV2YWx1YXRpb25zLlNpZ21hMS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgczIgPSBldmFsdWF0aW9ucy5TaWdtYTIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IHMzID0gZXZhbHVhdGlvbnMuU2lnbWEzLmdldEV2YWx1YXRpb24oaSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFwID0gRnIuYWRkKGNoYWxsZW5nZXMuYlsyXSwgRnIubXVsKGNoYWxsZW5nZXMuYlsxXSwgdykpO1xuICAgICAgICAgICAgY29uc3QgYnAgPSBGci5hZGQoY2hhbGxlbmdlcy5iWzRdLCBGci5tdWwoY2hhbGxlbmdlcy5iWzNdLCB3KSk7XG4gICAgICAgICAgICBjb25zdCBjcCA9IEZyLmFkZChjaGFsbGVuZ2VzLmJbNl0sIEZyLm11bChjaGFsbGVuZ2VzLmJbNV0sIHcpKTtcblxuICAgICAgICAgICAgY29uc3QgdzIgPSBGci5zcXVhcmUodyk7XG4gICAgICAgICAgICBjb25zdCB6cCA9IEZyLmFkZChGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYls3XSwgdzIpLCBGci5tdWwoY2hhbGxlbmdlcy5iWzhdLCB3KSksIGNoYWxsZW5nZXMuYls5XSk7XG4gICAgICAgICAgICBjb25zdCB3VyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgICAgIGNvbnN0IHdXMiA9IEZyLnNxdWFyZSh3Vyk7XG4gICAgICAgICAgICBjb25zdCB6V3AgPSBGci5hZGQoRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJbN10sIHdXMiksIEZyLm11bChjaGFsbGVuZ2VzLmJbOF0sIHdXKSksIGNoYWxsZW5nZXMuYls5XSk7XG5cbiAgICAgICAgICAgIGxldCBwaSA9IEZyLnplcm87XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHprZXkublB1YmxpYzsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKGogKiA0ICogemtleS5kb21haW5TaXplKSArIGk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsUG9sID0gZXZhbHVhdGlvbnMuTGFncmFuZ2UuZ2V0RXZhbHVhdGlvbihvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFWYWwgPSBidWZmZXJzLkEuc2xpY2UoaiAqIG44ciwgKGogKyAxKSAqIG44cik7XG5cbiAgICAgICAgICAgICAgICBwaSA9IEZyLnN1YihwaSwgRnIubXVsKGxQb2wsIGFWYWwpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZTEgOj0gYShYKWIoWClxTShYKSArIGEoWClxTChYKSArIGIoWClxUihYKSArIGMoWClxTyhYKSArIFBJKFgpICsgcUMoWClcbiAgICAgICAgICAgIGxldCBbZTEsIGUxel0gPSBNdWxaLm11bDIoYSwgYiwgYXAsIGJwLCBpICUgNCwgRnIpO1xuICAgICAgICAgICAgZTEgPSBGci5tdWwoZTEsIHFtKTtcbiAgICAgICAgICAgIGUxeiA9IEZyLm11bChlMXosIHFtKTtcblxuICAgICAgICAgICAgZTEgPSBGci5hZGQoZTEsIEZyLm11bChhLCBxbCkpO1xuICAgICAgICAgICAgZTF6ID0gRnIuYWRkKGUxeiwgRnIubXVsKGFwLCBxbCkpO1xuXG4gICAgICAgICAgICBlMSA9IEZyLmFkZChlMSwgRnIubXVsKGIsIHFyKSk7XG4gICAgICAgICAgICBlMXogPSBGci5hZGQoZTF6LCBGci5tdWwoYnAsIHFyKSk7XG5cbiAgICAgICAgICAgIGUxID0gRnIuYWRkKGUxLCBGci5tdWwoYywgcW8pKTtcbiAgICAgICAgICAgIGUxeiA9IEZyLmFkZChlMXosIEZyLm11bChjcCwgcW8pKTtcblxuICAgICAgICAgICAgZTEgPSBGci5hZGQoZTEsIHBpKTtcbiAgICAgICAgICAgIGUxID0gRnIuYWRkKGUxLCBxYyk7XG5cbiAgICAgICAgICAgIC8vIGUyIDo9IM6xWyhhKFgpICsgzrJYICsgzrMpKGIoWCkgKyDOsmsxWCArIM6zKShjKFgpICsgzrJrMlggKyDOsyl6KFgpXVxuICAgICAgICAgICAgY29uc3QgYmV0YXcgPSBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCB3KTtcbiAgICAgICAgICAgIGxldCBlMmEgPSBhO1xuICAgICAgICAgICAgZTJhID0gRnIuYWRkKGUyYSwgYmV0YXcpO1xuICAgICAgICAgICAgZTJhID0gRnIuYWRkKGUyYSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlMmIgPSBiO1xuICAgICAgICAgICAgZTJiID0gRnIuYWRkKGUyYiwgRnIubXVsKGJldGF3LCB6a2V5LmsxKSk7XG4gICAgICAgICAgICBlMmIgPSBGci5hZGQoZTJiLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUyYyA9IGM7XG4gICAgICAgICAgICBlMmMgPSBGci5hZGQoZTJjLCBGci5tdWwoYmV0YXcsIHprZXkuazIpKTtcbiAgICAgICAgICAgIGUyYyA9IEZyLmFkZChlMmMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTJkID0gejtcblxuICAgICAgICAgICAgbGV0IFtlMiwgZTJ6XSA9IE11bFoubXVsNChlMmEsIGUyYiwgZTJjLCBlMmQsIGFwLCBicCwgY3AsIHpwLCBpICUgNCwgRnIpO1xuICAgICAgICAgICAgZTIgPSBGci5tdWwoZTIsIGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICAgICAgZTJ6ID0gRnIubXVsKGUyeiwgY2hhbGxlbmdlcy5hbHBoYSk7XG5cbiAgICAgICAgICAgIC8vIGUzIDo9IM6xWyhhKFgpICsgzrJTz4MxKFgpICsgzrMpKGIoWCkgKyDOslPPgzIoWCkgKyDOsykoYyhYKSArIM6yU8+DMyhYKSArIM6zKXooWM+JKV1cbiAgICAgICAgICAgIGxldCBlM2EgPSBhO1xuICAgICAgICAgICAgZTNhID0gRnIuYWRkKGUzYSwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgczEpKTtcbiAgICAgICAgICAgIGUzYSA9IEZyLmFkZChlM2EsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTNiID0gYjtcbiAgICAgICAgICAgIGUzYiA9IEZyLmFkZChlM2IsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHMyKSk7XG4gICAgICAgICAgICBlM2IgPSBGci5hZGQoZTNiLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUzYyA9IGM7XG4gICAgICAgICAgICBlM2MgPSBGci5hZGQoZTNjLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBzMykpO1xuICAgICAgICAgICAgZTNjID0gRnIuYWRkKGUzYywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlM2QgPSB6dztcbiAgICAgICAgICAgIGxldCBbZTMsIGUzel0gPSBNdWxaLm11bDQoZTNhLCBlM2IsIGUzYywgZTNkLCBhcCwgYnAsIGNwLCB6V3AsIGkgJSA0LCBGcik7XG5cbiAgICAgICAgICAgIGUzID0gRnIubXVsKGUzLCBjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICAgICAgICAgIGUzeiA9IEZyLm11bChlM3osIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgICAgICAgICAvLyBlNCA6PSDOsV4yKHooWCniiJIxKUwxKFgpXG4gICAgICAgICAgICBsZXQgZTQgPSBGci5zdWIoeiwgRnIub25lKTtcbiAgICAgICAgICAgIGU0ID0gRnIubXVsKGU0LCBldmFsdWF0aW9ucy5MYWdyYW5nZS5nZXRFdmFsdWF0aW9uKGkpKTtcbiAgICAgICAgICAgIGU0ID0gRnIubXVsKGU0LCBjaGFsbGVuZ2VzLmFscGhhMik7XG5cbiAgICAgICAgICAgIGxldCBlNHogPSBGci5tdWwoenAsIGV2YWx1YXRpb25zLkxhZ3JhbmdlLmdldEV2YWx1YXRpb24oaSkpO1xuICAgICAgICAgICAgZTR6ID0gRnIubXVsKGU0eiwgY2hhbGxlbmdlcy5hbHBoYTIpO1xuXG5cbiAgICAgICAgICAgIGxldCB0ID0gRnIuYWRkKEZyLnN1YihGci5hZGQoZTEsIGUyKSwgZTMpLCBlNCk7XG4gICAgICAgICAgICBsZXQgdHogPSBGci5hZGQoRnIuc3ViKEZyLmFkZChlMXosIGUyeiksIGUzeiksIGU0eik7XG5cbiAgICAgICAgICAgIGJ1ZmZlcnMuVC5zZXQodCwgaSAqIG44cik7XG4gICAgICAgICAgICBidWZmZXJzLlR6LnNldCh0eiwgaSAqIG44cik7XG5cbiAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1t6a2V5LnBvd2VyICsgMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQwKFgpIGZyb20gYnVmZmVycy5UMFxuICAgICAgICBpZiAobG9nZ2VyKVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBUIGlmZnRcIik7XG4gICAgICAgIHBvbHlub21pYWxzLlQgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIERpdmlkZSB0aGUgcG9seW5vbWlhbCBUMCBieSBaX0goWClcbiAgICAgICAgaWYgKGxvZ2dlcilcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgVCAvIFpIXCIpO1xuICAgICAgICBwb2x5bm9taWFscy5ULmRpdlpoKHprZXkuZG9tYWluU2l6ZSwgNCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFR6KFgpIGZyb20gYnVmZmVycy5UelxuICAgICAgICBpZiAobG9nZ2VyKVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBUeiBpZmZ0XCIpO1xuICAgICAgICBwb2x5bm9taWFscy5UeiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVHosIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgcG9seW5vbWlhbCBUMXogdG8gVDEgdG8gZ2V0IHRoZSBmaW5hbCBwb2x5bm9taWFsIFQxXG4gICAgICAgIHBvbHlub21pYWxzLlQuYWRkKHBvbHlub21pYWxzLlR6KTtcblxuICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgaWYgKHBvbHlub21pYWxzLlQuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICogMyArIDYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlQgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdCh4KSBoYXMgZGVncmVlIDNuICsgNSwgd2UgYXJlIGdvaW5nIHRvIHNwbGl0IHQoeCkgaW50byB0aHJlZSBzbWFsbGVyIHBvbHlub21pYWxzOlxuICAgICAgICAvLyBUMScgYW5kIFQyJyAgd2l0aCBhIGRlZ3JlZSA8IG4gYW5kIFQzJyB3aXRoIGEgZGVncmVlIG4rNVxuICAgICAgICAvLyBzdWNoIHRoYXQgdCh4KSA9IFQxJyhYKSArIFhebiBUMicoWCkgKyBYXnsybn0gVDMnKFgpXG4gICAgICAgIC8vIFRvIHJhbmRvbWl6ZSB0aGUgcGFydHMgd2UgdXNlIGJsaW5kaW5nIHNjYWxhcnMgYl8xMCBhbmQgYl8xMSBpbiBhIHdheSB0aGF0IGRvZXNuJ3QgY2hhbmdlIHQoWCk6XG4gICAgICAgIC8vIFQxKFgpID0gVDEnKFgpICsgYl8xMCBYXm5cbiAgICAgICAgLy8gVDIoWCkgPSBUMicoWCkgLSBiXzEwICsgYl8xMSBYXm5cbiAgICAgICAgLy8gVDMoWCkgPSBUMycoWCkgLSBiXzExXG4gICAgICAgIC8vIHN1Y2ggdGhhdFxuICAgICAgICAvLyB0KFgpID0gVDEoWCkgKyBYXm4gVDIoWCkgKyBYXjJuIFQzKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgVDEsIFQyLCBUMyBwb2x5bm9taWFsc1wiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDEgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKCh6a2V5LmRvbWFpblNpemUgKyAxKSAqIG44ciksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5UMiA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDEpICogbjhyKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlQzID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgNikgKiBuOHIpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICBwb2x5bm9taWFscy5UMS5jb2VmLnNldChwb2x5bm9taWFscy5ULmNvZWYuc2xpY2UoMCwgc0RvbWFpbiksIDApO1xuICAgICAgICBwb2x5bm9taWFscy5UMi5jb2VmLnNldChwb2x5bm9taWFscy5ULmNvZWYuc2xpY2Uoc0RvbWFpbiwgc0RvbWFpbiAqIDIpLCAwKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDMuY29lZi5zZXQocG9seW5vbWlhbHMuVC5jb2VmLnNsaWNlKHNEb21haW4gKiAyLCBzRG9tYWluICogMyArIDYgKiBuOHIpLCAwKTtcblxuICAgICAgICAvLyBBZGQgYmxpbmRpbmcgc2NhbGFyIGJfMTAgYXMgYSBuZXcgY29lZmZpY2llbnQgblxuICAgICAgICBwb2x5bm9taWFscy5UMS5zZXRDb2VmKHprZXkuZG9tYWluU2l6ZSwgY2hhbGxlbmdlcy5iWzEwXSk7XG5cbiAgICAgICAgLy8gY29tcHV0ZSB0X21pZChYKVxuICAgICAgICAvLyBTdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMCB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfbWlkXG4gICAgICAgIGNvbnN0IGxvd2VzdE1pZCA9IEZyLnN1Yihwb2x5bm9taWFscy5UMi5nZXRDb2VmKDApLCBjaGFsbGVuZ2VzLmJbMTBdKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDIuc2V0Q29lZigwLCBsb3dlc3RNaWQpO1xuICAgICAgICBwb2x5bm9taWFscy5UMi5zZXRDb2VmKHprZXkuZG9tYWluU2l6ZSwgY2hhbGxlbmdlcy5iWzExXSk7XG5cbiAgICAgICAgLy8gY29tcHV0ZSB0X2hpZ2goWClcbiAgICAgICAgLy9TdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMSB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfaGlnaFxuICAgICAgICBjb25zdCBsb3dlc3RIaWdoID0gRnIuc3ViKHBvbHlub21pYWxzLlQzLmdldENvZWYoMCksIGNoYWxsZW5nZXMuYlsxMV0pO1xuICAgICAgICBwb2x5bm9taWFscy5UMy5zZXRDb2VmKDAsIGxvd2VzdEhpZ2gpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kNCgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIHhpXCIpO1xuXG4gICAgICAgIC8vIFNURVAgNC4xIC0gQ29tcHV0ZSBldmFsdWF0aW9uIGNoYWxsZW5nZSB4aSDiiIggRlxuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIlQxXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJUMlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiVDNcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMueGkgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBjaGFsbGVuZ2VzLnhpdyA9IEZyLm11bChjaGFsbGVuZ2VzLnhpLCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBjaGFsbGVuZ2VzLnhpOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMueGksIDE2KSk7ICBcblxuICAgICAgICAvLyBGb3VydGggb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKCBhKHhpKSwgYih4aSksIGMoeGkpLCBzMSh4aSksIHMyKHhpKSwgeih4aXcpIClcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfYVwiLCBwb2x5bm9taWFscy5BLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfYlwiLCBwb2x5bm9taWFscy5CLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfY1wiLCBwb2x5bm9taWFscy5DLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfczFcIiwgcG9seW5vbWlhbHMuU2lnbWExLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfczJcIiwgcG9seW5vbWlhbHMuU2lnbWEyLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImV2YWxfendcIiwgcG9seW5vbWlhbHMuWi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpdykpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kNSgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIHZcIik7XG4gICAgICAgIFxuICAgICAgICAvLyBTVEVQIDUuMSAtIENvbXB1dGUgZXZhbHVhdGlvbiBjaGFsbGVuZ2UgdiDiiIggRlxuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMueGkpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiZXZhbF9hXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImV2YWxfYlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJldmFsX2NcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiZXZhbF9zMVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJldmFsX3MyXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImV2YWxfendcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMudiA9IFtdO1xuICAgICAgICBjaGFsbGVuZ2VzLnZbMV0gPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgY2hhbGxlbmdlcy52OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMudlsxXSwgMTYpKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgY2hhbGxlbmdlcy52W2ldID0gRnIubXVsKGNoYWxsZW5nZXMudltpIC0gMV0sIGNoYWxsZW5nZXMudlsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDUuMiBDb21wdXRlIGxpbmVhcmlzYXRpb24gcG9seW5vbWlhbCByKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIGxpbmVhcmlzYXRpb24gcG9seW5vbWlhbCBSKFgpXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlUigpO1xuXG4gICAgICAgIC8vU1RFUCA1LjMgQ29tcHV0ZSBvcGVuaW5nIHByb29mIHBvbHlub21pYWwgV3hpKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIG9wZW5pbmcgcHJvb2YgcG9seW5vbWlhbCBXeGkoWCkgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgY29tcHV0ZVd4aSgpO1xuXG4gICAgICAgIC8vU1RFUCA1LjQgQ29tcHV0ZSBvcGVuaW5nIHByb29mIHBvbHlub21pYWwgV3hpdyhYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBvcGVuaW5nIHByb29mIHBvbHlub21pYWwgV3hpdyhYKSBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb21wdXRlV3hpdygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIFd4aSwgV3hpdyBNU01cIik7XG4gICAgICAgIGxldCBjb21taXRXeGkgPSBhd2FpdCBwb2x5bm9taWFscy5XeGkubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIld4aVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFd4aXcgPSBhd2FpdCBwb2x5bm9taWFscy5XeGl3Lm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJXeGl3XCIpO1xuXG4gICAgICAgIC8vIEZpZnRoIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbV3hpXV8xLCBbV3hpd11fMSlcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIld4aVwiLCBjb21taXRXeGkpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiV3hpd1wiLCBjb21taXRXeGl3KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlUigpIHtcbiAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBcbiAgICAgICAgLy8gUmVzZXJ2ZSBtZW1vcnkgZm9yIFEncyBwb2x5bm9taWFsc1xuICAgICAgICBwb2x5bm9taWFscy5RTCA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RUiA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RTSA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RTyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5RQyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIFJlYWQgUSdzIGV2YWx1YXRpb25zIGZyb20gemtleSBmaWxlXG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUUwuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfUUxfU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUVIuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfUVJfU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUU0uY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfUU1fU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUU8uY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfUU9fU0VDVElPTl1bMF0ucCk7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuUUMuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfUUNfU0VDVElPTl1bMF0ucCk7ICAgXG4gICAgICAgIFxuICAgICAgICBjaGFsbGVuZ2VzLnhpbiA9IGNoYWxsZW5nZXMueGk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5wb3dlcjsgaSsrKSB7XG4gICAgICAgICAgICBjaGFsbGVuZ2VzLnhpbiA9IEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpbik7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFsbGVuZ2VzLnpoID0gRnIuc3ViKGNoYWxsZW5nZXMueGluLCBGci5vbmUpO1xuXG4gICAgICAgIGNvbnN0IEwgPSBbXTtcblxuICAgICAgICBjb25zdCBuID0gRnIuZSh6a2V5LmRvbWFpblNpemUpO1xuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gTWF0aC5tYXgoMSwgemtleS5uUHVibGljKTsgaSsrKSB7XG4gICAgICAgICAgICBMW2ldID0gRnIuZGl2KEZyLm11bCh3LCBjaGFsbGVuZ2VzLnpoKSwgRnIubXVsKG4sIEZyLnN1YihjaGFsbGVuZ2VzLnhpLCB3KSkpO1xuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV2YWxfbDEgPSBGci5kaXYoXG4gICAgICAgICAgICBGci5zdWIoY2hhbGxlbmdlcy54aW4sIEZyLm9uZSksXG4gICAgICAgICAgICBGci5tdWwobiwgRnIuc3ViKGNoYWxsZW5nZXMueGksIEZyLm9uZSkpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiTGFncmFuZ2UgRXZhbHVhdGlvbnM6IFwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MTsgaTxMLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBMJHtpfSh4aSk9YCArIEZyLnRvU3RyaW5nKExbaV0sIDE2KSk7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGV2YWxfcGkgPSBGci56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cHVibGljU2lnbmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdyA9IEZyLmUocHVibGljU2lnbmFsc1tpXSk7XG4gICAgICAgICAgICBldmFsX3BpID0gRnIuc3ViKGV2YWxfcGksIEZyLm11bCh3LCBMW2krMV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlBJOiBcIiArIEZyLnRvU3RyaW5nKGV2YWxfcGksIDE2KSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBjb25zdGFudCBwYXJ0cyBvZiBSKFgpXG4gICAgICAgIGNvbnN0IGNvZWZfYWIgPSBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9hLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2IpO1xuXG4gICAgICAgIGxldCBlMmEgPSBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2E7XG4gICAgICAgIGNvbnN0IGJldGF4aSA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGNoYWxsZW5nZXMueGkpO1xuICAgICAgICBlMmEgPSBGci5hZGQoZTJhLCBiZXRheGkpO1xuICAgICAgICBlMmEgPSBGci5hZGQoZTJhLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICBsZXQgZTJiID0gcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9iO1xuICAgICAgICBlMmIgPSBGci5hZGQoZTJiLCBGci5tdWwoYmV0YXhpLCB6a2V5LmsxKSk7XG4gICAgICAgIGUyYiA9IEZyLmFkZChlMmIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgIGxldCBlMmMgPSBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2M7XG4gICAgICAgIGUyYyA9IEZyLmFkZChlMmMsIEZyLm11bChiZXRheGksIHprZXkuazIpKTtcbiAgICAgICAgZTJjID0gRnIuYWRkKGUyYywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgY29uc3QgZTIgPSBGci5tdWwoRnIubXVsKEZyLm11bChlMmEsIGUyYiksIGUyYyksIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgICAgIGxldCBlM2EgPSBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2E7XG4gICAgICAgIGUzYSA9IEZyLmFkZChlM2EsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLmV2YWxfczEpKTtcbiAgICAgICAgZTNhID0gRnIuYWRkKGUzYSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgbGV0IGUzYiA9IHByb29mLmV2YWx1YXRpb25zLmV2YWxfYjtcbiAgICAgICAgZTNiID0gRnIuYWRkKGUzYiwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9zMikpO1xuICAgICAgICBlM2IgPSBGci5hZGQoZTNiLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICBsZXQgZTMgPSBGci5tdWwoZTNhLCBlM2IpO1xuICAgICAgICBlMyA9IEZyLm11bChlMywgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF96dyk7XG4gICAgICAgIGUzID0gRnIubXVsKGUzLCBjaGFsbGVuZ2VzLmFscGhhKTtcblxuICAgICAgICBjb25zdCBlNCA9IEZyLm11bChldmFsX2wxLCBjaGFsbGVuZ2VzLmFscGhhMik7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuUiA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDYpICogbjhyKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGQocG9seW5vbWlhbHMuUU0sIGNvZWZfYWIpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5RTCwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9hKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGQocG9seW5vbWlhbHMuUVIsIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYik7XG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkKHBvbHlub21pYWxzLlFPLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2MpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5RQyk7XG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkKHBvbHlub21pYWxzLlosIGUyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUi5zdWIocG9seW5vbWlhbHMuU2lnbWEzLCBGci5tdWwoZTMsIGNoYWxsZW5nZXMuYmV0YSkpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5aLCBlNCk7XG5cbiAgICAgICAgbGV0IHRtcCA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuVDMsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICB0bXAubXVsU2NhbGFyKEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpbikpO1xuICAgICAgICB0bXAuYWRkKHBvbHlub21pYWxzLlQyLCBjaGFsbGVuZ2VzLnhpbik7XG4gICAgICAgIHRtcC5hZGQocG9seW5vbWlhbHMuVDEpO1xuICAgICAgICB0bXAubXVsU2NhbGFyKGNoYWxsZW5nZXMuemgpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLlIuc3ViKHRtcCk7XG5cbiAgICAgICAgbGV0IHIwID0gRnIuc3ViKGV2YWxfcGksIEZyLm11bChlMywgRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmV2YWxfYywgY2hhbGxlbmdlcy5nYW1tYSkpKTtcbiAgICAgICAgcjAgPSBGci5zdWIocjAsIGU0KTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJyMDogXCIgKyBGci50b1N0cmluZyhyMCwgMTYpKTtcblxuICAgICAgICBwb2x5bm9taWFscy5SLmFkZFNjYWxhcihyMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVd4aSgpIHtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluICsgNiAqIG44ciksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLld4aS5hZGQocG9seW5vbWlhbHMuUik7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5hZGQocG9seW5vbWlhbHMuQSwgY2hhbGxlbmdlcy52WzFdKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLmFkZChwb2x5bm9taWFscy5CLCBjaGFsbGVuZ2VzLnZbMl0pO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuYWRkKHBvbHlub21pYWxzLkMsIGNoYWxsZW5nZXMudlszXSk7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5hZGQocG9seW5vbWlhbHMuU2lnbWExLCBjaGFsbGVuZ2VzLnZbNF0pO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuYWRkKHBvbHlub21pYWxzLlNpZ21hMiwgY2hhbGxlbmdlcy52WzVdKTtcblxuICAgICAgICBwb2x5bm9taWFscy5XeGkuc3ViU2NhbGFyKEZyLm11bChjaGFsbGVuZ2VzLnZbMV0sIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYSkpO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuc3ViU2NhbGFyKEZyLm11bChjaGFsbGVuZ2VzLnZbMl0sIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYikpO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuc3ViU2NhbGFyKEZyLm11bChjaGFsbGVuZ2VzLnZbM10sIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYykpO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuc3ViU2NhbGFyKEZyLm11bChjaGFsbGVuZ2VzLnZbNF0sIHByb29mLmV2YWx1YXRpb25zLmV2YWxfczEpKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLnN1YlNjYWxhcihGci5tdWwoY2hhbGxlbmdlcy52WzVdLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX3MyKSk7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLmRpdkJ5WmVyb2ZpZXIoMSwgY2hhbGxlbmdlcy54aSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVd4aXcoKSB7XG4gICAgICAgIHBvbHlub21pYWxzLld4aXcgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLlosIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5XeGl3LnN1YlNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX3p3KTtcblxuICAgICAgICBwb2x5bm9taWFscy5XeGl3LmRpdkJ5WmVyb2ZpZXIoMSwgY2hhbGxlbmdlcy54aXcpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/plonk_prove.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/plonk_setup.js":
/*!*************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_setup.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkSetup)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(ssr)/./node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bigarray.js */ \"(ssr)/./node_modules/snarkjs/src/bigarray.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\n\n\n\n\n\n\n\n\nasync function plonkSetup(r1csName, ptauName, zkeyName, logger) {\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const {fd: fdPTau, sections: sectionsPTau} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csFd)(fdR1cs, sectionsR1cs, {loadConstraints: true, loadCustomGates: true});\n\n    const sG1 = curve.G1.F.n8*2;\n    const G1 = curve.G1;\n    const sG2 = curve.G2.F.n8*2;\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdR1cs, sectionsR1cs, 2);\n\n    const plonkConstraints = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n    const plonkAdditions = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n    let plonkNVars = r1cs.nVars;\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n\n    await processConstraints(curve.Fr, r1cs, logger);\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyName, \"zkey\", 1, 14, 1<<22, 1<<24);\n\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    let cirPower = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(plonkConstraints.length -1) +1;\n    if (cirPower < 3) cirPower = 3;   // As the t polynomial is n+5 we need at least a power of 4\n    const domainSize = 2 ** cirPower;\n\n    if (logger) logger.info(\"Plonk constraints: \" + plonkConstraints.length);\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${plonkConstraints.length} > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n\n    const LPoints = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*sG1);\n    const o = sectionsPTau[12][0].p + ((2 ** (cirPower)) -1)*sG1;\n    await fdPTau.readToBuffer(LPoints, 0, domainSize*sG1, o);\n\n    const [k1, k2] = getK1K2();\n\n    const vk = {};\n\n\n    await writeAdditions(3, \"Additions\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(4, 0, \"Amap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(5, 1, \"Bmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(6, 2, \"Cmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(7, 3, \"Qm\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(8, 4, \"Ql\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(9, 5, \"Qr\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(10, 6, \"Qo\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(11, 7, \"Qc\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeSigma(12, \"sigma\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeLs(13, \"lagrange polynomials\");\n    if (globalThis.gc) {globalThis.gc();}\n\n    // Write PTau points\n    ////////////\n\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 14);\n    const buffOut = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((domainSize+6)*sG1);\n    await fdPTau.readToBuffer(buffOut, 0, (domainSize+6)*sG1, sectionsPTau[2][0].p);\n    await fdZKey.write(buffOut);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    if (globalThis.gc) {globalThis.gc();}\n\n\n    await writeHeaders();\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"Setup Finished\");\n\n    return ;\n\n    async function processConstraints(Fr, r1cs, logger) {\n\n        function normalize(linearComb) {\n            const ss = Object.keys(linearComb);\n            for (let i = 0; i < ss.length; i++) {\n                if (linearComb[ss[i]] == 0n) delete linearComb[ss[i]];\n            }\n        }\n\n        function join(linearComb1, k, linearComb2) {\n            const res = {};\n\n            for (let s in linearComb1) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = Fr.mul(k, linearComb1[s]);\n                } else {\n                    res[s] = Fr.add(res[s], Fr.mul(k, linearComb1[s]));\n                }\n            }\n\n            for (let s in linearComb2) {\n                const val = Fr.neg(linearComb2[s]);\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = val;\n                } else {\n                    res[s] = Fr.add(res[s], val);\n                }\n            }\n            normalize(res);\n            return res;\n        }\n\n        function reduceCoefs(linearComb, maxC) {\n            const res = {\n                k: Fr.zero,\n                s: [],\n                coefs: []\n            };\n            const cs = [];\n\n            for (let s in linearComb) {\n                if (s == 0) {\n                    res.k = Fr.add(res.k, linearComb[s]);\n                } else if (linearComb[s] != 0n) {\n                    cs.push([Number(s), linearComb[s]])\n                }\n            }\n            while (cs.length > maxC) {\n                const c1 = cs.shift();\n                const c2 = cs.shift();\n\n                const sl = c1[0];\n                const sr = c2[0];\n                const so = plonkNVars++;\n                const qm = Fr.zero;\n                const ql = Fr.neg(c1[1]);\n                const qr = Fr.neg(c2[1]);\n                const qo = Fr.one;\n                const qc = Fr.zero;\n\n                plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n\n                plonkAdditions.push([sl, sr, c1[1], c2[1]]);\n\n                cs.push([so, Fr.one]);\n            }\n            for (let i = 0; i < cs.length; i++) {\n                res.s[i] = cs[i][0];\n                res.coefs[i] = cs[i][1];\n            }\n            while (res.coefs.length < maxC) {\n                res.s.push(0);\n                res.coefs.push(Fr.zero);\n            }\n            return res;\n        }\n\n        function addConstraintSum(lc) {\n            const C = reduceCoefs(lc, 3);\n            const sl = C.s[0];\n            const sr = C.s[1];\n            const so = C.s[2];\n            const qm = Fr.zero;\n            const ql = C.coefs[0];\n            const qr = C.coefs[1];\n            const qo = C.coefs[2];\n            const qc = C.k;\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function addConstraintMul(lcA, lcB, lcC) {\n            const A = reduceCoefs(lcA, 1);\n            const B = reduceCoefs(lcB, 1);\n            const C = reduceCoefs(lcC, 1);\n\n\n            const sl = A.s[0];\n            const sr = B.s[0];\n            const so = C.s[0];\n            const qm = Fr.mul(A.coefs[0], B.coefs[0]);\n            const ql = Fr.mul(A.coefs[0], B.k);\n            const qr = Fr.mul(A.k, B.coefs[0]);\n            const qo = Fr.neg(C.coefs[0]);\n            const qc = Fr.sub(Fr.mul(A.k, B.k), C.k);\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function getLinearCombinationType(lc) {\n            let k = Fr.zero;\n            let n = 0;\n            const ss = Object.keys(lc);\n            for (let i = 0; i < ss.length; i++) {\n                if (lc[ss[i]] == 0n) {\n                    delete lc[ss[i]];\n                } else if (ss[i] == 0) {\n                    k = Fr.add(k, lc[ss[i]]);\n                } else {\n                    n++;\n                }\n            }\n            if (n > 0) return n.toString();\n            if (k != Fr.zero) return \"k\";\n            return \"0\";\n        }\n\n        function process(lcA, lcB, lcC) {\n            const lctA = getLinearCombinationType(lcA);\n            const lctB = getLinearCombinationType(lcB);\n            if ((lctA === \"0\") || (lctB === \"0\")) {\n                normalize(lcC);\n                addConstraintSum(lcC);\n            } else if (lctA === \"k\") {\n                const lcCC = join(lcB, lcA[0], lcC);\n                addConstraintSum(lcCC);\n            } else if (lctB === \"k\") {\n                const lcCC = join(lcA, lcB[0], lcC);\n                addConstraintSum(lcCC);\n            } else {\n                addConstraintMul(lcA, lcB, lcC);\n            }\n        }\n\n        for (let s = 1; s <= nPublic; s++) {\n            const sl = s;\n            const sr = 0;\n            const so = 0;\n            const qm = Fr.zero;\n            const ql = Fr.one;\n            const qr = Fr.zero;\n            const qo = Fr.zero;\n            const qc = Fr.zero;\n\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        for (let c = 0; c < r1cs.constraints.length; c++) {\n            if ((logger) && (c % 10000 === 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            process(...r1cs.constraints[c]);\n        }\n    }\n\n    async function writeWitnessMap(sectionNum, posConstraint, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeQMap(sectionNum, posConstraint, name) {\n        let Q = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i*n8r);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        await writeP4(Q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n        Q = await Fr.batchFromMontgomery(Q);\n        vk[name]= await curve.G1.multiExpAffine(LPoints, Q, logger, \"multiexp \"+name);\n    }\n\n    async function writeP4(buff) {\n        const q = await Fr.ifft(buff);\n        const q4 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r*4);\n        q4.set(q, 0);\n        const Q4 = await Fr.fft(q4);\n        await fdZKey.write(q);\n        await fdZKey.write(Q4);\n    }\n\n    async function writeAdditions(sectionNum, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        const buffOut = new Uint8Array((2*4+2*n8r));\n        const buffOutV = new DataView(buffOut.buffer);\n        for (let i=0; i<plonkAdditions.length; i++) {\n            const addition=plonkAdditions[i];\n            let o=0;\n            buffOutV.setUint32(o, addition[0], true); o+=4;\n            buffOutV.setUint32(o, addition[1], true); o+=4;\n            // The value is stored in Montgomery. stored = v*R\n            // so when montgomery multiplied by the witness, it's result = v*R*w/R = v*w\n            buffOut.set(addition[2], o); o+= n8r;\n            buffOut.set(addition[3], o); o+= n8r;\n            await fdZKey.write(buffOut);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkAdditions.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeSigma(sectionNum, name) {\n        const sigma = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(n8r*domainSize*3);\n        const lastAparence =  new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](plonkNVars);\n        const firstPos = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](plonkNVars);\n        let w = Fr.one;\n        for (let i=0; i<domainSize;i++) {\n            if (i<plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], domainSize + i);\n                buildSigma(plonkConstraints[i][2], domainSize*2 + i);\n            } else {\n                buildSigma(0, i);\n                buildSigma(0, domainSize + i);\n                buildSigma(0, domainSize*2 + i);\n            }\n            w = Fr.mul(w, Fr.w[cirPower]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name} phase1: ${i}/${plonkConstraints.length}`);\n        }\n        for (let s=0; s<plonkNVars; s++) {\n            if (typeof firstPos[s] !== \"undefined\") {\n                sigma.set(lastAparence[s], firstPos[s]*n8r);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger)&&(s%1000000 == 0)) logger.debug(`writing ${name} phase2: ${s}/${plonkNVars}`);\n        }\n\n        if (globalThis.gc) {globalThis.gc();}\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        let S1 = sigma.slice(0, domainSize*n8r);\n        await writeP4(S1);\n        if (globalThis.gc) {globalThis.gc();}\n        let S2 = sigma.slice(domainSize*n8r, domainSize*n8r*2);\n        await writeP4(S2);\n        if (globalThis.gc) {globalThis.gc();}\n        let S3 = sigma.slice(domainSize*n8r*2, domainSize*n8r*3);\n        await writeP4(S3);\n        if (globalThis.gc) {globalThis.gc();}\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        S1 = await Fr.batchFromMontgomery(S1);\n        S2 = await Fr.batchFromMontgomery(S2);\n        S3 = await Fr.batchFromMontgomery(S3);\n\n        vk.S1= await curve.G1.multiExpAffine(LPoints, S1, logger, \"multiexp S1\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S2= await curve.G1.multiExpAffine(LPoints, S2, logger, \"multiexp S2\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S3= await curve.G1.multiExpAffine(LPoints, S3, logger, \"multiexp S3\");\n        if (globalThis.gc) {globalThis.gc();}\n\n        function buildSigma(s, p) {\n            if (typeof lastAparence[s] === \"undefined\") {\n                firstPos[s] = p;\n            } else {\n                sigma.set(lastAparence[s], p*n8r);\n            }\n            let v;\n            if (p<domainSize) {\n                v = w;\n            } else if (p<2*domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n            lastAparence[s]=v;\n        }\n    }\n\n    async function writeLs(sectionNum, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        const l=Math.max(nPublic, 1);\n        for (let i=0; i<l; i++) {\n            let buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r);\n            buff.set(Fr.one, i*n8r);\n            await writeP4(buff);\n            if (logger) logger.debug(`writing ${name} ${i}/${l}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeHeaders() {\n\n        // Write the header\n        ///////////\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 1);\n        await fdZKey.writeULE32(2); // Plonk\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        // Write the Plonk header section\n        ///////////\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 2);\n        const primeQ = curve.q;\n        const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n        const primeR = curve.r;\n        const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n        await fdZKey.writeULE32(n8q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n        await fdZKey.writeULE32(n8r);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n        await fdZKey.writeULE32(plonkNVars);                         // Total number of bars\n        await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n        await fdZKey.writeULE32(domainSize);                  // domainSize\n        await fdZKey.writeULE32(plonkAdditions.length);                  // domainSize\n        await fdZKey.writeULE32(plonkConstraints.length); \n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(G1.toAffine(vk.Qm));\n        await fdZKey.write(G1.toAffine(vk.Ql));\n        await fdZKey.write(G1.toAffine(vk.Qr));\n        await fdZKey.write(G1.toAffine(vk.Qo));\n        await fdZKey.write(G1.toAffine(vk.Qc));\n\n        await fdZKey.write(G1.toAffine(vk.S1));\n        await fdZKey.write(G1.toAffine(vk.S2));\n        await fdZKey.write(G1.toAffine(vk.S3));\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, sectionsPTau[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    function getK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize= 2**pow;\n            let w = Fr.one;\n            for (let i=0; i<domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j=0; j<kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfc2V0dXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRW9DO0FBQ1k7QUFRbkI7QUFDSztBQUNlO0FBQ1o7OztBQUd0Qjs7QUFFZix3QkFBd0I7O0FBRXhCLFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7QUFDbEUsV0FBVyxjQUFjLFFBQVEsaUVBQW9CO0FBQ3JELFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7O0FBRWxFLHVCQUF1QixvREFBVSx3QkFBd0IsNkNBQTZDOztBQUV0RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdFQUFXOztBQUVqQyxpQ0FBaUMsb0RBQVE7QUFDekMsK0JBQStCLG9EQUFRO0FBQ3ZDOztBQUVBOztBQUVBOztBQUVBLHdCQUF3Qjs7QUFFeEIseUJBQXlCLGtFQUFhOzs7QUFHdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDhDQUFJO0FBQ3ZCLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0Esb0ZBQW9GLHlCQUF5QixPQUFPLE1BQU07QUFDMUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esd0JBQXdCLG1EQUFTO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBLFVBQVUsc0VBQWlCO0FBQzNCLHdCQUF3QixtREFBUztBQUNqQztBQUNBO0FBQ0EsVUFBVSxvRUFBZTtBQUN6Qix3QkFBd0I7OztBQUd4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsNkJBQTZCO0FBQ3JELHVGQUF1RixFQUFFLEdBQUcsa0JBQWtCO0FBQzlHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCO0FBQy9CLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQSxvRUFBb0UsS0FBSyxJQUFJLEVBQUUsR0FBRyx3QkFBd0I7QUFDMUc7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0Esb0JBQW9CLG1EQUFTO0FBQzdCLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQSxvRUFBb0UsS0FBSyxJQUFJLEVBQUUsR0FBRyx3QkFBd0I7QUFDMUc7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQjtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsbURBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDO0FBQ0Esb0VBQW9FLEtBQUssSUFBSSxFQUFFLEdBQUcsc0JBQXNCO0FBQ3hHO0FBQ0EsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBLDBCQUEwQixtREFBUztBQUNuQyxrQ0FBa0Msb0RBQVE7QUFDMUMsNkJBQTZCLG9EQUFRO0FBQ3JDO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxNQUFNLFVBQVUsRUFBRSxHQUFHLHdCQUF3QjtBQUNqSDtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLE1BQU0sVUFBVSxFQUFFLEdBQUcsV0FBVztBQUNwRzs7QUFFQSw0QkFBNEI7QUFDNUIsY0FBYyxzRUFBaUI7QUFDL0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsY0FBYyxvRUFBZTs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxzRUFBaUI7QUFDL0I7QUFDQSxzQkFBc0IsS0FBSztBQUMzQiwyQkFBMkIsbURBQVM7QUFDcEM7QUFDQTtBQUNBLGdEQUFnRCxNQUFNLEVBQUUsRUFBRSxHQUFHLEVBQUU7QUFDL0Q7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQixvQ0FBb0M7QUFDcEMsY0FBYyxvRUFBZTs7QUFFN0I7QUFDQTs7QUFFQSxjQUFjLHNFQUFpQjtBQUMvQjtBQUNBLGtDQUFrQyxnREFBTTs7QUFFeEM7QUFDQSxrQ0FBa0MsZ0RBQU07O0FBRXhDO0FBQ0EsY0FBYyxnRUFBVztBQUN6QjtBQUNBLGNBQWMsZ0VBQVc7QUFDekIscUVBQXFFO0FBQ3JFLGdFQUFnRTtBQUNoRSw4REFBOEQ7QUFDOUQseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfc2V0dXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMSAwa2ltcyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLyogSW1wbGVtZW50YXRpb24gb2YgdGhpcyBwYXBlcjogaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxOS85NTMucGRmICovXG5cbmltcG9ydCB7cmVhZFIxY3NGZH0gZnJvbSBcInIxY3NmaWxlXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0IHtcbiAgICByZWFkQmluRmlsZSxcbiAgICBjcmVhdGVCaW5GaWxlLFxuICAgIHJlYWRTZWN0aW9uLFxuICAgIHdyaXRlQmlnSW50LFxuICAgIHN0YXJ0V3JpdGVTZWN0aW9uLFxuICAgIGVuZFdyaXRlU2VjdGlvbixcbn0gZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7IGxvZzIgIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgU2NhbGFyLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgQmlnQXJyYXkgZnJvbSBcIi4vYmlnYXJyYXkuanNcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwbG9ua1NldHVwKHIxY3NOYW1lLCBwdGF1TmFtZSwgemtleU5hbWUsIGxvZ2dlcikge1xuXG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuXG4gICAgY29uc3Qge2ZkOiBmZFBUYXUsIHNlY3Rpb25zOiBzZWN0aW9uc1BUYXV9ID0gYXdhaXQgcmVhZEJpbkZpbGUocHRhdU5hbWUsIFwicHRhdVwiLCAxLCAxPDwyMiwgMTw8MjQpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRQVGF1LCBzZWN0aW9uc1BUYXUpO1xuICAgIGNvbnN0IHtmZDogZmRSMWNzLCBzZWN0aW9uczogc2VjdGlvbnNSMWNzfSA9IGF3YWl0IHJlYWRCaW5GaWxlKHIxY3NOYW1lLCBcInIxY3NcIiwgMSwgMTw8MjIsIDE8PDI0KTtcblxuICAgIGNvbnN0IHIxY3MgPSBhd2FpdCByZWFkUjFjc0ZkKGZkUjFjcywgc2VjdGlvbnNSMWNzLCB7bG9hZENvbnN0cmFpbnRzOiB0cnVlLCBsb2FkQ3VzdG9tR2F0ZXM6IHRydWV9KTtcblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IG44ciA9IGN1cnZlLkZyLm44O1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIHIxY3NcIik7XG4gICAgbGV0IHNSMWNzID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRSMWNzLCBzZWN0aW9uc1IxY3MsIDIpO1xuXG4gICAgY29uc3QgcGxvbmtDb25zdHJhaW50cyA9IG5ldyBCaWdBcnJheSgpO1xuICAgIGNvbnN0IHBsb25rQWRkaXRpb25zID0gbmV3IEJpZ0FycmF5KCk7XG4gICAgbGV0IHBsb25rTlZhcnMgPSByMWNzLm5WYXJzO1xuXG4gICAgY29uc3QgblB1YmxpYyA9IHIxY3Mubk91dHB1dHMgKyByMWNzLm5QdWJJbnB1dHM7XG5cbiAgICBhd2FpdCBwcm9jZXNzQ29uc3RyYWludHMoY3VydmUuRnIsIHIxY3MsIGxvZ2dlcik7XG5cbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICBjb25zdCBmZFpLZXkgPSBhd2FpdCBjcmVhdGVCaW5GaWxlKHprZXlOYW1lLCBcInprZXlcIiwgMSwgMTQsIDE8PDIyLCAxPDwyNCk7XG5cblxuICAgIGlmIChyMWNzLnByaW1lICE9IGN1cnZlLnIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwicjFjcyBjdXJ2ZSBkb2VzIG5vdCBtYXRjaCBwb3dlcnMgb2YgdGF1IGNlcmVtb255IGN1cnZlXCIpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgbGV0IGNpclBvd2VyID0gbG9nMihwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCAtMSkgKzE7XG4gICAgaWYgKGNpclBvd2VyIDwgMykgY2lyUG93ZXIgPSAzOyAgIC8vIEFzIHRoZSB0IHBvbHlub21pYWwgaXMgbis1IHdlIG5lZWQgYXQgbGVhc3QgYSBwb3dlciBvZiA0XG4gICAgY29uc3QgZG9tYWluU2l6ZSA9IDIgKiogY2lyUG93ZXI7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlBsb25rIGNvbnN0cmFpbnRzOiBcIiArIHBsb25rQ29uc3RyYWludHMubGVuZ3RoKTtcbiAgICBpZiAoY2lyUG93ZXIgPiBwb3dlcikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYGNpcmN1aXQgdG9vIGJpZyBmb3IgdGhpcyBwb3dlciBvZiB0YXUgY2VyZW1vbnkuICR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9ID4gMioqJHtwb3dlcn1gKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmICghc2VjdGlvbnNQVGF1WzEyXSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQb3dlcnMgb2YgdGF1IGlzIG5vdCBwcmVwYXJlZC5cIik7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cblxuICAgIGNvbnN0IExQb2ludHMgPSBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUqc0cxKTtcbiAgICBjb25zdCBvID0gc2VjdGlvbnNQVGF1WzEyXVswXS5wICsgKCgyICoqIChjaXJQb3dlcikpIC0xKSpzRzE7XG4gICAgYXdhaXQgZmRQVGF1LnJlYWRUb0J1ZmZlcihMUG9pbnRzLCAwLCBkb21haW5TaXplKnNHMSwgbyk7XG5cbiAgICBjb25zdCBbazEsIGsyXSA9IGdldEsxSzIoKTtcblxuICAgIGNvbnN0IHZrID0ge307XG5cblxuICAgIGF3YWl0IHdyaXRlQWRkaXRpb25zKDMsIFwiQWRkaXRpb25zXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVdpdG5lc3NNYXAoNCwgMCwgXCJBbWFwXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVdpdG5lc3NNYXAoNSwgMSwgXCJCbWFwXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVdpdG5lc3NNYXAoNiwgMiwgXCJDbWFwXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVFNYXAoNywgMywgXCJRbVwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVRTWFwKDgsIDQsIFwiUWxcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlUU1hcCg5LCA1LCBcIlFyXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVFNYXAoMTAsIDYsIFwiUW9cIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlUU1hcCgxMSwgNywgXCJRY1wiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVTaWdtYSgxMiwgXCJzaWdtYVwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVMcygxMywgXCJsYWdyYW5nZSBwb2x5bm9taWFsc1wiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICAvLyBXcml0ZSBQVGF1IHBvaW50c1xuICAgIC8vLy8vLy8vLy8vL1xuXG4gICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAxNCk7XG4gICAgY29uc3QgYnVmZk91dCA9IG5ldyBCaWdCdWZmZXIoKGRvbWFpblNpemUrNikqc0cxKTtcbiAgICBhd2FpdCBmZFBUYXUucmVhZFRvQnVmZmVyKGJ1ZmZPdXQsIDAsIChkb21haW5TaXplKzYpKnNHMSwgc2VjdGlvbnNQVGF1WzJdWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShidWZmT3V0KTtcbiAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cblxuICAgIGF3YWl0IHdyaXRlSGVhZGVycygpO1xuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRSMWNzLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRQVGF1LmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlNldHVwIEZpbmlzaGVkXCIpO1xuXG4gICAgcmV0dXJuIDtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDb25zdHJhaW50cyhGciwgcjFjcywgbG9nZ2VyKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKGxpbmVhckNvbWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNzID0gT2JqZWN0LmtleXMobGluZWFyQ29tYik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVhckNvbWJbc3NbaV1dID09IDBuKSBkZWxldGUgbGluZWFyQ29tYltzc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBqb2luKGxpbmVhckNvbWIxLCBrLCBsaW5lYXJDb21iMikge1xuICAgICAgICAgICAgY29uc3QgcmVzID0ge307XG5cbiAgICAgICAgICAgIGZvciAobGV0IHMgaW4gbGluZWFyQ29tYjEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc1tzXSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tzXSA9IEZyLm11bChrLCBsaW5lYXJDb21iMVtzXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3NdID0gRnIuYWRkKHJlc1tzXSwgRnIubXVsKGssIGxpbmVhckNvbWIxW3NdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIGxpbmVhckNvbWIyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gRnIubmVnKGxpbmVhckNvbWIyW3NdKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc1tzXSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tzXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNbc10gPSBGci5hZGQocmVzW3NdLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1hbGl6ZShyZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlZHVjZUNvZWZzKGxpbmVhckNvbWIsIG1heEMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgICAgICBrOiBGci56ZXJvLFxuICAgICAgICAgICAgICAgIHM6IFtdLFxuICAgICAgICAgICAgICAgIGNvZWZzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNzID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IHMgaW4gbGluZWFyQ29tYikge1xuICAgICAgICAgICAgICAgIGlmIChzID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmsgPSBGci5hZGQocmVzLmssIGxpbmVhckNvbWJbc10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZWFyQ29tYltzXSAhPSAwbikge1xuICAgICAgICAgICAgICAgICAgICBjcy5wdXNoKFtOdW1iZXIocyksIGxpbmVhckNvbWJbc11dKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjcy5sZW5ndGggPiBtYXhDKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYzEgPSBjcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMyID0gY3Muc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNsID0gYzFbMF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3IgPSBjMlswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbyA9IHBsb25rTlZhcnMrKztcbiAgICAgICAgICAgICAgICBjb25zdCBxbSA9IEZyLnplcm87XG4gICAgICAgICAgICAgICAgY29uc3QgcWwgPSBGci5uZWcoYzFbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFyID0gRnIubmVnKGMyWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxbyA9IEZyLm9uZTtcbiAgICAgICAgICAgICAgICBjb25zdCBxYyA9IEZyLnplcm87XG5cbiAgICAgICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goW3NsLCBzciwgc28sIHFtLCBxbCwgcXIsIHFvLCBxY10pO1xuXG4gICAgICAgICAgICAgICAgcGxvbmtBZGRpdGlvbnMucHVzaChbc2wsIHNyLCBjMVsxXSwgYzJbMV1dKTtcblxuICAgICAgICAgICAgICAgIGNzLnB1c2goW3NvLCBGci5vbmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMuc1tpXSA9IGNzW2ldWzBdO1xuICAgICAgICAgICAgICAgIHJlcy5jb2Vmc1tpXSA9IGNzW2ldWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHJlcy5jb2Vmcy5sZW5ndGggPCBtYXhDKSB7XG4gICAgICAgICAgICAgICAgcmVzLnMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICByZXMuY29lZnMucHVzaChGci56ZXJvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDb25zdHJhaW50U3VtKGxjKSB7XG4gICAgICAgICAgICBjb25zdCBDID0gcmVkdWNlQ29lZnMobGMsIDMpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSBDLnNbMF07XG4gICAgICAgICAgICBjb25zdCBzciA9IEMuc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IHNvID0gQy5zWzJdO1xuICAgICAgICAgICAgY29uc3QgcW0gPSBGci56ZXJvO1xuICAgICAgICAgICAgY29uc3QgcWwgPSBDLmNvZWZzWzBdO1xuICAgICAgICAgICAgY29uc3QgcXIgPSBDLmNvZWZzWzFdO1xuICAgICAgICAgICAgY29uc3QgcW8gPSBDLmNvZWZzWzJdO1xuICAgICAgICAgICAgY29uc3QgcWMgPSBDLms7XG4gICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goW3NsLCBzciwgc28sIHFtLCBxbCwgcXIsIHFvLCBxY10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkQ29uc3RyYWludE11bChsY0EsIGxjQiwgbGNDKSB7XG4gICAgICAgICAgICBjb25zdCBBID0gcmVkdWNlQ29lZnMobGNBLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IEIgPSByZWR1Y2VDb2VmcyhsY0IsIDEpO1xuICAgICAgICAgICAgY29uc3QgQyA9IHJlZHVjZUNvZWZzKGxjQywgMSk7XG5cblxuICAgICAgICAgICAgY29uc3Qgc2wgPSBBLnNbMF07XG4gICAgICAgICAgICBjb25zdCBzciA9IEIuc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNvID0gQy5zWzBdO1xuICAgICAgICAgICAgY29uc3QgcW0gPSBGci5tdWwoQS5jb2Vmc1swXSwgQi5jb2Vmc1swXSk7XG4gICAgICAgICAgICBjb25zdCBxbCA9IEZyLm11bChBLmNvZWZzWzBdLCBCLmspO1xuICAgICAgICAgICAgY29uc3QgcXIgPSBGci5tdWwoQS5rLCBCLmNvZWZzWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHFvID0gRnIubmVnKEMuY29lZnNbMF0pO1xuICAgICAgICAgICAgY29uc3QgcWMgPSBGci5zdWIoRnIubXVsKEEuaywgQi5rKSwgQy5rKTtcbiAgICAgICAgICAgIHBsb25rQ29uc3RyYWludHMucHVzaChbc2wsIHNyLCBzbywgcW0sIHFsLCBxciwgcW8sIHFjXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGMpIHtcbiAgICAgICAgICAgIGxldCBrID0gRnIuemVybztcbiAgICAgICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNzID0gT2JqZWN0LmtleXMobGMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsY1tzc1tpXV0gPT0gMG4pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxjW3NzW2ldXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNzW2ldID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IEZyLmFkZChrLCBsY1tzc1tpXV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA+IDApIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoayAhPSBGci56ZXJvKSByZXR1cm4gXCJrXCI7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzKGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgICAgIGNvbnN0IGxjdEEgPSBnZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGNBKTtcbiAgICAgICAgICAgIGNvbnN0IGxjdEIgPSBnZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGNCKTtcbiAgICAgICAgICAgIGlmICgobGN0QSA9PT0gXCIwXCIpIHx8IChsY3RCID09PSBcIjBcIikpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemUobGNDKTtcbiAgICAgICAgICAgICAgICBhZGRDb25zdHJhaW50U3VtKGxjQyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxjdEEgPT09IFwia1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGNDQyA9IGpvaW4obGNCLCBsY0FbMF0sIGxjQyk7XG4gICAgICAgICAgICAgICAgYWRkQ29uc3RyYWludFN1bShsY0NDKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGN0QiA9PT0gXCJrXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsY0NDID0gam9pbihsY0EsIGxjQlswXSwgbGNDKTtcbiAgICAgICAgICAgICAgICBhZGRDb25zdHJhaW50U3VtKGxjQ0MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRDb25zdHJhaW50TXVsKGxjQSwgbGNCLCBsY0MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcyA9IDE7IHMgPD0gblB1YmxpYzsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHM7XG4gICAgICAgICAgICBjb25zdCBzciA9IDA7XG4gICAgICAgICAgICBjb25zdCBzbyA9IDA7XG4gICAgICAgICAgICBjb25zdCBxbSA9IEZyLnplcm87XG4gICAgICAgICAgICBjb25zdCBxbCA9IEZyLm9uZTtcbiAgICAgICAgICAgIGNvbnN0IHFyID0gRnIuemVybztcbiAgICAgICAgICAgIGNvbnN0IHFvID0gRnIuemVybztcbiAgICAgICAgICAgIGNvbnN0IHFjID0gRnIuemVybztcblxuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKFtzbCwgc3IsIHNvLCBxbSwgcWwsIHFyLCBxbywgcWNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcjFjcy5jb25zdHJhaW50cy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChjICUgMTAwMDAgPT09IDApKSBsb2dnZXIuZGVidWcoYHByb2Nlc3NpbmcgY29uc3RyYWludHM6ICR7Y30vJHtyMWNzLm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgICAgIHByb2Nlc3MoLi4ucjFjcy5jb25zdHJhaW50c1tjXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVdpdG5lc3NNYXAoc2VjdGlvbk51bSwgcG9zQ29uc3RyYWludCwgbmFtZSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtDb25zdHJhaW50c1tpXVtwb3NDb25zdHJhaW50XSk7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9OiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVRTWFwKHNlY3Rpb25OdW0sIHBvc0NvbnN0cmFpbnQsIG5hbWUpIHtcbiAgICAgICAgbGV0IFEgPSBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUqbjhyKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBsb25rQ29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIFEuc2V0KHBsb25rQ29uc3RyYWludHNbaV1bcG9zQ29uc3RyYWludF0sIGkqbjhyKTtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGB3cml0aW5nICR7bmFtZX06ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFEpO1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICAgICAgUSA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoUSk7XG4gICAgICAgIHZrW25hbWVdPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShMUG9pbnRzLCBRLCBsb2dnZXIsIFwibXVsdGlleHAgXCIrbmFtZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVQNChidWZmKSB7XG4gICAgICAgIGNvbnN0IHEgPSBhd2FpdCBGci5pZmZ0KGJ1ZmYpO1xuICAgICAgICBjb25zdCBxNCA9IG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSpuOHIqNCk7XG4gICAgICAgIHE0LnNldChxLCAwKTtcbiAgICAgICAgY29uc3QgUTQgPSBhd2FpdCBGci5mZnQocTQpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUocSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShRNCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVBZGRpdGlvbnMoc2VjdGlvbk51bSwgbmFtZSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBjb25zdCBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoKDIqNCsyKm44cikpO1xuICAgICAgICBjb25zdCBidWZmT3V0ViA9IG5ldyBEYXRhVmlldyhidWZmT3V0LmJ1ZmZlcik7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwbG9ua0FkZGl0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWRkaXRpb249cGxvbmtBZGRpdGlvbnNbaV07XG4gICAgICAgICAgICBsZXQgbz0wO1xuICAgICAgICAgICAgYnVmZk91dFYuc2V0VWludDMyKG8sIGFkZGl0aW9uWzBdLCB0cnVlKTsgbys9NDtcbiAgICAgICAgICAgIGJ1ZmZPdXRWLnNldFVpbnQzMihvLCBhZGRpdGlvblsxXSwgdHJ1ZSk7IG8rPTQ7XG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIE1vbnRnb21lcnkuIHN0b3JlZCA9IHYqUlxuICAgICAgICAgICAgLy8gc28gd2hlbiBtb250Z29tZXJ5IG11bHRpcGxpZWQgYnkgdGhlIHdpdG5lc3MsIGl0J3MgcmVzdWx0ID0gdipSKncvUiA9IHYqd1xuICAgICAgICAgICAgYnVmZk91dC5zZXQoYWRkaXRpb25bMl0sIG8pOyBvKz0gbjhyO1xuICAgICAgICAgICAgYnVmZk91dC5zZXQoYWRkaXRpb25bM10sIG8pOyBvKz0gbjhyO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJ1ZmZPdXQpO1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfTogJHtpfS8ke3Bsb25rQWRkaXRpb25zLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVNpZ21hKHNlY3Rpb25OdW0sIG5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2lnbWEgPSBuZXcgQmlnQnVmZmVyKG44cipkb21haW5TaXplKjMpO1xuICAgICAgICBjb25zdCBsYXN0QXBhcmVuY2UgPSAgbmV3IEJpZ0FycmF5KHBsb25rTlZhcnMpO1xuICAgICAgICBjb25zdCBmaXJzdFBvcyA9IG5ldyBCaWdBcnJheShwbG9ua05WYXJzKTtcbiAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxkb21haW5TaXplO2krKykge1xuICAgICAgICAgICAgaWYgKGk8cGxvbmtDb25zdHJhaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKHBsb25rQ29uc3RyYWludHNbaV1bMF0sIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsxXSwgZG9tYWluU2l6ZSArIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsyXSwgZG9tYWluU2l6ZSoyICsgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBkb21haW5TaXplICsgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBkb21haW5TaXplKjIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1tjaXJQb3dlcl0pO1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfSBwaGFzZTE6ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzPTA7IHM8cGxvbmtOVmFyczsgcysrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpcnN0UG9zW3NdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KGxhc3RBcGFyZW5jZVtzXSwgZmlyc3RQb3Nbc10qbjhyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgbm90IHVzZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWYXJpYWJsZSBub3QgdXNlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKHMlMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGB3cml0aW5nICR7bmFtZX0gcGhhc2UyOiAke3N9LyR7cGxvbmtOVmFyc31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgbGV0IFMxID0gc2lnbWEuc2xpY2UoMCwgZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFMxKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICBsZXQgUzIgPSBzaWdtYS5zbGljZShkb21haW5TaXplKm44ciwgZG9tYWluU2l6ZSpuOHIqMik7XG4gICAgICAgIGF3YWl0IHdyaXRlUDQoUzIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIGxldCBTMyA9IHNpZ21hLnNsaWNlKGRvbWFpblNpemUqbjhyKjIsIGRvbWFpblNpemUqbjhyKjMpO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFMzKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgICAgICBTMSA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoUzEpO1xuICAgICAgICBTMiA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoUzIpO1xuICAgICAgICBTMyA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoUzMpO1xuXG4gICAgICAgIHZrLlMxPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShMUG9pbnRzLCBTMSwgbG9nZ2VyLCBcIm11bHRpZXhwIFMxXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIHZrLlMyPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShMUG9pbnRzLCBTMiwgbG9nZ2VyLCBcIm11bHRpZXhwIFMyXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIHZrLlMzPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShMUG9pbnRzLCBTMywgbG9nZ2VyLCBcIm11bHRpZXhwIFMzXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRTaWdtYShzLCBwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RBcGFyZW5jZVtzXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGZpcnN0UG9zW3NdID0gcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KGxhc3RBcGFyZW5jZVtzXSwgcCpuOHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHY7XG4gICAgICAgICAgICBpZiAocDxkb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IHc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHA8Mipkb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IEZyLm11bCh3LCBrMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHYgPSBGci5tdWwodywgazIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEFwYXJlbmNlW3NdPXY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUxzKHNlY3Rpb25OdW0sIG5hbWUpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgY29uc3QgbD1NYXRoLm1heChuUHVibGljLCAxKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJ1ZmYgPSBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUqbjhyKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KEZyLm9uZSwgaSpuOHIpO1xuICAgICAgICAgICAgYXdhaXQgd3JpdGVQNChidWZmKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9ICR7aX0vJHtsfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhZGVycygpIHtcblxuICAgICAgICAvLyBXcml0ZSB0aGUgaGVhZGVyXG4gICAgICAgIC8vLy8vLy8vLy8vXG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKDIpOyAvLyBQbG9ua1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgICAgICAvLyBXcml0ZSB0aGUgUGxvbmsgaGVhZGVyIHNlY3Rpb25cbiAgICAgICAgLy8vLy8vLy8vLy9cblxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDIpO1xuICAgICAgICBjb25zdCBwcmltZVEgPSBjdXJ2ZS5xO1xuICAgICAgICBjb25zdCBuOHEgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgICAgIGNvbnN0IHByaW1lUiA9IGN1cnZlLnI7XG4gICAgICAgIGNvbnN0IG44ciA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZVIpIC0gMSkgLyA2NCkgKzEpKjg7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhxKTtcbiAgICAgICAgYXdhaXQgd3JpdGVCaWdJbnQoZmRaS2V5LCBwcmltZVEsIG44cSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG44cik7XG4gICAgICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkWktleSwgcHJpbWVSLCBuOHIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihwbG9ua05WYXJzKTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIGJhcnNcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoblB1YmxpYyk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcHVibGljIHZhcnMgKG5vdCBpbmNsdWRpbmcgT05FKVxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihkb21haW5TaXplKTsgICAgICAgICAgICAgICAgICAvLyBkb21haW5TaXplXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQWRkaXRpb25zLmxlbmd0aCk7ICAgICAgICAgICAgICAgICAgLy8gZG9tYWluU2l6ZVxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCk7IFxuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShrMSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShrMik7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlFtKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5RbCkpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUXIpKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlFvKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5RYykpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5TMSkpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUzIpKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlMzKSk7XG5cbiAgICAgICAgbGV0IGJYXzI7XG4gICAgICAgIGJYXzIgPSBhd2FpdCBmZFBUYXUucmVhZChzRzIsIHNlY3Rpb25zUFRhdVszXVswXS5wICsgc0cyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJYXzIpO1xuXG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEsxSzIoKSB7XG4gICAgICAgIGxldCBrMSA9IEZyLnR3bztcbiAgICAgICAgd2hpbGUgKGlzSW5jbHVkZWQoazEsIFtdLCBjaXJQb3dlcikpIEZyLmFkZChrMSwgRnIub25lKTtcbiAgICAgICAgbGV0IGsyID0gRnIuYWRkKGsxLCBGci5vbmUpO1xuICAgICAgICB3aGlsZSAoaXNJbmNsdWRlZChrMiwgW2sxXSwgY2lyUG93ZXIpKSBGci5hZGQoazIsIEZyLm9uZSk7XG4gICAgICAgIHJldHVybiBbazEsIGsyXTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIGlzSW5jbHVkZWQoaywga0FyciwgcG93KSB7XG4gICAgICAgICAgICBjb25zdCBkb21haW5TaXplPSAyKipwb3c7XG4gICAgICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxkb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnIuZXEoaywgdykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxrQXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChGci5lcShrLCBGci5tdWwoa0FycltqXSwgdykpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3Bvd10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/plonk_setup.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/plonk_verify.js":
/*!**************************************************!*\
  !*** ./node_modules/snarkjs/src/plonk_verify.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkVerify)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(ssr)/./node_modules/snarkjs/src/Keccak256Transcript.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\n\n\n\n\n\nconst { unstringifyBigInts } = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nasync function plonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    let vk_verifier = unstringifyBigInts(_vk_verifier);\n    _proof = unstringifyBigInts(_proof);\n    let publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName(vk_verifier.curve);\n\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n\n    if (logger) logger.info(\"PLONK VERIFIER STARTED\");\n\n    let proof = fromObjectProof(curve,_proof);\n    vk_verifier = fromObjectVk(curve, vk_verifier);\n\n    if (!isWellConstructed(curve, proof)) {\n        logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    if (publicSignals.length != vk_verifier.nPublic) {\n        if (logger) logger.error(\"Invalid number of public inputs\");\n        return false;\n    }\n\n    if (!evaluationsAreValid(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid\");\n        return false;\n    }\n\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    const challenges = calculatechallenges(curve, proof, publicSignals, vk_verifier);\n    if (logger) {\n        logger.debug(\"beta: \" + Fr.toString(challenges.beta, 16));    \n        logger.debug(\"gamma: \" + Fr.toString(challenges.gamma, 16));    \n        logger.debug(\"alpha: \" + Fr.toString(challenges.alpha, 16));    \n        logger.debug(\"xi: \" + Fr.toString(challenges.xi, 16));\n        for(let i=1;i<6;i++) {\n            if (logger) logger.debug(\"v: \" + Fr.toString(challenges.v[i], 16));\n        }\n        logger.debug(\"u: \" + Fr.toString(challenges.u, 16));    \n    }\n    const L = calculateLagrangeEvaluations(curve, challenges, vk_verifier);\n    if (logger) {\n        for (let i=1; i<L.length; i++) {\n            logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));\n        }\n    }\n    \n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const pi = calculatePI(curve, publicSignals, L);\n    if (logger) {\n        logger.debug(\"PI(xi): \" + Fr.toString(pi, 16));\n    }\n    \n    const r0 = calculateR0(curve, proof, challenges, pi, L[1]);\n    if (logger) {\n        logger.debug(\"r0: \" + Fr.toString(r0, 16));\n    }\n\n    const D = calculateD(curve, proof, challenges, vk_verifier, L[1]);\n    if (logger) {\n        logger.debug(\"D: \" + G1.toString(G1.toAffine(D), 16));\n    }\n\n    const F = calculateF(curve, proof, challenges, vk_verifier, D);\n    if (logger) {\n        logger.debug(\"F: \" + G1.toString(G1.toAffine(F), 16));\n    }\n\n    const E = calculateE(curve, proof, challenges, r0);\n    if (logger) {\n        logger.debug(\"E: \" + G1.toString(G1.toAffine(E), 16));\n    }\n\n    const res = await isValidPairing(curve, proof, challenges, vk_verifier, E, F);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"OK!\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    return res;\n}\n\n\nfunction fromObjectProof(curve, proof) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    const res = {};\n    res.A = G1.fromObject(proof.A);\n    res.B = G1.fromObject(proof.B);\n    res.C = G1.fromObject(proof.C);\n    res.Z = G1.fromObject(proof.Z);\n    res.T1 = G1.fromObject(proof.T1);\n    res.T2 = G1.fromObject(proof.T2);\n    res.T3 = G1.fromObject(proof.T3);\n    res.eval_a = Fr.fromObject(proof.eval_a);\n    res.eval_b = Fr.fromObject(proof.eval_b);\n    res.eval_c = Fr.fromObject(proof.eval_c);\n    res.eval_zw = Fr.fromObject(proof.eval_zw);\n    res.eval_s1 = Fr.fromObject(proof.eval_s1);\n    res.eval_s2 = Fr.fromObject(proof.eval_s2);\n    res.Wxi = G1.fromObject(proof.Wxi);\n    res.Wxiw = G1.fromObject(proof.Wxiw);\n    return res;\n}\n\nfunction fromObjectVk(curve, vk) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n    const Fr = curve.Fr;\n    const res = vk;\n    res.Qm = G1.fromObject(vk.Qm);\n    res.Ql = G1.fromObject(vk.Ql);\n    res.Qr = G1.fromObject(vk.Qr);\n    res.Qo = G1.fromObject(vk.Qo);\n    res.Qc = G1.fromObject(vk.Qc);\n    res.S1 = G1.fromObject(vk.S1);\n    res.S2 = G1.fromObject(vk.S2);\n    res.S3 = G1.fromObject(vk.S3);\n    res.k1 = Fr.fromObject(vk.k1);\n    res.k2 = Fr.fromObject(vk.k2);\n    res.X_2 = G2.fromObject(vk.X_2);\n\n    return res;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    if (!G1.isValid(proof.A)) return false;\n    if (!G1.isValid(proof.B)) return false;\n    if (!G1.isValid(proof.C)) return false;\n    if (!G1.isValid(proof.Z)) return false;\n    if (!G1.isValid(proof.T1)) return false;\n    if (!G1.isValid(proof.T2)) return false;\n    if (!G1.isValid(proof.T3)) return false;\n    if (!G1.isValid(proof.Wxi)) return false;\n    if (!G1.isValid(proof.Wxiw)) return false;\n    return true;\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.geq(value, 0) && ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid(curve, evaluation) {\n    return checkValueBelongToField(curve, ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid(curve, proof) {\n    return checkEvaluationIsValid(curve, proof.eval_a)\n        && checkEvaluationIsValid(curve, proof.eval_b)\n        && checkEvaluationIsValid(curve, proof.eval_c)\n        && checkEvaluationIsValid(curve, proof.eval_s1)\n        && checkEvaluationIsValid(curve, proof.eval_s2)\n        && checkEvaluationIsValid(curve, proof.eval_zw);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction calculatechallenges(curve, proof, publicSignals, vk) {\n    const Fr = curve.Fr;\n    const res = {};\n    const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_2__.Keccak256Transcript(curve);\n\n    // Challenge round 2: beta and gamma\n    transcript.addPolCommitment(vk.Qm);\n    transcript.addPolCommitment(vk.Ql);\n    transcript.addPolCommitment(vk.Qr);\n    transcript.addPolCommitment(vk.Qo);\n    transcript.addPolCommitment(vk.Qc);\n    transcript.addPolCommitment(vk.S1);\n    transcript.addPolCommitment(vk.S2);\n    transcript.addPolCommitment(vk.S3);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.A);\n    transcript.addPolCommitment(proof.B);\n    transcript.addPolCommitment(proof.C);\n\n    res.beta = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    res.gamma = transcript.getChallenge();\n\n    // Challenge round 3: alpha\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    transcript.addScalar(res.gamma);\n    transcript.addPolCommitment(proof.Z);\n    res.alpha = transcript.getChallenge();\n\n    // Challenge round 4: xi\n    transcript.reset();\n    transcript.addScalar(res.alpha);\n    transcript.addPolCommitment(proof.T1);\n    transcript.addPolCommitment(proof.T2);\n    transcript.addPolCommitment(proof.T3);\n    res.xi = transcript.getChallenge();\n    \n    // Challenge round 5: v\n    transcript.reset();\n    transcript.addScalar(res.xi);\n    transcript.addScalar(proof.eval_a);\n    transcript.addScalar(proof.eval_b);\n    transcript.addScalar(proof.eval_c);\n    transcript.addScalar(proof.eval_s1);\n    transcript.addScalar(proof.eval_s2);\n    transcript.addScalar(proof.eval_zw);\n    res.v = [];\n    res.v[1] = transcript.getChallenge();\n\n    for (let i=2; i<6; i++ ) res.v[i] = Fr.mul(res.v[i-1], res.v[1]);\n\n    // Challenge: u\n    transcript.reset();\n    transcript.addPolCommitment(proof.Wxi);\n    transcript.addPolCommitment(proof.Wxiw);\n    res.u = transcript.getChallenge();\n\n    return res;\n}\n\nfunction calculateLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    let xin = challenges.xi;\n    let domainSize = 1;\n    for (let i=0; i<vk.power; i++) {\n        xin = Fr.square(xin);\n        domainSize *= 2;\n    }\n    challenges.xin = xin;\n\n    challenges.zh = Fr.sub(xin, Fr.one);\n\n    const L = [];\n\n    const n = Fr.e(domainSize);\n    let w = Fr.one;\n    for (let i=1; i<=Math.max(1, vk.nPublic); i++) {\n        L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n        w = Fr.mul(w, Fr.w[vk.power]);\n    }\n\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, L) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i=0; i<publicSignals.length; i++) {        \n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, L[i+1]));\n    }\n    return pi;\n}\n\nfunction calculateR0(curve, proof, challenges, pi, l1) {\n    const Fr = curve.Fr;\n\n    const e1 = pi;\n\n    const e2 = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    let e3a = Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1));\n    e3a = Fr.add(e3a, challenges.gamma);\n\n    let e3b = Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2));\n    e3b = Fr.add(e3b, challenges.gamma);\n\n    let e3c = Fr.add(proof.eval_c, challenges.gamma);\n\n    let e3 = Fr.mul(Fr.mul(e3a, e3b), e3c);\n    e3 = Fr.mul(e3, proof.eval_zw);\n    e3 = Fr.mul(e3, challenges.alpha);\n\n    const r0 = Fr.sub(Fr.sub(e1, e2), e3);\n\n    return r0;\n}\n\nfunction calculateD(curve, proof, challenges, vk, l1) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    \n    let d1 = G1.timesFr(vk.Qm, Fr.mul(proof.eval_a, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Ql, proof.eval_a));\n    d1 = G1.add(d1, G1.timesFr(vk.Qr, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Qo, proof.eval_c));\n    d1 = G1.add(d1, vk.Qc);\n\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n\n    const d2a1 = Fr.add(Fr.add(proof.eval_a, betaxi), challenges.gamma);\n    const d2a2 = Fr.add(Fr.add(proof.eval_b, Fr.mul(betaxi, vk.k1)), challenges.gamma);\n    const d2a3 = Fr.add(Fr.add(proof.eval_c, Fr.mul(betaxi, vk.k2)), challenges.gamma);\n\n    const d2a = Fr.mul(Fr.mul(Fr.mul(d2a1, d2a2), d2a3), challenges.alpha);\n\n    const d2b = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    const d2 = G1.timesFr(proof.Z, Fr.add(Fr.add(d2a, d2b), challenges.u));\n\n    const d3a = Fr.add(Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1)), challenges.gamma);\n    const d3b = Fr.add(Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2)), challenges.gamma);\n    const d3c = Fr.mul(Fr.mul(challenges.alpha, challenges.beta), proof.eval_zw);\n\n    const d3 = G1.timesFr(vk.S3, Fr.mul(Fr.mul(d3a, d3b), d3c));\n    \n    const d4low = proof.T1;\n    const d4mid = G1.timesFr(proof.T2, challenges.xin);\n    const d4high = G1.timesFr(proof.T3, Fr.square(challenges.xin));\n    let d4 = G1.add(d4low, G1.add(d4mid, d4high));\n    d4 = G1.timesFr(d4, challenges.zh);\n\n    const d = G1.sub(G1.sub(G1.add(d1, d2), d3), d4);\n\n    return d;\n}\n\nfunction calculateF(curve, proof, challenges, vk, D) {\n    const G1 = curve.G1;\n\n    let res = G1.add(D, G1.timesFr(proof.A, challenges.v[1]));\n    res = G1.add(res, G1.timesFr(proof.B, challenges.v[2]));\n    res = G1.add(res, G1.timesFr(proof.C, challenges.v[3]));\n    res = G1.add(res, G1.timesFr(vk.S1, challenges.v[4]));\n    res = G1.add(res, G1.timesFr(vk.S2, challenges.v[5]));\n\n    return res;\n}\n\nfunction calculateE(curve, proof, challenges, r0) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let e = Fr.add(Fr.neg(r0), Fr.mul(challenges.v[1], proof.eval_a));\n    e = Fr.add(e, Fr.mul(challenges.v[2], proof.eval_b));\n    e = Fr.add(e, Fr.mul(challenges.v[3], proof.eval_c));\n    e = Fr.add(e, Fr.mul(challenges.v[4], proof.eval_s1));\n    e = Fr.add(e, Fr.mul(challenges.v[5], proof.eval_s2));\n    e = Fr.add(e, Fr.mul(challenges.u, proof.eval_zw));\n\n    const res = G1.timesFr(G1.one, e);\n\n    return res;\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, E, F) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let A1 = proof.Wxi;\n    A1 = G1.add(A1, G1.timesFr(proof.Wxiw, challenges.u));\n\n    let B1 = G1.timesFr(proof.Wxi, challenges.xi);\n    const s = Fr.mul(Fr.mul(challenges.u, challenges.xi), Fr.w[vk.power]);\n    B1 = G1.add(B1, G1.timesFr(proof.Wxiw, s));\n    B1 = G1.add(B1, F);\n    B1 = G1.sub(B1, E);\n\n    const res = await curve.pairingEq(\n        G1.neg(A1) , vk.X_2,\n        B1 , curve.G2.one\n    );\n\n    return res;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfdmVyaWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVzQztBQUNDO0FBQ3dCO0FBQ3pCOztBQUV0QyxRQUFRLHFCQUFxQixFQUFFLCtDQUFLOztBQUVyQjtBQUNmO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isd0RBQXVCOztBQUUvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsNkJBQTZCLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdEQUFNLGtCQUFrQixnREFBTTtBQUN6Qzs7QUFFQTtBQUNBLDBDQUEwQyxnREFBTTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdFQUFtQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsS0FBSzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX3ZlcmlmeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGlzIHBhcGVyOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE5Lzk1My5wZGYgKi9cblxuaW1wb3J0ICogYXMgY3VydmVzIGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHsgdXRpbHMgfSAgIGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCB7IEtlY2NhazI1NlRyYW5zY3JpcHQgfSBmcm9tIFwiLi9LZWNjYWsyNTZUcmFuc2NyaXB0LmpzXCI7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmNvbnN0IHsgdW5zdHJpbmdpZnlCaWdJbnRzIH0gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGxvbmtWZXJpZnkoX3ZrX3ZlcmlmaWVyLCBfcHVibGljU2lnbmFscywgX3Byb29mLCBsb2dnZXIpIHtcbiAgICBsZXQgdmtfdmVyaWZpZXIgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3ZrX3ZlcmlmaWVyKTtcbiAgICBfcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3Byb29mKTtcbiAgICBsZXQgcHVibGljU2lnbmFscyA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHVibGljU2lnbmFscyk7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGN1cnZlcy5nZXRDdXJ2ZUZyb21OYW1lKHZrX3ZlcmlmaWVyLmN1cnZlKTtcblxuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUExPTksgVkVSSUZJRVIgU1RBUlRFRFwiKTtcblxuICAgIGxldCBwcm9vZiA9IGZyb21PYmplY3RQcm9vZihjdXJ2ZSxfcHJvb2YpO1xuICAgIHZrX3ZlcmlmaWVyID0gZnJvbU9iamVjdFZrKGN1cnZlLCB2a192ZXJpZmllcik7XG5cbiAgICBpZiAoIWlzV2VsbENvbnN0cnVjdGVkKGN1cnZlLCBwcm9vZikpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiUHJvb2YgY29tbWl0bWVudHMgYXJlIG5vdCB2YWxpZC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocHVibGljU2lnbmFscy5sZW5ndGggIT0gdmtfdmVyaWZpZXIublB1YmxpYykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwdWJsaWMgaW5wdXRzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFldmFsdWF0aW9uc0FyZVZhbGlkKGN1cnZlLCBwcm9vZikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUHJvb2YgZXZhbHVhdGlvbnMgYXJlIG5vdCB2YWxpZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghcHVibGljSW5wdXRzQXJlVmFsaWQoY3VydmUsIHB1YmxpY1NpZ25hbHMpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlB1YmxpYyBpbnB1dHMgYXJlIG5vdCB2YWxpZC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFsbGVuZ2VzID0gY2FsY3VsYXRlY2hhbGxlbmdlcyhjdXJ2ZSwgcHJvb2YsIHB1YmxpY1NpZ25hbHMsIHZrX3ZlcmlmaWVyKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcImJldGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5iZXRhLCAxNikpOyAgICBcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZ2FtbWE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5nYW1tYSwgMTYpKTsgICAgXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcImFscGhhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYWxwaGEsIDE2KSk7ICAgIFxuICAgICAgICBsb2dnZXIuZGVidWcoXCJ4aTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnhpLCAxNikpO1xuICAgICAgICBmb3IobGV0IGk9MTtpPDY7aSsrKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJ2OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMudltpXSwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoXCJ1OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMudSwgMTYpKTsgICAgXG4gICAgfVxuICAgIGNvbnN0IEwgPSBjYWxjdWxhdGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2a192ZXJpZmllcik7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBmb3IgKGxldCBpPTE7IGk8TC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBMJHtpfSh4aSk9YCArIEZyLnRvU3RyaW5nKExbaV0sIDE2KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHB1YmxpY1NpZ25hbHMubGVuZ3RoICE9IHZrX3ZlcmlmaWVyLm5QdWJsaWMpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTnVtYmVyIG9mIHB1YmxpYyBzaWduYWxzIGRvZXMgbm90IG1hdGNoIHdpdGggdmtcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwaSA9IGNhbGN1bGF0ZVBJKGN1cnZlLCBwdWJsaWNTaWduYWxzLCBMKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlBJKHhpKTogXCIgKyBGci50b1N0cmluZyhwaSwgMTYpKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcjAgPSBjYWxjdWxhdGVSMChjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHBpLCBMWzFdKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcInIwOiBcIiArIEZyLnRvU3RyaW5nKHIwLCAxNikpO1xuICAgIH1cblxuICAgIGNvbnN0IEQgPSBjYWxjdWxhdGVEKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmtfdmVyaWZpZXIsIExbMV0pO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRDogXCIgKyBHMS50b1N0cmluZyhHMS50b0FmZmluZShEKSwgMTYpKTtcbiAgICB9XG5cbiAgICBjb25zdCBGID0gY2FsY3VsYXRlRihjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrX3ZlcmlmaWVyLCBEKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkY6IFwiICsgRzEudG9TdHJpbmcoRzEudG9BZmZpbmUoRiksIDE2KSk7XG4gICAgfVxuXG4gICAgY29uc3QgRSA9IGNhbGN1bGF0ZUUoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCByMCk7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJFOiBcIiArIEcxLnRvU3RyaW5nKEcxLnRvQWZmaW5lKEUpLCAxNikpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGlzVmFsaWRQYWlyaW5nKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmtfdmVyaWZpZXIsIEUsIEYpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIk9LIVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiSW52YWxpZCBQcm9vZlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cblxuZnVuY3Rpb24gZnJvbU9iamVjdFByb29mKGN1cnZlLCBwcm9vZikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICByZXMuQSA9IEcxLmZyb21PYmplY3QocHJvb2YuQSk7XG4gICAgcmVzLkIgPSBHMS5mcm9tT2JqZWN0KHByb29mLkIpO1xuICAgIHJlcy5DID0gRzEuZnJvbU9iamVjdChwcm9vZi5DKTtcbiAgICByZXMuWiA9IEcxLmZyb21PYmplY3QocHJvb2YuWik7XG4gICAgcmVzLlQxID0gRzEuZnJvbU9iamVjdChwcm9vZi5UMSk7XG4gICAgcmVzLlQyID0gRzEuZnJvbU9iamVjdChwcm9vZi5UMik7XG4gICAgcmVzLlQzID0gRzEuZnJvbU9iamVjdChwcm9vZi5UMyk7XG4gICAgcmVzLmV2YWxfYSA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF9hKTtcbiAgICByZXMuZXZhbF9iID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX2IpO1xuICAgIHJlcy5ldmFsX2MgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfYyk7XG4gICAgcmVzLmV2YWxfencgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfencpO1xuICAgIHJlcy5ldmFsX3MxID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX3MxKTtcbiAgICByZXMuZXZhbF9zMiA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF9zMik7XG4gICAgcmVzLld4aSA9IEcxLmZyb21PYmplY3QocHJvb2YuV3hpKTtcbiAgICByZXMuV3hpdyA9IEcxLmZyb21PYmplY3QocHJvb2YuV3hpdyk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdFZrKGN1cnZlLCB2aykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRzIgPSBjdXJ2ZS5HMjtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHJlcyA9IHZrO1xuICAgIHJlcy5RbSA9IEcxLmZyb21PYmplY3QodmsuUW0pO1xuICAgIHJlcy5RbCA9IEcxLmZyb21PYmplY3QodmsuUWwpO1xuICAgIHJlcy5RciA9IEcxLmZyb21PYmplY3QodmsuUXIpO1xuICAgIHJlcy5RbyA9IEcxLmZyb21PYmplY3QodmsuUW8pO1xuICAgIHJlcy5RYyA9IEcxLmZyb21PYmplY3QodmsuUWMpO1xuICAgIHJlcy5TMSA9IEcxLmZyb21PYmplY3QodmsuUzEpO1xuICAgIHJlcy5TMiA9IEcxLmZyb21PYmplY3QodmsuUzIpO1xuICAgIHJlcy5TMyA9IEcxLmZyb21PYmplY3QodmsuUzMpO1xuICAgIHJlcy5rMSA9IEZyLmZyb21PYmplY3QodmsuazEpO1xuICAgIHJlcy5rMiA9IEZyLmZyb21PYmplY3QodmsuazIpO1xuICAgIHJlcy5YXzIgPSBHMi5mcm9tT2JqZWN0KHZrLlhfMik7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBpc1dlbGxDb25zdHJ1Y3RlZChjdXJ2ZSwgcHJvb2YpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5BKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5CKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5DKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5aKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5UMSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuVDIpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFHMS5pc1ZhbGlkKHByb29mLlQzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5XeGkpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFHMS5pc1ZhbGlkKHByb29mLld4aXcpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsdWVCZWxvbmdUb0ZpZWxkKGN1cnZlLCB2YWx1ZSkge1xuICAgIHJldHVybiBTY2FsYXIuZ2VxKHZhbHVlLCAwKSAmJiBTY2FsYXIubHQodmFsdWUsIGN1cnZlLnIpO1xufVxuXG5mdW5jdGlvbiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBldmFsdWF0aW9uKSB7XG4gICAgcmV0dXJuIGNoZWNrVmFsdWVCZWxvbmdUb0ZpZWxkKGN1cnZlLCBTY2FsYXIuZnJvbVJwckxFKGV2YWx1YXRpb24pKTtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGlvbnNBcmVWYWxpZChjdXJ2ZSwgcHJvb2YpIHtcbiAgICByZXR1cm4gY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbF9hKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsX2IpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWxfYylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbF9zMSlcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbF9zMilcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbF96dyk7XG59XG5cbmZ1bmN0aW9uIHB1YmxpY0lucHV0c0FyZVZhbGlkKGN1cnZlLCBwdWJsaWNJbnB1dHMpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHVibGljSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKCFjaGVja1ZhbHVlQmVsb25nVG9GaWVsZChjdXJ2ZSwgcHVibGljSW5wdXRzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVjaGFsbGVuZ2VzKGN1cnZlLCBwcm9vZiwgcHVibGljU2lnbmFscywgdmspIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgMjogYmV0YSBhbmQgZ2FtbWFcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUW0pO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5RbCk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLlFyKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUW8pO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5RYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLlMxKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUzIpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5TMyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoRnIuZShwdWJsaWNTaWduYWxzW2ldKSk7XG4gICAgfVxuXG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLkEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5CKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuQyk7XG5cbiAgICByZXMuYmV0YSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmJldGEpO1xuICAgIHJlcy5nYW1tYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgMzogYWxwaGFcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmJldGEpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHJlcy5nYW1tYSk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLlopO1xuICAgIHJlcy5hbHBoYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgNDogeGlcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmFscGhhKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuVDEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5UMik7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLlQzKTtcbiAgICByZXMueGkgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgIFxuICAgIC8vIENoYWxsZW5nZSByb3VuZCA1OiB2XG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHJlcy54aSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9hKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsX2IpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWxfYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9zMSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9zMik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF96dyk7XG4gICAgcmVzLnYgPSBbXTtcbiAgICByZXMudlsxXSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICBmb3IgKGxldCBpPTI7IGk8NjsgaSsrICkgcmVzLnZbaV0gPSBGci5tdWwocmVzLnZbaS0xXSwgcmVzLnZbMV0pO1xuXG4gICAgLy8gQ2hhbGxlbmdlOiB1XG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5XeGkpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5XeGl3KTtcbiAgICByZXMudSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2aykge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgeGluID0gY2hhbGxlbmdlcy54aTtcbiAgICBsZXQgZG9tYWluU2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaT0wOyBpPHZrLnBvd2VyOyBpKyspIHtcbiAgICAgICAgeGluID0gRnIuc3F1YXJlKHhpbik7XG4gICAgICAgIGRvbWFpblNpemUgKj0gMjtcbiAgICB9XG4gICAgY2hhbGxlbmdlcy54aW4gPSB4aW47XG5cbiAgICBjaGFsbGVuZ2VzLnpoID0gRnIuc3ViKHhpbiwgRnIub25lKTtcblxuICAgIGNvbnN0IEwgPSBbXTtcblxuICAgIGNvbnN0IG4gPSBGci5lKGRvbWFpblNpemUpO1xuICAgIGxldCB3ID0gRnIub25lO1xuICAgIGZvciAobGV0IGk9MTsgaTw9TWF0aC5tYXgoMSwgdmsublB1YmxpYyk7IGkrKykge1xuICAgICAgICBMW2ldID0gRnIuZGl2KEZyLm11bCh3LCBjaGFsbGVuZ2VzLnpoKSwgRnIubXVsKG4sIEZyLnN1YihjaGFsbGVuZ2VzLnhpLCB3KSkpO1xuICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbdmsucG93ZXJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUEkoY3VydmUsIHB1YmxpY1NpZ25hbHMsIEwpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IHBpID0gRnIuemVybztcbiAgICBmb3IgKGxldCBpPTA7IGk8cHVibGljU2lnbmFscy5sZW5ndGg7IGkrKykgeyAgICAgICAgXG4gICAgICAgIGNvbnN0IHcgPSBGci5lKHB1YmxpY1NpZ25hbHNbaV0pO1xuICAgICAgICBwaSA9IEZyLnN1YihwaSwgRnIubXVsKHcsIExbaSsxXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVIwKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgcGksIGwxKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IGUxID0gcGk7XG5cbiAgICBjb25zdCBlMiA9IEZyLm11bChsMSwgRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpKTtcblxuICAgIGxldCBlM2EgPSBGci5hZGQocHJvb2YuZXZhbF9hLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MxKSk7XG4gICAgZTNhID0gRnIuYWRkKGUzYSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICBsZXQgZTNiID0gRnIuYWRkKHByb29mLmV2YWxfYiwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbF9zMikpO1xuICAgIGUzYiA9IEZyLmFkZChlM2IsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgbGV0IGUzYyA9IEZyLmFkZChwcm9vZi5ldmFsX2MsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgbGV0IGUzID0gRnIubXVsKEZyLm11bChlM2EsIGUzYiksIGUzYyk7XG4gICAgZTMgPSBGci5tdWwoZTMsIHByb29mLmV2YWxfencpO1xuICAgIGUzID0gRnIubXVsKGUzLCBjaGFsbGVuZ2VzLmFscGhhKTtcblxuICAgIGNvbnN0IHIwID0gRnIuc3ViKEZyLnN1YihlMSwgZTIpLCBlMyk7XG5cbiAgICByZXR1cm4gcjA7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUQoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgbDEpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgXG4gICAgbGV0IGQxID0gRzEudGltZXNGcih2ay5RbSwgRnIubXVsKHByb29mLmV2YWxfYSwgcHJvb2YuZXZhbF9iKSk7XG4gICAgZDEgPSBHMS5hZGQoZDEsIEcxLnRpbWVzRnIodmsuUWwsIHByb29mLmV2YWxfYSkpO1xuICAgIGQxID0gRzEuYWRkKGQxLCBHMS50aW1lc0ZyKHZrLlFyLCBwcm9vZi5ldmFsX2IpKTtcbiAgICBkMSA9IEcxLmFkZChkMSwgRzEudGltZXNGcih2ay5RbywgcHJvb2YuZXZhbF9jKSk7XG4gICAgZDEgPSBHMS5hZGQoZDEsIHZrLlFjKTtcblxuICAgIGNvbnN0IGJldGF4aSA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGNoYWxsZW5nZXMueGkpO1xuXG4gICAgY29uc3QgZDJhMSA9IEZyLmFkZChGci5hZGQocHJvb2YuZXZhbF9hLCBiZXRheGkpLCBjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICBjb25zdCBkMmEyID0gRnIuYWRkKEZyLmFkZChwcm9vZi5ldmFsX2IsIEZyLm11bChiZXRheGksIHZrLmsxKSksIGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIGNvbnN0IGQyYTMgPSBGci5hZGQoRnIuYWRkKHByb29mLmV2YWxfYywgRnIubXVsKGJldGF4aSwgdmsuazIpKSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICBjb25zdCBkMmEgPSBGci5tdWwoRnIubXVsKEZyLm11bChkMmExLCBkMmEyKSwgZDJhMyksIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgY29uc3QgZDJiID0gRnIubXVsKGwxLCBGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSkpO1xuXG4gICAgY29uc3QgZDIgPSBHMS50aW1lc0ZyKHByb29mLlosIEZyLmFkZChGci5hZGQoZDJhLCBkMmIpLCBjaGFsbGVuZ2VzLnUpKTtcblxuICAgIGNvbnN0IGQzYSA9IEZyLmFkZChGci5hZGQocHJvb2YuZXZhbF9hLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MxKSksIGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIGNvbnN0IGQzYiA9IEZyLmFkZChGci5hZGQocHJvb2YuZXZhbF9iLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MyKSksIGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIGNvbnN0IGQzYyA9IEZyLm11bChGci5tdWwoY2hhbGxlbmdlcy5hbHBoYSwgY2hhbGxlbmdlcy5iZXRhKSwgcHJvb2YuZXZhbF96dyk7XG5cbiAgICBjb25zdCBkMyA9IEcxLnRpbWVzRnIodmsuUzMsIEZyLm11bChGci5tdWwoZDNhLCBkM2IpLCBkM2MpKTtcbiAgICBcbiAgICBjb25zdCBkNGxvdyA9IHByb29mLlQxO1xuICAgIGNvbnN0IGQ0bWlkID0gRzEudGltZXNGcihwcm9vZi5UMiwgY2hhbGxlbmdlcy54aW4pO1xuICAgIGNvbnN0IGQ0aGlnaCA9IEcxLnRpbWVzRnIocHJvb2YuVDMsIEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpbikpO1xuICAgIGxldCBkNCA9IEcxLmFkZChkNGxvdywgRzEuYWRkKGQ0bWlkLCBkNGhpZ2gpKTtcbiAgICBkNCA9IEcxLnRpbWVzRnIoZDQsIGNoYWxsZW5nZXMuemgpO1xuXG4gICAgY29uc3QgZCA9IEcxLnN1YihHMS5zdWIoRzEuYWRkKGQxLCBkMiksIGQzKSwgZDQpO1xuXG4gICAgcmV0dXJuIGQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUYoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRCkge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG5cbiAgICBsZXQgcmVzID0gRzEuYWRkKEQsIEcxLnRpbWVzRnIocHJvb2YuQSwgY2hhbGxlbmdlcy52WzFdKSk7XG4gICAgcmVzID0gRzEuYWRkKHJlcywgRzEudGltZXNGcihwcm9vZi5CLCBjaGFsbGVuZ2VzLnZbMl0pKTtcbiAgICByZXMgPSBHMS5hZGQocmVzLCBHMS50aW1lc0ZyKHByb29mLkMsIGNoYWxsZW5nZXMudlszXSkpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIodmsuUzEsIGNoYWxsZW5nZXMudls0XSkpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIodmsuUzIsIGNoYWxsZW5nZXMudls1XSkpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHIwKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IGUgPSBGci5hZGQoRnIubmVnKHIwKSwgRnIubXVsKGNoYWxsZW5nZXMudlsxXSwgcHJvb2YuZXZhbF9hKSk7XG4gICAgZSA9IEZyLmFkZChlLCBGci5tdWwoY2hhbGxlbmdlcy52WzJdLCBwcm9vZi5ldmFsX2IpKTtcbiAgICBlID0gRnIuYWRkKGUsIEZyLm11bChjaGFsbGVuZ2VzLnZbM10sIHByb29mLmV2YWxfYykpO1xuICAgIGUgPSBGci5hZGQoZSwgRnIubXVsKGNoYWxsZW5nZXMudls0XSwgcHJvb2YuZXZhbF9zMSkpO1xuICAgIGUgPSBGci5hZGQoZSwgRnIubXVsKGNoYWxsZW5nZXMudls1XSwgcHJvb2YuZXZhbF9zMikpO1xuICAgIGUgPSBGci5hZGQoZSwgRnIubXVsKGNoYWxsZW5nZXMudSwgcHJvb2YuZXZhbF96dykpO1xuXG4gICAgY29uc3QgcmVzID0gRzEudGltZXNGcihHMS5vbmUsIGUpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gaXNWYWxpZFBhaXJpbmcoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRSwgRikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBBMSA9IHByb29mLld4aTtcbiAgICBBMSA9IEcxLmFkZChBMSwgRzEudGltZXNGcihwcm9vZi5XeGl3LCBjaGFsbGVuZ2VzLnUpKTtcblxuICAgIGxldCBCMSA9IEcxLnRpbWVzRnIocHJvb2YuV3hpLCBjaGFsbGVuZ2VzLnhpKTtcbiAgICBjb25zdCBzID0gRnIubXVsKEZyLm11bChjaGFsbGVuZ2VzLnUsIGNoYWxsZW5nZXMueGkpLCBGci53W3ZrLnBvd2VyXSk7XG4gICAgQjEgPSBHMS5hZGQoQjEsIEcxLnRpbWVzRnIocHJvb2YuV3hpdywgcykpO1xuICAgIEIxID0gRzEuYWRkKEIxLCBGKTtcbiAgICBCMSA9IEcxLnN1YihCMSwgRSk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBjdXJ2ZS5wYWlyaW5nRXEoXG4gICAgICAgIEcxLm5lZyhBMSkgLCB2ay5YXzIsXG4gICAgICAgIEIxICwgY3VydmUuRzIub25lXG4gICAgKTtcblxuICAgIHJldHVybiByZXM7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/plonk_verify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/polynomial/cpolynomial.js":
/*!************************************************************!*\
  !*** ./node_modules/snarkjs/src/polynomial/cpolynomial.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CPolynomial: () => (/* binding */ CPolynomial)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _polynomial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polynomial.js */ \"(ssr)/./node_modules/snarkjs/src/polynomial/polynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// CPolynomial is a Combined Polynomial of the type :\n// CPolynomial(X) := P_0(X^n) + XP_1(X^n) + ... + X^{n-1}P_{n-1}(X^n)\n// We can use this class to avoid the allocation of a big memory buffer\n// for the coefficients because in some cases a big number of the coefficients are zero\n\n\n\n\n\nclass CPolynomial {\n    constructor(n, curve, logger) {\n        this.n = n;\n        this.polynomials = Array(n).fill(undefined);\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    addPolynomial(position, polynomial) {\n        if (position > this.n - 1) {\n            throw new Error(\"CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1\");\n        }\n\n        this.polynomials[position] = polynomial;\n    }\n\n    degree() {\n        let degrees = this.polynomials.map(\n            (polynomial, index) => polynomial === undefined ? 0 : polynomial.degree() * this.n + index);\n        return Math.max(...degrees);\n    }\n\n    getPolynomial() {\n        let degrees = this.polynomials.map(polynomial => polynomial === undefined ? 0 : polynomial.degree());\n        const maxDegree = this.degree();\n        const lengthBuffer = 2 ** ((0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.log2)(maxDegree - 1) + 1);\n        const sFr = this.Fr.n8;\n\n        let polynomial = new _polynomial_js__WEBPACK_IMPORTED_MODULE_2__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(lengthBuffer * sFr), this.curve, this.logger);\n\n        for (let i = 0; i < maxDegree; i++) {\n            const i_n8 = i * sFr;\n            const i_sFr = i_n8 * this.n;\n\n            for (let j = 0; j < this.n; j++) {\n                if (this.polynomials[j] !== undefined) {\n                    if (i <= degrees[j]) polynomial.coef.set(this.polynomials[j].coef.slice(i_n8, i_n8 + sFr), i_sFr + j * sFr);\n                }\n            }\n        }\n\n        return polynomial;\n    }\n\n    async multiExponentiation(PTau, name) {\n        let polynomial = this.getPolynomial();\n        const n = polynomial.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(polynomial.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG9seW5vbWlhbC9jcG9seW5vbWlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxJQUFJLElBQUksSUFBSTtBQUNsRTtBQUNBOztBQUV1QztBQUNQO0FBQ1c7O0FBRXBDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhDQUFJO0FBQ3ZDOztBQUVBLDZCQUE2QixzREFBVSxLQUFLLG1EQUFTOztBQUVyRCx3QkFBd0IsZUFBZTtBQUN2QztBQUNBOztBQUVBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb2x5bm9taWFsL2Nwb2x5bm9taWFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIENQb2x5bm9taWFsIGlzIGEgQ29tYmluZWQgUG9seW5vbWlhbCBvZiB0aGUgdHlwZSA6XG4vLyBDUG9seW5vbWlhbChYKSA6PSBQXzAoWF5uKSArIFjCt1BfMShYXm4pICsgLi4uICsgWF57bi0xfcK3UF97bi0xfShYXm4pXG4vLyBXZSBjYW4gdXNlIHRoaXMgY2xhc3MgdG8gYXZvaWQgdGhlIGFsbG9jYXRpb24gb2YgYSBiaWcgbWVtb3J5IGJ1ZmZlclxuLy8gZm9yIHRoZSBjb2VmZmljaWVudHMgYmVjYXVzZSBpbiBzb21lIGNhc2VzIGEgYmlnIG51bWJlciBvZiB0aGUgY29lZmZpY2llbnRzIGFyZSB6ZXJvXG5cbmltcG9ydCB7QmlnQnVmZmVyfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQge2xvZzJ9IGZyb20gXCIuLi9taXNjLmpzXCI7XG5pbXBvcnQge1BvbHlub21pYWx9IGZyb20gXCIuL3BvbHlub21pYWwuanNcIjtcblxuZXhwb3J0IGNsYXNzIENQb2x5bm9taWFsIHtcbiAgICBjb25zdHJ1Y3RvcihuLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMubiA9IG47XG4gICAgICAgIHRoaXMucG9seW5vbWlhbHMgPSBBcnJheShuKS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgdGhpcy5GciA9IGN1cnZlLkZyO1xuICAgICAgICB0aGlzLkcxID0gY3VydmUuRzE7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cblxuICAgIGFkZFBvbHlub21pYWwocG9zaXRpb24sIHBvbHlub21pYWwpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID4gdGhpcy5uIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ1BvbHlub21pYWw6YWRkUG9seW5vbWlhbCwgY2Fubm90IGFkZCBhIHBvbHlub21pYWwgdG8gYSBwb3NpdGlvbiBncmVhdGVyIHRoYW4gbi0xXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb2x5bm9taWFsc1twb3NpdGlvbl0gPSBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIGRlZ3JlZSgpIHtcbiAgICAgICAgbGV0IGRlZ3JlZXMgPSB0aGlzLnBvbHlub21pYWxzLm1hcChcbiAgICAgICAgICAgIChwb2x5bm9taWFsLCBpbmRleCkgPT4gcG9seW5vbWlhbCA9PT0gdW5kZWZpbmVkID8gMCA6IHBvbHlub21pYWwuZGVncmVlKCkgKiB0aGlzLm4gKyBpbmRleCk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCguLi5kZWdyZWVzKTtcbiAgICB9XG5cbiAgICBnZXRQb2x5bm9taWFsKCkge1xuICAgICAgICBsZXQgZGVncmVlcyA9IHRoaXMucG9seW5vbWlhbHMubWFwKHBvbHlub21pYWwgPT4gcG9seW5vbWlhbCA9PT0gdW5kZWZpbmVkID8gMCA6IHBvbHlub21pYWwuZGVncmVlKCkpO1xuICAgICAgICBjb25zdCBtYXhEZWdyZWUgPSB0aGlzLmRlZ3JlZSgpO1xuICAgICAgICBjb25zdCBsZW5ndGhCdWZmZXIgPSAyICoqIChsb2cyKG1heERlZ3JlZSAtIDEpICsgMSk7XG4gICAgICAgIGNvbnN0IHNGciA9IHRoaXMuRnIubjg7XG5cbiAgICAgICAgbGV0IHBvbHlub21pYWwgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKGxlbmd0aEJ1ZmZlciAqIHNGciksIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heERlZ3JlZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHNGcjtcbiAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaV9uOCAqIHRoaXMubjtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLm47IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvbHlub21pYWxzW2pdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPD0gZGVncmVlc1tqXSkgcG9seW5vbWlhbC5jb2VmLnNldCh0aGlzLnBvbHlub21pYWxzW2pdLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHNGciksIGlfc0ZyICsgaiAqIHNGcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlub21pYWw7XG4gICAgfVxuXG4gICAgYXN5bmMgbXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBuYW1lKSB7XG4gICAgICAgIGxldCBwb2x5bm9taWFsID0gdGhpcy5nZXRQb2x5bm9taWFsKCk7XG4gICAgICAgIGNvbnN0IG4gPSBwb2x5bm9taWFsLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjg7XG4gICAgICAgIGNvbnN0IFBUYXVOID0gUFRhdS5zbGljZSgwLCBuICogdGhpcy5HMS5GLm44ICogMik7XG4gICAgICAgIGNvbnN0IGJtID0gYXdhaXQgdGhpcy5Gci5iYXRjaEZyb21Nb250Z29tZXJ5KHBvbHlub21pYWwuY29lZik7XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLkcxLm11bHRpRXhwQWZmaW5lKFBUYXVOLCBibSwgdGhpcy5sb2dnZXIsIG5hbWUpO1xuICAgICAgICByZXMgPSB0aGlzLkcxLnRvQWZmaW5lKHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/polynomial/cpolynomial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/polynomial/evaluations.js":
/*!************************************************************!*\
  !*** ./node_modules/snarkjs/src/polynomial/evaluations.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Evaluations: () => (/* binding */ Evaluations)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nclass Evaluations {\n    constructor(evaluations, curve, logger) {\n        this.eval = evaluations;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.logger = logger;\n    }\n\n    static async fromPolynomial(polynomial, extension, curve, logger) {\n        const coefficientsN = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(polynomial.length() * extension * curve.Fr.n8);\n        coefficientsN.set(polynomial.coef, 0);\n\n        const evaluations = await curve.Fr.fft(coefficientsN);\n\n        return new Evaluations(evaluations, curve, logger);\n    }\n\n    getEvaluation(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.eval.byteLength) {\n            throw new Error(\"Evaluations.getEvaluation() out of bounds\");\n        }\n\n        return this.eval.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    length() {\n        let length = this.eval.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.eval.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial evaluations buffer has incorrect size\");\n        }\n        if (0 === length) {\n            this.logger.warn(\"Polynomial has length zero\");\n        }\n        return length;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG9seW5vbWlhbC9ldmFsdWF0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXVDOztBQUVoQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxtREFBUztBQUMzQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb2x5bm9taWFsL2V2YWx1YXRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7QmlnQnVmZmVyfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmV4cG9ydCBjbGFzcyBFdmFsdWF0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoZXZhbHVhdGlvbnMsIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5ldmFsID0gZXZhbHVhdGlvbnM7XG4gICAgICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgdGhpcy5GciA9IGN1cnZlLkZyO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgZnJvbVBvbHlub21pYWwocG9seW5vbWlhbCwgZXh0ZW5zaW9uLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IGNvZWZmaWNpZW50c04gPSBuZXcgQmlnQnVmZmVyKHBvbHlub21pYWwubGVuZ3RoKCkgKiBleHRlbnNpb24gKiBjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGNvZWZmaWNpZW50c04uc2V0KHBvbHlub21pYWwuY29lZiwgMCk7XG5cbiAgICAgICAgY29uc3QgZXZhbHVhdGlvbnMgPSBhd2FpdCBjdXJ2ZS5Gci5mZnQoY29lZmZpY2llbnRzTik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBFdmFsdWF0aW9ucyhldmFsdWF0aW9ucywgY3VydmUsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgZ2V0RXZhbHVhdGlvbihpbmRleCkge1xuICAgICAgICBjb25zdCBpX244ID0gaW5kZXggKiB0aGlzLkZyLm44O1xuXG4gICAgICAgIGlmIChpX244ICsgdGhpcy5Gci5uOCA+IHRoaXMuZXZhbC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmFsdWF0aW9ucy5nZXRFdmFsdWF0aW9uKCkgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmV2YWwuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpO1xuICAgIH1cblxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMuZXZhbC5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uODtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gTWF0aC5mbG9vcih0aGlzLmV2YWwuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5bm9taWFsIGV2YWx1YXRpb25zIGJ1ZmZlciBoYXMgaW5jb3JyZWN0IHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlBvbHlub21pYWwgaGFzIGxlbmd0aCB6ZXJvXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/polynomial/evaluations.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/polynomial/polynomial.js":
/*!***********************************************************!*\
  !*** ./node_modules/snarkjs/src/polynomial/polynomial.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polynomial: () => (/* binding */ Polynomial)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nclass Polynomial {\n    constructor(coefficients, curve, logger) {\n        this.coef = coefficients;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    static async fromEvaluations(buffer, curve, logger) {\n        let coefficients = await curve.Fr.ifft(buffer);\n\n        return new Polynomial(coefficients, curve, logger);\n    }\n\n    static fromCoefficientsArray(array, curve, logger) {\n        const Fr = curve.Fr;\n        let buff = array.length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(array.length * Fr.n8) : new Uint8Array(array.length * Fr.n8);\n        for (let i = 0; i < array.length; i++) buff.set(array[i], i * Fr.n8);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    static fromPolynomial(polynomial, curve, logger) {\n        let length = polynomial.length();\n        let Fr = curve.Fr;\n\n        let buff = length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        buff.set(polynomial.coef.slice(), 0);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    isEqual(polynomial) {\n        const degree = this.degree();\n        if (degree !== polynomial.degree()) return false;\n\n        for (let i = 0; i < degree + 1; i++) {\n            if (!this.Fr.eq(this.getCoef(i), polynomial.getCoef(i))) return false;\n        }\n\n        return true;\n    }\n\n    blindCoefficients(blindingFactors) {\n        blindingFactors = blindingFactors || [];\n\n        const blindedCoefficients = (this.length() + blindingFactors.length) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((this.length() + blindingFactors.length) * this.Fr.n8) :\n            new Uint8Array((this.length() + blindingFactors.length) * this.Fr.n8);\n\n        blindedCoefficients.set(this.coef, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            blindedCoefficients.set(\n                this.Fr.add(\n                    blindedCoefficients.slice((this.length() + i) * this.Fr.n8, (this.length() + i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                (this.length() + i) * this.Fr.n8\n            );\n            blindedCoefficients.set(\n                this.Fr.sub(\n                    blindedCoefficients.slice(i * this.Fr.n8, (i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * this.Fr.n8\n            );\n        }\n        this.coef = blindedCoefficients;\n    }\n\n    getCoef(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.coef.byteLength) return this.Fr.zero;\n\n        return this.coef.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    setCoef(index, value) {\n        if (index > (this.length() - 1)) {\n            throw new Error(\"Coef index is not available\");\n        }\n\n        this.coef.set(value, index * this.Fr.n8);\n    }\n\n    static async to4T(buffer, domainSize, blindingFactors, Fr) {\n        blindingFactors = blindingFactors || [];\n        let a = await Fr.ifft(buffer);\n\n        const a4 = (domainSize * 4) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(domainSize * 4 * Fr.n8) : new Uint8Array(domainSize * 4 * Fr.n8);\n        a4.set(a, 0);\n\n        const A4 = await Fr.fft(a4);\n\n        if (blindingFactors.length === 0) {\n            return [a, A4];\n        }\n\n        const a1 = domainSize + blindingFactors.length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((domainSize + blindingFactors.length) * Fr.n8) :\n            new Uint8Array((domainSize + blindingFactors.length) * Fr.n8);\n\n        a1.set(a, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            a1.set(\n                Fr.add(\n                    a1.slice((domainSize + i) * Fr.n8, (domainSize + i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                (domainSize + i) * Fr.n8\n            );\n            a1.set(\n                Fr.sub(\n                    a1.slice(i * Fr.n8, (i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * Fr.n8\n            );\n        }\n\n        return [a1, A4];\n    }\n\n    length() {\n        let length = this.coef.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.coef.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial coefficients buffer has incorrect size\");\n        }\n        if (0 === length) {\n            if (this.logger) {\n                this.logger.warn(\"Polynomial has length zero\");\n            }\n        }\n        return length;\n    }\n\n    degree() {\n        for (let i = this.length() - 1; i > 0; i--) {\n            const i_n8 = i * this.Fr.n8;\n            if (!this.Fr.eq(this.Fr.zero, this.coef.slice(i_n8, i_n8 + this.Fr.n8))) {\n                return i;\n            }\n        }\n\n        return 0;\n    }\n\n    evaluate(point) {\n        let res = this.Fr.zero;\n\n        for (let i = this.degree() + 1; i > 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            const currentCoefficient = this.coef.slice(i_n8 - this.Fr.n8, i_n8);\n            res = this.Fr.add(currentCoefficient, this.Fr.mul(res, point));\n        }\n\n        return res;\n    }\n\n    fastEvaluate(point) {\n        const Fr = this.Fr;\n        let nThreads = 3;\n\n        let nCoefs = this.degree() + 1;\n        let coefsThread = parseInt(nCoefs / nThreads);\n        let residualCoefs = nCoefs - coefsThread * nThreads;\n\n        let res = [];\n        let xN = [];\n\n        xN[0] = Fr.one;\n\n        for (let i = 0; i < nThreads; i++) {\n            res[i] = Fr.zero;\n\n            let nCoefs = i === (nThreads - 1) ? coefsThread + residualCoefs : coefsThread;\n            for (let j = nCoefs; j > 0; j--) {\n                res[i] = Fr.add(this.getCoef((i * coefsThread) + j - 1), Fr.mul(res[i], point));\n\n                if (i === 0) xN[0] = Fr.mul(xN[0], point);\n            }\n        }\n\n        for (let i = 1; i < nThreads; i++) {\n            res[0] = Fr.add(res[0], Fr.mul(xN[i - 1], res[i]));\n            xN[i] = Fr.mul(xN[i - 1], xN[0]);\n        }\n\n        return res[0];\n    }\n\n    add(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.add(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.add(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    sub(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.sub(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.sub(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    mulScalar(value) {\n        for (let i = 0; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            this.coef.set(this.Fr.mul(this.coef.slice(i_n8, i_n8 + this.Fr.n8), value), i_n8);\n        }\n    }\n\n    addScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.add(currentValue, value), 0);\n    }\n\n    subScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.sub(currentValue, value), 0);\n    }\n\n    // Multiply current polynomial by the polynomial (X - value)\n    byXSubValue(value) {\n        const Fr = this.Fr;\n        const resize = !Fr.eq(Fr.zero, this.getCoef(this.length() - 1));\n\n        const length = resize ? this.length() + 1 : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (length - 1) * Fr.n8), 32);\n\n        // Step 1: multiply each coefficient by (-value)\n        this.mulScalar(Fr.neg(value));\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Multiply current polynomial by the polynomial (X^n + value)\n    byXNSubValue(n, value) {\n        const Fr = this.Fr;\n        const resize = !(this.length() - n - 1 >= this.degree());\n\n        const length = resize ? this.length() + n : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (this.degree() + 1) * 32, ), n * 32);\n\n        // Step 1: multiply each coefficient by (- value)\n        this.mulScalar(value);\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Euclidean division\n    divBy(polynomial) {\n        const Fr = this.Fr;\n        const degreeA = this.degree();\n        const degreeB = polynomial.degree();\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = degreeA - degreeB; i >= 0; i--) {\n            this.setCoef(i, Fr.div(polR.getCoef(i + degreeB), polynomial.getCoef(degreeB)));\n            for (let j = 0; j <= degreeB; j++) {\n                polR.setCoef(i + j, Fr.sub(polR.getCoef(i + j), Fr.mul(this.getCoef(i), polynomial.getCoef(j))));\n            }\n        }\n\n        return polR;\n    }\n\n    // Division by a Polynomial of the form (x^m - beta)\n    divByMonic(m, beta) {\n        const Fr = this.Fr;\n\n        let d = this.degree();\n\n        let buffer = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n        let quotient = new Polynomial(buffer, this.curve, this.logger);\n\n        let bArr = [];\n\n        // Add the m leading coefficients of this to quotient\n        for (let i = 0; i < m; i++) {\n            quotient.setCoef((d - i) - m, this.getCoef(d - i));\n            bArr[i] = this.getCoef(d - i);\n        }\n\n        let nThreads = m;\n\n        let j = 0;\n        for (let k = 0; k < nThreads; k++) {\n            for (let i = d - 2 * m - k; i >= 0; i = i - nThreads) {\n                if (i < 0) break;\n                let idx = k;\n                bArr[idx] = Fr.add(this.getCoef(i + m), Fr.mul(bArr[idx], beta));\n\n                quotient.setCoef(i, bArr[idx]);\n                j = (j + 1) % m;\n            }\n        }\n\n        this.coef = quotient.coef;\n    }\n\n    divByVanishing(n, beta) {\n        if (this.degree() < n) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = this.length() - 1; i >= n; i--) {\n            let leadingCoef = polR.getCoef(i);\n            if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n            polR.setCoef(i, Fr.zero);\n            polR.setCoef(i - n, Fr.add(polR.getCoef(i - n), Fr.mul(beta, leadingCoef)));\n            this.setCoef(i - n, Fr.add(this.getCoef(i - n), leadingCoef));\n        }\n\n        return polR;\n    }\n\n    divByVanishing2(m, beta) {\n        if (this.degree() < m) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        let nThreads = 3;\n        let nTotal = this.length() - m;\n        let nElementsChunk = Math.floor(nTotal / nThreads);\n        let nElementsLast = nTotal - (nThreads - 1) * nElementsChunk;\n\n        console.log(nTotal);\n        console.log(nElementsChunk + \"  \" + nElementsLast);\n        for (let k = 0; k < nThreads; k++) {\n            console.log(\"> Thread \" + k);\n            for (let i = (k === 0 ? nElementsLast : nElementsChunk); i > 0; i--) {\n                let idxDst = i - 1;\n                if (k !== 0) idxDst += (k - 1) * nElementsChunk + nElementsLast;\n                let idxSrc = idxDst + m;\n\n                let leadingCoef = polR.getCoef(idxSrc);\n                if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n                polR.setCoef(idxSrc, Fr.zero);\n                polR.setCoef(idxDst, Fr.add(polR.getCoef(idxDst), Fr.mul(beta, leadingCoef)));\n                this.setCoef(idxDst, Fr.add(this.getCoef(idxDst), leadingCoef));\n                console.log(idxDst + \" <-- \" + idxSrc);\n            }\n        }\n\n        this.print();\n        return polR;\n    }\n\n    fastDivByVanishing(data) {\n        const Fr = this.Fr;\n\n        for (let i = 0; i < data.length; i++) {\n\n            let m = data[i][0];\n            let beta = data[i][1];\n\n            if (this.degree() < m) {\n                throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n            }\n\n            let nThreads = 5;\n            let nElements = this.length() - m;\n            let nElementsBucket = Math.floor(nElements / nThreads / m);\n            let nElementsChunk = nElementsBucket * m;\n            let nElementsLast = nElements - nThreads * nElementsChunk;\n\n            //In C++ implementation this buffer will be allocated only once outside the loop\n            let polTmp = new Polynomial(this.length() > 2 << 14 ?\n                new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8), this.curve, this.logger);\n\n            let ptr = this.coef;\n            this.coef = polTmp.coef;\n            polTmp.coef = ptr;\n\n            // STEP 1: Setejar els m valors del segent bucket al chunk actual, PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n                let idx0 = (k + 1) * nElementsChunk + nElementsLast;\n                for (let i = 0; i < m; i++) {\n                    this.setCoef(idx0 + i - m, polTmp.getCoef(idx0 + i));\n                }\n\n                for (let i = 0; i < nElementsChunk - m; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                    this.setCoef(offset - m, val);\n                }\n            }\n\n            //STEP 2: Setejar els valors del elements last NO PARALLELITZAR\n            let idx0 = nElementsLast;\n            let pending = nElementsLast;\n            for (let i = 0; i < m && pending; i++) {\n                this.setCoef(idx0 - i - 1, polTmp.getCoef(idx0 + m - i - 1));\n                pending--;\n            }\n\n            for (let i = 0; i < pending; i++) {\n                let offset = idx0 - i - 1;\n                let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                this.setCoef(offset - m, val);\n            }\n\n            //Step 3: calcular acumulats NO  PARALELLITZAR\n\n            let acc = [];\n            let betaPow = Fr.one;\n            for (let i = 0; i < nElementsBucket; i++) {\n                betaPow = Fr.mul(betaPow, beta);\n            }\n            let currentBeta = Fr.one;\n\n            for (let k = nThreads; k > 0; k--) {\n                let idThread = k - 1;\n                let idx0 = idThread * nElementsChunk + nElementsLast;\n                acc[idThread] = [];\n\n                for (let i = 0; i < m; i++) {\n                    acc[idThread][i] = this.getCoef(idx0 + i);\n\n                    if (k !== nThreads) {\n                        acc[idThread][i] = Fr.add(acc[idThread][i], Fr.mul(betaPow, acc[idThread + 1][i]));\n                    }\n                }\n                currentBeta = Fr.mul(currentBeta, betaPow);\n            }\n\n            //STEP 4 recalcular  PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n\n                let idx0 = k * nElementsChunk + nElementsLast;\n                let currentBeta = beta; //Quan hopassem a C++ i ho paralelitzem aquesta variable ha de ser privada\n                let currentM = m - 1;\n\n                let limit = k === 0 ? nElementsLast : nElementsChunk;\n                for (let i = 0; i < limit; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(this.getCoef(offset), Fr.mul(currentBeta, acc[k][currentM]));\n\n                    this.setCoef(offset, val);\n\n                    // To avoid modular operations in each loop...\n                    if (currentM === 0) {\n                        currentM = m - 1;\n                        currentBeta = Fr.mul(currentBeta, beta);\n                    } else {\n                        currentM--;\n                    }\n                }\n            }\n        }\n    }\n\n\n    // Divide polynomial by X - value\n    divByXSubValue(value) {\n        const coefs = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * this.Fr.n8) : new Uint8Array(this.length() * this.Fr.n8);\n\n        coefs.set(this.Fr.zero, (this.length() - 1) * this.Fr.n8);\n        coefs.set(this.coef.slice((this.length() - 1) * this.Fr.n8, this.length() * this.Fr.n8), (this.length() - 2) * this.Fr.n8);\n        for (let i = this.length() - 3; i >= 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            coefs.set(\n                this.Fr.add(\n                    this.coef.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8),\n                    this.Fr.mul(value, coefs.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8))\n                ),\n                i * this.Fr.n8\n            );\n        }\n        if (!this.Fr.eq(\n            this.coef.slice(0, this.Fr.n8),\n            this.Fr.mul(this.Fr.neg(value), coefs.slice(0, this.Fr.n8))\n        )) {\n            throw new Error(\"Polynomial does not divide\");\n        }\n\n        this.coef = coefs;\n    }\n\n    divZh(domainSize, extensions = 4) {\n        for (let i = 0; i < domainSize; i++) {\n            const i_n8 = i * this.Fr.n8;\n            this.coef.set(this.Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8)), i_n8);\n        }\n\n        const upperBound = this.coef.byteLength / this.Fr.n8;\n        for (let i = domainSize; i < upperBound; i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = this.Fr.sub(\n                this.coef.slice((i - domainSize) * this.Fr.n8, (i - domainSize) * this.Fr.n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n            this.coef.set(a, i_n8);\n            if (i > (domainSize * (extensions-1) - extensions)) {\n                if (!this.Fr.isZero(a)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n    divByZerofier(n, beta) {\n        let Fr = this.Fr;\n        const invBeta = Fr.inv(beta);\n        const invBetaNeg = Fr.neg(invBeta);\n\n        let isOne = Fr.eq(Fr.one, invBetaNeg);\n        let isNegOne = Fr.eq(Fr.negone, invBetaNeg);\n\n        if (!isOne) {\n            for (let i = 0; i < n; i++) {\n                const i_n8 = i * this.Fr.n8;\n                let element;\n\n                // If invBetaNeg === -1 we'll save a multiplication changing it by a neg function call\n                if (isNegOne) {\n                    element = Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                } else {\n                    element = Fr.mul(invBetaNeg, this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                }\n\n                this.coef.set(element, i_n8);\n            }\n        }\n\n        isOne = Fr.eq(Fr.one, invBeta);\n        isNegOne = Fr.eq(Fr.negone, invBeta);\n\n        for (let i = n; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n            const i_prev_n8 = (i - n) * this.Fr.n8;\n\n            let element = this.Fr.sub(\n                this.coef.slice(i_prev_n8, i_prev_n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n\n            // If invBeta === 1 we'll not do anything\n            if(!isOne) {\n                // If invBeta === -1 we'll save a multiplication changing it by a neg function call\n                if(isNegOne) {\n                    element = Fr.neg(element);\n                } else {\n                    element = Fr.mul(invBeta, element);\n                }\n            }\n\n            this.coef.set(element, i_n8);\n\n            // Check if polynomial is divisible by checking if n high coefficients are zero\n            if (i > this.length() - n - 1) {\n                if (!this.Fr.isZero(element)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n// function divideByVanishing(f, n, p) {\n//     // polynomial division f(X) / (X^n - 1) with remainder\n//     // very cheap, 0 multiplications\n//     // strategy:\n//     // start with q(X) = 0, r(X) = f(X)\n//     // then start changing q, r while preserving the identity:\n//     // f(X) = q(X) * (X^n - 1) + r(X)\n//     // in every step, move highest-degree term of r into the product\n//     // => r eventually has degree < n and we're done\n//     let q = Array(f.length).fill(0n);\n//     let r = [...f];\n//     for (let i = f.length - 1; i >= n; i--) {\n//         let leadingCoeff = r[i];\n//         if (leadingCoeff === 0n) continue;\n//         r[i] = 0n;\n//         r[i - n] = mod(r[i - n] + leadingCoeff, p);\n//         q[i - n] = mod(q[i - n] + leadingCoeff, p);\n//     }\n//     return [q, r];\n// }\n\n    byX() {\n        const coefs = (this.length() + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.coef.byteLength + this.Fr.n8) : new Uint8Array(this.coef.byteLength + this.Fr.n8);\n        coefs.set(this.Fr.zero, 0);\n        coefs.set(this.coef, this.Fr.n8);\n\n        this.coef = coefs;\n    }\n\n// Compute a new polynomial f(x^n) from f(x)\n// f(x)   = a_0 + a_1x + a_2x^2 + ... + a_jx^j\n// f(x^n) = a_0 + a_1x^n + a_2x^2n + ... + a_jx^jn\n    static\n    async expX(polynomial, n, truncate = false) {\n        const Fr = polynomial.Fr;\n\n        if (n < 1) {\n            // n == 0 not allowed because it has no sense, but if it's necessary we have to return\n            // a zero degree polynomial with a constant coefficient equals to the sum of all the original coefficients\n            throw new Error(\"Compute a new polynomial to a zero or negative number is not allowed\");\n        } else if (1 === n) {\n            return await Polynomial.fromEvaluations(polynomial.coef, curve, polynomial.logger);\n        }\n\n        // length is the length of non-constant coefficients\n        // if truncate === true, the highest zero coefficients (if exist) will be removed\n        const length = truncate ? polynomial.degree() : (polynomial.length() - 1);\n        const bufferDst = (length * n + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((length * n + 1) * Fr.n8) : new Uint8Array((length * n + 1) * Fr.n8);\n\n        // Copy constant coefficient as is because is not related to x\n        bufferDst.set(polynomial.getCoef(0), 0);\n\n        for (let i = 1; i <= length; i++) {\n            const i_sFr = i * Fr.n8;\n\n            const coef = polynomial.getCoef(i);\n            bufferDst.set(coef, i_sFr * n);\n        }\n\n        return new Polynomial(bufferDst, polynomial.curve, polynomial.logger);\n    }\n\n    split(numPols, degPols, blindingFactors) {\n        if (numPols < 1) {\n            throw new Error(`Polynomials can't be split in ${numPols} parts`);\n        } else if (1 === numPols) {\n            return [this];\n        }\n\n        //blinding factors can be void or must have a length of numPols - 1\n        if (0 !== blindingFactors.length && blindingFactors.length < numPols - 1) {\n            throw new Error(`Blinding factors length must be ${numPols - 1}`);\n        }\n\n        const chunkByteLength = (degPols + 1) * this.Fr.n8;\n        let res = [];\n\n        // Check polynomial can be split in numChunks parts of chunkSize bytes...\n        const numRealPols = Math.ceil((this.degree() + 1) * this.Fr.n8 / chunkByteLength);\n        if (numRealPols < numPols) {\n            //throw new Error(`Polynomial is short to be split in ${numPols} parts of ${degPols} coefficients each.`);\n            for (let i = numRealPols; i < numPols; i++) {\n                res[i] = new Polynomial(new Uint8Array(this.Fr.n8), this.curve, this.logger);\n            }\n        }\n\n        numPols = Math.min(numPols, numRealPols);\n        for (let i = 0; i < numPols; i++) {\n            const isLast = (numPols - 1) === i;\n            const byteLength = isLast ? this.coef.byteLength - ((numPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n\n            let buff = (byteLength / this.Fr.n8) > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(byteLength) : new Uint8Array(byteLength);\n            res[i] = new Polynomial(buff, this.curve, this.logger);\n\n            const fr = i * chunkByteLength;\n            const to = isLast ? this.coef.byteLength : (i + 1) * chunkByteLength;\n            res[i].coef.set(this.coef.slice(fr, to), 0);\n\n            // Add a blinding factor as higher degree\n            if (!isLast) {\n                res[i].coef.set(blindingFactors[i], chunkByteLength);\n            }\n\n            // Sub blinding factor to the lowest degree\n            if (0 !== i) {\n                const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n                res[i].coef.set(lowestDegree, 0);\n            }\n\n            if (isLast) {\n                res[i].truncate();\n            }\n        }\n\n        return res;\n\n        // // compute t_low(X)\n        // let polTLow = new BigBuffer((chunkSize + 1) * n8r);\n        // polTLow.set(t.slice(0, zkey.domainSize * n8r), 0);\n        // // Add blinding scalar b_10 as a new coefficient n\n        // polTLow.set(ch.b[10], zkey.domainSize * n8r);\n        //\n        // // compute t_mid(X)\n        // let polTMid = new BigBuffer((zkey.domainSize + 1) * n8r);\n        // polTMid.set(t.slice(zkey.domainSize * n8r, zkey.domainSize * 2 * n8r), 0);\n        // // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        // const lowestMid = Fr.sub(polTMid.slice(0, n8r), ch.b[10]);\n        // polTMid.set(lowestMid, 0);\n        // // Add blinding scalar b_11 as a new coefficient n\n        // polTMid.set(ch.b[11], zkey.domainSize * n8r);\n        //\n        // // compute t_high(X)\n        // let polTHigh = new BigBuffer((zkey.domainSize + 6) * n8r);\n        // polTHigh.set(t.slice(zkey.domainSize * 2 * n8r, (zkey.domainSize * 3 + 6) * n8r), 0);\n        // //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        // const lowestHigh = Fr.sub(polTHigh.slice(0, n8r), ch.b[11]);\n        // polTHigh.set(lowestHigh, 0);\n        //\n        // proof.T1 = await expTau(polTLow, \"multiexp T1\");\n        // proof.T2 = await expTau(polTMid, \"multiexp T2\");\n        // proof.T3 = await expTau(polTHigh, \"multiexp T3\");\n    }\n\n// split2(degPols, blindingFactors) {\n//     let currentDegree = this.degree();\n//     const numFilledPols = Math.ceil((currentDegree + 1) / (degPols + 1));\n//\n//     //blinding factors can be void or must have a length of numPols - 1\n//     if (0 !== blindingFactors.length && blindingFactors.length < numFilledPols - 1) {\n//         throw new Error(`Blinding factors length must be ${numFilledPols - 1}`);\n//     }\n//\n//     const chunkByteLength = (degPols + 1) * this.Fr.n8;\n//\n//     // Check polynomial can be split in numChunks parts of chunkSize bytes...\n//     if (this.coef.byteLength / chunkByteLength <= numFilledPols - 1) {\n//         throw new Error(`Polynomial is short to be split in ${numFilledPols} parts of ${degPols} coefficients each.`);\n//     }\n//\n//     let res = [];\n//     for (let i = 0; i < numFilledPols; i++) {\n//         const isLast = (numFilledPols - 1) === i;\n//         const byteLength = isLast ? (currentDegree + 1) * this.Fr.n8 - ((numFilledPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n//\n//         res[i] = new Polynomial(new BigBuffer(byteLength), this.Fr, this.logger);\n//         const fr = i * chunkByteLength;\n//         const to = isLast ? (currentDegree + 1) * this.Fr.n8 : (i + 1) * chunkByteLength;\n//         res[i].coef.set(this.coef.slice(fr, to), 0);\n//\n//         // Add a blinding factor as higher degree\n//         if (!isLast) {\n//             res[i].coef.set(blindingFactors[i], chunkByteLength);\n//         }\n//\n//         // Sub blinding factor to the lowest degree\n//         if (0 !== i) {\n//             const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n//             res[i].coef.set(lowestDegree, 0);\n//         }\n//     }\n//\n//     return res;\n// }\n\n// merge(pols, overlap = true) {\n//     let length = 0;\n//     for (let i = 0; i < pols.length; i++) {\n//         length += pols[i].length();\n//     }\n//\n//     if (overlap) {\n//         length -= pols.length - 1;\n//     }\n//\n//     let res = new Polynomial(new BigBuffer(length * this.Fr.n8));\n//     for (let i = 0; i < pols.length; i++) {\n//         const byteLength = pols[i].coef.byteLength;\n//         if (0 === i) {\n//             res.coef.set(pols[i].coef, 0);\n//         } else {\n//\n//         }\n//     }\n//\n//     return res;\n// }\n\n    truncate() {\n        const deg = this.degree();\n        if (deg + 1 < this.coef.byteLength / this.Fr.n8) {\n            const newCoefs = (deg + 1) > 2 << 14 ?\n                new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((deg + 1) * this.Fr.n8) : new Uint8Array((deg + 1) * this.Fr.n8);\n\n            newCoefs.set(this.coef.slice(0, (deg + 1) * this.Fr.n8), 0);\n            this.coef = newCoefs;\n        }\n    }\n\n    static lagrangePolynomialInterpolation(xArr, yArr, curve) {\n        const Fr = curve.Fr;\n        let polynomial = computeLagrangePolynomial(0);\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.add(computeLagrangePolynomial(i));\n        }\n\n        return polynomial;\n\n        function computeLagrangePolynomial(i) {\n            let polynomial;\n\n            for (let j = 0; j < xArr.length; j++) {\n                if (j === i) continue;\n\n                if (polynomial === undefined) {\n                    let buff = (xArr.length) > 2 << 14 ?\n                        new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((xArr.length) * Fr.n8) : new Uint8Array((xArr.length) * Fr.n8);\n                    polynomial = new Polynomial(buff, curve);\n                    polynomial.setCoef(0, Fr.neg(xArr[j]));\n                    polynomial.setCoef(1, Fr.one);\n                } else {\n                    polynomial.byXSubValue(xArr[j]);\n                }\n            }\n\n            let denominator = polynomial.evaluate(xArr[i]);\n            denominator = Fr.inv(denominator);\n            const mulFactor = Fr.mul(yArr[i], denominator);\n\n            polynomial.mulScalar(mulFactor);\n\n            return polynomial;\n        }\n    }\n\n    static zerofierPolynomial(xArr, curve) {\n        const Fr = curve.Fr;\n        let buff = (xArr.length + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((xArr.length + 1) * Fr.n8) : new Uint8Array((xArr.length + 1) * Fr.n8);\n        let polynomial = new Polynomial(buff, curve);\n\n        // Build a zerofier polynomial with the following form:\n        // zerofier(X) = (X-xArr[0])(X-xArr[1])...(X-xArr[n])\n        polynomial.setCoef(0, Fr.neg(xArr[0]));\n        polynomial.setCoef(1, Fr.one);\n\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.byXSubValue(xArr[i]);\n        }\n\n        return polynomial;\n    }\n\n    print() {\n        const Fr = this.Fr;\n        let res = \"\";\n        for (let i = this.degree(); i >= 0; i--) {\n            const coef = this.getCoef(i);\n            if (!Fr.eq(Fr.zero, coef)) {\n                if (Fr.isNegative(coef)) {\n                    res += \" - \";\n                } else if (i !== this.degree()) {\n                    res += \" + \";\n                }\n                res += Fr.toString(coef);\n                if (i > 0) {\n                    res += i > 1 ? \"x^\" + i : \"x\";\n                }\n            }\n        }\n        console.log(res);\n    }\n\n    async multiExponentiation(PTau, name) {\n        const n = this.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(this.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG9seW5vbWlhbC9wb2x5bm9taWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFdUM7O0FBRWhDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qix3QkFBd0Isa0JBQWtCOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1EQUFTO0FBQ3pCOztBQUVBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbURBQVM7QUFDekI7O0FBRUE7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixjQUFjO0FBQ3RDOztBQUVBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQXNDO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isc0NBQXNDO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsbURBQVM7QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLG1EQUFTO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6Qix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6Qix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsbURBQVM7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBLHFFQUFxRSxPQUFPO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVM7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTs7QUFFQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsT0FBTztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsY0FBYzs7QUFFMUM7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6QjtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6QjtBQUNBOztBQUVBLHdCQUF3QixhQUFhO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsU0FBUyxXQUFXLFNBQVM7QUFDakcsc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTs7QUFFQSxpRUFBaUUsbURBQVM7QUFDMUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0JBQWtCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxlQUFlLFdBQVcsU0FBUztBQUNwRztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVM7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixpQkFBaUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixtREFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb2x5bm9taWFsL3BvbHlub21pYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHtCaWdCdWZmZXJ9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuZXhwb3J0IGNsYXNzIFBvbHlub21pYWwge1xuICAgIGNvbnN0cnVjdG9yKGNvZWZmaWNpZW50cywgY3VydmUsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmNvZWYgPSBjb2VmZmljaWVudHM7XG4gICAgICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgdGhpcy5GciA9IGN1cnZlLkZyO1xuICAgICAgICB0aGlzLkcxID0gY3VydmUuRzE7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBmcm9tRXZhbHVhdGlvbnMoYnVmZmVyLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGxldCBjb2VmZmljaWVudHMgPSBhd2FpdCBjdXJ2ZS5Gci5pZmZ0KGJ1ZmZlcik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGNvZWZmaWNpZW50cywgY3VydmUsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21Db2VmZmljaWVudHNBcnJheShhcnJheSwgY3VydmUsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBsZXQgYnVmZiA9IGFycmF5Lmxlbmd0aCA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcihhcnJheS5sZW5ndGggKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShhcnJheS5sZW5ndGggKiBGci5uOCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIGJ1ZmYuc2V0KGFycmF5W2ldLCBpICogRnIubjgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9seW5vbWlhbChidWZmLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVBvbHlub21pYWwocG9seW5vbWlhbCwgY3VydmUsIGxvZ2dlcikge1xuICAgICAgICBsZXQgbGVuZ3RoID0gcG9seW5vbWlhbC5sZW5ndGgoKTtcbiAgICAgICAgbGV0IEZyID0gY3VydmUuRnI7XG5cbiAgICAgICAgbGV0IGJ1ZmYgPSBsZW5ndGggPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIobGVuZ3RoICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkobGVuZ3RoICogRnIubjgpO1xuICAgICAgICBidWZmLnNldChwb2x5bm9taWFsLmNvZWYuc2xpY2UoKSwgMCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGJ1ZmYsIGN1cnZlLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIGlzRXF1YWwocG9seW5vbWlhbCkge1xuICAgICAgICBjb25zdCBkZWdyZWUgPSB0aGlzLmRlZ3JlZSgpO1xuICAgICAgICBpZiAoZGVncmVlICE9PSBwb2x5bm9taWFsLmRlZ3JlZSgpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWdyZWUgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5Gci5lcSh0aGlzLmdldENvZWYoaSksIHBvbHlub21pYWwuZ2V0Q29lZihpKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGJsaW5kQ29lZmZpY2llbnRzKGJsaW5kaW5nRmFjdG9ycykge1xuICAgICAgICBibGluZGluZ0ZhY3RvcnMgPSBibGluZGluZ0ZhY3RvcnMgfHwgW107XG5cbiAgICAgICAgY29uc3QgYmxpbmRlZENvZWZmaWNpZW50cyA9ICh0aGlzLmxlbmd0aCgpICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIoKHRoaXMubGVuZ3RoKCkgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSAqIHRoaXMuRnIubjgpIDpcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KCh0aGlzLmxlbmd0aCgpICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCkgKiB0aGlzLkZyLm44KTtcblxuICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNldCh0aGlzLmNvZWYsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsaW5kaW5nRmFjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYmxpbmRlZENvZWZmaWNpZW50cy5zZXQoXG4gICAgICAgICAgICAgICAgdGhpcy5Gci5hZGQoXG4gICAgICAgICAgICAgICAgICAgIGJsaW5kZWRDb2VmZmljaWVudHMuc2xpY2UoKHRoaXMubGVuZ3RoKCkgKyBpKSAqIHRoaXMuRnIubjgsICh0aGlzLmxlbmd0aCgpICsgaSArIDEpICogdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgICAgIGJsaW5kaW5nRmFjdG9yc1tpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKHRoaXMubGVuZ3RoKCkgKyBpKSAqIHRoaXMuRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNldChcbiAgICAgICAgICAgICAgICB0aGlzLkZyLnN1YihcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRlZENvZWZmaWNpZW50cy5zbGljZShpICogdGhpcy5Gci5uOCwgKGkgKyAxKSAqIHRoaXMuRnIubjgpLFxuICAgICAgICAgICAgICAgICAgICBibGluZGluZ0ZhY3RvcnNbaV1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGkgKiB0aGlzLkZyLm44XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29lZiA9IGJsaW5kZWRDb2VmZmljaWVudHM7XG4gICAgfVxuXG4gICAgZ2V0Q29lZihpbmRleCkge1xuICAgICAgICBjb25zdCBpX244ID0gaW5kZXggKiB0aGlzLkZyLm44O1xuXG4gICAgICAgIGlmIChpX244ICsgdGhpcy5Gci5uOCA+IHRoaXMuY29lZi5ieXRlTGVuZ3RoKSByZXR1cm4gdGhpcy5Gci56ZXJvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpO1xuICAgIH1cblxuICAgIHNldENvZWYoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmRleCA+ICh0aGlzLmxlbmd0aCgpIC0gMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZWYgaW5kZXggaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29lZi5zZXQodmFsdWUsIGluZGV4ICogdGhpcy5Gci5uOCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIHRvNFQoYnVmZmVyLCBkb21haW5TaXplLCBibGluZGluZ0ZhY3RvcnMsIEZyKSB7XG4gICAgICAgIGJsaW5kaW5nRmFjdG9ycyA9IGJsaW5kaW5nRmFjdG9ycyB8fCBbXTtcbiAgICAgICAgbGV0IGEgPSBhd2FpdCBGci5pZmZ0KGJ1ZmZlcik7XG5cbiAgICAgICAgY29uc3QgYTQgPSAoZG9tYWluU2l6ZSAqIDQpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUgKiA0ICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoZG9tYWluU2l6ZSAqIDQgKiBGci5uOCk7XG4gICAgICAgIGE0LnNldChhLCAwKTtcblxuICAgICAgICBjb25zdCBBNCA9IGF3YWl0IEZyLmZmdChhNCk7XG5cbiAgICAgICAgaWYgKGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbYSwgQTRdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYTEgPSBkb21haW5TaXplICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigoZG9tYWluU2l6ZSArIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGgpICogRnIubjgpIDpcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KChkb21haW5TaXplICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCkgKiBGci5uOCk7XG5cbiAgICAgICAgYTEuc2V0KGEsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsaW5kaW5nRmFjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYTEuc2V0KFxuICAgICAgICAgICAgICAgIEZyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgYTEuc2xpY2UoKGRvbWFpblNpemUgKyBpKSAqIEZyLm44LCAoZG9tYWluU2l6ZSArIGkgKyAxKSAqIEZyLm44KSxcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRpbmdGYWN0b3JzW2ldXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZG9tYWluU2l6ZSArIGkpICogRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhMS5zZXQoXG4gICAgICAgICAgICAgICAgRnIuc3ViKFxuICAgICAgICAgICAgICAgICAgICBhMS5zbGljZShpICogRnIubjgsIChpICsgMSkgKiBGci5uOCksXG4gICAgICAgICAgICAgICAgICAgIGJsaW5kaW5nRmFjdG9yc1tpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaSAqIEZyLm44XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFthMSwgQTRdO1xuICAgIH1cblxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uODtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gTWF0aC5mbG9vcih0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5bm9taWFsIGNvZWZmaWNpZW50cyBidWZmZXIgaGFzIGluY29ycmVjdCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvZ2dlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJQb2x5bm9taWFsIGhhcyBsZW5ndGggemVyb1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cblxuICAgIGRlZ3JlZSgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoKCkgLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICBpZiAoIXRoaXMuRnIuZXEodGhpcy5Gci56ZXJvLCB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZXZhbHVhdGUocG9pbnQpIHtcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuRnIuemVybztcblxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5kZWdyZWUoKSArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29lZmZpY2llbnQgPSB0aGlzLmNvZWYuc2xpY2UoaV9uOCAtIHRoaXMuRnIubjgsIGlfbjgpO1xuICAgICAgICAgICAgcmVzID0gdGhpcy5Gci5hZGQoY3VycmVudENvZWZmaWNpZW50LCB0aGlzLkZyLm11bChyZXMsIHBvaW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZhc3RFdmFsdWF0ZShwb2ludCkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGxldCBuVGhyZWFkcyA9IDM7XG5cbiAgICAgICAgbGV0IG5Db2VmcyA9IHRoaXMuZGVncmVlKCkgKyAxO1xuICAgICAgICBsZXQgY29lZnNUaHJlYWQgPSBwYXJzZUludChuQ29lZnMgLyBuVGhyZWFkcyk7XG4gICAgICAgIGxldCByZXNpZHVhbENvZWZzID0gbkNvZWZzIC0gY29lZnNUaHJlYWQgKiBuVGhyZWFkcztcblxuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGxldCB4TiA9IFtdO1xuXG4gICAgICAgIHhOWzBdID0gRnIub25lO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgblRocmVhZHM7IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gRnIuemVybztcblxuICAgICAgICAgICAgbGV0IG5Db2VmcyA9IGkgPT09IChuVGhyZWFkcyAtIDEpID8gY29lZnNUaHJlYWQgKyByZXNpZHVhbENvZWZzIDogY29lZnNUaHJlYWQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gbkNvZWZzOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gRnIuYWRkKHRoaXMuZ2V0Q29lZigoaSAqIGNvZWZzVGhyZWFkKSArIGogLSAxKSwgRnIubXVsKHJlc1tpXSwgcG9pbnQpKTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB4TlswXSA9IEZyLm11bCh4TlswXSwgcG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuVGhyZWFkczsgaSsrKSB7XG4gICAgICAgICAgICByZXNbMF0gPSBGci5hZGQocmVzWzBdLCBGci5tdWwoeE5baSAtIDFdLCByZXNbaV0pKTtcbiAgICAgICAgICAgIHhOW2ldID0gRnIubXVsKHhOW2kgLSAxXSwgeE5bMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc1swXTtcbiAgICB9XG5cbiAgICBhZGQocG9seW5vbWlhbCwgYmxpbmRpbmdWYWx1ZSkge1xuICAgICAgICBsZXQgb3RoZXIgPSBmYWxzZTtcblxuICAgICAgICBpZiAocG9seW5vbWlhbC5sZW5ndGgoKSA+IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIG90aGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBjb25zdCBwb2x5TGVuZ3RoID0gcG9seW5vbWlhbC5sZW5ndGgoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heCh0aGlzTGVuZ3RoLCBwb2x5TGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgICAgIGNvbnN0IGEgPSBpIDwgdGhpc0xlbmd0aCA/IHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkgOiB0aGlzLkZyLnplcm87XG4gICAgICAgICAgICBsZXQgYiA9IGkgPCBwb2x5TGVuZ3RoID8gcG9seW5vbWlhbC5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSA6IHRoaXMuRnIuemVybztcblxuICAgICAgICAgICAgaWYgKGJsaW5kaW5nVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGIgPSB0aGlzLkZyLm11bChiLCBibGluZGluZ1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgICAgIHBvbHlub21pYWwuY29lZi5zZXQodGhpcy5Gci5hZGQoYSwgYiksIGlfbjgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIuYWRkKGEsIGIpLCBpX244KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvZWY7XG4gICAgICAgICAgICB0aGlzLmNvZWYgPSBwb2x5bm9taWFsLmNvZWY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdWIocG9seW5vbWlhbCwgYmxpbmRpbmdWYWx1ZSkge1xuICAgICAgICBsZXQgb3RoZXIgPSBmYWxzZTtcblxuICAgICAgICBpZiAocG9seW5vbWlhbC5sZW5ndGgoKSA+IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIG90aGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBjb25zdCBwb2x5TGVuZ3RoID0gcG9seW5vbWlhbC5sZW5ndGgoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heCh0aGlzTGVuZ3RoLCBwb2x5TGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgICAgIGNvbnN0IGEgPSBpIDwgdGhpc0xlbmd0aCA/IHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkgOiB0aGlzLkZyLnplcm87XG4gICAgICAgICAgICBsZXQgYiA9IGkgPCBwb2x5TGVuZ3RoID8gcG9seW5vbWlhbC5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSA6IHRoaXMuRnIuemVybztcblxuICAgICAgICAgICAgaWYgKGJsaW5kaW5nVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGIgPSB0aGlzLkZyLm11bChiLCBibGluZGluZ1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgICAgIHBvbHlub21pYWwuY29lZi5zZXQodGhpcy5Gci5zdWIoYSwgYiksIGlfbjgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIuc3ViKGEsIGIpLCBpX244KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvZWY7XG4gICAgICAgICAgICB0aGlzLmNvZWYgPSBwb2x5bm9taWFsLmNvZWY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtdWxTY2FsYXIodmFsdWUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgdGhpcy5jb2VmLnNldCh0aGlzLkZyLm11bCh0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpLCB2YWx1ZSksIGlfbjgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkU2NhbGFyKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IDAgPT09IHRoaXMubGVuZ3RoKCkgPyB0aGlzLkZyLnplcm8gOiB0aGlzLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCk7XG4gICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5hZGQoY3VycmVudFZhbHVlLCB2YWx1ZSksIDApO1xuICAgIH1cblxuICAgIHN1YlNjYWxhcih2YWx1ZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSAwID09PSB0aGlzLmxlbmd0aCgpID8gdGhpcy5Gci56ZXJvIDogdGhpcy5jb2VmLnNsaWNlKDAsIHRoaXMuRnIubjgpO1xuICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIuc3ViKGN1cnJlbnRWYWx1ZSwgdmFsdWUpLCAwKTtcbiAgICB9XG5cbiAgICAvLyBNdWx0aXBseSBjdXJyZW50IHBvbHlub21pYWwgYnkgdGhlIHBvbHlub21pYWwgKFggLSB2YWx1ZSlcbiAgICBieVhTdWJWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9ICFGci5lcShGci56ZXJvLCB0aGlzLmdldENvZWYodGhpcy5sZW5ndGgoKSAtIDEpKTtcblxuICAgICAgICBjb25zdCBsZW5ndGggPSByZXNpemUgPyB0aGlzLmxlbmd0aCgpICsgMSA6IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBsZW5ndGggPiAyIDw8IDE0ID8gbmV3IEJpZ0J1ZmZlcihsZW5ndGggKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShsZW5ndGggKiBGci5uOCk7XG4gICAgICAgIGxldCBwb2wgPSBuZXcgUG9seW5vbWlhbChidWZmLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgLy8gU3RlcCAwOiBTZXQgY3VycmVudCBjb2VmZmljaWVudHMgdG8gdGhlIG5ldyBidWZmZXIgc2hpZnRlZCBvbmUgcG9zaXRpb25cbiAgICAgICAgcG9sLmNvZWYuc2V0KHRoaXMuY29lZi5zbGljZSgwLCAobGVuZ3RoIC0gMSkgKiBGci5uOCksIDMyKTtcblxuICAgICAgICAvLyBTdGVwIDE6IG11bHRpcGx5IGVhY2ggY29lZmZpY2llbnQgYnkgKC12YWx1ZSlcbiAgICAgICAgdGhpcy5tdWxTY2FsYXIoRnIubmVnKHZhbHVlKSk7XG5cbiAgICAgICAgLy8gU3RlcCAyOiBBZGQgY3VycmVudCBwb2x5bm9taWFsIHRvIGRlc3RpbmF0aW9uIHBvbHlub21pYWxcbiAgICAgICAgcG9sLmFkZCh0aGlzKTtcblxuICAgICAgICAvLyBTd2FwIGJ1ZmZlcnNcbiAgICAgICAgdGhpcy5jb2VmID0gcG9sLmNvZWY7XG4gICAgfVxuXG4gICAgLy8gTXVsdGlwbHkgY3VycmVudCBwb2x5bm9taWFsIGJ5IHRoZSBwb2x5bm9taWFsIChYXm4gKyB2YWx1ZSlcbiAgICBieVhOU3ViVmFsdWUobiwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgRnIgPSB0aGlzLkZyO1xuICAgICAgICBjb25zdCByZXNpemUgPSAhKHRoaXMubGVuZ3RoKCkgLSBuIC0gMSA+PSB0aGlzLmRlZ3JlZSgpKTtcblxuICAgICAgICBjb25zdCBsZW5ndGggPSByZXNpemUgPyB0aGlzLmxlbmd0aCgpICsgbiA6IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBsZW5ndGggPiAyIDw8IDE0ID8gbmV3IEJpZ0J1ZmZlcihsZW5ndGggKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShsZW5ndGggKiBGci5uOCk7XG4gICAgICAgIGxldCBwb2wgPSBuZXcgUG9seW5vbWlhbChidWZmLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgLy8gU3RlcCAwOiBTZXQgY3VycmVudCBjb2VmZmljaWVudHMgdG8gdGhlIG5ldyBidWZmZXIgc2hpZnRlZCBvbmUgcG9zaXRpb25cbiAgICAgICAgcG9sLmNvZWYuc2V0KHRoaXMuY29lZi5zbGljZSgwLCAodGhpcy5kZWdyZWUoKSArIDEpICogMzIsICksIG4gKiAzMik7XG5cbiAgICAgICAgLy8gU3RlcCAxOiBtdWx0aXBseSBlYWNoIGNvZWZmaWNpZW50IGJ5ICgtIHZhbHVlKVxuICAgICAgICB0aGlzLm11bFNjYWxhcih2YWx1ZSk7XG5cbiAgICAgICAgLy8gU3RlcCAyOiBBZGQgY3VycmVudCBwb2x5bm9taWFsIHRvIGRlc3RpbmF0aW9uIHBvbHlub21pYWxcbiAgICAgICAgcG9sLmFkZCh0aGlzKTtcblxuICAgICAgICAvLyBTd2FwIGJ1ZmZlcnNcbiAgICAgICAgdGhpcy5jb2VmID0gcG9sLmNvZWY7XG4gICAgfVxuXG4gICAgLy8gRXVjbGlkZWFuIGRpdmlzaW9uXG4gICAgZGl2QnkocG9seW5vbWlhbCkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGNvbnN0IGRlZ3JlZUEgPSB0aGlzLmRlZ3JlZSgpO1xuICAgICAgICBjb25zdCBkZWdyZWVCID0gcG9seW5vbWlhbC5kZWdyZWUoKTtcblxuICAgICAgICBsZXQgcG9sUiA9IG5ldyBQb2x5bm9taWFsKHRoaXMuY29lZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIodGhpcy5sZW5ndGgoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKiBGci5uOCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlZ3JlZUEgLSBkZWdyZWVCOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb2VmKGksIEZyLmRpdihwb2xSLmdldENvZWYoaSArIGRlZ3JlZUIpLCBwb2x5bm9taWFsLmdldENvZWYoZGVncmVlQikpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGRlZ3JlZUI7IGorKykge1xuICAgICAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpICsgaiwgRnIuc3ViKHBvbFIuZ2V0Q29lZihpICsgaiksIEZyLm11bCh0aGlzLmdldENvZWYoaSksIHBvbHlub21pYWwuZ2V0Q29lZihqKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2xSO1xuICAgIH1cblxuICAgIC8vIERpdmlzaW9uIGJ5IGEgUG9seW5vbWlhbCBvZiB0aGUgZm9ybSAoeF5tIC0gYmV0YSlcbiAgICBkaXZCeU1vbmljKG0sIGJldGEpIHtcbiAgICAgICAgY29uc3QgRnIgPSB0aGlzLkZyO1xuXG4gICAgICAgIGxldCBkID0gdGhpcy5kZWdyZWUoKTtcblxuICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy5sZW5ndGgoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KTtcbiAgICAgICAgbGV0IHF1b3RpZW50ID0gbmV3IFBvbHlub21pYWwoYnVmZmVyLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgbGV0IGJBcnIgPSBbXTtcblxuICAgICAgICAvLyBBZGQgdGhlIG0gbGVhZGluZyBjb2VmZmljaWVudHMgb2YgdGhpcyB0byBxdW90aWVudFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgcXVvdGllbnQuc2V0Q29lZigoZCAtIGkpIC0gbSwgdGhpcy5nZXRDb2VmKGQgLSBpKSk7XG4gICAgICAgICAgICBiQXJyW2ldID0gdGhpcy5nZXRDb2VmKGQgLSBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuVGhyZWFkcyA9IG07XG5cbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5UaHJlYWRzOyBrKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBkIC0gMiAqIG0gLSBrOyBpID49IDA7IGkgPSBpIC0gblRocmVhZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDApIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpZHggPSBrO1xuICAgICAgICAgICAgICAgIGJBcnJbaWR4XSA9IEZyLmFkZCh0aGlzLmdldENvZWYoaSArIG0pLCBGci5tdWwoYkFycltpZHhdLCBiZXRhKSk7XG5cbiAgICAgICAgICAgICAgICBxdW90aWVudC5zZXRDb2VmKGksIGJBcnJbaWR4XSk7XG4gICAgICAgICAgICAgICAgaiA9IChqICsgMSkgJSBtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2VmID0gcXVvdGllbnQuY29lZjtcbiAgICB9XG5cbiAgICBkaXZCeVZhbmlzaGluZyhuLCBiZXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZ3JlZSgpIDwgbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGl2QnlWYW5pc2hpbmcgcG9seW5vbWlhbCBkaXZpc29yIG11c3QgYmUgb2YgZGVncmVlIGxvd2VyIHRoYW4gdGhlIGRpdmlkZW5kIHBvbHlub21pYWxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG5cbiAgICAgICAgbGV0IHBvbFIgPSBuZXcgUG9seW5vbWlhbCh0aGlzLmNvZWYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICB0aGlzLmNvZWYgPSB0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogRnIubjgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxlbmd0aCgpIC0gMTsgaSA+PSBuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBsZWFkaW5nQ29lZiA9IHBvbFIuZ2V0Q29lZihpKTtcbiAgICAgICAgICAgIGlmIChGci5lcShGci56ZXJvLCBsZWFkaW5nQ29lZikpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBwb2xSLnNldENvZWYoaSwgRnIuemVybyk7XG4gICAgICAgICAgICBwb2xSLnNldENvZWYoaSAtIG4sIEZyLmFkZChwb2xSLmdldENvZWYoaSAtIG4pLCBGci5tdWwoYmV0YSwgbGVhZGluZ0NvZWYpKSk7XG4gICAgICAgICAgICB0aGlzLnNldENvZWYoaSAtIG4sIEZyLmFkZCh0aGlzLmdldENvZWYoaSAtIG4pLCBsZWFkaW5nQ29lZikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbFI7XG4gICAgfVxuXG4gICAgZGl2QnlWYW5pc2hpbmcyKG0sIGJldGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVncmVlKCkgPCBtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXZCeVZhbmlzaGluZyBwb2x5bm9taWFsIGRpdmlzb3IgbXVzdCBiZSBvZiBkZWdyZWUgbG93ZXIgdGhhbiB0aGUgZGl2aWRlbmQgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcblxuICAgICAgICBsZXQgcG9sUiA9IG5ldyBQb2x5bm9taWFsKHRoaXMuY29lZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIodGhpcy5sZW5ndGgoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKiBGci5uOCk7XG5cbiAgICAgICAgbGV0IG5UaHJlYWRzID0gMztcbiAgICAgICAgbGV0IG5Ub3RhbCA9IHRoaXMubGVuZ3RoKCkgLSBtO1xuICAgICAgICBsZXQgbkVsZW1lbnRzQ2h1bmsgPSBNYXRoLmZsb29yKG5Ub3RhbCAvIG5UaHJlYWRzKTtcbiAgICAgICAgbGV0IG5FbGVtZW50c0xhc3QgPSBuVG90YWwgLSAoblRocmVhZHMgLSAxKSAqIG5FbGVtZW50c0NodW5rO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKG5Ub3RhbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKG5FbGVtZW50c0NodW5rICsgXCIgIFwiICsgbkVsZW1lbnRzTGFzdCk7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgblRocmVhZHM7IGsrKykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCI+IFRocmVhZCBcIiArIGspO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IChrID09PSAwID8gbkVsZW1lbnRzTGFzdCA6IG5FbGVtZW50c0NodW5rKTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBpZHhEc3QgPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAoayAhPT0gMCkgaWR4RHN0ICs9IChrIC0gMSkgKiBuRWxlbWVudHNDaHVuayArIG5FbGVtZW50c0xhc3Q7XG4gICAgICAgICAgICAgICAgbGV0IGlkeFNyYyA9IGlkeERzdCArIG07XG5cbiAgICAgICAgICAgICAgICBsZXQgbGVhZGluZ0NvZWYgPSBwb2xSLmdldENvZWYoaWR4U3JjKTtcbiAgICAgICAgICAgICAgICBpZiAoRnIuZXEoRnIuemVybywgbGVhZGluZ0NvZWYpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpZHhTcmMsIEZyLnplcm8pO1xuICAgICAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpZHhEc3QsIEZyLmFkZChwb2xSLmdldENvZWYoaWR4RHN0KSwgRnIubXVsKGJldGEsIGxlYWRpbmdDb2VmKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29lZihpZHhEc3QsIEZyLmFkZCh0aGlzLmdldENvZWYoaWR4RHN0KSwgbGVhZGluZ0NvZWYpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpZHhEc3QgKyBcIiA8LS0gXCIgKyBpZHhTcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmludCgpO1xuICAgICAgICByZXR1cm4gcG9sUjtcbiAgICB9XG5cbiAgICBmYXN0RGl2QnlWYW5pc2hpbmcoZGF0YSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGxldCBtID0gZGF0YVtpXVswXTtcbiAgICAgICAgICAgIGxldCBiZXRhID0gZGF0YVtpXVsxXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZGVncmVlKCkgPCBtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGl2QnlWYW5pc2hpbmcgcG9seW5vbWlhbCBkaXZpc29yIG11c3QgYmUgb2YgZGVncmVlIGxvd2VyIHRoYW4gdGhlIGRpdmlkZW5kIHBvbHlub21pYWxcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBuVGhyZWFkcyA9IDU7XG4gICAgICAgICAgICBsZXQgbkVsZW1lbnRzID0gdGhpcy5sZW5ndGgoKSAtIG07XG4gICAgICAgICAgICBsZXQgbkVsZW1lbnRzQnVja2V0ID0gTWF0aC5mbG9vcihuRWxlbWVudHMgLyBuVGhyZWFkcyAvIG0pO1xuICAgICAgICAgICAgbGV0IG5FbGVtZW50c0NodW5rID0gbkVsZW1lbnRzQnVja2V0ICogbTtcbiAgICAgICAgICAgIGxldCBuRWxlbWVudHNMYXN0ID0gbkVsZW1lbnRzIC0gblRocmVhZHMgKiBuRWxlbWVudHNDaHVuaztcblxuICAgICAgICAgICAgLy9JbiBDKysgaW1wbGVtZW50YXRpb24gdGhpcyBidWZmZXIgd2lsbCBiZSBhbGxvY2F0ZWQgb25seSBvbmNlIG91dHNpZGUgdGhlIGxvb3BcbiAgICAgICAgICAgIGxldCBwb2xUbXAgPSBuZXcgUG9seW5vbWlhbCh0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KSwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgICAgICBsZXQgcHRyID0gdGhpcy5jb2VmO1xuICAgICAgICAgICAgdGhpcy5jb2VmID0gcG9sVG1wLmNvZWY7XG4gICAgICAgICAgICBwb2xUbXAuY29lZiA9IHB0cjtcblxuICAgICAgICAgICAgLy8gU1RFUCAxOiBTZXRlamFyIGVscyBtIHZhbG9ycyBkZWwgc2Vnw7xlbnQgYnVja2V0IGFsIGNodW5rIGFjdHVhbCwgUEFSQUxFTMK3TElUWkFSXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5UaHJlYWRzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaWR4MCA9IChrICsgMSkgKiBuRWxlbWVudHNDaHVuayArIG5FbGVtZW50c0xhc3Q7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKGlkeDAgKyBpIC0gbSwgcG9sVG1wLmdldENvZWYoaWR4MCArIGkpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5FbGVtZW50c0NodW5rIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpZHgwIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBGci5hZGQocG9sVG1wLmdldENvZWYob2Zmc2V0KSwgRnIubXVsKGJldGEsIHRoaXMuZ2V0Q29lZihvZmZzZXQpKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29lZihvZmZzZXQgLSBtLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TVEVQIDI6IFNldGVqYXIgZWxzIHZhbG9ycyBkZWwgZWxlbWVudHMgbGFzdCBOTyBQQVJBTMK3TEVMSVRaQVJcbiAgICAgICAgICAgIGxldCBpZHgwID0gbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbSAmJiBwZW5kaW5nOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYoaWR4MCAtIGkgLSAxLCBwb2xUbXAuZ2V0Q29lZihpZHgwICsgbSAtIGkgLSAxKSk7XG4gICAgICAgICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmc7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpZHgwIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IEZyLmFkZChwb2xUbXAuZ2V0Q29lZihvZmZzZXQpLCBGci5tdWwoYmV0YSwgdGhpcy5nZXRDb2VmKG9mZnNldCkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYob2Zmc2V0IC0gbSwgdmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TdGVwIDM6IGNhbGN1bGFyIGFjdW11bGF0cyBOTyAgUEFSQUxFTMK3TElUWkFSXG5cbiAgICAgICAgICAgIGxldCBhY2MgPSBbXTtcbiAgICAgICAgICAgIGxldCBiZXRhUG93ID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuRWxlbWVudHNCdWNrZXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGJldGFQb3cgPSBGci5tdWwoYmV0YVBvdywgYmV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudEJldGEgPSBGci5vbmU7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBuVGhyZWFkczsgayA+IDA7IGstLSkge1xuICAgICAgICAgICAgICAgIGxldCBpZFRocmVhZCA9IGsgLSAxO1xuICAgICAgICAgICAgICAgIGxldCBpZHgwID0gaWRUaHJlYWQgKiBuRWxlbWVudHNDaHVuayArIG5FbGVtZW50c0xhc3Q7XG4gICAgICAgICAgICAgICAgYWNjW2lkVGhyZWFkXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2lkVGhyZWFkXVtpXSA9IHRoaXMuZ2V0Q29lZihpZHgwICsgaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgIT09IG5UaHJlYWRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NbaWRUaHJlYWRdW2ldID0gRnIuYWRkKGFjY1tpZFRocmVhZF1baV0sIEZyLm11bChiZXRhUG93LCBhY2NbaWRUaHJlYWQgKyAxXVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRCZXRhID0gRnIubXVsKGN1cnJlbnRCZXRhLCBiZXRhUG93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TVEVQIDQgcmVjYWxjdWxhciAgUEFSQUxFTMK3TElUWkFSXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5UaHJlYWRzOyBrKyspIHtcblxuICAgICAgICAgICAgICAgIGxldCBpZHgwID0gayAqIG5FbGVtZW50c0NodW5rICsgbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEJldGEgPSBiZXRhOyAvL1F1YW4gaG9wYXNzZW0gYSBDKysgaSBobyBwYXJhbGVsaXR6ZW0gYXF1ZXN0YSB2YXJpYWJsZSBoYSBkZSBzZXIgcHJpdmFkYVxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TSA9IG0gLSAxO1xuXG4gICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gayA9PT0gMCA/IG5FbGVtZW50c0xhc3QgOiBuRWxlbWVudHNDaHVuaztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGlkeDAgLSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IEZyLmFkZCh0aGlzLmdldENvZWYob2Zmc2V0KSwgRnIubXVsKGN1cnJlbnRCZXRhLCBhY2Nba11bY3VycmVudE1dKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKG9mZnNldCwgdmFsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBhdm9pZCBtb2R1bGFyIG9wZXJhdGlvbnMgaW4gZWFjaCBsb29wLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE0gPSBtIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCZXRhID0gRnIubXVsKGN1cnJlbnRCZXRhLCBiZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIERpdmlkZSBwb2x5bm9taWFsIGJ5IFggLSB2YWx1ZVxuICAgIGRpdkJ5WFN1YlZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvZWZzID0gdGhpcy5sZW5ndGgoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogdGhpcy5Gci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogdGhpcy5Gci5uOCk7XG5cbiAgICAgICAgY29lZnMuc2V0KHRoaXMuRnIuemVybywgKHRoaXMubGVuZ3RoKCkgLSAxKSAqIHRoaXMuRnIubjgpO1xuICAgICAgICBjb2Vmcy5zZXQodGhpcy5jb2VmLnNsaWNlKCh0aGlzLmxlbmd0aCgpIC0gMSkgKiB0aGlzLkZyLm44LCB0aGlzLmxlbmd0aCgpICogdGhpcy5Gci5uOCksICh0aGlzLmxlbmd0aCgpIC0gMikgKiB0aGlzLkZyLm44KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoKCkgLSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIGNvZWZzLnNldChcbiAgICAgICAgICAgICAgICB0aGlzLkZyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNsaWNlKGlfbjggKyB0aGlzLkZyLm44LCBpX244ICsgMiAqIHRoaXMuRnIubjgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkZyLm11bCh2YWx1ZSwgY29lZnMuc2xpY2UoaV9uOCArIHRoaXMuRnIubjgsIGlfbjggKyAyICogdGhpcy5Gci5uOCkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpICogdGhpcy5Gci5uOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuRnIuZXEoXG4gICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCksXG4gICAgICAgICAgICB0aGlzLkZyLm11bCh0aGlzLkZyLm5lZyh2YWx1ZSksIGNvZWZzLnNsaWNlKDAsIHRoaXMuRnIubjgpKVxuICAgICAgICApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5bm9taWFsIGRvZXMgbm90IGRpdmlkZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29lZiA9IGNvZWZzO1xuICAgIH1cblxuICAgIGRpdlpoKGRvbWFpblNpemUsIGV4dGVuc2lvbnMgPSA0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIubmVnKHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkpLCBpX244KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSB0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjg7XG4gICAgICAgIGZvciAobGV0IGkgPSBkb21haW5TaXplOyBpIDwgdXBwZXJCb3VuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLkZyLnN1YihcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoKGkgLSBkb21haW5TaXplKSAqIHRoaXMuRnIubjgsIChpIC0gZG9tYWluU2l6ZSkgKiB0aGlzLkZyLm44ICsgdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuY29lZi5zZXQoYSwgaV9uOCk7XG4gICAgICAgICAgICBpZiAoaSA+IChkb21haW5TaXplICogKGV4dGVuc2lvbnMtMSkgLSBleHRlbnNpb25zKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBpcyBub3QgZGl2aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRpdkJ5WmVyb2ZpZXIobiwgYmV0YSkge1xuICAgICAgICBsZXQgRnIgPSB0aGlzLkZyO1xuICAgICAgICBjb25zdCBpbnZCZXRhID0gRnIuaW52KGJldGEpO1xuICAgICAgICBjb25zdCBpbnZCZXRhTmVnID0gRnIubmVnKGludkJldGEpO1xuXG4gICAgICAgIGxldCBpc09uZSA9IEZyLmVxKEZyLm9uZSwgaW52QmV0YU5lZyk7XG4gICAgICAgIGxldCBpc05lZ09uZSA9IEZyLmVxKEZyLm5lZ29uZSwgaW52QmV0YU5lZyk7XG5cbiAgICAgICAgaWYgKCFpc09uZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpbnZCZXRhTmVnID09PSAtMSB3ZSdsbCBzYXZlIGEgbXVsdGlwbGljYXRpb24gY2hhbmdpbmcgaXQgYnkgYSBuZWcgZnVuY3Rpb24gY2FsbFxuICAgICAgICAgICAgICAgIGlmIChpc05lZ09uZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gRnIubmVnKHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBGci5tdWwoaW52QmV0YU5lZywgdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNldChlbGVtZW50LCBpX244KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlzT25lID0gRnIuZXEoRnIub25lLCBpbnZCZXRhKTtcbiAgICAgICAgaXNOZWdPbmUgPSBGci5lcShGci5uZWdvbmUsIGludkJldGEpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBuOyBpIDwgdGhpcy5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICBjb25zdCBpX3ByZXZfbjggPSAoaSAtIG4pICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLkZyLnN1YihcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoaV9wcmV2X244LCBpX3ByZXZfbjggKyB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBJZiBpbnZCZXRhID09PSAxIHdlJ2xsIG5vdCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgaWYoIWlzT25lKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaW52QmV0YSA9PT0gLTEgd2UnbGwgc2F2ZSBhIG11bHRpcGxpY2F0aW9uIGNoYW5naW5nIGl0IGJ5IGEgbmVnIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgICAgICBpZihpc05lZ09uZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gRnIubmVnKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBGci5tdWwoaW52QmV0YSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvZWYuc2V0KGVsZW1lbnQsIGlfbjgpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBwb2x5bm9taWFsIGlzIGRpdmlzaWJsZSBieSBjaGVja2luZyBpZiBuIGhpZ2ggY29lZmZpY2llbnRzIGFyZSB6ZXJvXG4gICAgICAgICAgICBpZiAoaSA+IHRoaXMubGVuZ3RoKCkgLSBuIC0gMSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBpcyBub3QgZGl2aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuLy8gZnVuY3Rpb24gZGl2aWRlQnlWYW5pc2hpbmcoZiwgbiwgcCkge1xuLy8gICAgIC8vIHBvbHlub21pYWwgZGl2aXNpb24gZihYKSAvIChYXm4gLSAxKSB3aXRoIHJlbWFpbmRlclxuLy8gICAgIC8vIHZlcnkgY2hlYXAsIDAgbXVsdGlwbGljYXRpb25zXG4vLyAgICAgLy8gc3RyYXRlZ3k6XG4vLyAgICAgLy8gc3RhcnQgd2l0aCBxKFgpID0gMCwgcihYKSA9IGYoWClcbi8vICAgICAvLyB0aGVuIHN0YXJ0IGNoYW5naW5nIHEsIHIgd2hpbGUgcHJlc2VydmluZyB0aGUgaWRlbnRpdHk6XG4vLyAgICAgLy8gZihYKSA9IHEoWCkgKiAoWF5uIC0gMSkgKyByKFgpXG4vLyAgICAgLy8gaW4gZXZlcnkgc3RlcCwgbW92ZSBoaWdoZXN0LWRlZ3JlZSB0ZXJtIG9mIHIgaW50byB0aGUgcHJvZHVjdFxuLy8gICAgIC8vID0+IHIgZXZlbnR1YWxseSBoYXMgZGVncmVlIDwgbiBhbmQgd2UncmUgZG9uZVxuLy8gICAgIGxldCBxID0gQXJyYXkoZi5sZW5ndGgpLmZpbGwoMG4pO1xuLy8gICAgIGxldCByID0gWy4uLmZdO1xuLy8gICAgIGZvciAobGV0IGkgPSBmLmxlbmd0aCAtIDE7IGkgPj0gbjsgaS0tKSB7XG4vLyAgICAgICAgIGxldCBsZWFkaW5nQ29lZmYgPSByW2ldO1xuLy8gICAgICAgICBpZiAobGVhZGluZ0NvZWZmID09PSAwbikgY29udGludWU7XG4vLyAgICAgICAgIHJbaV0gPSAwbjtcbi8vICAgICAgICAgcltpIC0gbl0gPSBtb2QocltpIC0gbl0gKyBsZWFkaW5nQ29lZmYsIHApO1xuLy8gICAgICAgICBxW2kgLSBuXSA9IG1vZChxW2kgLSBuXSArIGxlYWRpbmdDb2VmZiwgcCk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBbcSwgcl07XG4vLyB9XG5cbiAgICBieVgoKSB7XG4gICAgICAgIGNvbnN0IGNvZWZzID0gKHRoaXMubGVuZ3RoKCkgKyAxKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmNvZWYuYnl0ZUxlbmd0aCArIHRoaXMuRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5jb2VmLmJ5dGVMZW5ndGggKyB0aGlzLkZyLm44KTtcbiAgICAgICAgY29lZnMuc2V0KHRoaXMuRnIuemVybywgMCk7XG4gICAgICAgIGNvZWZzLnNldCh0aGlzLmNvZWYsIHRoaXMuRnIubjgpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IGNvZWZzO1xuICAgIH1cblxuLy8gQ29tcHV0ZSBhIG5ldyBwb2x5bm9taWFsIGYoeF5uKSBmcm9tIGYoeClcbi8vIGYoeCkgICA9IGFfMCArIGFfMcK3eCArIGFfMsK3eF4yICsgLi4uICsgYV9qwrd4Xmpcbi8vIGYoeF5uKSA9IGFfMCArIGFfMcK3eF5uICsgYV8ywrd4XjJuICsgLi4uICsgYV9qwrd4XmpuXG4gICAgc3RhdGljXG4gICAgYXN5bmMgZXhwWChwb2x5bm9taWFsLCBuLCB0cnVuY2F0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IEZyID0gcG9seW5vbWlhbC5GcjtcblxuICAgICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgICAgIC8vIG4gPT0gMCBub3QgYWxsb3dlZCBiZWNhdXNlIGl0IGhhcyBubyBzZW5zZSwgYnV0IGlmIGl0J3MgbmVjZXNzYXJ5IHdlIGhhdmUgdG8gcmV0dXJuXG4gICAgICAgICAgICAvLyBhIHplcm8gZGVncmVlIHBvbHlub21pYWwgd2l0aCBhIGNvbnN0YW50IGNvZWZmaWNpZW50IGVxdWFscyB0byB0aGUgc3VtIG9mIGFsbCB0aGUgb3JpZ2luYWwgY29lZmZpY2llbnRzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wdXRlIGEgbmV3IHBvbHlub21pYWwgdG8gYSB6ZXJvIG9yIG5lZ2F0aXZlIG51bWJlciBpcyBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICgxID09PSBuKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMocG9seW5vbWlhbC5jb2VmLCBjdXJ2ZSwgcG9seW5vbWlhbC5sb2dnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIGlzIHRoZSBsZW5ndGggb2Ygbm9uLWNvbnN0YW50IGNvZWZmaWNpZW50c1xuICAgICAgICAvLyBpZiB0cnVuY2F0ZSA9PT0gdHJ1ZSwgdGhlIGhpZ2hlc3QgemVybyBjb2VmZmljaWVudHMgKGlmIGV4aXN0KSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdHJ1bmNhdGUgPyBwb2x5bm9taWFsLmRlZ3JlZSgpIDogKHBvbHlub21pYWwubGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgY29uc3QgYnVmZmVyRHN0ID0gKGxlbmd0aCAqIG4gKyAxKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigobGVuZ3RoICogbiArIDEpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKGxlbmd0aCAqIG4gKyAxKSAqIEZyLm44KTtcblxuICAgICAgICAvLyBDb3B5IGNvbnN0YW50IGNvZWZmaWNpZW50IGFzIGlzIGJlY2F1c2UgaXMgbm90IHJlbGF0ZWQgdG8geFxuICAgICAgICBidWZmZXJEc3Quc2V0KHBvbHlub21pYWwuZ2V0Q29lZigwKSwgMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIEZyLm44O1xuXG4gICAgICAgICAgICBjb25zdCBjb2VmID0gcG9seW5vbWlhbC5nZXRDb2VmKGkpO1xuICAgICAgICAgICAgYnVmZmVyRHN0LnNldChjb2VmLCBpX3NGciAqIG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGJ1ZmZlckRzdCwgcG9seW5vbWlhbC5jdXJ2ZSwgcG9seW5vbWlhbC5sb2dnZXIpO1xuICAgIH1cblxuICAgIHNwbGl0KG51bVBvbHMsIGRlZ1BvbHMsIGJsaW5kaW5nRmFjdG9ycykge1xuICAgICAgICBpZiAobnVtUG9scyA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbHMgY2FuJ3QgYmUgc3BsaXQgaW4gJHtudW1Qb2xzfSBwYXJ0c2ApO1xuICAgICAgICB9IGVsc2UgaWYgKDEgPT09IG51bVBvbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XG4gICAgICAgIH1cblxuICAgICAgICAvL2JsaW5kaW5nIGZhY3RvcnMgY2FuIGJlIHZvaWQgb3IgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIG51bVBvbHMgLSAxXG4gICAgICAgIGlmICgwICE9PSBibGluZGluZ0ZhY3RvcnMubGVuZ3RoICYmIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPCBudW1Qb2xzIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbGluZGluZyBmYWN0b3JzIGxlbmd0aCBtdXN0IGJlICR7bnVtUG9scyAtIDF9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaHVua0J5dGVMZW5ndGggPSAoZGVnUG9scyArIDEpICogdGhpcy5Gci5uODtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuXG4gICAgICAgIC8vIENoZWNrIHBvbHlub21pYWwgY2FuIGJlIHNwbGl0IGluIG51bUNodW5rcyBwYXJ0cyBvZiBjaHVua1NpemUgYnl0ZXMuLi5cbiAgICAgICAgY29uc3QgbnVtUmVhbFBvbHMgPSBNYXRoLmNlaWwoKHRoaXMuZGVncmVlKCkgKyAxKSAqIHRoaXMuRnIubjggLyBjaHVua0J5dGVMZW5ndGgpO1xuICAgICAgICBpZiAobnVtUmVhbFBvbHMgPCBudW1Qb2xzKSB7XG4gICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbCBpcyBzaG9ydCB0byBiZSBzcGxpdCBpbiAke251bVBvbHN9IHBhcnRzIG9mICR7ZGVnUG9sc30gY29lZmZpY2llbnRzIGVhY2guYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbnVtUmVhbFBvbHM7IGkgPCBudW1Qb2xzOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBuZXcgUG9seW5vbWlhbChuZXcgVWludDhBcnJheSh0aGlzLkZyLm44KSwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbnVtUG9scyA9IE1hdGgubWluKG51bVBvbHMsIG51bVJlYWxQb2xzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2xzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdCA9IChudW1Qb2xzIC0gMSkgPT09IGk7XG4gICAgICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gaXNMYXN0ID8gdGhpcy5jb2VmLmJ5dGVMZW5ndGggLSAoKG51bVBvbHMgLSAxKSAqIGNodW5rQnl0ZUxlbmd0aCkgOiBjaHVua0J5dGVMZW5ndGggKyB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICBsZXQgYnVmZiA9IChieXRlTGVuZ3RoIC8gdGhpcy5Gci5uOCkgPiAyIDw8IDE0ID8gbmV3IEJpZ0J1ZmZlcihieXRlTGVuZ3RoKSA6IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgcmVzW2ldID0gbmV3IFBvbHlub21pYWwoYnVmZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgICAgICBjb25zdCBmciA9IGkgKiBjaHVua0J5dGVMZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0byA9IGlzTGFzdCA/IHRoaXMuY29lZi5ieXRlTGVuZ3RoIDogKGkgKyAxKSAqIGNodW5rQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldCh0aGlzLmNvZWYuc2xpY2UoZnIsIHRvKSwgMCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhIGJsaW5kaW5nIGZhY3RvciBhcyBoaWdoZXIgZGVncmVlXG4gICAgICAgICAgICBpZiAoIWlzTGFzdCkge1xuICAgICAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldChibGluZGluZ0ZhY3RvcnNbaV0sIGNodW5rQnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1YiBibGluZGluZyBmYWN0b3IgdG8gdGhlIGxvd2VzdCBkZWdyZWVcbiAgICAgICAgICAgIGlmICgwICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG93ZXN0RGVncmVlID0gdGhpcy5Gci5zdWIocmVzW2ldLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCksIGJsaW5kaW5nRmFjdG9yc1tpIC0gMV0pO1xuICAgICAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldChsb3dlc3REZWdyZWUsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldLnRydW5jYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuXG4gICAgICAgIC8vIC8vIGNvbXB1dGUgdF9sb3coWClcbiAgICAgICAgLy8gbGV0IHBvbFRMb3cgPSBuZXcgQmlnQnVmZmVyKChjaHVua1NpemUgKyAxKSAqIG44cik7XG4gICAgICAgIC8vIHBvbFRMb3cuc2V0KHQuc2xpY2UoMCwgemtleS5kb21haW5TaXplICogbjhyKSwgMCk7XG4gICAgICAgIC8vIC8vIEFkZCBibGluZGluZyBzY2FsYXIgYl8xMCBhcyBhIG5ldyBjb2VmZmljaWVudCBuXG4gICAgICAgIC8vIHBvbFRMb3cuc2V0KGNoLmJbMTBdLCB6a2V5LmRvbWFpblNpemUgKiBuOHIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAvLyBjb21wdXRlIHRfbWlkKFgpXG4gICAgICAgIC8vIGxldCBwb2xUTWlkID0gbmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgMSkgKiBuOHIpO1xuICAgICAgICAvLyBwb2xUTWlkLnNldCh0LnNsaWNlKHprZXkuZG9tYWluU2l6ZSAqIG44ciwgemtleS5kb21haW5TaXplICogMiAqIG44ciksIDApO1xuICAgICAgICAvLyAvLyBTdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMCB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfbWlkXG4gICAgICAgIC8vIGNvbnN0IGxvd2VzdE1pZCA9IEZyLnN1Yihwb2xUTWlkLnNsaWNlKDAsIG44ciksIGNoLmJbMTBdKTtcbiAgICAgICAgLy8gcG9sVE1pZC5zZXQobG93ZXN0TWlkLCAwKTtcbiAgICAgICAgLy8gLy8gQWRkIGJsaW5kaW5nIHNjYWxhciBiXzExIGFzIGEgbmV3IGNvZWZmaWNpZW50IG5cbiAgICAgICAgLy8gcG9sVE1pZC5zZXQoY2guYlsxMV0sIHprZXkuZG9tYWluU2l6ZSAqIG44cik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIC8vIGNvbXB1dGUgdF9oaWdoKFgpXG4gICAgICAgIC8vIGxldCBwb2xUSGlnaCA9IG5ldyBCaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDYpICogbjhyKTtcbiAgICAgICAgLy8gcG9sVEhpZ2guc2V0KHQuc2xpY2UoemtleS5kb21haW5TaXplICogMiAqIG44ciwgKHprZXkuZG9tYWluU2l6ZSAqIDMgKyA2KSAqIG44ciksIDApO1xuICAgICAgICAvLyAvL1N1YnRyYWN0IGJsaW5kaW5nIHNjYWxhciBiXzExIHRvIHRoZSBsb3dlc3QgY29lZmZpY2llbnQgb2YgdF9oaWdoXG4gICAgICAgIC8vIGNvbnN0IGxvd2VzdEhpZ2ggPSBGci5zdWIocG9sVEhpZ2guc2xpY2UoMCwgbjhyKSwgY2guYlsxMV0pO1xuICAgICAgICAvLyBwb2xUSGlnaC5zZXQobG93ZXN0SGlnaCwgMCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHByb29mLlQxID0gYXdhaXQgZXhwVGF1KHBvbFRMb3csIFwibXVsdGlleHAgVDFcIik7XG4gICAgICAgIC8vIHByb29mLlQyID0gYXdhaXQgZXhwVGF1KHBvbFRNaWQsIFwibXVsdGlleHAgVDJcIik7XG4gICAgICAgIC8vIHByb29mLlQzID0gYXdhaXQgZXhwVGF1KHBvbFRIaWdoLCBcIm11bHRpZXhwIFQzXCIpO1xuICAgIH1cblxuLy8gc3BsaXQyKGRlZ1BvbHMsIGJsaW5kaW5nRmFjdG9ycykge1xuLy8gICAgIGxldCBjdXJyZW50RGVncmVlID0gdGhpcy5kZWdyZWUoKTtcbi8vICAgICBjb25zdCBudW1GaWxsZWRQb2xzID0gTWF0aC5jZWlsKChjdXJyZW50RGVncmVlICsgMSkgLyAoZGVnUG9scyArIDEpKTtcbi8vXG4vLyAgICAgLy9ibGluZGluZyBmYWN0b3JzIGNhbiBiZSB2b2lkIG9yIG11c3QgaGF2ZSBhIGxlbmd0aCBvZiBudW1Qb2xzIC0gMVxuLy8gICAgIGlmICgwICE9PSBibGluZGluZ0ZhY3RvcnMubGVuZ3RoICYmIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPCBudW1GaWxsZWRQb2xzIC0gMSkge1xuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsaW5kaW5nIGZhY3RvcnMgbGVuZ3RoIG11c3QgYmUgJHtudW1GaWxsZWRQb2xzIC0gMX1gKTtcbi8vICAgICB9XG4vL1xuLy8gICAgIGNvbnN0IGNodW5rQnl0ZUxlbmd0aCA9IChkZWdQb2xzICsgMSkgKiB0aGlzLkZyLm44O1xuLy9cbi8vICAgICAvLyBDaGVjayBwb2x5bm9taWFsIGNhbiBiZSBzcGxpdCBpbiBudW1DaHVua3MgcGFydHMgb2YgY2h1bmtTaXplIGJ5dGVzLi4uXG4vLyAgICAgaWYgKHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gY2h1bmtCeXRlTGVuZ3RoIDw9IG51bUZpbGxlZFBvbHMgLSAxKSB7XG4vLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbCBpcyBzaG9ydCB0byBiZSBzcGxpdCBpbiAke251bUZpbGxlZFBvbHN9IHBhcnRzIG9mICR7ZGVnUG9sc30gY29lZmZpY2llbnRzIGVhY2guYCk7XG4vLyAgICAgfVxuLy9cbi8vICAgICBsZXQgcmVzID0gW107XG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1GaWxsZWRQb2xzOyBpKyspIHtcbi8vICAgICAgICAgY29uc3QgaXNMYXN0ID0gKG51bUZpbGxlZFBvbHMgLSAxKSA9PT0gaTtcbi8vICAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGlzTGFzdCA/IChjdXJyZW50RGVncmVlICsgMSkgKiB0aGlzLkZyLm44IC0gKChudW1GaWxsZWRQb2xzIC0gMSkgKiBjaHVua0J5dGVMZW5ndGgpIDogY2h1bmtCeXRlTGVuZ3RoICsgdGhpcy5Gci5uODtcbi8vXG4vLyAgICAgICAgIHJlc1tpXSA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoYnl0ZUxlbmd0aCksIHRoaXMuRnIsIHRoaXMubG9nZ2VyKTtcbi8vICAgICAgICAgY29uc3QgZnIgPSBpICogY2h1bmtCeXRlTGVuZ3RoO1xuLy8gICAgICAgICBjb25zdCB0byA9IGlzTGFzdCA/IChjdXJyZW50RGVncmVlICsgMSkgKiB0aGlzLkZyLm44IDogKGkgKyAxKSAqIGNodW5rQnl0ZUxlbmd0aDtcbi8vICAgICAgICAgcmVzW2ldLmNvZWYuc2V0KHRoaXMuY29lZi5zbGljZShmciwgdG8pLCAwKTtcbi8vXG4vLyAgICAgICAgIC8vIEFkZCBhIGJsaW5kaW5nIGZhY3RvciBhcyBoaWdoZXIgZGVncmVlXG4vLyAgICAgICAgIGlmICghaXNMYXN0KSB7XG4vLyAgICAgICAgICAgICByZXNbaV0uY29lZi5zZXQoYmxpbmRpbmdGYWN0b3JzW2ldLCBjaHVua0J5dGVMZW5ndGgpO1xuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICAvLyBTdWIgYmxpbmRpbmcgZmFjdG9yIHRvIHRoZSBsb3dlc3QgZGVncmVlXG4vLyAgICAgICAgIGlmICgwICE9PSBpKSB7XG4vLyAgICAgICAgICAgICBjb25zdCBsb3dlc3REZWdyZWUgPSB0aGlzLkZyLnN1YihyZXNbaV0uY29lZi5zbGljZSgwLCB0aGlzLkZyLm44KSwgYmxpbmRpbmdGYWN0b3JzW2kgLSAxXSk7XG4vLyAgICAgICAgICAgICByZXNbaV0uY29lZi5zZXQobG93ZXN0RGVncmVlLCAwKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vXG4vLyAgICAgcmV0dXJuIHJlcztcbi8vIH1cblxuLy8gbWVyZ2UocG9scywgb3ZlcmxhcCA9IHRydWUpIHtcbi8vICAgICBsZXQgbGVuZ3RoID0gMDtcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHMubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgbGVuZ3RoICs9IHBvbHNbaV0ubGVuZ3RoKCk7XG4vLyAgICAgfVxuLy9cbi8vICAgICBpZiAob3ZlcmxhcCkge1xuLy8gICAgICAgICBsZW5ndGggLT0gcG9scy5sZW5ndGggLSAxO1xuLy8gICAgIH1cbi8vXG4vLyAgICAgbGV0IHJlcyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIobGVuZ3RoICogdGhpcy5Gci5uOCkpO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9scy5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gcG9sc1tpXS5jb2VmLmJ5dGVMZW5ndGg7XG4vLyAgICAgICAgIGlmICgwID09PSBpKSB7XG4vLyAgICAgICAgICAgICByZXMuY29lZi5zZXQocG9sc1tpXS5jb2VmLCAwKTtcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vL1xuLy8gICAgIHJldHVybiByZXM7XG4vLyB9XG5cbiAgICB0cnVuY2F0ZSgpIHtcbiAgICAgICAgY29uc3QgZGVnID0gdGhpcy5kZWdyZWUoKTtcbiAgICAgICAgaWYgKGRlZyArIDEgPCB0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvZWZzID0gKGRlZyArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigoZGVnICsgMSkgKiB0aGlzLkZyLm44KSA6IG5ldyBVaW50OEFycmF5KChkZWcgKyAxKSAqIHRoaXMuRnIubjgpO1xuXG4gICAgICAgICAgICBuZXdDb2Vmcy5zZXQodGhpcy5jb2VmLnNsaWNlKDAsIChkZWcgKyAxKSAqIHRoaXMuRnIubjgpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY29lZiA9IG5ld0NvZWZzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oeEFyciwgeUFyciwgY3VydmUpIHtcbiAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgbGV0IHBvbHlub21pYWwgPSBjb21wdXRlTGFncmFuZ2VQb2x5bm9taWFsKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHhBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvbHlub21pYWwuYWRkKGNvbXB1dGVMYWdyYW5nZVBvbHlub21pYWwoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlub21pYWw7XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUxhZ3JhbmdlUG9seW5vbWlhbChpKSB7XG4gICAgICAgICAgICBsZXQgcG9seW5vbWlhbDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB4QXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvbHlub21pYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYnVmZiA9ICh4QXJyLmxlbmd0aCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIoKHhBcnIubGVuZ3RoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KCh4QXJyLmxlbmd0aCkgKiBGci5uOCk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwgPSBuZXcgUG9seW5vbWlhbChidWZmLCBjdXJ2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwuc2V0Q29lZigwLCBGci5uZWcoeEFycltqXSkpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFsLnNldENvZWYoMSwgRnIub25lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFsLmJ5WFN1YlZhbHVlKHhBcnJbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gcG9seW5vbWlhbC5ldmFsdWF0ZSh4QXJyW2ldKTtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gRnIuaW52KGRlbm9taW5hdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG11bEZhY3RvciA9IEZyLm11bCh5QXJyW2ldLCBkZW5vbWluYXRvcik7XG5cbiAgICAgICAgICAgIHBvbHlub21pYWwubXVsU2NhbGFyKG11bEZhY3Rvcik7XG5cbiAgICAgICAgICAgIHJldHVybiBwb2x5bm9taWFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHplcm9maWVyUG9seW5vbWlhbCh4QXJyLCBjdXJ2ZSkge1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBsZXQgYnVmZiA9ICh4QXJyLmxlbmd0aCArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKCh4QXJyLmxlbmd0aCArIDEpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKHhBcnIubGVuZ3RoICsgMSkgKiBGci5uOCk7XG4gICAgICAgIGxldCBwb2x5bm9taWFsID0gbmV3IFBvbHlub21pYWwoYnVmZiwgY3VydmUpO1xuXG4gICAgICAgIC8vIEJ1aWxkIGEgemVyb2ZpZXIgcG9seW5vbWlhbCB3aXRoIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAgICAgICAgLy8gemVyb2ZpZXIoWCkgPSAoWC14QXJyWzBdKShYLXhBcnJbMV0pLi4uKFgteEFycltuXSlcbiAgICAgICAgcG9seW5vbWlhbC5zZXRDb2VmKDAsIEZyLm5lZyh4QXJyWzBdKSk7XG4gICAgICAgIHBvbHlub21pYWwuc2V0Q29lZigxLCBGci5vbmUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgeEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcG9seW5vbWlhbC5ieVhTdWJWYWx1ZSh4QXJyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIHByaW50KCkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGxldCByZXMgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5kZWdyZWUoKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZWYgPSB0aGlzLmdldENvZWYoaSk7XG4gICAgICAgICAgICBpZiAoIUZyLmVxKEZyLnplcm8sIGNvZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZyLmlzTmVnYXRpdmUoY29lZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiIC0gXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpICE9PSB0aGlzLmRlZ3JlZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIiArIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMgKz0gRnIudG9TdHJpbmcoY29lZik7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBpID4gMSA/IFwieF5cIiArIGkgOiBcInhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cocmVzKTtcbiAgICB9XG5cbiAgICBhc3luYyBtdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uODtcbiAgICAgICAgY29uc3QgUFRhdU4gPSBQVGF1LnNsaWNlKDAsIG4gKiB0aGlzLkcxLkYubjggKiAyKTtcbiAgICAgICAgY29uc3QgYm0gPSBhd2FpdCB0aGlzLkZyLmJhdGNoRnJvbU1vbnRnb21lcnkodGhpcy5jb2VmKTtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHRoaXMuRzEubXVsdGlFeHBBZmZpbmUoUFRhdU4sIGJtLCB0aGlzLmxvZ2dlciwgbmFtZSk7XG4gICAgICAgIHJlcyA9IHRoaXMuRzEudG9BZmZpbmUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/polynomial/polynomial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau.js":
/*!*************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   beacon: () => (/* reexport safe */ _powersoftau_beacon_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   challengeContribute: () => (/* reexport safe */ _powersoftau_challenge_contribute_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   contribute: () => (/* reexport safe */ _powersoftau_contribute_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   convert: () => (/* reexport safe */ _powersoftau_convert_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   exportChallenge: () => (/* reexport safe */ _powersoftau_export_challenge_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _powersoftau_export_json_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   importResponse: () => (/* reexport safe */ _powersoftau_import_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   newAccumulator: () => (/* reexport safe */ _powersoftau_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   preparePhase2: () => (/* reexport safe */ _powersoftau_preparephase2_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   truncate: () => (/* reexport safe */ _powersoftau_truncate_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _powersoftau_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _powersoftau_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_new.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_new.js\");\n/* harmony import */ var _powersoftau_export_challenge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_export_challenge.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_export_challenge.js\");\n/* harmony import */ var _powersoftau_import_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./powersoftau_import.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_import.js\");\n/* harmony import */ var _powersoftau_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./powersoftau_verify.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_verify.js\");\n/* harmony import */ var _powersoftau_challenge_contribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./powersoftau_challenge_contribute.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_challenge_contribute.js\");\n/* harmony import */ var _powersoftau_beacon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./powersoftau_beacon.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_beacon.js\");\n/* harmony import */ var _powersoftau_contribute_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./powersoftau_contribute.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_contribute.js\");\n/* harmony import */ var _powersoftau_preparephase2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./powersoftau_preparephase2.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_preparephase2.js\");\n/* harmony import */ var _powersoftau_truncate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./powersoftau_truncate.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_truncate.js\");\n/* harmony import */ var _powersoftau_convert_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./powersoftau_convert.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_convert.js\");\n/* harmony import */ var _powersoftau_export_json_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./powersoftau_export_json.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_export_json.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRStEO0FBQ2M7QUFDWDtBQUNSO0FBQzJCO0FBQzNCO0FBQ1E7QUFDTTtBQUNWO0FBQ0Y7QUFDTyIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQge2RlZmF1bHQgYXMgbmV3QWNjdW11bGF0b3J9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X25ldy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4cG9ydENoYWxsZW5nZX0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfZXhwb3J0X2NoYWxsZW5nZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGltcG9ydFJlc3BvbnNlfSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9pbXBvcnQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB2ZXJpZnl9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X3ZlcmlmeS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNoYWxsZW5nZUNvbnRyaWJ1dGV9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X2NoYWxsZW5nZV9jb250cmlidXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYmVhY29ufSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9iZWFjb24uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjb250cmlidXRlfSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9jb250cmlidXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcHJlcGFyZVBoYXNlMn0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfcHJlcGFyZXBoYXNlMi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRydW5jYXRlfSBmcm9tIFwiLi9wb3dlcnNvZnRhdV90cnVuY2F0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNvbnZlcnR9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X2NvbnZlcnQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRKc29ufSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9leHBvcnRfanNvbi5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_beacon.js":
/*!********************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_beacon.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ beacon)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function beacon(oldPtauFilename, newPTauFilename, name,  beaconHashStr,numIterationsExp, logger) {\n    const beaconHash = _misc_js__WEBPACK_IMPORTED_MODULE_1__.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        return false;\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 1, // Beacon\n        numIterationsExp: numIterationsExp,\n        beaconHash: beaconHash\n    };\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    curContribution.key = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.keyFromBeacon(curve, lastChallengeHash, beaconHash, numIterationsExp);\n\n    const responseHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_3__.blake2b.create({ dkLen: 64 });\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\", logger );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\", logger );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\", logger );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\", logger );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\", logger );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = _misc_js__WEBPACK_IMPORTED_MODULE_1__.toPartialHash(responseHasher);\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_1__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_3__.blake2b.create({ dkLen: 64 });\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_1__.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName, logger) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`applying key${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfYmVhY29uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDQTtBQUNkO0FBQ2tCOztBQUVyQztBQUNmLHVCQUF1QixtREFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsV0FBVyxxQkFBcUIsUUFBUSw0REFBd0I7QUFDaEUsV0FBVyw2QkFBNkIsUUFBUSxpRUFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0VBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0Qiw4RUFBaUM7QUFDN0Q7O0FBRUEsZ0NBQWdDLGdFQUFtQjs7QUFFbkQsMkJBQTJCLDBEQUFPLFVBQVUsV0FBVztBQUN2RDs7QUFFQSx3QkFBd0IsOERBQTBCO0FBQ2xELFVBQVUsa0VBQXFCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxtREFBa0I7O0FBRXBEOztBQUVBLElBQUksa0VBQXFCOztBQUV6QjtBQUNBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0MsZ0NBQWdDLDBEQUFPLFVBQVUsV0FBVztBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0M7O0FBRUEsVUFBVSxxRUFBd0I7O0FBRWxDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsa0VBQThCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkMsb0RBQW9ELFlBQVksSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnRUFBNEI7O0FBRTFDO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDLGdEQUFnRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDN0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfYmVhY29uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gYmVhY29uKG9sZFB0YXVGaWxlbmFtZSwgbmV3UFRhdUZpbGVuYW1lLCBuYW1lLCAgYmVhY29uSGFzaFN0cixudW1JdGVyYXRpb25zRXhwLCBsb2dnZXIpIHtcbiAgICBjb25zdCBiZWFjb25IYXNoID0gbWlzYy5oZXgyQnl0ZUFycmF5KGJlYWNvbkhhc2hTdHIpO1xuICAgIGlmICggICAoYmVhY29uSGFzaC5ieXRlTGVuZ3RoID09IDApXG4gICAgICAgIHx8IChiZWFjb25IYXNoLmJ5dGVMZW5ndGgqMiAhPWJlYWNvbkhhc2hTdHIubGVuZ3RoKSlcbiAgICB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgQmVhY29uIEhhc2guIChJdCBtdXN0IGJlIGEgdmFsaWQgaGV4YWRlY2ltYWwgc2VxdWVuY2UpXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiZWFjb25IYXNoLmxlbmd0aD49MjU2KSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIk1heGltdW0gbGVuZ3RoIG9mIGJlYWNvbiBoYXNoIGlzIDI1NSBieXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG51bUl0ZXJhdGlvbnNFeHAgPSBwYXJzZUludChudW1JdGVyYXRpb25zRXhwKTtcbiAgICBpZiAoKG51bUl0ZXJhdGlvbnNFeHA8MTApfHwobnVtSXRlcmF0aW9uc0V4cD42MykpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1JdGVyYXRpb25zRXhwLiAoTXVzdCBiZSBiZXR3ZWVuIDEwIGFuZCA2MylcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShvbGRQdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyLCBjZXJlbW9ueVBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG4gICAgaWYgKHBvd2VyICE9IGNlcmVtb255UG93ZXIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiVGhpcyBmaWxlIGhhcyBiZWVuIHJlZHVjZWQuIFlvdSBjYW5ub3QgY29udHJpYnV0ZSBpbnRvIGEgcmVkdWNlZCBmaWxlLlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc2VjdGlvbnNbMTJdKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci53YXJuKFwiQ29udHJpYnV0aW5nIGludG8gYSBmaWxlIHRoYXQgaGFzIHBoYXNlMiBjYWxjdWxhdGVkLiBZb3Ugd2lsbCBoYXZlIHRvIHByZXBhcmUgcGhhc2UyIGFnYWluLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY29udHJpYnV0aW9ucyA9IGF3YWl0IHV0aWxzLnJlYWRDb250cmlidXRpb25zKGZkT2xkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuICAgIGNvbnN0IGN1ckNvbnRyaWJ1dGlvbiA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogMSwgLy8gQmVhY29uXG4gICAgICAgIG51bUl0ZXJhdGlvbnNFeHA6IG51bUl0ZXJhdGlvbnNFeHAsXG4gICAgICAgIGJlYWNvbkhhc2g6IGJlYWNvbkhhc2hcbiAgICB9O1xuXG4gICAgbGV0IGxhc3RDaGFsbGVuZ2VIYXNoO1xuXG4gICAgaWYgKGNvbnRyaWJ1dGlvbnMubGVuZ3RoPjApIHtcbiAgICAgICAgbGFzdENoYWxsZW5nZUhhc2ggPSBjb250cmlidXRpb25zW2NvbnRyaWJ1dGlvbnMubGVuZ3RoLTFdLm5leHRDaGFsbGVuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdENoYWxsZW5nZUhhc2ggPSB1dGlscy5jYWxjdWxhdGVGaXJzdENoYWxsZW5nZUhhc2goY3VydmUsIHBvd2VyLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5rZXkgPSBhd2FpdCB1dGlscy5rZXlGcm9tQmVhY29uKGN1cnZlLCBsYXN0Q2hhbGxlbmdlSGFzaCwgYmVhY29uSGFzaCwgbnVtSXRlcmF0aW9uc0V4cCk7XG5cbiAgICBjb25zdCByZXNwb25zZUhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShsYXN0Q2hhbGxlbmdlSGFzaCk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDcpO1xuICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGNvbnN0IHN0YXJ0U2VjdGlvbnMgPSBbXTtcblxuICAgIGxldCBmaXJzdFBvaW50cztcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDIsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAqIDIgLTEsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24udGF1RzEgPSBmaXJzdFBvaW50c1sxXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIFwiRzJcIiwgICgyICoqIHBvd2VyKSAsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMlwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24udGF1RzIgPSBmaXJzdFBvaW50c1sxXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDQsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAsIGN1ckNvbnRyaWJ1dGlvbi5rZXkuYWxwaGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYWxwaGFHMSA9IGZpcnN0UG9pbnRzWzBdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNSwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICwgY3VyQ29udHJpYnV0aW9uLmtleS5iZXRhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImJldGFUYXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYmV0YUcxID0gZmlyc3RQb2ludHNbMF07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig2LCBcIkcyXCIsICAxLCBjdXJDb250cmlidXRpb24ua2V5LmJldGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYmV0YVRhdUcyXCIsIGxvZ2dlciApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5iZXRhRzIgPSBmaXJzdFBvaW50c1swXTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5wYXJ0aWFsSGFzaCA9IG1pc2MudG9QYXJ0aWFsSGFzaChyZXNwb25zZUhhc2hlcik7XG5cbiAgICBjb25zdCBidWZmS2V5ID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMio2K2N1cnZlLkYyLm44KjIqMyk7XG5cbiAgICB1dGlscy50b1B0YXVQdWJLZXlScHIoYnVmZktleSwgMCwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5rZXksIGZhbHNlKTtcblxuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShuZXcgVWludDhBcnJheShidWZmS2V5KSk7XG4gICAgY29uc3QgaGFzaFJlc3BvbnNlID0gcmVzcG9uc2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goaGFzaFJlc3BvbnNlLCBcIkNvbnRyaWJ1dGlvbiBSZXNwb25zZSBIYXNoIGltcG9ydGVkOiBcIikpO1xuXG4gICAgY29uc3QgbmV4dENoYWxsZW5nZUhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGhhc2hSZXNwb25zZSk7XG5cbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgXCJ0YXVHMlwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDQsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgXCJiZXRhRzJcIiwgbG9nZ2VyKTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbmV4dENoYWxsZW5nZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjdXJDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSwgXCJOZXh0IENoYWxsZW5nZSBIYXNoOiBcIikpO1xuXG4gICAgY29udHJpYnV0aW9ucy5wdXNoKGN1ckNvbnRyaWJ1dGlvbik7XG5cbiAgICBhd2FpdCB1dGlscy53cml0ZUNvbnRyaWJ1dGlvbnMoZmROZXcsIGN1cnZlLCBjb250cmlidXRpb25zKTtcblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcblxuICAgIHJldHVybiBoYXNoUmVzcG9uc2U7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihzZWN0aW9uSWQsIGdyb3VwTmFtZSwgTlBvaW50cywgZmlyc3QsIGluYywgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZmRPbGQucG9zID0gc2VjdGlvbnNbc2VjdGlvbklkXVswXS5wO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgc2VjdGlvbklkKTtcblxuICAgICAgICBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF0gPSBmZE5ldy5wb3M7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGguZmxvb3IoKDE8PDIwKSAvIHNHKTsgICAvLyAxMjhNYiBjaHVua3NcbiAgICAgICAgbGV0IHQgPSBmaXJzdDtcbiAgICAgICAgZm9yIChsZXQgaT0wIDsgaTxOUG9pbnRzIDsgaSs9IGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBhcHBseWluZyBrZXkke3NlY3Rpb25OYW1lfTogJHtpfS8ke05Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuPSBNYXRoLm1pbihOUG9pbnRzLWksIGNodW5rU2l6ZSApO1xuICAgICAgICAgICAgY29uc3QgYnVmZkluID0gYXdhaXQgZmRPbGQucmVhZChuICogc0cpO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dExFTSA9IGF3YWl0IEcuYmF0Y2hBcHBseUtleShidWZmSW4sIHQsIGluYyk7XG5cbiAgICAgICAgICAgIC8qIENvZGUgdG8gdGVzdCB0aGUgY2FzZSB3aGVyZSB3ZSBkb24ndCBoYXZlIHRoZSAyXm0tMiBjb21wb25lbnRcbiAgICAgICAgICAgIGlmIChzZWN0aW9uTmFtZT09IFwidGF1RzFcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ6ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXRMRU0uc2V0KGJ6LCA2NCooKDIgKiogcG93ZXIpIC0gMSApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VXcml0ZSA9IGZkTmV3LndyaXRlKGJ1ZmZPdXRMRU0pO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dEMgPSBhd2FpdCBHLmJhdGNoTEVNdG9DKGJ1ZmZPdXRMRU0pO1xuXG4gICAgICAgICAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZk91dEMpO1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZVdyaXRlO1xuICAgICAgICAgICAgaWYgKGk9PTApICAgLy8gUmV0dXJuIHRoZSAyIGZpcnN0IHBvaW50cy5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8TWF0aC5taW4oMiwgTlBvaW50cyk7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goRy5mcm9tUnByTEVNKGJ1ZmZPdXRMRU0sIGoqc0cpKTtcbiAgICAgICAgICAgIHQgPSBjdXJ2ZS5Gci5tdWwodCwgY3VydmUuRnIuZXhwKGluYywgbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZE5ldyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhc2hTZWN0aW9uKGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zRyk7XG5cbiAgICAgICAgY29uc3Qgb2xkUG9zID0gZmRUby5wb3M7XG4gICAgICAgIGZkVG8ucG9zID0gc3RhcnRTZWN0aW9uc1tzZWN0aW9uSWRdO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSGFzaGluZyAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cy1pLCBuUG9pbnRzQ2h1bmspO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmTEVNID0gYXdhaXQgZmRUby5yZWFkKG4gKiBzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZVID0gYXdhaXQgRy5iYXRjaExFTXRvVShidWZmTEVNKTtcblxuICAgICAgICAgICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoYnVmZlUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmRUby5wb3MgPSBvbGRQb3M7XG4gICAgfVxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_beacon.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_challenge_contribute.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_challenge_contribute.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ challengeContribute)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(ssr)/./node_modules/snarkjs/src/mpc_applykey.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/./node_modules/snarkjs/src/keypair.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\n\n\n\n\n\n\n\nasync function challengeContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    const fdFrom = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(challengeFilename);\n\n\n    const sG1 = curve.F1.n64*8*2;\n    const sG2 = curve.F2.n64*8*2;\n    const domainSize = (fdFrom.totalSize + sG1 - 64 - sG2) / (4*sG1 + sG2);\n    let e = domainSize;\n    let power = 0;\n    while (e>1) {\n        e = e /2;\n        power += 1;\n    }\n\n    if (2 ** power != domainSize) throw new Error(\"Invalid file size\");\n    if (logger) logger.debug(\"Power to tau size: \"+power);\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_2__.getRandomRng(entropy);\n\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(responseFileName);\n\n    // Calculate the hash\n    const challengeHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 });\n    for (let i=0; i<fdFrom.totalSize; i+= fdFrom.pageSize) {\n        if (logger) logger.debug(`Hashing challenge ${i}/${fdFrom.totalSize}`);\n        const s = Math.min(fdFrom.totalSize - i, fdFrom.pageSize);\n        const buff = await fdFrom.read(s);\n        challengeHasher.update(buff);\n    }\n\n    const claimedHash = await fdFrom.read(64, 0);\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(claimedHash, \"Claimed Previous Response Hash: \"));\n\n    const challengeHash = challengeHasher.digest();\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(challengeHash, \"Current Challenge Hash: \"));\n\n    const key = _keypair_js__WEBPACK_IMPORTED_MODULE_4__.createPTauKey(curve, challengeHash, rng);\n\n    if (logger) {\n        [\"tau\", \"alpha\", \"beta\"].forEach( (k) => {\n            logger.debug(k + \".g1_s: \" + curve.G1.toString(key[k].g1_s, 16));\n            logger.debug(k + \".g1_sx: \" + curve.G1.toString(key[k].g1_sx, 16));\n            logger.debug(k + \".g2_sp: \" + curve.G2.toString(key[k].g2_sp, 16));\n            logger.debug(k + \".g2_spx: \" + curve.G2.toString(key[k].g2_spx, 16));\n            logger.debug(\"\");\n        });\n    }\n\n    const responseHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 });\n\n    await fdTo.write(challengeHash);\n    responseHasher.update(challengeHash);\n\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)*2-1, curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG1\"     , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G2\", (2 ** power)    , curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG2\"     , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.alpha.prvKey, key.tau.prvKey, \"COMPRESSED\", \"alphaTauG1\", logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG1\" , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G2\", 1             , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG2\" , logger );\n\n    // Write and hash key\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.toPtauPubKeyRpr(buffKey, 0, curve, key, false);\n    await fdTo.write(buffKey);\n    responseHasher.update(buffKey);\n    const responseHash = responseHasher.digest();\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(responseHash, \"Contribution Response Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfY2hhbGxlbmdlX2NvbnRyaWJ1dGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDVztBQUNBO0FBQ2Q7QUFDNkI7QUFDdkI7O0FBRXpCO0FBQ2YseUJBQXlCLGtEQUFxQjs7O0FBRzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixrREFBaUI7O0FBRXZDLHVCQUF1QixvREFBdUI7O0FBRTlDO0FBQ0EsNEJBQTRCLDBEQUFPLFVBQVUsV0FBVztBQUN4RCxrQkFBa0Isb0JBQW9CO0FBQ3RDLHNEQUFzRCxFQUFFLEdBQUcsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBLDRCQUE0QixnREFBZTs7QUFFM0MsZ0JBQWdCLHNEQUFxQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsMkJBQTJCLDBEQUFPLFVBQVUsV0FBVzs7QUFFdkQ7QUFDQTs7QUFFQSxVQUFVLDRFQUEwQjtBQUNwQyxVQUFVLDRFQUEwQjtBQUNwQyxVQUFVLDRFQUEwQjtBQUNwQyxVQUFVLDRFQUEwQjtBQUNwQyxVQUFVLDRFQUEwQjs7QUFFcEM7QUFDQTtBQUNBLElBQUksa0VBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBZTs7QUFFM0M7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2NoYWxsZW5nZV9jb250cmlidXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIEZvcm1hdCBvZiB0aGUgb3V0cHV0XG4vLyAgICAgIEhhc2ggb2YgdGhlIGxhc3QgY29udHJpYnV0aW9uICA2NCBCeXRlc1xuLy8gICAgICAyXk4qMi0xIFRhdUcxIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgMl5OIFRhdUcyIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgMl5OIEFscGhhVGF1RzEgUG9pbnRzIChjb21wcmVzc2VkKVxuLy8gICAgICAyXk4gQmV0YVRhdUcxIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgUHVibGljIEtleVxuLy8gICAgICAgICAgQmV0YUcyIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqcyAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnMqdGF1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdCAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnQqYWxwaGEgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSp1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdSpiZXRhIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzIqc3AqdGF1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzIqdHAqYWxwaGEgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMip1cCpiZXRhIChjb21wcmVzc2VkKVxuXG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbiB9IGZyb20gXCIuL21wY19hcHBseWtleS5qc1wiO1xuaW1wb3J0ICogYXMga2V5UGFpciBmcm9tIFwiLi9rZXlwYWlyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGNoYWxsZW5nZUNvbnRyaWJ1dGUoY3VydmUsIGNoYWxsZW5nZUZpbGVuYW1lLCByZXNwb25zZUZpbGVOYW1lLCBlbnRyb3B5LCBsb2dnZXIpIHtcbiAgICBjb25zdCBmZEZyb20gPSBhd2FpdCBmYXN0RmlsZS5yZWFkRXhpc3RpbmcoY2hhbGxlbmdlRmlsZW5hbWUpO1xuXG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5GMS5uNjQqOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkYyLm42NCo4KjI7XG4gICAgY29uc3QgZG9tYWluU2l6ZSA9IChmZEZyb20udG90YWxTaXplICsgc0cxIC0gNjQgLSBzRzIpIC8gKDQqc0cxICsgc0cyKTtcbiAgICBsZXQgZSA9IGRvbWFpblNpemU7XG4gICAgbGV0IHBvd2VyID0gMDtcbiAgICB3aGlsZSAoZT4xKSB7XG4gICAgICAgIGUgPSBlIC8yO1xuICAgICAgICBwb3dlciArPSAxO1xuICAgIH1cblxuICAgIGlmICgyICoqIHBvd2VyICE9IGRvbWFpblNpemUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZmlsZSBzaXplXCIpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlBvd2VyIHRvIHRhdSBzaXplOiBcIitwb3dlcik7XG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBtaXNjLmdldFJhbmRvbVJuZyhlbnRyb3B5KTtcblxuICAgIGNvbnN0IGZkVG8gPSBhd2FpdCBmYXN0RmlsZS5jcmVhdGVPdmVycmlkZShyZXNwb25zZUZpbGVOYW1lKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgaGFzaFxuICAgIGNvbnN0IGNoYWxsZW5nZUhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIGZvciAobGV0IGk9MDsgaTxmZEZyb20udG90YWxTaXplOyBpKz0gZmRGcm9tLnBhZ2VTaXplKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSGFzaGluZyBjaGFsbGVuZ2UgJHtpfS8ke2ZkRnJvbS50b3RhbFNpemV9YCk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLm1pbihmZEZyb20udG90YWxTaXplIC0gaSwgZmRGcm9tLnBhZ2VTaXplKTtcbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkRnJvbS5yZWFkKHMpO1xuICAgICAgICBjaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGNvbnN0IGNsYWltZWRIYXNoID0gYXdhaXQgZmRGcm9tLnJlYWQoNjQsIDApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjbGFpbWVkSGFzaCwgXCJDbGFpbWVkIFByZXZpb3VzIFJlc3BvbnNlIEhhc2g6IFwiKSk7XG5cbiAgICBjb25zdCBjaGFsbGVuZ2VIYXNoID0gY2hhbGxlbmdlSGFzaGVyLmRpZ2VzdCgpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjaGFsbGVuZ2VIYXNoLCBcIkN1cnJlbnQgQ2hhbGxlbmdlIEhhc2g6IFwiKSk7XG5cbiAgICBjb25zdCBrZXkgPSBrZXlQYWlyLmNyZWF0ZVBUYXVLZXkoY3VydmUsIGNoYWxsZW5nZUhhc2gsIHJuZyk7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIFtcInRhdVwiLCBcImFscGhhXCIsIFwiYmV0YVwiXS5mb3JFYWNoKCAoaykgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGsgKyBcIi5nMV9zOiBcIiArIGN1cnZlLkcxLnRvU3RyaW5nKGtleVtrXS5nMV9zLCAxNikpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGsgKyBcIi5nMV9zeDogXCIgKyBjdXJ2ZS5HMS50b1N0cmluZyhrZXlba10uZzFfc3gsIDE2KSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoayArIFwiLmcyX3NwOiBcIiArIGN1cnZlLkcyLnRvU3RyaW5nKGtleVtrXS5nMl9zcCwgMTYpKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhrICsgXCIuZzJfc3B4OiBcIiArIGN1cnZlLkcyLnRvU3RyaW5nKGtleVtrXS5nMl9zcHgsIDE2KSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJcIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG5cbiAgICBhd2FpdCBmZFRvLndyaXRlKGNoYWxsZW5nZUhhc2gpO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShjaGFsbGVuZ2VIYXNoKTtcblxuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcxXCIsICgyICoqIHBvd2VyKSoyLTEsIGN1cnZlLkZyLm9uZSAgICAsIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJ0YXVHMVwiICAgICAsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcyXCIsICgyICoqIHBvd2VyKSAgICAsIGN1cnZlLkZyLm9uZSAgICAsIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJ0YXVHMlwiICAgICAsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcxXCIsICgyICoqIHBvd2VyKSAgICAsIGtleS5hbHBoYS5wcnZLZXksIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJhbHBoYVRhdUcxXCIsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcxXCIsICgyICoqIHBvd2VyKSAgICAsIGtleS5iZXRhLnBydktleSAsIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJiZXRhVGF1RzFcIiAsIGxvZ2dlciApO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgcmVzcG9uc2VIYXNoZXIsIGN1cnZlLCBcIkcyXCIsIDEgICAgICAgICAgICAgLCBrZXkuYmV0YS5wcnZLZXkgLCBrZXkudGF1LnBydktleSwgXCJDT01QUkVTU0VEXCIsIFwiYmV0YVRhdUcyXCIgLCBsb2dnZXIgKTtcblxuICAgIC8vIFdyaXRlIGFuZCBoYXNoIGtleVxuICAgIGNvbnN0IGJ1ZmZLZXkgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCoyKjYrY3VydmUuRjIubjgqMiozKTtcbiAgICB1dGlscy50b1B0YXVQdWJLZXlScHIoYnVmZktleSwgMCwgY3VydmUsIGtleSwgZmFsc2UpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZktleSk7XG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGJ1ZmZLZXkpO1xuICAgIGNvbnN0IHJlc3BvbnNlSGFzaCA9IHJlc3BvbnNlSGFzaGVyLmRpZ2VzdCgpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChyZXNwb25zZUhhc2gsIFwiQ29udHJpYnV0aW9uIFJlc3BvbnNlIEhhc2g6IFwiKSk7XG5cbiAgICBhd2FpdCBmZFRvLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRGcm9tLmNsb3NlKCk7XG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_challenge_contribute.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_contribute.js":
/*!************************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_contribute.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ contribute)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (uncompressed)\n//      2^N TauG2 Points (uncompressed)\n//      2^N AlphaTauG1 Points (uncompressed)\n//      2^N BetaTauG1 Points (uncompressed)\n\n\n\n\n\n\n\nasync function contribute(oldPtauFilename, newPTauFilename, name, entropy, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        throw new Error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 0, // Beacon\n    };\n\n    let lastChallengeHash;\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomRng(entropy);\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    // Generate a random key\n\n\n    curContribution.key = _keypair_js__WEBPACK_IMPORTED_MODULE_1__.createPTauKey(curve, lastChallengeHash, rng);\n\n\n    const responseHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\" );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\" );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\" );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\" );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\" );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = _misc_js__WEBPACK_IMPORTED_MODULE_3__.toPartialHash(responseHasher);\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\");\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\");\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\");\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\");\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\");\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`processing: ${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if ((logger)&&i) logger.debug(`Hashing ${sectionName}: ` + i);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfY29udHJpYnV0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDQTtBQUNSO0FBQ1k7QUFDbEI7O0FBRW5COztBQUVmLFdBQVcscUJBQXFCLFFBQVEsNERBQXdCO0FBQ2hFLFdBQVcsNkJBQTZCLFFBQVEsaUVBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9FQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0Isa0RBQWlCOztBQUV2QztBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0Qiw4RUFBaUM7QUFDN0Q7O0FBRUE7OztBQUdBLDBCQUEwQixzREFBcUI7OztBQUcvQywyQkFBMkIsMERBQU8sVUFBVSxXQUFXO0FBQ3ZEOztBQUVBLHdCQUF3Qiw4REFBMEI7QUFDbEQsVUFBVSxrRUFBcUI7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLG1EQUFrQjs7QUFFcEQ7O0FBRUEsSUFBSSxrRUFBcUI7O0FBRXpCO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQyxnQ0FBZ0MsMERBQU8sVUFBVSxXQUFXO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQzs7QUFFQSxVQUFVLHFFQUF3Qjs7QUFFbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxrRUFBOEI7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQyxvREFBb0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdFQUE0Qjs7QUFFMUM7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEMscURBQXFELFlBQVk7QUFDakU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9jb250cmlidXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIEZvcm1hdCBvZiB0aGUgb3V0cHV0XG4vLyAgICAgIEhhc2ggb2YgdGhlIGxhc3QgY29udHJpYnV0aW9uICA2NCBCeXRlc1xuLy8gICAgICAyXk4qMi0xIFRhdUcxIFBvaW50cyAodW5jb21wcmVzc2VkKVxuLy8gICAgICAyXk4gVGF1RzIgUG9pbnRzICh1bmNvbXByZXNzZWQpXG4vLyAgICAgIDJeTiBBbHBoYVRhdUcxIFBvaW50cyAodW5jb21wcmVzc2VkKVxuLy8gICAgICAyXk4gQmV0YVRhdUcxIFBvaW50cyAodW5jb21wcmVzc2VkKVxuXG5pbXBvcnQgeyBibGFrZTJiIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvYmxha2UyYlwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGtleVBhaXIgZnJvbSBcIi4va2V5cGFpci5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY29udHJpYnV0ZShvbGRQdGF1RmlsZW5hbWUsIG5ld1BUYXVGaWxlbmFtZSwgbmFtZSwgZW50cm9weSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUob2xkUHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlciwgY2VyZW1vbnlQb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuICAgIGlmIChwb3dlciAhPSBjZXJlbW9ueVBvd2VyKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlRoaXMgZmlsZSBoYXMgYmVlbiByZWR1Y2VkLiBZb3UgY2Fubm90IGNvbnRyaWJ1dGUgaW50byBhIHJlZHVjZWQgZmlsZS5cIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZmlsZSBoYXMgYmVlbiByZWR1Y2VkLiBZb3UgY2Fubm90IGNvbnRyaWJ1dGUgaW50byBhIHJlZHVjZWQgZmlsZS5cIik7XG4gICAgfVxuICAgIGlmIChzZWN0aW9uc1sxMl0pIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLndhcm4oXCJXQVJOSU5HOiBDb250cmlidXRpbmcgaW50byBhIGZpbGUgdGhhdCBoYXMgcGhhc2UyIGNhbGN1bGF0ZWQuIFlvdSB3aWxsIGhhdmUgdG8gcHJlcGFyZSBwaGFzZTIgYWdhaW4uXCIpO1xuICAgIH1cbiAgICBjb25zdCBjb250cmlidXRpb25zID0gYXdhaXQgdXRpbHMucmVhZENvbnRyaWJ1dGlvbnMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiAwLCAvLyBCZWFjb25cbiAgICB9O1xuXG4gICAgbGV0IGxhc3RDaGFsbGVuZ2VIYXNoO1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5nZXRSYW5kb21SbmcoZW50cm9weSk7XG5cbiAgICBpZiAoY29udHJpYnV0aW9ucy5sZW5ndGg+MCkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IHV0aWxzLmNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgYSByYW5kb20ga2V5XG5cblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5rZXkgPSBrZXlQYWlyLmNyZWF0ZVBUYXVLZXkoY3VydmUsIGxhc3RDaGFsbGVuZ2VIYXNoLCBybmcpO1xuXG5cbiAgICBjb25zdCByZXNwb25zZUhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShsYXN0Q2hhbGxlbmdlSGFzaCk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDcpO1xuICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGNvbnN0IHN0YXJ0U2VjdGlvbnMgPSBbXTtcblxuICAgIGxldCBmaXJzdFBvaW50cztcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDIsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAqIDIgLTEsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMVwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLnRhdUcxID0gZmlyc3RQb2ludHNbMV07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbigzLCBcIkcyXCIsICAoMiAqKiBwb3dlcikgLCBjdXJ2ZS5Gci5lKDEpLCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwidGF1RzJcIiApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50YXVHMiA9IGZpcnN0UG9pbnRzWzFdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNCwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICwgY3VyQ29udHJpYnV0aW9uLmtleS5hbHBoYS5wcnZLZXksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJhbHBoYVRhdUcxXCIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYWxwaGFHMSA9IGZpcnN0UG9pbnRzWzBdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNSwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICwgY3VyQ29udHJpYnV0aW9uLmtleS5iZXRhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImJldGFUYXVHMVwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmJldGFHMSA9IGZpcnN0UG9pbnRzWzBdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNiwgXCJHMlwiLCAgMSwgY3VyQ29udHJpYnV0aW9uLmtleS5iZXRhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImJldGFUYXVHMlwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmJldGFHMiA9IGZpcnN0UG9pbnRzWzBdO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLnBhcnRpYWxIYXNoID0gbWlzYy50b1BhcnRpYWxIYXNoKHJlc3BvbnNlSGFzaGVyKTtcblxuICAgIGNvbnN0IGJ1ZmZLZXkgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCoyKjYrY3VydmUuRjIubjgqMiozKTtcblxuICAgIHV0aWxzLnRvUHRhdVB1YktleVJwcihidWZmS2V5LCAwLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmtleSwgZmFsc2UpO1xuXG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZLZXkpKTtcbiAgICBjb25zdCBoYXNoUmVzcG9uc2UgPSByZXNwb25zZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChoYXNoUmVzcG9uc2UsIFwiQ29udHJpYnV0aW9uIFJlc3BvbnNlIEhhc2ggaW1wb3J0ZWQ6IFwiKSk7XG5cbiAgICBjb25zdCBuZXh0Q2hhbGxlbmdlSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoaGFzaFJlc3BvbnNlKTtcblxuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDIsICgyICoqIHBvd2VyKSAqIDIgLTEsIFwidGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgXCJ0YXVHMlwiKTtcbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCA0LCAoMiAqKiBwb3dlcikgICAgICAgLCBcImFscGhhVGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzFcIiwgNSwgKDIgKiogcG93ZXIpICAgICAgICwgXCJiZXRhVGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgXCJiZXRhRzJcIik7XG5cbiAgICBjdXJDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSA9IG5leHRDaGFsbGVuZ2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY3VyQ29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuICAgIGNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgdXRpbHMud3JpdGVDb250cmlidXRpb25zKGZkTmV3LCBjdXJ2ZSwgY29udHJpYnV0aW9ucyk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICByZXR1cm4gaGFzaFJlc3BvbnNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIE5Qb2ludHMsIGZpcnN0LCBpbmMsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmZE9sZC5wb3MgPSBzZWN0aW9uc1tzZWN0aW9uSWRdWzBdLnA7XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkTmV3LCBzZWN0aW9uSWQpO1xuXG4gICAgICAgIHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXSA9IGZkTmV3LnBvcztcblxuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5mbG9vcigoMTw8MjApIC8gc0cpOyAgIC8vIDEyOE1iIGNodW5rc1xuICAgICAgICBsZXQgdCA9IGZpcnN0O1xuICAgICAgICBmb3IgKGxldCBpPTAgOyBpPE5Qb2ludHMgOyBpKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHByb2Nlc3Npbmc6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7TlBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG49IE1hdGgubWluKE5Qb2ludHMtaSwgY2h1bmtTaXplICk7XG4gICAgICAgICAgICBjb25zdCBidWZmSW4gPSBhd2FpdCBmZE9sZC5yZWFkKG4gKiBzRyk7XG4gICAgICAgICAgICBjb25zdCBidWZmT3V0TEVNID0gYXdhaXQgRy5iYXRjaEFwcGx5S2V5KGJ1ZmZJbiwgdCwgaW5jKTtcblxuICAgICAgICAgICAgLyogQ29kZSB0byB0ZXN0IHRoZSBjYXNlIHdoZXJlIHdlIGRvbid0IGhhdmUgdGhlIDJebS0yIGNvbXBvbmVudFxuICAgICAgICAgICAgaWYgKHNlY3Rpb25OYW1lPT0gXCJ0YXVHMVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnogPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgICAgICAgICAgICAgYnVmZk91dExFTS5zZXQoYnosIDY0KigoMiAqKiBwb3dlcikgLSAxICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZVdyaXRlID0gZmROZXcud3JpdGUoYnVmZk91dExFTSk7XG4gICAgICAgICAgICBjb25zdCBidWZmT3V0QyA9IGF3YWl0IEcuYmF0Y2hMRU10b0MoYnVmZk91dExFTSk7XG5cbiAgICAgICAgICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmT3V0Qyk7XG4gICAgICAgICAgICBhd2FpdCBwcm9taXNlV3JpdGU7XG4gICAgICAgICAgICBpZiAoaT09MCkgICAvLyBSZXR1cm4gdGhlIDIgZmlyc3QgcG9pbnRzLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxNYXRoLm1pbigyLCBOUG9pbnRzKTsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChHLmZyb21ScHJMRU0oYnVmZk91dExFTSwgaipzRykpO1xuICAgICAgICAgICAgdCA9IGN1cnZlLkZyLm11bCh0LCBjdXJ2ZS5Gci5leHAoaW5jLCBuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFzaFNlY3Rpb24oZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNlY3Rpb25OYW1lKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zRyk7XG5cbiAgICAgICAgY29uc3Qgb2xkUG9zID0gZmRUby5wb3M7XG4gICAgICAgIGZkVG8ucG9zID0gc3RhcnRTZWN0aW9uc1tzZWN0aW9uSWRdO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmaSkgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nICR7c2VjdGlvbk5hbWV9OiBgICsgaSk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cy1pLCBuUG9pbnRzQ2h1bmspO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmTEVNID0gYXdhaXQgZmRUby5yZWFkKG4gKiBzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZVID0gYXdhaXQgRy5iYXRjaExFTXRvVShidWZmTEVNKTtcblxuICAgICAgICAgICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoYnVmZlUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmRUby5wb3MgPSBvbGRQb3M7XG4gICAgfVxuXG5cbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_contribute.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_convert.js":
/*!*********************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_convert.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ convert)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function convert(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    // const fdTmp = await fastFile.createOverride(newPTauFilename+ \".tmp\");\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 13);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 14);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 15);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, newSectionId);\n\n        const size = sections[newSectionId][0].size;\n        const chunkSize = fdOld.pageSize;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, newSectionId);\n        for (let p=0; p<size; p+=chunkSize) {\n            const l = Math.min(size -p, chunkSize);\n            const buff = await fdOld.read(l);\n            await fdNew.write(buff);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld);\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const sGin = G.F.n8*2;\n\n            let buff;\n            buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(nPoints*sGin);\n\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld, true);\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    if (i%10000) logger.debug(`sectionName prepare L calc: ${sectionName}, ${i}/${smallM}`);\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t1\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n\n\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfY29udmVydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ0o7QUFDWDtBQUNFOztBQUV4Qjs7QUFFZixXQUFXLHFCQUFxQixRQUFRLDREQUF3QjtBQUNoRSxXQUFXLGNBQWMsUUFBUSxpRUFBb0I7O0FBRXJELHdCQUF3Qiw4REFBMEI7QUFDbEQsVUFBVSxrRUFBcUI7O0FBRS9COztBQUVBLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCOztBQUVsQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxrRUFBOEI7O0FBRTVDO0FBQ0E7QUFDQSxjQUFjLHVFQUFtQztBQUNqRCxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQTJCOztBQUV6QztBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnRUFBNEI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1EQUFTOztBQUVoQyxrQkFBa0IsdUVBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDLDZFQUE2RSxZQUFZLElBQUksRUFBRSxHQUFHLE9BQU87QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9jb252ZXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuaW1wb3J0IHtCaWdCdWZmZXJ9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY29udmVydChvbGRQdGF1RmlsZW5hbWUsIG5ld1BUYXVGaWxlbmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUob2xkUHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZShuZXdQVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxLCAxMSk7XG4gICAgYXdhaXQgdXRpbHMud3JpdGVQVGF1SGVhZGVyKGZkTmV3LCBjdXJ2ZSwgcG93ZXIpO1xuXG4gICAgLy8gY29uc3QgZmRUbXAgPSBhd2FpdCBmYXN0RmlsZS5jcmVhdGVPdmVycmlkZShuZXdQVGF1RmlsZW5hbWUrIFwiLnRtcFwiKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMyk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDQpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNik7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDcpO1xuXG4gICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgMTIsIFwiRzFcIiwgXCJ0YXVHMVwiICk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDEzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTQpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxNSk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICAvLyBhd2FpdCBmcy5wcm9taXNlcy51bmxpbmsobmV3UFRhdUZpbGVuYW1lKyBcIi50bXBcIik7XG5cbiAgICByZXR1cm47XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihvbGRTZWN0aW9uSWQsIG5ld1NlY3Rpb25JZCwgR3N0ciwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiU3RhcnRpbmcgc2VjdGlvbjogXCIrc2VjdGlvbk5hbWUpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgbmV3U2VjdGlvbklkKTtcblxuICAgICAgICBjb25zdCBzaXplID0gc2VjdGlvbnNbbmV3U2VjdGlvbklkXVswXS5zaXplO1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBmZE9sZC5wYWdlU2l6ZTtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBuZXdTZWN0aW9uSWQpO1xuICAgICAgICBmb3IgKGxldCBwPTA7IHA8c2l6ZTsgcCs9Y2h1bmtTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gTWF0aC5taW4oc2l6ZSAtcCwgY2h1bmtTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZE9sZC5yZWFkKGwpO1xuICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkT2xkKTtcblxuICAgICAgICBpZiAob2xkU2VjdGlvbklkID09IDIpIHtcbiAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uUG93ZXIocG93ZXIrMSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvblBvd2VyKHApIHtcbiAgICAgICAgICAgIGNvbnN0IG5Qb2ludHMgPSAyICoqIHA7XG4gICAgICAgICAgICBjb25zdCBHID0gY3VydmVbR3N0cl07XG4gICAgICAgICAgICBjb25zdCBzR2luID0gRy5GLm44KjI7XG5cbiAgICAgICAgICAgIGxldCBidWZmO1xuICAgICAgICAgICAgYnVmZiA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzR2luKTtcblxuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBvbGRTZWN0aW9uSWQpO1xuICAgICAgICAgICAgaWYgKChvbGRTZWN0aW9uSWQgPT0gMikmJihwPT1wb3dlcisxKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkT2xkLnJlYWRUb0J1ZmZlcihidWZmLCAwLChuUG9pbnRzLTEpKnNHaW4gKTtcbiAgICAgICAgICAgICAgICBidWZmLnNldChjdXJ2ZS5HMS56ZXJvQWZmaW5lLCAoblBvaW50cy0xKSpzR2luICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkT2xkLnJlYWRUb0J1ZmZlcihidWZmLCAwLG5Qb2ludHMqc0dpbiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkT2xkLCB0cnVlKTtcblxuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcubGFncmFuZ2VFdmFsdWF0aW9ucyhidWZmLCBcImFmZmluZVwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuXG4vKlxuICAgICAgICAgICAgaWYgKHAgPD0gY3VydmUuRnIucykge1xuICAgICAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmlmZnQoYnVmZiwgXCJhZmZpbmVcIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAgPT0gY3VydmUuRnIucysxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc21hbGxNID0gMTw8Y3VydmUuRnIucztcbiAgICAgICAgICAgICAgICBsZXQgdDAgPSBuZXcgQmlnQnVmZmVyKCBzbWFsbE0gKiBzR21pZCApO1xuICAgICAgICAgICAgICAgIGxldCB0MSA9IG5ldyBCaWdCdWZmZXIoIHNtYWxsTSAqIHNHbWlkICk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaGlmdF90b19zbWFsbF9tID0gRnIuZXhwKEZyLnNoaWZ0LCBzbWFsbE0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uZV9vdmVyX2Rlbm9tID0gRnIuaW52KEZyLnN1YihzaGlmdF90b19zbWFsbF9tLCBGci5vbmUpKTtcblxuICAgICAgICAgICAgICAgIGxldCBzSW52QWNjID0gRnIub25lO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxzbWFsbE07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSUxMDAwMCkgbG9nZ2VyLmRlYnVnKGBzZWN0aW9uTmFtZSBwcmVwYXJlIEwgY2FsYzogJHtzZWN0aW9uTmFtZX0sICR7aX0vJHtzbWFsbE19YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpID0gIGJ1ZmYuc2xpY2UoaSpzR2luLCAoaSsxKSpzR2luKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1pID0gYnVmZi5zbGljZSgoaStzbWFsbE0pKnNHaW4sIChpK3NtYWxsTSsxKSpzR2luKTtcblxuICAgICAgICAgICAgICAgICAgICB0MC5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRy5zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcudGltZXNGcih0aSAsIHNoaWZ0X3RvX3NtYWxsX20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bWlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZV9vdmVyX2Rlbm9tXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSpzR21pZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0MS5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRy5zdWIoIHRtaSwgdGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZyLm11bChzSW52QWNjLCBvbmVfb3Zlcl9kZW5vbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpKnNHbWlkXG4gICAgICAgICAgICAgICAgICAgICk7XG5cblxuICAgICAgICAgICAgICAgICAgICBzSW52QWNjID0gRnIubXVsKHNJbnZBY2MsIEZyLnNoaWZ0SW52KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdDAgPSBhd2FpdCBHLmlmZnQodDAsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiIHQwXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKHQwKTtcbiAgICAgICAgICAgICAgICB0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdDEgPSBhd2FpdCBHLmlmZnQodDEsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiIHQxXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKHQxKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQb3dlciB0b28gYmlnXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VyIHRvIGJpZ1wiKTtcbiAgICAgICAgICAgIH1cbiovXG4gICAgICAgIH1cblxuXG4gICAgfVxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_convert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_export_challenge.js":
/*!******************************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_export_challenge.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportChallenge)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n// Format of the outpu\n//     Hash of the last contribution  64Bytes\n//     2^N * 2 -1  TauG1 points (uncompressed)\n//     2^N  TauG2 Points (uncompressed)\n//     2^N  AlphaTauG1 Points (uncompressed)\n//     2^N  BetaTauG1 Points (uncompressed)\n//     BetaG2 (uncompressed)\n\n\n\n\n\n\n\nasync function exportChallenge(pTauFilename, challengeFilename, logger) {\n    const {fd: fdFrom, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdFrom, sections);\n\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readContributions(fdFrom, curve, sections);\n    let lastResponseHash, curChallengeHash;\n    if (contributions.length == 0) {\n        lastResponseHash = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 }).digest();\n        curChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateFirstChallengeHash(curve, power);\n    } else {\n        lastResponseHash = contributions[contributions.length-1].responseHash;\n        curChallengeHash = contributions[contributions.length-1].nextChallenge;\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(lastResponseHash, \"Last Response Hash: \"));\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(curChallengeHash, \"New Challenge Hash: \"));\n\n\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(challengeFilename);\n\n    const toHash = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n    await fdTo.write(lastResponseHash);\n    toHash.update(lastResponseHash);\n\n    await exportSection(2, \"G1\", (2 ** power) * 2 -1, \"tauG1\");\n    await exportSection(3, \"G2\", (2 ** power)       , \"tauG2\");\n    await exportSection(4, \"G1\", (2 ** power)       , \"alphaTauG1\");\n    await exportSection(5, \"G1\", (2 ** power)       , \"betaTauG1\");\n    await exportSection(6, \"G2\", 1                  , \"betaG2\");\n\n    await fdFrom.close();\n    await fdTo.close();\n\n    const calcCurChallengeHash = toHash.digest();\n\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_3__.hashIsEqual (curChallengeHash, calcCurChallengeHash)) {\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(calcCurChallengeHash, \"Calc Curret Challenge Hash: \"));\n\n        if (logger) logger.error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n        throw new Error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n    }\n\n    return curChallengeHash;\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startReadUniqueSection(fdFrom, sections, sectionId);\n        for (let i=0; i< nPoints; i+= nPointsChunk) {\n            if (logger) logger.debug(`Exporting ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n            let buff;\n            buff = await fdFrom.read(n*sG);\n            buff = await G.batchLEMtoU(buff);\n            await fdTo.write(buff);\n            toHash.update(buff);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endReadSection(fdFrom);\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfZXhwb3J0X2NoYWxsZW5nZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDVztBQUNBO0FBQ0k7QUFDbEI7O0FBRW5CO0FBQ2YsV0FBVyxzQkFBc0IsUUFBUSw0REFBd0I7O0FBRWpFLFdBQVcsY0FBYyxRQUFRLGlFQUFvQjs7QUFFckQsZ0NBQWdDLG9FQUF1QjtBQUN2RDtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFPLFVBQVUsV0FBVztBQUN2RCwyQkFBMkIsOEVBQWlDO0FBQzVELE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQyw0QkFBNEIsZ0RBQWU7OztBQUczQyx1QkFBdUIsb0RBQXVCOztBQUU5QyxtQkFBbUIsMERBQU8sVUFBVSxXQUFXO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsaURBQWdCO0FBQ3pCLGdDQUFnQyxnREFBZTs7QUFFL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsdUVBQW1DO0FBQ2pELHNCQUFzQixZQUFZO0FBQ2xDLGtEQUFrRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUEyQjtBQUN6Qzs7O0FBR0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfZXhwb3J0X2NoYWxsZW5nZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGb3JtYXQgb2YgdGhlIG91dHB1XG4vLyAgICAgSGFzaCBvZiB0aGUgbGFzdCBjb250cmlidXRpb24gIDY0Qnl0ZXNcbi8vICAgICAyXk4gKiAyIC0xICBUYXVHMSBwb2ludHMgKHVuY29tcHJlc3NlZClcbi8vICAgICAyXk4gIFRhdUcyIFBvaW50cyAodW5jb21wcmVzc2VkKVxuLy8gICAgIDJeTiAgQWxwaGFUYXVHMSBQb2ludHMgKHVuY29tcHJlc3NlZClcbi8vICAgICAyXk4gIEJldGFUYXVHMSBQb2ludHMgKHVuY29tcHJlc3NlZClcbi8vICAgICBCZXRhRzIgKHVuY29tcHJlc3NlZClcblxuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5pbXBvcnQgeyBibGFrZTJiIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvYmxha2UyYlwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGV4cG9ydENoYWxsZW5nZShwVGF1RmlsZW5hbWUsIGNoYWxsZW5nZUZpbGVuYW1lLCBsb2dnZXIpIHtcbiAgICBjb25zdCB7ZmQ6IGZkRnJvbSwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHBUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuXG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZEZyb20sIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnMgPSBhd2FpdCB1dGlscy5yZWFkQ29udHJpYnV0aW9ucyhmZEZyb20sIGN1cnZlLCBzZWN0aW9ucyk7XG4gICAgbGV0IGxhc3RSZXNwb25zZUhhc2gsIGN1ckNoYWxsZW5nZUhhc2g7XG4gICAgaWYgKGNvbnRyaWJ1dGlvbnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgbGFzdFJlc3BvbnNlSGFzaCA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pLmRpZ2VzdCgpO1xuICAgICAgICBjdXJDaGFsbGVuZ2VIYXNoID0gdXRpbHMuY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdFJlc3BvbnNlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ucmVzcG9uc2VIYXNoO1xuICAgICAgICBjdXJDaGFsbGVuZ2VIYXNoID0gY29udHJpYnV0aW9uc1tjb250cmlidXRpb25zLmxlbmd0aC0xXS5uZXh0Q2hhbGxlbmdlO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChsYXN0UmVzcG9uc2VIYXNoLCBcIkxhc3QgUmVzcG9uc2UgSGFzaDogXCIpKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjdXJDaGFsbGVuZ2VIYXNoLCBcIk5ldyBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuXG4gICAgY29uc3QgZmRUbyA9IGF3YWl0IGZhc3RGaWxlLmNyZWF0ZU92ZXJyaWRlKGNoYWxsZW5nZUZpbGVuYW1lKTtcblxuICAgIGNvbnN0IHRvSGFzaCA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIGF3YWl0IGZkVG8ud3JpdGUobGFzdFJlc3BvbnNlSGFzaCk7XG4gICAgdG9IYXNoLnVwZGF0ZShsYXN0UmVzcG9uc2VIYXNoKTtcblxuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oMiwgXCJHMVwiLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIpO1xuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oMywgXCJHMlwiLCAoMiAqKiBwb3dlcikgICAgICAgLCBcInRhdUcyXCIpO1xuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oNCwgXCJHMVwiLCAoMiAqKiBwb3dlcikgICAgICAgLCBcImFscGhhVGF1RzFcIik7XG4gICAgYXdhaXQgZXhwb3J0U2VjdGlvbig1LCBcIkcxXCIsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIpO1xuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oNiwgXCJHMlwiLCAxICAgICAgICAgICAgICAgICAgLCBcImJldGFHMlwiKTtcblxuICAgIGF3YWl0IGZkRnJvbS5jbG9zZSgpO1xuICAgIGF3YWl0IGZkVG8uY2xvc2UoKTtcblxuICAgIGNvbnN0IGNhbGNDdXJDaGFsbGVuZ2VIYXNoID0gdG9IYXNoLmRpZ2VzdCgpO1xuXG4gICAgaWYgKCFtaXNjLmhhc2hJc0VxdWFsIChjdXJDaGFsbGVuZ2VIYXNoLCBjYWxjQ3VyQ2hhbGxlbmdlSGFzaCkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGNhbGNDdXJDaGFsbGVuZ2VIYXNoLCBcIkNhbGMgQ3VycmV0IENoYWxsZW5nZSBIYXNoOiBcIikpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlBUYXUgZmlsZSBpcyBjb3JydXB0ZWQuIENhbGN1bGF0ZWQgbmV3IGNoYWxsZW5nZSBoYXNoIGRvZXMgbm90IG1hdGNoIHdpdGggdGhlIGVjbGFyZWQgb25lXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQVGF1IGZpbGUgaXMgY29ycnVwdGVkLiBDYWxjdWxhdGVkIG5ldyBjaGFsbGVuZ2UgaGFzaCBkb2VzIG5vdCBtYXRjaCB3aXRoIHRoZSBlY2xhcmVkIG9uZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VyQ2hhbGxlbmdlSGFzaDtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGV4cG9ydFNlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIG5Qb2ludHMsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkRnJvbSwgc2VjdGlvbnMsIHNlY3Rpb25JZCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSs9IG5Qb2ludHNDaHVuaykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBFeHBvcnRpbmcgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMtaSwgblBvaW50c0NodW5rKTtcbiAgICAgICAgICAgIGxldCBidWZmO1xuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IGZkRnJvbS5yZWFkKG4qc0cpO1xuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcuYmF0Y2hMRU10b1UoYnVmZik7XG4gICAgICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmYpO1xuICAgICAgICAgICAgdG9IYXNoLnVwZGF0ZShidWZmKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmRGcm9tKTtcbiAgICB9XG5cblxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_export_challenge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_export_json.js":
/*!*************************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_export_json.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportJson)\n/* harmony export */ });\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function exportJson(pTauFilename, verbose) {\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readPTauHeader(fd, sections);\n\n    const pTau = {};\n    pTau.q = curve.q;\n    pTau.power = power;\n    pTau.contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readContributions(fd, curve, sections);\n\n    pTau.tauG1 = await exportSection(2, \"G1\", (2 ** power)*2 -1, \"tauG1\");\n    pTau.tauG2 = await exportSection(3, \"G2\", (2 ** power), \"tauG2\");\n    pTau.alphaTauG1 = await exportSection(4, \"G1\", (2 ** power), \"alphaTauG1\");\n    pTau.betaTauG1 = await exportSection(5, \"G1\", (2 ** power), \"betaTauG1\");\n    pTau.betaG2 = await exportSection(6, \"G2\", 1, \"betaG2\");\n\n    pTau.lTauG1 = await exportLagrange(12, \"G1\", \"lTauG1\");\n    pTau.lTauG2 = await exportLagrange(13, \"G2\", \"lTauG2\");\n    pTau.lAlphaTauG1 = await exportLagrange(14, \"G1\", \"lAlphaTauG2\");\n    pTau.lBetaTauG1 = await exportLagrange(15, \"G1\", \"lBetaTauG2\");\n\n    await fd.close();\n\n    return (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.stringifyBigIntsWithField)(curve.Fr, pTau);\n\n\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, sectionId);\n        for (let i=0; i< nPoints; i++) {\n            if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ` + i);\n            const buff = await fd.read(sG);\n            res.push(G.fromRprLEM(buff, 0));\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n        return res;\n    }\n\n    async function exportLagrange(sectionId, groupName, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, sectionId);\n        for (let p=0; p<=power; p++) {\n            if (verbose) console.log(`${sectionName}: Power: ${p}`);\n            res[p] = [];\n            const nPoints = (2 ** p);\n            for (let i=0; i<nPoints; i++) {\n                if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ${i}/${nPoints}`);\n                const buff = await fd.read(sG);\n                res[p].push(G.fromRprLEM(buff, 0));\n            }\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd, true);\n        return res;\n    }\n\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfZXhwb3J0X2pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWdEO0FBQ0k7QUFDRTs7QUFFdkM7QUFDZixXQUFXLGNBQWMsUUFBUSw0REFBd0I7O0FBRXpELFdBQVcsY0FBYyxRQUFRLGlFQUFvQjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9FQUF1Qjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLG1FQUF5Qjs7OztBQUlwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHVFQUFtQztBQUNqRCxzQkFBc0IsWUFBWTtBQUNsQyw2REFBNkQsWUFBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUEyQjs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHVFQUFtQztBQUNqRCxzQkFBc0IsVUFBVTtBQUNoQyx3Q0FBd0MsWUFBWSxXQUFXLEVBQUU7QUFDakU7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDLGlFQUFpRSxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUEyQjtBQUN6QztBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9leHBvcnRfanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgeyBzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBleHBvcnRKc29uKHBUYXVGaWxlbmFtZSwgdmVyYm9zZSkge1xuICAgIGNvbnN0IHtmZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHBUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuXG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZCwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgcFRhdSA9IHt9O1xuICAgIHBUYXUucSA9IGN1cnZlLnE7XG4gICAgcFRhdS5wb3dlciA9IHBvd2VyO1xuICAgIHBUYXUuY29udHJpYnV0aW9ucyA9IGF3YWl0IHV0aWxzLnJlYWRDb250cmlidXRpb25zKGZkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuXG4gICAgcFRhdS50YXVHMSA9IGF3YWl0IGV4cG9ydFNlY3Rpb24oMiwgXCJHMVwiLCAoMiAqKiBwb3dlcikqMiAtMSwgXCJ0YXVHMVwiKTtcbiAgICBwVGF1LnRhdUcyID0gYXdhaXQgZXhwb3J0U2VjdGlvbigzLCBcIkcyXCIsICgyICoqIHBvd2VyKSwgXCJ0YXVHMlwiKTtcbiAgICBwVGF1LmFscGhhVGF1RzEgPSBhd2FpdCBleHBvcnRTZWN0aW9uKDQsIFwiRzFcIiwgKDIgKiogcG93ZXIpLCBcImFscGhhVGF1RzFcIik7XG4gICAgcFRhdS5iZXRhVGF1RzEgPSBhd2FpdCBleHBvcnRTZWN0aW9uKDUsIFwiRzFcIiwgKDIgKiogcG93ZXIpLCBcImJldGFUYXVHMVwiKTtcbiAgICBwVGF1LmJldGFHMiA9IGF3YWl0IGV4cG9ydFNlY3Rpb24oNiwgXCJHMlwiLCAxLCBcImJldGFHMlwiKTtcblxuICAgIHBUYXUubFRhdUcxID0gYXdhaXQgZXhwb3J0TGFncmFuZ2UoMTIsIFwiRzFcIiwgXCJsVGF1RzFcIik7XG4gICAgcFRhdS5sVGF1RzIgPSBhd2FpdCBleHBvcnRMYWdyYW5nZSgxMywgXCJHMlwiLCBcImxUYXVHMlwiKTtcbiAgICBwVGF1LmxBbHBoYVRhdUcxID0gYXdhaXQgZXhwb3J0TGFncmFuZ2UoMTQsIFwiRzFcIiwgXCJsQWxwaGFUYXVHMlwiKTtcbiAgICBwVGF1LmxCZXRhVGF1RzEgPSBhd2FpdCBleHBvcnRMYWdyYW5nZSgxNSwgXCJHMVwiLCBcImxCZXRhVGF1RzJcIik7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQoY3VydmUuRnIsIHBUYXUpO1xuXG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGV4cG9ydFNlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIG5Qb2ludHMsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIHNlY3Rpb25JZCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKHZlcmJvc2UpJiZpJiYoaSUxMDAwMCA9PSAwKSkgY29uc29sZS5sb2coYCR7c2VjdGlvbk5hbWV9OiBgICsgaSk7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRyk7XG4gICAgICAgICAgICByZXMucHVzaChHLmZyb21ScHJMRU0oYnVmZiwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBleHBvcnRMYWdyYW5nZShzZWN0aW9uSWQsIGdyb3VwTmFtZSwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgc2VjdGlvbklkKTtcbiAgICAgICAgZm9yIChsZXQgcD0wOyBwPD1wb3dlcjsgcCsrKSB7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSkgY29uc29sZS5sb2coYCR7c2VjdGlvbk5hbWV9OiBQb3dlcjogJHtwfWApO1xuICAgICAgICAgICAgcmVzW3BdID0gW107XG4gICAgICAgICAgICBjb25zdCBuUG9pbnRzID0gKDIgKiogcCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh2ZXJib3NlKSYmaSYmKGklMTAwMDAgPT0gMCkpIGNvbnNvbGUubG9nKGAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoc0cpO1xuICAgICAgICAgICAgICAgIHJlc1twXS5wdXNoKEcuZnJvbVJwckxFTShidWZmLCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_export_json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_import.js":
/*!********************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_import.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ importResponse)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger) {\n\n    const noHash = new Uint8Array(64);\n    for (let i=0; i<64; i++) noHash[i] = 0xFF;\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readContributions(fdOld, curve, sections);\n    const currentContribution = {};\n\n    if (name) currentContribution.name = name;\n\n    const sG1 = curve.F1.n8*2;\n    const scG1 = curve.F1.n8; // Compressed size\n    const sG2 = curve.F2.n8*2;\n    const scG2 = curve.F2.n8; // Compressed size\n\n    const fdResponse = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(contributionFilename);\n\n    if  (fdResponse.totalSize !=\n        64 +                            // Old Hash\n        ((2 ** power)*2-1)*scG1 +\n        (2 ** power)*scG2 +\n        (2 ** power)*scG1 +\n        (2 ** power)*scG1 +\n        scG2 +\n        sG1*6 + sG2*3)\n        throw new Error(\"Size of the contribution is invalid\");\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile(newPTauFilename, \"ptau\", 1, importPoints ? 7: 2);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    const contributionPreviousHash = await fdResponse.read(64);\n\n    if (_misc_js__WEBPACK_IMPORTED_MODULE_3__.hashIsEqual(noHash,lastChallengeHash)) {\n        lastChallengeHash = contributionPreviousHash;\n        contributions[contributions.length-1].nextChallenge = lastChallengeHash;\n    }\n\n    if(!_misc_js__WEBPACK_IMPORTED_MODULE_3__.hashIsEqual(contributionPreviousHash,lastChallengeHash))\n        throw new Error(\"Wrong contribution. This contribution is not based on the previous hash\");\n\n    const hasherResponse = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n    hasherResponse.update(contributionPreviousHash);\n\n    const startSections = [];\n    let res;\n    res = await processSection(fdResponse, fdNew, \"G1\", 2, (2 ** power) * 2 -1, [1], \"tauG1\");\n    currentContribution.tauG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 3, (2 ** power)       , [1], \"tauG2\");\n    currentContribution.tauG2 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 4, (2 ** power)       , [0], \"alphaG1\");\n    currentContribution.alphaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 5, (2 ** power)       , [0], \"betaG1\");\n    currentContribution.betaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 6, 1                  , [0], \"betaG2\");\n    currentContribution.betaG2 = res[0];\n\n    currentContribution.partialHash = _misc_js__WEBPACK_IMPORTED_MODULE_3__.toPartialHash(hasherResponse);\n\n\n    const buffKey = await fdResponse.read(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    currentContribution.key = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.fromPtauPubKeyRpr(buffKey, 0, curve, false);\n\n    hasherResponse.update(new Uint8Array(buffKey));\n    const hashResponse = hasherResponse.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    if (importPoints) {\n        const nextChallengeHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n        nextChallengeHasher.update(hashResponse);\n\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n        currentContribution.nextChallenge = nextChallengeHasher.digest();\n\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(currentContribution.nextChallenge, \"Next Challenge Hash: \"));\n    } else {\n        currentContribution.nextChallenge = noHash;\n    }\n\n    contributions.push(currentContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeContributions(fdNew, curve, contributions);\n\n    await fdResponse.close();\n    await fdNew.close();\n    await fdOld.close();\n\n    return currentContribution.nextChallenge;\n\n    async function processSection(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n        if (importPoints) {\n            return await processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        } else {\n            return await processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        }\n    }\n\n    async function processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n        const sG = G.F.n8*2;\n\n        const singularPoints = [];\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection(fdTo, sectionId);\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        startSections[sectionId] = fdTo.pos;\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            const buffLEM = await G.batchCtoLEM(buffC);\n\n            await fdTo.write(buffLEM);\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(buffLEM, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection(fdTo);\n\n        return singularPoints;\n    }\n\n\n    async function processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n\n        const singularPoints = [];\n\n        const nPointsChunk = Math.floor((1<<24)/scG);\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprCompressed(buffC, (sp-i)*scG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        return singularPoints;\n    }\n\n\n    async function hashSection(nextChallengeHasher, fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfaW1wb3J0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ1c7QUFDQTtBQUNJO0FBQ2xCOztBQUVuQjs7QUFFZjtBQUNBLGtCQUFrQixNQUFNOztBQUV4QixXQUFXLHFCQUFxQixRQUFRLDREQUF3QjtBQUNoRSxXQUFXLGNBQWMsUUFBUSxpRUFBb0I7QUFDckQsZ0NBQWdDLG9FQUF1QjtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4Qjs7QUFFOUIsNkJBQTZCLGtEQUFxQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEJBQTRCLDhFQUFpQztBQUM3RDs7QUFFQSx3QkFBd0IsOERBQTBCO0FBQ2xELFVBQVUsa0VBQXFCOztBQUUvQjs7QUFFQSxRQUFRLGlEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxpREFBZ0I7QUFDeEI7O0FBRUEsMkJBQTJCLDBEQUFPLFVBQVUsV0FBVztBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLG1EQUFrQjs7O0FBR3hEOztBQUVBLDhCQUE4QixvRUFBdUI7O0FBRXJEO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBLG9DQUFvQywwREFBTyxVQUFVLFdBQVc7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsZ0RBQWU7QUFDL0MsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSxxRUFBd0I7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLGtFQUE4QjtBQUM1Qzs7QUFFQTs7QUFFQSxzQkFBc0IsWUFBWTtBQUNsQyxrREFBa0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQy9FOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0VBQTRCOztBQUUxQztBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDLGtEQUFrRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDL0U7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDLGdEQUFnRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDN0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2ltcG9ydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0UmVzcG9uc2Uob2xkUHRhdUZpbGVuYW1lLCBjb250cmlidXRpb25GaWxlbmFtZSwgbmV3UFRhdUZpbGVuYW1lLCBuYW1lLCBpbXBvcnRQb2ludHMsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qgbm9IYXNoID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgIGZvciAobGV0IGk9MDsgaTw2NDsgaSsrKSBub0hhc2hbaV0gPSAweEZGO1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKG9sZFB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcbiAgICBjb25zdCBjb250cmlidXRpb25zID0gYXdhaXQgdXRpbHMucmVhZENvbnRyaWJ1dGlvbnMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY3VycmVudENvbnRyaWJ1dGlvbiA9IHt9O1xuXG4gICAgaWYgKG5hbWUpIGN1cnJlbnRDb250cmlidXRpb24ubmFtZSA9IG5hbWU7XG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5GMS5uOCoyO1xuICAgIGNvbnN0IHNjRzEgPSBjdXJ2ZS5GMS5uODsgLy8gQ29tcHJlc3NlZCBzaXplXG4gICAgY29uc3Qgc0cyID0gY3VydmUuRjIubjgqMjtcbiAgICBjb25zdCBzY0cyID0gY3VydmUuRjIubjg7IC8vIENvbXByZXNzZWQgc2l6ZVxuXG4gICAgY29uc3QgZmRSZXNwb25zZSA9IGF3YWl0IGZhc3RGaWxlLnJlYWRFeGlzdGluZyhjb250cmlidXRpb25GaWxlbmFtZSk7XG5cbiAgICBpZiAgKGZkUmVzcG9uc2UudG90YWxTaXplICE9XG4gICAgICAgIDY0ICsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2xkIEhhc2hcbiAgICAgICAgKCgyICoqIHBvd2VyKSoyLTEpKnNjRzEgK1xuICAgICAgICAoMiAqKiBwb3dlcikqc2NHMiArXG4gICAgICAgICgyICoqIHBvd2VyKSpzY0cxICtcbiAgICAgICAgKDIgKiogcG93ZXIpKnNjRzEgK1xuICAgICAgICBzY0cyICtcbiAgICAgICAgc0cxKjYgKyBzRzIqMylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBvZiB0aGUgY29udHJpYnV0aW9uIGlzIGludmFsaWRcIik7XG5cbiAgICBsZXQgbGFzdENoYWxsZW5nZUhhc2g7XG5cbiAgICBpZiAoY29udHJpYnV0aW9ucy5sZW5ndGg+MCkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IHV0aWxzLmNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZShuZXdQVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxLCBpbXBvcnRQb2ludHMgPyA3OiAyKTtcbiAgICBhd2FpdCB1dGlscy53cml0ZVBUYXVIZWFkZXIoZmROZXcsIGN1cnZlLCBwb3dlcik7XG5cbiAgICBjb25zdCBjb250cmlidXRpb25QcmV2aW91c0hhc2ggPSBhd2FpdCBmZFJlc3BvbnNlLnJlYWQoNjQpO1xuXG4gICAgaWYgKG1pc2MuaGFzaElzRXF1YWwobm9IYXNoLGxhc3RDaGFsbGVuZ2VIYXNoKSkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvblByZXZpb3VzSGFzaDtcbiAgICAgICAgY29udHJpYnV0aW9uc1tjb250cmlidXRpb25zLmxlbmd0aC0xXS5uZXh0Q2hhbGxlbmdlID0gbGFzdENoYWxsZW5nZUhhc2g7XG4gICAgfVxuXG4gICAgaWYoIW1pc2MuaGFzaElzRXF1YWwoY29udHJpYnV0aW9uUHJldmlvdXNIYXNoLGxhc3RDaGFsbGVuZ2VIYXNoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgY29udHJpYnV0aW9uLiBUaGlzIGNvbnRyaWJ1dGlvbiBpcyBub3QgYmFzZWQgb24gdGhlIHByZXZpb3VzIGhhc2hcIik7XG5cbiAgICBjb25zdCBoYXNoZXJSZXNwb25zZSA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIGhhc2hlclJlc3BvbnNlLnVwZGF0ZShjb250cmlidXRpb25QcmV2aW91c0hhc2gpO1xuXG4gICAgY29uc3Qgc3RhcnRTZWN0aW9ucyA9IFtdO1xuICAgIGxldCByZXM7XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzFcIiwgMiwgKDIgKiogcG93ZXIpICogMiAtMSwgWzFdLCBcInRhdUcxXCIpO1xuICAgIGN1cnJlbnRDb250cmlidXRpb24udGF1RzEgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgWzFdLCBcInRhdUcyXCIpO1xuICAgIGN1cnJlbnRDb250cmlidXRpb24udGF1RzIgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzFcIiwgNCwgKDIgKiogcG93ZXIpICAgICAgICwgWzBdLCBcImFscGhhRzFcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5hbHBoYUcxID0gcmVzWzBdO1xuICAgIHJlcyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKGZkUmVzcG9uc2UsIGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFswXSwgXCJiZXRhRzFcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5iZXRhRzEgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgWzBdLCBcImJldGFHMlwiKTtcbiAgICBjdXJyZW50Q29udHJpYnV0aW9uLmJldGFHMiA9IHJlc1swXTtcblxuICAgIGN1cnJlbnRDb250cmlidXRpb24ucGFydGlhbEhhc2ggPSBtaXNjLnRvUGFydGlhbEhhc2goaGFzaGVyUmVzcG9uc2UpO1xuXG5cbiAgICBjb25zdCBidWZmS2V5ID0gYXdhaXQgZmRSZXNwb25zZS5yZWFkKGN1cnZlLkYxLm44KjIqNitjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5rZXkgPSB1dGlscy5mcm9tUHRhdVB1YktleVJwcihidWZmS2V5LCAwLCBjdXJ2ZSwgZmFsc2UpO1xuXG4gICAgaGFzaGVyUmVzcG9uc2UudXBkYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZLZXkpKTtcbiAgICBjb25zdCBoYXNoUmVzcG9uc2UgPSBoYXNoZXJSZXNwb25zZS5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChoYXNoUmVzcG9uc2UsIFwiQ29udHJpYnV0aW9uIFJlc3BvbnNlIEhhc2ggaW1wb3J0ZWQ6IFwiKSk7XG5cbiAgICBpZiAoaW1wb3J0UG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IG5leHRDaGFsbGVuZ2VIYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTtcbiAgICAgICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoaGFzaFJlc3BvbnNlKTtcblxuICAgICAgICBhd2FpdCBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcyXCIsIDMsICgyICoqIHBvd2VyKSAgICAgICAsIFwidGF1RzJcIiwgbG9nZ2VyKTtcbiAgICAgICAgYXdhaXQgaGFzaFNlY3Rpb24obmV4dENoYWxsZW5nZUhhc2hlciwgZmROZXcsIFwiRzFcIiwgNCwgKDIgKiogcG93ZXIpICAgICAgICwgXCJhbHBoYVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcyXCIsIDYsIDEgICAgICAgICAgICAgICAgICAsIFwiYmV0YUcyXCIsIGxvZ2dlcik7XG5cbiAgICAgICAgY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbmV4dENoYWxsZW5nZUhhc2hlci5kaWdlc3QoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlLCBcIk5leHQgQ2hhbGxlbmdlIEhhc2g6IFwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbm9IYXNoO1xuICAgIH1cblxuICAgIGNvbnRyaWJ1dGlvbnMucHVzaChjdXJyZW50Q29udHJpYnV0aW9uKTtcblxuICAgIGF3YWl0IHV0aWxzLndyaXRlQ29udHJpYnV0aW9ucyhmZE5ldywgY3VydmUsIGNvbnRyaWJ1dGlvbnMpO1xuXG4gICAgYXdhaXQgZmRSZXNwb25zZS5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcblxuICAgIHJldHVybiBjdXJyZW50Q29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2U7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihmZEZyb20sIGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzaW5ndWxhclBvaW50SW5kZXhlcywgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKGltcG9ydFBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NTZWN0aW9uSW1wb3J0UG9pbnRzKGZkRnJvbSwgZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNpbmd1bGFyUG9pbnRJbmRleGVzLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc1NlY3Rpb25Ob0ltcG9ydFBvaW50cyhmZEZyb20sIGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzaW5ndWxhclBvaW50SW5kZXhlcywgc2VjdGlvbk5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb25JbXBvcnRQb2ludHMoZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNjRyA9IEcuRi5uODtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcblxuICAgICAgICBjb25zdCBzaW5ndWxhclBvaW50cyA9IFtdO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFRvLCBzZWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXSA9IGZkVG8ucG9zO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSW1wb3J0aW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDID0gYXdhaXQgZmRGcm9tLnJlYWQobiAqIHNjRyk7XG4gICAgICAgICAgICBoYXNoZXJSZXNwb25zZS51cGRhdGUoYnVmZkMpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmTEVNID0gYXdhaXQgRy5iYXRjaEN0b0xFTShidWZmQyk7XG5cbiAgICAgICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZkxFTSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8c2luZ3VsYXJQb2ludEluZGV4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcCA9IHNpbmd1bGFyUG9pbnRJbmRleGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICgoc3AgPj1pKSAmJiAoc3AgPCBpK24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJMRU0oYnVmZkxFTSwgKHNwLWkpKnNHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkVG8pO1xuXG4gICAgICAgIHJldHVybiBzaW5ndWxhclBvaW50cztcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uTm9JbXBvcnRQb2ludHMoZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNjRyA9IEcuRi5uODtcblxuICAgICAgICBjb25zdCBzaW5ndWxhclBvaW50cyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zY0cpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSW1wb3J0aW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDID0gYXdhaXQgZmRGcm9tLnJlYWQobiAqIHNjRyk7XG4gICAgICAgICAgICBoYXNoZXJSZXNwb25zZS51cGRhdGUoYnVmZkMpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8c2luZ3VsYXJQb2ludEluZGV4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcCA9IHNpbmd1bGFyUG9pbnRJbmRleGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICgoc3AgPj1pKSAmJiAoc3AgPCBpK24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJDb21wcmVzc2VkKGJ1ZmZDLCAoc3AtaSkqc2NHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2luZ3VsYXJQb2ludHM7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIGNvbnN0IG9sZFBvcyA9IGZkVG8ucG9zO1xuICAgICAgICBmZFRvLnBvcyA9IHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkgKz0gblBvaW50c0NodW5rKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEhhc2hpbmcgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMtaSwgblBvaW50c0NodW5rKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZkxFTSA9IGF3YWl0IGZkVG8ucmVhZChuICogc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmVSA9IGF3YWl0IEcuYmF0Y2hMRU10b1UoYnVmZkxFTSk7XG5cbiAgICAgICAgICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGJ1ZmZVKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZkVG8ucG9zID0gb2xkUG9zO1xuICAgIH1cblxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_import.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_new.js":
/*!*****************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_new.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ newAccumulator)\n/* harmony export */ });\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\nHeader(1)\n    n8\n    prime\n    power\ntauG1(2)\n    {(2 ** power)*2-1} [\n        G1, tau*G1, tau^2 * G1, ....\n    ]\ntauG2(3)\n    {2 ** power}[\n        G2, tau*G2, tau^2 * G2, ...\n    ]\nalphaTauG1(4)\n    {2 ** power}[\n        alpha*G1, alpha*tau*G1, alpha*tau^2*G1,....\n    ]\nbetaTauG1(5)\n    {2 ** power} []\n        beta*G1, beta*tau*G1, beta*tau^2*G1, ....\n    ]\nbetaG2(6)\n    {1}[\n        beta*G2\n    ]\ncontributions(7)\n    NContributions\n    {NContributions}[\n        tau*G1\n        tau*G2\n        alpha*G1\n        beta*G1\n        beta*G2\n        pubKey\n            tau_g1s\n            tau_g1sx\n            tau_g2spx\n            alpha_g1s\n            alpha_g1sx\n            alpha_g1spx\n            beta_g1s\n            beta_g1sx\n            beta_g1spx\n        partialHash (216 bytes) See https://github.com/mafintosh/blake2b-wasm/blob/23bee06945806309977af802bc374727542617c7/blake2b.wat#L9\n        hashNewChallenge\n    ]\n */\n\n\n\n\n\n\nasync function newAccumulator(curve, power, fileName, logger) {\n\n    const fd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(fileName, \"ptau\", 1, 7);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writePTauHeader(fd, curve, power, 0);\n\n    const buffG1 = curve.G1.oneAffine;\n    const buffG2 = curve.G2.oneAffine;\n\n    // Write tauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    const nTauG1 = (2 ** power) * 2 -1;\n    for (let i=0; i< nTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write tauG2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 3);\n    const nTauG2 = (2 ** power);\n    for (let i=0; i< nTauG2; i++) {\n        await fd.write(buffG2);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG2: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write alphaTauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 4);\n    const nAlfaTauG1 = (2 ** power);\n    for (let i=0; i< nAlfaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"alphaTauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write betaTauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 5);\n    const nBetaTauG1 = (2 ** power);\n    for (let i=0; i< nBetaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"betaTauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write betaG2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 6);\n    await fd.write(buffG2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Contributions\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 7);\n    await fd.writeULE32(0); // 0 Contributions\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await fd.close();\n\n    const firstChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.calculateFirstChallengeHash(curve, power, logger);\n\n    if (logger) logger.debug(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(_noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_3__.blake2b.create({ dkLen: 64 }).digest(), \"Blank Contribution Hash:\"));\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(firstChallengeHash, \"First Contribution Hash:\"));\n\n    return firstChallengeHash;\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfbmV3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGtCQUFrQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLLFdBQVc7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSyxXQUFXO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEtBQUssWUFBWTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZUFBZTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDQTtBQUNKO0FBQ2Q7O0FBRW5COztBQUVmLHFCQUFxQiw4REFBMEI7O0FBRS9DLFVBQVUsa0VBQXlCOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOztBQUV0QztBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOztBQUV0QztBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLDRCQUE0QjtBQUM1QixVQUFVLGdFQUE0Qjs7QUFFdEM7O0FBRUEsK0JBQStCLDhFQUFxQzs7QUFFcEUsNkJBQTZCLGdEQUFlLENBQUMsMERBQU8sVUFBVSxXQUFXOztBQUV6RSw0QkFBNEIsZ0RBQWU7O0FBRTNDOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X25ldy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKlxuSGVhZGVyKDEpXG4gICAgbjhcbiAgICBwcmltZVxuICAgIHBvd2VyXG50YXVHMSgyKVxuICAgIHsoMiAqKiBwb3dlcikqMi0xfSBbXG4gICAgICAgIEcxLCB0YXUqRzEsIHRhdV4yICogRzEsIC4uLi5cbiAgICBdXG50YXVHMigzKVxuICAgIHsyICoqIHBvd2VyfVtcbiAgICAgICAgRzIsIHRhdSpHMiwgdGF1XjIgKiBHMiwgLi4uXG4gICAgXVxuYWxwaGFUYXVHMSg0KVxuICAgIHsyICoqIHBvd2VyfVtcbiAgICAgICAgYWxwaGEqRzEsIGFscGhhKnRhdSpHMSwgYWxwaGEqdGF1XjIqRzEsLi4uLlxuICAgIF1cbmJldGFUYXVHMSg1KVxuICAgIHsyICoqIHBvd2VyfSBbXVxuICAgICAgICBiZXRhKkcxLCBiZXRhKnRhdSpHMSwgYmV0YSp0YXVeMipHMSwgLi4uLlxuICAgIF1cbmJldGFHMig2KVxuICAgIHsxfVtcbiAgICAgICAgYmV0YSpHMlxuICAgIF1cbmNvbnRyaWJ1dGlvbnMoNylcbiAgICBOQ29udHJpYnV0aW9uc1xuICAgIHtOQ29udHJpYnV0aW9uc31bXG4gICAgICAgIHRhdSpHMVxuICAgICAgICB0YXUqRzJcbiAgICAgICAgYWxwaGEqRzFcbiAgICAgICAgYmV0YSpHMVxuICAgICAgICBiZXRhKkcyXG4gICAgICAgIHB1YktleVxuICAgICAgICAgICAgdGF1X2cxc1xuICAgICAgICAgICAgdGF1X2cxc3hcbiAgICAgICAgICAgIHRhdV9nMnNweFxuICAgICAgICAgICAgYWxwaGFfZzFzXG4gICAgICAgICAgICBhbHBoYV9nMXN4XG4gICAgICAgICAgICBhbHBoYV9nMXNweFxuICAgICAgICAgICAgYmV0YV9nMXNcbiAgICAgICAgICAgIGJldGFfZzFzeFxuICAgICAgICAgICAgYmV0YV9nMXNweFxuICAgICAgICBwYXJ0aWFsSGFzaCAoMjE2IGJ5dGVzKSBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9ibGFrZTJiLXdhc20vYmxvYi8yM2JlZTA2OTQ1ODA2MzA5OTc3YWY4MDJiYzM3NDcyNzU0MjYxN2M3L2JsYWtlMmIud2F0I0w5XG4gICAgICAgIGhhc2hOZXdDaGFsbGVuZ2VcbiAgICBdXG4gKi9cblxuaW1wb3J0ICogYXMgcHRhdVV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gbmV3QWNjdW11bGF0b3IoY3VydmUsIHBvd2VyLCBmaWxlTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBmZCA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKGZpbGVOYW1lLCBcInB0YXVcIiwgMSwgNyk7XG5cbiAgICBhd2FpdCBwdGF1VXRpbHMud3JpdGVQVGF1SGVhZGVyKGZkLCBjdXJ2ZSwgcG93ZXIsIDApO1xuXG4gICAgY29uc3QgYnVmZkcxID0gY3VydmUuRzEub25lQWZmaW5lO1xuICAgIGNvbnN0IGJ1ZmZHMiA9IGN1cnZlLkcyLm9uZUFmZmluZTtcblxuICAgIC8vIFdyaXRlIHRhdUcxXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDIpO1xuICAgIGNvbnN0IG5UYXVHMSA9ICgyICoqIHBvd2VyKSAqIDIgLTE7XG4gICAgZm9yIChsZXQgaT0wOyBpPCBuVGF1RzE7IGkrKykge1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgICAgICBpZiAoKGxvZ2dlcikmJigoaSUxMDAwMDApID09IDApJiZpKSBsb2dnZXIubG9nKFwidGF1RzE6IFwiICsgaSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgdGF1RzJcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMyk7XG4gICAgY29uc3QgblRhdUcyID0gKDIgKiogcG93ZXIpO1xuICAgIGZvciAobGV0IGk9MDsgaTwgblRhdUcyOyBpKyspIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUoYnVmZkcyKTtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoKGklMTAwMDAwKSA9PSAwKSYmaSkgbG9nZ2VyLmxvZyhcInRhdUcyOiBcIiArIGkpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIGFscGhhVGF1RzFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNCk7XG4gICAgY29uc3QgbkFsZmFUYXVHMSA9ICgyICoqIHBvd2VyKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IG5BbGZhVGF1RzE7IGkrKykge1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgICAgICBpZiAoKGxvZ2dlcikmJigoaSUxMDAwMDApID09IDApJiZpKSBsb2dnZXIubG9nKFwiYWxwaGFUYXVHMTogXCIgKyBpKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSBiZXRhVGF1RzFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNSk7XG4gICAgY29uc3QgbkJldGFUYXVHMSA9ICgyICoqIHBvd2VyKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IG5CZXRhVGF1RzE7IGkrKykge1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgICAgICBpZiAoKGxvZ2dlcikmJigoaSUxMDAwMDApID09IDApJiZpKSBsb2dnZXIubG9nKFwiYmV0YVRhdUcxOiBcIiArIGkpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIGJldGFHMlxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA2KTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmRzIpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gQ29udHJpYnV0aW9uc1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA3KTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDApOyAvLyAwIENvbnRyaWJ1dGlvbnNcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICBjb25zdCBmaXJzdENoYWxsZW5nZUhhc2ggPSBwdGF1VXRpbHMuY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlciwgbG9nZ2VyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhtaXNjLmZvcm1hdEhhc2goYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSkuZGlnZXN0KCksIFwiQmxhbmsgQ29udHJpYnV0aW9uIEhhc2g6XCIpKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChmaXJzdENoYWxsZW5nZUhhc2gsIFwiRmlyc3QgQ29udHJpYnV0aW9uIEhhc2g6XCIpKTtcblxuICAgIHJldHVybiBmaXJzdENoYWxsZW5nZUhhc2g7XG5cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_new.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_preparephase2.js":
/*!***************************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_preparephase2.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ preparePhase2)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function preparePhase2(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await processSection(3, 13, \"G2\", \"tauG2\" );\n    await processSection(4, 14, \"G1\", \"alphaTauG1\" );\n    await processSection(5, 15, \"G1\", \"betaTauG1\" );\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, newSectionId);\n\n        for (let p=0; p<=power; p++) {\n            await processSectionPower(p);\n        }\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const Fr = curve.Fr;\n            const sGin = G.F.n8*2;\n            const sGmid = G.F.n8*3;\n\n            let buff;\n            buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_2__.BigBuffer(nPoints*sGin);\n\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld, true);\n\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfcHJlcGFyZXBoYXNlMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDSjtBQUNUOztBQUV4Qjs7QUFFZixXQUFXLHFCQUFxQixRQUFRLDREQUF3QjtBQUNoRSxXQUFXLGNBQWMsUUFBUSxpRUFBb0I7O0FBRXJELHdCQUF3Qiw4REFBMEI7QUFDbEQsVUFBVSxrRUFBcUI7O0FBRS9CLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCO0FBQ2xDLFVBQVUsNERBQXdCOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxrRUFBOEI7O0FBRTVDLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0VBQTRCOzs7QUFHMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1EQUFTOztBQUVoQyxrQkFBa0IsdUVBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7O0FBRzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9wcmVwYXJlcGhhc2UyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCB7QmlnQnVmZmVyfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVQaGFzZTIob2xkUHRhdUZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKG9sZFB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUobmV3UFRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSwgMTEpO1xuICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMyk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDQpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNik7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDcpO1xuXG4gICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgMTIsIFwiRzFcIiwgXCJ0YXVHMVwiICk7XG4gICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMywgMTMsIFwiRzJcIiwgXCJ0YXVHMlwiICk7XG4gICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNCwgMTQsIFwiRzFcIiwgXCJhbHBoYVRhdUcxXCIgKTtcbiAgICBhd2FpdCBwcm9jZXNzU2VjdGlvbig1LCAxNSwgXCJHMVwiLCBcImJldGFUYXVHMVwiICk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICAvLyBhd2FpdCBmcy5wcm9taXNlcy51bmxpbmsobmV3UFRhdUZpbGVuYW1lKyBcIi50bXBcIik7XG5cbiAgICByZXR1cm47XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihvbGRTZWN0aW9uSWQsIG5ld1NlY3Rpb25JZCwgR3N0ciwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiU3RhcnRpbmcgc2VjdGlvbjogXCIrc2VjdGlvbk5hbWUpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgbmV3U2VjdGlvbklkKTtcblxuICAgICAgICBmb3IgKGxldCBwPTA7IHA8PXBvd2VyOyBwKyspIHtcbiAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uUG93ZXIocCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2xkU2VjdGlvbklkID09IDIpIHtcbiAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uUG93ZXIocG93ZXIrMSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcblxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uUG93ZXIocCkge1xuICAgICAgICAgICAgY29uc3QgblBvaW50cyA9IDIgKiogcDtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtHc3RyXTtcbiAgICAgICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgICAgICBjb25zdCBzR2luID0gRy5GLm44KjI7XG4gICAgICAgICAgICBjb25zdCBzR21pZCA9IEcuRi5uOCozO1xuXG4gICAgICAgICAgICBsZXQgYnVmZjtcbiAgICAgICAgICAgIGJ1ZmYgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0dpbik7XG5cbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgb2xkU2VjdGlvbklkKTtcbiAgICAgICAgICAgIGlmICgob2xkU2VjdGlvbklkID09IDIpJiYocD09cG93ZXIrMSkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE9sZC5yZWFkVG9CdWZmZXIoYnVmZiwgMCwoblBvaW50cy0xKSpzR2luICk7XG4gICAgICAgICAgICAgICAgYnVmZi5zZXQoY3VydmUuRzEuemVyb0FmZmluZSwgKG5Qb2ludHMtMSkqc0dpbiApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE9sZC5yZWFkVG9CdWZmZXIoYnVmZiwgMCxuUG9pbnRzKnNHaW4gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZE9sZCwgdHJ1ZSk7XG5cblxuICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcubGFncmFuZ2VFdmFsdWF0aW9ucyhidWZmLCBcImFmZmluZVwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuXG4vKlxuICAgICAgICAgICAgaWYgKHAgPD0gY3VydmUuRnIucykge1xuICAgICAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmlmZnQoYnVmZiwgXCJhZmZpbmVcIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAgPT0gY3VydmUuRnIucysxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc21hbGxNID0gMTw8Y3VydmUuRnIucztcbiAgICAgICAgICAgICAgICBsZXQgdDAgPSBuZXcgQmlnQnVmZmVyKCBzbWFsbE0gKiBzR21pZCApO1xuICAgICAgICAgICAgICAgIGxldCB0MSA9IG5ldyBCaWdCdWZmZXIoIHNtYWxsTSAqIHNHbWlkICk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaGlmdF90b19zbWFsbF9tID0gRnIuZXhwKEZyLnNoaWZ0LCBzbWFsbE0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uZV9vdmVyX2Rlbm9tID0gRnIuaW52KEZyLnN1YihzaGlmdF90b19zbWFsbF9tLCBGci5vbmUpKTtcblxuICAgICAgICAgICAgICAgIGxldCBzSW52QWNjID0gRnIub25lO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxzbWFsbE07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aSA9ICBidWZmLnNsaWNlKGkqc0dpbiwgKGkrMSkqc0dpbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtaSA9IGJ1ZmYuc2xpY2UoKGkrc21hbGxNKSpzR2luLCAoaStzbWFsbE0rMSkqc0dpbik7XG5cbiAgICAgICAgICAgICAgICAgICAgdDAuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcuc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIodGkgLCBzaGlmdF90b19zbWFsbF9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVfb3Zlcl9kZW5vbVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkqc0dtaWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdDEuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcuc3ViKCB0bWksIHRpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGci5tdWwoc0ludkFjYywgb25lX292ZXJfZGVub20pXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSpzR21pZFxuICAgICAgICAgICAgICAgICAgICApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgc0ludkFjYyA9IEZyLm11bChzSW52QWNjLCBGci5zaGlmdEludik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQwID0gYXdhaXQgRy5pZmZ0KHQwLCBcImphY29iaWFuXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIiB0MFwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZSh0MCk7XG4gICAgICAgICAgICAgICAgdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHQxID0gYXdhaXQgRy5pZmZ0KHQxLCBcImphY29iaWFuXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIiB0MFwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZSh0MSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUG93ZXIgdG9vIGJpZ1wiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3dlciB0byBiaWdcIik7XG4gICAgICAgICAgICB9XG4qL1xuICAgICAgICB9XG4gICAgfVxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_preparephase2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_truncate.js":
/*!**********************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_truncate.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ truncate)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nasync function truncate(ptauFilename, template, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(ptauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    for (let p=1; p<power; p++) {\n        await generateTruncate(p);\n    }\n\n    await fdOld.close();\n\n    return true;\n\n    async function generateTruncate(p) {\n\n        let sP = p.toString();\n        while (sP.length<2) sP = \"0\" + sP;\n\n        if (logger) logger.debug(\"Writing Power: \"+sP);\n\n        const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(template + sP + \".ptau\", \"ptau\", 1, 11);\n        await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, p, ceremonyPower);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2, ((2 ** p)*2-1) * sG1 ); // tagG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3, (2 ** p) * sG2); // tauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4, (2 ** p) * sG1); // alfaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5, (2 ** p) * sG1); // betaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6,  sG2); // betaTauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7); // contributions\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 12, ((2 ** (p+1))*2 -1) * sG1); // L_tauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 13, ((2 ** p)*2 -1) * sG2); // L_tauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 14, ((2 ** p)*2 -1) * sG1); // L_alfaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 15, ((2 ** p)*2 -1) * sG1); // L_betaTauG1\n\n        await fdNew.close();\n    }\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdHJ1bmNhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDSjs7QUFFakM7O0FBRWYsV0FBVyxxQkFBcUIsUUFBUSw0REFBd0I7QUFDaEUsV0FBVyw2QkFBNkIsUUFBUSxpRUFBb0I7O0FBRXBFO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qiw4REFBMEI7QUFDdEQsY0FBYyxrRUFBcUI7O0FBRW5DLGNBQWMsNERBQXdCLG9EQUFvRDtBQUMxRixjQUFjLDREQUF3Qiw2Q0FBNkM7QUFDbkYsY0FBYyw0REFBd0IsNkNBQTZDO0FBQ25GLGNBQWMsNERBQXdCLDZDQUE2QztBQUNuRixjQUFjLDREQUF3QixtQ0FBbUM7QUFDekUsY0FBYyw0REFBd0IsNkJBQTZCO0FBQ25FLGNBQWMsNERBQXdCLHlEQUF5RDtBQUMvRixjQUFjLDREQUF3QixxREFBcUQ7QUFDM0YsY0FBYyw0REFBd0IscURBQXFEO0FBQzNGLGNBQWMsNERBQXdCLHFEQUFxRDs7QUFFM0Y7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdHJ1bmNhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB0cnVuY2F0ZShwdGF1RmlsZW5hbWUsIHRlbXBsYXRlLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShwdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyLCBjZXJlbW9ueVBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuXG4gICAgZm9yIChsZXQgcD0xOyBwPHBvd2VyOyBwKyspIHtcbiAgICAgICAgYXdhaXQgZ2VuZXJhdGVUcnVuY2F0ZShwKTtcbiAgICB9XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRydW5jYXRlKHApIHtcblxuICAgICAgICBsZXQgc1AgPSBwLnRvU3RyaW5nKCk7XG4gICAgICAgIHdoaWxlIChzUC5sZW5ndGg8Mikgc1AgPSBcIjBcIiArIHNQO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIldyaXRpbmcgUG93ZXI6IFwiK3NQKTtcblxuICAgICAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKHRlbXBsYXRlICsgc1AgKyBcIi5wdGF1XCIsIFwicHRhdVwiLCAxLCAxMSk7XG4gICAgICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHAsIGNlcmVtb255UG93ZXIpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAyLCAoKDIgKiogcCkqMi0xKSAqIHNHMSApOyAvLyB0YWdHMVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMywgKDIgKiogcCkgKiBzRzIpOyAvLyB0YXVHMlxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNCwgKDIgKiogcCkgKiBzRzEpOyAvLyBhbGZhVGF1RzFcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDUsICgyICoqIHApICogc0cxKTsgLy8gYmV0YVRhdUcxXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA2LCAgc0cyKTsgLy8gYmV0YVRhdUcyXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA3KTsgLy8gY29udHJpYnV0aW9uc1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTIsICgoMiAqKiAocCsxKSkqMiAtMSkgKiBzRzEpOyAvLyBMX3RhdUcxXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxMywgKCgyICoqIHApKjIgLTEpICogc0cyKTsgLy8gTF90YXVHMlxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTQsICgoMiAqKiBwKSoyIC0xKSAqIHNHMSk7IC8vIExfYWxmYVRhdUcxXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxNSwgKCgyICoqIHApKjIgLTEpICogc0cxKTsgLy8gTF9iZXRhVGF1RzFcblxuICAgICAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuICAgIH1cblxuXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_truncate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateFirstChallengeHash: () => (/* binding */ calculateFirstChallengeHash),\n/* harmony export */   fromPtauPubKeyRpr: () => (/* binding */ fromPtauPubKeyRpr),\n/* harmony export */   keyFromBeacon: () => (/* binding */ keyFromBeacon),\n/* harmony export */   readContributions: () => (/* binding */ readContributions),\n/* harmony export */   readPTauHeader: () => (/* binding */ readPTauHeader),\n/* harmony export */   readPtauPubKey: () => (/* binding */ readPtauPubKey),\n/* harmony export */   toPtauPubKeyRpr: () => (/* binding */ toPtauPubKeyRpr),\n/* harmony export */   writeContributions: () => (/* binding */ writeContributions),\n/* harmony export */   writePTauHeader: () => (/* binding */ writePTauHeader),\n/* harmony export */   writePtauPubKey: () => (/* binding */ writePtauPubKey)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function writePTauHeader(fd, curve, power, ceremonyPower) {\n    // Write the header\n    ///////////\n\n    if (! ceremonyPower) ceremonyPower = power;\n    await fd.writeULE32(1); // Header type\n    const pHeaderSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(curve.F1.n64*8);\n\n    const buff = new Uint8Array(curve.F1.n8);\n    ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(buff, 0, curve.q, curve.F1.n8);\n    await fd.write(buff);\n    await fd.writeULE32(power);                    // power\n    await fd.writeULE32(ceremonyPower);               // power\n\n    const headerSize = fd.pos - pHeaderSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(headerSize, pHeaderSize);\n\n    fd.pos = oldPos;\n}\n\nasync function readPTauHeader(fd, sections) {\n    if (!sections[1])  throw new Error(fd.fileName + \": File has no  header\");\n    if (sections[1].length>1) throw new Error(fd.fileName +\": File has more than one header\");\n\n    fd.pos = sections[1][0].p;\n    const n8 = await fd.readULE32();\n    const buff = await fd.read(n8);\n    const q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(buff);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_3__.getCurveFromQ)(q);\n\n    if (curve.F1.n64*8 != n8) throw new Error(fd.fileName +\": Invalid size\");\n\n    const power = await fd.readULE32();\n    const ceremonyPower = await fd.readULE32();\n\n    if (fd.pos-sections[1][0].p != sections[1][0].size) throw new Error(\"Invalid PTau header size\");\n\n    return {curve, power, ceremonyPower};\n}\n\n\nasync function readPtauPubKey(fd, curve, montgomery) {\n\n    const buff = await fd.read(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n\n    return fromPtauPubKeyRpr(buff, 0, curve, montgomery);\n}\n\nfunction fromPtauPubKeyRpr(buff, pos, curve, montgomery) {\n\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n\n    key.tau.g1_s = readG1();\n    key.tau.g1_sx = readG1();\n    key.alpha.g1_s = readG1();\n    key.alpha.g1_sx = readG1();\n    key.beta.g1_s = readG1();\n    key.beta.g1_sx = readG1();\n    key.tau.g2_spx = readG2();\n    key.alpha.g2_spx = readG2();\n    key.beta.g2_spx = readG2();\n\n    return key;\n\n    function readG1() {\n        let p;\n        if (montgomery) {\n            p = curve.G1.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G1.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G1.F.n8*2;\n        return p;\n    }\n\n    function readG2() {\n        let p;\n        if (montgomery) {\n            p = curve.G2.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G2.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G2.F.n8*2;\n        return p;\n    }\n}\n\nfunction toPtauPubKeyRpr(buff, pos, curve, key, montgomery) {\n\n    writeG1(key.tau.g1_s);\n    writeG1(key.tau.g1_sx);\n    writeG1(key.alpha.g1_s);\n    writeG1(key.alpha.g1_sx);\n    writeG1(key.beta.g1_s);\n    writeG1(key.beta.g1_sx);\n    writeG2(key.tau.g2_spx);\n    writeG2(key.alpha.g2_spx);\n    writeG2(key.beta.g2_spx);\n\n    async function writeG1(p) {\n        if (montgomery) {\n            curve.G1.toRprLEM(buff, pos, p);\n        } else {\n            curve.G1.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F1.n8*2;\n    }\n\n    async function writeG2(p) {\n        if (montgomery) {\n            curve.G2.toRprLEM(buff, pos, p);\n        } else {\n            curve.G2.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F2.n8*2;\n    }\n\n    return buff;\n}\n\nasync function writePtauPubKey(fd, curve, key, montgomery) {\n    const buff = new Uint8Array(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n    toPtauPubKeyRpr(buff, 0, curve, key, montgomery);\n    await fd.write(buff);\n}\n\nasync function readContribution(fd, curve) {\n    const c = {};\n\n    c.tauG1 = await readG1();\n    c.tauG2 = await readG2();\n    c.alphaG1 = await readG1();\n    c.betaG1 = await readG1();\n    c.betaG2 = await readG2();\n    c.key = await readPtauPubKey(fd, curve, true);\n    c.partialHash = await fd.read(216);\n    c.nextChallenge = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n    toPtauPubKeyRpr(buffV, 0, curve, c.key, false);\n\n    const responseHasher =  _misc_js__WEBPACK_IMPORTED_MODULE_2__.fromPartialHash(c.partialHash);\n    responseHasher.update(buffV);\n    c.responseHash = responseHasher.digest();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await readDV(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await readDV(1);\n            const buffStr = await readDV(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await readDV(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await readDV(1);\n            c.beaconHash = await readDV(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n\n    async function readG1() {\n        const pBuff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprLEM( pBuff );\n    }\n\n    async function readG2() {\n        const pBuff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprLEM( pBuff );\n    }\n\n    async function readDV(n) {\n        const b = await fd.read(n);\n        return new Uint8Array(b);\n    }\n}\n\nasync function readContributions(fd, curve, sections) {\n    if (!sections[7])  throw new Error(fd.fileName + \": File has no  contributions\");\n    if (sections[7][0].length>1) throw new Error(fd.fileName +\": File has more than one contributions section\");\n\n    fd.pos = sections[7][0].p;\n    const nContributions = await fd.readULE32();\n    const contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = await readContribution(fd, curve);\n        c.id = i+1;\n        contributions.push(c);\n    }\n\n    if (fd.pos-sections[7][0].p != sections[7][0].size) throw new Error(\"Invalid contribution section size\");\n\n    return contributions;\n}\n\nasync function writeContribution(fd, curve, contribution) {\n\n    const buffG1 = new Uint8Array(curve.F1.n8*2);\n    const buffG2 = new Uint8Array(curve.F2.n8*2);\n    await writeG1(contribution.tauG1);\n    await writeG2(contribution.tauG2);\n    await writeG1(contribution.alphaG1);\n    await writeG1(contribution.betaG1);\n    await writeG2(contribution.betaG2);\n    await writePtauPubKey(fd, curve, contribution.key, true);\n    await fd.write(contribution.partialHash);\n    await fd.write(contribution.nextChallenge);\n    await fd.writeULE32(contribution.type || 0);\n\n    const params = [];\n    if (contribution.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(contribution.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (contribution.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(contribution.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(contribution.beaconHash.byteLength);\n        for (let i=0; i<contribution.beaconHash.byteLength; i++) params.push(contribution.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n\n    async function writeG1(p) {\n        curve.G1.toRprLEM(buffG1, 0, p);\n        await fd.write(buffG1);\n    }\n\n    async function writeG2(p) {\n        curve.G2.toRprLEM(buffG2, 0, p);\n        await fd.write(buffG2);\n    }\n\n}\n\nasync function writeContributions(fd, curve, contributions) {\n\n    await fd.writeULE32(7); // Header type\n    const pContributionsSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(contributions.length);\n    for (let i=0; i< contributions.length; i++) {\n        await writeContribution(fd, curve, contributions[i]);\n    }\n    const contributionsSize = fd.pos - pContributionsSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(contributionsSize, pContributionsSize);\n    fd.pos = oldPos;\n}\n\nfunction calculateFirstChallengeHash(curve, power, logger) {\n    if (logger) logger.debug(\"Calculating First Challenge Hash\");\n\n    const hasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 });\n\n    const vG1 = new Uint8Array(curve.G1.F.n8*2);\n    const vG2 = new Uint8Array(curve.G2.F.n8*2);\n    curve.G1.toRprUncompressed(vG1, 0, curve.G1.g);\n    curve.G2.toRprUncompressed(vG2, 0, curve.G2.g);\n\n    hasher.update(_noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_4__.blake2b.create({ dkLen: 64 }).digest());\n\n    let n;\n\n    n=(2 ** power)*2 -1;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG1\");\n    hashBlock(vG1, n);\n    n= 2 ** power;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG2\");\n    hashBlock(vG2, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: alphaTauG1\");\n    hashBlock(vG1, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: betaTauG1\");\n    hashBlock(vG1, n);\n    hasher.update(vG2);\n\n    return hasher.digest();\n\n    function hashBlock(buff, n) {\n        // this block size is a good compromise between speed and the maximum\n        // input size of the Blake2b update method (65,535,720 bytes).\n        const blockSize = 341000;\n        const nBlocks = Math.floor(n / blockSize);\n        const rem = n % blockSize;\n        const bigBuff = new Uint8Array(blockSize * buff.byteLength);\n        for (let i=0; i<blockSize; i++) {\n            bigBuff.set(buff, i*buff.byteLength);\n        }\n        for (let i=0; i<nBlocks; i++) {\n            hasher.update(bigBuff);\n            if (logger) logger.debug(\"Initial hash: \" +i*blockSize);\n        }\n        for (let i=0; i<rem; i++) {\n            hasher.update(buff);\n        }\n    }\n}\n\n\nasync function keyFromBeacon(curve, challengeHash, beaconHash, numIterationsExp) {\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_2__.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const key = _keypair_js__WEBPACK_IMPORTED_MODULE_1__.createPTauKey(curve, challengeHash, rng);\n\n    return key;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0M7QUFDVTtBQUNSO0FBQ047QUFDVTs7QUFFckM7QUFDUDtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBLG1EQUFtRDtBQUNuRCxzREFBc0Q7O0FBRXREOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0RBQU07O0FBRXBCLHdCQUF3Qix5REFBYTs7QUFFckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxZQUFZO0FBQ1o7OztBQUdPOztBQUVQOztBQUVBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixxREFBb0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0Esc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPOztBQUVQLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQSxtQkFBbUIsMERBQU8sVUFBVSxXQUFXOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsMERBQU8sVUFBVSxXQUFXOztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTzs7QUFFUCxzQkFBc0IseURBQXdCOztBQUU5QyxnQkFBZ0Isc0RBQXFCOztBQUVyQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyBrZXlQYWlyIGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVQVGF1SGVhZGVyKGZkLCBjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXIpIHtcbiAgICAvLyBXcml0ZSB0aGUgaGVhZGVyXG4gICAgLy8vLy8vLy8vLy9cblxuICAgIGlmICghIGNlcmVtb255UG93ZXIpIGNlcmVtb255UG93ZXIgPSBwb3dlcjtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDEpOyAvLyBIZWFkZXIgdHlwZVxuICAgIGNvbnN0IHBIZWFkZXJTaXplID0gZmQucG9zO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFNjQoMCk7IC8vIFRlbXBvcmFsbHkgc2V0IHRvIDAgbGVuZ3RoXG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGN1cnZlLkYxLm42NCo4KTtcblxuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCk7XG4gICAgU2NhbGFyLnRvUnByTEUoYnVmZiwgMCwgY3VydmUucSwgY3VydmUuRjEubjgpO1xuICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmYpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIocG93ZXIpOyAgICAgICAgICAgICAgICAgICAgLy8gcG93ZXJcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGNlcmVtb255UG93ZXIpOyAgICAgICAgICAgICAgIC8vIHBvd2VyXG5cbiAgICBjb25zdCBoZWFkZXJTaXplID0gZmQucG9zIC0gcEhlYWRlclNpemUgLSA4O1xuXG4gICAgY29uc3Qgb2xkUG9zID0gZmQucG9zO1xuXG4gICAgYXdhaXQgZmQud3JpdGVVTEU2NChoZWFkZXJTaXplLCBwSGVhZGVyU2l6ZSk7XG5cbiAgICBmZC5wb3MgPSBvbGRQb3M7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkUFRhdUhlYWRlcihmZCwgc2VjdGlvbnMpIHtcbiAgICBpZiAoIXNlY3Rpb25zWzFdKSAgdGhyb3cgbmV3IEVycm9yKGZkLmZpbGVOYW1lICsgXCI6IEZpbGUgaGFzIG5vICBoZWFkZXJcIik7XG4gICAgaWYgKHNlY3Rpb25zWzFdLmxlbmd0aD4xKSB0aHJvdyBuZXcgRXJyb3IoZmQuZmlsZU5hbWUgK1wiOiBGaWxlIGhhcyBtb3JlIHRoYW4gb25lIGhlYWRlclwiKTtcblxuICAgIGZkLnBvcyA9IHNlY3Rpb25zWzFdWzBdLnA7XG4gICAgY29uc3QgbjggPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChuOCk7XG4gICAgY29uc3QgcSA9IFNjYWxhci5mcm9tUnByTEUoYnVmZik7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbVEocSk7XG5cbiAgICBpZiAoY3VydmUuRjEubjY0KjggIT0gbjgpIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArXCI6IEludmFsaWQgc2l6ZVwiKTtcblxuICAgIGNvbnN0IHBvd2VyID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgY29uc3QgY2VyZW1vbnlQb3dlciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuXG4gICAgaWYgKGZkLnBvcy1zZWN0aW9uc1sxXVswXS5wICE9IHNlY3Rpb25zWzFdWzBdLnNpemUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUFRhdSBoZWFkZXIgc2l6ZVwiKTtcblxuICAgIHJldHVybiB7Y3VydmUsIHBvd2VyLCBjZXJlbW9ueVBvd2VyfTtcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZFB0YXVQdWJLZXkoZmQsIGN1cnZlLCBtb250Z29tZXJ5KSB7XG5cbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5GMS5uOCoyKjYgKyBjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgcmV0dXJuIGZyb21QdGF1UHViS2V5UnByKGJ1ZmYsIDAsIGN1cnZlLCBtb250Z29tZXJ5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21QdGF1UHViS2V5UnByKGJ1ZmYsIHBvcywgY3VydmUsIG1vbnRnb21lcnkpIHtcblxuICAgIGNvbnN0IGtleSA9IHtcbiAgICAgICAgdGF1OiB7fSxcbiAgICAgICAgYWxwaGE6IHt9LFxuICAgICAgICBiZXRhOiB7fVxuICAgIH07XG5cbiAgICBrZXkudGF1LmcxX3MgPSByZWFkRzEoKTtcbiAgICBrZXkudGF1LmcxX3N4ID0gcmVhZEcxKCk7XG4gICAga2V5LmFscGhhLmcxX3MgPSByZWFkRzEoKTtcbiAgICBrZXkuYWxwaGEuZzFfc3ggPSByZWFkRzEoKTtcbiAgICBrZXkuYmV0YS5nMV9zID0gcmVhZEcxKCk7XG4gICAga2V5LmJldGEuZzFfc3ggPSByZWFkRzEoKTtcbiAgICBrZXkudGF1LmcyX3NweCA9IHJlYWRHMigpO1xuICAgIGtleS5hbHBoYS5nMl9zcHggPSByZWFkRzIoKTtcbiAgICBrZXkuYmV0YS5nMl9zcHggPSByZWFkRzIoKTtcblxuICAgIHJldHVybiBrZXk7XG5cbiAgICBmdW5jdGlvbiByZWFkRzEoKSB7XG4gICAgICAgIGxldCBwO1xuICAgICAgICBpZiAobW9udGdvbWVyeSkge1xuICAgICAgICAgICAgcCA9IGN1cnZlLkcxLmZyb21ScHJMRU0oIGJ1ZmYsIHBvcyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IGN1cnZlLkcxLmZyb21ScHJVbmNvbXByZXNzZWQoIGJ1ZmYsIHBvcyApO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRHMigpIHtcbiAgICAgICAgbGV0IHA7XG4gICAgICAgIGlmIChtb250Z29tZXJ5KSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzIuZnJvbVJwckxFTSggYnVmZiwgcG9zICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzIuZnJvbVJwclVuY29tcHJlc3NlZCggYnVmZiwgcG9zICk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGN1cnZlLkcyLkYubjgqMjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9QdGF1UHViS2V5UnByKGJ1ZmYsIHBvcywgY3VydmUsIGtleSwgbW9udGdvbWVyeSkge1xuXG4gICAgd3JpdGVHMShrZXkudGF1LmcxX3MpO1xuICAgIHdyaXRlRzEoa2V5LnRhdS5nMV9zeCk7XG4gICAgd3JpdGVHMShrZXkuYWxwaGEuZzFfcyk7XG4gICAgd3JpdGVHMShrZXkuYWxwaGEuZzFfc3gpO1xuICAgIHdyaXRlRzEoa2V5LmJldGEuZzFfcyk7XG4gICAgd3JpdGVHMShrZXkuYmV0YS5nMV9zeCk7XG4gICAgd3JpdGVHMihrZXkudGF1LmcyX3NweCk7XG4gICAgd3JpdGVHMihrZXkuYWxwaGEuZzJfc3B4KTtcbiAgICB3cml0ZUcyKGtleS5iZXRhLmcyX3NweCk7XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUcxKHApIHtcbiAgICAgICAgaWYgKG1vbnRnb21lcnkpIHtcbiAgICAgICAgICAgIGN1cnZlLkcxLnRvUnByTEVNKGJ1ZmYsIHBvcywgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJ2ZS5HMS50b1JwclVuY29tcHJlc3NlZChidWZmLCBwb3MsIHApO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjdXJ2ZS5GMS5uOCoyO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIocCkge1xuICAgICAgICBpZiAobW9udGdvbWVyeSkge1xuICAgICAgICAgICAgY3VydmUuRzIudG9ScHJMRU0oYnVmZiwgcG9zLCBwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnZlLkcyLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIHBvcywgcCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGN1cnZlLkYyLm44KjI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZVB0YXVQdWJLZXkoZmQsIGN1cnZlLCBrZXksIG1vbnRnb21lcnkpIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMio2ICsgY3VydmUuRjIubjgqMiozKTtcbiAgICB0b1B0YXVQdWJLZXlScHIoYnVmZiwgMCwgY3VydmUsIGtleSwgbW9udGdvbWVyeSk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDb250cmlidXRpb24oZmQsIGN1cnZlKSB7XG4gICAgY29uc3QgYyA9IHt9O1xuXG4gICAgYy50YXVHMSA9IGF3YWl0IHJlYWRHMSgpO1xuICAgIGMudGF1RzIgPSBhd2FpdCByZWFkRzIoKTtcbiAgICBjLmFscGhhRzEgPSBhd2FpdCByZWFkRzEoKTtcbiAgICBjLmJldGFHMSA9IGF3YWl0IHJlYWRHMSgpO1xuICAgIGMuYmV0YUcyID0gYXdhaXQgcmVhZEcyKCk7XG4gICAgYy5rZXkgPSBhd2FpdCByZWFkUHRhdVB1YktleShmZCwgY3VydmUsIHRydWUpO1xuICAgIGMucGFydGlhbEhhc2ggPSBhd2FpdCBmZC5yZWFkKDIxNik7XG4gICAgYy5uZXh0Q2hhbGxlbmdlID0gYXdhaXQgZmQucmVhZCg2NCk7XG4gICAgYy50eXBlID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG5cbiAgICBjb25zdCBidWZmViAgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIqNitjdXJ2ZS5HMi5GLm44KjIqMyk7XG4gICAgdG9QdGF1UHViS2V5UnByKGJ1ZmZWLCAwLCBjdXJ2ZSwgYy5rZXksIGZhbHNlKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSGFzaGVyID0gIG1pc2MuZnJvbVBhcnRpYWxIYXNoKGMucGFydGlhbEhhc2gpO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmVik7XG4gICAgYy5yZXNwb25zZUhhc2ggPSByZXNwb25zZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGNvbnN0IHBhcmFtTGVuZ3RoID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgY29uc3QgY3VyUG9zID0gZmQucG9zO1xuICAgIGxldCBsYXN0VHlwZSA9MDtcbiAgICB3aGlsZSAoZmQucG9zLWN1clBvcyA8IHBhcmFtTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZUeXBlID0gYXdhaXQgcmVhZERWKDEpO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF08PSBsYXN0VHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVycyBpbiB0aGUgY29udHJpYnV0aW9uIG11c3QgYmUgc29ydGVkXCIpO1xuICAgICAgICBsYXN0VHlwZSA9IGJ1ZmZUeXBlWzBdO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF09PTEpIHsgICAgIC8vIE5hbWVcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMZW4gPSBhd2FpdCByZWFkRFYoMSk7XG4gICAgICAgICAgICBjb25zdCBidWZmU3RyID0gYXdhaXQgcmVhZERWKGJ1ZmZMZW5bMF0pO1xuICAgICAgICAgICAgYy5uYW1lID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZTdHIpO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZUeXBlWzBdPT0yKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmRXhwID0gYXdhaXQgcmVhZERWKDEpO1xuICAgICAgICAgICAgYy5udW1JdGVyYXRpb25zRXhwID0gYnVmZkV4cFswXTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmVHlwZVswXT09Mykge1xuICAgICAgICAgICAgY29uc3QgYnVmZkxlbiA9IGF3YWl0IHJlYWREVigxKTtcbiAgICAgICAgICAgIGMuYmVhY29uSGFzaCA9IGF3YWl0IHJlYWREVihidWZmTGVuWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBub3QgcmVjb2duaXplZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmQucG9zICE9IGN1clBvcyArIHBhcmFtTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlcnMgZG8gbm90IG1hdGNoXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBjO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcxKCkge1xuICAgICAgICBjb25zdCBwQnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcxLmZyb21ScHJMRU0oIHBCdWZmICk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcyKCkge1xuICAgICAgICBjb25zdCBwQnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzIuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcyLmZyb21ScHJMRU0oIHBCdWZmICk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZERWKG4pIHtcbiAgICAgICAgY29uc3QgYiA9IGF3YWl0IGZkLnJlYWQobik7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiKTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkQ29udHJpYnV0aW9ucyhmZCwgY3VydmUsIHNlY3Rpb25zKSB7XG4gICAgaWYgKCFzZWN0aW9uc1s3XSkgIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArIFwiOiBGaWxlIGhhcyBubyAgY29udHJpYnV0aW9uc1wiKTtcbiAgICBpZiAoc2VjdGlvbnNbN11bMF0ubGVuZ3RoPjEpIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArXCI6IEZpbGUgaGFzIG1vcmUgdGhhbiBvbmUgY29udHJpYnV0aW9ucyBzZWN0aW9uXCIpO1xuXG4gICAgZmQucG9zID0gc2VjdGlvbnNbN11bMF0ucDtcbiAgICBjb25zdCBuQ29udHJpYnV0aW9ucyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bkNvbnRyaWJ1dGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbihmZCwgY3VydmUpO1xuICAgICAgICBjLmlkID0gaSsxO1xuICAgICAgICBjb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgaWYgKGZkLnBvcy1zZWN0aW9uc1s3XVswXS5wICE9IHNlY3Rpb25zWzddWzBdLnNpemUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29udHJpYnV0aW9uIHNlY3Rpb24gc2l6ZVwiKTtcblxuICAgIHJldHVybiBjb250cmlidXRpb25zO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsIGNvbnRyaWJ1dGlvbikge1xuXG4gICAgY29uc3QgYnVmZkcxID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMik7XG4gICAgY29uc3QgYnVmZkcyID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjIubjgqMik7XG4gICAgYXdhaXQgd3JpdGVHMShjb250cmlidXRpb24udGF1RzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoY29udHJpYnV0aW9uLnRhdUcyKTtcbiAgICBhd2FpdCB3cml0ZUcxKGNvbnRyaWJ1dGlvbi5hbHBoYUcxKTtcbiAgICBhd2FpdCB3cml0ZUcxKGNvbnRyaWJ1dGlvbi5iZXRhRzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoY29udHJpYnV0aW9uLmJldGFHMik7XG4gICAgYXdhaXQgd3JpdGVQdGF1UHViS2V5KGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9uLmtleSwgdHJ1ZSk7XG4gICAgYXdhaXQgZmQud3JpdGUoY29udHJpYnV0aW9uLnBhcnRpYWxIYXNoKTtcbiAgICBhd2FpdCBmZC53cml0ZShjb250cmlidXRpb24ubmV4dENoYWxsZW5nZSk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb250cmlidXRpb24udHlwZSB8fCAwKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGlmIChjb250cmlidXRpb24ubmFtZSkge1xuICAgICAgICBwYXJhbXMucHVzaCgxKTsgICAgICAvLyBQYXJhbSBOYW1lXG4gICAgICAgIGNvbnN0IG5hbWVEYXRhID0gbmV3IFRleHRFbmNvZGVyKFwidXRmLThcIikuZW5jb2RlKGNvbnRyaWJ1dGlvbi5uYW1lLnN1YnN0cmluZygwLDY0KSk7XG4gICAgICAgIHBhcmFtcy5wdXNoKG5hbWVEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bmFtZURhdGEuYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChuYW1lRGF0YVtpXSk7XG4gICAgfVxuICAgIGlmIChjb250cmlidXRpb24udHlwZSA9PSAxKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKDIpOyAgICAgIC8vIFBhcmFtIG51bUl0ZXJhdGlvbnNFeHBcbiAgICAgICAgcGFyYW1zLnB1c2goY29udHJpYnV0aW9uLm51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgICAgIHBhcmFtcy5wdXNoKDMpOyAgICAgIC8vIEJlYWNvbiBIYXNoXG4gICAgICAgIHBhcmFtcy5wdXNoKGNvbnRyaWJ1dGlvbi5iZWFjb25IYXNoLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29udHJpYnV0aW9uLmJlYWNvbkhhc2guYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChjb250cmlidXRpb24uYmVhY29uSGFzaFtpXSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGVuZ3RoPjApIHtcbiAgICAgICAgY29uc3QgcGFyYW1zQnVmZiA9IG5ldyBVaW50OEFycmF5KHBhcmFtcyk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIocGFyYW1zQnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUocGFyYW1zQnVmZik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMigwKTtcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEocCkge1xuICAgICAgICBjdXJ2ZS5HMS50b1JwckxFTShidWZmRzEsIDAsIHApO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIocCkge1xuICAgICAgICBjdXJ2ZS5HMi50b1JwckxFTShidWZmRzIsIDAsIHApO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzIpO1xuICAgIH1cblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVDb250cmlidXRpb25zKGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9ucykge1xuXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMig3KTsgLy8gSGVhZGVyIHR5cGVcbiAgICBjb25zdCBwQ29udHJpYnV0aW9uc1NpemUgPSBmZC5wb3M7XG4gICAgYXdhaXQgZmQud3JpdGVVTEU2NCgwKTsgLy8gVGVtcG9yYWxseSBzZXQgdG8gMCBsZW5ndGhcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY29udHJpYnV0aW9ucy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGk9MDsgaTwgY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsIGNvbnRyaWJ1dGlvbnNbaV0pO1xuICAgIH1cbiAgICBjb25zdCBjb250cmlidXRpb25zU2l6ZSA9IGZkLnBvcyAtIHBDb250cmlidXRpb25zU2l6ZSAtIDg7XG5cbiAgICBjb25zdCBvbGRQb3MgPSBmZC5wb3M7XG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KGNvbnRyaWJ1dGlvbnNTaXplLCBwQ29udHJpYnV0aW9uc1NpemUpO1xuICAgIGZkLnBvcyA9IG9sZFBvcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNhbGN1bGF0aW5nIEZpcnN0IENoYWxsZW5nZSBIYXNoXCIpO1xuXG4gICAgY29uc3QgaGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG5cbiAgICBjb25zdCB2RzEgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIpO1xuICAgIGNvbnN0IHZHMiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcyLkYubjgqMik7XG4gICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQodkcxLCAwLCBjdXJ2ZS5HMS5nKTtcbiAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZCh2RzIsIDAsIGN1cnZlLkcyLmcpO1xuXG4gICAgaGFzaGVyLnVwZGF0ZShibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KS5kaWdlc3QoKSk7XG5cbiAgICBsZXQgbjtcblxuICAgIG49KDIgKiogcG93ZXIpKjIgLTE7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQ2FsY3VsYXRlIEluaXRpYWwgSGFzaDogdGF1RzFcIik7XG4gICAgaGFzaEJsb2NrKHZHMSwgbik7XG4gICAgbj0gMiAqKiBwb3dlcjtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDYWxjdWxhdGUgSW5pdGlhbCBIYXNoOiB0YXVHMlwiKTtcbiAgICBoYXNoQmxvY2sodkcyLCBuKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDYWxjdWxhdGUgSW5pdGlhbCBIYXNoOiBhbHBoYVRhdUcxXCIpO1xuICAgIGhhc2hCbG9jayh2RzEsIG4pO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNhbGN1bGF0ZSBJbml0aWFsIEhhc2g6IGJldGFUYXVHMVwiKTtcbiAgICBoYXNoQmxvY2sodkcxLCBuKTtcbiAgICBoYXNoZXIudXBkYXRlKHZHMik7XG5cbiAgICByZXR1cm4gaGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgZnVuY3Rpb24gaGFzaEJsb2NrKGJ1ZmYsIG4pIHtcbiAgICAgICAgLy8gdGhpcyBibG9jayBzaXplIGlzIGEgZ29vZCBjb21wcm9taXNlIGJldHdlZW4gc3BlZWQgYW5kIHRoZSBtYXhpbXVtXG4gICAgICAgIC8vIGlucHV0IHNpemUgb2YgdGhlIEJsYWtlMmIgdXBkYXRlIG1ldGhvZCAoNjUsNTM1LDcyMCBieXRlcykuXG4gICAgICAgIGNvbnN0IGJsb2NrU2l6ZSA9IDM0MTAwMDtcbiAgICAgICAgY29uc3QgbkJsb2NrcyA9IE1hdGguZmxvb3IobiAvIGJsb2NrU2l6ZSk7XG4gICAgICAgIGNvbnN0IHJlbSA9IG4gJSBibG9ja1NpemU7XG4gICAgICAgIGNvbnN0IGJpZ0J1ZmYgPSBuZXcgVWludDhBcnJheShibG9ja1NpemUgKiBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YmxvY2tTaXplOyBpKyspIHtcbiAgICAgICAgICAgIGJpZ0J1ZmYuc2V0KGJ1ZmYsIGkqYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkJsb2NrczsgaSsrKSB7XG4gICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJpZ0J1ZmYpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiSW5pdGlhbCBoYXNoOiBcIiAraSpibG9ja1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZW07IGkrKykge1xuICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShidWZmKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24ga2V5RnJvbUJlYWNvbihjdXJ2ZSwgY2hhbGxlbmdlSGFzaCwgYmVhY29uSGFzaCwgbnVtSXRlcmF0aW9uc0V4cCkge1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5ybmdGcm9tQmVhY29uUGFyYW1zKGJlYWNvbkhhc2gsIG51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgY29uc3Qga2V5ID0ga2V5UGFpci5jcmVhdGVQVGF1S2V5KGN1cnZlLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuXG4gICAgcmV0dXJuIGtleTtcbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/powersoftau_verify.js":
/*!********************************************************!*\
  !*** ./node_modules/snarkjs/src/powersoftau_verify.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst sameRatio = _misc_js__WEBPACK_IMPORTED_MODULE_4__.sameRatio;\n\nasync function verifyContribution(curve, cur, prev, logger) {\n    let sr;\n    if (cur.type == 1) {    // Verify the beacon.\n        const beaconKey = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.keyFromBeacon(curve, prev.nextChallenge, cur.beaconHash, cur.numIterationsExp);\n\n        if (!curve.G1.eq(cur.key.tau.g1_s, beaconKey.tau.g1_s)) {\n            if (logger) logger.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.tau.g1_sx, beaconKey.tau.g1_sx)) {\n            if (logger) logger.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.tau.g2_spx, beaconKey.tau.g2_spx)) {\n            if (logger) logger.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.alpha.g1_s, beaconKey.alpha.g1_s)) {\n            if (logger) logger.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.alpha.g1_sx, beaconKey.alpha.g1_sx)) {\n            if (logger) logger.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.alpha.g2_spx, beaconKey.alpha.g2_spx)) {\n            if (logger) logger.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.beta.g1_s, beaconKey.beta.g1_s)) {\n            if (logger) logger.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.beta.g1_sx, beaconKey.beta.g1_sx)) {\n            if (logger) logger.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.beta.g2_spx, beaconKey.beta.g2_spx)) {\n            if (logger) logger.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n    }\n\n    cur.key.tau.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_1__.getG2sp(curve, 0, prev.nextChallenge, cur.key.tau.g1_s, cur.key.tau.g1_sx));\n    cur.key.alpha.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_1__.getG2sp(curve, 1, prev.nextChallenge, cur.key.alpha.g1_s, cur.key.alpha.g1_sx));\n    cur.key.beta.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_1__.getG2sp(curve, 2, prev.nextChallenge, cur.key.beta.g1_s, cur.key.beta.g1_sx));\n\n    sr = await sameRatio(curve, cur.key.tau.g1_s, cur.key.tau.g1_sx, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (tau) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.alpha.g1_s, cur.key.alpha.g1_sx, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (alpha) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.beta.g1_s, cur.key.beta.g1_sx, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (beta) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.tauG1, cur.tauG1, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.tau.g1_s, cur.key.tau.g1_sx, prev.tauG2, cur.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G2. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.alphaG1, cur.alphaG1, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID alpha*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.betaG1, cur.betaG1, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.beta.g1_s, cur.key.beta.g1_sx, prev.betaG2, cur.betaG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G2. challenge #\"+cur.id+\"It does not follow the previous contribution\");\n        return false;\n    }\n\n    if (logger) logger.info(\"Powers Of tau file OK!\");\n    return true;\n}\n\nasync function verify(tauFilename, logger) {\n    let sr;\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile(tauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readPTauHeader(fd, sections);\n    const contrs = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readContributions(fd, curve, sections);\n\n    if (logger) logger.debug(\"power: 2**\" + power);\n    // Verify Last contribution\n\n    if (logger) logger.debug(\"Computing initial contribution hash\");\n    const initialContribution = {\n        tauG1: curve.G1.g,\n        tauG2: curve.G2.g,\n        alphaG1: curve.G1.g,\n        betaG1: curve.G1.g,\n        betaG2: curve.G2.g,\n        nextChallenge: _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.calculateFirstChallengeHash(curve, ceremonyPower, logger),\n        responseHash: _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 }).digest()\n    };\n\n    if (contrs.length == 0) {\n        if (logger) logger.error(\"This file has no contribution! It cannot be used in production\");\n        return false;\n    }\n\n    let prevContr;\n    if (contrs.length>1) {\n        prevContr = contrs[contrs.length-2];\n    } else {\n        prevContr = initialContribution;\n    }\n    const curContr = contrs[contrs.length-1];\n    if (logger) logger.debug(\"Validating contribution #\"+contrs[contrs.length-1].id);\n    const res = await verifyContribution(curve, curContr, prevContr, logger);\n    if (!res) return false;\n\n\n    const nextContributionHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 });\n    nextContributionHasher.update(curContr.responseHash);\n\n    // Verify powers and compute nextChallengeHash\n\n    // await test();\n\n    // Verify Section tau*G1\n    if (logger) logger.debug(\"Verifying powers in tau*G1 section\");\n    const rTau1 = await processSection(2, \"G1\", \"tauG1\", (2 ** power)*2-1, [0, 1], logger);\n    sr = await sameRatio(curve, rTau1.R1, rTau1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curve.G1.g, rTau1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G1 section must be the generator\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.tauG1, rTau1.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G1 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // await test();\n\n    // Verify Section tau*G2\n    if (logger) logger.debug(\"Verifying powers in tau*G2 section\");\n    const rTau2 = await processSection(3, \"G2\", \"tauG2\", 2 ** power, [0, 1],  logger);\n    sr = await sameRatio(curve, curve.G1.g, curContr.tauG1, rTau2.R1, rTau2.R2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG2 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G2.eq(curve.G2.g, rTau2.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G2 section must be the generator\");\n        return false;\n    }\n    if (!curve.G2.eq(curContr.tauG2, rTau2.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section alpha*tau*G1\n    if (logger) logger.debug(\"Verifying powers in alpha*tau*G1 section\");\n    const rAlphaTauG1 = await processSection(4, \"G1\", \"alphatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rAlphaTauG1.R1, rAlphaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"alphaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.alphaG1, rAlphaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section beta*tau*G1\n    if (logger) logger.debug(\"Verifying powers in beta*tau*G1 section\");\n    const rBetaTauG1 = await processSection(5, \"G1\", \"betatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rBetaTauG1.R1, rBetaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"betaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.betaG1, rBetaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    //Verify Beta G2\n    const betaG2 = await processSectionBetaG2(logger);\n    if (!curve.G2.eq(curContr.betaG2, betaG2)) {\n        if (logger) logger.error(\"betaG2 element in betaG2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n\n    const nextContributionHash = nextContributionHasher.digest();\n\n    // Check the nextChallengeHash\n    if (power == ceremonyPower) {\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(nextContributionHash,curContr.nextChallenge)) {\n            if (logger) logger.error(\"Hash of the values does not match the next challenge of the last contributor in the contributions section\");\n            return false;\n        }\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(nextContributionHash, \"Next challenge hash: \"));\n\n    // Verify Previous contributions\n\n    printContribution(curContr, prevContr);\n    for (let i = contrs.length-2; i>=0; i--) {\n        const curContr = contrs[i];\n        const prevContr =  (i>0) ? contrs[i-1] : initialContribution;\n        const res = await verifyContribution(curve, curContr, prevContr, logger);\n        if (!res) return false;\n        printContribution(curContr, prevContr, logger);\n    }\n    if (logger) logger.info(\"-----------------------------------------------------\");\n\n    if ((!sections[12]) || (!sections[13]) || (!sections[14]) || (!sections[15])) {\n        if (logger) logger.warn(\n            \"this file does not contain phase2 precalculated values. Please run: \\n\" +\n            \"   snarkjs \\\"powersoftau preparephase2\\\" to prepare this file to be used in the phase2 ceremony.\"\n        );\n    } else {\n        let res;\n        res = await verifyLagrangeEvaluations(\"G1\", 2, 12, \"tauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G2\", 3, 13, \"tauG2\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 4, 14, \"alphaTauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 5, 15, \"betaTauG1\", logger);\n        if (!res) return false;\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"Powers of Tau Ok!\");\n\n    return true;\n\n    function printContribution(curContr, prevContr) {\n        if (!logger) return;\n        logger.info(\"-----------------------------------------------------\");\n        logger.info(`Contribution #${curContr.id}: ${curContr.name ||\"\"}`);\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(curContr.nextChallenge, \"Next Challenge: \"));\n\n        const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n        _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.toPtauPubKeyRpr(buffV, 0, curve, curContr.key, false);\n\n        const responseHasher =  _misc_js__WEBPACK_IMPORTED_MODULE_4__.fromPartialHash(curContr.partialHash);\n        responseHasher.update(buffV);\n        const responseHash = responseHasher.digest();\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(responseHash, \"Response Hash:\"));\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(prevContr.nextChallenge, \"Response Hash:\"));\n\n        if (curContr.type == 1) {\n            logger.info(`Beacon generator: ${_misc_js__WEBPACK_IMPORTED_MODULE_4__.byteArray2hex(curContr.beaconHash)}`);\n            logger.info(`Beacon iterations Exp: ${curContr.numIterationsExp}`);\n        }\n\n    }\n\n    async function processSectionBetaG2(logger) {\n        const G = curve.G2;\n        const sG = G.F.n8*2;\n        const buffUv = new Uint8Array(sG);\n\n        if (!sections[6])  {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has no BetaG2 section\");\n        }\n        if (sections[6].length>1) {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has more than one GetaG2 section\");\n        }\n        fd.pos = sections[6][0].p;\n\n        const buff = await fd.read(sG);\n        const P = G.fromRprLEM(buff);\n\n        G.toRprUncompressed(buffUv, 0, P);\n        nextContributionHasher.update(buffUv);\n\n        return P;\n    }\n\n    async function processSection(idSection, groupName, sectionName, nPoints, singularPointIndexes, logger) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startReadUniqueSection(fd, sections, idSection);\n\n        const singularPoints = [];\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        let lastBase = G.zero;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`points relations: ${sectionName}: ${i}/${nPoints} `);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases = await fd.read(n*sG);\n\n            const basesU = await G.batchLEMtoU(bases);\n            nextContributionHasher.update(basesU);\n\n            const scalars = _misc_js__WEBPACK_IMPORTED_MODULE_4__.getRandomBytes(4*(n-1));\n\n            if (i>0) {\n                const firstBase = G.fromRprLEM(bases, 0);\n                const r = _misc_js__WEBPACK_IMPORTED_MODULE_4__.readUInt32BE(_misc_js__WEBPACK_IMPORTED_MODULE_4__.getRandomBytes(4), 0);\n\n                R1 = G.add(R1, G.timesScalar(lastBase, r));\n                R2 = G.add(R2, G.timesScalar(firstBase, r));\n            }\n\n            const r1 = await G.multiExpAffine(bases.slice(0, (n-1)*sG), scalars);\n            const r2 = await G.multiExpAffine(bases.slice(sG), scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n\n            lastBase = G.fromRprLEM( bases, (n-1)*sG);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(bases, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endReadSection(fd);\n\n        return {\n            R1: R1,\n            R2: R2,\n            singularPoints: singularPoints\n        };\n\n    }\n\n    async function verifyLagrangeEvaluations(gName, tauSection, lagrangeSection, sectionName, logger) {\n\n        if (logger) logger.debug(`Verifying phase2 calculated values ${sectionName}...`);\n        const G = curve[gName];\n        const sG = G.F.n8*2;\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = _misc_js__WEBPACK_IMPORTED_MODULE_4__.readUInt32BE(_misc_js__WEBPACK_IMPORTED_MODULE_4__.getRandomBytes(4), 0);\n        }\n\n        for (let p=0; p<= power; p ++) {\n            const res = await verifyPower(p);\n            if (!res) return false;\n        }\n\n        if (tauSection == 2) {\n            const res = await verifyPower(power+1);\n            if (!res) return false;\n        }\n\n        return true;\n\n        async function verifyPower(p) {\n            if (logger) logger.debug(`Power ${p}...`);\n            const n8r = curve.Fr.n8;\n            const nPoints = 2 ** p;\n            let buff_r = new Uint32Array(nPoints);\n            let buffG;\n\n            let rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.ChaCha(seed);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((p == power+1)&&(i == nPoints-1)) {\n                    buff_r[i] = 0;\n                } else {\n                    buff_r[i] = rng.nextU32();\n                }\n            }\n\n            buff_r = new Uint8Array(buff_r.buffer, buff_r.byteOffset, buff_r.byteLength);\n\n            if (logger) logger.debug(`reading points Powers${p}...`);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startReadUniqueSection(fd, sections, tauSection);\n            buffG = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(nPoints*sG);\n            if (p == power+1) {\n                await fd.readToBuffer(buffG, 0, (nPoints-1)*sG);\n                buffG.set(curve.G1.zeroAffine, (nPoints-1)*sG);\n            } else {\n                await fd.readToBuffer(buffG, 0, nPoints*sG);\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endReadSection(fd, true);\n\n            const resTau = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p);\n\n            buff_r = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(nPoints * n8r);\n\n            rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.ChaCha(seed);\n\n            const buff4 = new Uint8Array(4);\n            const buff4V = new DataView(buff4.buffer);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((i != nPoints-1) || (p != power+1)) {\n                    buff4V.setUint32(0, rng.nextU32(), true);\n                    buff_r.set(buff4, i*n8r);\n                }\n            }\n\n            if (logger) logger.debug(`batchToMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchToMontgomery(buff_r);\n            if (logger) logger.debug(`fft ${p}...`);\n            buff_r = await curve.Fr.fft(buff_r);\n            if (logger) logger.debug(`batchFromMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchFromMontgomery(buff_r);\n\n            if (logger) logger.debug(`reading points Lagrange${p}...`);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startReadUniqueSection(fd, sections, lagrangeSection);\n            fd.pos += sG*((2 ** p)-1);\n            await fd.readToBuffer(buffG, 0, nPoints*sG);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endReadSection(fd, true);\n\n            const resLagrange = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p + \"_transformed\");\n\n            if (!G.eq(resTau, resLagrange)) {\n                if (logger) logger.error(\"Phase2 caclutation does not match with powers of tau\");\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdmVyaWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVnRDtBQUNBO0FBQ1I7QUFDWTtBQUNIO0FBQ2Y7QUFDbEMsa0JBQWtCLCtDQUFjOztBQUVoQztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGdDQUFnQyxnRUFBbUI7O0FBRW5EO0FBQ0Esc0dBQXNHLFNBQVMsRUFBRSxlQUFlO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxTQUFTLEVBQUUsZUFBZTtBQUNqSTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csU0FBUyxFQUFFLGVBQWU7QUFDbEk7QUFDQTs7QUFFQTtBQUNBLHdHQUF3RyxTQUFTLEVBQUUsZUFBZTtBQUNsSTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsU0FBUyxFQUFFLGVBQWU7QUFDbkk7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLFNBQVMsRUFBRSxlQUFlO0FBQ3BJO0FBQ0E7O0FBRUE7QUFDQSx1R0FBdUcsU0FBUyxFQUFFLGVBQWU7QUFDakk7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLFNBQVMsRUFBRSxlQUFlO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RyxTQUFTLEVBQUUsZUFBZTtBQUNuSTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLGdEQUFlO0FBQ3pELDRDQUE0QyxnREFBZTtBQUMzRCwyQ0FBMkMsZ0RBQWU7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjs7QUFFQSxXQUFXLGNBQWMsUUFBUSw0REFBd0I7QUFDekQsV0FBVyw2QkFBNkIsUUFBUSxpRUFBb0I7QUFDcEUseUJBQXlCLG9FQUF1Qjs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4RUFBaUM7QUFDeEQsc0JBQXNCLDBEQUFPLFVBQVUsV0FBVztBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxtQ0FBbUMsMERBQU8sVUFBVSxXQUFXO0FBQy9EOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpREFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQzs7QUFFQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVksSUFBSSxtQkFBbUI7O0FBRXhFLG9CQUFvQixnREFBZTs7QUFFbkM7QUFDQSxRQUFRLGtFQUFxQjs7QUFFN0IsZ0NBQWdDLHFEQUFvQjtBQUNwRDtBQUNBOztBQUVBLG9CQUFvQixnREFBZTs7QUFFbkMsb0JBQW9CLGdEQUFlOztBQUVuQztBQUNBLDZDQUE2QyxtREFBa0Isc0JBQXNCO0FBQ3JGLGtEQUFrRCwwQkFBMEI7QUFDNUU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1RUFBbUM7O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLFdBQVc7QUFDakMsMERBQTBELFlBQVksSUFBSSxFQUFFLEdBQUcsU0FBUztBQUN4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLG9EQUFtQjs7QUFFL0M7QUFDQTtBQUNBLDBCQUEwQixrREFBaUIsQ0FBQyxvREFBbUI7O0FBRS9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLCtEQUEyQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1RUFBdUUsWUFBWTtBQUNuRjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0Isc0JBQXNCLGtEQUFpQixDQUFDLG9EQUFtQjtBQUMzRDs7QUFFQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsZ0RBQU07O0FBRWhDLHNFQUFzRSxFQUFFO0FBQ3hFLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZEQUE2RCxFQUFFO0FBQy9ELGtCQUFrQix1RUFBbUM7QUFDckQsd0JBQXdCLG1EQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7QUFFN0M7O0FBRUEseUJBQXlCLG1EQUFTOztBQUVsQyxzQkFBc0IsZ0RBQU07O0FBRTVCO0FBQ0E7O0FBRUEsc0VBQXNFLEVBQUU7QUFDeEUsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsRUFBRTtBQUM1RDtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0EsNERBQTRELEVBQUU7QUFDOUQ7O0FBRUEsK0RBQStELEVBQUU7QUFDakUsa0JBQWtCLHVFQUFtQztBQUNyRDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUEyQjs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdmVyaWZ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMga2V5UGFpciBmcm9tIFwiLi9rZXlwYWlyLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7IENoYUNoYSwgQmlnQnVmZmVyIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5jb25zdCBzYW1lUmF0aW8gPSBtaXNjLnNhbWVSYXRpbztcblxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5Q29udHJpYnV0aW9uKGN1cnZlLCBjdXIsIHByZXYsIGxvZ2dlcikge1xuICAgIGxldCBzcjtcbiAgICBpZiAoY3VyLnR5cGUgPT0gMSkgeyAgICAvLyBWZXJpZnkgdGhlIGJlYWNvbi5cbiAgICAgICAgY29uc3QgYmVhY29uS2V5ID0gYXdhaXQgdXRpbHMua2V5RnJvbUJlYWNvbihjdXJ2ZSwgcHJldi5uZXh0Q2hhbGxlbmdlLCBjdXIuYmVhY29uSGFzaCwgY3VyLm51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS50YXUuZzFfcywgYmVhY29uS2V5LnRhdS5nMV9zKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5ICh0YXVHMV9zKSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkudGF1LmcxX3N4LCBiZWFjb25LZXkudGF1LmcxX3N4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5ICh0YXVHMV9zeCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXIua2V5LnRhdS5nMl9zcHgsIGJlYWNvbktleS50YXUuZzJfc3B4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5ICh0YXVHMl9zcHgpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LmFscGhhLmcxX3MsIGJlYWNvbktleS5hbHBoYS5nMV9zKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChhbHBoYUcxX3MpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS5hbHBoYS5nMV9zeCwgYmVhY29uS2V5LmFscGhhLmcxX3N4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChhbHBoYUcxX3N4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcyLmVxKGN1ci5rZXkuYWxwaGEuZzJfc3B4LCBiZWFjb25LZXkuYWxwaGEuZzJfc3B4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChhbHBoYUcyX3NweCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkuYmV0YS5nMV9zLCBiZWFjb25LZXkuYmV0YS5nMV9zKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChiZXRhRzFfcykgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LmJldGEuZzFfc3gsIGJlYWNvbktleS5iZXRhLmcxX3N4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChiZXRhRzFfc3gpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzIuZXEoY3VyLmtleS5iZXRhLmcyX3NweCwgYmVhY29uS2V5LmJldGEuZzJfc3B4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChiZXRhRzJfc3B4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGN1ci5rZXkudGF1LmcyX3NwID0gY3VydmUuRzIudG9BZmZpbmUoa2V5UGFpci5nZXRHMnNwKGN1cnZlLCAwLCBwcmV2Lm5leHRDaGFsbGVuZ2UsIGN1ci5rZXkudGF1LmcxX3MsIGN1ci5rZXkudGF1LmcxX3N4KSk7XG4gICAgY3VyLmtleS5hbHBoYS5nMl9zcCA9IGN1cnZlLkcyLnRvQWZmaW5lKGtleVBhaXIuZ2V0RzJzcChjdXJ2ZSwgMSwgcHJldi5uZXh0Q2hhbGxlbmdlLCBjdXIua2V5LmFscGhhLmcxX3MsIGN1ci5rZXkuYWxwaGEuZzFfc3gpKTtcbiAgICBjdXIua2V5LmJldGEuZzJfc3AgPSBjdXJ2ZS5HMi50b0FmZmluZShrZXlQYWlyLmdldEcyc3AoY3VydmUsIDIsIHByZXYubmV4dENoYWxsZW5nZSwgY3VyLmtleS5iZXRhLmcxX3MsIGN1ci5rZXkuYmV0YS5nMV9zeCkpO1xuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIGN1ci5rZXkudGF1LmcxX3MsIGN1ci5rZXkudGF1LmcxX3N4LCBjdXIua2V5LnRhdS5nMl9zcCwgY3VyLmtleS50YXUuZzJfc3B4KTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCBrZXkgKHRhdSkgaW4gY2hhbGxlbmdlICNcIitjdXIuaWQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIGN1ci5rZXkuYWxwaGEuZzFfcywgY3VyLmtleS5hbHBoYS5nMV9zeCwgY3VyLmtleS5hbHBoYS5nMl9zcCwgY3VyLmtleS5hbHBoYS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGtleSAoYWxwaGEpIGluIGNoYWxsZW5nZSAjXCIrY3VyLmlkKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXIua2V5LmJldGEuZzFfcywgY3VyLmtleS5iZXRhLmcxX3N4LCBjdXIua2V5LmJldGEuZzJfc3AsIGN1ci5rZXkuYmV0YS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGtleSAoYmV0YSkgaW4gY2hhbGxlbmdlICNcIitjdXIuaWQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIHByZXYudGF1RzEsIGN1ci50YXVHMSwgY3VyLmtleS50YXUuZzJfc3AsIGN1ci5rZXkudGF1LmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgdGF1KkcxLiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCtcIiBJdCBkb2VzIG5vdCBmb2xsb3cgdGhlIHByZXZpb3VzIGNvbnRyaWJ1dGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCAgY3VyLmtleS50YXUuZzFfcywgY3VyLmtleS50YXUuZzFfc3gsIHByZXYudGF1RzIsIGN1ci50YXVHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgdGF1KkcyLiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCtcIiBJdCBkb2VzIG5vdCBmb2xsb3cgdGhlIHByZXZpb3VzIGNvbnRyaWJ1dGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBwcmV2LmFscGhhRzEsIGN1ci5hbHBoYUcxLCBjdXIua2V5LmFscGhhLmcyX3NwLCBjdXIua2V5LmFscGhhLmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgYWxwaGEqRzEuIGNoYWxsZW5nZSAjXCIrY3VyLmlkK1wiIEl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIHByZXYuYmV0YUcxLCBjdXIuYmV0YUcxLCBjdXIua2V5LmJldGEuZzJfc3AsIGN1ci5rZXkuYmV0YS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGJldGEqRzEuIGNoYWxsZW5nZSAjXCIrY3VyLmlkK1wiIEl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsICBjdXIua2V5LmJldGEuZzFfcywgY3VyLmtleS5iZXRhLmcxX3N4LCBwcmV2LmJldGFHMiwgY3VyLmJldGFHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgYmV0YSpHMi4gY2hhbGxlbmdlICNcIitjdXIuaWQrXCJJdCBkb2VzIG5vdCBmb2xsb3cgdGhlIHByZXZpb3VzIGNvbnRyaWJ1dGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUG93ZXJzIE9mIHRhdSBmaWxlIE9LIVwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5KHRhdUZpbGVuYW1lLCBsb2dnZXIpIHtcbiAgICBsZXQgc3I7XG5cbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmQsIHNlY3Rpb25zKTtcbiAgICBjb25zdCBjb250cnMgPSBhd2FpdCB1dGlscy5yZWFkQ29udHJpYnV0aW9ucyhmZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcInBvd2VyOiAyKipcIiArIHBvd2VyKTtcbiAgICAvLyBWZXJpZnkgTGFzdCBjb250cmlidXRpb25cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNvbXB1dGluZyBpbml0aWFsIGNvbnRyaWJ1dGlvbiBoYXNoXCIpO1xuICAgIGNvbnN0IGluaXRpYWxDb250cmlidXRpb24gPSB7XG4gICAgICAgIHRhdUcxOiBjdXJ2ZS5HMS5nLFxuICAgICAgICB0YXVHMjogY3VydmUuRzIuZyxcbiAgICAgICAgYWxwaGFHMTogY3VydmUuRzEuZyxcbiAgICAgICAgYmV0YUcxOiBjdXJ2ZS5HMS5nLFxuICAgICAgICBiZXRhRzI6IGN1cnZlLkcyLmcsXG4gICAgICAgIG5leHRDaGFsbGVuZ2U6IHV0aWxzLmNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgY2VyZW1vbnlQb3dlciwgbG9nZ2VyKSxcbiAgICAgICAgcmVzcG9uc2VIYXNoOiBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KS5kaWdlc3QoKVxuICAgIH07XG5cbiAgICBpZiAoY29udHJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlRoaXMgZmlsZSBoYXMgbm8gY29udHJpYnV0aW9uISBJdCBjYW5ub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHByZXZDb250cjtcbiAgICBpZiAoY29udHJzLmxlbmd0aD4xKSB7XG4gICAgICAgIHByZXZDb250ciA9IGNvbnRyc1tjb250cnMubGVuZ3RoLTJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZDb250ciA9IGluaXRpYWxDb250cmlidXRpb247XG4gICAgfVxuICAgIGNvbnN0IGN1ckNvbnRyID0gY29udHJzW2NvbnRycy5sZW5ndGgtMV07XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmFsaWRhdGluZyBjb250cmlidXRpb24gI1wiK2NvbnRyc1tjb250cnMubGVuZ3RoLTFdLmlkKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcblxuXG4gICAgY29uc3QgbmV4dENvbnRyaWJ1dGlvbkhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIG5leHRDb250cmlidXRpb25IYXNoZXIudXBkYXRlKGN1ckNvbnRyLnJlc3BvbnNlSGFzaCk7XG5cbiAgICAvLyBWZXJpZnkgcG93ZXJzIGFuZCBjb21wdXRlIG5leHRDaGFsbGVuZ2VIYXNoXG5cbiAgICAvLyBhd2FpdCB0ZXN0KCk7XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiB0YXUqRzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIHRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJUYXUxID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgXCJHMVwiLCBcInRhdUcxXCIsICgyICoqIHBvd2VyKSoyLTEsIFswLCAxXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgclRhdTEuUjEsIHJUYXUxLlIyLCBjdXJ2ZS5HMi5nLCBjdXJDb250ci50YXVHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcInRhdUcxIHNlY3Rpb24uIFBvd2VycyBkbyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXJ2ZS5HMS5nLCByVGF1MS5zaW5ndWxhclBvaW50c1swXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiRmlyc3QgZWxlbWVudCBvZiB0YXUqRzEgc2VjdGlvbiBtdXN0IGJlIHRoZSBnZW5lcmF0b3JcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXJDb250ci50YXVHMSwgclRhdTEuc2luZ3VsYXJQb2ludHNbMV0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlNlY29uZCBlbGVtZW50IG9mIHRhdSpHMSBzZWN0aW9uIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYXdhaXQgdGVzdCgpO1xuXG4gICAgLy8gVmVyaWZ5IFNlY3Rpb24gdGF1KkcyXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiB0YXUqRzIgc2VjdGlvblwiKTtcbiAgICBjb25zdCByVGF1MiA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIFwiRzJcIiwgXCJ0YXVHMlwiLCAyICoqIHBvd2VyLCBbMCwgMV0sICBsb2dnZXIpO1xuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJ2ZS5HMS5nLCBjdXJDb250ci50YXVHMSwgclRhdTIuUjEsIHJUYXUyLlIyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwidGF1RzIgc2VjdGlvbi4gUG93ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKGN1cnZlLkcyLmcsIHJUYXUyLnNpbmd1bGFyUG9pbnRzWzBdKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJGaXJzdCBlbGVtZW50IG9mIHRhdSpHMiBzZWN0aW9uIG11c3QgYmUgdGhlIGdlbmVyYXRvclwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKGN1ckNvbnRyLnRhdUcyLCByVGF1Mi5zaW5ndWxhclBvaW50c1sxXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiU2Vjb25kIGVsZW1lbnQgb2YgdGF1KkcyIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2ggdGhlIG9uZSBpbiB0aGUgY29udHJpYnV0aW9uIHNlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiBhbHBoYSp0YXUqRzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIGFscGhhKnRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJBbHBoYVRhdUcxID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNCwgXCJHMVwiLCBcImFscGhhdGF1RzFcIiwgMiAqKiBwb3dlciwgWzBdLCBsb2dnZXIpO1xuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCByQWxwaGFUYXVHMS5SMSwgckFscGhhVGF1RzEuUjIsIGN1cnZlLkcyLmcsIGN1ckNvbnRyLnRhdUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiYWxwaGFUYXVHMSBzZWN0aW9uLiBQb3dlcnMgZG8gbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoY3VyQ29udHIuYWxwaGFHMSwgckFscGhhVGF1RzEuc2luZ3VsYXJQb2ludHNbMF0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkZpcnN0IGVsZW1lbnQgb2YgYWxwaGEqdGF1KkcxIHNlY3Rpb24gKGFscGhhKkcxKSBkb2VzIG5vdCBtYXRjaCB0aGUgb25lIGluIHRoZSBjb250cmlidXRpb24gc2VjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSBTZWN0aW9uIGJldGEqdGF1KkcxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiBiZXRhKnRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJCZXRhVGF1RzEgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig1LCBcIkcxXCIsIFwiYmV0YXRhdUcxXCIsIDIgKiogcG93ZXIsIFswXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgckJldGFUYXVHMS5SMSwgckJldGFUYXVHMS5SMiwgY3VydmUuRzIuZywgY3VyQ29udHIudGF1RzIpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJiZXRhVGF1RzEgc2VjdGlvbi4gUG93ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ckNvbnRyLmJldGFHMSwgckJldGFUYXVHMS5zaW5ndWxhclBvaW50c1swXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiRmlyc3QgZWxlbWVudCBvZiBiZXRhKnRhdSpHMSBzZWN0aW9uIChiZXRhKkcxKSBkb2VzIG5vdCBtYXRjaCB0aGUgb25lIGluIHRoZSBjb250cmlidXRpb24gc2VjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vVmVyaWZ5IEJldGEgRzJcbiAgICBjb25zdCBiZXRhRzIgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbkJldGFHMihsb2dnZXIpO1xuICAgIGlmICghY3VydmUuRzIuZXEoY3VyQ29udHIuYmV0YUcyLCBiZXRhRzIpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcImJldGFHMiBlbGVtZW50IGluIGJldGFHMiBzZWN0aW9uIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBjb25zdCBuZXh0Q29udHJpYnV0aW9uSGFzaCA9IG5leHRDb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICAvLyBDaGVjayB0aGUgbmV4dENoYWxsZW5nZUhhc2hcbiAgICBpZiAocG93ZXIgPT0gY2VyZW1vbnlQb3dlcikge1xuICAgICAgICBpZiAoIW1pc2MuaGFzaElzRXF1YWwobmV4dENvbnRyaWJ1dGlvbkhhc2gsY3VyQ29udHIubmV4dENoYWxsZW5nZSkpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkhhc2ggb2YgdGhlIHZhbHVlcyBkb2VzIG5vdCBtYXRjaCB0aGUgbmV4dCBjaGFsbGVuZ2Ugb2YgdGhlIGxhc3QgY29udHJpYnV0b3IgaW4gdGhlIGNvbnRyaWJ1dGlvbnMgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChuZXh0Q29udHJpYnV0aW9uSGFzaCwgXCJOZXh0IGNoYWxsZW5nZSBoYXNoOiBcIikpO1xuXG4gICAgLy8gVmVyaWZ5IFByZXZpb3VzIGNvbnRyaWJ1dGlvbnNcblxuICAgIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIpO1xuICAgIGZvciAobGV0IGkgPSBjb250cnMubGVuZ3RoLTI7IGk+PTA7IGktLSkge1xuICAgICAgICBjb25zdCBjdXJDb250ciA9IGNvbnRyc1tpXTtcbiAgICAgICAgY29uc3QgcHJldkNvbnRyID0gIChpPjApID8gY29udHJzW2ktMV0gOiBpbml0aWFsQ29udHJpYnV0aW9uO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgfVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG5cbiAgICBpZiAoKCFzZWN0aW9uc1sxMl0pIHx8ICghc2VjdGlvbnNbMTNdKSB8fCAoIXNlY3Rpb25zWzE0XSkgfHwgKCFzZWN0aW9uc1sxNV0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgXCJ0aGlzIGZpbGUgZG9lcyBub3QgY29udGFpbiBwaGFzZTIgcHJlY2FsY3VsYXRlZCB2YWx1ZXMuIFBsZWFzZSBydW46IFxcblwiICtcbiAgICAgICAgICAgIFwiICAgc25hcmtqcyBcXFwicG93ZXJzb2Z0YXUgcHJlcGFyZXBoYXNlMlxcXCIgdG8gcHJlcGFyZSB0aGlzIGZpbGUgdG8gYmUgdXNlZCBpbiB0aGUgcGhhc2UyIGNlcmVtb255LlwiXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgcmVzID0gYXdhaXQgdmVyaWZ5TGFncmFuZ2VFdmFsdWF0aW9ucyhcIkcxXCIsIDIsIDEyLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJlcyA9IGF3YWl0IHZlcmlmeUxhZ3JhbmdlRXZhbHVhdGlvbnMoXCJHMlwiLCAzLCAxMywgXCJ0YXVHMlwiLCBsb2dnZXIpO1xuICAgICAgICBpZiAoIXJlcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXMgPSBhd2FpdCB2ZXJpZnlMYWdyYW5nZUV2YWx1YXRpb25zKFwiRzFcIiwgNCwgMTQsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgICAgICBpZiAoIXJlcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXMgPSBhd2FpdCB2ZXJpZnlMYWdyYW5nZUV2YWx1YXRpb25zKFwiRzFcIiwgNSwgMTUsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUG93ZXJzIG9mIFRhdSBPayFcIik7XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIpIHtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHJldHVybjtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYENvbnRyaWJ1dGlvbiAjJHtjdXJDb250ci5pZH06ICR7Y3VyQ29udHIubmFtZSB8fFwiXCJ9YCk7XG5cbiAgICAgICAgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGN1ckNvbnRyLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2U6IFwiKSk7XG5cbiAgICAgICAgY29uc3QgYnVmZlYgID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKjYrY3VydmUuRzIuRi5uOCoyKjMpO1xuICAgICAgICB1dGlscy50b1B0YXVQdWJLZXlScHIoYnVmZlYsIDAsIGN1cnZlLCBjdXJDb250ci5rZXksIGZhbHNlKTtcblxuICAgICAgICBjb25zdCByZXNwb25zZUhhc2hlciA9ICBtaXNjLmZyb21QYXJ0aWFsSGFzaChjdXJDb250ci5wYXJ0aWFsSGFzaCk7XG4gICAgICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmVik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGFzaCA9IHJlc3BvbnNlSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgICAgIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChyZXNwb25zZUhhc2gsIFwiUmVzcG9uc2UgSGFzaDpcIikpO1xuXG4gICAgICAgIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChwcmV2Q29udHIubmV4dENoYWxsZW5nZSwgXCJSZXNwb25zZSBIYXNoOlwiKSk7XG5cbiAgICAgICAgaWYgKGN1ckNvbnRyLnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEJlYWNvbiBnZW5lcmF0b3I6ICR7bWlzYy5ieXRlQXJyYXkyaGV4KGN1ckNvbnRyLmJlYWNvbkhhc2gpfWApO1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEJlYWNvbiBpdGVyYXRpb25zIEV4cDogJHtjdXJDb250ci5udW1JdGVyYXRpb25zRXhwfWApO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbkJldGFHMihsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlLkcyO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBidWZmVXYgPSBuZXcgVWludDhBcnJheShzRyk7XG5cbiAgICAgICAgaWYgKCFzZWN0aW9uc1s2XSkgIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkZpbGUgaGFzIG5vIEJldGFHMiBzZWN0aW9uXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlsZSBoYXMgbm8gQmV0YUcyIHNlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25zWzZdLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGaWxlIGhhcyBubyBCZXRhRzIgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGUgaGFzIG1vcmUgdGhhbiBvbmUgR2V0YUcyIHNlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZmQucG9zID0gc2VjdGlvbnNbNl1bMF0ucDtcblxuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRyk7XG4gICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJMRU0oYnVmZik7XG5cbiAgICAgICAgRy50b1JwclVuY29tcHJlc3NlZChidWZmVXYsIDAsIFApO1xuICAgICAgICBuZXh0Q29udHJpYnV0aW9uSGFzaGVyLnVwZGF0ZShidWZmVXYpO1xuXG4gICAgICAgIHJldHVybiBQO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uKGlkU2VjdGlvbiwgZ3JvdXBOYW1lLCBzZWN0aW9uTmFtZSwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDE8PDE2O1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBpZFNlY3Rpb24pO1xuXG4gICAgICAgIGNvbnN0IHNpbmd1bGFyUG9pbnRzID0gW107XG5cbiAgICAgICAgbGV0IFIxID0gRy56ZXJvO1xuICAgICAgICBsZXQgUjIgPSBHLnplcm87XG5cbiAgICAgICAgbGV0IGxhc3RCYXNlID0gRy56ZXJvO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHBvaW50cyByZWxhdGlvbnM6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c30gYCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzID0gYXdhaXQgZmQucmVhZChuKnNHKTtcblxuICAgICAgICAgICAgY29uc3QgYmFzZXNVID0gYXdhaXQgRy5iYXRjaExFTXRvVShiYXNlcyk7XG4gICAgICAgICAgICBuZXh0Q29udHJpYnV0aW9uSGFzaGVyLnVwZGF0ZShiYXNlc1UpO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsYXJzID0gbWlzYy5nZXRSYW5kb21CeXRlcyg0KihuLTEpKTtcblxuICAgICAgICAgICAgaWYgKGk+MCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0QmFzZSA9IEcuZnJvbVJwckxFTShiYXNlcywgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IG1pc2MucmVhZFVJbnQzMkJFKG1pc2MuZ2V0UmFuZG9tQnl0ZXMoNCksIDApO1xuXG4gICAgICAgICAgICAgICAgUjEgPSBHLmFkZChSMSwgRy50aW1lc1NjYWxhcihsYXN0QmFzZSwgcikpO1xuICAgICAgICAgICAgICAgIFIyID0gRy5hZGQoUjIsIEcudGltZXNTY2FsYXIoZmlyc3RCYXNlLCByKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHIxID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiYXNlcy5zbGljZSgwLCAobi0xKSpzRyksIHNjYWxhcnMpO1xuICAgICAgICAgICAgY29uc3QgcjIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJhc2VzLnNsaWNlKHNHKSwgc2NhbGFycyk7XG5cbiAgICAgICAgICAgIFIxID0gRy5hZGQoUjEsIHIxKTtcbiAgICAgICAgICAgIFIyID0gRy5hZGQoUjIsIHIyKTtcblxuICAgICAgICAgICAgbGFzdEJhc2UgPSBHLmZyb21ScHJMRU0oIGJhc2VzLCAobi0xKSpzRyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxzaW5ndWxhclBvaW50SW5kZXhlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwID0gc2luZ3VsYXJQb2ludEluZGV4ZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKChzcCA+PWkpICYmIChzcCA8IGkrbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgUCA9IEcuZnJvbVJwckxFTShiYXNlcywgKHNwLWkpKnNHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBSMTogUjEsXG4gICAgICAgICAgICBSMjogUjIsXG4gICAgICAgICAgICBzaW5ndWxhclBvaW50czogc2luZ3VsYXJQb2ludHNcbiAgICAgICAgfTtcblxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHZlcmlmeUxhZ3JhbmdlRXZhbHVhdGlvbnMoZ05hbWUsIHRhdVNlY3Rpb24sIGxhZ3JhbmdlU2VjdGlvbiwgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgVmVyaWZ5aW5nIHBoYXNlMiBjYWxjdWxhdGVkIHZhbHVlcyAke3NlY3Rpb25OYW1lfS4uLmApO1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ05hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHNlZWQ9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDg7IGkrKykge1xuICAgICAgICAgICAgc2VlZFtpXSA9IG1pc2MucmVhZFVJbnQzMkJFKG1pc2MuZ2V0UmFuZG9tQnl0ZXMoNCksIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcD0wOyBwPD0gcG93ZXI7IHAgKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHZlcmlmeVBvd2VyKHApO1xuICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXVTZWN0aW9uID09IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHZlcmlmeVBvd2VyKHBvd2VyKzEpO1xuICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBvd2VyKHApIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgUG93ZXIgJHtwfS4uLmApO1xuICAgICAgICAgICAgY29uc3QgbjhyID0gY3VydmUuRnIubjg7XG4gICAgICAgICAgICBjb25zdCBuUG9pbnRzID0gMiAqKiBwO1xuICAgICAgICAgICAgbGV0IGJ1ZmZfciA9IG5ldyBVaW50MzJBcnJheShuUG9pbnRzKTtcbiAgICAgICAgICAgIGxldCBidWZmRztcblxuICAgICAgICAgICAgbGV0IHJuZyA9IG5ldyBDaGFDaGEoc2VlZCk7XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgQ3JlYXRpbmcgcmFuZG9tIG51bWJlcnMgUG93ZXJzJHtwfS4uLmApO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgocCA9PSBwb3dlcisxKSYmKGkgPT0gblBvaW50cy0xKSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmX3JbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZfcltpXSA9IHJuZy5uZXh0VTMyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWZmX3IgPSBuZXcgVWludDhBcnJheShidWZmX3IuYnVmZmVyLCBidWZmX3IuYnl0ZU9mZnNldCwgYnVmZl9yLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHJlYWRpbmcgcG9pbnRzIFBvd2VycyR7cH0uLi5gKTtcbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgdGF1U2VjdGlvbik7XG4gICAgICAgICAgICBidWZmRyA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzRyk7XG4gICAgICAgICAgICBpZiAocCA9PSBwb3dlcisxKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmQucmVhZFRvQnVmZmVyKGJ1ZmZHLCAwLCAoblBvaW50cy0xKSpzRyk7XG4gICAgICAgICAgICAgICAgYnVmZkcuc2V0KGN1cnZlLkcxLnplcm9BZmZpbmUsIChuUG9pbnRzLTEpKnNHKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmQucmVhZFRvQnVmZmVyKGJ1ZmZHLCAwLCBuUG9pbnRzKnNHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc1RhdSA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZkcsIGJ1ZmZfciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiX1wiICsgcCk7XG5cbiAgICAgICAgICAgIGJ1ZmZfciA9IG5ldyBCaWdCdWZmZXIoblBvaW50cyAqIG44cik7XG5cbiAgICAgICAgICAgIHJuZyA9IG5ldyBDaGFDaGEoc2VlZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmY0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgICAgICBjb25zdCBidWZmNFYgPSBuZXcgRGF0YVZpZXcoYnVmZjQuYnVmZmVyKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBDcmVhdGluZyByYW5kb20gbnVtYmVycyBQb3dlcnMke3B9Li4uYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChpICE9IG5Qb2ludHMtMSkgfHwgKHAgIT0gcG93ZXIrMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZjRWLnNldFVpbnQzMigwLCBybmcubmV4dFUzMigpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZl9yLnNldChidWZmNCwgaSpuOHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBiYXRjaFRvTW9udGdvbWVyeSAke3B9Li4uYCk7XG4gICAgICAgICAgICBidWZmX3IgPSBhd2FpdCBjdXJ2ZS5Gci5iYXRjaFRvTW9udGdvbWVyeShidWZmX3IpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBmZnQgJHtwfS4uLmApO1xuICAgICAgICAgICAgYnVmZl9yID0gYXdhaXQgY3VydmUuRnIuZmZ0KGJ1ZmZfcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYGJhdGNoRnJvbU1vbnRnb21lcnkgJHtwfS4uLmApO1xuICAgICAgICAgICAgYnVmZl9yID0gYXdhaXQgY3VydmUuRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShidWZmX3IpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHJlYWRpbmcgcG9pbnRzIExhZ3JhbmdlJHtwfS4uLmApO1xuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBsYWdyYW5nZVNlY3Rpb24pO1xuICAgICAgICAgICAgZmQucG9zICs9IHNHKigoMiAqKiBwKS0xKTtcbiAgICAgICAgICAgIGF3YWl0IGZkLnJlYWRUb0J1ZmZlcihidWZmRywgMCwgblBvaW50cypzRyk7XG4gICAgICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQsIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCByZXNMYWdyYW5nZSA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZkcsIGJ1ZmZfciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiX1wiICsgcCArIFwiX3RyYW5zZm9ybWVkXCIpO1xuXG4gICAgICAgICAgICBpZiAoIUcuZXEocmVzVGF1LCByZXNMYWdyYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQaGFzZTIgY2FjbHV0YXRpb24gZG9lcyBub3QgbWF0Y2ggd2l0aCBwb3dlcnMgb2YgdGF1XCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/powersoftau_verify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/proof.js":
/*!*******************************************!*\
  !*** ./node_modules/snarkjs/src/proof.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Proof: () => (/* binding */ Proof)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass Proof {\n    constructor(curve, logger) {\n        this.curve = curve;\n        this.logger = logger;\n\n        this.resetProof();\n    }\n\n    resetProof() {\n        this.polynomials = {};\n        this.evaluations = {};\n    }\n\n    addPolynomial(key, polynomial) {\n        if (key in this.polynomials) {\n            this.logger.warn(`proof: polynomial.${key} already exist in proof`);\n        }\n        this.polynomials[key] = polynomial;\n    }\n\n    getPolynomial(key) {\n        if (!(key in this.polynomials)) {\n            this.logger.warn(`proof: polynomial ${key} does not exist in proof`);\n        }\n        return this.polynomials[key];\n    }\n\n    addEvaluation(key, evaluation) {\n        if (key in this.evaluations) {\n            this.logger.warn(`proof: evaluations.${key} already exist in proof`);\n        }\n        this.evaluations[key] = evaluation;\n    }\n\n    getEvaluation(key) {\n        if (!(key in this.evaluations)) {\n            this.logger.warn(`proof: evaluation ${key} does not exist in proof`);\n        }\n        return this.evaluations[key];\n    }\n\n    toObjectProof(splitFields = true) {\n        let res = splitFields ? {polynomials: {}, evaluations: {}} : {};\n\n        Object.keys(this.polynomials).forEach(key => {\n            const value = this.curve.G1.toObject(this.polynomials[key]);\n            if(splitFields) {\n                res.polynomials[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        Object.keys(this.evaluations).forEach(key => {\n            const value = this.curve.Fr.toObject(this.evaluations[key]);\n            if(splitFields) {\n                res.evaluations[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        return res;\n    }\n\n    fromObjectProof(objectProof) {\n        this.resetProof();\n\n        Object.keys(objectProof.polynomials).forEach(key => {\n            this.polynomials[key] = this.curve.G1.fromObject(objectProof.polynomials[key]);\n        });\n\n        Object.keys(objectProof.evaluations).forEach(key => {\n            this.evaluations[key] = this.curve.Fr.fromObject(objectProof.evaluations[key]);\n        });\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcHJvb2YuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGVBQWUsbUJBQW1COztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Byb29mLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBjbGFzcyBQcm9vZiB7XG4gICAgY29uc3RydWN0b3IoY3VydmUsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmN1cnZlID0gY3VydmU7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuXG4gICAgICAgIHRoaXMucmVzZXRQcm9vZigpO1xuICAgIH1cblxuICAgIHJlc2V0UHJvb2YoKSB7XG4gICAgICAgIHRoaXMucG9seW5vbWlhbHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmFsdWF0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGFkZFBvbHlub21pYWwoa2V5LCBwb2x5bm9taWFsKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5wb2x5bm9taWFscykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcHJvb2Y6IHBvbHlub21pYWwuJHtrZXl9IGFscmVhZHkgZXhpc3QgaW4gcHJvb2ZgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvbHlub21pYWxzW2tleV0gPSBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIGdldFBvbHlub21pYWwoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzLnBvbHlub21pYWxzKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcHJvb2Y6IHBvbHlub21pYWwgJHtrZXl9IGRvZXMgbm90IGV4aXN0IGluIHByb29mYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9seW5vbWlhbHNba2V5XTtcbiAgICB9XG5cbiAgICBhZGRFdmFsdWF0aW9uKGtleSwgZXZhbHVhdGlvbikge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuZXZhbHVhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHByb29mOiBldmFsdWF0aW9ucy4ke2tleX0gYWxyZWFkeSBleGlzdCBpbiBwcm9vZmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZhbHVhdGlvbnNba2V5XSA9IGV2YWx1YXRpb247XG4gICAgfVxuXG4gICAgZ2V0RXZhbHVhdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuZXZhbHVhdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBwcm9vZjogZXZhbHVhdGlvbiAke2tleX0gZG9lcyBub3QgZXhpc3QgaW4gcHJvb2ZgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0aW9uc1trZXldO1xuICAgIH1cblxuICAgIHRvT2JqZWN0UHJvb2Yoc3BsaXRGaWVsZHMgPSB0cnVlKSB7XG4gICAgICAgIGxldCByZXMgPSBzcGxpdEZpZWxkcyA/IHtwb2x5bm9taWFsczoge30sIGV2YWx1YXRpb25zOiB7fX0gOiB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnBvbHlub21pYWxzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY3VydmUuRzEudG9PYmplY3QodGhpcy5wb2x5bm9taWFsc1trZXldKTtcbiAgICAgICAgICAgIGlmKHNwbGl0RmllbGRzKSB7XG4gICAgICAgICAgICAgICAgcmVzLnBvbHlub21pYWxzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ldmFsdWF0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmN1cnZlLkZyLnRvT2JqZWN0KHRoaXMuZXZhbHVhdGlvbnNba2V5XSk7XG4gICAgICAgICAgICBpZihzcGxpdEZpZWxkcykge1xuICAgICAgICAgICAgICAgIHJlcy5ldmFsdWF0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnJvbU9iamVjdFByb29mKG9iamVjdFByb29mKSB7XG4gICAgICAgIHRoaXMucmVzZXRQcm9vZigpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdFByb29mLnBvbHlub21pYWxzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvbHlub21pYWxzW2tleV0gPSB0aGlzLmN1cnZlLkcxLmZyb21PYmplY3Qob2JqZWN0UHJvb2YucG9seW5vbWlhbHNba2V5XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdFByb29mLmV2YWx1YXRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2YWx1YXRpb25zW2tleV0gPSB0aGlzLmN1cnZlLkZyLmZyb21PYmplY3Qob2JqZWN0UHJvb2YuZXZhbHVhdGlvbnNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/proof.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/r1cs.js":
/*!******************************************!*\
  !*** ./node_modules/snarkjs/src/r1cs.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportJson: () => (/* reexport safe */ _r1cs_export_json_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   info: () => (/* reexport safe */ _r1cs_info_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   print: () => (/* reexport safe */ _r1cs_print_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _r1cs_print_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./r1cs_print.js */ \"(ssr)/./node_modules/snarkjs/src/r1cs_print.js\");\n/* harmony import */ var _r1cs_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./r1cs_info.js */ \"(ssr)/./node_modules/snarkjs/src/r1cs_info.js\");\n/* harmony import */ var _r1cs_export_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./r1cs_export_json.js */ \"(ssr)/./node_modules/snarkjs/src/r1cs_export_json.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVpRDtBQUNGO0FBQ2EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQge2RlZmF1bHQgYXMgcHJpbnR9IGZyb20gXCIuL3IxY3NfcHJpbnQuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbmZvfSBmcm9tIFwiLi9yMWNzX2luZm8uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRKc29ufSBmcm9tIFwiLi9yMWNzX2V4cG9ydF9qc29uLmpzXCI7XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/r1cs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/r1cs_constraint_processor.js":
/*!***************************************************************!*\
  !*** ./node_modules/snarkjs/src/r1cs_constraint_processor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   r1csConstraintProcessor: () => (/* binding */ r1csConstraintProcessor)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst LINEAR_COMBINATION_NULLABLE = 0;\nconst LINEAR_COMBINATION_CONSTANT = 1;\nconst LINEAR_COMBINATION_VARIABLE = 2;\n\nclass r1csConstraintProcessor {\n    constructor(Fr, fnGetConstantConstraint, fnGetAdditionConstraint, fnGetMultiplicationConstraint, logger) {\n        this.Fr = Fr;\n        this.logger = logger;\n        this.fnGetAdditionConstraint = fnGetAdditionConstraint;\n        this.fnGetMultiplicationConstraint = fnGetMultiplicationConstraint;\n    }\n\n    processR1csConstraint(settings, lcA, lcB, lcC) {\n        this.normalizeLinearCombination(lcA);\n        this.normalizeLinearCombination(lcB);\n        this.normalizeLinearCombination(lcC);\n\n        const lctA = this.getLinearCombinationType(lcA);\n        const lctB = this.getLinearCombinationType(lcB);\n\n        if ((lctA === LINEAR_COMBINATION_NULLABLE) || (lctB === LINEAR_COMBINATION_NULLABLE)) {\n            return this.processR1csAdditionConstraint(settings, lcC);\n        } else if (lctA === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcB, lcC, lcA[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else if (lctB === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcA, lcC, lcB[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else {\n            return this.processR1csMultiplicationConstraint(settings, lcA, lcB, lcC);\n        }\n    }\n\n    getLinearCombinationType(linCom) {\n        // let k = this.Fr.zero;\n        //\n        // const signalIds = Object.keys(linCom);\n        // for (let i = 0; i < signalIds.length; i++) {\n        //     if (signalIds[i] === \"0\") {\n        //         k = this.Fr.add(k, linCom[signalIds[i]]);\n        //     } else {\n        //         return LINEAR_COMBINATION_VARIABLE;\n        //     }\n        // }\n        //\n        // if (!this.Fr.eq(k, this.Fr.zero)) return LINEAR_COMBINATION_CONSTANT;\n        //\n        // return LINEAR_COMBINATION_NULLABLE;\n\n        let k = this.Fr.zero;\n        let n = 0;\n        const ss = Object.keys(linCom);\n        for (let i = 0; i < ss.length; i++) {\n            if (linCom[ss[i]] == 0n) {\n                delete linCom[ss[i]];\n            } else if (ss[i] == 0) {\n                k = this.Fr.add(k, linCom[ss[i]]);\n            } else {\n                n++;\n            }\n        }\n        if (n > 0) return LINEAR_COMBINATION_VARIABLE;\n        if (!this.Fr.isZero(k)) return LINEAR_COMBINATION_CONSTANT;\n        return LINEAR_COMBINATION_NULLABLE;\n    }\n\n    normalizeLinearCombination(linCom) {\n        const signalIds = Object.keys(linCom);\n        for (let i = 0; i < signalIds.length; i++) {\n            if (this.Fr.isZero(linCom[signalIds[i]])) delete linCom[signalIds[i]];\n        }\n\n        return linCom;\n    }\n\n    joinLinearCombinations(linCom1, linCom2, k) {\n        const res = {};\n\n        for (let s in linCom1) {\n            if (typeof res[s] == \"undefined\") {\n                res[s] = this.Fr.mul(k, linCom1[s]);\n            } else {\n                res[s] = this.Fr.add(res[s], this.Fr.mul(k, linCom1[s]));\n            }\n        }\n\n        for (let s in linCom2) {\n            const val = this.Fr.neg(linCom2[s]);\n            if (typeof res[s] == \"undefined\") {\n                res[s] = val;\n            } else {\n                res[s] = this.Fr.add(res[s], val);\n            }\n        }\n\n        return this.normalizeLinearCombination(res);\n    }\n\n    reduceCoefs(settings, constraintsArr, additionsArr, linCom, maxC) {\n        const res = {\n            k: this.Fr.zero,\n            signals: [],\n            coefs: []\n        };\n        const cs = [];\n\n        for (let signalId in linCom) {\n            if (signalId == 0) {\n                res.k = this.Fr.add(res.k, linCom[signalId]);\n            } else if (linCom[signalId] != 0n) {\n                cs.push([Number(signalId), linCom[signalId]]);\n            }\n        }\n\n        while (cs.length > maxC) {\n            const c1 = cs.shift();\n            const c2 = cs.shift();\n            const so = settings.nVars++;\n\n            const constraints = this.fnGetAdditionConstraint(\n                c1[0], c2[0], so,\n                this.Fr.neg(c1[1]), this.Fr.neg(c2[1]), this.Fr.zero, this.Fr.one, this.Fr.zero);\n\n            constraintsArr.push(constraints);\n            additionsArr.push([c1[0], c2[0], c1[1], c2[1]]);\n\n            cs.push([so, this.Fr.one]);\n        }\n\n        for (let i = 0; i < cs.length; i++) {\n            res.signals[i] = cs[i][0];\n            res.coefs[i] = cs[i][1];\n        }\n\n        while (res.coefs.length < maxC) {\n            res.signals.push(0);\n            res.coefs.push(this.Fr.zero);\n        }\n\n        return res;\n    }\n\n    processR1csAdditionConstraint(settings, linCom) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, linCom, 3);\n\n        const constraints = this.fnGetAdditionConstraint(\n            C.signals[0], C.signals[1], C.signals[2],\n            C.coefs[0], C.coefs[1], this.Fr.zero, C.coefs[2], C.k);\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n\n    processR1csMultiplicationConstraint(settings, lcA, lcB, lcC) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const A = this.reduceCoefs(settings, constraintsArr, additionsArr, lcA, 1);\n        const B = this.reduceCoefs(settings, constraintsArr, additionsArr, lcB, 1);\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, lcC, 1);\n\n        const constraints = this.fnGetMultiplicationConstraint(\n            A.signals[0], B.signals[0], C.signals[0],\n            this.Fr.mul(A.coefs[0], B.k),\n            this.Fr.mul(A.k, B.coefs[0]),\n            this.Fr.mul(A.coefs[0], B.coefs[0]),\n            this.Fr.neg(C.coefs[0]),\n            this.Fr.sub(this.Fr.mul(A.k, B.k), C.k));\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19jb25zdHJhaW50X3Byb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19jb25zdHJhaW50X3Byb2Nlc3Nvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUgPSAwO1xuY29uc3QgTElORUFSX0NPTUJJTkFUSU9OX0NPTlNUQU5UID0gMTtcbmNvbnN0IExJTkVBUl9DT01CSU5BVElPTl9WQVJJQUJMRSA9IDI7XG5cbmV4cG9ydCBjbGFzcyByMWNzQ29uc3RyYWludFByb2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IoRnIsIGZuR2V0Q29uc3RhbnRDb25zdHJhaW50LCBmbkdldEFkZGl0aW9uQ29uc3RyYWludCwgZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLkZyID0gRnI7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLmZuR2V0QWRkaXRpb25Db25zdHJhaW50ID0gZm5HZXRBZGRpdGlvbkNvbnN0cmFpbnQ7XG4gICAgICAgIHRoaXMuZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQgPSBmbkdldE11bHRpcGxpY2F0aW9uQ29uc3RyYWludDtcbiAgICB9XG5cbiAgICBwcm9jZXNzUjFjc0NvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaW5lYXJDb21iaW5hdGlvbihsY0EpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUxpbmVhckNvbWJpbmF0aW9uKGxjQik7XG4gICAgICAgIHRoaXMubm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24obGNDKTtcblxuICAgICAgICBjb25zdCBsY3RBID0gdGhpcy5nZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGNBKTtcbiAgICAgICAgY29uc3QgbGN0QiA9IHRoaXMuZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxjQik7XG5cbiAgICAgICAgaWYgKChsY3RBID09PSBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUpIHx8IChsY3RCID09PSBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUjFjc0FkZGl0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGNDKTtcbiAgICAgICAgfSBlbHNlIGlmIChsY3RBID09PSBMSU5FQVJfQ09NQklOQVRJT05fQ09OU1RBTlQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxjQ0MgPSB0aGlzLmpvaW5MaW5lYXJDb21iaW5hdGlvbnMobGNCLCBsY0MsIGxjQVswXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUjFjc0FkZGl0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGNDQyk7XG4gICAgICAgIH0gZWxzZSBpZiAobGN0QiA9PT0gTElORUFSX0NPTUJJTkFUSU9OX0NPTlNUQU5UKSB7XG4gICAgICAgICAgICBjb25zdCBsY0NDID0gdGhpcy5qb2luTGluZWFyQ29tYmluYXRpb25zKGxjQSwgbGNDLCBsY0JbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1IxY3NBZGRpdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQ0MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1IxY3NNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxpbkNvbSkge1xuICAgICAgICAvLyBsZXQgayA9IHRoaXMuRnIuemVybztcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3Qgc2lnbmFsSWRzID0gT2JqZWN0LmtleXMobGluQ29tKTtcbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYWxJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gICAgIGlmIChzaWduYWxJZHNbaV0gPT09IFwiMFwiKSB7XG4gICAgICAgIC8vICAgICAgICAgayA9IHRoaXMuRnIuYWRkKGssIGxpbkNvbVtzaWduYWxJZHNbaV1dKTtcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9WQVJJQUJMRTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvL1xuICAgICAgICAvLyBpZiAoIXRoaXMuRnIuZXEoaywgdGhpcy5Gci56ZXJvKSkgcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9DT05TVEFOVDtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9OVUxMQUJMRTtcblxuICAgICAgICBsZXQgayA9IHRoaXMuRnIuemVybztcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBjb25zdCBzcyA9IE9iamVjdC5rZXlzKGxpbkNvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5Db21bc3NbaV1dID09IDBuKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxpbkNvbVtzc1tpXV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNzW2ldID09IDApIHtcbiAgICAgICAgICAgICAgICBrID0gdGhpcy5Gci5hZGQoaywgbGluQ29tW3NzW2ldXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+IDApIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fVkFSSUFCTEU7XG4gICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oaykpIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fQ09OU1RBTlQ7XG4gICAgICAgIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEU7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24obGluQ29tKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hbElkcyA9IE9iamVjdC5rZXlzKGxpbkNvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmFsSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5Gci5pc1plcm8obGluQ29tW3NpZ25hbElkc1tpXV0pKSBkZWxldGUgbGluQ29tW3NpZ25hbElkc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluQ29tO1xuICAgIH1cblxuICAgIGpvaW5MaW5lYXJDb21iaW5hdGlvbnMobGluQ29tMSwgbGluQ29tMiwgaykge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcblxuICAgICAgICBmb3IgKGxldCBzIGluIGxpbkNvbTEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzW3NdID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXNbc10gPSB0aGlzLkZyLm11bChrLCBsaW5Db20xW3NdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW3NdID0gdGhpcy5Gci5hZGQocmVzW3NdLCB0aGlzLkZyLm11bChrLCBsaW5Db20xW3NdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBzIGluIGxpbkNvbTIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuRnIubmVnKGxpbkNvbTJbc10pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNbc10gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJlc1tzXSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW3NdID0gdGhpcy5Gci5hZGQocmVzW3NdLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24ocmVzKTtcbiAgICB9XG5cbiAgICByZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGluQ29tLCBtYXhDKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgIGs6IHRoaXMuRnIuemVybyxcbiAgICAgICAgICAgIHNpZ25hbHM6IFtdLFxuICAgICAgICAgICAgY29lZnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgc2lnbmFsSWQgaW4gbGluQ29tKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsSWQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlcy5rID0gdGhpcy5Gci5hZGQocmVzLmssIGxpbkNvbVtzaWduYWxJZF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5Db21bc2lnbmFsSWRdICE9IDBuKSB7XG4gICAgICAgICAgICAgICAgY3MucHVzaChbTnVtYmVyKHNpZ25hbElkKSwgbGluQ29tW3NpZ25hbElkXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGNzLmxlbmd0aCA+IG1heEMpIHtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gY3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gY3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNvID0gc2V0dGluZ3MublZhcnMrKztcblxuICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmZuR2V0QWRkaXRpb25Db25zdHJhaW50KFxuICAgICAgICAgICAgICAgIGMxWzBdLCBjMlswXSwgc28sXG4gICAgICAgICAgICAgICAgdGhpcy5Gci5uZWcoYzFbMV0pLCB0aGlzLkZyLm5lZyhjMlsxXSksIHRoaXMuRnIuemVybywgdGhpcy5Gci5vbmUsIHRoaXMuRnIuemVybyk7XG5cbiAgICAgICAgICAgIGNvbnN0cmFpbnRzQXJyLnB1c2goY29uc3RyYWludHMpO1xuICAgICAgICAgICAgYWRkaXRpb25zQXJyLnB1c2goW2MxWzBdLCBjMlswXSwgYzFbMV0sIGMyWzFdXSk7XG5cbiAgICAgICAgICAgIGNzLnB1c2goW3NvLCB0aGlzLkZyLm9uZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzLnNpZ25hbHNbaV0gPSBjc1tpXVswXTtcbiAgICAgICAgICAgIHJlcy5jb2Vmc1tpXSA9IGNzW2ldWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHJlcy5jb2Vmcy5sZW5ndGggPCBtYXhDKSB7XG4gICAgICAgICAgICByZXMuc2lnbmFscy5wdXNoKDApO1xuICAgICAgICAgICAgcmVzLmNvZWZzLnB1c2godGhpcy5Gci56ZXJvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgcHJvY2Vzc1IxY3NBZGRpdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxpbkNvbSkge1xuICAgICAgICBjb25zdCBjb25zdHJhaW50c0FyciA9IFtdO1xuICAgICAgICBjb25zdCBhZGRpdGlvbnNBcnIgPSBbXTtcblxuICAgICAgICBjb25zdCBDID0gdGhpcy5yZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGluQ29tLCAzKTtcblxuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuZm5HZXRBZGRpdGlvbkNvbnN0cmFpbnQoXG4gICAgICAgICAgICBDLnNpZ25hbHNbMF0sIEMuc2lnbmFsc1sxXSwgQy5zaWduYWxzWzJdLFxuICAgICAgICAgICAgQy5jb2Vmc1swXSwgQy5jb2Vmc1sxXSwgdGhpcy5Gci56ZXJvLCBDLmNvZWZzWzJdLCBDLmspO1xuXG4gICAgICAgIGNvbnN0cmFpbnRzQXJyLnB1c2goY29uc3RyYWludHMpO1xuXG4gICAgICAgIHJldHVybiBbY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0Fycl07XG4gICAgfVxuXG4gICAgcHJvY2Vzc1IxY3NNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHNBcnIgPSBbXTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25zQXJyID0gW107XG5cbiAgICAgICAgY29uc3QgQSA9IHRoaXMucmVkdWNlQ29lZnMoc2V0dGluZ3MsIGNvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnIsIGxjQSwgMSk7XG4gICAgICAgIGNvbnN0IEIgPSB0aGlzLnJlZHVjZUNvZWZzKHNldHRpbmdzLCBjb25zdHJhaW50c0FyciwgYWRkaXRpb25zQXJyLCBsY0IsIDEpO1xuICAgICAgICBjb25zdCBDID0gdGhpcy5yZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGNDLCAxKTtcblxuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoXG4gICAgICAgICAgICBBLnNpZ25hbHNbMF0sIEIuc2lnbmFsc1swXSwgQy5zaWduYWxzWzBdLFxuICAgICAgICAgICAgdGhpcy5Gci5tdWwoQS5jb2Vmc1swXSwgQi5rKSxcbiAgICAgICAgICAgIHRoaXMuRnIubXVsKEEuaywgQi5jb2Vmc1swXSksXG4gICAgICAgICAgICB0aGlzLkZyLm11bChBLmNvZWZzWzBdLCBCLmNvZWZzWzBdKSxcbiAgICAgICAgICAgIHRoaXMuRnIubmVnKEMuY29lZnNbMF0pLFxuICAgICAgICAgICAgdGhpcy5Gci5zdWIodGhpcy5Gci5tdWwoQS5rLCBCLmspLCBDLmspKTtcblxuICAgICAgICBjb25zdHJhaW50c0Fyci5wdXNoKGNvbnN0cmFpbnRzKTtcblxuICAgICAgICByZXR1cm4gW2NvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnJdO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/r1cs_constraint_processor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/r1cs_export_json.js":
/*!******************************************************!*\
  !*** ./node_modules/snarkjs/src/r1cs_export_json.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csExportJson)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(ssr)/./node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function r1csExportJson(r1csFileName, logger) {\n\n    const cir = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1cs)(r1csFileName, true, true, true, logger);\n    const Fr=cir.curve.Fr;\n    delete cir.curve;\n    delete cir.F;\n\n    return (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.stringifyBigIntsWithField)(Fr, cir);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19leHBvcnRfanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVtQztBQUNtQjs7O0FBR3ZDOztBQUVmLHNCQUFzQixrREFBUTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtRUFBeUI7QUFDcEMiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19leHBvcnRfanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQge3JlYWRSMWNzfSAgZnJvbSBcInIxY3NmaWxlXCI7XG5pbXBvcnQgeyBzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHIxY3NFeHBvcnRKc29uKHIxY3NGaWxlTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBjaXIgPSBhd2FpdCByZWFkUjFjcyhyMWNzRmlsZU5hbWUsIHRydWUsIHRydWUsIHRydWUsIGxvZ2dlcik7XG4gICAgY29uc3QgRnI9Y2lyLmN1cnZlLkZyO1xuICAgIGRlbGV0ZSBjaXIuY3VydmU7XG4gICAgZGVsZXRlIGNpci5GO1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQoRnIsIGNpcik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/r1cs_export_json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/r1cs_info.js":
/*!***********************************************!*\
  !*** ./node_modules/snarkjs/src/r1cs_info.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csInfo)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! r1csfile */ \"(ssr)/./node_modules/r1csfile/src/r1csfile.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst bls12381r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nasync function r1csInfo(r1csName, logger) {\n\n    const cir = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_1__.readR1cs)(r1csName);\n\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(cir.prime, bn128r)) {\n        if (logger) logger.info(\"Curve: bn-128\");\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(cir.prime, bls12381r)) {\n        if (logger) logger.info(\"Curve: bls12-381\");\n    } else {\n        if (logger) logger.info(`Unknown Curve. Prime: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(cir.prime)}`);\n    }\n    if (logger) logger.info(`# of Wires: ${cir.nVars}`);\n    if (logger) logger.info(`# of Constraints: ${cir.nConstraints}`);\n    if (logger) logger.info(`# of Private Inputs: ${cir.nPrvInputs}`);\n    if (logger) logger.info(`# of Public Inputs: ${cir.nPubInputs}`);\n    if (logger) logger.info(`# of Labels: ${cir.nLabels}`);\n    if (logger) logger.info(`# of Outputs: ${cir.nOutputs}`);\n\n    return cir;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19pbmZvLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXNDO0FBQ0Q7O0FBRXJDLGtCQUFrQixnREFBTTtBQUN4QixlQUFlLGdEQUFNOztBQUVOOztBQUVmLHNCQUFzQixrREFBUTs7QUFFOUIsUUFBUSxnREFBTTtBQUNkO0FBQ0EsTUFBTSxTQUFTLGdEQUFNO0FBQ3JCO0FBQ0EsTUFBTTtBQUNOLHlEQUF5RCxnREFBTSxxQkFBcUI7QUFDcEY7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRCxpREFBaUQsaUJBQWlCO0FBQ2xFLG9EQUFvRCxlQUFlO0FBQ25FLG1EQUFtRCxlQUFlO0FBQ2xFLDRDQUE0QyxZQUFZO0FBQ3hELDZDQUE2QyxhQUFhOztBQUUxRDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3IxY3NfaW5mby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgeyByZWFkUjFjcyB9ICBmcm9tIFwicjFjc2ZpbGVcIjtcblxuY29uc3QgYmxzMTIzODFyID0gU2NhbGFyLmUoXCI3M2VkYTc1MzI5OWQ3ZDQ4MzMzOWQ4MDgwOWExZDgwNTUzYmRhNDAyZmZmZTViZmVmZmZmZmZmZjAwMDAwMDAxXCIsIDE2KTtcbmNvbnN0IGJuMTI4ciA9IFNjYWxhci5lKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHIxY3NJbmZvKHIxY3NOYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IGNpciA9IGF3YWl0IHJlYWRSMWNzKHIxY3NOYW1lKTtcblxuICAgIGlmIChTY2FsYXIuZXEoY2lyLnByaW1lLCBibjEyOHIpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiQ3VydmU6IGJuLTEyOFwiKTtcbiAgICB9IGVsc2UgaWYgKFNjYWxhci5lcShjaXIucHJpbWUsIGJsczEyMzgxcikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJDdXJ2ZTogYmxzMTItMzgxXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGBVbmtub3duIEN1cnZlLiBQcmltZTogJHtTY2FsYXIudG9TdHJpbmcoY2lyLnByaW1lKX1gKTtcbiAgICB9XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgV2lyZXM6ICR7Y2lyLm5WYXJzfWApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIENvbnN0cmFpbnRzOiAke2Npci5uQ29uc3RyYWludHN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgUHJpdmF0ZSBJbnB1dHM6ICR7Y2lyLm5QcnZJbnB1dHN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgUHVibGljIElucHV0czogJHtjaXIublB1YklucHV0c31gKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgIyBvZiBMYWJlbHM6ICR7Y2lyLm5MYWJlbHN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgT3V0cHV0czogJHtjaXIubk91dHB1dHN9YCk7XG5cbiAgICByZXR1cm4gY2lyO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/r1cs_info.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/r1cs_print.js":
/*!************************************************!*\
  !*** ./node_modules/snarkjs/src/r1cs_print.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csPrint)\n/* harmony export */ });\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nfunction r1csPrint(r1cs, syms, logger) {\n    for (let i=0; i<r1cs.constraints.length; i++) {\n        printCostraint(r1cs.constraints[i]);\n    }\n    function printCostraint(c) {\n        const lc2str = (lc) => {\n            let S = \"\";\n            const keys = Object.keys(lc);\n            keys.forEach( (k) => {\n                let name = syms.varIdx2Name[k];\n                if (name == \"one\") name = \"1\";\n\n                let vs = r1cs.curve.Fr.toString(lc[k]);\n                if (vs == \"1\") vs = \"\";  // Do not show ones\n                if (vs == \"-1\") vs = \"-\";  // Do not show ones\n                if ((S!=\"\")&&(vs[0]!=\"-\")) vs = \"+\"+vs;\n                if (S!=\"\") vs = \" \"+vs;\n                S= S + vs   + name;\n            });\n            return S;\n        };\n        const S = `[ ${lc2str(c[0])} ] * [ ${lc2str(c[1])} ] - [ ${lc2str(c[2])} ] = 0`;\n        if (logger) logger.info(S);\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19wcmludC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QixjQUFjLFFBQVEsY0FBYyxRQUFRLGNBQWM7QUFDakY7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9yMWNzX3ByaW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHIxY3NQcmludChyMWNzLCBzeW1zLCBsb2dnZXIpIHtcbiAgICBmb3IgKGxldCBpPTA7IGk8cjFjcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmludENvc3RyYWludChyMWNzLmNvbnN0cmFpbnRzW2ldKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJpbnRDb3N0cmFpbnQoYykge1xuICAgICAgICBjb25zdCBsYzJzdHIgPSAobGMpID0+IHtcbiAgICAgICAgICAgIGxldCBTID0gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhsYyk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goIChrKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBzeW1zLnZhcklkeDJOYW1lW2tdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwib25lXCIpIG5hbWUgPSBcIjFcIjtcblxuICAgICAgICAgICAgICAgIGxldCB2cyA9IHIxY3MuY3VydmUuRnIudG9TdHJpbmcobGNba10pO1xuICAgICAgICAgICAgICAgIGlmICh2cyA9PSBcIjFcIikgdnMgPSBcIlwiOyAgLy8gRG8gbm90IHNob3cgb25lc1xuICAgICAgICAgICAgICAgIGlmICh2cyA9PSBcIi0xXCIpIHZzID0gXCItXCI7ICAvLyBEbyBub3Qgc2hvdyBvbmVzXG4gICAgICAgICAgICAgICAgaWYgKChTIT1cIlwiKSYmKHZzWzBdIT1cIi1cIikpIHZzID0gXCIrXCIrdnM7XG4gICAgICAgICAgICAgICAgaWYgKFMhPVwiXCIpIHZzID0gXCIgXCIrdnM7XG4gICAgICAgICAgICAgICAgUz0gUyArIHZzICAgKyBuYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgUyA9IGBbICR7bGMyc3RyKGNbMF0pfSBdICogWyAke2xjMnN0cihjWzFdKX0gXSAtIFsgJHtsYzJzdHIoY1syXSl9IF0gPSAwYDtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oUyk7XG4gICAgfVxuXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/r1cs_print.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/wtns.js":
/*!******************************************!*\
  !*** ./node_modules/snarkjs/src/wtns.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculate: () => (/* reexport safe */ _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   check: () => (/* reexport safe */ _wtns_check_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   debug: () => (/* reexport safe */ _wtns_debug_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _wtns_export_json_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var _wtns_debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_debug.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_debug.js\");\n/* harmony import */ var _wtns_export_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_export_json.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_export_json.js\");\n/* harmony import */ var _wtns_check_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wtns_check.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_check.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Rucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXlEO0FBQ1I7QUFDVyIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy93dG5zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBjYWxjdWxhdGV9IGZyb20gXCIuL3d0bnNfY2FsY3VsYXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZGVidWd9IGZyb20gXCIuL3d0bnNfZGVidWcuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRKc29ufSBmcm9tIFwiLi93dG5zX2V4cG9ydF9qc29uLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY2hlY2t9IGZyb20gXCIuL3d0bnNfY2hlY2suanNcIjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/wtns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/wtns_calculate.js":
/*!****************************************************!*\
  !*** ./node_modules/snarkjs/src/wtns_calculate.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsCalculate)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var circom_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! circom_runtime */ \"(ssr)/./node_modules/circom_runtime/main.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.utils;\n\nasync function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wc = await (0,circom_runtime__WEBPACK_IMPORTED_MODULE_1__.WitnessCalculatorBuilder)(wasm, options);\n    if (wc.circom_version() === 1) {\n        const w = await wc.calculateBinWitness(input);\n\n        const fdWtns = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n        await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.writeBin(fdWtns, w, wc.prime);\n        await fdWtns.close();\n    } else {\n        const fdWtns = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(wtnsFileName);\n\n        const w = await wc.calculateWTNSBin(input);\n\n        await fdWtns.write(w);\n        await fdWtns.close();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19jYWxjdWxhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDcUI7QUFDYjtBQUNPO0FBQ1o7QUFDeEMsUUFBUSxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFcEI7QUFDZjs7QUFFQSx5QkFBeUIsa0RBQXFCO0FBQzlDO0FBQ0E7O0FBRUEscUJBQXFCLHdFQUF3QjtBQUM3QztBQUNBOztBQUVBLDZCQUE2Qiw4REFBMEI7O0FBRXZELGNBQWMsb0RBQWtCO0FBQ2hDO0FBQ0EsTUFBTTtBQUNOLDZCQUE2QixvREFBdUI7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfY2FsY3VsYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuaW1wb3J0IHsgV2l0bmVzc0NhbGN1bGF0b3JCdWlsZGVyIH0gZnJvbSBcImNpcmNvbV9ydW50aW1lXCI7XG5pbXBvcnQgKiBhcyB3dG5zVXRpbHMgZnJvbSBcIi4vd3Ruc191dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgeyAgdXRpbHMgfSAgIGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHsgdW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB3dG5zQ2FsY3VsYXRlKF9pbnB1dCwgd2FzbUZpbGVOYW1lLCB3dG5zRmlsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyhfaW5wdXQpO1xuXG4gICAgY29uc3QgZmRXYXNtID0gYXdhaXQgZmFzdEZpbGUucmVhZEV4aXN0aW5nKHdhc21GaWxlTmFtZSk7XG4gICAgY29uc3Qgd2FzbSA9IGF3YWl0IGZkV2FzbS5yZWFkKGZkV2FzbS50b3RhbFNpemUpO1xuICAgIGF3YWl0IGZkV2FzbS5jbG9zZSgpO1xuXG4gICAgY29uc3Qgd2MgPSBhd2FpdCBXaXRuZXNzQ2FsY3VsYXRvckJ1aWxkZXIod2FzbSwgb3B0aW9ucyk7XG4gICAgaWYgKHdjLmNpcmNvbV92ZXJzaW9uKCkgPT09IDEpIHtcbiAgICAgICAgY29uc3QgdyA9IGF3YWl0IHdjLmNhbGN1bGF0ZUJpbldpdG5lc3MoaW5wdXQpO1xuXG4gICAgICAgIGNvbnN0IGZkV3RucyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKHd0bnNGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDIpO1xuXG4gICAgICAgIGF3YWl0IHd0bnNVdGlscy53cml0ZUJpbihmZFd0bnMsIHcsIHdjLnByaW1lKTtcbiAgICAgICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmRXdG5zID0gYXdhaXQgZmFzdEZpbGUuY3JlYXRlT3ZlcnJpZGUod3Ruc0ZpbGVOYW1lKTtcblxuICAgICAgICBjb25zdCB3ID0gYXdhaXQgd2MuY2FsY3VsYXRlV1ROU0JpbihpbnB1dCk7XG5cbiAgICAgICAgYXdhaXQgZmRXdG5zLndyaXRlKHcpO1xuICAgICAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/wtns_calculate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/wtns_check.js":
/*!************************************************!*\
  !*** ./node_modules/snarkjs/src/wtns_check.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsCheck)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! r1csfile */ \"(ssr)/./node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function wtnsCheck(r1csFilename, wtnsFilename, logger) {\n\n    if (logger) logger.info(\"WITNESS CHECKING STARTED\");\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {\n        fd: fdR1cs,\n        sections: sectionsR1cs\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_2__.readR1csFd)(fdR1cs, sectionsR1cs, { loadConstraints: false, loadCustomGates: false });\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(wtnsFilename, \"wtns\", 2, 1 << 22, 1 << 24);\n    const wtnsHeader = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdWtns, wtnsSections);\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.eq(r1cs.prime, wtnsHeader.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_4__.getCurveFromR(r1cs.prime);\n    const Fr = curve.Fr;\n    const sFr = Fr.n8;\n\n    const bR1cs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdR1cs, sectionsR1cs, 2);\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  WITNESS CHECK\");\n        logger.info(`  Curve:          ${r1cs.curve.name}`);\n        logger.info(`  Vars (wires):   ${r1cs.nVars}`);\n        logger.info(`  Outputs:        ${r1cs.nOutputs}`);\n        logger.info(`  Public Inputs:  ${r1cs.nPubInputs}`);\n        logger.info(`  Private Inputs: ${r1cs.nPrvInputs}`);\n        logger.info(`  Labels:         ${r1cs.nLabels}`);\n        logger.info(`  Constraints:    ${r1cs.nConstraints}`);\n        logger.info(`  Custom Gates:   ${r1cs.useCustomGates}`);\n        logger.info(\"----------------------------\");\n    }\n\n    if (logger) logger.info(\"> Checking witness correctness\");\n\n    let bR1csPos = 0;\n    let res = true;\n    for (let i = 0; i < r1cs.nConstraints; i++) {\n        if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n            logger.info(` processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n        }\n\n        //Read the three linear combinations of the constraint where A * B - C = 0\n        const lcA = readLC();\n        const lcB = readLC();\n        const lcC = readLC();\n\n        // Evaluate the linear combinations\n        const evalA = EvaluateLinearCombination(lcA);\n        const evalB = EvaluateLinearCombination(lcB);\n        const evalC = EvaluateLinearCombination(lcC);\n\n        // Check that A * B - C == 0\n        if (!Fr.eq(Fr.sub(Fr.mul(evalA, evalB), evalC), Fr.zero)) {\n            logger.warn(\" aborting checking process at constraint \" + i);\n            res = false;\n            break;\n        }\n    }\n\n    fdR1cs.close();\n\n    if (logger) {\n        if (res) {\n            logger.info(\"WITNESS IS CORRECT\");\n            logger.info(\"WITNESS CHECKING FINISHED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"WITNESS IS NOT CORRECT\");\n            logger.warn(\"WITNESS CHECKING FINISHED UNSUCCESSFULLY\");\n        }\n    }\n\n    return res;\n\n    function EvaluateLinearCombination(lc) {\n        let res = Fr.zero;\n\n        const keys = Object.keys(lc);\n        keys.forEach((signalId) => {\n            const signalValue = getWitnessValue(signalId);\n            const signalFactor = lc[signalId];\n\n            res = Fr.add(res, Fr.mul(signalValue, signalFactor));\n        });\n\n        return res;\n    }\n\n    function readLC() {\n        const lc = {};\n\n        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n        bR1csPos += 4;\n        const buffUL32V = new DataView(buffUL32.buffer);\n        const nIdx = buffUL32V.getUint32(0, true);\n\n        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n        bR1csPos += (4 + r1cs.n8) * nIdx;\n        const buffV = new DataView(buff.buffer);\n        for (let i = 0; i < nIdx; i++) {\n            const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n            const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n            lc[idx] = val;\n        }\n        return lc;\n    }\n\n    function getWitnessValue(signalId) {\n        return Fr.fromRprLE(buffWitness.slice(signalId * sFr, signalId * sFr + sFr));\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19jaGVjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDtBQUNQO0FBQ1A7QUFDQTtBQUNBOztBQUV2Qjs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxRQUFRLDREQUF3QjtBQUN0Qyx1QkFBdUIsb0RBQVUseUJBQXlCLGdEQUFnRDs7QUFFMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSw0REFBd0I7QUFDdEMsNkJBQTZCLHNEQUFvQjs7QUFFakQsU0FBUyxnREFBTTtBQUNmO0FBQ0E7O0FBRUEsOEJBQThCLDREQUF3QjtBQUN0RDs7QUFFQSx3QkFBd0IscURBQW9CO0FBQzVDO0FBQ0E7O0FBRUEsd0JBQXdCLDREQUF3Qjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RCx5Q0FBeUMsV0FBVztBQUNwRCx5Q0FBeUMsY0FBYztBQUN2RCx5Q0FBeUMsZ0JBQWdCO0FBQ3pELHlDQUF5QyxnQkFBZ0I7QUFDekQseUNBQXlDLGFBQWE7QUFDdEQseUNBQXlDLGtCQUFrQjtBQUMzRCx5Q0FBeUMsb0JBQW9CO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQSwyREFBMkQsRUFBRSxHQUFHLGtCQUFrQjtBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfY2hlY2suanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB3dG5zVXRpbHMgZnJvbSBcIi4vd3Ruc191dGlscy5qc1wiO1xuaW1wb3J0IHsgcmVhZFIxY3NGZCB9IGZyb20gXCJyMWNzZmlsZVwiO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0ICogYXMgY3VydmVzIGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB3dG5zQ2hlY2socjFjc0ZpbGVuYW1lLCB3dG5zRmlsZW5hbWUsIGxvZ2dlcikge1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJXSVRORVNTIENIRUNLSU5HIFNUQVJURURcIik7XG5cbiAgICAvLyBSZWFkIHIxY3MgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIHIxY3MgZmlsZVwiKTtcbiAgICBjb25zdCB7XG4gICAgICAgIGZkOiBmZFIxY3MsXG4gICAgICAgIHNlY3Rpb25zOiBzZWN0aW9uc1IxY3NcbiAgICB9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHIxY3NGaWxlbmFtZSwgXCJyMWNzXCIsIDEsIDEgPDwgMjIsIDEgPDwgMjQpO1xuICAgIGNvbnN0IHIxY3MgPSBhd2FpdCByZWFkUjFjc0ZkKGZkUjFjcywgc2VjdGlvbnNSMWNzLCB7IGxvYWRDb25zdHJhaW50czogZmFsc2UsIGxvYWRDdXN0b21HYXRlczogZmFsc2UgfSk7XG5cbiAgICAvLyBSZWFkIHdpdG5lc3MgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIHdpdG5lc3MgZmlsZVwiKTtcbiAgICBjb25zdCB7XG4gICAgICAgIGZkOiBmZFd0bnMsXG4gICAgICAgIHNlY3Rpb25zOiB3dG5zU2VjdGlvbnNcbiAgICB9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHd0bnNGaWxlbmFtZSwgXCJ3dG5zXCIsIDIsIDEgPDwgMjIsIDEgPDwgMjQpO1xuICAgIGNvbnN0IHd0bnNIZWFkZXIgPSBhd2FpdCB3dG5zVXRpbHMucmVhZEhlYWRlcihmZFd0bnMsIHd0bnNTZWN0aW9ucyk7XG5cbiAgICBpZiAoIVNjYWxhci5lcShyMWNzLnByaW1lLCB3dG5zSGVhZGVyLnEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN1cnZlIG9mIHRoZSB3aXRuZXNzIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJ2ZSBvZiB0aGUgcHJvdmluZyBrZXlcIik7XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRXdG5zLCB3dG5zU2VjdGlvbnMsIDIpO1xuICAgIGF3YWl0IGZkV3Rucy5jbG9zZSgpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBjdXJ2ZXMuZ2V0Q3VydmVGcm9tUihyMWNzLnByaW1lKTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHNGciA9IEZyLm44O1xuXG4gICAgY29uc3QgYlIxY3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRSMWNzLCBzZWN0aW9uc1IxY3MsIDIpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiICBXSVRORVNTIENIRUNLXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXJ2ZTogICAgICAgICAgJHtyMWNzLmN1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFZhcnMgKHdpcmVzKTogICAke3IxY3MublZhcnN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIE91dHB1dHM6ICAgICAgICAke3IxY3Mubk91dHB1dHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFB1YmxpYyBJbnB1dHM6ICAke3IxY3MublB1YklucHV0c31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHJpdmF0ZSBJbnB1dHM6ICR7cjFjcy5uUHJ2SW5wdXRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBMYWJlbHM6ICAgICAgICAgJHtyMWNzLm5MYWJlbHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENvbnN0cmFpbnRzOiAgICAke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXN0b20gR2F0ZXM6ICAgJHtyMWNzLnVzZUN1c3RvbUdhdGVzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENoZWNraW5nIHdpdG5lc3MgY29ycmVjdG5lc3NcIik7XG5cbiAgICBsZXQgYlIxY3NQb3MgPSAwO1xuICAgIGxldCByZXMgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjFjcy5uQ29uc3RyYWludHM7IGkrKykge1xuICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGkgIT09IDApICYmIChpICUgNTAwMDAwID09PSAwKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYMK3wrfCtyBwcm9jZXNzaW5nIHIxY3MgY29uc3RyYWludHMgJHtpfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9SZWFkIHRoZSB0aHJlZSBsaW5lYXIgY29tYmluYXRpb25zIG9mIHRoZSBjb25zdHJhaW50IHdoZXJlIEEgKiBCIC0gQyA9IDBcbiAgICAgICAgY29uc3QgbGNBID0gcmVhZExDKCk7XG4gICAgICAgIGNvbnN0IGxjQiA9IHJlYWRMQygpO1xuICAgICAgICBjb25zdCBsY0MgPSByZWFkTEMoKTtcblxuICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgbGluZWFyIGNvbWJpbmF0aW9uc1xuICAgICAgICBjb25zdCBldmFsQSA9IEV2YWx1YXRlTGluZWFyQ29tYmluYXRpb24obGNBKTtcbiAgICAgICAgY29uc3QgZXZhbEIgPSBFdmFsdWF0ZUxpbmVhckNvbWJpbmF0aW9uKGxjQik7XG4gICAgICAgIGNvbnN0IGV2YWxDID0gRXZhbHVhdGVMaW5lYXJDb21iaW5hdGlvbihsY0MpO1xuXG4gICAgICAgIC8vIENoZWNrIHRoYXQgQSAqIEIgLSBDID09IDBcbiAgICAgICAgaWYgKCFGci5lcShGci5zdWIoRnIubXVsKGV2YWxBLCBldmFsQiksIGV2YWxDKSwgRnIuemVybykpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiwrfCt8K3IGFib3J0aW5nIGNoZWNraW5nIHByb2Nlc3MgYXQgY29uc3RyYWludCBcIiArIGkpO1xuICAgICAgICAgICAgcmVzID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZkUjFjcy5jbG9zZSgpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIldJVE5FU1MgSVMgQ09SUkVDVFwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiV0lUTkVTUyBDSEVDS0lORyBGSU5JU0hFRCBTVUNDRVNTRlVMTFlcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIldJVE5FU1MgSVMgTk9UIENPUlJFQ1RcIik7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIldJVE5FU1MgQ0hFQ0tJTkcgRklOSVNIRUQgVU5TVUNDRVNTRlVMTFlcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuXG4gICAgZnVuY3Rpb24gRXZhbHVhdGVMaW5lYXJDb21iaW5hdGlvbihsYykge1xuICAgICAgICBsZXQgcmVzID0gRnIuemVybztcblxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobGMpO1xuICAgICAgICBrZXlzLmZvckVhY2goKHNpZ25hbElkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxWYWx1ZSA9IGdldFdpdG5lc3NWYWx1ZShzaWduYWxJZCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxGYWN0b3IgPSBsY1tzaWduYWxJZF07XG5cbiAgICAgICAgICAgIHJlcyA9IEZyLmFkZChyZXMsIEZyLm11bChzaWduYWxWYWx1ZSwgc2lnbmFsRmFjdG9yKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZExDKCkge1xuICAgICAgICBjb25zdCBsYyA9IHt9O1xuXG4gICAgICAgIGNvbnN0IGJ1ZmZVTDMyID0gYlIxY3Muc2xpY2UoYlIxY3NQb3MsIGJSMWNzUG9zICsgNCk7XG4gICAgICAgIGJSMWNzUG9zICs9IDQ7XG4gICAgICAgIGNvbnN0IGJ1ZmZVTDMyViA9IG5ldyBEYXRhVmlldyhidWZmVUwzMi5idWZmZXIpO1xuICAgICAgICBjb25zdCBuSWR4ID0gYnVmZlVMMzJWLmdldFVpbnQzMigwLCB0cnVlKTtcblxuICAgICAgICBjb25zdCBidWZmID0gYlIxY3Muc2xpY2UoYlIxY3NQb3MsIGJSMWNzUG9zICsgKDQgKyByMWNzLm44KSAqIG5JZHgpO1xuICAgICAgICBiUjFjc1BvcyArPSAoNCArIHIxY3MubjgpICogbklkeDtcbiAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5JZHg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gYnVmZlYuZ2V0VWludDMyKGkgKiAoNCArIHIxY3MubjgpLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHIxY3MuRi5mcm9tUnByTEUoYnVmZiwgaSAqICg0ICsgcjFjcy5uOCkgKyA0KTtcbiAgICAgICAgICAgIGxjW2lkeF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpdG5lc3NWYWx1ZShzaWduYWxJZCkge1xuICAgICAgICByZXR1cm4gRnIuZnJvbVJwckxFKGJ1ZmZXaXRuZXNzLnNsaWNlKHNpZ25hbElkICogc0ZyLCBzaWduYWxJZCAqIHNGciArIHNGcikpO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/wtns_check.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/wtns_debug.js":
/*!************************************************!*\
  !*** ./node_modules/snarkjs/src/wtns_debug.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsDebug)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var circom_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! circom_runtime */ \"(ssr)/./node_modules/circom_runtime/main.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _loadsyms_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loadsyms.js */ \"(ssr)/./node_modules/snarkjs/src/loadsyms.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_5__.utils;\n\n\nasync function wtnsDebug(_input, wasmFileName, wtnsFileName, symName, options, logger) {\n\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wcOps = {...options, sanityCheck: true};\n    let sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n    if (options.set) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logSetSignal= function(labelIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"SET \" + sym.labelIdx2Name[labelIdx] + \" <\" + \"-- \" + value.toString());\n        };\n    }\n    if (options.get) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logGetSignal= function(varIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"GET \" + sym.labelIdx2Name[varIdx] + \" --\" + \"> \" + value.toString());\n        };\n    }\n    if (options.trigger) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logStartComponent= function(cIdx) {\n            if (logger) logger.info(\"START: \" + sym.componentIdx2Name[cIdx]);\n        };\n        wcOps.logFinishComponent= function(cIdx) {\n            if (logger) logger.info(\"FINISH: \" + sym.componentIdx2Name[cIdx]);\n        };\n    }\n    wcOps.sym = sym;\n\n    const wc = await (0,circom_runtime__WEBPACK_IMPORTED_MODULE_1__.WitnessCalculatorBuilder)(wasm, wcOps);\n    const w = await wc.calculateWitness(input, true);\n\n    const fdWtns = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n    await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.write(fdWtns, w, wc.prime);\n\n    await fdWtns.close();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDcUI7QUFDYjtBQUNPO0FBQ2Y7QUFDRztBQUN4QyxPQUFPLG9CQUFvQixFQUFFLCtDQUFLOzs7QUFHbkI7O0FBRWY7O0FBRUEseUJBQXlCLGtEQUFxQjtBQUM5QztBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixvQkFBb0Isd0RBQVE7QUFDNUI7QUFDQSw4QkFBOEIsd0RBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdEQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3REFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix3RUFBd0I7QUFDN0M7O0FBRUEseUJBQXlCLDhEQUEwQjs7QUFFbkQsVUFBVSxpREFBZTs7QUFFekI7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy93dG5zX2RlYnVnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuaW1wb3J0IHsgV2l0bmVzc0NhbGN1bGF0b3JCdWlsZGVyIH0gZnJvbSBcImNpcmNvbV9ydW50aW1lXCI7XG5pbXBvcnQgKiBhcyB3dG5zVXRpbHMgZnJvbSBcIi4vd3Ruc191dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgbG9hZFN5bXMgZnJvbSBcIi4vbG9hZHN5bXMuanNcIjtcbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB3dG5zRGVidWcoX2lucHV0LCB3YXNtRmlsZU5hbWUsIHd0bnNGaWxlTmFtZSwgc3ltTmFtZSwgb3B0aW9ucywgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyhfaW5wdXQpO1xuXG4gICAgY29uc3QgZmRXYXNtID0gYXdhaXQgZmFzdEZpbGUucmVhZEV4aXN0aW5nKHdhc21GaWxlTmFtZSk7XG4gICAgY29uc3Qgd2FzbSA9IGF3YWl0IGZkV2FzbS5yZWFkKGZkV2FzbS50b3RhbFNpemUpO1xuICAgIGF3YWl0IGZkV2FzbS5jbG9zZSgpO1xuXG4gICAgY29uc3Qgd2NPcHMgPSB7Li4ub3B0aW9ucywgc2FuaXR5Q2hlY2s6IHRydWV9O1xuICAgIGxldCBzeW0gPSBhd2FpdCBsb2FkU3ltcyhzeW1OYW1lKTtcbiAgICBpZiAob3B0aW9ucy5zZXQpIHtcbiAgICAgICAgaWYgKCFzeW0pIHN5bSA9IGF3YWl0IGxvYWRTeW1zKHN5bU5hbWUpO1xuICAgICAgICB3Y09wcy5sb2dTZXRTaWduYWw9IGZ1bmN0aW9uKGxhYmVsSWR4LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIGxpbmUgYmVsb3cgc3BsaXRzIHRoZSBhcnJvdyBsb2cgaW50byAyIHN0cmluZ3MgdG8gYXZvaWQgc29tZSBTZWN1cmUgRUNNQVNjcmlwdCBpc3N1ZXNcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiU0VUIFwiICsgc3ltLmxhYmVsSWR4Mk5hbWVbbGFiZWxJZHhdICsgXCIgPFwiICsgXCItLSBcIiArIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5nZXQpIHtcbiAgICAgICAgaWYgKCFzeW0pIHN5bSA9IGF3YWl0IGxvYWRTeW1zKHN5bU5hbWUpO1xuICAgICAgICB3Y09wcy5sb2dHZXRTaWduYWw9IGZ1bmN0aW9uKHZhcklkeCwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBsaW5lIGJlbG93IHNwbGl0cyB0aGUgYXJyb3cgbG9nIGludG8gMiBzdHJpbmdzIHRvIGF2b2lkIHNvbWUgU2VjdXJlIEVDTUFTY3JpcHQgaXNzdWVzXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkdFVCBcIiArIHN5bS5sYWJlbElkeDJOYW1lW3ZhcklkeF0gKyBcIiAtLVwiICsgXCI+IFwiICsgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRyaWdnZXIpIHtcbiAgICAgICAgaWYgKCFzeW0pIHN5bSA9IGF3YWl0IGxvYWRTeW1zKHN5bU5hbWUpO1xuICAgICAgICB3Y09wcy5sb2dTdGFydENvbXBvbmVudD0gZnVuY3Rpb24oY0lkeCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJTVEFSVDogXCIgKyBzeW0uY29tcG9uZW50SWR4Mk5hbWVbY0lkeF0pO1xuICAgICAgICB9O1xuICAgICAgICB3Y09wcy5sb2dGaW5pc2hDb21wb25lbnQ9IGZ1bmN0aW9uKGNJZHgpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRklOSVNIOiBcIiArIHN5bS5jb21wb25lbnRJZHgyTmFtZVtjSWR4XSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHdjT3BzLnN5bSA9IHN5bTtcblxuICAgIGNvbnN0IHdjID0gYXdhaXQgV2l0bmVzc0NhbGN1bGF0b3JCdWlsZGVyKHdhc20sIHdjT3BzKTtcbiAgICBjb25zdCB3ID0gYXdhaXQgd2MuY2FsY3VsYXRlV2l0bmVzcyhpbnB1dCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBmZFd0bnMgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZSh3dG5zRmlsZU5hbWUsIFwid3Ruc1wiLCAyLCAyKTtcblxuICAgIGF3YWl0IHd0bnNVdGlscy53cml0ZShmZFd0bnMsIHcsIHdjLnByaW1lKTtcblxuICAgIGF3YWl0IGZkV3Rucy5jbG9zZSgpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/wtns_debug.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/wtns_export_json.js":
/*!******************************************************!*\
  !*** ./node_modules/snarkjs/src/wtns_export_json.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsExportJson)\n/* harmony export */ });\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/./node_modules/snarkjs/src/wtns_utils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nasync function wtnsExportJson(wtnsFileName) {\n\n    const w = await (0,_wtns_utils_js__WEBPACK_IMPORTED_MODULE_0__.read)(wtnsFileName);\n\n    return w;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19leHBvcnRfanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFDOztBQUV0Qjs7QUFFZixvQkFBb0Isb0RBQUk7O0FBRXhCO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19leHBvcnRfanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQge3JlYWR9IGZyb20gXCIuL3d0bnNfdXRpbHMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gd3Ruc0V4cG9ydEpzb24od3Ruc0ZpbGVOYW1lKSB7XG5cbiAgICBjb25zdCB3ID0gYXdhaXQgcmVhZCh3dG5zRmlsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHc7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/wtns_export_json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/wtns_utils.js":
/*!************************************************!*\
  !*** ./node_modules/snarkjs/src/wtns_utils.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   read: () => (/* binding */ read),\n/* harmony export */   readHeader: () => (/* binding */ readHeader),\n/* harmony export */   write: () => (/* binding */ write),\n/* harmony export */   writeBin: () => (/* binding */ writeBin)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function write(fd, witness, prime) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, prime, n8);\n    await fd.writeULE32(witness.length);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    for (let i=0; i<witness.length; i++) {\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, witness[i], n8);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd, 2);\n\n\n}\n\nasync function writeBin(fd, witnessBin, prime) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, prime, n8);\n    if (witnessBin.byteLength % n8 != 0) {\n        throw new Error(\"Invalid witness length\");\n    }\n    await fd.writeULE32(witnessBin.byteLength / n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    await fd.write(witnessBin);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n}\n\nasync function readHeader(fd, sections) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 1);\n    const n8 = await fd.readULE32();\n    const q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8);\n    const nWitness = await fd.readULE32();\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return {n8, q, nWitness};\n\n}\n\nasync function read(fileName) {\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(fileName, \"wtns\", 2);\n\n    const {n8, nWitness} = await readHeader(fd, sections);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const res = [];\n    for (let i=0; i<nWitness; i++) {\n        const v = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8);\n        res.push(v);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    await fd.close();\n\n    return res;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVzQzs7QUFFYzs7O0FBRzdDOztBQUVQLFVBQVUsa0VBQThCO0FBQ3hDLDZCQUE2QixnREFBTTtBQUNuQztBQUNBLFVBQVUsNERBQXdCO0FBQ2xDO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixrQkFBa0I7QUFDcEMsY0FBYyw0REFBd0I7QUFDdEM7QUFDQSxVQUFVLGdFQUE0Qjs7O0FBR3RDOztBQUVPOztBQUVQLFVBQVUsa0VBQThCO0FBQ3hDLDZCQUE2QixnREFBTTtBQUNuQztBQUNBLFVBQVUsNERBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7OztBQUd0QyxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLFVBQVUsZ0VBQTRCOztBQUV0Qzs7QUFFTzs7QUFFUCxVQUFVLHVFQUFtQztBQUM3QztBQUNBLG9CQUFvQiwyREFBdUI7QUFDM0M7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckMsWUFBWTs7QUFFWjs7QUFFTzs7QUFFUCxXQUFXLGNBQWMsUUFBUSw0REFBd0I7O0FBRXpELFdBQVcsY0FBYzs7QUFFekIsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSxrQkFBa0IsWUFBWTtBQUM5Qix3QkFBd0IsMkRBQXVCO0FBQy9DO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckM7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy93dG5zX3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlKGZkLCB3aXRuZXNzLCBwcmltZSkge1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAxKTtcbiAgICBjb25zdCBuOCA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZSkgLSAxKSAvIDY0KSArMSkqODtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKG44KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMud3JpdGVCaWdJbnQoZmQsIHByaW1lLCBuOCk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMih3aXRuZXNzLmxlbmd0aCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDIpO1xuICAgIGZvciAobGV0IGk9MDsgaTx3aXRuZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy53cml0ZUJpZ0ludChmZCwgd2l0bmVzc1tpXSwgbjgpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkLCAyKTtcblxuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZUJpbihmZCwgd2l0bmVzc0JpbiwgcHJpbWUpIHtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMSk7XG4gICAgY29uc3QgbjggPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWUpIC0gMSkgLyA2NCkgKzEpKjg7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihuOCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLndyaXRlQmlnSW50KGZkLCBwcmltZSwgbjgpO1xuICAgIGlmICh3aXRuZXNzQmluLmJ5dGVMZW5ndGggJSBuOCAhPSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2l0bmVzcyBsZW5ndGhcIik7XG4gICAgfVxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIod2l0bmVzc0Jpbi5ieXRlTGVuZ3RoIC8gbjgpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDIpO1xuICAgIGF3YWl0IGZkLndyaXRlKHdpdG5lc3NCaW4pO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyKGZkLCBzZWN0aW9ucykge1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAxKTtcbiAgICBjb25zdCBuOCA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IHEgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpZ0ludChmZCwgbjgpO1xuICAgIGNvbnN0IG5XaXRuZXNzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiB7bjgsIHEsIG5XaXRuZXNzfTtcblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZChmaWxlTmFtZSkge1xuXG4gICAgY29uc3Qge2ZkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoZmlsZU5hbWUsIFwid3Ruc1wiLCAyKTtcblxuICAgIGNvbnN0IHtuOCwgbldpdG5lc3N9ID0gYXdhaXQgcmVhZEhlYWRlcihmZCwgc2VjdGlvbnMpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAyKTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bldpdG5lc3M7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaWdJbnQoZmQsIG44KTtcbiAgICAgICAgcmVzLnB1c2godik7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/wtns_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey.js":
/*!******************************************!*\
  !*** ./node_modules/snarkjs/src/zkey.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   beacon: () => (/* reexport safe */ _zkey_beacon_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   bellmanContribute: () => (/* reexport safe */ _zkey_bellman_contribute_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   contribute: () => (/* reexport safe */ _zkey_contribute_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   exportBellman: () => (/* reexport safe */ _zkey_export_bellman_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _zkey_export_json_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   exportSolidityVerifier: () => (/* reexport safe */ _zkey_export_solidityverifier_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   exportVerificationKey: () => (/* reexport safe */ _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   importBellman: () => (/* reexport safe */ _zkey_import_bellman_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   newZKey: () => (/* reexport safe */ _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verifyFromInit: () => (/* reexport safe */ _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   verifyFromR1cs: () => (/* reexport safe */ _zkey_verify_fromr1cs_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_new.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_new.js\");\n/* harmony import */ var _zkey_export_bellman_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_export_bellman.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_export_bellman.js\");\n/* harmony import */ var _zkey_import_bellman_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zkey_import_bellman.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_import_bellman.js\");\n/* harmony import */ var _zkey_verify_fromr1cs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zkey_verify_fromr1cs.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_verify_fromr1cs.js\");\n/* harmony import */ var _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_verify_frominit.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_verify_frominit.js\");\n/* harmony import */ var _zkey_contribute_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zkey_contribute.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_contribute.js\");\n/* harmony import */ var _zkey_beacon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zkey_beacon.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_beacon.js\");\n/* harmony import */ var _zkey_export_json_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zkey_export_json.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_export_json.js\");\n/* harmony import */ var _zkey_bellman_contribute_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./zkey_bellman_contribute.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_bellman_contribute.js\");\n/* harmony import */ var _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./zkey_export_verificationkey.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_export_verificationkey.js\");\n/* harmony import */ var _zkey_export_solidityverifier_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./zkey_export_solidityverifier.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_export_solidityverifier.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR2lEO0FBQ2lCO0FBQ0E7QUFDRTtBQUNBO0FBQ1Q7QUFDUjtBQUNTO0FBQ2M7QUFDUTtBQUNFIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuXG5leHBvcnQge2RlZmF1bHQgYXMgbmV3WktleX0gZnJvbSBcIi4vemtleV9uZXcuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRCZWxsbWFufSBmcm9tIFwiLi96a2V5X2V4cG9ydF9iZWxsbWFuLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW1wb3J0QmVsbG1hbn0gZnJvbSBcIi4vemtleV9pbXBvcnRfYmVsbG1hbi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZlcmlmeUZyb21SMWNzfSBmcm9tIFwiLi96a2V5X3ZlcmlmeV9mcm9tcjFjcy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZlcmlmeUZyb21Jbml0fSBmcm9tIFwiLi96a2V5X3ZlcmlmeV9mcm9taW5pdC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNvbnRyaWJ1dGV9IGZyb20gXCIuL3prZXlfY29udHJpYnV0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGJlYWNvbn0gZnJvbSBcIi4vemtleV9iZWFjb24uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRKc29ufSBmcm9tIFwiLi96a2V5X2V4cG9ydF9qc29uLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYmVsbG1hbkNvbnRyaWJ1dGV9IGZyb20gXCIuL3prZXlfYmVsbG1hbl9jb250cmlidXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0VmVyaWZpY2F0aW9uS2V5fSBmcm9tIFwiLi96a2V5X2V4cG9ydF92ZXJpZmljYXRpb25rZXkuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRTb2xpZGl0eVZlcmlmaWVyfSBmcm9tIFwiLi96a2V5X2V4cG9ydF9zb2xpZGl0eXZlcmlmaWVyLmpzXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_beacon.js":
/*!*************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_beacon.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ beacon)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(ssr)/./node_modules/snarkjs/src/mpc_applykey.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\nasync function beacon(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger) {\n    const beaconHash = _misc_js__WEBPACK_IMPORTED_MODULE_3__.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections: sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdOld, sections);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const transcriptHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });;\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_4__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 1;\n    curContribution.numIterationsExp = numIterationsExp;\n    curContribution.beaconHash = beaconHash;\n\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeHeader(fdNew, zkey);\n\n    // IC\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__.applyKeyToSection)(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__.applyKeyToSection)(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });;\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9iZWFjb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDtBQUNQO0FBQ1c7QUFDdEI7QUFDYztBQUNQO0FBQ1c7QUFDRTs7O0FBR3ZDO0FBQ2YsdUJBQXVCLG1EQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxXQUFXLCtCQUErQixRQUFRLDREQUF3QjtBQUMxRSx1QkFBdUIsc0RBQW9COztBQUUzQztBQUNBO0FBQ0E7OztBQUdBLHdCQUF3Qix5REFBUTs7QUFFaEMsNEJBQTRCLHlEQUF1Qjs7QUFFbkQsd0JBQXdCLDhEQUEwQjs7QUFFbEQsc0JBQXNCLHlEQUF3Qjs7QUFFOUMsNkJBQTZCLDBEQUFPLFVBQVUsV0FBVztBQUN6RDtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQsUUFBUSxzREFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0RBQVk7QUFDaEIsSUFBSSxrREFBWTtBQUNoQjtBQUNBLGtDQUFrQyxxREFBUTtBQUMxQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLHVEQUFxQjs7QUFFL0I7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLG1FQUFpQjtBQUMzQixVQUFVLG1FQUFpQjs7QUFFM0IsVUFBVSwwREFBd0I7O0FBRWxDO0FBQ0E7O0FBRUEsK0JBQStCLDBEQUFPLFVBQVUsV0FBVztBQUMzRCxJQUFJLHNEQUFnQjs7QUFFcEI7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfYmVhY29uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IGdldEN1cnZlRnJvbVEgYXMgZ2V0Q3VydmUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgYmxha2UyYiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2JsYWtlMmJcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IGhhc2hUb0cyIGFzIGhhc2hUb0cyIH0gZnJvbSBcIi4va2V5cGFpci5qc1wiO1xuaW1wb3J0IHsgYXBwbHlLZXlUb1NlY3Rpb24gfSBmcm9tIFwiLi9tcGNfYXBwbHlrZXkuanNcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBiZWFjb24oemtleU5hbWVPbGQsIHprZXlOYW1lTmV3LCBuYW1lLCBiZWFjb25IYXNoU3RyLCBudW1JdGVyYXRpb25zRXhwLCBsb2dnZXIpIHtcbiAgICBjb25zdCBiZWFjb25IYXNoID0gbWlzYy5oZXgyQnl0ZUFycmF5KGJlYWNvbkhhc2hTdHIpO1xuICAgIGlmICggICAoYmVhY29uSGFzaC5ieXRlTGVuZ3RoID09IDApXG4gICAgICAgIHx8IChiZWFjb25IYXNoLmJ5dGVMZW5ndGgqMiAhPWJlYWNvbkhhc2hTdHIubGVuZ3RoKSlcbiAgICB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgQmVhY29uIEhhc2guIChJdCBtdXN0IGJlIGEgdmFsaWQgaGV4YWRlY2ltYWwgc2VxdWVuY2UpXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiZWFjb25IYXNoLmxlbmd0aD49MjU2KSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIk1heGltdW0gbGVuZ3RoIG9mIGJlYWNvbiBoYXNoIGlzIDI1NSBieXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG51bUl0ZXJhdGlvbnNFeHAgPSBwYXJzZUludChudW1JdGVyYXRpb25zRXhwKTtcbiAgICBpZiAoKG51bUl0ZXJhdGlvbnNFeHA8MTApfHwobnVtSXRlcmF0aW9uc0V4cD42MykpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1JdGVyYXRpb25zRXhwLiAoTXVzdCBiZSBiZXR3ZWVuIDEwIGFuZCA2MylcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zOiBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoemtleU5hbWVPbGQsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcblxuICAgIGlmICh6a2V5LnByb3RvY29sICE9IFwiZ3JvdGgxNlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcblxuICAgIGNvbnN0IG1wY1BhcmFtcyA9IGF3YWl0IHprZXlVdGlscy5yZWFkTVBDUGFyYW1zKGZkT2xkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZSh6a2V5TmFtZU5ldywgXCJ6a2V5XCIsIDEsIDEwKTtcblxuICAgIGNvbnN0IHJuZyA9IGF3YWl0IG1pc2Mucm5nRnJvbUJlYWNvblBhcmFtcyhiZWFjb25IYXNoLCBudW1JdGVyYXRpb25zRXhwKTtcblxuICAgIGNvbnN0IHRyYW5zY3JpcHRIYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTs7XG4gICAgdHJhbnNjcmlwdEhhc2hlci51cGRhdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHV0aWxzLmhhc2hQdWJLZXkodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJDb250cmlidXRpb24gPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEgPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5ID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEuZnJvbVJuZyhybmcpKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KSk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3gpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0ID0gdHJhbnNjcmlwdEhhc2hlci5kaWdlc3QoKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AgPSBoYXNoVG9HMihjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLnRyYW5zY3JpcHQpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcHggPSBjdXJ2ZS5HMi50b0FmZmluZShjdXJ2ZS5HMi50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcCwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSkpO1xuXG4gICAgemtleS52a19kZWx0YV8xID0gY3VydmUuRzEudGltZXNGcih6a2V5LnZrX2RlbHRhXzEsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpO1xuICAgIHprZXkudmtfZGVsdGFfMiA9IGN1cnZlLkcyLnRpbWVzRnIoemtleS52a19kZWx0YV8yLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YUFmdGVyID0gemtleS52a19kZWx0YV8xO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLnR5cGUgPSAxO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5udW1JdGVyYXRpb25zRXhwID0gbnVtSXRlcmF0aW9uc0V4cDtcbiAgICBjdXJDb250cmlidXRpb24uYmVhY29uSGFzaCA9IGJlYWNvbkhhc2g7XG5cbiAgICBpZiAobmFtZSkgY3VyQ29udHJpYnV0aW9uLm5hbWUgPSBuYW1lO1xuXG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgemtleVV0aWxzLndyaXRlSGVhZGVyKGZkTmV3LCB6a2V5KTtcblxuICAgIC8vIElDXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDMpO1xuXG4gICAgLy8gQ29lZmZzIChLZWVwIG9yaWdpbmFsKVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA0KTtcblxuICAgIC8vIEEgU2VjdGlvblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1KTtcblxuICAgIC8vIEIxIFNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNik7XG5cbiAgICAvLyBCMiBTZWN0aW9uXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDcpO1xuXG4gICAgY29uc3QgaW52RGVsdGEgPSBjdXJ2ZS5Gci5pbnYoY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOCwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiTCBTZWN0aW9uXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOSwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiSCBTZWN0aW9uXCIsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCB6a2V5VXRpbHMud3JpdGVNUENQYXJhbXMoZmROZXcsIGN1cnZlLCBtcGNQYXJhbXMpO1xuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7O1xuICAgIHV0aWxzLmhhc2hQdWJLZXkoY29udHJpYnV0aW9uSGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2ggPSBjb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY29udHJpYnV0aW9uSGFzaCwgXCJDb250cmlidXRpb24gSGFzaDogXCIpKTtcblxuICAgIHJldHVybiBjb250cmlidXRpb25IYXNoO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_beacon.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_bellman_contribute.js":
/*!*************************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_bellman_contribute.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ bellmanContribute)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(ssr)/./node_modules/snarkjs/src/mpc_applykey.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/./node_modules/snarkjs/src/keypair.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\n\n\n\n\n\n\n\n\nasync function bellmanContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_2__.getRandomRng(entropy);\n\n    const delta = curve.Fr.fromRng(rng);\n    const invDelta = curve.Fr.inv(delta);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const fdFrom = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(challengeFilename);\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(responseFileName);\n\n\n    await copy(sG1); // alpha1\n    await copy(sG1); // beta1\n    await copy(sG2); // beta2\n    await copy(sG2); // gamma2\n    const oldDelta1 = await readG1();\n    const delta1 = curve.G1.timesFr(oldDelta1, delta);\n    await writeG1(delta1);\n    const oldDelta2 = await readG2();\n    const delta2 = curve.G2.timesFr(oldDelta2, delta);\n    await writeG2(delta2);\n\n    // IC\n    const nIC = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nIC);\n    await copy(nIC*sG1);\n\n    // H\n    const nH = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nH);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, null, curve, \"G1\", nH, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"H\", logger);\n\n    // L\n    const nL = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nL);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_3__.applyKeyToChallengeSection)(fdFrom, fdTo, null, curve, \"G1\", nL, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"L\", logger);\n\n    // A\n    const nA = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nA);\n    await copy(nA*sG1);\n\n    // B1\n    const nB1 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB1);\n    await copy(nB1*sG1);\n\n    // B2\n    const nB2 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB2);\n    await copy(nB2*sG2);\n\n\n    //////////\n    /// Read contributions\n    //////////\n    const transcriptHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 });;\n\n    const mpcParams = {};\n    // csHash\n    mpcParams.csHash =  await fdFrom.read(64);\n    transcriptHasher.update(mpcParams.csHash);\n\n    const nContributions = await fdFrom.readUBE32();\n    mpcParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1();\n        c.delta.g1_s = await readG1();\n        c.delta.g1_sx = await readG1();\n        c.delta.g2_spx = await readG2();\n        c.transcript = await fdFrom.read(64);\n        mpcParams.contributions.push(c);\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(transcriptHasher, curve, c);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = delta;\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, delta));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_4__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, delta));\n    curContribution.deltaAfter = delta1;\n    curContribution.type = 0;\n    mpcParams.contributions.push(curContribution);\n\n\n    //////////\n    /// Write Contribution\n    //////////\n\n    await fdTo.write(mpcParams.csHash);\n    await fdTo.writeUBE32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdTo.write(c.transcript);\n    }\n\n    const contributionHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_5__.blake2b.create({ dkLen: 64 });;\n    (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n\n    return contributionHash;\n\n    async function copy(nBytes) {\n        const CHUNK_SIZE = fdFrom.pageSize*2;\n        for (let i=0; i<nBytes; i+= CHUNK_SIZE) {\n            const n = Math.min(nBytes -i, CHUNK_SIZE);\n            const buff = await fdFrom.read(n);\n            await fdTo.write(buff);\n        }\n    }\n\n    async function readG1() {\n        const buff = await fdFrom.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2() {\n        const buff = await fdFrom.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9iZWxsbWFuX2NvbnRyaWJ1dGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDVztBQUNQO0FBQ1A7QUFDNkI7QUFDbEI7QUFDTzs7QUFFckM7QUFDZixzQkFBc0Isa0RBQWlCOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLGtEQUFxQjtBQUM5Qyx1QkFBdUIsb0RBQXVCOzs7QUFHOUMscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRFQUEwQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0RUFBMEI7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQU8sVUFBVSxXQUFXOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBVTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCO0FBQ0Esa0NBQWtDLHFEQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isa0NBQWtDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiwwREFBTyxVQUFVLFdBQVc7QUFDM0QsSUFBSSwwREFBVTs7QUFFZDs7QUFFQSw0QkFBNEIsZ0RBQWU7O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2JlbGxtYW5fY29udHJpYnV0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBGb3JtYXQgb2YgdGhlIG91dHB1dFxuLy8gICAgICBIYXNoIG9mIHRoZSBsYXN0IGNvbnRyaWJ1dGlvbiAgNjQgQnl0ZXNcbi8vICAgICAgMl5OKjItMSBUYXVHMSBQb2ludHMgKGNvbXByZXNzZWQpXG4vLyAgICAgIDJeTiBUYXVHMiBQb2ludHMgKGNvbXByZXNzZWQpXG4vLyAgICAgIDJeTiBBbHBoYVRhdUcxIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgMl5OIEJldGFUYXVHMSBQb2ludHMgKGNvbXByZXNzZWQpXG4vLyAgICAgIFB1YmxpYyBLZXlcbi8vICAgICAgICAgIEJldGFHMiAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnMgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSpzKnRhdSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnQgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSp0KmFscGhhIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnUqYmV0YSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcyKnNwKnRhdSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcyKnRwKmFscGhhIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzIqdXAqYmV0YSAoY29tcHJlc3NlZClcblxuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5pbXBvcnQgeyBibGFrZTJiIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvYmxha2UyYlwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbiB9IGZyb20gXCIuL21wY19hcHBseWtleS5qc1wiO1xuaW1wb3J0IHsgaGFzaFB1YktleSB9IGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IGhhc2hUb0cyIGFzIGhhc2hUb0cyIH0gZnJvbSBcIi4va2V5cGFpci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBiZWxsbWFuQ29udHJpYnV0ZShjdXJ2ZSwgY2hhbGxlbmdlRmlsZW5hbWUsIHJlc3BvbnNlRmlsZU5hbWUsIGVudHJvcHksIGxvZ2dlcikge1xuICAgIGNvbnN0IHJuZyA9IGF3YWl0IG1pc2MuZ2V0UmFuZG9tUm5nKGVudHJvcHkpO1xuXG4gICAgY29uc3QgZGVsdGEgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAgY29uc3QgaW52RGVsdGEgPSBjdXJ2ZS5Gci5pbnYoZGVsdGEpO1xuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcblxuICAgIGNvbnN0IGZkRnJvbSA9IGF3YWl0IGZhc3RGaWxlLnJlYWRFeGlzdGluZyhjaGFsbGVuZ2VGaWxlbmFtZSk7XG4gICAgY29uc3QgZmRUbyA9IGF3YWl0IGZhc3RGaWxlLmNyZWF0ZU92ZXJyaWRlKHJlc3BvbnNlRmlsZU5hbWUpO1xuXG5cbiAgICBhd2FpdCBjb3B5KHNHMSk7IC8vIGFscGhhMVxuICAgIGF3YWl0IGNvcHkoc0cxKTsgLy8gYmV0YTFcbiAgICBhd2FpdCBjb3B5KHNHMik7IC8vIGJldGEyXG4gICAgYXdhaXQgY29weShzRzIpOyAvLyBnYW1tYTJcbiAgICBjb25zdCBvbGREZWx0YTEgPSBhd2FpdCByZWFkRzEoKTtcbiAgICBjb25zdCBkZWx0YTEgPSBjdXJ2ZS5HMS50aW1lc0ZyKG9sZERlbHRhMSwgZGVsdGEpO1xuICAgIGF3YWl0IHdyaXRlRzEoZGVsdGExKTtcbiAgICBjb25zdCBvbGREZWx0YTIgPSBhd2FpdCByZWFkRzIoKTtcbiAgICBjb25zdCBkZWx0YTIgPSBjdXJ2ZS5HMi50aW1lc0ZyKG9sZERlbHRhMiwgZGVsdGEpO1xuICAgIGF3YWl0IHdyaXRlRzIoZGVsdGEyKTtcblxuICAgIC8vIElDXG4gICAgY29uc3QgbklDID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuSUMpO1xuICAgIGF3YWl0IGNvcHkobklDKnNHMSk7XG5cbiAgICAvLyBIXG4gICAgY29uc3QgbkggPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5IKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIG51bGwsIGN1cnZlLCBcIkcxXCIsIG5ILCBpbnZEZWx0YSwgY3VydmUuRnIuZSgxKSwgXCJVTkNPTVBSRVNTRURcIiwgXCJIXCIsIGxvZ2dlcik7XG5cbiAgICAvLyBMXG4gICAgY29uc3QgbkwgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5MKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIG51bGwsIGN1cnZlLCBcIkcxXCIsIG5MLCBpbnZEZWx0YSwgY3VydmUuRnIuZSgxKSwgXCJVTkNPTVBSRVNTRURcIiwgXCJMXCIsIGxvZ2dlcik7XG5cbiAgICAvLyBBXG4gICAgY29uc3QgbkEgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5BKTtcbiAgICBhd2FpdCBjb3B5KG5BKnNHMSk7XG5cbiAgICAvLyBCMVxuICAgIGNvbnN0IG5CMSA9IGF3YWl0IGZkRnJvbS5yZWFkVUJFMzIoKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlVUJFMzIobkIxKTtcbiAgICBhd2FpdCBjb3B5KG5CMSpzRzEpO1xuXG4gICAgLy8gQjJcbiAgICBjb25zdCBuQjIgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5CMik7XG4gICAgYXdhaXQgY29weShuQjIqc0cyKTtcblxuXG4gICAgLy8vLy8vLy8vL1xuICAgIC8vLyBSZWFkIGNvbnRyaWJ1dGlvbnNcbiAgICAvLy8vLy8vLy8vXG4gICAgY29uc3QgdHJhbnNjcmlwdEhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pOztcblxuICAgIGNvbnN0IG1wY1BhcmFtcyA9IHt9O1xuICAgIC8vIGNzSGFzaFxuICAgIG1wY1BhcmFtcy5jc0hhc2ggPSAgYXdhaXQgZmRGcm9tLnJlYWQoNjQpO1xuICAgIHRyYW5zY3JpcHRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuXG4gICAgY29uc3QgbkNvbnRyaWJ1dGlvbnMgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bkNvbnRyaWJ1dGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBjID0geyBkZWx0YTp7fSB9O1xuICAgICAgICBjLmRlbHRhQWZ0ZXIgPSBhd2FpdCByZWFkRzEoKTtcbiAgICAgICAgYy5kZWx0YS5nMV9zID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgICAgIGMuZGVsdGEuZzFfc3ggPSBhd2FpdCByZWFkRzEoKTtcbiAgICAgICAgYy5kZWx0YS5nMl9zcHggPSBhd2FpdCByZWFkRzIoKTtcbiAgICAgICAgYy50cmFuc2NyaXB0ID0gYXdhaXQgZmRGcm9tLnJlYWQoNjQpO1xuICAgICAgICBtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5wdXNoKGMpO1xuICAgICAgICBoYXNoUHViS2V5KHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJDb250cmlidXRpb24gPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEgPSB7fTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5ID0gZGVsdGE7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzRnIoY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MsIGRlbHRhKSk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyk7XG4gICAgdXRpbHMuaGFzaEcxKHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3gpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0ID0gdHJhbnNjcmlwdEhhc2hlci5kaWdlc3QoKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AgPSBoYXNoVG9HMihjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLnRyYW5zY3JpcHQpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcHggPSBjdXJ2ZS5HMi50b0FmZmluZShjdXJ2ZS5HMi50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcCwgZGVsdGEpKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGFBZnRlciA9IGRlbHRhMTtcbiAgICBjdXJDb250cmlidXRpb24udHlwZSA9IDA7XG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG5cbiAgICAvLy8vLy8vLy8vXG4gICAgLy8vIFdyaXRlIENvbnRyaWJ1dGlvblxuICAgIC8vLy8vLy8vLy9cblxuICAgIGF3YWl0IGZkVG8ud3JpdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGFBZnRlcik7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YS5nMV9zKTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhLmcxX3N4KTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMihjLmRlbHRhLmcyX3NweCk7XG4gICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYy50cmFuc2NyaXB0KTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250cmlidXRpb25IYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTs7XG4gICAgaGFzaFB1YktleShjb250cmlidXRpb25IYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24pO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaCA9IGNvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjb250cmlidXRpb25IYXNoLCBcIkNvbnRyaWJ1dGlvbiBIYXNoOiBcIikpO1xuXG4gICAgYXdhaXQgZmRUby5jbG9zZSgpO1xuICAgIGF3YWl0IGZkRnJvbS5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIGNvbnRyaWJ1dGlvbkhhc2g7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb3B5KG5CeXRlcykge1xuICAgICAgICBjb25zdCBDSFVOS19TSVpFID0gZmRGcm9tLnBhZ2VTaXplKjI7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQnl0ZXM7IGkrPSBDSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4obkJ5dGVzIC1pLCBDSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChuKTtcbiAgICAgICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzEoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChjdXJ2ZS5HMS5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzEuZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCAwKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzIoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChjdXJ2ZS5HMi5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzIuZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCAwKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUcxKFApIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHNHMSk7XG4gICAgICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDAsIFApO1xuICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIoUCkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc0cyKTtcbiAgICAgICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgUCk7XG4gICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZik7XG4gICAgfVxuXG5cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_bellman_contribute.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_constants.js":
/*!****************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_constants.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FFLONK_PROTOCOL_ID: () => (/* binding */ FFLONK_PROTOCOL_ID),\n/* harmony export */   GROTH16_PROTOCOL_ID: () => (/* binding */ GROTH16_PROTOCOL_ID),\n/* harmony export */   HEADER_ZKEY_SECTION: () => (/* binding */ HEADER_ZKEY_SECTION),\n/* harmony export */   PLONK_PROTOCOL_ID: () => (/* binding */ PLONK_PROTOCOL_ID)\n/* harmony export */ });\nconst HEADER_ZKEY_SECTION = 1;\n\nconst GROTH16_PROTOCOL_ID = 1;\nconst PLONK_PROTOCOL_ID = 2;\nconst FFLONK_PROTOCOL_ID = 10;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFPOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgSEVBREVSX1pLRVlfU0VDVElPTiA9IDE7XG5cbmV4cG9ydCBjb25zdCBHUk9USDE2X1BST1RPQ09MX0lEID0gMTtcbmV4cG9ydCBjb25zdCBQTE9OS19QUk9UT0NPTF9JRCA9IDI7XG5leHBvcnQgY29uc3QgRkZMT05LX1BST1RPQ09MX0lEID0gMTA7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_contribute.js":
/*!*****************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_contribute.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2contribute)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(ssr)/./node_modules/snarkjs/src/mpc_applykey.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\nasync function phase2contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger) {\n\n    const {fd: fdOld, sections: sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdOld, sections);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomRng(entropy);\n\n    const transcriptHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_4__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 0;\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeHeader(fdNew, zkey);\n\n    // IC\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__.applyKeyToSection)(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_5__.applyKeyToSection)(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9jb250cmlidXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDUDtBQUNXO0FBQ3RCO0FBQ2M7QUFDUDtBQUNXO0FBQ0U7O0FBRXZDOztBQUVmLFdBQVcsK0JBQStCLFFBQVEsNERBQXdCO0FBQzFFLHVCQUF1QixzREFBb0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix5REFBUTs7QUFFaEMsNEJBQTRCLHlEQUF1Qjs7QUFFbkQsd0JBQXdCLDhEQUEwQjs7O0FBR2xELHNCQUFzQixrREFBaUI7O0FBRXZDLDZCQUE2QiwwREFBTyxVQUFVLFdBQVc7QUFDekQ7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELFFBQVEsc0RBQWdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtEQUFZO0FBQ2hCLElBQUksa0RBQVk7QUFDaEI7QUFDQSxrQ0FBa0MscURBQVE7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsdURBQXFCOztBQUUvQjtBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBLFVBQVUsbUVBQWlCO0FBQzNCLFVBQVUsbUVBQWlCOztBQUUzQixVQUFVLDBEQUF3Qjs7QUFFbEM7QUFDQTs7QUFFQSwrQkFBK0IsMERBQU8sVUFBVSxXQUFXO0FBQzNELElBQUksc0RBQWdCOztBQUVwQjs7QUFFQSw0QkFBNEIsZ0RBQWU7QUFDM0MsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfY29udHJpYnV0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHprZXlVdGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21RIGFzIGdldEN1cnZlIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcbmltcG9ydCB7IGJsYWtlMmIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9ibGFrZTJiXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBoYXNoVG9HMiBhcyBoYXNoVG9HMiB9IGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmltcG9ydCB7IGFwcGx5S2V5VG9TZWN0aW9uIH0gZnJvbSBcIi4vbXBjX2FwcGx5a2V5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBoYXNlMmNvbnRyaWJ1dGUoemtleU5hbWVPbGQsIHprZXlOYW1lTmV3LCBuYW1lLCBlbnRyb3B5LCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zOiBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoemtleU5hbWVPbGQsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuXG4gICAgY29uc3QgbXBjUGFyYW1zID0gYXdhaXQgemtleVV0aWxzLnJlYWRNUENQYXJhbXMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKHprZXlOYW1lTmV3LCBcInprZXlcIiwgMSwgMTApO1xuXG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBtaXNjLmdldFJhbmRvbVJuZyhlbnRyb3B5KTtcblxuICAgIGNvbnN0IHRyYW5zY3JpcHRIYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTtcbiAgICB0cmFuc2NyaXB0SGFzaGVyLnVwZGF0ZShtcGNQYXJhbXMuY3NIYXNoKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXRpbHMuaGFzaFB1YktleSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0pO1xuICAgIH1cblxuICAgIGNvbnN0IGN1ckNvbnRyaWJ1dGlvbiA9IHt9O1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YSA9IHt9O1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzRnIoY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpKTtcbiAgICB1dGlscy5oYXNoRzEodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zKTtcbiAgICB1dGlscy5oYXNoRzEodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zeCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLnRyYW5zY3JpcHQgPSB0cmFuc2NyaXB0SGFzaGVyLmRpZ2VzdCgpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcCA9IGhhc2hUb0cyKGN1cnZlLCBjdXJDb250cmlidXRpb24udHJhbnNjcmlwdCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NweCA9IGN1cnZlLkcyLnRvQWZmaW5lKGN1cnZlLkcyLnRpbWVzRnIoY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NwLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KSk7XG5cbiAgICB6a2V5LnZrX2RlbHRhXzEgPSBjdXJ2ZS5HMS50aW1lc0ZyKHprZXkudmtfZGVsdGFfMSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG4gICAgemtleS52a19kZWx0YV8yID0gY3VydmUuRzIudGltZXNGcih6a2V5LnZrX2RlbHRhXzIsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhQWZ0ZXIgPSB6a2V5LnZrX2RlbHRhXzE7XG5cbiAgICBjdXJDb250cmlidXRpb24udHlwZSA9IDA7XG4gICAgaWYgKG5hbWUpIGN1ckNvbnRyaWJ1dGlvbi5uYW1lID0gbmFtZTtcblxuICAgIG1wY1BhcmFtcy5jb250cmlidXRpb25zLnB1c2goY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGF3YWl0IHprZXlVdGlscy53cml0ZUhlYWRlcihmZE5ldywgemtleSk7XG5cbiAgICAvLyBJQ1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAzKTtcblxuICAgIC8vIENvZWZmcyAoS2VlcCBvcmlnaW5hbClcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNCk7XG5cbiAgICAvLyBBIFNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNSk7XG5cbiAgICAvLyBCMSBTZWN0aW9uXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDYpO1xuXG4gICAgLy8gQjIgU2VjdGlvblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA3KTtcblxuICAgIGNvbnN0IGludkRlbHRhID0gY3VydmUuRnIuaW52KGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9TZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDgsIGN1cnZlLCBcIkcxXCIsIGludkRlbHRhLCBjdXJ2ZS5Gci5lKDEpLCBcIkwgU2VjdGlvblwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9TZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDksIGN1cnZlLCBcIkcxXCIsIGludkRlbHRhLCBjdXJ2ZS5Gci5lKDEpLCBcIkggU2VjdGlvblwiLCBsb2dnZXIpO1xuXG4gICAgYXdhaXQgemtleVV0aWxzLndyaXRlTVBDUGFyYW1zKGZkTmV3LCBjdXJ2ZSwgbXBjUGFyYW1zKTtcblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIHV0aWxzLmhhc2hQdWJLZXkoY29udHJpYnV0aW9uSGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2ggPSBjb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2gobXBjUGFyYW1zLmNzSGFzaCwgXCJDaXJjdWl0IEhhc2g6IFwiKSk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGNvbnRyaWJ1dGlvbkhhc2gsIFwiQ29udHJpYnV0aW9uIEhhc2g6IFwiKSk7XG5cbiAgICByZXR1cm4gY29udHJpYnV0aW9uSGFzaDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_contribute.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_export_bellman.js":
/*!*********************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_export_bellman.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2exportMPCParams)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n\n\n\n\n\n\nasync function phase2exportMPCParams(zkeyName, mpcparamsName, logger) {\n\n    const {fd: fdZKey, sections: sectionsZKey} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, sectionsZKey);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_3__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdZKey, curve, sectionsZKey);\n\n    const fdMPCParams = await fastfile__WEBPACK_IMPORTED_MODULE_2__.createOverride(mpcparamsName);\n\n    /////////////////////\n    // Verification Key Section\n    /////////////////////\n    await writeG1(zkey.vk_alpha_1);\n    await writeG1(zkey.vk_beta_1);\n    await writeG2(zkey.vk_beta_2);\n    await writeG2(zkey.vk_gamma_2);\n    await writeG1(zkey.vk_delta_1);\n    await writeG2(zkey.vk_delta_2);\n\n    // IC\n    let buffBasesIC;\n    buffBasesIC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 3);\n    buffBasesIC = await curve.G1.batchLEMtoU(buffBasesIC);\n\n    await writePointArray(\"G1\", buffBasesIC);\n\n    /////////////////////\n    // h Section\n    /////////////////////\n    const buffBasesH_Lodd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 9);\n\n    let buffBasesH_Tau;\n    buffBasesH_Tau = await curve.G1.fft(buffBasesH_Lodd, \"affine\", \"jacobian\", logger);\n    buffBasesH_Tau = await curve.G1.batchApplyKey(buffBasesH_Tau, curve.Fr.neg(curve.Fr.e(2)), curve.Fr.w[zkey.power+1], \"jacobian\", \"affine\", logger);\n\n    // Remove last element.  (The degree of H will be always m-2)\n    buffBasesH_Tau = buffBasesH_Tau.slice(0, buffBasesH_Tau.byteLength - sG1);\n    buffBasesH_Tau = await curve.G1.batchLEMtoU(buffBasesH_Tau);\n    await writePointArray(\"G1\", buffBasesH_Tau);\n\n    /////////////////////\n    // L section\n    /////////////////////\n    let buffBasesC;\n    buffBasesC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 8);\n    buffBasesC = await curve.G1.batchLEMtoU(buffBasesC);\n    await writePointArray(\"G1\", buffBasesC);\n\n    /////////////////////\n    // A Section (C section)\n    /////////////////////\n    let buffBasesA;\n    buffBasesA = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 5);\n    buffBasesA = await curve.G1.batchLEMtoU(buffBasesA);\n    await writePointArray(\"G1\", buffBasesA);\n\n    /////////////////////\n    // B1 Section\n    /////////////////////\n    let buffBasesB1;\n    buffBasesB1 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 6);\n    buffBasesB1 = await curve.G1.batchLEMtoU(buffBasesB1);\n    await writePointArray(\"G1\", buffBasesB1);\n\n    /////////////////////\n    // B2 Section\n    /////////////////////\n    let buffBasesB2;\n    buffBasesB2 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 7);\n    buffBasesB2 = await curve.G2.batchLEMtoU(buffBasesB2);\n    await writePointArray(\"G2\", buffBasesB2);\n\n    await fdMPCParams.write(mpcParams.csHash);\n    await writeU32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdMPCParams.write(c.transcript);\n    }\n\n    await fdZKey.close();\n    await fdMPCParams.close();\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writePointArray(groupName, buff) {\n        let sG;\n        if (groupName == \"G1\") {\n            sG = sG1;\n        } else {\n            sG = sG2;\n        }\n\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, buff.byteLength / sG, false);\n\n        await fdMPCParams.write(buffSize);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeU32(n) {\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, n, false);\n\n        await fdMPCParams.write(buffSize);\n    }\n\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfYmVsbG1hbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDb0Q7QUFDUDtBQUNSO0FBQ21COztBQUV6Qzs7QUFFZixXQUFXLG9DQUFvQyxRQUFRLDREQUF3QjtBQUMvRSx1QkFBdUIsc0RBQW9CO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IseURBQVE7QUFDaEM7QUFDQTs7QUFFQSw0QkFBNEIseURBQXVCOztBQUVuRCw4QkFBOEIsb0RBQXVCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qiw0REFBd0I7QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDREQUF3Qjs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDREQUF3QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDREQUF3QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfZXhwb3J0X2JlbGxtYW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHprZXlVdGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCB7IGdldEN1cnZlRnJvbVEgYXMgZ2V0Q3VydmUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGhhc2UyZXhwb3J0TVBDUGFyYW1zKHprZXlOYW1lLCBtcGNwYXJhbXNOYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRaS2V5LCBzZWN0aW9uczogc2VjdGlvbnNaS2V5fSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5TmFtZSwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXkgPSBhd2FpdCB6a2V5VXRpbHMucmVhZEhlYWRlcihmZFpLZXksIHNlY3Rpb25zWktleSk7XG4gICAgaWYgKHprZXkucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuXG4gICAgY29uc3QgbXBjUGFyYW1zID0gYXdhaXQgemtleVV0aWxzLnJlYWRNUENQYXJhbXMoZmRaS2V5LCBjdXJ2ZSwgc2VjdGlvbnNaS2V5KTtcblxuICAgIGNvbnN0IGZkTVBDUGFyYW1zID0gYXdhaXQgZmFzdEZpbGUuY3JlYXRlT3ZlcnJpZGUobXBjcGFyYW1zTmFtZSk7XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBWZXJpZmljYXRpb24gS2V5IFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBhd2FpdCB3cml0ZUcxKHprZXkudmtfYWxwaGFfMSk7XG4gICAgYXdhaXQgd3JpdGVHMSh6a2V5LnZrX2JldGFfMSk7XG4gICAgYXdhaXQgd3JpdGVHMih6a2V5LnZrX2JldGFfMik7XG4gICAgYXdhaXQgd3JpdGVHMih6a2V5LnZrX2dhbW1hXzIpO1xuICAgIGF3YWl0IHdyaXRlRzEoemtleS52a19kZWx0YV8xKTtcbiAgICBhd2FpdCB3cml0ZUcyKHprZXkudmtfZGVsdGFfMik7XG5cbiAgICAvLyBJQ1xuICAgIGxldCBidWZmQmFzZXNJQztcbiAgICBidWZmQmFzZXNJQyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgMyk7XG4gICAgYnVmZkJhc2VzSUMgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShidWZmQmFzZXNJQyk7XG5cbiAgICBhd2FpdCB3cml0ZVBvaW50QXJyYXkoXCJHMVwiLCBidWZmQmFzZXNJQyk7XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBoIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBjb25zdCBidWZmQmFzZXNIX0xvZGQgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDkpO1xuXG4gICAgbGV0IGJ1ZmZCYXNlc0hfVGF1O1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuZmZ0KGJ1ZmZCYXNlc0hfTG9kZCwgXCJhZmZpbmVcIiwgXCJqYWNvYmlhblwiLCBsb2dnZXIpO1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hBcHBseUtleShidWZmQmFzZXNIX1RhdSwgY3VydmUuRnIubmVnKGN1cnZlLkZyLmUoMikpLCBjdXJ2ZS5Gci53W3prZXkucG93ZXIrMV0sIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyKTtcblxuICAgIC8vIFJlbW92ZSBsYXN0IGVsZW1lbnQuICAoVGhlIGRlZ3JlZSBvZiBIIHdpbGwgYmUgYWx3YXlzIG0tMilcbiAgICBidWZmQmFzZXNIX1RhdSA9IGJ1ZmZCYXNlc0hfVGF1LnNsaWNlKDAsIGJ1ZmZCYXNlc0hfVGF1LmJ5dGVMZW5ndGggLSBzRzEpO1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzSF9UYXUpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0hfVGF1KTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEwgc2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGxldCBidWZmQmFzZXNDO1xuICAgIGJ1ZmZCYXNlc0MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDgpO1xuICAgIGJ1ZmZCYXNlc0MgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShidWZmQmFzZXNDKTtcbiAgICBhd2FpdCB3cml0ZVBvaW50QXJyYXkoXCJHMVwiLCBidWZmQmFzZXNDKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEEgU2VjdGlvbiAoQyBzZWN0aW9uKVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGxldCBidWZmQmFzZXNBO1xuICAgIGJ1ZmZCYXNlc0EgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDUpO1xuICAgIGJ1ZmZCYXNlc0EgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShidWZmQmFzZXNBKTtcbiAgICBhd2FpdCB3cml0ZVBvaW50QXJyYXkoXCJHMVwiLCBidWZmQmFzZXNBKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEIxIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBsZXQgYnVmZkJhc2VzQjE7XG4gICAgYnVmZkJhc2VzQjEgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDYpO1xuICAgIGJ1ZmZCYXNlc0IxID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzQjEpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0IxKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEIyIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBsZXQgYnVmZkJhc2VzQjI7XG4gICAgYnVmZkJhc2VzQjIgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDcpO1xuICAgIGJ1ZmZCYXNlc0IyID0gYXdhaXQgY3VydmUuRzIuYmF0Y2hMRU10b1UoYnVmZkJhc2VzQjIpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcyXCIsIGJ1ZmZCYXNlc0IyKTtcblxuICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGF3YWl0IHdyaXRlVTMyKG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGFBZnRlcik7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YS5nMV9zKTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhLmcxX3N4KTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMihjLmRlbHRhLmcyX3NweCk7XG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGMudHJhbnNjcmlwdCk7XG4gICAgfVxuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRNUENQYXJhbXMuY2xvc2UoKTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEoUCkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc0cxKTtcbiAgICAgICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgUCk7XG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIoUCkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc0cyKTtcbiAgICAgICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgUCk7XG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUG9pbnRBcnJheShncm91cE5hbWUsIGJ1ZmYpIHtcbiAgICAgICAgbGV0IHNHO1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgc0cgPSBzRzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzRyA9IHNHMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZTaXplID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZTaXplViA9IG5ldyBEYXRhVmlldyhidWZmU2l6ZS5idWZmZXIsIGJ1ZmZTaXplLmJ5dGVPZmZzZXQsIGJ1ZmZTaXplLmJ5dGVMZW5ndGgpO1xuICAgICAgICBidWZmU2l6ZVYuc2V0VWludDMyKDAsIGJ1ZmYuYnl0ZUxlbmd0aCAvIHNHLCBmYWxzZSk7XG5cbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYnVmZlNpemUpO1xuICAgICAgICBhd2FpdCBmZE1QQ1BhcmFtcy53cml0ZShidWZmKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVUzMihuKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZTaXplID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZTaXplViA9IG5ldyBEYXRhVmlldyhidWZmU2l6ZS5idWZmZXIsIGJ1ZmZTaXplLmJ5dGVPZmZzZXQsIGJ1ZmZTaXplLmJ5dGVMZW5ndGgpO1xuICAgICAgICBidWZmU2l6ZVYuc2V0VWludDMyKDAsIG4sIGZhbHNlKTtcblxuICAgICAgICBhd2FpdCBmZE1QQ1BhcmFtcy53cml0ZShidWZmU2l6ZSk7XG4gICAgfVxuXG5cblxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_export_bellman.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_export_json.js":
/*!******************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_export_json.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ zkeyExportJson)\n/* harmony export */ });\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n\n\n\nasync function zkeyExportJson(zkeyFileName) {\n\n    const zKey = await (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readZKey)(zkeyFileName, true);\n    delete zKey.curve;\n    delete zKey.F;\n\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils.stringifyBigInts(zKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUQ7QUFDbEI7O0FBRXRCOztBQUVmLHVCQUF1Qix3REFBUTtBQUMvQjtBQUNBOztBQUVBLFdBQVcsK0NBQUs7QUFDaEIiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWFkWktleSBhcyByZWFkWktleSB9IGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IHV0aWxzIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB6a2V5RXhwb3J0SnNvbih6a2V5RmlsZU5hbWUpIHtcblxuICAgIGNvbnN0IHpLZXkgPSBhd2FpdCByZWFkWktleSh6a2V5RmlsZU5hbWUsIHRydWUpO1xuICAgIGRlbGV0ZSB6S2V5LmN1cnZlO1xuICAgIGRlbGV0ZSB6S2V5LkY7XG5cbiAgICByZXR1cm4gdXRpbHMuc3RyaW5naWZ5QmlnSW50cyh6S2V5KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_export_json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_export_solidityverifier.js":
/*!******************************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_export_solidityverifier.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportSolidityVerifier)\n/* harmony export */ });\n/* harmony import */ var ejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ejs */ \"(ssr)/./node_modules/ejs/lib/ejs.js\");\n/* harmony import */ var _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_export_verificationkey.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_export_verificationkey.js\");\n/* harmony import */ var _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fflonk_export_solidity_verifier.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\");\n\n\n\n\n// Not ready yet\n// module.exports.generateVerifier_kimleeoh = generateVerifier_kimleeoh;\n\nasync function exportSolidityVerifier(zKeyName, templates, logger) {\n\n    const verificationKey = await (0,_zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(zKeyName, logger);\n\n    if (\"fflonk\" === verificationKey.protocol) {\n        return (0,_fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(verificationKey, templates, logger);\n    }\n\n    let template = templates[verificationKey.protocol];\n\n    return ejs__WEBPACK_IMPORTED_MODULE_0__.render(template, verificationKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfc29saWRpdHl2ZXJpZmllci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNCOztBQUUrQztBQUNjO0FBQ25GO0FBQ0E7O0FBRWU7O0FBRWYsa0NBQWtDLDJFQUFxQjs7QUFFdkQ7QUFDQSxlQUFlLCtFQUErQjtBQUM5Qzs7QUFFQTs7QUFFQSxXQUFXLHVDQUFVO0FBQ3JCIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfZXhwb3J0X3NvbGlkaXR5dmVyaWZpZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGVqcyBmcm9tIFwiZWpzXCI7XG5cbmltcG9ydCBleHBvcnRWZXJpZmljYXRpb25LZXkgZnJvbSBcIi4vemtleV9leHBvcnRfdmVyaWZpY2F0aW9ua2V5LmpzXCI7XG5pbXBvcnQgZmZsb25rRXhwb3J0U29saWRpdHlWZXJpZmllckNtZCBmcm9tIFwiLi9mZmxvbmtfZXhwb3J0X3NvbGlkaXR5X3ZlcmlmaWVyLmpzXCI7XG4vLyBOb3QgcmVhZHkgeWV0XG4vLyBtb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZVZlcmlmaWVyX2tpbWxlZW9oID0gZ2VuZXJhdGVWZXJpZmllcl9raW1sZWVvaDtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0U29saWRpdHlWZXJpZmllcih6S2V5TmFtZSwgdGVtcGxhdGVzLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHZlcmlmaWNhdGlvbktleSA9IGF3YWl0IGV4cG9ydFZlcmlmaWNhdGlvbktleSh6S2V5TmFtZSwgbG9nZ2VyKTtcblxuICAgIGlmIChcImZmbG9ua1wiID09PSB2ZXJpZmljYXRpb25LZXkucHJvdG9jb2wpIHtcbiAgICAgICAgcmV0dXJuIGZmbG9ua0V4cG9ydFNvbGlkaXR5VmVyaWZpZXJDbWQodmVyaWZpY2F0aW9uS2V5LCB0ZW1wbGF0ZXMsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVzW3ZlcmlmaWNhdGlvbktleS5wcm90b2NvbF07XG5cbiAgICByZXR1cm4gZWpzLnJlbmRlcih0ZW1wbGF0ZSwgdmVyaWZpY2F0aW9uS2V5KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_export_solidityverifier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_export_verificationkey.js":
/*!*****************************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_export_verificationkey.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ zkeyExportVerificationKey)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_constants.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_3__.utils;\n\nasync function zkeyExportVerificationKey(zkeyName, logger) {\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY STARTED\");\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fd, sections);\n\n    if (logger) logger.info(\"> Detected protocol: \" + zkey.protocol);\n\n    let res;\n    if (zkey.protocol === \"groth16\") {\n        res = await groth16Vk(zkey, fd, sections);\n    } else if (zkey.protocol === \"plonk\") {\n        res = await plonkVk(zkey);\n    } else if (zkey.protocolId && zkey.protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        res = await exportFFlonkVk(zkey, logger);\n    } else {\n        throw new Error(\"zkey file protocol unrecognized\");\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY FINISHED\");\n\n    return res;\n}\n\n\nasync function groth16Vk(zkey, fd, sections) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8 * 2;\n\n    const alphaBeta = await curve.pairing(zkey.vk_alpha_1, zkey.vk_beta_2);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n\n        vk_alpha_1: curve.G1.toObject(zkey.vk_alpha_1),\n\n        vk_beta_2: curve.G2.toObject(zkey.vk_beta_2),\n        vk_gamma_2: curve.G2.toObject(zkey.vk_gamma_2),\n        vk_delta_2: curve.G2.toObject(zkey.vk_delta_2),\n\n        vk_alphabeta_12: curve.Gt.toObject(alphaBeta)\n    };\n\n    // Read IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd, sections, 3);\n    vKey.IC = [];\n    for (let i = 0; i <= zkey.nPublic; i++) {\n        const buff = await fd.read(sG1);\n        const P = curve.G1.toObject(buff);\n        vKey.IC.push(P);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd);\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\n\nasync function plonkVk(zkey) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        Qm: curve.G1.toObject(zkey.Qm),\n        Ql: curve.G1.toObject(zkey.Ql),\n        Qr: curve.G1.toObject(zkey.Qr),\n        Qo: curve.G1.toObject(zkey.Qo),\n        Qc: curve.G1.toObject(zkey.Qc),\n        S1: curve.G1.toObject(zkey.S1),\n        S2: curve.G1.toObject(zkey.S2),\n        S3: curve.G1.toObject(zkey.S3),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power])\n    };\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\nasync function exportFFlonkVk(zkey, logger) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power]),\n        //wW: curve.Fr.toObject(curve.Fr.w[zkey.power + 1]),\n        w3: curve.Fr.toObject(zkey.w3),\n        w4: curve.Fr.toObject(zkey.w4),\n        w8: curve.Fr.toObject(zkey.w8),\n        wr: curve.Fr.toObject(zkey.wr),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        C0: curve.G1.toObject(zkey.C0),\n    };\n\n    return stringifyBigInts(vKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfdmVyaWZpY2F0aW9ua2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ1A7QUFDUztBQUNuQjtBQUNvQjs7QUFFdkQsT0FBTyxrQkFBa0IsRUFBRSwrQ0FBSzs7QUFFakI7QUFDZjs7QUFFQSxXQUFXLGNBQWMsUUFBUSw0REFBd0I7QUFDekQsdUJBQXVCLHNEQUFvQjs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTSxnREFBZ0Qsa0VBQWtCO0FBQ3hFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSx3QkFBd0IseURBQVE7QUFDaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOztBQUVyQzs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLHdCQUF3Qix5REFBUTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHlEQUFROztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2V4cG9ydF92ZXJpZmljYXRpb25rZXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0IHtnZXRDdXJ2ZUZyb21RIGFzIGdldEN1cnZlfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7dXRpbHN9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCB7RkZMT05LX1BST1RPQ09MX0lEfSBmcm9tIFwiLi96a2V5X2NvbnN0YW50cy5qc1wiO1xuXG5jb25zdCB7c3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gemtleUV4cG9ydFZlcmlmaWNhdGlvbktleSh6a2V5TmFtZSwgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJFWFBPUlQgVkVSSUZJQ0FUSU9OIEtFWSBTVEFSVEVEXCIpO1xuXG4gICAgY29uc3Qge2ZkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoemtleU5hbWUsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmQsIHNlY3Rpb25zKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBEZXRlY3RlZCBwcm90b2NvbDogXCIgKyB6a2V5LnByb3RvY29sKTtcblxuICAgIGxldCByZXM7XG4gICAgaWYgKHprZXkucHJvdG9jb2wgPT09IFwiZ3JvdGgxNlwiKSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IGdyb3RoMTZWayh6a2V5LCBmZCwgc2VjdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoemtleS5wcm90b2NvbCA9PT0gXCJwbG9ua1wiKSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IHBsb25rVmsoemtleSk7XG4gICAgfSBlbHNlIGlmICh6a2V5LnByb3RvY29sSWQgJiYgemtleS5wcm90b2NvbElkID09PSBGRkxPTktfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgcmVzID0gYXdhaXQgZXhwb3J0RkZsb25rVmsoemtleSwgbG9nZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgcHJvdG9jb2wgdW5yZWNvZ25pemVkXCIpO1xuICAgIH1cblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkVYUE9SVCBWRVJJRklDQVRJT04gS0VZIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBncm90aDE2VmsoemtleSwgZmQsIHNlY3Rpb25zKSB7XG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjggKiAyO1xuXG4gICAgY29uc3QgYWxwaGFCZXRhID0gYXdhaXQgY3VydmUucGFpcmluZyh6a2V5LnZrX2FscGhhXzEsIHprZXkudmtfYmV0YV8yKTtcblxuICAgIGxldCB2S2V5ID0ge1xuICAgICAgICBwcm90b2NvbDogemtleS5wcm90b2NvbCxcbiAgICAgICAgY3VydmU6IGN1cnZlLm5hbWUsXG4gICAgICAgIG5QdWJsaWM6IHprZXkublB1YmxpYyxcblxuICAgICAgICB2a19hbHBoYV8xOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LnZrX2FscGhhXzEpLFxuXG4gICAgICAgIHZrX2JldGFfMjogY3VydmUuRzIudG9PYmplY3QoemtleS52a19iZXRhXzIpLFxuICAgICAgICB2a19nYW1tYV8yOiBjdXJ2ZS5HMi50b09iamVjdCh6a2V5LnZrX2dhbW1hXzIpLFxuICAgICAgICB2a19kZWx0YV8yOiBjdXJ2ZS5HMi50b09iamVjdCh6a2V5LnZrX2RlbHRhXzIpLFxuXG4gICAgICAgIHZrX2FscGhhYmV0YV8xMjogY3VydmUuR3QudG9PYmplY3QoYWxwaGFCZXRhKVxuICAgIH07XG5cbiAgICAvLyBSZWFkIElDIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMyk7XG4gICAgdktleS5JQyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKHNHMSk7XG4gICAgICAgIGNvbnN0IFAgPSBjdXJ2ZS5HMS50b09iamVjdChidWZmKTtcbiAgICAgICAgdktleS5JQy5wdXNoKFApO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgdktleSA9IHN0cmluZ2lmeUJpZ0ludHModktleSk7XG5cbiAgICByZXR1cm4gdktleTtcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBwbG9ua1ZrKHprZXkpIHtcbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSk7XG5cbiAgICBsZXQgdktleSA9IHtcbiAgICAgICAgcHJvdG9jb2w6IHprZXkucHJvdG9jb2wsXG4gICAgICAgIGN1cnZlOiBjdXJ2ZS5uYW1lLFxuICAgICAgICBuUHVibGljOiB6a2V5Lm5QdWJsaWMsXG4gICAgICAgIHBvd2VyOiB6a2V5LnBvd2VyLFxuXG4gICAgICAgIGsxOiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5LmsxKSxcbiAgICAgICAgazI6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkuazIpLFxuXG4gICAgICAgIFFtOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlFtKSxcbiAgICAgICAgUWw6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUWwpLFxuICAgICAgICBRcjogY3VydmUuRzEudG9PYmplY3QoemtleS5RciksXG4gICAgICAgIFFvOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlFvKSxcbiAgICAgICAgUWM6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUWMpLFxuICAgICAgICBTMTogY3VydmUuRzEudG9PYmplY3QoemtleS5TMSksXG4gICAgICAgIFMyOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlMyKSxcbiAgICAgICAgUzM6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUzMpLFxuXG4gICAgICAgIFhfMjogY3VydmUuRzIudG9PYmplY3QoemtleS5YXzIpLFxuXG4gICAgICAgIHc6IGN1cnZlLkZyLnRvT2JqZWN0KGN1cnZlLkZyLndbemtleS5wb3dlcl0pXG4gICAgfTtcblxuICAgIHZLZXkgPSBzdHJpbmdpZnlCaWdJbnRzKHZLZXkpO1xuXG4gICAgcmV0dXJuIHZLZXk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4cG9ydEZGbG9ua1ZrKHprZXksIGxvZ2dlcikge1xuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcblxuICAgIGxldCB2S2V5ID0ge1xuICAgICAgICBwcm90b2NvbDogemtleS5wcm90b2NvbCxcbiAgICAgICAgY3VydmU6IGN1cnZlLm5hbWUsXG4gICAgICAgIG5QdWJsaWM6IHprZXkublB1YmxpYyxcbiAgICAgICAgcG93ZXI6IHprZXkucG93ZXIsXG5cbiAgICAgICAgazE6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkuazEpLFxuICAgICAgICBrMjogY3VydmUuRnIudG9PYmplY3QoemtleS5rMiksXG5cbiAgICAgICAgdzogY3VydmUuRnIudG9PYmplY3QoY3VydmUuRnIud1t6a2V5LnBvd2VyXSksXG4gICAgICAgIC8vd1c6IGN1cnZlLkZyLnRvT2JqZWN0KGN1cnZlLkZyLndbemtleS5wb3dlciArIDFdKSxcbiAgICAgICAgdzM6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkudzMpLFxuICAgICAgICB3NDogY3VydmUuRnIudG9PYmplY3QoemtleS53NCksXG4gICAgICAgIHc4OiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5Lnc4KSxcbiAgICAgICAgd3I6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkud3IpLFxuXG4gICAgICAgIFhfMjogY3VydmUuRzIudG9PYmplY3QoemtleS5YXzIpLFxuXG4gICAgICAgIEMwOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LkMwKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeUJpZ0ludHModktleSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_export_verificationkey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_import_bellman.js":
/*!*********************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_import_bellman.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2importMPCParams)\n/* harmony export */ });\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function phase2importMPCParams(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger) {\n\n    const {fd: fdZKeyOld, sections: sectionsZKeyOld} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkeyHeader = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readHeader(fdZKeyOld, sectionsZKeyOld, false);\n    if (zkeyHeader.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_3__.getCurveFromQ)(zkeyHeader.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const oldMPCParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readMPCParams(fdZKeyOld, curve, sectionsZKeyOld);\n    const newMPCParams = {};\n\n    const fdMPCParams = await fastfile__WEBPACK_IMPORTED_MODULE_2__.readExisting(mpcparamsName);\n\n    fdMPCParams.pos =\n        sG1*3 + sG2*3 +                     // vKey\n        8 + sG1*zkeyHeader.nVars +              // IC + C\n        4 + sG1*(zkeyHeader.domainSize-1) +     // H\n        4 + sG1*zkeyHeader.nVars +              // A\n        4 + sG1*zkeyHeader.nVars +              // B1\n        4 + sG2*zkeyHeader.nVars;               // B2\n\n    // csHash\n    newMPCParams.csHash =  await fdMPCParams.read(64);\n\n    const nContributions = await fdMPCParams.readUBE32();\n    newMPCParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1(fdMPCParams);\n        c.delta.g1_s = await readG1(fdMPCParams);\n        c.delta.g1_sx = await readG1(fdMPCParams);\n        c.delta.g2_spx = await readG2(fdMPCParams);\n        c.transcript = await fdMPCParams.read(64);\n        if (i<oldMPCParams.contributions.length) {\n            c.type = oldMPCParams.contributions[i].type;\n            if (c.type==1) {\n                c.beaconHash = oldMPCParams.contributions[i].beaconHash;\n                c.numIterationsExp = oldMPCParams.contributions[i].numIterationsExp;\n            }\n            if (oldMPCParams.contributions[i].name) {\n                c.name = oldMPCParams.contributions[i].name;\n            }\n        }\n        newMPCParams.contributions.push(c);\n    }\n\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(newMPCParams.csHash, oldMPCParams.csHash)) {\n        if (logger) logger.error(\"Hash of the original circuit does not match with the MPC one\");\n        return false;\n    }\n\n    if (oldMPCParams.contributions.length > newMPCParams.contributions.length) {\n        if (logger) logger.error(\"The impoerted file does not include new contributions\");\n        return false;\n    }\n\n    for (let i=0; i<oldMPCParams.contributions.length; i++) {\n        if (!contributionIsEqual(oldMPCParams.contributions[i], newMPCParams.contributions[i])) {\n            if (logger) logger.error(`Previous contribution ${i} does not match`);\n            return false;\n        }\n    }\n\n\n    // Set the same name to all new contributions\n    if (name) {\n        for (let i=oldMPCParams.contributions.length; i<newMPCParams.contributions.length; i++) {\n            newMPCParams.contributions[i].name = name;\n        }\n    }\n\n    const fdZKeyNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n    fdMPCParams.pos = 0;\n\n    // Header\n    fdMPCParams.pos += sG1;  // ignore alpha1 (keep original)\n    fdMPCParams.pos += sG1;  // ignore beta1\n    fdMPCParams.pos += sG2;  // ignore beta2\n    fdMPCParams.pos += sG2;  // ignore gamma2\n    zkeyHeader.vk_delta_1 = await readG1(fdMPCParams);\n    zkeyHeader.vk_delta_2 = await readG2(fdMPCParams);\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeHeader(fdZKeyNew, zkeyHeader);\n\n    // IC (Keep original)\n    const nIC = await fdMPCParams.readUBE32();\n    if (nIC != zkeyHeader.nPublic +1) {\n        if (logger) logger.error(\"Invalid number of points in IC\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nPublic+1);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 4);\n\n    // H Section\n    const nH = await fdMPCParams.readUBE32();\n    if (nH != zkeyHeader.domainSize-1) {\n        if (logger) logger.error(\"Invalid number of points in H\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffH;\n    const buffTauU = await fdMPCParams.read(sG1*(zkeyHeader.domainSize-1));\n    const buffTauLEM = await curve.G1.batchUtoLEM(buffTauU);\n    buffH = new Uint8Array(zkeyHeader.domainSize*sG1);\n    buffH.set(buffTauLEM);   // Let the last one to zero.\n    curve.G1.toRprLEM(buffH, sG1*(zkeyHeader.domainSize-1), curve.G1.zeroAffine);\n    const n2Inv = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n    const wInv = curve.Fr.inv(curve.Fr.w[zkeyHeader.power+1]);\n    buffH = await curve.G1.batchApplyKey(buffH, n2Inv, wInv, \"affine\", \"jacobian\", logger);\n    buffH = await curve.G1.ifft(buffH, \"jacobian\", \"affine\", logger);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fdZKeyNew, 9);\n    await fdZKeyNew.write(buffH);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fdZKeyNew);\n\n    // C Section (L section)\n    const nL = await fdMPCParams.readUBE32();\n    if (nL != (zkeyHeader.nVars-zkeyHeader.nPublic-1)) {\n        if (logger) logger.error(\"Invalid number of points in L\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffL;\n    buffL = await fdMPCParams.read(sG1*(zkeyHeader.nVars-zkeyHeader.nPublic-1));\n    buffL = await curve.G1.batchUtoLEM(buffL);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fdZKeyNew, 8);\n    await fdZKeyNew.write(buffL);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fdZKeyNew);\n\n    // A Section\n    const nA = await fdMPCParams.readUBE32();\n    if (nA != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in A\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 5);\n\n    // B1 Section\n    const nB1 = await fdMPCParams.readUBE32();\n    if (nB1 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B1\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 6);\n\n    // B2 Section\n    const nB2 = await fdMPCParams.readUBE32();\n    if (nB2 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B2\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG2*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 7);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeMPCParams(fdZKeyNew, curve, newMPCParams);\n\n    await fdMPCParams.close();\n    await fdZKeyNew.close();\n    await fdZKeyOld.close();\n\n    return true;\n\n    async function readG1(fd) {\n        const buff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2(fd) {\n        const buff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n\n    function contributionIsEqual(c1, c2) {\n        if (!curve.G1.eq(c1.deltaAfter   , c2.deltaAfter)) return false;\n        if (!curve.G1.eq(c1.delta.g1_s   , c2.delta.g1_s)) return false;\n        if (!curve.G1.eq(c1.delta.g1_sx  , c2.delta.g1_sx)) return false;\n        if (!curve.G2.eq(c1.delta.g2_spx , c2.delta.g2_spx)) return false;\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(c1.transcript, c2.transcript)) return false;\n        return true;\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9pbXBvcnRfYmVsbG1hbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU2QztBQUNPO0FBQ2Y7QUFDbUI7QUFDdEI7O0FBRW5COztBQUVmLFdBQVcsMENBQTBDLFFBQVEsNERBQXdCO0FBQ3JGLDZCQUE2QixzREFBb0I7QUFDakQ7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix5REFBUTtBQUNoQztBQUNBOztBQUVBLCtCQUErQix5REFBdUI7QUFDdEQ7O0FBRUEsOEJBQThCLGtEQUFxQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsaURBQWdCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUNBQXFDO0FBQ3ZEO0FBQ0EsOERBQThELEdBQUc7QUFDakU7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esc0RBQXNELHFDQUFxQztBQUMzRjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDhEQUEwQjtBQUN0RDs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSx1REFBcUI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLFVBQVUsZ0VBQTRCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0REFBd0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNERBQXdCOztBQUVsQyxVQUFVLDBEQUF3Qjs7QUFFbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpREFBZ0I7QUFDN0I7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9pbXBvcnRfYmVsbG1hbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCB7IGdldEN1cnZlRnJvbVEgYXMgZ2V0Q3VydmUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwaGFzZTJpbXBvcnRNUENQYXJhbXMoemtleU5hbWVPbGQsIG1wY3BhcmFtc05hbWUsIHprZXlOYW1lTmV3LCBuYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRaS2V5T2xkLCBzZWN0aW9uczogc2VjdGlvbnNaS2V5T2xkfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5TmFtZU9sZCwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXlIZWFkZXIgPSBhd2FpdCB6a2V5VXRpbHMucmVhZEhlYWRlcihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmFsc2UpO1xuICAgIGlmICh6a2V5SGVhZGVyLnByb3RvY29sICE9IFwiZ3JvdGgxNlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXlIZWFkZXIucSk7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcblxuICAgIGNvbnN0IG9sZE1QQ1BhcmFtcyA9IGF3YWl0IHprZXlVdGlscy5yZWFkTVBDUGFyYW1zKGZkWktleU9sZCwgY3VydmUsIHNlY3Rpb25zWktleU9sZCk7XG4gICAgY29uc3QgbmV3TVBDUGFyYW1zID0ge307XG5cbiAgICBjb25zdCBmZE1QQ1BhcmFtcyA9IGF3YWl0IGZhc3RGaWxlLnJlYWRFeGlzdGluZyhtcGNwYXJhbXNOYW1lKTtcblxuICAgIGZkTVBDUGFyYW1zLnBvcyA9XG4gICAgICAgIHNHMSozICsgc0cyKjMgKyAgICAgICAgICAgICAgICAgICAgIC8vIHZLZXlcbiAgICAgICAgOCArIHNHMSp6a2V5SGVhZGVyLm5WYXJzICsgICAgICAgICAgICAgIC8vIElDICsgQ1xuICAgICAgICA0ICsgc0cxKih6a2V5SGVhZGVyLmRvbWFpblNpemUtMSkgKyAgICAgLy8gSFxuICAgICAgICA0ICsgc0cxKnprZXlIZWFkZXIublZhcnMgKyAgICAgICAgICAgICAgLy8gQVxuICAgICAgICA0ICsgc0cxKnprZXlIZWFkZXIublZhcnMgKyAgICAgICAgICAgICAgLy8gQjFcbiAgICAgICAgNCArIHNHMip6a2V5SGVhZGVyLm5WYXJzOyAgICAgICAgICAgICAgIC8vIEIyXG5cbiAgICAvLyBjc0hhc2hcbiAgICBuZXdNUENQYXJhbXMuY3NIYXNoID0gIGF3YWl0IGZkTVBDUGFyYW1zLnJlYWQoNjQpO1xuXG4gICAgY29uc3QgbkNvbnRyaWJ1dGlvbnMgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkVUJFMzIoKTtcbiAgICBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxuQ29udHJpYnV0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSB7IGRlbHRhOnt9IH07XG4gICAgICAgIGMuZGVsdGFBZnRlciA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMuZGVsdGEuZzFfcyA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMuZGVsdGEuZzFfc3ggPSBhd2FpdCByZWFkRzEoZmRNUENQYXJhbXMpO1xuICAgICAgICBjLmRlbHRhLmcyX3NweCA9IGF3YWl0IHJlYWRHMihmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMudHJhbnNjcmlwdCA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWQoNjQpO1xuICAgICAgICBpZiAoaTxvbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGMudHlwZSA9IG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLnR5cGU7XG4gICAgICAgICAgICBpZiAoYy50eXBlPT0xKSB7XG4gICAgICAgICAgICAgICAgYy5iZWFjb25IYXNoID0gb2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0uYmVhY29uSGFzaDtcbiAgICAgICAgICAgICAgICBjLm51bUl0ZXJhdGlvbnNFeHAgPSBvbGRNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXS5udW1JdGVyYXRpb25zRXhwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjLm5hbWUgPSBvbGRNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgaWYgKCFtaXNjLmhhc2hJc0VxdWFsKG5ld01QQ1BhcmFtcy5jc0hhc2gsIG9sZE1QQ1BhcmFtcy5jc0hhc2gpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkhhc2ggb2YgdGhlIG9yaWdpbmFsIGNpcmN1aXQgZG9lcyBub3QgbWF0Y2ggd2l0aCB0aGUgTVBDIG9uZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGggPiBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiVGhlIGltcG9lcnRlZCBmaWxlIGRvZXMgbm90IGluY2x1ZGUgbmV3IGNvbnRyaWJ1dGlvbnNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8b2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFjb250cmlidXRpb25Jc0VxdWFsKG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLCBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXSkpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihgUHJldmlvdXMgY29udHJpYnV0aW9uICR7aX0gZG9lcyBub3QgbWF0Y2hgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gU2V0IHRoZSBzYW1lIG5hbWUgdG8gYWxsIG5ldyBjb250cmlidXRpb25zXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgaT1vbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGk8bmV3TVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLm5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmRaS2V5TmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUoemtleU5hbWVOZXcsIFwiemtleVwiLCAxLCAxMCk7XG4gICAgZmRNUENQYXJhbXMucG9zID0gMDtcblxuICAgIC8vIEhlYWRlclxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzE7ICAvLyBpZ25vcmUgYWxwaGExIChrZWVwIG9yaWdpbmFsKVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzE7ICAvLyBpZ25vcmUgYmV0YTFcbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cyOyAgLy8gaWdub3JlIGJldGEyXG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMjsgIC8vIGlnbm9yZSBnYW1tYTJcbiAgICB6a2V5SGVhZGVyLnZrX2RlbHRhXzEgPSBhd2FpdCByZWFkRzEoZmRNUENQYXJhbXMpO1xuICAgIHprZXlIZWFkZXIudmtfZGVsdGFfMiA9IGF3YWl0IHJlYWRHMihmZE1QQ1BhcmFtcyk7XG4gICAgYXdhaXQgemtleVV0aWxzLndyaXRlSGVhZGVyKGZkWktleU5ldywgemtleUhlYWRlcik7XG5cbiAgICAvLyBJQyAoS2VlcCBvcmlnaW5hbClcbiAgICBjb25zdCBuSUMgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkVUJFMzIoKTtcbiAgICBpZiAobklDICE9IHprZXlIZWFkZXIublB1YmxpYyArMSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gSUNcIik7XG4gICAgICAgIGF3YWl0IGZkWktleU5ldy5kaXNjYXJkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMSooemtleUhlYWRlci5uUHVibGljKzEpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmRaS2V5TmV3LCAzKTtcblxuICAgIC8vIENvZWZmcyAoS2VlcCBvcmlnaW5hbClcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgNCk7XG5cbiAgICAvLyBIIFNlY3Rpb25cbiAgICBjb25zdCBuSCA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuSCAhPSB6a2V5SGVhZGVyLmRvbWFpblNpemUtMSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gSFwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYnVmZkg7XG4gICAgY29uc3QgYnVmZlRhdVUgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkKHNHMSooemtleUhlYWRlci5kb21haW5TaXplLTEpKTtcbiAgICBjb25zdCBidWZmVGF1TEVNID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hVdG9MRU0oYnVmZlRhdVUpO1xuICAgIGJ1ZmZIID0gbmV3IFVpbnQ4QXJyYXkoemtleUhlYWRlci5kb21haW5TaXplKnNHMSk7XG4gICAgYnVmZkguc2V0KGJ1ZmZUYXVMRU0pOyAgIC8vIExldCB0aGUgbGFzdCBvbmUgdG8gemVyby5cbiAgICBjdXJ2ZS5HMS50b1JwckxFTShidWZmSCwgc0cxKih6a2V5SGVhZGVyLmRvbWFpblNpemUtMSksIGN1cnZlLkcxLnplcm9BZmZpbmUpO1xuICAgIGNvbnN0IG4ySW52ID0gY3VydmUuRnIubmVnKGN1cnZlLkZyLmludihjdXJ2ZS5Gci5lKDIpKSk7XG4gICAgY29uc3Qgd0ludiA9IGN1cnZlLkZyLmludihjdXJ2ZS5Gci53W3prZXlIZWFkZXIucG93ZXIrMV0pO1xuICAgIGJ1ZmZIID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hBcHBseUtleShidWZmSCwgbjJJbnYsIHdJbnYsIFwiYWZmaW5lXCIsIFwiamFjb2JpYW5cIiwgbG9nZ2VyKTtcbiAgICBidWZmSCA9IGF3YWl0IGN1cnZlLkcxLmlmZnQoYnVmZkgsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5TmV3LCA5KTtcbiAgICBhd2FpdCBmZFpLZXlOZXcud3JpdGUoYnVmZkgpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmRaS2V5TmV3KTtcblxuICAgIC8vIEMgU2VjdGlvbiAoTCBzZWN0aW9uKVxuICAgIGNvbnN0IG5MID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5MICE9ICh6a2V5SGVhZGVyLm5WYXJzLXprZXlIZWFkZXIublB1YmxpYy0xKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTFwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYnVmZkw7XG4gICAgYnVmZkwgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkKHNHMSooemtleUhlYWRlci5uVmFycy16a2V5SGVhZGVyLm5QdWJsaWMtMSkpO1xuICAgIGJ1ZmZMID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hVdG9MRU0oYnVmZkwpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFpLZXlOZXcsIDgpO1xuICAgIGF3YWl0IGZkWktleU5ldy53cml0ZShidWZmTCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXlOZXcpO1xuXG4gICAgLy8gQSBTZWN0aW9uXG4gICAgY29uc3QgbkEgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkVUJFMzIoKTtcbiAgICBpZiAobkEgIT0gemtleUhlYWRlci5uVmFycykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gQVwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cxKih6a2V5SGVhZGVyLm5WYXJzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgNSk7XG5cbiAgICAvLyBCMSBTZWN0aW9uXG4gICAgY29uc3QgbkIxID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5CMSAhPSB6a2V5SGVhZGVyLm5WYXJzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBCMVwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cxKih6a2V5SGVhZGVyLm5WYXJzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgNik7XG5cbiAgICAvLyBCMiBTZWN0aW9uXG4gICAgY29uc3QgbkIyID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5CMiAhPSB6a2V5SGVhZGVyLm5WYXJzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBCMlwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cyKih6a2V5SGVhZGVyLm5WYXJzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgNyk7XG5cbiAgICBhd2FpdCB6a2V5VXRpbHMud3JpdGVNUENQYXJhbXMoZmRaS2V5TmV3LCBjdXJ2ZSwgbmV3TVBDUGFyYW1zKTtcblxuICAgIGF3YWl0IGZkTVBDUGFyYW1zLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRaS2V5TmV3LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRaS2V5T2xkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRHMShmZCkge1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5HMS5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzEuZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCAwKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzIoZmQpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzIuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcyLmZyb21ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb250cmlidXRpb25Jc0VxdWFsKGMxLCBjMikge1xuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGMxLmRlbHRhQWZ0ZXIgICAsIGMyLmRlbHRhQWZ0ZXIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoYzEuZGVsdGEuZzFfcyAgICwgYzIuZGVsdGEuZzFfcykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjMS5kZWx0YS5nMV9zeCAgLCBjMi5kZWx0YS5nMV9zeCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFjdXJ2ZS5HMi5lcShjMS5kZWx0YS5nMl9zcHggLCBjMi5kZWx0YS5nMl9zcHgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghbWlzYy5oYXNoSXNFcXVhbChjMS50cmFuc2NyaXB0LCBjMi50cmFuc2NyaXB0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxufVxuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_import_bellman.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_new.js":
/*!**********************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_new.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ newZKey)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(ssr)/./node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/./node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bigarray.js */ \"(ssr)/./node_modules/snarkjs/src/bigarray.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\nasync function newZKey(r1csName, ptauName, zkeyName, logger) {\n\n    const TAU_G1 = 0;\n    const TAU_G2 = 1;\n    const ALPHATAU_G1 = 2;\n    const BETATAU_G1 = 3;\n    const csHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });\n\n    const {fd: fdPTau, sections: sectionsPTau} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csHeader)(fdR1cs, sectionsR1cs, false);\n\n    const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyName, \"zkey\", 1, 10, 1<<22, 1<<24);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    const cirPower = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(r1cs.nConstraints + r1cs.nPubInputs + r1cs.nOutputs +1 -1) +1;\n\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${r1cs.nConstraints}*2 > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n    const domainSize = 2 ** cirPower;\n\n    // Write the header\n    ///////////\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 1);\n    await fdZKey.writeULE32(1); // Groth\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    // Write the Groth header section\n    ///////////\n\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.shl(1, n8r*8), primeR);\n    const R2r = curve.Fr.e(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mul(Rr,Rr), primeR));\n\n    await fdZKey.writeULE32(n8q);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n    await fdZKey.writeULE32(n8r);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n    await fdZKey.writeULE32(r1cs.nVars);                         // Total number of bars\n    await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n    await fdZKey.writeULE32(domainSize);                  // domainSize\n\n    let bAlpha1;\n    bAlpha1 = await fdPTau.read(sG1, sectionsPTau[4][0].p);\n    await fdZKey.write(bAlpha1);\n    bAlpha1 = await curve.G1.batchLEMtoU(bAlpha1);\n    csHasher.update(bAlpha1);\n\n    let bBeta1;\n    bBeta1 = await fdPTau.read(sG1, sectionsPTau[5][0].p);\n    await fdZKey.write(bBeta1);\n    bBeta1 = await curve.G1.batchLEMtoU(bBeta1);\n    csHasher.update(bBeta1);\n\n    let bBeta2;\n    bBeta2 = await fdPTau.read(sG2, sectionsPTau[6][0].p);\n    await fdZKey.write(bBeta2);\n    bBeta2 = await curve.G2.batchLEMtoU(bBeta2);\n    csHasher.update(bBeta2);\n\n    const bg1 = new Uint8Array(sG1);\n    curve.G1.toRprLEM(bg1, 0, curve.G1.g);\n    const bg2 = new Uint8Array(sG2);\n    curve.G2.toRprLEM(bg2, 0, curve.G2.g);\n    const bg1U = new Uint8Array(sG1);\n    curve.G1.toRprUncompressed(bg1U, 0, curve.G1.g);\n    const bg2U = new Uint8Array(sG2);\n    curve.G2.toRprUncompressed(bg2U, 0, curve.G2.g);\n\n    await fdZKey.write(bg2);        // gamma2\n    await fdZKey.write(bg1);        // delta1\n    await fdZKey.write(bg2);        // delta2\n    csHasher.update(bg2U);      // gamma2\n    csHasher.update(bg1U);      // delta1\n    csHasher.update(bg2U);      // delta2\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdR1cs, sectionsR1cs, 2);\n\n    const A = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](r1cs.nVars);\n    const B1 = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](r1cs.nVars);\n    const B2 = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](r1cs.nVars);\n    const C = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](r1cs.nVars- nPublic -1);\n    const IC = new Array(nPublic+1);\n\n    if (logger) logger.info(\"Reading tauG1\");\n    let sTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 12, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading tauG2\");\n    let sTauG2 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 13, (domainSize -1)*sG2, domainSize*sG2);\n    if (logger) logger.info(\"Reading alphatauG1\");\n    let sAlphaTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 14, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading betatauG1\");\n    let sBetaTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 15, (domainSize -1)*sG1, domainSize*sG1);\n\n    await processConstraints();\n\n    await composeAndWritePoints(3, \"G1\", IC, \"IC\");\n\n    await writeHs();\n\n    await hashHPoints();\n\n    await composeAndWritePoints(8, \"G1\", C, \"C\");\n    await composeAndWritePoints(5, \"G1\", A, \"A\");\n    await composeAndWritePoints(6, \"G1\", B1, \"B1\");\n    await composeAndWritePoints(7, \"G2\", B2, \"B2\");\n\n    const csHash = csHasher.digest();\n    // Contributions section\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 10);\n    await fdZKey.write(csHash);\n    await fdZKey.writeULE32(0);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    if (logger) logger.info((0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash)(csHash, \"Circuit hash: \"));\n\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    return csHash;\n\n    async function writeHs() {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 9);\n        const buffOut = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*sG1);\n        if (cirPower < curve.Fr.s) {\n            let sTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 12, (domainSize*2-1)*sG1, domainSize*2*sG1);\n            for (let i=0; i< domainSize; i++) {\n                if ((logger)&&(i%10000 == 0)) logger.debug(`splitting buffer: ${i}/${domainSize}`);\n                const buff = sTauG1.slice( (i*2+1)*sG1, (i*2+1)*sG1 + sG1 );\n                buffOut.set(buff, i*sG1);\n            }\n        } else if (cirPower == curve.Fr.s) {\n            const o = sectionsPTau[12][0].p + ((2 ** (cirPower+1)) -1)*sG1;\n            await fdPTau.readToBuffer(buffOut, 0, domainSize*sG1, o + domainSize*sG1);\n        } else {\n            if (logger) logger.error(\"Circuit too big\");\n            throw new Error(\"Circuit too big for this curve\");\n        }\n        await fdZKey.write(buffOut);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function processConstraints() {\n        const buffCoeff = new Uint8Array(12 + curve.Fr.n8);\n        const buffCoeffV = new DataView(buffCoeff.buffer);\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let r1csPos = 0;\n\n        function r1cs_readULE32() {\n            const buff = sR1cs.slice(r1csPos, r1csPos+4);\n            r1csPos += 4;\n            const buffV = new DataView(buff.buffer);\n            return buffV.getUint32(0, true);\n        }\n\n        const coefs = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n        for (let c=0; c<r1cs.nConstraints; c++) {\n            if ((logger)&&(c%10000 == 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            const nA = r1cs_readULE32();\n            for (let i=0; i<nA; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = BETATAU_G1;\n                const l2 = sG1*c;\n                if (typeof A[s] === \"undefined\") A[s] = [];\n                A[s].push([l1t, l1, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l2t, l2, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s - nPublic -1].push([l2t, l2, coefp]);\n                }\n                coefs.push([0, c, s, coefp]);\n            }\n\n            const nB = r1cs_readULE32();\n            for (let i=0; i<nB; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = TAU_G2;\n                const l2 = sG2*c;\n                const l3t = ALPHATAU_G1;\n                const l3 = sG1*c;\n                if (typeof B1[s] === \"undefined\") B1[s] = [];\n                B1[s].push([l1t, l1, coefp]);\n                if (typeof B2[s] === \"undefined\") B2[s] = [];\n                B2[s].push([l2t, l2, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l3t, l3, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l3t, l3, coefp]);\n                }\n\n                coefs.push([1, c, s, coefp]);\n            }\n\n            const nC = r1cs_readULE32();\n            for (let i=0; i<nC; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l1t, l1, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l1t, l1, coefp]);\n                }\n            }\n        }\n\n        for (let s = 0; s <= nPublic ; s++) {\n            const l1t = TAU_G1;\n            const l1 = sG1*(r1cs.nConstraints + s);\n            const l2t = BETATAU_G1;\n            const l2 = sG1*(r1cs.nConstraints + s);\n            if (typeof A[s] === \"undefined\") A[s] = [];\n            A[s].push([l1t, l1, -1]);\n            if (typeof IC[s] === \"undefined\") IC[s] = [];\n            IC[s].push([l2t, l2, -1]);\n            coefs.push([0, r1cs.nConstraints + s, s, -1]);\n        }\n\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 4);\n\n        const buffSection = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(coefs.length*(12+curve.Fr.n8) + 4);\n\n        const buff4 = new Uint8Array(4);\n        const buff4V = new DataView(buff4.buffer);\n        buff4V.setUint32(0, coefs.length, true);\n        buffSection.set(buff4);\n        let coefsPos = 4;\n        for (let i=0; i<coefs.length; i++) {\n            if ((logger)&&(i%100000 == 0)) logger.debug(`writing coeffs: ${i}/${coefs.length}`);\n            writeCoef(coefs[i]);\n        }\n\n        await fdZKey.write(buffSection);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        function writeCoef(c) {\n            buffCoeffV.setUint32(0, c[0], true);\n            buffCoeffV.setUint32(4, c[1], true);\n            buffCoeffV.setUint32(8, c[2], true);\n            let n;\n            if (c[3]>=0) {\n                n = curve.Fr.fromRprLE(sR1cs.slice(c[3], c[3] + curve.Fr.n8), 0);\n            } else {\n                n = curve.Fr.fromRprLE(bOne, 0);\n            }\n            const nR2 = curve.Fr.mul(n, R2r);\n            curve.Fr.toRprLE(buffCoeff, 12, nR2);\n            buffSection.set(buffCoeff, coefsPos);\n            coefsPos += buffCoeff.length;\n        }\n\n    }\n\n    async function composeAndWritePoints(idSection, groupName, arr, sectionName) {\n        const CHUNK_SIZE= 1<<15;\n        const G = curve[groupName];\n\n        hashU32(arr.length);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, idSection);\n\n        let opPromises = [];\n\n        let i=0;\n        while (i<arr.length) {\n\n            let t=0;\n            while ((i<arr.length)&&(t<curve.tm.concurrency)) {\n                if (logger)  logger.debug(`Writing points start ${sectionName}: ${i}/${arr.length}`);\n                let n = 1;\n                let nP = (arr[i] ? arr[i].length : 0);\n                while ((i + n < arr.length) && (nP + (arr[i+n] ? arr[i+n].length : 0) < CHUNK_SIZE) && (n<CHUNK_SIZE)) {\n                    nP += (arr[i+n] ? arr[i+n].length : 0);\n                    n ++;\n                }\n                const subArr = arr.slice(i, i + n);\n                const _i = i;\n                opPromises.push(composeAndWritePointsThread(groupName, subArr, logger, sectionName).then( (r) => {\n                    if (logger)  logger.debug(`Writing points end ${sectionName}: ${_i}/${arr.length}`);\n                    return r;\n                }));\n                i += n;\n                t++;\n            }\n\n            const result = await Promise.all(opPromises);\n\n            for (let k=0; k<result.length; k++) {\n                await fdZKey.write(result[k][0]);\n                const buff = await G.batchLEMtoU(result[k][0]);\n                csHasher.update(buff);\n            }\n            opPromises = [];\n\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    }\n\n    async function composeAndWritePointsThread(groupName, arr, logger, sectionName) {\n        const G = curve[groupName];\n        const sGin = G.F.n8*2;\n        const sGmid = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnExp, fnMultiExp, fnBatchToAffine, fnZero;\n        if (groupName == \"G1\") {\n            fnExp = \"g1m_timesScalarAffine\";\n            fnMultiExp = \"g1m_multiexpAffine\";\n            fnBatchToAffine = \"g1m_batchToAffine\";\n            fnZero = \"g1m_zero\";\n        } else if (groupName == \"G2\") {\n            fnExp = \"g2m_timesScalarAffine\";\n            fnMultiExp = \"g2m_multiexpAffine\";\n            fnBatchToAffine = \"g2m_batchToAffine\";\n            fnZero = \"g2m_zero\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        let acc =0;\n        for (let i=0; i<arr.length; i++) acc += arr[i] ? arr[i].length : 0;\n        let bBases, bScalars;\n        if (acc> 2<<14) {\n            bBases = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(acc*sGin);\n            bScalars = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(acc*curve.Fr.n8);\n        } else {\n            bBases = new Uint8Array(acc*sGin);\n            bScalars = new Uint8Array(acc*curve.Fr.n8);\n        }\n        let pB =0;\n        let pS =0;\n\n        const sBuffs = [\n            sTauG1,\n            sTauG2,\n            sAlphaTauG1,\n            sBetaTauG1\n        ];\n\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let offset = 0;\n        for (let i=0; i<arr.length; i++) {\n            if (!arr[i]) continue;\n            for (let j=0; j<arr[i].length; j++) {\n                if ((logger)&&(j)&&(j%10000 == 0))  logger.debug(`Configuring big array ${sectionName}: ${j}/${arr[i].length}`);\n                bBases.set(\n                    sBuffs[arr[i][j][0]].slice(\n                        arr[i][j][1],\n                        arr[i][j][1] + sGin\n                    ), offset*sGin\n                );\n                if (arr[i][j][2]>=0) {\n                    bScalars.set(\n                        sR1cs.slice(\n                            arr[i][j][2],\n                            arr[i][j][2] + curve.Fr.n8\n                        ),\n                        offset*curve.Fr.n8\n                    );\n                } else {\n                    bScalars.set(bOne, offset*curve.Fr.n8);\n                }\n                offset ++;\n            }\n        }\n\n        if (arr.length>1) {\n            const task = [];\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: bBases});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: bScalars});\n            task.push({cmd: \"ALLOC\", var: 2, len: arr.length*sGmid});\n            pB = 0;\n            pS = 0;\n            let pD =0;\n            for (let i=0; i<arr.length; i++) {\n                if (!arr[i]) {\n                    task.push({cmd: \"CALL\", fnName: fnZero, params: [\n                        {var: 2, offset: pD}\n                    ]});\n                    pD += sGmid;\n                    continue;\n                }\n                if (arr[i].length == 1) {\n                    task.push({cmd: \"CALL\", fnName: fnExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {var: 2, offset: pD}\n                    ]});\n                } else {\n                    task.push({cmd: \"CALL\", fnName: fnMultiExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {val: arr[i].length},\n                        {var: 2, offset: pD}\n                    ]});\n                }\n                pB += sGin*arr[i].length;\n                pS += curve.Fr.n8*arr[i].length;\n                pD += sGmid;\n            }\n            task.push({cmd: \"CALL\", fnName: fnBatchToAffine, params: [\n                {var: 2},\n                {val: arr.length},\n                {var: 2},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: arr.length*sGout});\n\n            const res = await curve.tm.queueAction(task);\n            return res;\n        } else {\n            let res = await G.multiExpAffine(bBases, bScalars, logger, sectionName);\n            res = [ G.toAffine(res) ];\n            return res;\n        }\n    }\n\n\n    async function hashHPoints() {\n        const CHUNK_SIZE = 1<<14;\n\n        hashU32(domainSize-1);\n\n        for (let i=0; i<domainSize-1; i+= CHUNK_SIZE) {\n            if (logger)  logger.debug(`HashingHPoints: ${i}/${domainSize}`);\n            const n = Math.min(domainSize-1, CHUNK_SIZE);\n            await hashHPointsChunk(i, n);\n        }\n    }\n\n    async function hashHPointsChunk(offset, nPoints) {\n        const buff1 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + (offset + domainSize)*sG1);\n        const buff2 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + offset*sG1);\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(hashHPointsThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        for (let i=0; i<result.length; i++) {\n            csHasher.update(result[i][0]);\n        }\n    }\n\n    async function hashHPointsThread(buff1, buff2) {\n        const nPoints = buff1.byteLength/sG1;\n        const sGmid = curve.G1.F.n8*3;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchLEMtoU\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n    function hashU32(n) {\n        const buff = new Uint8Array(4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        buffV.setUint32(0, n, false);\n        csHasher.update(buff);\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9uZXcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUV3QztBQUNRO0FBUW5CO0FBQ2dCO0FBQ0k7QUFDRDtBQUNYOzs7QUFHdEI7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMERBQU8sVUFBVSxXQUFXOztBQUVqRCxXQUFXLG9DQUFvQyxRQUFRLGdFQUFXO0FBQ2xFLFdBQVcsY0FBYyxRQUFRLGlFQUFvQjtBQUNyRCxXQUFXLG9DQUFvQyxRQUFRLGdFQUFXO0FBQ2xFLHVCQUF1Qix3REFBYzs7QUFFckMseUJBQXlCLGtFQUFhOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiw4Q0FBSTs7QUFFekI7QUFDQSxvRkFBb0Ysa0JBQWtCLFVBQVUsTUFBTTtBQUN0SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsc0VBQWlCO0FBQzNCLGdDQUFnQztBQUNoQyxVQUFVLG9FQUFlOztBQUV6QjtBQUNBOztBQUVBLFVBQVUsc0VBQWlCO0FBQzNCO0FBQ0EsOEJBQThCLGdEQUFNOztBQUVwQztBQUNBLDhCQUE4QixnREFBTTtBQUNwQyxlQUFlLGdEQUFNLEtBQUssZ0RBQU07QUFDaEMsMkJBQTJCLGdEQUFNLEtBQUssZ0RBQU07O0FBRTVDO0FBQ0EsVUFBVSxnRUFBVztBQUNyQjtBQUNBLFVBQVUsZ0VBQVc7QUFDckIsaUVBQWlFO0FBQ2pFLDREQUE0RDtBQUM1RCwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsVUFBVSxvRUFBZTs7QUFFekI7QUFDQSxzQkFBc0IsZ0VBQVc7O0FBRWpDLGtCQUFrQixvREFBUTtBQUMxQixtQkFBbUIsb0RBQVE7QUFDM0IsbUJBQW1CLG9EQUFRO0FBQzNCLGtCQUFrQixvREFBUTtBQUMxQjs7QUFFQTtBQUNBLHVCQUF1QixnRUFBVztBQUNsQztBQUNBLHVCQUF1QixnRUFBVztBQUNsQztBQUNBLDRCQUE0QixnRUFBVztBQUN2QztBQUNBLDJCQUEyQixnRUFBVzs7QUFFdEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsc0VBQWlCO0FBQzNCO0FBQ0E7QUFDQSxVQUFVLG9FQUFlOztBQUV6Qiw0QkFBNEIsb0RBQVU7OztBQUd0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQiw0QkFBNEIsbURBQVM7QUFDckM7QUFDQSwrQkFBK0IsZ0VBQVc7QUFDMUMsMEJBQTBCLGVBQWU7QUFDekMsZ0ZBQWdGLEVBQUUsR0FBRyxXQUFXO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsb0RBQVE7QUFDbEMsc0JBQXNCLHFCQUFxQjtBQUMzQyxrRkFBa0YsRUFBRSxHQUFHLGtCQUFrQjtBQUN6RztBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsY0FBYyxzRUFBaUI7O0FBRS9CLGdDQUFnQyxtREFBUzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEMsMkVBQTJFLEVBQUUsR0FBRyxhQUFhO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG9FQUFlOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQjs7QUFFL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVksSUFBSSxFQUFFLEdBQUcsV0FBVztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsWUFBWSxJQUFJLEdBQUcsR0FBRyxXQUFXO0FBQ3JHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG9FQUFlOztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQSx5QkFBeUIsbURBQVM7QUFDbEMsMkJBQTJCLG1EQUFTO0FBQ3BDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDLDBGQUEwRixZQUFZLElBQUksRUFBRSxHQUFHLGNBQWM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdELHVCQUF1Qix3Q0FBd0M7QUFDL0QsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHlCQUF5QixtQkFBbUI7QUFDNUMseUJBQXlCLG1CQUFtQjtBQUM1Qyx5QkFBeUIsaUJBQWlCO0FBQzFDLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLCtCQUErQjtBQUMvQix5QkFBeUIsbUJBQW1CO0FBQzVDLHlCQUF5QixtQkFBbUI7QUFDNUMseUJBQXlCLGlCQUFpQjtBQUMxQyx5QkFBeUIsbUJBQW1CO0FBQzVDLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsZ0JBQWdCO0FBQ2pDLGlCQUFpQixPQUFPO0FBQ3hCLGNBQWM7QUFDZCx1QkFBdUIsa0RBQWtEOztBQUV6RTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0Qyx5REFBeUQsRUFBRSxHQUFHLFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQixxQ0FBcUM7QUFDeEQsbUJBQW1CLHlDQUF5QztBQUM1RCxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0MscUJBQXFCLHNCQUFzQjtBQUMzQyxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCLFVBQVU7QUFDVixtQkFBbUI7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsYUFBYTtBQUMxQixhQUFhLE9BQU87QUFDcEIsVUFBVTtBQUNWLG1CQUFtQiw2Q0FBNkM7O0FBRWhFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfbmV3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7cmVhZFIxY3NIZWFkZXJ9IGZyb20gXCJyMWNzZmlsZVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCB7XG4gICAgcmVhZEJpbkZpbGUsXG4gICAgY3JlYXRlQmluRmlsZSxcbiAgICByZWFkU2VjdGlvbixcbiAgICB3cml0ZUJpZ0ludCxcbiAgICBzdGFydFdyaXRlU2VjdGlvbixcbiAgICBlbmRXcml0ZVNlY3Rpb24sXG59IGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgeyBsb2cyLCBmb3JtYXRIYXNoIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgU2NhbGFyLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgeyBibGFrZTJiIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvYmxha2UyYlwiO1xuaW1wb3J0IEJpZ0FycmF5IGZyb20gXCIuL2JpZ2FycmF5LmpzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gbmV3WktleShyMWNzTmFtZSwgcHRhdU5hbWUsIHprZXlOYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IFRBVV9HMSA9IDA7XG4gICAgY29uc3QgVEFVX0cyID0gMTtcbiAgICBjb25zdCBBTFBIQVRBVV9HMSA9IDI7XG4gICAgY29uc3QgQkVUQVRBVV9HMSA9IDM7XG4gICAgY29uc3QgY3NIYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTtcblxuICAgIGNvbnN0IHtmZDogZmRQVGF1LCBzZWN0aW9uczogc2VjdGlvbnNQVGF1fSA9IGF3YWl0IHJlYWRCaW5GaWxlKHB0YXVOYW1lLCBcInB0YXVcIiwgMSwgMTw8MjIsIDE8PDI0KTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkUFRhdSwgc2VjdGlvbnNQVGF1KTtcbiAgICBjb25zdCB7ZmQ6IGZkUjFjcywgc2VjdGlvbnM6IHNlY3Rpb25zUjFjc30gPSBhd2FpdCByZWFkQmluRmlsZShyMWNzTmFtZSwgXCJyMWNzXCIsIDEsIDE8PDIyLCAxPDwyNCk7XG4gICAgY29uc3QgcjFjcyA9IGF3YWl0IHJlYWRSMWNzSGVhZGVyKGZkUjFjcywgc2VjdGlvbnNSMWNzLCBmYWxzZSk7XG5cbiAgICBjb25zdCBmZFpLZXkgPSBhd2FpdCBjcmVhdGVCaW5GaWxlKHprZXlOYW1lLCBcInprZXlcIiwgMSwgMTAsIDE8PDIyLCAxPDwyNCk7XG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuXG4gICAgaWYgKHIxY3MucHJpbWUgIT0gY3VydmUucikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJyMWNzIGN1cnZlIGRvZXMgbm90IG1hdGNoIHBvd2VycyBvZiB0YXUgY2VyZW1vbnkgY3VydmVcIik7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBjb25zdCBjaXJQb3dlciA9IGxvZzIocjFjcy5uQ29uc3RyYWludHMgKyByMWNzLm5QdWJJbnB1dHMgKyByMWNzLm5PdXRwdXRzICsxIC0xKSArMTtcblxuICAgIGlmIChjaXJQb3dlciA+IHBvd2VyKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihgY2lyY3VpdCB0b28gYmlnIGZvciB0aGlzIHBvd2VyIG9mIHRhdSBjZXJlbW9ueS4gJHtyMWNzLm5Db25zdHJhaW50c30qMiA+IDIqKiR7cG93ZXJ9YCk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoIXNlY3Rpb25zUFRhdVsxMl0pIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUG93ZXJzIG9mIHRhdSBpcyBub3QgcHJlcGFyZWQuXCIpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgY29uc3QgblB1YmxpYyA9IHIxY3Mubk91dHB1dHMgKyByMWNzLm5QdWJJbnB1dHM7XG4gICAgY29uc3QgZG9tYWluU2l6ZSA9IDIgKiogY2lyUG93ZXI7XG5cbiAgICAvLyBXcml0ZSB0aGUgaGVhZGVyXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDEpO1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKDEpOyAvLyBHcm90aFxuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuXG4gICAgLy8gV3JpdGUgdGhlIEdyb3RoIGhlYWRlciBzZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cblxuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMik7XG4gICAgY29uc3QgcHJpbWVRID0gY3VydmUucTtcbiAgICBjb25zdCBuOHEgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVSKSAtIDEpIC8gNjQpICsxKSo4O1xuICAgIGNvbnN0IFJyID0gU2NhbGFyLm1vZChTY2FsYXIuc2hsKDEsIG44cio4KSwgcHJpbWVSKTtcbiAgICBjb25zdCBSMnIgPSBjdXJ2ZS5Gci5lKFNjYWxhci5tb2QoU2NhbGFyLm11bChScixSciksIHByaW1lUikpO1xuXG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhxKTtcbiAgICBhd2FpdCB3cml0ZUJpZ0ludChmZFpLZXksIHByaW1lUSwgbjhxKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHIpO1xuICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkWktleSwgcHJpbWVSLCBuOHIpO1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHIxY3MublZhcnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgYmFyc1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG5QdWJsaWMpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIHB1YmxpYyB2YXJzIChub3QgaW5jbHVkaW5nIE9ORSlcbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihkb21haW5TaXplKTsgICAgICAgICAgICAgICAgICAvLyBkb21haW5TaXplXG5cbiAgICBsZXQgYkFscGhhMTtcbiAgICBiQWxwaGExID0gYXdhaXQgZmRQVGF1LnJlYWQoc0cxLCBzZWN0aW9uc1BUYXVbNF1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJBbHBoYTEpO1xuICAgIGJBbHBoYTEgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShiQWxwaGExKTtcbiAgICBjc0hhc2hlci51cGRhdGUoYkFscGhhMSk7XG5cbiAgICBsZXQgYkJldGExO1xuICAgIGJCZXRhMSA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMSwgc2VjdGlvbnNQVGF1WzVdWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShiQmV0YTEpO1xuICAgIGJCZXRhMSA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJCZXRhMSk7XG4gICAgY3NIYXNoZXIudXBkYXRlKGJCZXRhMSk7XG5cbiAgICBsZXQgYkJldGEyO1xuICAgIGJCZXRhMiA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMiwgc2VjdGlvbnNQVGF1WzZdWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShiQmV0YTIpO1xuICAgIGJCZXRhMiA9IGF3YWl0IGN1cnZlLkcyLmJhdGNoTEVNdG9VKGJCZXRhMik7XG4gICAgY3NIYXNoZXIudXBkYXRlKGJCZXRhMik7XG5cbiAgICBjb25zdCBiZzEgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgIGN1cnZlLkcxLnRvUnByTEVNKGJnMSwgMCwgY3VydmUuRzEuZyk7XG4gICAgY29uc3QgYmcyID0gbmV3IFVpbnQ4QXJyYXkoc0cyKTtcbiAgICBjdXJ2ZS5HMi50b1JwckxFTShiZzIsIDAsIGN1cnZlLkcyLmcpO1xuICAgIGNvbnN0IGJnMVUgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKGJnMVUsIDAsIGN1cnZlLkcxLmcpO1xuICAgIGNvbnN0IGJnMlUgPSBuZXcgVWludDhBcnJheShzRzIpO1xuICAgIGN1cnZlLkcyLnRvUnByVW5jb21wcmVzc2VkKGJnMlUsIDAsIGN1cnZlLkcyLmcpO1xuXG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJnMik7ICAgICAgICAvLyBnYW1tYTJcbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoYmcxKTsgICAgICAgIC8vIGRlbHRhMVxuICAgIGF3YWl0IGZkWktleS53cml0ZShiZzIpOyAgICAgICAgLy8gZGVsdGEyXG4gICAgY3NIYXNoZXIudXBkYXRlKGJnMlUpOyAgICAgIC8vIGdhbW1hMlxuICAgIGNzSGFzaGVyLnVwZGF0ZShiZzFVKTsgICAgICAvLyBkZWx0YTFcbiAgICBjc0hhc2hlci51cGRhdGUoYmcyVSk7ICAgICAgLy8gZGVsdGEyXG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgcjFjc1wiKTtcbiAgICBsZXQgc1IxY3MgPSBhd2FpdCByZWFkU2VjdGlvbihmZFIxY3MsIHNlY3Rpb25zUjFjcywgMik7XG5cbiAgICBjb25zdCBBID0gbmV3IEJpZ0FycmF5KHIxY3MublZhcnMpO1xuICAgIGNvbnN0IEIxID0gbmV3IEJpZ0FycmF5KHIxY3MublZhcnMpO1xuICAgIGNvbnN0IEIyID0gbmV3IEJpZ0FycmF5KHIxY3MublZhcnMpO1xuICAgIGNvbnN0IEMgPSBuZXcgQmlnQXJyYXkocjFjcy5uVmFycy0gblB1YmxpYyAtMSk7XG4gICAgY29uc3QgSUMgPSBuZXcgQXJyYXkoblB1YmxpYysxKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUmVhZGluZyB0YXVHMVwiKTtcbiAgICBsZXQgc1RhdUcxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDEyLCAoZG9tYWluU2l6ZSAtMSkqc0cxLCBkb21haW5TaXplKnNHMSk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIHRhdUcyXCIpO1xuICAgIGxldCBzVGF1RzIgPSBhd2FpdCByZWFkU2VjdGlvbihmZFBUYXUsIHNlY3Rpb25zUFRhdSwgMTMsIChkb21haW5TaXplIC0xKSpzRzIsIGRvbWFpblNpemUqc0cyKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgYWxwaGF0YXVHMVwiKTtcbiAgICBsZXQgc0FscGhhVGF1RzEgPSBhd2FpdCByZWFkU2VjdGlvbihmZFBUYXUsIHNlY3Rpb25zUFRhdSwgMTQsIChkb21haW5TaXplIC0xKSpzRzEsIGRvbWFpblNpemUqc0cxKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgYmV0YXRhdUcxXCIpO1xuICAgIGxldCBzQmV0YVRhdUcxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDE1LCAoZG9tYWluU2l6ZSAtMSkqc0cxLCBkb21haW5TaXplKnNHMSk7XG5cbiAgICBhd2FpdCBwcm9jZXNzQ29uc3RyYWludHMoKTtcblxuICAgIGF3YWl0IGNvbXBvc2VBbmRXcml0ZVBvaW50cygzLCBcIkcxXCIsIElDLCBcIklDXCIpO1xuXG4gICAgYXdhaXQgd3JpdGVIcygpO1xuXG4gICAgYXdhaXQgaGFzaEhQb2ludHMoKTtcblxuICAgIGF3YWl0IGNvbXBvc2VBbmRXcml0ZVBvaW50cyg4LCBcIkcxXCIsIEMsIFwiQ1wiKTtcbiAgICBhd2FpdCBjb21wb3NlQW5kV3JpdGVQb2ludHMoNSwgXCJHMVwiLCBBLCBcIkFcIik7XG4gICAgYXdhaXQgY29tcG9zZUFuZFdyaXRlUG9pbnRzKDYsIFwiRzFcIiwgQjEsIFwiQjFcIik7XG4gICAgYXdhaXQgY29tcG9zZUFuZFdyaXRlUG9pbnRzKDcsIFwiRzJcIiwgQjIsIFwiQjJcIik7XG5cbiAgICBjb25zdCBjc0hhc2ggPSBjc0hhc2hlci5kaWdlc3QoKTtcbiAgICAvLyBDb250cmlidXRpb25zIHNlY3Rpb25cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDEwKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoY3NIYXNoKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMigwKTtcbiAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goY3NIYXNoLCBcIkNpcmN1aXQgaGFzaDogXCIpKTtcblxuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRSMWNzLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRQVGF1LmNsb3NlKCk7XG5cbiAgICByZXR1cm4gY3NIYXNoO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVIcygpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCA5KTtcbiAgICAgICAgY29uc3QgYnVmZk91dCA9IG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSpzRzEpO1xuICAgICAgICBpZiAoY2lyUG93ZXIgPCBjdXJ2ZS5Gci5zKSB7XG4gICAgICAgICAgICBsZXQgc1RhdUcxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDEyLCAoZG9tYWluU2l6ZSoyLTEpKnNHMSwgZG9tYWluU2l6ZSoyKnNHMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8IGRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgc3BsaXR0aW5nIGJ1ZmZlcjogJHtpfS8ke2RvbWFpblNpemV9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IHNUYXVHMS5zbGljZSggKGkqMisxKSpzRzEsIChpKjIrMSkqc0cxICsgc0cxICk7XG4gICAgICAgICAgICAgICAgYnVmZk91dC5zZXQoYnVmZiwgaSpzRzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNpclBvd2VyID09IGN1cnZlLkZyLnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBzZWN0aW9uc1BUYXVbMTJdWzBdLnAgKyAoKDIgKiogKGNpclBvd2VyKzEpKSAtMSkqc0cxO1xuICAgICAgICAgICAgYXdhaXQgZmRQVGF1LnJlYWRUb0J1ZmZlcihidWZmT3V0LCAwLCBkb21haW5TaXplKnNHMSwgbyArIGRvbWFpblNpemUqc0cxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkNpcmN1aXQgdG9vIGJpZ1wiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNpcmN1aXQgdG9vIGJpZyBmb3IgdGhpcyBjdXJ2ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYnVmZk91dCk7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDb25zdHJhaW50cygpIHtcbiAgICAgICAgY29uc3QgYnVmZkNvZWZmID0gbmV3IFVpbnQ4QXJyYXkoMTIgKyBjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZDb2VmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZkNvZWZmLmJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGJPbmUgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGN1cnZlLkZyLnRvUnByTEUoYk9uZSwgMCwgY3VydmUuRnIuZSgxKSk7XG5cbiAgICAgICAgbGV0IHIxY3NQb3MgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHIxY3NfcmVhZFVMRTMyKCkge1xuICAgICAgICAgICAgY29uc3QgYnVmZiA9IHNSMWNzLnNsaWNlKHIxY3NQb3MsIHIxY3NQb3MrNCk7XG4gICAgICAgICAgICByMWNzUG9zICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gYnVmZlYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29lZnMgPSBuZXcgQmlnQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgYz0wOyBjPHIxY3MubkNvbnN0cmFpbnRzOyBjKyspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGMlMTAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1ZyhgcHJvY2Vzc2luZyBjb25zdHJhaW50czogJHtjfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbkEgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5BOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2VmcCA9IHIxY3NQb3M7XG4gICAgICAgICAgICAgICAgcjFjc1BvcyArPSBjdXJ2ZS5Gci5uODtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGwxdCA9IFRBVV9HMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsMSA9IHNHMSpjO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwydCA9IEJFVEFUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEFbc10gPT09IFwidW5kZWZpbmVkXCIpIEFbc10gPSBbXTtcbiAgICAgICAgICAgICAgICBBW3NdLnB1c2goW2wxdCwgbDEsIGNvZWZwXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocyA8PSBuUHVibGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICAgICAgICAgIElDW3NdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBDW3MtIG5QdWJsaWMgLTFdID09PSBcInVuZGVmaW5lZFwiKSBDW3MtIG5QdWJsaWMgLTFdID0gW107XG4gICAgICAgICAgICAgICAgICAgIENbcyAtIG5QdWJsaWMgLTFdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZWZzLnB1c2goWzAsIGMsIHMsIGNvZWZwXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5CID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuQjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29lZnAgPSByMWNzUG9zO1xuICAgICAgICAgICAgICAgIHIxY3NQb3MgKz0gY3VydmUuRnIubjg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsMXQgPSBUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDEgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBjb25zdCBsMnQgPSBUQVVfRzI7XG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBzRzIqYztcbiAgICAgICAgICAgICAgICBjb25zdCBsM3QgPSBBTFBIQVRBVV9HMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsMyA9IHNHMSpjO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQjFbc10gPT09IFwidW5kZWZpbmVkXCIpIEIxW3NdID0gW107XG4gICAgICAgICAgICAgICAgQjFbc10ucHVzaChbbDF0LCBsMSwgY29lZnBdKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEIyW3NdID09PSBcInVuZGVmaW5lZFwiKSBCMltzXSA9IFtdO1xuICAgICAgICAgICAgICAgIEIyW3NdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocyA8PSBuUHVibGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICAgICAgICAgIElDW3NdLnB1c2goW2wzdCwgbDMsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBDW3MtIG5QdWJsaWMgLTFdID09PSBcInVuZGVmaW5lZFwiKSBDW3MtIG5QdWJsaWMgLTFdID0gW107XG4gICAgICAgICAgICAgICAgICAgIENbcy0gblB1YmxpYyAtMV0ucHVzaChbbDN0LCBsMywgY29lZnBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2Vmcy5wdXNoKFsxLCBjLCBzLCBjb2VmcF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuQyA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZWZwID0gcjFjc1BvcztcbiAgICAgICAgICAgICAgICByMWNzUG9zICs9IGN1cnZlLkZyLm44O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbDF0ID0gVEFVX0cxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwxID0gc0cxKmM7XG4gICAgICAgICAgICAgICAgaWYgKHMgPD0gblB1YmxpYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIElDW3NdID09PSBcInVuZGVmaW5lZFwiKSBJQ1tzXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBJQ1tzXS5wdXNoKFtsMXQsIGwxLCBjb2VmcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQ1tzLSBuUHVibGljIC0xXSA9PT0gXCJ1bmRlZmluZWRcIikgQ1tzLSBuUHVibGljIC0xXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBDW3MtIG5QdWJsaWMgLTFdLnB1c2goW2wxdCwgbDEsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPD0gblB1YmxpYyA7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgbDF0ID0gVEFVX0cxO1xuICAgICAgICAgICAgY29uc3QgbDEgPSBzRzEqKHIxY3MubkNvbnN0cmFpbnRzICsgcyk7XG4gICAgICAgICAgICBjb25zdCBsMnQgPSBCRVRBVEFVX0cxO1xuICAgICAgICAgICAgY29uc3QgbDIgPSBzRzEqKHIxY3MubkNvbnN0cmFpbnRzICsgcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEFbc10gPT09IFwidW5kZWZpbmVkXCIpIEFbc10gPSBbXTtcbiAgICAgICAgICAgIEFbc10ucHVzaChbbDF0LCBsMSwgLTFdKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICBJQ1tzXS5wdXNoKFtsMnQsIGwyLCAtMV0pO1xuICAgICAgICAgICAgY29lZnMucHVzaChbMCwgcjFjcy5uQ29uc3RyYWludHMgKyBzLCBzLCAtMV0pO1xuICAgICAgICB9XG5cblxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDQpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmZTZWN0aW9uID0gbmV3IEJpZ0J1ZmZlcihjb2Vmcy5sZW5ndGgqKDEyK2N1cnZlLkZyLm44KSArIDQpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmY0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IGJ1ZmY0ViA9IG5ldyBEYXRhVmlldyhidWZmNC5idWZmZXIpO1xuICAgICAgICBidWZmNFYuc2V0VWludDMyKDAsIGNvZWZzLmxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgIGJ1ZmZTZWN0aW9uLnNldChidWZmNCk7XG4gICAgICAgIGxldCBjb2Vmc1BvcyA9IDQ7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb2Vmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyBjb2VmZnM6ICR7aX0vJHtjb2Vmcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB3cml0ZUNvZWYoY29lZnNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJ1ZmZTZWN0aW9uKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDb2VmKGMpIHtcbiAgICAgICAgICAgIGJ1ZmZDb2VmZlYuc2V0VWludDMyKDAsIGNbMF0sIHRydWUpO1xuICAgICAgICAgICAgYnVmZkNvZWZmVi5zZXRVaW50MzIoNCwgY1sxXSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmQ29lZmZWLnNldFVpbnQzMig4LCBjWzJdLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGNbM10+PTApIHtcbiAgICAgICAgICAgICAgICBuID0gY3VydmUuRnIuZnJvbVJwckxFKHNSMWNzLnNsaWNlKGNbM10sIGNbM10gKyBjdXJ2ZS5Gci5uOCksIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gY3VydmUuRnIuZnJvbVJwckxFKGJPbmUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgblIyID0gY3VydmUuRnIubXVsKG4sIFIycik7XG4gICAgICAgICAgICBjdXJ2ZS5Gci50b1JwckxFKGJ1ZmZDb2VmZiwgMTIsIG5SMik7XG4gICAgICAgICAgICBidWZmU2VjdGlvbi5zZXQoYnVmZkNvZWZmLCBjb2Vmc1Bvcyk7XG4gICAgICAgICAgICBjb2Vmc1BvcyArPSBidWZmQ29lZmYubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wb3NlQW5kV3JpdGVQb2ludHMoaWRTZWN0aW9uLCBncm91cE5hbWUsIGFyciwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgQ0hVTktfU0laRT0gMTw8MTU7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuXG4gICAgICAgIGhhc2hVMzIoYXJyLmxlbmd0aCk7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgaWRTZWN0aW9uKTtcblxuICAgICAgICBsZXQgb3BQcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGxldCBpPTA7XG4gICAgICAgIHdoaWxlIChpPGFyci5sZW5ndGgpIHtcblxuICAgICAgICAgICAgbGV0IHQ9MDtcbiAgICAgICAgICAgIHdoaWxlICgoaTxhcnIubGVuZ3RoKSYmKHQ8Y3VydmUudG0uY29uY3VycmVuY3kpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgIGxvZ2dlci5kZWJ1ZyhgV3JpdGluZyBwb2ludHMgc3RhcnQgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHthcnIubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIGxldCBuID0gMTtcbiAgICAgICAgICAgICAgICBsZXQgblAgPSAoYXJyW2ldID8gYXJyW2ldLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoaSArIG4gPCBhcnIubGVuZ3RoKSAmJiAoblAgKyAoYXJyW2krbl0gPyBhcnJbaStuXS5sZW5ndGggOiAwKSA8IENIVU5LX1NJWkUpICYmIChuPENIVU5LX1NJWkUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5QICs9IChhcnJbaStuXSA/IGFycltpK25dLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgICAgICAgICBuICsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdWJBcnIgPSBhcnIuc2xpY2UoaSwgaSArIG4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9pID0gaTtcbiAgICAgICAgICAgICAgICBvcFByb21pc2VzLnB1c2goY29tcG9zZUFuZFdyaXRlUG9pbnRzVGhyZWFkKGdyb3VwTmFtZSwgc3ViQXJyLCBsb2dnZXIsIHNlY3Rpb25OYW1lKS50aGVuKCAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSAgbG9nZ2VyLmRlYnVnKGBXcml0aW5nIHBvaW50cyBlbmQgJHtzZWN0aW9uTmFtZX06ICR7X2l9LyR7YXJyLmxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGkgKz0gbjtcbiAgICAgICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBrPTA7IGs8cmVzdWx0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHJlc3VsdFtrXVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IEcuYmF0Y2hMRU10b1UocmVzdWx0W2tdWzBdKTtcbiAgICAgICAgICAgICAgICBjc0hhc2hlci51cGRhdGUoYnVmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcFByb21pc2VzID0gW107XG5cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXBvc2VBbmRXcml0ZVBvaW50c1RocmVhZChncm91cE5hbWUsIGFyciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0dpbiA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBzR21pZCA9IEcuRi5uOCozO1xuICAgICAgICBjb25zdCBzR291dCA9IEcuRi5uOCoyO1xuICAgICAgICBsZXQgZm5FeHAsIGZuTXVsdGlFeHAsIGZuQmF0Y2hUb0FmZmluZSwgZm5aZXJvO1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgZm5FeHAgPSBcImcxbV90aW1lc1NjYWxhckFmZmluZVwiO1xuICAgICAgICAgICAgZm5NdWx0aUV4cCA9IFwiZzFtX211bHRpZXhwQWZmaW5lXCI7XG4gICAgICAgICAgICBmbkJhdGNoVG9BZmZpbmUgPSBcImcxbV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICBmblplcm8gPSBcImcxbV96ZXJvXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgZm5FeHAgPSBcImcybV90aW1lc1NjYWxhckFmZmluZVwiO1xuICAgICAgICAgICAgZm5NdWx0aUV4cCA9IFwiZzJtX211bHRpZXhwQWZmaW5lXCI7XG4gICAgICAgICAgICBmbkJhdGNoVG9BZmZpbmUgPSBcImcybV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICBmblplcm8gPSBcImcybV96ZXJvXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY2MgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIGFjYyArPSBhcnJbaV0gPyBhcnJbaV0ubGVuZ3RoIDogMDtcbiAgICAgICAgbGV0IGJCYXNlcywgYlNjYWxhcnM7XG4gICAgICAgIGlmIChhY2M+IDI8PDE0KSB7XG4gICAgICAgICAgICBiQmFzZXMgPSBuZXcgQmlnQnVmZmVyKGFjYypzR2luKTtcbiAgICAgICAgICAgIGJTY2FsYXJzID0gbmV3IEJpZ0J1ZmZlcihhY2MqY3VydmUuRnIubjgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYkJhc2VzID0gbmV3IFVpbnQ4QXJyYXkoYWNjKnNHaW4pO1xuICAgICAgICAgICAgYlNjYWxhcnMgPSBuZXcgVWludDhBcnJheShhY2MqY3VydmUuRnIubjgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwQiA9MDtcbiAgICAgICAgbGV0IHBTID0wO1xuXG4gICAgICAgIGNvbnN0IHNCdWZmcyA9IFtcbiAgICAgICAgICAgIHNUYXVHMSxcbiAgICAgICAgICAgIHNUYXVHMixcbiAgICAgICAgICAgIHNBbHBoYVRhdUcxLFxuICAgICAgICAgICAgc0JldGFUYXVHMVxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGJPbmUgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGN1cnZlLkZyLnRvUnByTEUoYk9uZSwgMCwgY3VydmUuRnIuZSgxKSk7XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghYXJyW2ldKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxhcnJbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihqKSYmKGolMTAwMDAgPT0gMCkpICBsb2dnZXIuZGVidWcoYENvbmZpZ3VyaW5nIGJpZyBhcnJheSAke3NlY3Rpb25OYW1lfTogJHtqfS8ke2FycltpXS5sZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgYkJhc2VzLnNldChcbiAgICAgICAgICAgICAgICAgICAgc0J1ZmZzW2FycltpXVtqXVswXV0uc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMV0gKyBzR2luXG4gICAgICAgICAgICAgICAgICAgICksIG9mZnNldCpzR2luXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldW2pdWzJdPj0wKSB7XG4gICAgICAgICAgICAgICAgICAgIGJTY2FsYXJzLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIHNSMWNzLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXVtqXVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMl0gKyBjdXJ2ZS5Gci5uOFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCpjdXJ2ZS5Gci5uOFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJTY2FsYXJzLnNldChiT25lLCBvZmZzZXQqY3VydmUuRnIubjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJCYXNlc30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBiU2NhbGFyc30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IGFyci5sZW5ndGgqc0dtaWR9KTtcbiAgICAgICAgICAgIHBCID0gMDtcbiAgICAgICAgICAgIHBTID0gMDtcbiAgICAgICAgICAgIGxldCBwRCA9MDtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycltpXSkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5aZXJvLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogcER9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICAgICAgcEQgKz0gc0dtaWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkV4cCwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwLCBvZmZzZXQ6IHBCfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogcFN9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogY3VydmUuRnIubjh9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMiwgb2Zmc2V0OiBwRH1cbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk11bHRpRXhwLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDAsIG9mZnNldDogcEJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMSwgb2Zmc2V0OiBwU30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBjdXJ2ZS5Gci5uOH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBhcnJbaV0ubGVuZ3RofSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogcER9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcEIgKz0gc0dpbiphcnJbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBTICs9IGN1cnZlLkZyLm44KmFycltpXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcEQgKz0gc0dtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5CYXRjaFRvQWZmaW5lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBhcnIubGVuZ3RofSxcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBhcnIubGVuZ3RoKnNHb3V0fSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJCYXNlcywgYlNjYWxhcnMsIGxvZ2dlciwgc2VjdGlvbk5hbWUpO1xuICAgICAgICAgICAgcmVzID0gWyBHLnRvQWZmaW5lKHJlcykgXTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhc2hIUG9pbnRzKCkge1xuICAgICAgICBjb25zdCBDSFVOS19TSVpFID0gMTw8MTQ7XG5cbiAgICAgICAgaGFzaFUzMihkb21haW5TaXplLTEpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxkb21haW5TaXplLTE7IGkrPSBDSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSAgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nSFBvaW50czogJHtpfS8ke2RvbWFpblNpemV9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oZG9tYWluU2l6ZS0xLCBDSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGF3YWl0IGhhc2hIUG9pbnRzQ2h1bmsoaSwgbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoSFBvaW50c0NodW5rKG9mZnNldCwgblBvaW50cykge1xuICAgICAgICBjb25zdCBidWZmMSA9IGF3YWl0IGZkUFRhdS5yZWFkKG5Qb2ludHMgKnNHMSwgc2VjdGlvbnNQVGF1WzJdWzBdLnAgKyAob2Zmc2V0ICsgZG9tYWluU2l6ZSkqc0cxKTtcbiAgICAgICAgY29uc3QgYnVmZjIgPSBhd2FpdCBmZFBUYXUucmVhZChuUG9pbnRzICpzRzEsIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgb2Zmc2V0KnNHMSk7XG4gICAgICAgIGNvbnN0IGNvbmN1cnJlbmN5PSBjdXJ2ZS50bS5jb25jdXJyZW5jeTtcbiAgICAgICAgY29uc3QgblBvaW50c1BlclRocmVhZCA9IE1hdGguZmxvb3IoblBvaW50cyAvIGNvbmN1cnJlbmN5KTtcbiAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzUGVyVGhyZWFkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqblBvaW50c1BlclRocmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuPT0wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3Qgc3ViQnVmZjEgPSBidWZmMS5zbGljZShpKm5Qb2ludHNQZXJUaHJlYWQqc0cxLCAoaSpuUG9pbnRzUGVyVGhyZWFkK24pKnNHMSk7XG4gICAgICAgICAgICBjb25zdCBzdWJCdWZmMiA9IGJ1ZmYyLnNsaWNlKGkqblBvaW50c1BlclRocmVhZCpzRzEsIChpKm5Qb2ludHNQZXJUaHJlYWQrbikqc0cxKTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChoYXNoSFBvaW50c1RocmVhZChzdWJCdWZmMSwgc3ViQnVmZjIpKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3NIYXNoZXIudXBkYXRlKHJlc3VsdFtpXVswXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoSFBvaW50c1RocmVhZChidWZmMSwgYnVmZjIpIHtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGgvc0cxO1xuICAgICAgICBjb25zdCBzR21pZCA9IGN1cnZlLkcxLkYubjgqMztcbiAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJ1ZmYxfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYnVmZjJ9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IG5Qb2ludHMqc0dtaWR9KTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgdGFzay5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbWQ6IFwiQ0FMTFwiLFxuICAgICAgICAgICAgICAgIGZuTmFtZTogXCJnMW1fc3ViQWZmaW5lXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDAsIG9mZnNldDogaSpzRzF9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAxLCBvZmZzZXQ6IGkqc0cxfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMiwgb2Zmc2V0OiBpKnNHbWlkfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJnMW1fYmF0Y2hUb0FmZmluZVwiLCBwYXJhbXM6IFtcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAge3ZhbDogblBvaW50c30sXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgXX0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJnMW1fYmF0Y2hMRU10b1VcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIHt2YWw6IG5Qb2ludHN9LFxuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgIF19KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAyLCBsZW46IG5Qb2ludHMqc0cxfSk7XG5cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUudG0ucXVldWVBY3Rpb24odGFzayk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNoVTMyKG4pIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0LCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICBidWZmVi5zZXRVaW50MzIoMCwgbiwgZmFsc2UpO1xuICAgICAgICBjc0hhc2hlci51cGRhdGUoYnVmZik7XG4gICAgfVxuXG59XG5cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_new.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_utils.js":
/*!************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_utils.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashG1: () => (/* binding */ hashG1),\n/* harmony export */   hashG2: () => (/* binding */ hashG2),\n/* harmony export */   hashPubKey: () => (/* binding */ hashPubKey),\n/* harmony export */   readHeader: () => (/* binding */ readHeader),\n/* harmony export */   readMPCParams: () => (/* binding */ readMPCParams),\n/* harmony export */   readZKey: () => (/* binding */ readZKey),\n/* harmony export */   writeHeader: () => (/* binding */ writeHeader),\n/* harmony export */   writeMPCParams: () => (/* binding */ writeMPCParams),\n/* harmony export */   writeZKey: () => (/* binding */ writeZKey)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(ssr)/./node_modules/snarkjs/src/fflonk_constants.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format\n// ======\n// Header(1)\n//      Prover Type 1 Groth\n// HeaderGroth(2)\n//      n8q\n//      q\n//      n8r\n//      r\n//      NVars\n//      NPub\n//      DomainSize  (multiple of 2\n//      alpha1\n//      beta1\n//      delta1\n//      beta2\n//      gamma2\n//      delta2\n// IC(3)\n// Coefs(4)\n// PointsA(5)\n// PointsB1(6)\n// PointsB2(7)\n// PointsC(8)\n// PointsH(9)\n// Contributions(10)\n\n\n\n\n\n\n\n\n\nasync function writeHeader(fd, zkey) {\n\n    // Write the header\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    await fd.writeULE32(1); // Groth\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write the Groth header section\n    ///////////\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n    await fd.writeULE32(n8q);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, primeQ, n8q);\n    await fd.writeULE32(n8r);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, primeR, n8r);\n    await fd.writeULE32(zkey.nVars);                         // Total number of bars\n    await fd.writeULE32(zkey.nPublic);                       // Total number of public vars (not including ONE)\n    await fd.writeULE32(zkey.domainSize);                  // domainSize\n    await writeG1(fd, curve, zkey.vk_alpha_1);\n    await writeG1(fd, curve, zkey.vk_beta_1);\n    await writeG2(fd, curve, zkey.vk_beta_2);\n    await writeG2(fd, curve, zkey.vk_gamma_2);\n    await writeG1(fd, curve, zkey.vk_delta_1);\n    await writeG2(fd, curve, zkey.vk_delta_2);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n}\n\nasync function writeZKey(fileName, zkey) {\n\n    let curve = (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const fd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(fileName,\"zkey\", 1, 9);\n\n    await writeHeader(fd, zkey);\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(zkey.r) - 1) / 64) +1)*8;\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.shl(1, n8r*8), zkey.r);\n    const R2r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mul(Rr,Rr), zkey.r);\n\n    // Write Pols (A and B (C can be omitted))\n    ///////////\n\n    zkey.ccoefs = zkey.ccoefs.filter(c => c.matrix<2);\n    zkey.ccoefs.sort( (a,b) => a.constraint - b.constraint );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 4);\n    await fd.writeULE32(zkey.ccoefs.length);\n    for (let i=0; i<zkey.ccoefs.length; i++) {\n        const coef = zkey.ccoefs[i];\n        await fd.writeULE32(coef.matrix);\n        await fd.writeULE32(coef.constraint);\n        await fd.writeULE32(coef.signal);\n        await writeFr2(coef.value);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 3);\n    for (let i=0; i<= zkey.nPublic; i++) {\n        await writeG1(fd, curve, zkey.IC[i] );\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write A\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 5);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.A[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write B1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 6);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.B1[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write B2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 7);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG2(fd, curve, zkey.B2[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write C\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 8);\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.C[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write H points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 9);\n    for (let i=0; i<zkey.domainSize; i++) {\n        await writeG1(fd, curve, zkey.hExps[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await fd.close();\n\n    async function writeFr2(n) {\n        // Convert to montgomery\n        n = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod( ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mul(n, R2r), zkey.r);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, n, n8r);\n    }\n\n}\n\nasync function writeG1(fd, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function writeG2(fd, curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function readG1(fd, curve, toObject) {\n    const buff = await fd.read(curve.G1.F.n8*2);\n    const res = curve.G1.fromRprLEM(buff, 0);\n    return toObject ? curve.G1.toObject(res) : res;\n}\n\nasync function readG2(fd, curve, toObject) {\n    const buff = await fd.read(curve.G2.F.n8*2);\n    const res = curve.G2.fromRprLEM(buff, 0);\n    return toObject ? curve.G2.toObject(res) : res;\n}\n\n\nasync function readHeader(fd, sections, toObject, options) {\n    // Read Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 1);\n    const protocolId = await fd.readULE32();\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.GROTH16_PROTOCOL_ID) {\n        return await readHeaderGroth16(fd, sections, toObject, options);\n    } else if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.PLONK_PROTOCOL_ID) {\n        return await readHeaderPlonk(fd, sections, toObject, options);\n    } else if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        return await readHeaderFFlonk(fd, sections, toObject, options);\n    } else {\n        throw new Error(\"Protocol not supported: \");\n    }\n}\n\n\n\n\nasync function readHeaderGroth16(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"groth16\";\n\n    // Read Groth Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.vk_alpha_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_gamma_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_delta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_delta_2 = await readG2(fd, zkey.curve, toObject);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n\n}\n\nasync function readHeaderPlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"plonk\";\n\n    // Read Plonk Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.Qm = await readG1(fd, zkey.curve, toObject);\n    zkey.Ql = await readG1(fd, zkey.curve, toObject);\n    zkey.Qr = await readG1(fd, zkey.curve, toObject);\n    zkey.Qo = await readG1(fd, zkey.curve, toObject);\n    zkey.Qc = await readG1(fd, zkey.curve, toObject);\n    zkey.S1 = await readG1(fd, zkey.curve, toObject);\n    zkey.S2 = await readG1(fd, zkey.curve, toObject);\n    zkey.S3 = await readG1(fd, zkey.curve, toObject);\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readHeaderFFlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"fflonk\";\n    zkey.protocolId = _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID;\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_HEADER_SECTION);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q, options);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.w3 = await fd.read(n8r);\n    zkey.w4 = await fd.read(n8r);\n    zkey.w8 = await fd.read(n8r);\n    zkey.wr = await fd.read(n8r);\n\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    zkey.C0 = await readG1(fd, zkey.curve, toObject);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readZKey(fileName, toObject) {\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(fileName, \"zkey\", 1);\n\n    const zkey = await readHeader(fd, sections, toObject);\n\n    const Fr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.F1Field(zkey.r);\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.shl(1, zkey.n8r*8), zkey.r);\n    const Rri = Fr.inv(Rr);\n    const Rri2 = Fr.mul(Rri, Rri);\n\n    let curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    // Read IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 3);\n    zkey.IC = [];\n    for (let i=0; i<= zkey.nPublic; i++) {\n        const P = await readG1(fd, curve, toObject);\n        zkey.IC.push(P);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read Coefs\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 4);\n    const nCCoefs = await fd.readULE32();\n    zkey.ccoefs = [];\n    for (let i=0; i<nCCoefs; i++) {\n        const m = await fd.readULE32();\n        const c = await fd.readULE32();\n        const s = await fd.readULE32();\n        const v = await readFr2(toObject);\n        zkey.ccoefs.push({\n            matrix: m,\n            constraint: c,\n            signal: s,\n            value: v\n        });\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    // Read A points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 5);\n    zkey.A = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const A = await readG1(fd, curve, toObject);\n        zkey.A[i] = A;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read B1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 6);\n    zkey.B1 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B1 = await readG1(fd, curve, toObject);\n\n        zkey.B1[i] = B1;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read B2 points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 7);\n    zkey.B2 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B2 = await readG2(fd, curve, toObject);\n        zkey.B2[i] = B2;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read C points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 8);\n    zkey.C = [];\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        const C = await readG1(fd, curve, toObject);\n\n        zkey.C[i] = C;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read H points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 9);\n    zkey.hExps = [];\n    for (let i=0; i<zkey.domainSize; i++) {\n        const H = await readG1(fd, curve, toObject);\n        zkey.hExps.push(H);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    await fd.close();\n\n    return zkey;\n\n    async function readFr2(/* toObject */) {\n        const n = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, zkey.n8r);\n        return Fr.mul(n, Rri2);\n    }\n\n}\n\n\nasync function readContribution(fd, curve, toObject) {\n    const c = {delta:{}};\n    c.deltaAfter = await readG1(fd, curve, toObject);\n    c.delta.g1_s = await readG1(fd, curve, toObject);\n    c.delta.g1_sx = await readG1(fd, curve, toObject);\n    c.delta.g2_spx = await readG2(fd, curve, toObject);\n    c.transcript = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await fd.read(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await fd.read(1);\n            const buffStr = await fd.read(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await fd.read(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await fd.read(1);\n            c.beaconHash = await fd.read(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n}\n\n\nasync function readMPCParams(fd, curve, sections) {\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 10);\n    const res = { contributions: []};\n    res.csHash = await fd.read(64);\n    const n = await fd.readULE32();\n    for (let i=0; i<n; i++) {\n        const c = await readContribution(fd, curve);\n        res.contributions.push(c);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return res;\n}\n\nasync function writeContribution(fd, curve, c) {\n    await writeG1(fd, curve, c.deltaAfter);\n    await writeG1(fd, curve, c.delta.g1_s);\n    await writeG1(fd, curve, c.delta.g1_sx);\n    await writeG2(fd, curve, c.delta.g2_spx);\n    await fd.write(c.transcript);\n    await fd.writeULE32(c.type || 0);\n\n    const params = [];\n    if (c.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(c.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (c.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(c.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(c.beaconHash.byteLength);\n        for (let i=0; i<c.beaconHash.byteLength; i++) params.push(c.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n}\n\nasync function writeMPCParams(fd, curve, mpcParams) {\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 10);\n    await fd.write(mpcParams.csHash);\n    await fd.writeULE32(mpcParams.contributions.length);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        await writeContribution(fd, curve,mpcParams.contributions[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n}\n\nfunction hashG1(hasher, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashG2(hasher,curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashPubKey(hasher, curve, c) {\n    hashG1(hasher, curve, c.deltaAfter);\n    hashG1(hasher, curve, c.delta.g1_s);\n    hashG1(hasher, curve, c.delta.g1_sx);\n    hashG2(hasher, curve, c.delta.g2_spx);\n    hasher.update(c.transcript);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStDO0FBQ0s7O0FBRUk7QUFDdkI7QUFDOEQ7QUFDbEM7O0FBRXREOztBQUVQO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4Qyw0QkFBNEI7QUFDNUIsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7O0FBRUEsd0JBQXdCLHlEQUFROztBQUVoQyxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLDhCQUE4QixnREFBTTs7QUFFcEM7QUFDQSw4QkFBOEIsZ0RBQU07O0FBRXBDO0FBQ0EsVUFBVSw0REFBd0I7QUFDbEM7QUFDQSxVQUFVLDREQUF3QjtBQUNsQyw2REFBNkQ7QUFDN0QsNkRBQTZEO0FBQzdELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnRUFBNEI7OztBQUd0Qzs7QUFFTzs7QUFFUCxnQkFBZ0IseURBQVE7O0FBRXhCLHFCQUFxQiw4REFBMEI7O0FBRS9DO0FBQ0EsOEJBQThCLGdEQUFNO0FBQ3BDLGVBQWUsZ0RBQU0sS0FBSyxnREFBTTtBQUNoQyxnQkFBZ0IsZ0RBQU0sS0FBSyxnREFBTTs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOzs7QUFHdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOzs7QUFHdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7O0FBR3RDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QyxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBLFlBQVksZ0RBQU0sTUFBTSxnREFBTTs7QUFFOUIsY0FBYyw0REFBd0I7QUFDdEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckMsdUJBQXVCLG1FQUFtQjtBQUMxQztBQUNBLE1BQU0sd0JBQXdCLGlFQUFpQjtBQUMvQztBQUNBLE1BQU0sd0JBQXdCLGtFQUFrQjtBQUNoRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQTtBQUNBLG1CQUFtQiwyREFBdUI7O0FBRTFDO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQXVCO0FBQzFDLHVCQUF1Qix5REFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrREFBMkI7O0FBRXJDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQXVCOztBQUUxQztBQUNBO0FBQ0EsbUJBQW1CLDJEQUF1QjtBQUMxQyx1QkFBdUIseURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLCtEQUEyQjs7QUFFckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGtFQUFrQjs7QUFFeEMsVUFBVSx1RUFBbUMsZUFBZSx3RUFBc0I7QUFDbEY7QUFDQTtBQUNBLG1CQUFtQiwyREFBdUI7QUFDMUMsdUJBQXVCLHlEQUFROztBQUUvQjtBQUNBO0FBQ0EsbUJBQW1CLDJEQUF1Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLCtEQUEyQjs7QUFFckM7QUFDQTs7QUFFTztBQUNQLFdBQVcsY0FBYyxRQUFRLDREQUF3Qjs7QUFFekQ7O0FBRUEsbUJBQW1CLGlEQUFPO0FBQzFCLGVBQWUsZ0RBQU0sS0FBSyxnREFBTTtBQUNoQztBQUNBOztBQUVBLHNCQUFzQix5REFBUTs7QUFFOUI7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7O0FBR3JDO0FBQ0E7QUFDQSxVQUFVLHVFQUFtQztBQUM3QztBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsVUFBVSwrREFBMkI7O0FBRXJDO0FBQ0E7QUFDQSxVQUFVLHVFQUFtQztBQUM3QztBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOzs7QUFHckM7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7O0FBRUE7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOzs7QUFHckM7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrREFBMkI7OztBQUdyQztBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSwrQkFBK0IsY0FBYztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0EsVUFBVSwrREFBMkI7OztBQUdyQztBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOztBQUVyQzs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QiwyREFBdUI7QUFDL0M7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdPO0FBQ1AsVUFBVSx1RUFBbUM7QUFDN0Msa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRU87QUFDUCxVQUFVLGtFQUE4QjtBQUN4QztBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7QUFDdEM7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9uZW8vZ2l0L3puZXAxNy93ZWIvbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLy8gRm9ybWF0XG4vLyA9PT09PT1cbi8vIEhlYWRlcigxKVxuLy8gICAgICBQcm92ZXIgVHlwZSAxIEdyb3RoXG4vLyBIZWFkZXJHcm90aCgyKVxuLy8gICAgICBuOHFcbi8vICAgICAgcVxuLy8gICAgICBuOHJcbi8vICAgICAgclxuLy8gICAgICBOVmFyc1xuLy8gICAgICBOUHViXG4vLyAgICAgIERvbWFpblNpemUgIChtdWx0aXBsZSBvZiAyXG4vLyAgICAgIGFscGhhMVxuLy8gICAgICBiZXRhMVxuLy8gICAgICBkZWx0YTFcbi8vICAgICAgYmV0YTJcbi8vICAgICAgZ2FtbWEyXG4vLyAgICAgIGRlbHRhMlxuLy8gSUMoMylcbi8vIENvZWZzKDQpXG4vLyBQb2ludHNBKDUpXG4vLyBQb2ludHNCMSg2KVxuLy8gUG9pbnRzQjIoNylcbi8vIFBvaW50c0MoOClcbi8vIFBvaW50c0goOSlcbi8vIENvbnRyaWJ1dGlvbnMoMTApXG5cbmltcG9ydCB7IFNjYWxhciwgRjFGaWVsZCB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuXG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21RIGFzIGdldEN1cnZlIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgeyBsb2cyIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHtGRkxPTktfUFJPVE9DT0xfSUQsIEdST1RIMTZfUFJPVE9DT0xfSUQsIFBMT05LX1BST1RPQ09MX0lEfSBmcm9tIFwiLi96a2V5X2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHtaS0VZX0ZGX0hFQURFUl9TRUNUSU9OfSBmcm9tIFwiLi9mZmxvbmtfY29uc3RhbnRzLmpzXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZUhlYWRlcihmZCwgemtleSkge1xuXG4gICAgLy8gV3JpdGUgdGhlIGhlYWRlclxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAxKTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDEpOyAvLyBHcm90aFxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgdGhlIEdyb3RoIGhlYWRlciBzZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMik7XG4gICAgY29uc3QgcHJpbWVRID0gY3VydmUucTtcbiAgICBjb25zdCBuOHEgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVSKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihuOHEpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy53cml0ZUJpZ0ludChmZCwgcHJpbWVRLCBuOHEpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobjhyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMud3JpdGVCaWdJbnQoZmQsIHByaW1lUiwgbjhyKTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHprZXkublZhcnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgYmFyc1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoemtleS5uUHVibGljKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBwdWJsaWMgdmFycyAobm90IGluY2x1ZGluZyBPTkUpXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMih6a2V5LmRvbWFpblNpemUpOyAgICAgICAgICAgICAgICAgIC8vIGRvbWFpblNpemVcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS52a19hbHBoYV8xKTtcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS52a19iZXRhXzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoZmQsIGN1cnZlLCB6a2V5LnZrX2JldGFfMik7XG4gICAgYXdhaXQgd3JpdGVHMihmZCwgY3VydmUsIHprZXkudmtfZ2FtbWFfMik7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkudmtfZGVsdGFfMSk7XG4gICAgYXdhaXQgd3JpdGVHMihmZCwgY3VydmUsIHprZXkudmtfZGVsdGFfMik7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZVpLZXkoZmlsZU5hbWUsIHprZXkpIHtcblxuICAgIGxldCBjdXJ2ZSA9IGdldEN1cnZlKHprZXkucSk7XG5cbiAgICBjb25zdCBmZCA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKGZpbGVOYW1lLFwiemtleVwiLCAxLCA5KTtcblxuICAgIGF3YWl0IHdyaXRlSGVhZGVyKGZkLCB6a2V5KTtcbiAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgoemtleS5yKSAtIDEpIC8gNjQpICsxKSo4O1xuICAgIGNvbnN0IFJyID0gU2NhbGFyLm1vZChTY2FsYXIuc2hsKDEsIG44cio4KSwgemtleS5yKTtcbiAgICBjb25zdCBSMnIgPSBTY2FsYXIubW9kKFNjYWxhci5tdWwoUnIsUnIpLCB6a2V5LnIpO1xuXG4gICAgLy8gV3JpdGUgUG9scyAoQSBhbmQgQiAoQyBjYW4gYmUgb21pdHRlZCkpXG4gICAgLy8vLy8vLy8vLy9cblxuICAgIHprZXkuY2NvZWZzID0gemtleS5jY29lZnMuZmlsdGVyKGMgPT4gYy5tYXRyaXg8Mik7XG4gICAgemtleS5jY29lZnMuc29ydCggKGEsYikgPT4gYS5jb25zdHJhaW50IC0gYi5jb25zdHJhaW50ICk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA0KTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHprZXkuY2NvZWZzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkuY2NvZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZWYgPSB6a2V5LmNjb2Vmc1tpXTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb2VmLm1hdHJpeCk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY29lZi5jb25zdHJhaW50KTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb2VmLnNpZ25hbCk7XG4gICAgICAgIGF3YWl0IHdyaXRlRnIyKGNvZWYudmFsdWUpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gV3JpdGUgSUMgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAzKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS5JQ1tpXSApO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gV3JpdGUgQVxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA1KTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LkFbaV0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIEIxXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDYpO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkuQjFbaV0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIEIyXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDcpO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVHMihmZCwgY3VydmUsIHprZXkuQjJbaV0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIENcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgOCk7XG4gICAgZm9yIChsZXQgaT16a2V5Lm5QdWJsaWMrMTsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkuQ1tpXSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBXcml0ZSBIIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA5KTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkuaEV4cHNbaV0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUZyMihuKSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gbW9udGdvbWVyeVxuICAgICAgICBuID0gU2NhbGFyLm1vZCggU2NhbGFyLm11bChuLCBSMnIpLCB6a2V5LnIpO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy53cml0ZUJpZ0ludChmZCwgbiwgbjhyKTtcbiAgICB9XG5cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVHMShmZCwgY3VydmUsIHApIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKTtcbiAgICBjdXJ2ZS5HMS50b1JwckxFTShidWZmLCAwLCBwKTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVHMihmZCwgY3VydmUsIHApIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzIuRi5uOCoyKTtcbiAgICBjdXJ2ZS5HMi50b1JwckxFTShidWZmLCAwLCBwKTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpIHtcbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5HMS5GLm44KjIpO1xuICAgIGNvbnN0IHJlcyA9IGN1cnZlLkcxLmZyb21ScHJMRU0oYnVmZiwgMCk7XG4gICAgcmV0dXJuIHRvT2JqZWN0ID8gY3VydmUuRzEudG9PYmplY3QocmVzKSA6IHJlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEcyKGZkLCBjdXJ2ZSwgdG9PYmplY3QpIHtcbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5HMi5GLm44KjIpO1xuICAgIGNvbnN0IHJlcyA9IGN1cnZlLkcyLmZyb21ScHJMRU0oYnVmZiwgMCk7XG4gICAgcmV0dXJuIHRvT2JqZWN0ID8gY3VydmUuRzIudG9PYmplY3QocmVzKSA6IHJlcztcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlcihmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgLy8gUmVhZCBIZWFkZXJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDEpO1xuICAgIGNvbnN0IHByb3RvY29sSWQgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgaWYgKHByb3RvY29sSWQgPT09IEdST1RIMTZfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRIZWFkZXJHcm90aDE2KGZkLCBzZWN0aW9ucywgdG9PYmplY3QsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xJZCA9PT0gUExPTktfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRIZWFkZXJQbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHByb3RvY29sSWQgPT09IEZGTE9OS19QUk9UT0NPTF9JRCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVhZEhlYWRlckZGbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm90b2NvbCBub3Qgc3VwcG9ydGVkOiBcIik7XG4gICAgfVxufVxuXG5cblxuXG5hc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyR3JvdGgxNihmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgemtleSA9IHt9O1xuXG4gICAgemtleS5wcm90b2NvbCA9IFwiZ3JvdGgxNlwiO1xuXG4gICAgLy8gUmVhZCBHcm90aCBIZWFkZXJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDIpO1xuICAgIGNvbnN0IG44cSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhxID0gbjhxO1xuICAgIHprZXkucSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCBuOHEpO1xuXG4gICAgY29uc3QgbjhyID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uOHIgPSBuOHI7XG4gICAgemtleS5yID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaWdJbnQoZmQsIG44cik7XG4gICAgemtleS5jdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSwgb3B0aW9ucyk7XG4gICAgemtleS5uVmFycyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkublB1YmxpYyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuZG9tYWluU2l6ZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkucG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG4gICAgemtleS52a19hbHBoYV8xID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS52a19iZXRhXzEgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LnZrX2JldGFfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfZ2FtbWFfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfZGVsdGFfMSA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfZGVsdGFfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICByZXR1cm4gemtleTtcblxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyUGxvbmsoZmQsIHNlY3Rpb25zLCB0b09iamVjdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHprZXkgPSB7fTtcblxuICAgIHprZXkucHJvdG9jb2wgPSBcInBsb25rXCI7XG5cbiAgICAvLyBSZWFkIFBsb25rIEhlYWRlclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMik7XG4gICAgY29uc3QgbjhxID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uOHEgPSBuOHE7XG4gICAgemtleS5xID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaWdJbnQoZmQsIG44cSk7XG5cbiAgICBjb25zdCBuOHIgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm44ciA9IG44cjtcbiAgICB6a2V5LnIgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpZ0ludChmZCwgbjhyKTtcbiAgICB6a2V5LmN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xLCBvcHRpb25zKTtcbiAgICB6a2V5Lm5WYXJzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uUHVibGljID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5kb21haW5TaXplID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5wb3dlciA9IGxvZzIoemtleS5kb21haW5TaXplKTtcbiAgICB6a2V5Lm5BZGRpdGlvbnMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm5Db25zdHJhaW50cyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuazEgPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS5rMiA9IGF3YWl0IGZkLnJlYWQobjhyKTtcblxuICAgIHprZXkuUW0gPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlFsID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5RciA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUW8gPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlFjID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5TMSA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUzIgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlMzID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5YXzIgPSBhd2FpdCByZWFkRzIoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICByZXR1cm4gemtleTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlckZGbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgemtleSA9IHt9O1xuXG4gICAgemtleS5wcm90b2NvbCA9IFwiZmZsb25rXCI7XG4gICAgemtleS5wcm90b2NvbElkID0gRkZMT05LX1BST1RPQ09MX0lEO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBaS0VZX0ZGX0hFQURFUl9TRUNUSU9OKTtcbiAgICBjb25zdCBuOHEgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm44cSA9IG44cTtcbiAgICB6a2V5LnEgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpZ0ludChmZCwgbjhxKTtcbiAgICB6a2V5LmN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IG44ciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhyID0gbjhyO1xuICAgIHprZXkuciA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCBuOHIpO1xuXG4gICAgemtleS5uVmFycyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkublB1YmxpYyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuZG9tYWluU2l6ZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkucG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG4gICAgemtleS5uQWRkaXRpb25zID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uQ29uc3RyYWludHMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcblxuICAgIHprZXkuazEgPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS5rMiA9IGF3YWl0IGZkLnJlYWQobjhyKTtcblxuICAgIHprZXkudzMgPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS53NCA9IGF3YWl0IGZkLnJlYWQobjhyKTtcbiAgICB6a2V5Lnc4ID0gYXdhaXQgZmQucmVhZChuOHIpO1xuICAgIHprZXkud3IgPSBhd2FpdCBmZC5yZWFkKG44cik7XG5cbiAgICB6a2V5LlhfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuXG4gICAgemtleS5DMCA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiB6a2V5O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZFpLZXkoZmlsZU5hbWUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3Qge2ZkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoZmlsZU5hbWUsIFwiemtleVwiLCAxKTtcblxuICAgIGNvbnN0IHprZXkgPSBhd2FpdCByZWFkSGVhZGVyKGZkLCBzZWN0aW9ucywgdG9PYmplY3QpO1xuXG4gICAgY29uc3QgRnIgPSBuZXcgRjFGaWVsZCh6a2V5LnIpO1xuICAgIGNvbnN0IFJyID0gU2NhbGFyLm1vZChTY2FsYXIuc2hsKDEsIHprZXkubjhyKjgpLCB6a2V5LnIpO1xuICAgIGNvbnN0IFJyaSA9IEZyLmludihScik7XG4gICAgY29uc3QgUnJpMiA9IEZyLm11bChScmksIFJyaSk7XG5cbiAgICBsZXQgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuXG4gICAgLy8gUmVhZCBJQyBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDMpO1xuICAgIHprZXkuSUMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBQID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgICAgICB6a2V5LklDLnB1c2goUCk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQ29lZnNcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgNCk7XG4gICAgY29uc3QgbkNDb2VmcyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuY2NvZWZzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5DQ29lZnM7IGkrKykge1xuICAgICAgICBjb25zdCBtID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgICAgIGNvbnN0IGMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICAgICAgY29uc3QgcyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgICAgICBjb25zdCB2ID0gYXdhaXQgcmVhZEZyMih0b09iamVjdCk7XG4gICAgICAgIHprZXkuY2NvZWZzLnB1c2goe1xuICAgICAgICAgICAgbWF0cml4OiBtLFxuICAgICAgICAgICAgY29uc3RyYWludDogYyxcbiAgICAgICAgICAgIHNpZ25hbDogcyxcbiAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgLy8gUmVhZCBBIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA1KTtcbiAgICB6a2V5LkEgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEEgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgICAgIHprZXkuQVtpXSA9IEE7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQjFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgNik7XG4gICAgemtleS5CMSA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgY29uc3QgQjEgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG5cbiAgICAgICAgemtleS5CMVtpXSA9IEIxO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBSZWFkIEIyIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA3KTtcbiAgICB6a2V5LkIyID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBjb25zdCBCMiA9IGF3YWl0IHJlYWRHMihmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICAgICAgemtleS5CMltpXSA9IEIyO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBSZWFkIEMgcG9pbnRzXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDgpO1xuICAgIHprZXkuQyA9IFtdO1xuICAgIGZvciAobGV0IGk9emtleS5uUHVibGljKzE7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEMgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG5cbiAgICAgICAgemtleS5DW2ldID0gQztcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gUmVhZCBIIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA5KTtcbiAgICB6a2V5LmhFeHBzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEggPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgICAgIHprZXkuaEV4cHMucHVzaChIKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gemtleTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRGcjIoLyogdG9PYmplY3QgKi8pIHtcbiAgICAgICAgY29uc3QgbiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCB6a2V5Lm44cik7XG4gICAgICAgIHJldHVybiBGci5tdWwobiwgUnJpMik7XG4gICAgfVxuXG59XG5cblxuYXN5bmMgZnVuY3Rpb24gcmVhZENvbnRyaWJ1dGlvbihmZCwgY3VydmUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3QgYyA9IHtkZWx0YTp7fX07XG4gICAgYy5kZWx0YUFmdGVyID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMuZGVsdGEuZzFfcyA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICBjLmRlbHRhLmcxX3N4ID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMuZGVsdGEuZzJfc3B4ID0gYXdhaXQgcmVhZEcyKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMudHJhbnNjcmlwdCA9IGF3YWl0IGZkLnJlYWQoNjQpO1xuICAgIGMudHlwZSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuXG4gICAgY29uc3QgcGFyYW1MZW5ndGggPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBjdXJQb3MgPSBmZC5wb3M7XG4gICAgbGV0IGxhc3RUeXBlID0wO1xuICAgIHdoaWxlIChmZC5wb3MtY3VyUG9zIDwgcGFyYW1MZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYnVmZlR5cGUgPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF08PSBsYXN0VHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVycyBpbiB0aGUgY29udHJpYnV0aW9uIG11c3QgYmUgc29ydGVkXCIpO1xuICAgICAgICBsYXN0VHlwZSA9IGJ1ZmZUeXBlWzBdO1xuICAgICAgICBpZiAoYnVmZlR5cGVbMF09PTEpIHsgICAgIC8vIE5hbWVcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMZW4gPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICAgICAgY29uc3QgYnVmZlN0ciA9IGF3YWl0IGZkLnJlYWQoYnVmZkxlblswXSk7XG4gICAgICAgICAgICBjLm5hbWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZlN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZlR5cGVbMF09PTIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZFeHAgPSBhd2FpdCBmZC5yZWFkKDEpO1xuICAgICAgICAgICAgYy5udW1JdGVyYXRpb25zRXhwID0gYnVmZkV4cFswXTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmVHlwZVswXT09Mykge1xuICAgICAgICAgICAgY29uc3QgYnVmZkxlbiA9IGF3YWl0IGZkLnJlYWQoMSk7XG4gICAgICAgICAgICBjLmJlYWNvbkhhc2ggPSBhd2FpdCBmZC5yZWFkKGJ1ZmZMZW5bMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG5vdCByZWNvZ25pemVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmZC5wb3MgIT0gY3VyUG9zICsgcGFyYW1MZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVycyBkbyBub3QgbWF0Y2hcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGM7XG59XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRNUENQYXJhbXMoZmQsIGN1cnZlLCBzZWN0aW9ucykge1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMTApO1xuICAgIGNvbnN0IHJlcyA9IHsgY29udHJpYnV0aW9uczogW119O1xuICAgIHJlcy5jc0hhc2ggPSBhd2FpdCBmZC5yZWFkKDY0KTtcbiAgICBjb25zdCBuID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPG47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbihmZCwgY3VydmUpO1xuICAgICAgICByZXMuY29udHJpYnV0aW9ucy5wdXNoKGMpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVDb250cmlidXRpb24oZmQsIGN1cnZlLCBjKSB7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIGMuZGVsdGFBZnRlcik7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIGMuZGVsdGEuZzFfcyk7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIGMuZGVsdGEuZzFfc3gpO1xuICAgIGF3YWl0IHdyaXRlRzIoZmQsIGN1cnZlLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgYXdhaXQgZmQud3JpdGUoYy50cmFuc2NyaXB0KTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGMudHlwZSB8fCAwKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGlmIChjLm5hbWUpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goMSk7ICAgICAgLy8gUGFyYW0gTmFtZVxuICAgICAgICBjb25zdCBuYW1lRGF0YSA9IG5ldyBUZXh0RW5jb2RlcihcInV0Zi04XCIpLmVuY29kZShjLm5hbWUuc3Vic3RyaW5nKDAsNjQpKTtcbiAgICAgICAgcGFyYW1zLnB1c2gobmFtZURhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuYW1lRGF0YS5ieXRlTGVuZ3RoOyBpKyspIHBhcmFtcy5wdXNoKG5hbWVEYXRhW2ldKTtcbiAgICB9XG4gICAgaWYgKGMudHlwZSA9PSAxKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKDIpOyAgICAgIC8vIFBhcmFtIG51bUl0ZXJhdGlvbnNFeHBcbiAgICAgICAgcGFyYW1zLnB1c2goYy5udW1JdGVyYXRpb25zRXhwKTtcblxuICAgICAgICBwYXJhbXMucHVzaCgzKTsgICAgICAvLyBCZWFjb24gSGFzaFxuICAgICAgICBwYXJhbXMucHVzaChjLmJlYWNvbkhhc2guYnl0ZUxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjLmJlYWNvbkhhc2guYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChjLmJlYWNvbkhhc2hbaV0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxlbmd0aD4wKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc0J1ZmYgPSBuZXcgVWludDhBcnJheShwYXJhbXMpO1xuICAgICAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHBhcmFtc0J1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlKHBhcmFtc0J1ZmYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoMCk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZU1QQ1BhcmFtcyhmZCwgY3VydmUsIG1wY1BhcmFtcykge1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMTApO1xuICAgIGF3YWl0IGZkLndyaXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVDb250cmlidXRpb24oZmQsIGN1cnZlLG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNoRzEoaGFzaGVyLCBjdXJ2ZSwgcCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIpO1xuICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDAsIHApO1xuICAgIGhhc2hlci51cGRhdGUoYnVmZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNoRzIoaGFzaGVyLGN1cnZlLCBwKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcyLkYubjgqMik7XG4gICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgcCk7XG4gICAgaGFzaGVyLnVwZGF0ZShidWZmKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hQdWJLZXkoaGFzaGVyLCBjdXJ2ZSwgYykge1xuICAgIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBjLmRlbHRhQWZ0ZXIpO1xuICAgIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcxX3MpO1xuICAgIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcxX3N4KTtcbiAgICBoYXNoRzIoaGFzaGVyLCBjdXJ2ZSwgYy5kZWx0YS5nMl9zcHgpO1xuICAgIGhhc2hlci51cGRhdGUoYy50cmFuc2NyaXB0KTtcbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_verify_frominit.js":
/*!**********************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_verify_frominit.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2verifyFromInit)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/blake2b */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/./node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/snarkjs/node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst sameRatio = _misc_js__WEBPACK_IMPORTED_MODULE_3__.sameRatio;\n\n\n\n\n\nasync function phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger) {\n\n    let sr;\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fd, sections, false);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fd, curve, sections);\n\n    const accumulatedHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });\n    accumulatedHasher.update(mpcParams.csHash);\n    let curDelta = curve.G1.g;\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        const ourHasher = _misc_js__WEBPACK_IMPORTED_MODULE_3__.cloneHasher(accumulatedHasher);\n\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1)(ourHasher, curve, c.delta.g1_s);\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1)(ourHasher, curve, c.delta.g1_sx);\n\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_3__.hashIsEqual(ourHasher.digest(), c.transcript)) {\n            console.log(`INVALID(${i}): Inconsistent transcript `);\n            return false;\n        }\n\n        const delta_g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_4__.hashToG2)(curve, c.transcript);\n\n        sr = await sameRatio(curve, c.delta.g1_s, c.delta.g1_sx, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): public key G1 and G2 do not have the same ration `);\n            return false;\n        }\n\n        sr = await sameRatio(curve, curDelta, c.deltaAfter, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): deltaAfter does not fillow the public key `);\n            return false;\n        }\n\n        if (c.type == 1) {\n            const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.rngFromBeaconParams(c.beaconHash, c.numIterationsExp);\n            const expected_prvKey = curve.Fr.fromRng(rng);\n            const expected_g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n            const expected_g1_sx = curve.G1.toAffine(curve.G1.timesFr(expected_g1_s, expected_prvKey));\n            if (curve.G1.eq(expected_g1_s, c.delta.g1_s) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_s `);\n                return false;\n            }\n            if (curve.G1.eq(expected_g1_sx, c.delta.g1_sx) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_sx `);\n                return false;\n            }\n        }\n\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(accumulatedHasher, curve, c);\n\n        const contributionHasher = _noble_hashes_blake2b__WEBPACK_IMPORTED_MODULE_6__.blake2b.create({ dkLen: 64 });\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(contributionHasher, curve, c);\n\n        c.contributionHash = contributionHasher.digest();\n\n        curDelta = c.deltaAfter;\n    }\n\n\n    const {fd: fdInit, sections: sectionsInit} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(initFileName, \"zkey\", 2);\n    const zkeyInit = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdInit, sectionsInit, false);\n\n    if (zkeyInit.protocol != \"groth16\") {\n        throw new Error(\"zkeyinit file is not groth16\");\n    }\n\n    if (  (!ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.eq(zkeyInit.q, zkey.q))\n        ||(!ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.eq(zkeyInit.r, zkey.r))\n        ||(zkeyInit.n8q != zkey.n8q)\n        ||(zkeyInit.n8r != zkey.n8r))\n    {\n        if (logger) logger.error(\"INVALID:  Different curves\");\n        return false;\n    }\n\n    if (  (zkeyInit.nVars != zkey.nVars)\n        ||(zkeyInit.nPublic !=  zkey.nPublic)\n        ||(zkeyInit.domainSize != zkey.domainSize))\n    {\n        if (logger) logger.error(\"INVALID:  Different circuit parameters\");\n        return false;\n    }\n\n    if (!curve.G1.eq(zkey.vk_alpha_1, zkeyInit.vk_alpha_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid alpha1\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_beta_1, zkeyInit.vk_beta_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta1\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_beta_2, zkeyInit.vk_beta_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta2\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_gamma_2, zkeyInit.vk_gamma_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid gamma2\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_delta_1, curDelta)) {\n        if (logger) logger.error(\"INVALID:  Invalid delta1\");\n        return false;\n    }\n    sr = await sameRatio(curve, curve.G1.g, curDelta, curve.G2.g, zkey.vk_delta_2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID:  Invalid delta2\");\n        return false;\n    }\n\n    const mpcParamsInit = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdInit, curve, sectionsInit);\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_3__.hashIsEqual(mpcParams.csHash, mpcParamsInit.csHash)) {\n        if (logger) logger.error(\"INVALID:  Circuit does not match\");\n        return false;\n    }\n\n    // Check sizes of sections\n    if (sections[8][0].size != sG1*(zkey.nVars-zkey.nPublic-1)) {\n        if (logger) logger.error(\"INVALID:  Invalid L section size\");\n        return false;\n    }\n\n    if (sections[9][0].size != sG1*(zkey.domainSize)) {\n        if (logger) logger.error(\"INVALID:  Invalid H section size\");\n        return false;\n    }\n\n    let ss;\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 3);\n    if (!ss) {\n        if (logger) logger.error(\"INVALID:  IC section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 4);\n    if (!ss) {\n        if (logger) logger.error(\"Coeffs section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 5);\n    if (!ss) {\n        if (logger) logger.error(\"A section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 6);\n    if (!ss) {\n        if (logger) logger.error(\"B1 section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 7);\n    if (!ss) {\n        if (logger) logger.error(\"B2 section is not identical\");\n        return false;\n    }\n\n    // Check L\n    sr = await sectionHasSameRatio(\"G1\", fdInit, sectionsInit, fd, sections, 8, zkey.vk_delta_2, zkeyInit.vk_delta_2, \"L section\");\n    if (sr!==true) {\n        if (logger) logger.error(\"L section does not match\");\n        return false;\n    }\n\n    // Check H\n    sr = await sameRatioH();\n    if (sr!==true) {\n        if (logger) logger.error(\"H section does not match\");\n        return false;\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n\n    await fd.close();\n    await fdInit.close();\n\n    for (let i=mpcParams.contributions.length-1; i>=0; i--) {\n        const c = mpcParams.contributions[i];\n        if (logger) logger.info(\"-------------------------\");\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(c.contributionHash, `contribution #${i+1} ${c.name ? c.name : \"\"}:`));\n        if (c.type == 1) {\n            if (logger) logger.info(`Beacon generator: ${_misc_js__WEBPACK_IMPORTED_MODULE_3__.byteArray2hex(c.beaconHash)}`);\n            if (logger) logger.info(`Beacon iterations Exp: ${c.numIterationsExp}`);\n        }\n    }\n    if (logger) logger.info(\"-------------------------\");\n\n    if (logger) logger.info(\"ZKey Ok!\");\n\n    return true;\n\n\n    async function sectionHasSameRatio(groupName, fd1, sections1, fd2, sections2, idSection, g2sp, g2spx, sectionName) {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd1, sections1, idSection);\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd2, sections2, idSection);\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        const nPoints = sections1[idSection][0].size / sG;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`Same ratio check ${sectionName}:  ${i}/${nPoints}`);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases1 = await fd1.read(n*sG);\n            const bases2 = await fd2.read(n*sG);\n\n            const scalars = _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomBytes(4*n);\n\n            const r1 = await G.multiExpAffine(bases1, scalars);\n            const r2 = await G.multiExpAffine(bases2, scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd1);\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd2);\n\n        if (nPoints == 0) return true;\n\n        sr = await sameRatio(curve, R1, R2, g2sp, g2spx);\n        if (sr !== true) return false;\n\n        return true;\n    }\n\n    async function sameRatioH() {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve.G1;\n        const Fr = curve.Fr;\n        const sG = G.F.n8*2;\n\n        const {fd: fdPTau, sections: sectionsPTau} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(pTauFileName, \"ptau\", 1);\n\n        let buff_r = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * zkey.n8r);\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = _misc_js__WEBPACK_IMPORTED_MODULE_3__.readUInt32BE(_misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomBytes(4), 0);\n        }\n        const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.ChaCha(seed);\n        for (let i=0; i<zkey.domainSize-1; i++) {   // Note that last one is zero\n            const e = Fr.fromRng(rng);\n            Fr.toRprLE(buff_r, i*zkey.n8r, e);\n        }\n        Fr.toRprLE(buff_r, (zkey.domainSize-1)*zkey.n8r, Fr.zero);\n\n        let R1 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(tau):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff1 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + zkey.domainSize*sG + i*sG);\n            const buff2 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + i*sG);\n\n            const buffB = await batchSubtract(buff1, buff2);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buffB, buffS);\n\n            R1 = G.add(R1, r);\n        }\n\n        // Calculate odd coefficients in transformed domain\n\n        buff_r = await Fr.batchToMontgomery(buff_r);\n        // const first = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n        // Works*2   const first = curve.Fr.neg(curve.Fr.e(2));\n\n\n        let first;\n\n        if (zkey.power < Fr.s) {\n            first = Fr.neg(Fr.e(2));\n        } else {\n            const small_m  = 2 ** Fr.s;\n            const shift_to_small_m = Fr.exp(Fr.shift, small_m);\n            first = Fr.sub( shift_to_small_m, Fr.one);\n        }\n\n        // const inc = curve.Fr.inv(curve.PFr.w[zkey.power+1]);\n        const inc = zkey.power < Fr.s ? Fr.w[zkey.power+1] : Fr.shift;\n        buff_r = await Fr.batchApplyKey(buff_r, first, inc);\n        buff_r = await Fr.fft(buff_r);\n        buff_r = await Fr.batchFromMontgomery(buff_r);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd, sections, 9);\n        let R2 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(lagrange):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff = await fd.read(sG*n);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buff, buffS);\n\n            R2 = G.add(R2, r);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd);\n\n        sr = await sameRatio(curve, R1, R2, zkey.vk_delta_2, zkeyInit.vk_delta_2);\n        if (sr !== true) return false;\n\n\n        return true;\n\n    }\n\n    async function batchSubtract(buff1, buff2) {\n        const sG = curve.G1.F.n8*2;\n        const nPoints = buff1.byteLength / sG;\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(batchSubtractThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        const fullBuffOut = new Uint8Array(nPoints*sG);\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    }\n\n\n    async function batchSubtractThread(buff1, buff2) {\n        const sG1 = curve.G1.F.n8*2;\n        const sGmid = curve.G1.F.n8*3;\n        const nPoints = buff1.byteLength/sG1;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV92ZXJpZnlfZnJvbWluaXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDtBQUNQO0FBQ1c7QUFDUjtBQUNkO0FBQ2tCO0FBQ3BELGtCQUFrQiwrQ0FBYztBQUNtQjtBQUNNOzs7O0FBSTFDOztBQUVmO0FBQ0EsV0FBVyxjQUFjLFFBQVEsNERBQXdCO0FBQ3pELHVCQUF1QixzREFBb0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix5REFBUTtBQUNoQzs7QUFFQSw0QkFBNEIseURBQXVCOztBQUVuRCw4QkFBOEIsMERBQU8sVUFBVSxXQUFXO0FBQzFEO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BEO0FBQ0EsMEJBQTBCLGlEQUFnQjs7QUFFMUMsUUFBUSxzREFBTTtBQUNkLFFBQVEsc0RBQU07O0FBRWQsYUFBYSxpREFBZ0I7QUFDN0IsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTs7QUFFQSw0QkFBNEIscURBQVE7O0FBRXBDO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRTtBQUNyQztBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHlEQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLDBEQUFVOztBQUVsQixtQ0FBbUMsMERBQU8sVUFBVSxXQUFXO0FBQy9ELFFBQVEsMERBQVU7O0FBRWxCOztBQUVBO0FBQ0E7OztBQUdBLFdBQVcsb0NBQW9DLFFBQVEsNERBQXdCO0FBQy9FLDJCQUEyQixzREFBb0I7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGdEQUFNO0FBQ2xCLFlBQVksZ0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyx5REFBdUI7QUFDdkQsU0FBUyxpREFBZ0I7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0M7QUFDQTs7QUFFQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFlLHNDQUFzQyxLQUFLLEVBQUUscUJBQXFCO0FBQ2pIO0FBQ0EseURBQXlELG1EQUFrQixlQUFlO0FBQzFGLDhEQUE4RCxtQkFBbUI7QUFDakY7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUVBQW1DO0FBQ2pELGNBQWMsdUVBQW1DOztBQUVqRDtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixXQUFXO0FBQ2pDLHlEQUF5RCxZQUFZLEtBQUssRUFBRSxHQUFHLFFBQVE7QUFDdkY7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixvREFBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBMkI7QUFDekMsY0FBYywrREFBMkI7O0FBRXpDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsb0NBQW9DLFFBQVEsNERBQXdCOztBQUVuRix5QkFBeUIsbURBQVM7O0FBRWxDO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0Isc0JBQXNCLGtEQUFpQixDQUFDLG9EQUFtQjtBQUMzRDtBQUNBLHdCQUF3QixnREFBTTtBQUM5QixzQkFBc0IscUJBQXFCLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLDhEQUE4RCxFQUFFLEdBQUcsZ0JBQWdCO0FBQ25GOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1RUFBbUM7QUFDakQ7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLG1FQUFtRSxFQUFFLEdBQUcsZ0JBQWdCO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYywrREFBMkI7O0FBRXpDO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RCxtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQix5Q0FBeUM7QUFDNUQsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDLHFCQUFxQixzQkFBc0I7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsT0FBTztBQUNwQixVQUFVO0FBQ1YsbUJBQW1CLDZDQUE2Qzs7QUFFaEU7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X3ZlcmlmeV9mcm9taW5pdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHprZXlVdGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21RIGFzIGdldEN1cnZlIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgeyBibGFrZTJiIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvYmxha2UyYlwiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBoYXNoVG9HMiBhcyBoYXNoVG9HMiB9IGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmNvbnN0IHNhbWVSYXRpbyA9IG1pc2Muc2FtZVJhdGlvO1xuaW1wb3J0IHtoYXNoRzEsIGhhc2hQdWJLZXl9IGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IFNjYWxhciwgQ2hhQ2hhLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwaGFzZTJ2ZXJpZnlGcm9tSW5pdChpbml0RmlsZU5hbWUsIHBUYXVGaWxlTmFtZSwgemtleUZpbGVOYW1lLCBsb2dnZXIpIHtcblxuICAgIGxldCBzcjtcbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmQsIHNlY3Rpb25zLCBmYWxzZSk7XG4gICAgaWYgKHprZXkucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG5cbiAgICBjb25zdCBtcGNQYXJhbXMgPSBhd2FpdCB6a2V5VXRpbHMucmVhZE1QQ1BhcmFtcyhmZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGFjY3VtdWxhdGVkSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgYWNjdW11bGF0ZWRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGxldCBjdXJEZWx0YSA9IGN1cnZlLkcxLmc7XG4gICAgZm9yIChsZXQgaT0wOyBpPG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXTtcbiAgICAgICAgY29uc3Qgb3VySGFzaGVyID0gbWlzYy5jbG9uZUhhc2hlcihhY2N1bXVsYXRlZEhhc2hlcik7XG5cbiAgICAgICAgaGFzaEcxKG91ckhhc2hlciwgY3VydmUsIGMuZGVsdGEuZzFfcyk7XG4gICAgICAgIGhhc2hHMShvdXJIYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcxX3N4KTtcblxuICAgICAgICBpZiAoIW1pc2MuaGFzaElzRXF1YWwob3VySGFzaGVyLmRpZ2VzdCgpLCBjLnRyYW5zY3JpcHQpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgSU5WQUxJRCgke2l9KTogSW5jb25zaXN0ZW50IHRyYW5zY3JpcHQgYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWx0YV9nMl9zcCA9IGhhc2hUb0cyKGN1cnZlLCBjLnRyYW5zY3JpcHQpO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjLmRlbHRhLmcxX3MsIGMuZGVsdGEuZzFfc3gsIGRlbHRhX2cyX3NwLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYElOVkFMSUQoJHtpfSk6IHB1YmxpYyBrZXkgRzEgYW5kIEcyIGRvIG5vdCBoYXZlIHRoZSBzYW1lIHJhdGlvbiBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJEZWx0YSwgYy5kZWx0YUFmdGVyLCBkZWx0YV9nMl9zcCwgYy5kZWx0YS5nMl9zcHgpO1xuICAgICAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJTlZBTElEKCR7aX0pOiBkZWx0YUFmdGVyIGRvZXMgbm90IGZpbGxvdyB0aGUgcHVibGljIGtleSBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjLnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5ybmdGcm9tQmVhY29uUGFyYW1zKGMuYmVhY29uSGFzaCwgYy5udW1JdGVyYXRpb25zRXhwKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkX3BydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkX2cxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRfZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGV4cGVjdGVkX2cxX3MsIGV4cGVjdGVkX3BydktleSkpO1xuICAgICAgICAgICAgaWYgKGN1cnZlLkcxLmVxKGV4cGVjdGVkX2cxX3MsIGMuZGVsdGEuZzFfcykgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSU5WQUxJRCgke2l9KTogS2V5IG9mIHRoZSBiZWFjb24gZG9lcyBub3QgbWF0Y2guIGcxX3MgYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnZlLkcxLmVxKGV4cGVjdGVkX2cxX3N4LCBjLmRlbHRhLmcxX3N4KSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJTlZBTElEKCR7aX0pOiBLZXkgb2YgdGhlIGJlYWNvbiBkb2VzIG5vdCBtYXRjaC4gZzFfc3ggYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaGFzaFB1YktleShhY2N1bXVsYXRlZEhhc2hlciwgY3VydmUsIGMpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgICAgICBoYXNoUHViS2V5KGNvbnRyaWJ1dGlvbkhhc2hlciwgY3VydmUsIGMpO1xuXG4gICAgICAgIGMuY29udHJpYnV0aW9uSGFzaCA9IGNvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgICAgICBjdXJEZWx0YSA9IGMuZGVsdGFBZnRlcjtcbiAgICB9XG5cblxuICAgIGNvbnN0IHtmZDogZmRJbml0LCBzZWN0aW9uczogc2VjdGlvbnNJbml0fSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShpbml0RmlsZU5hbWUsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5SW5pdCA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkSW5pdCwgc2VjdGlvbnNJbml0LCBmYWxzZSk7XG5cbiAgICBpZiAoemtleUluaXQucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleWluaXQgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cbiAgICBpZiAoICAoIVNjYWxhci5lcSh6a2V5SW5pdC5xLCB6a2V5LnEpKVxuICAgICAgICB8fCghU2NhbGFyLmVxKHprZXlJbml0LnIsIHprZXkucikpXG4gICAgICAgIHx8KHprZXlJbml0Lm44cSAhPSB6a2V5Lm44cSlcbiAgICAgICAgfHwoemtleUluaXQubjhyICE9IHprZXkubjhyKSlcbiAgICB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBEaWZmZXJlbnQgY3VydmVzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCAgKHprZXlJbml0Lm5WYXJzICE9IHprZXkublZhcnMpXG4gICAgICAgIHx8KHprZXlJbml0Lm5QdWJsaWMgIT0gIHprZXkublB1YmxpYylcbiAgICAgICAgfHwoemtleUluaXQuZG9tYWluU2l6ZSAhPSB6a2V5LmRvbWFpblNpemUpKVxuICAgIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIERpZmZlcmVudCBjaXJjdWl0IHBhcmFtZXRlcnNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWN1cnZlLkcxLmVxKHprZXkudmtfYWxwaGFfMSwgemtleUluaXQudmtfYWxwaGFfMSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgYWxwaGExXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoemtleS52a19iZXRhXzEsIHprZXlJbml0LnZrX2JldGFfMSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgYmV0YTFcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMi5lcSh6a2V5LnZrX2JldGFfMiwgemtleUluaXQudmtfYmV0YV8yKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBiZXRhMlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKHprZXkudmtfZ2FtbWFfMiwgemtleUluaXQudmtfZ2FtbWFfMikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZ2FtbWEyXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoemtleS52a19kZWx0YV8xLCBjdXJEZWx0YSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZGVsdGExXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJ2ZS5HMS5nLCBjdXJEZWx0YSwgY3VydmUuRzIuZywgemtleS52a19kZWx0YV8yKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZGVsdGEyXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbXBjUGFyYW1zSW5pdCA9IGF3YWl0IHprZXlVdGlscy5yZWFkTVBDUGFyYW1zKGZkSW5pdCwgY3VydmUsIHNlY3Rpb25zSW5pdCk7XG4gICAgaWYgKCFtaXNjLmhhc2hJc0VxdWFsKG1wY1BhcmFtcy5jc0hhc2gsIG1wY1BhcmFtc0luaXQuY3NIYXNoKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgQ2lyY3VpdCBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHNpemVzIG9mIHNlY3Rpb25zXG4gICAgaWYgKHNlY3Rpb25zWzhdWzBdLnNpemUgIT0gc0cxKih6a2V5Lm5WYXJzLXprZXkublB1YmxpYy0xKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBMIHNlY3Rpb24gc2l6ZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzZWN0aW9uc1s5XVswXS5zaXplICE9IHNHMSooemtleS5kb21haW5TaXplKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBIIHNlY3Rpb24gc2l6ZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBzcztcbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCAzKTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJQyBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA0KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkNvZWZmcyBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA1KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkEgc2VjdGlvbiBpcyBub3QgaWRlbnRpY2FsXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMuc2VjdGlvbklzRXF1YWwoZmQsIHNlY3Rpb25zLCBmZEluaXQsIHNlY3Rpb25zSW5pdCwgNik7XG4gICAgaWYgKCFzcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJCMSBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA3KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkIyIHNlY3Rpb24gaXMgbm90IGlkZW50aWNhbFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIExcbiAgICBzciA9IGF3YWl0IHNlY3Rpb25IYXNTYW1lUmF0aW8oXCJHMVwiLCBmZEluaXQsIHNlY3Rpb25zSW5pdCwgZmQsIHNlY3Rpb25zLCA4LCB6a2V5LnZrX2RlbHRhXzIsIHprZXlJbml0LnZrX2RlbHRhXzIsIFwiTCBzZWN0aW9uXCIpO1xuICAgIGlmIChzciE9PXRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiTCBzZWN0aW9uIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgSFxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvSCgpO1xuICAgIGlmIChzciE9PXRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSCBzZWN0aW9uIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKG1wY1BhcmFtcy5jc0hhc2gsIFwiQ2lyY3VpdCBIYXNoOiBcIikpO1xuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZEluaXQuY2xvc2UoKTtcblxuICAgIGZvciAobGV0IGk9bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICBjb25zdCBjID0gbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV07XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGMuY29udHJpYnV0aW9uSGFzaCwgYGNvbnRyaWJ1dGlvbiAjJHtpKzF9ICR7Yy5uYW1lID8gYy5uYW1lIDogXCJcIn06YCkpO1xuICAgICAgICBpZiAoYy50eXBlID09IDEpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGBCZWFjb24gZ2VuZXJhdG9yOiAke21pc2MuYnl0ZUFycmF5MmhleChjLmJlYWNvbkhhc2gpfWApO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYEJlYWNvbiBpdGVyYXRpb25zIEV4cDogJHtjLm51bUl0ZXJhdGlvbnNFeHB9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJaS2V5IE9rIVwiKTtcblxuICAgIHJldHVybiB0cnVlO1xuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBzZWN0aW9uSGFzU2FtZVJhdGlvKGdyb3VwTmFtZSwgZmQxLCBzZWN0aW9uczEsIGZkMiwgc2VjdGlvbnMyLCBpZFNlY3Rpb24sIGcyc3AsIGcyc3B4LCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDE8PDIwO1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQxLCBzZWN0aW9uczEsIGlkU2VjdGlvbik7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkMiwgc2VjdGlvbnMyLCBpZFNlY3Rpb24pO1xuXG4gICAgICAgIGxldCBSMSA9IEcuemVybztcbiAgICAgICAgbGV0IFIyID0gRy56ZXJvO1xuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBzZWN0aW9uczFbaWRTZWN0aW9uXVswXS5zaXplIC8gc0c7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgU2FtZSByYXRpbyBjaGVjayAke3NlY3Rpb25OYW1lfTogICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMgLSBpLCBNQVhfQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBjb25zdCBiYXNlczEgPSBhd2FpdCBmZDEucmVhZChuKnNHKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzMiA9IGF3YWl0IGZkMi5yZWFkKG4qc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsYXJzID0gbWlzYy5nZXRSYW5kb21CeXRlcyg0Km4pO1xuXG4gICAgICAgICAgICBjb25zdCByMSA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYmFzZXMxLCBzY2FsYXJzKTtcbiAgICAgICAgICAgIGNvbnN0IHIyID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiYXNlczIsIHNjYWxhcnMpO1xuXG4gICAgICAgICAgICBSMSA9IEcuYWRkKFIxLCByMSk7XG4gICAgICAgICAgICBSMiA9IEcuYWRkKFIyLCByMik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkMSk7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZDIpO1xuXG4gICAgICAgIGlmIChuUG9pbnRzID09IDApIHJldHVybiB0cnVlO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBSMSwgUjIsIGcyc3AsIGcyc3B4KTtcbiAgICAgICAgaWYgKHNyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gc2FtZVJhdGlvSCgpIHtcbiAgICAgICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxPDwyMDtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlLkcxO1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHtmZDogZmRQVGF1LCBzZWN0aW9uczogc2VjdGlvbnNQVGF1fSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShwVGF1RmlsZU5hbWUsIFwicHRhdVwiLCAxKTtcblxuICAgICAgICBsZXQgYnVmZl9yID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiB6a2V5Lm44cik7XG5cbiAgICAgICAgY29uc3Qgc2VlZD0gbmV3IEFycmF5KDgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgICAgICBzZWVkW2ldID0gbWlzYy5yZWFkVUludDMyQkUobWlzYy5nZXRSYW5kb21CeXRlcyg0KSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm5nID0gbmV3IENoYUNoYShzZWVkKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZS0xOyBpKyspIHsgICAvLyBOb3RlIHRoYXQgbGFzdCBvbmUgaXMgemVyb1xuICAgICAgICAgICAgY29uc3QgZSA9IEZyLmZyb21Sbmcocm5nKTtcbiAgICAgICAgICAgIEZyLnRvUnByTEUoYnVmZl9yLCBpKnprZXkubjhyLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBGci50b1JwckxFKGJ1ZmZfciwgKHprZXkuZG9tYWluU2l6ZS0xKSp6a2V5Lm44ciwgRnIuemVybyk7XG5cbiAgICAgICAgbGV0IFIxID0gRy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEggVmVyaWZpY2F0aW9uKHRhdSk6ICAke2l9LyR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKHprZXkuZG9tYWluU2l6ZSAtIGksIE1BWF9DSFVOS19TSVpFKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZjEgPSBhd2FpdCBmZFBUYXUucmVhZChzRypuLCBzZWN0aW9uc1BUYXVbMl1bMF0ucCArIHprZXkuZG9tYWluU2l6ZSpzRyArIGkqc0cpO1xuICAgICAgICAgICAgY29uc3QgYnVmZjIgPSBhd2FpdCBmZFBUYXUucmVhZChzRypuLCBzZWN0aW9uc1BUYXVbMl1bMF0ucCArIGkqc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmQiA9IGF3YWl0IGJhdGNoU3VidHJhY3QoYnVmZjEsIGJ1ZmYyKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZTID0gYnVmZl9yLnNsaWNlKGkqemtleS5uOHIsIChpK24pKnprZXkubjhyKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJ1ZmZCLCBidWZmUyk7XG5cbiAgICAgICAgICAgIFIxID0gRy5hZGQoUjEsIHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG9kZCBjb2VmZmljaWVudHMgaW4gdHJhbnNmb3JtZWQgZG9tYWluXG5cbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZl9yKTtcbiAgICAgICAgLy8gY29uc3QgZmlyc3QgPSBjdXJ2ZS5Gci5uZWcoY3VydmUuRnIuaW52KGN1cnZlLkZyLmUoMikpKTtcbiAgICAgICAgLy8gV29ya3MqMiAgIGNvbnN0IGZpcnN0ID0gY3VydmUuRnIubmVnKGN1cnZlLkZyLmUoMikpO1xuXG5cbiAgICAgICAgbGV0IGZpcnN0O1xuXG4gICAgICAgIGlmICh6a2V5LnBvd2VyIDwgRnIucykge1xuICAgICAgICAgICAgZmlyc3QgPSBGci5uZWcoRnIuZSgyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzbWFsbF9tICA9IDIgKiogRnIucztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0X3RvX3NtYWxsX20gPSBGci5leHAoRnIuc2hpZnQsIHNtYWxsX20pO1xuICAgICAgICAgICAgZmlyc3QgPSBGci5zdWIoIHNoaWZ0X3RvX3NtYWxsX20sIEZyLm9uZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zdCBpbmMgPSBjdXJ2ZS5Gci5pbnYoY3VydmUuUEZyLndbemtleS5wb3dlcisxXSk7XG4gICAgICAgIGNvbnN0IGluYyA9IHprZXkucG93ZXIgPCBGci5zID8gRnIud1t6a2V5LnBvd2VyKzFdIDogRnIuc2hpZnQ7XG4gICAgICAgIGJ1ZmZfciA9IGF3YWl0IEZyLmJhdGNoQXBwbHlLZXkoYnVmZl9yLCBmaXJzdCwgaW5jKTtcbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuZmZ0KGJ1ZmZfcik7XG4gICAgICAgIGJ1ZmZfciA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoYnVmZl9yKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDkpO1xuICAgICAgICBsZXQgUjIgPSBHLnplcm87XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemU7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSCBWZXJpZmljYXRpb24obGFncmFuZ2UpOiAgJHtpfS8ke3prZXkuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbih6a2V5LmRvbWFpblNpemUgLSBpLCBNQVhfQ0hVTktfU0laRSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKHNHKm4pO1xuICAgICAgICAgICAgY29uc3QgYnVmZlMgPSBidWZmX3Iuc2xpY2UoaSp6a2V5Lm44ciwgKGkrbikqemtleS5uOHIpO1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZiwgYnVmZlMpO1xuXG4gICAgICAgICAgICBSMiA9IEcuYWRkKFIyLCByKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBSMSwgUjIsIHprZXkudmtfZGVsdGFfMiwgemtleUluaXQudmtfZGVsdGFfMik7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBiYXRjaFN1YnRyYWN0KGJ1ZmYxLCBidWZmMikge1xuICAgICAgICBjb25zdCBzRyA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGggLyBzRztcbiAgICAgICAgY29uc3QgY29uY3VycmVuY3k9IGN1cnZlLnRtLmNvbmN1cnJlbmN5O1xuICAgICAgICBjb25zdCBuUG9pbnRzUGVyVGhyZWFkID0gTWF0aC5mbG9vcihuUG9pbnRzIC8gY29uY3VycmVuY3kpO1xuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGlmIChpPCBjb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHNQZXJUaHJlYWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzIC0gaSpuUG9pbnRzUGVyVGhyZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBzdWJCdWZmMSA9IGJ1ZmYxLnNsaWNlKGkqblBvaW50c1BlclRocmVhZCpzRzEsIChpKm5Qb2ludHNQZXJUaHJlYWQrbikqc0cxKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YkJ1ZmYyID0gYnVmZjIuc2xpY2UoaSpuUG9pbnRzUGVyVGhyZWFkKnNHMSwgKGkqblBvaW50c1BlclRocmVhZCtuKSpzRzEpO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKGJhdGNoU3VidHJhY3RUaHJlYWQoc3ViQnVmZjEsIHN1YkJ1ZmYyKSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGNvbnN0IGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzRyk7XG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dC5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bGxCdWZmT3V0O1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gYmF0Y2hTdWJ0cmFjdFRocmVhZChidWZmMSwgYnVmZjIpIHtcbiAgICAgICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgICAgICBjb25zdCBzR21pZCA9IGN1cnZlLkcxLkYubjgqMztcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGgvc0cxO1xuICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYnVmZjF9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBidWZmMn0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDIsIGxlbjogblBvaW50cypzR21pZH0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICB0YXNrLnB1c2goe1xuICAgICAgICAgICAgICAgIGNtZDogXCJDQUxMXCIsXG4gICAgICAgICAgICAgICAgZm5OYW1lOiBcImcxbV9zdWJBZmZpbmVcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMCwgb2Zmc2V0OiBpKnNHMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogaSpzRzF9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAyLCBvZmZzZXQ6IGkqc0dtaWR9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcImcxbV9iYXRjaFRvQWZmaW5lXCIsIHBhcmFtczogW1xuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICB7dmFsOiBuUG9pbnRzfSxcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBuUG9pbnRzKnNHMX0pO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG59XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_verify_frominit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/snarkjs/src/zkey_verify_fromr1cs.js":
/*!**********************************************************!*\
  !*** ./node_modules/snarkjs/src/zkey_verify_fromr1cs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2verifyFromR1cs)\n/* harmony export */ });\n/* harmony import */ var _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_new.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_new.js\");\n/* harmony import */ var _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_verify_frominit.js */ \"(ssr)/./node_modules/snarkjs/src/zkey_verify_frominit.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nasync function phase2verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger) {\n\n    // const initFileName = \"~\" + zkeyFileName + \".init\";\n    const initFileName = {type: \"bigMem\"};\n    await (0,_zkey_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(r1csFileName, pTauFileName, initFileName, logger);\n\n    return await (0,_zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(initFileName, pTauFileName, zkeyFileName, logger);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV92ZXJpZnlfZnJvbXIxY3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDeUI7O0FBRTlDOztBQUVmO0FBQ0EsMEJBQTBCO0FBQzFCLFVBQVUsd0RBQU87O0FBRWpCLGlCQUFpQixvRUFBb0I7QUFDckMiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV92ZXJpZnlfZnJvbXIxY3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IG5ld1pLZXkgZnJvbSBcIi4vemtleV9uZXcuanNcIjtcbmltcG9ydCBwaGFzZTJ2ZXJpZnlGcm9tSW5pdCBmcm9tIFwiLi96a2V5X3ZlcmlmeV9mcm9taW5pdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwaGFzZTJ2ZXJpZnlGcm9tUjFjcyhyMWNzRmlsZU5hbWUsIHBUYXVGaWxlTmFtZSwgemtleUZpbGVOYW1lLCBsb2dnZXIpIHtcblxuICAgIC8vIGNvbnN0IGluaXRGaWxlTmFtZSA9IFwiflwiICsgemtleUZpbGVOYW1lICsgXCIuaW5pdFwiO1xuICAgIGNvbnN0IGluaXRGaWxlTmFtZSA9IHt0eXBlOiBcImJpZ01lbVwifTtcbiAgICBhd2FpdCBuZXdaS2V5KHIxY3NGaWxlTmFtZSwgcFRhdUZpbGVOYW1lLCBpbml0RmlsZU5hbWUsIGxvZ2dlcik7XG5cbiAgICByZXR1cm4gYXdhaXQgcGhhc2UydmVyaWZ5RnJvbUluaXQoaW5pdEZpbGVOYW1lLCBwVGF1RmlsZU5hbWUsIHprZXlGaWxlTmFtZSwgbG9nZ2VyKTtcbn1cblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snarkjs/src/zkey_verify_fromr1cs.js\n");

/***/ })

};
;