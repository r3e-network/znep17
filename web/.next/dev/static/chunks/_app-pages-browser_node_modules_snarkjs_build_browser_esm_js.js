"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_snarkjs_build_browser_esm_js"],{

/***/ "(app-pages-browser)/./node_modules/snarkjs/build/browser.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/snarkjs/build/browser.esm.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curves: () => (/* binding */ curves),\n/* harmony export */   fflonk: () => (/* binding */ fflonk),\n/* harmony export */   groth16: () => (/* binding */ groth16),\n/* harmony export */   plonk: () => (/* binding */ plonk),\n/* harmony export */   powersOfTau: () => (/* binding */ powersoftau),\n/* harmony export */   r1cs: () => (/* binding */ r1cs),\n/* harmony export */   wtns: () => (/* binding */ wtns),\n/* harmony export */   zKey: () => (/* binding */ zkey)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(app-pages-browser)/./node_modules/snarkjs/node_modules/ffjavascript/build/browser.esm.js\");\n\n\nvar fs = {};\n\nasync function open(fileName, openFlags, cacheSize, pageSize) {\n    cacheSize = cacheSize || 4096*64;\n    if (typeof openFlags !== \"number\" && [\"w+\", \"wx+\", \"r\", \"ax+\", \"a+\"].indexOf(openFlags) <0)\n        throw new Error(\"Invalid open option\");\n    const fd =await fs.promises.open(fileName, openFlags);\n\n    const stats = await fd.stat();\n\n    return  new FastFile(fd, stats, cacheSize, pageSize, fileName);\n}\n\n\nclass FastFile {\n\n    constructor(fd, stats, cacheSize, pageSize, fileName) {\n        this.fileName = fileName;\n        this.fd = fd;\n        this.pos = 0;\n        this.pageSize = pageSize || (1 << 8);\n        while (this.pageSize < stats.blksize) {\n            this.pageSize *= 2;\n        }\n        this.totalSize = stats.size;\n        this.totalPages = Math.floor((stats.size -1) / this.pageSize)+1;\n        this.maxPagesLoaded = Math.floor( cacheSize / this.pageSize)+1;\n        this.pages = {};\n        this.pendingLoads = [];\n        this.writing = false;\n        this.reading = false;\n        this.avBuffs = [];\n        this.history = {};\n    }\n\n    _loadPage(p) {\n        const self = this;\n        const P = new Promise((resolve, reject)=> {\n            self.pendingLoads.push({\n                page: p,\n                resolve: resolve,\n                reject: reject\n            });\n        });\n        self.__statusPage(\"After Load request: \", p);\n        return P;\n    }\n\n    __statusPage(s, p) {\n        const logEntry = [];\n        const self=this;\n        if (!self.logHistory) return;\n        logEntry.push(\"==\" + s+ \" \" +p);\n        let S = \"\";\n        for (let i=0; i<self.pendingLoads.length; i++) {\n            if (self.pendingLoads[i].page == p) S = S + \" \" + i;\n        }\n        if (S) logEntry.push(\"Pending loads:\"+S);\n        if (typeof self.pages[p] != \"undefined\") {\n            const page = self.pages[p];\n            logEntry.push(\"Loaded\");\n            logEntry.push(\"pendingOps: \"+page.pendingOps);\n            if (page.loading) logEntry.push(\"loading: \"+page.loading);\n            if (page.writing) logEntry.push(\"writing\");\n            if (page.dirty) logEntry.push(\"dirty\");\n        }\n        logEntry.push(\"==\");\n\n        if (!self.history[p]) self.history[p] = [];\n        self.history[p].push(logEntry);\n    }\n\n    __printHistory(p) {\n        const self = this;\n        if (!self.history[p]) console.log(\"Empty History \", p);\n        console.log(\"History \"+p);\n        for (let i=0; i<self.history[p].length; i++) {\n            for (let j=0; j<self.history[p][i].length; j++) {\n                console.log(\"-> \" + self.history[p][i][j]);\n            }\n        }\n    }\n\n\n\n    _triggerLoad() {\n        const self = this;\n\n        if (self.reading) return;\n        if (self.pendingLoads.length==0) return;\n\n        const pageIdxs = Object.keys(self.pages);\n\n        const deletablePages = [];\n        for (let i=0; i<pageIdxs.length; i++) {\n            const page = self.pages[parseInt(pageIdxs[i])];\n            if ((page.dirty == false)&&(page.pendingOps==0)&&(!page.writing)&&(!page.loading)) deletablePages.push(parseInt(pageIdxs[i]));\n        }\n\n        let freePages = self.maxPagesLoaded - pageIdxs.length;\n\n        const ops = [];\n\n        // while pending loads and\n        //     the page is loaded or I can recover one.\n        while (\n            (self.pendingLoads.length>0) &&\n            (   (typeof self.pages[self.pendingLoads[0].page] != \"undefined\" )\n              ||(  (freePages>0)\n                 ||(deletablePages.length>0)))) {\n            const load = self.pendingLoads.shift();\n            if (typeof self.pages[load.page] != \"undefined\") {\n                self.pages[load.page].pendingOps ++;\n                const idx = deletablePages.indexOf(load.page);\n                if (idx>=0) deletablePages.splice(idx, 1);\n                if (self.pages[load.page].loading) {\n                    self.pages[load.page].loading.push(load);\n                } else {\n                    load.resolve();\n                }\n                self.__statusPage(\"After Load (cached): \", load.page);\n\n            } else {\n                if (freePages) {\n                    freePages--;\n                } else {\n                    const fp = deletablePages.shift();\n                    self.__statusPage(\"Before Unload: \", fp);\n                    self.avBuffs.unshift(self.pages[fp]);\n                    delete self.pages[fp];\n                    self.__statusPage(\"After Unload: \", fp);\n                }\n\n                if (load.page>=self.totalPages) {\n                    self.pages[load.page] = getNewPage();\n                    load.resolve();\n                    self.__statusPage(\"After Load (new): \", load.page);\n                } else {\n                    self.reading = true;\n                    self.pages[load.page] = getNewPage();\n                    self.pages[load.page].loading = [load];\n                    ops.push(self.fd.read(self.pages[load.page].buff, 0, self.pageSize, load.page*self.pageSize).then((res)=> {\n                        self.pages[load.page].size = res.bytesRead;\n                        const loading = self.pages[load.page].loading;\n                        delete self.pages[load.page].loading;\n                        for (let i=0; i<loading.length; i++) {\n                            loading[i].resolve();\n                        }\n                        self.__statusPage(\"After Load (loaded): \", load.page);\n                        return res;\n                    }, (err) => {\n                        load.reject(err);\n                    }));\n                    self.__statusPage(\"After Load (loading): \", load.page);\n                }\n            }\n        }\n        // if (ops.length>1) console.log(ops.length);\n\n        Promise.all(ops).then( () => {\n            self.reading = false;\n            if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));\n            self._tryClose();\n        });\n\n        function getNewPage() {\n            if (self.avBuffs.length>0) {\n                const p = self.avBuffs.shift();\n                p.dirty = false;\n                p.pendingOps = 1;\n                p.size =0;\n                return p;\n            } else {\n                return {\n                    dirty: false,\n                    buff: new Uint8Array(self.pageSize),\n                    pendingOps: 1,\n                    size: 0\n                };\n            }\n        }\n\n    }\n\n\n    _triggerWrite() {\n        const self = this;\n        if (self.writing) return;\n\n        const pageIdxs = Object.keys(self.pages);\n\n        const ops = [];\n\n        for (let i=0; i<pageIdxs.length; i++) {\n            const page = self.pages[parseInt(pageIdxs[i])];\n            if (page.dirty) {\n                page.dirty = false;\n                page.writing = true;\n                self.writing = true;\n                ops.push( self.fd.write(page.buff, 0, page.size, parseInt(pageIdxs[i])*self.pageSize).then(() => {\n                    page.writing = false;\n                    return;\n                }, (err) => {\n                    console.log(\"ERROR Writing: \"+err);\n                    self.error = err;\n                    self._tryClose();\n                }));\n            }\n        }\n\n        if (self.writing) {\n            Promise.all(ops).then( () => {\n                self.writing = false;\n                setImmediate(self._triggerWrite.bind(self));\n                self._tryClose();\n                if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));\n            });\n        }\n    }\n\n    _getDirtyPage() {\n        for (let p in this.pages) {\n            if (this.pages[p].dirty) return p;\n        }\n        return -1;\n    }\n\n    async write(buff, pos) {\n        if (buff.byteLength == 0) return;\n        const self = this;\n/*\n        if (buff.byteLength > self.pageSize*self.maxPagesLoaded*0.8) {\n            const cacheSize = Math.floor(buff.byteLength * 1.1);\n            this.maxPagesLoaded = Math.floor( cacheSize / self.pageSize)+1;\n        }\n*/\n        if (typeof pos == \"undefined\") pos = self.pos;\n        self.pos = pos+buff.byteLength;\n        if (self.totalSize < pos + buff.byteLength) self.totalSize = pos + buff.byteLength;\n        if (self.pendingClose)\n            throw new Error(\"Writing a closing file\");\n        const firstPage = Math.floor(pos / self.pageSize);\n        const lastPage = Math.floor((pos + buff.byteLength -1) / self.pageSize);\n\n        const pagePromises = [];\n        for (let i=firstPage; i<=lastPage; i++) pagePromises.push(self._loadPage(i));\n        self._triggerLoad();\n\n        let p = firstPage;\n        let o = pos % self.pageSize;\n        let r = buff.byteLength;\n        while (r>0) {\n            await pagePromises[p-firstPage];\n            const l = (o+r > self.pageSize) ? (self.pageSize -o) : r;\n            const srcView = buff.slice( buff.byteLength - r, buff.byteLength - r + l);\n            const dstView = new Uint8Array(self.pages[p].buff.buffer, o, l);\n            dstView.set(srcView);\n            self.pages[p].dirty = true;\n            self.pages[p].pendingOps --;\n            self.pages[p].size = Math.max(o+l, self.pages[p].size);\n            if (p>=self.totalPages) {\n                self.totalPages = p+1;\n            }\n            r = r-l;\n            p ++;\n            o = 0;\n            if (!self.writing) setImmediate(self._triggerWrite.bind(self));\n        }\n    }\n\n    async read(len, pos) {\n        const self = this;\n        let buff = new Uint8Array(len);\n        await self.readToBuffer(buff, 0, len, pos);\n\n        return buff;\n    }\n\n    async readToBuffer(buffDst, offset, len, pos) {\n        if (len == 0) {\n            return;\n        }\n        const self = this;\n        if (len > self.pageSize*self.maxPagesLoaded*0.8) {\n            const cacheSize = Math.floor(len * 1.1);\n            this.maxPagesLoaded = Math.floor( cacheSize / self.pageSize)+1;\n        }\n        if (typeof pos == \"undefined\") pos = self.pos;\n        self.pos = pos+len;\n        if (self.pendingClose)\n            throw new Error(\"Reading a closing file\");\n        const firstPage = Math.floor(pos / self.pageSize);\n        const lastPage = Math.floor((pos + len -1) / self.pageSize);\n\n        const pagePromises = [];\n        for (let i=firstPage; i<=lastPage; i++) pagePromises.push(self._loadPage(i));\n\n        self._triggerLoad();\n\n        let p = firstPage;\n        let o = pos % self.pageSize;\n        // Remaining bytes to read\n        let r = pos + len > self.totalSize ? len - (pos + len - self.totalSize): len;\n        while (r>0) {\n            await pagePromises[p - firstPage];\n            self.__statusPage(\"After Await (read): \", p);\n\n            // bytes to copy from this page\n            const l = (o+r > self.pageSize) ? (self.pageSize -o) : r;\n            const srcView = new Uint8Array(self.pages[p].buff.buffer, self.pages[p].buff.byteOffset + o, l);\n            buffDst.set(srcView, offset+len-r);\n            self.pages[p].pendingOps --;\n\n            self.__statusPage(\"After Op done: \", p);\n\n            r = r-l;\n            p ++;\n            o = 0;\n            if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));\n        }\n\n        this.pos = pos + len;\n\n    }\n\n\n    _tryClose() {\n        const self = this;\n        if (!self.pendingClose) return;\n        if (self.error) {\n            self.pendingCloseReject(self.error);\n        }\n        const p = self._getDirtyPage();\n        if ((p>=0) || (self.writing) || (self.reading) || (self.pendingLoads.length>0)) return;\n        self.pendingClose();\n    }\n\n    close() {\n        const self = this;\n        if (self.pendingClose)\n            throw new Error(\"Closing the file twice\");\n        return new Promise((resolve, reject) => {\n            self.pendingClose = resolve;\n            self.pendingCloseReject = reject;\n            self._tryClose();\n        }).then(()=> {\n            self.fd.close();\n        }, (err) => {\n            self.fd.close();\n            throw (err);\n        });\n    }\n\n    async discard() {\n        const self = this;\n        await self.close();\n        await fs.promises.unlink(this.fileName);\n    }\n\n    async writeULE32(v, pos) {\n        const self = this;\n        const tmpBuff32 = new Uint8Array(4);\n        const tmpBuff32v = new DataView(tmpBuff32.buffer);\n\n        tmpBuff32v.setUint32(0, v, true);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n    async writeUBE32(v, pos) {\n        const self = this;\n\n        const tmpBuff32 = new Uint8Array(4);\n        const tmpBuff32v = new DataView(tmpBuff32.buffer);\n\n        tmpBuff32v.setUint32(0, v, false);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n\n    async writeULE64(v, pos) {\n        const self = this;\n\n        const tmpBuff64 = new Uint8Array(8);\n        const tmpBuff64v = new DataView(tmpBuff64.buffer);\n\n        tmpBuff64v.setUint32(0, v & 0xFFFFFFFF, true);\n        tmpBuff64v.setUint32(4, Math.floor(v / 0x100000000) , true);\n\n        await self.write(tmpBuff64, pos);\n    }\n\n    async readULE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[0];\n    }\n\n    async readUBE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new DataView(b.buffer);\n\n        return view.getUint32(0, false);\n    }\n\n    async readULE64(pos) {\n        const self = this;\n        const b = await self.read(8, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[1] * 0x100000000 + view[0];\n    }\n\n    async readString(pos) {\n        const self = this;\n\n        if (self.pendingClose) {\n            throw new Error(\"Reading a closing file\");\n        }\n\n        let currentPosition = typeof pos == \"undefined\" ? self.pos : pos;\n        let currentPage = Math.floor(currentPosition / self.pageSize);\n\n        let endOfStringFound = false;\n        let str = \"\";\n\n        while (!endOfStringFound) {\n            //Read page\n            let pagePromise = self._loadPage(currentPage);\n            self._triggerLoad();\n            await pagePromise;\n            self.__statusPage(\"After Await (read): \", currentPage);\n\n            let offsetOnPage = currentPosition % self.pageSize;\n\n            const dataArray = new Uint8Array(\n                self.pages[currentPage].buff.buffer,\n                self.pages[currentPage].buff.byteOffset + offsetOnPage,\n                self.pageSize - offsetOnPage\n            );\n\n            let indexEndOfString = dataArray.findIndex(element => element === 0);\n            endOfStringFound = indexEndOfString !== -1;\n\n            if (endOfStringFound) {\n                str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));\n                self.pos = currentPage * this.pageSize + offsetOnPage + indexEndOfString + 1;\n            } else {\n                str += new TextDecoder().decode(dataArray);\n                self.pos = currentPage * this.pageSize + offsetOnPage + dataArray.length;\n            }\n\n            self.pages[currentPage].pendingOps--;\n            self.__statusPage(\"After Op done: \", currentPage);\n\n            currentPosition = self.pos;\n            currentPage++;\n\n            if (self.pendingLoads.length > 0) setImmediate(self._triggerLoad.bind(self));\n        }\n\n        return str;\n    }\n}\n\nfunction createNew$1(o) {\n    const initialSize = o.initialSize || 1<<20;\n    const fd = new MemFile();\n    fd.o = o;\n    fd.o.data = new Uint8Array(initialSize);\n    fd.allocSize = initialSize;\n    fd.totalSize = 0;\n    fd.readOnly = false;\n    fd.pos = 0;\n    return fd;\n}\n\nfunction readExisting$2(o) {\n    const fd = new MemFile();\n    fd.o = o;\n    fd.allocSize = o.data.byteLength;\n    fd.totalSize = o.data.byteLength;\n    fd.readOnly = true;\n    fd.pos = 0;\n    return fd;\n}\n\nconst tmpBuff32$1 = new Uint8Array(4);\nconst tmpBuff32v$1 = new DataView(tmpBuff32$1.buffer);\nconst tmpBuff64$1 = new Uint8Array(8);\nconst tmpBuff64v$1 = new DataView(tmpBuff64$1.buffer);\n\nclass MemFile {\n\n    constructor() {\n        this.pageSize = 1 << 14;  // for compatibility\n    }\n\n    _resizeIfNeeded(newLen) {\n        if (newLen > this.allocSize) {\n            const newAllocSize = Math.max(\n                this.allocSize + (1 << 20),\n                Math.floor(this.allocSize * 1.1),\n                newLen\n            );\n            const newData = new Uint8Array(newAllocSize);\n            newData.set(this.o.data);\n            this.o.data = newData;\n            this.allocSize = newAllocSize;\n        }\n    }\n\n    async write(buff, pos) {\n        const self =this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) throw new Error(\"Writing a read only file\");\n\n        this._resizeIfNeeded(pos + buff.byteLength);\n\n        this.o.data.set(buff.slice(), pos);\n\n        if (pos + buff.byteLength > this.totalSize) this.totalSize = pos + buff.byteLength;\n\n        this.pos = pos + buff.byteLength;\n    }\n\n    async readToBuffer(buffDest, offset, len, pos) {\n        const self = this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) {\n            if (pos + len > this.totalSize) throw new Error(\"Reading out of bounds\");\n        }\n        this._resizeIfNeeded(pos + len);\n\n        const buffSrc = new Uint8Array(this.o.data.buffer, this.o.data.byteOffset + pos, len);\n\n        buffDest.set(buffSrc, offset);\n\n        this.pos = pos + len;\n    }\n\n    async read(len, pos) {\n        const self = this;\n\n        const buff = new Uint8Array(len);\n        await self.readToBuffer(buff, 0, len, pos);\n\n        return buff;\n    }\n\n    close() {\n        if (this.o.data.byteLength != this.totalSize) {\n            this.o.data = this.o.data.slice(0, this.totalSize);\n        }\n    }\n\n    async discard() {\n    }\n\n\n    async writeULE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v$1.setUint32(0, v, true);\n\n        await self.write(tmpBuff32$1, pos);\n    }\n\n    async writeUBE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v$1.setUint32(0, v, false);\n\n        await self.write(tmpBuff32$1, pos);\n    }\n\n\n    async writeULE64(v, pos) {\n        const self = this;\n\n        tmpBuff64v$1.setUint32(0, v & 0xFFFFFFFF, true);\n        tmpBuff64v$1.setUint32(4, Math.floor(v / 0x100000000) , true);\n\n        await self.write(tmpBuff64$1, pos);\n    }\n\n\n    async readULE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[0];\n    }\n\n    async readUBE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new DataView(b.buffer);\n\n        return view.getUint32(0, false);\n    }\n\n    async readULE64(pos) {\n        const self = this;\n        const b = await self.read(8, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[1] * 0x100000000 + view[0];\n    }\n\n    async readString(pos) {\n        const self = this;\n\n        let currentPosition = typeof pos == \"undefined\" ? self.pos : pos;\n\n        if (currentPosition > this.totalSize) {\n            if (this.readOnly) {\n                throw new Error(\"Reading out of bounds\");\n            }\n            this._resizeIfNeeded(pos);\n        }\n        const dataArray = new Uint8Array(\n            self.o.data.buffer,\n            currentPosition,\n            this.totalSize - currentPosition\n        );\n\n        let indexEndOfString = dataArray.findIndex(element => element === 0);\n        let endOfStringFound = indexEndOfString !== -1;\n\n        let str = \"\";\n        if (endOfStringFound) {\n            str = new TextDecoder().decode(dataArray.slice(0, indexEndOfString));\n            self.pos = currentPosition + indexEndOfString + 1;\n        } else {\n            self.pos = currentPosition;\n        }\n        return str;\n    }\n}\n\nconst PAGE_SIZE = 1<<22;\n\nfunction createNew(o) {\n    const initialSize = o.initialSize || 0;\n    const fd = new BigMemFile();\n    fd.o = o;\n    const nPages = initialSize ? Math.floor((initialSize - 1) / PAGE_SIZE)+1 : 0;\n    fd.o.data = [];\n    for (let i=0; i<nPages-1; i++) {\n        fd.o.data.push( new Uint8Array(PAGE_SIZE));\n    }\n    if (nPages) fd.o.data.push( new Uint8Array(initialSize - PAGE_SIZE*(nPages-1)));\n    fd.totalSize = 0;\n    fd.readOnly = false;\n    fd.pos = 0;\n    return fd;\n}\n\nfunction readExisting$1(o) {\n    const fd = new BigMemFile();\n    fd.o = o;\n    fd.totalSize = (o.data.length-1)* PAGE_SIZE + o.data[o.data.length-1].byteLength;\n    fd.readOnly = true;\n    fd.pos = 0;\n    return fd;\n}\n\nconst tmpBuff32 = new Uint8Array(4);\nconst tmpBuff32v = new DataView(tmpBuff32.buffer);\nconst tmpBuff64 = new Uint8Array(8);\nconst tmpBuff64v = new DataView(tmpBuff64.buffer);\n\nclass BigMemFile {\n\n    constructor() {\n        this.pageSize = 1 << 14;  // for compatibility\n    }\n\n    _resizeIfNeeded(newLen) {\n\n        if (newLen <= this.totalSize) return;\n\n        if (this.readOnly) throw new Error(\"Reading out of file bounds\");\n\n        const nPages = Math.floor((newLen - 1) / PAGE_SIZE)+1;\n        for (let i= Math.max(this.o.data.length-1, 0); i<nPages; i++) {\n            const newSize = i<nPages-1 ? PAGE_SIZE : newLen - (nPages-1)*PAGE_SIZE;\n            const p = new Uint8Array(newSize);\n            if (i == this.o.data.length-1) p.set(this.o.data[i]);\n            this.o.data[i] = p;\n        }\n        this.totalSize = newLen;\n    }\n\n    async write(buff, pos) {\n        const self =this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) throw new Error(\"Writing a read only file\");\n\n        this._resizeIfNeeded(pos + buff.byteLength);\n\n        const firstPage = Math.floor(pos / PAGE_SIZE);\n\n        let p = firstPage;\n        let o = pos % PAGE_SIZE;\n        let r = buff.byteLength;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice(buff.byteLength - r, buff.byteLength - r + l);\n            const dstView = new Uint8Array(self.o.data[p].buffer, o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        this.pos = pos + buff.byteLength;\n    }\n\n    async readToBuffer(buffDst, offset, len, pos) {\n        const self = this;\n        if (typeof pos == \"undefined\") pos = self.pos;\n        if (this.readOnly) {\n            if (pos + len > this.totalSize) throw new Error(\"Reading out of bounds\");\n        }\n        this._resizeIfNeeded(pos + len);\n\n        const firstPage = Math.floor(pos / PAGE_SIZE);\n\n        let p = firstPage;\n        let o = pos % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(self.o.data[p].buffer, o, l);\n            buffDst.set(srcView, offset+len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        this.pos = pos + len;\n    }\n\n    async read(len, pos) {\n        const self = this;\n        const buff = new Uint8Array(len);\n\n        await self.readToBuffer(buff, 0, len, pos);\n\n        return buff;\n    }\n\n    close() {\n    }\n\n    async discard() {\n    }\n\n\n    async writeULE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v.setUint32(0, v, true);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n    async writeUBE32(v, pos) {\n        const self = this;\n\n        tmpBuff32v.setUint32(0, v, false);\n\n        await self.write(tmpBuff32, pos);\n    }\n\n\n    async writeULE64(v, pos) {\n        const self = this;\n\n        tmpBuff64v.setUint32(0, v & 0xFFFFFFFF, true);\n        tmpBuff64v.setUint32(4, Math.floor(v / 0x100000000) , true);\n\n        await self.write(tmpBuff64, pos);\n    }\n\n\n    async readULE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[0];\n    }\n\n    async readUBE32(pos) {\n        const self = this;\n        const b = await self.read(4, pos);\n\n        const view = new DataView(b.buffer);\n\n        return view.getUint32(0, false);\n    }\n\n    async readULE64(pos) {\n        const self = this;\n        const b = await self.read(8, pos);\n\n        const view = new Uint32Array(b.buffer);\n\n        return view[1] * 0x100000000 + view[0];\n    }\n\n    async readString(pos) {\n        const self = this;\n        const fixedSize = 2048;\n\n        let currentPosition = typeof pos == \"undefined\" ? self.pos : pos;\n\n        if (currentPosition > this.totalSize) {\n            if (this.readOnly) {\n                throw new Error(\"Reading out of bounds\");\n            }\n            this._resizeIfNeeded(pos);\n        }\n\n        let endOfStringFound = false;\n        let str = \"\";\n\n        while (!endOfStringFound) {\n            let currentPage = Math.floor(currentPosition / PAGE_SIZE);\n            let offsetOnPage = currentPosition % PAGE_SIZE;\n\n            if (self.o.data[currentPage] === undefined) {\n                throw new Error(\"ERROR\");\n            }\n\n            let readLength = Math.min(fixedSize, self.o.data[currentPage].length - offsetOnPage);\n            const dataArray = new Uint8Array(self.o.data[currentPage].buffer, offsetOnPage, readLength);\n\n            let indexEndOfString = dataArray.findIndex(element => element === 0);\n            endOfStringFound = indexEndOfString !== -1;\n\n            if (endOfStringFound) {\n                str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));\n                self.pos = currentPage * PAGE_SIZE + offsetOnPage + indexEndOfString + 1;\n            } else {\n                str += new TextDecoder().decode(dataArray);\n                self.pos = currentPage * PAGE_SIZE + offsetOnPage + dataArray.length;\n            }\n\n            currentPosition = self.pos;\n        }\n        return str;\n    }\n}\n\nconst O_TRUNC = 1024;\nconst O_CREAT = 512;\nconst O_RDWR = 2;\nconst O_RDONLY = 0;\n\n/* global fetch */\n\nconst DEFAULT_CACHE_SIZE = (1 << 16);\nconst DEFAULT_PAGE_SIZE = (1 << 13);\n\n\nasync function createOverride(o, b, c) {\n    if (typeof o === \"string\") {\n        o = {\n            type: \"file\",\n            fileName: o,\n            cacheSize: b || DEFAULT_CACHE_SIZE,\n            pageSize: c || DEFAULT_PAGE_SIZE\n        };\n    }\n    if (o.type == \"file\") {\n        return await open(o.fileName, O_TRUNC | O_CREAT | O_RDWR, o.cacheSize, o.pageSize);\n    } else if (o.type == \"mem\") {\n        return createNew$1(o);\n    } else if (o.type == \"bigMem\") {\n        return createNew(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n\nasync function readExisting(o, b, c) {\n    if (o instanceof Uint8Array) {\n        o = {\n            type: \"mem\",\n            data: o\n        };\n    }\n    {\n        if (typeof o === \"string\") {\n            const buff = await fetch(o).then( function(res) {\n                return res.arrayBuffer();\n            }).then(function (ab) {\n                return new Uint8Array(ab);\n            });\n            o = {\n                type: \"mem\",\n                data: buff\n            };\n        }\n    }\n    if (o.type == \"file\") {\n        return await open(o.fileName, O_RDONLY, o.cacheSize, o.pageSize);\n    } else if (o.type == \"mem\") {\n        return await readExisting$2(o);\n    } else if (o.type == \"bigMem\") {\n        return await readExisting$1(o);\n    } else {\n        throw new Error(\"Invalid FastFile type: \"+o.type);\n    }\n}\n\nasync function readBinFile(fileName, type, maxVersion, cacheSize, pageSize) {\n\n    const fd = await readExisting(fileName);\n\n    const b = await fd.read(4);\n    let readedType = \"\";\n    for (let i=0; i<4; i++) readedType += String.fromCharCode(b[i]);\n\n    if (readedType != type) throw new Error(fileName + \": Invalid File format\");\n\n    let v = await fd.readULE32();\n\n    if (v>maxVersion) throw new Error(\"Version not supported\");\n\n    const nSections = await fd.readULE32();\n\n    // Scan sections\n    let sections = [];\n    for (let i=0; i<nSections; i++) {\n        let ht = await fd.readULE32();\n        let hl = await fd.readULE64();\n        if (typeof sections[ht] == \"undefined\") sections[ht] = [];\n        sections[ht].push({\n            p: fd.pos,\n            size: hl\n        });\n        fd.pos += hl;\n    }\n\n    return {fd, sections};\n}\n\nasync function createBinFile(fileName, type, version, nSections, cacheSize, pageSize) {\n\n    const fd = await createOverride(fileName, cacheSize, pageSize);\n\n    const buff = new Uint8Array(4);\n    for (let i=0; i<4; i++) buff[i] = type.charCodeAt(i);\n    await fd.write(buff, 0); // Magic \"r1cs\"\n\n    await fd.writeULE32(version); // Version\n    await fd.writeULE32(nSections); // Number of Sections\n\n    return fd;\n}\n\nasync function startWriteSection(fd, idSection) {\n    if (typeof fd.writingSection !== \"undefined\") throw new Error(\"Already writing a section\");\n    await fd.writeULE32(idSection); // Header type\n    fd.writingSection = {\n        pSectionSize: fd.pos\n    };\n    await fd.writeULE64(0); // Temporally set to 0 length\n}\n\nasync function endWriteSection(fd) {\n    if (typeof fd.writingSection === \"undefined\") throw new Error(\"Not writing a section\");\n\n    const sectionSize = fd.pos - fd.writingSection.pSectionSize - 8;\n    const oldPos = fd.pos;\n    fd.pos = fd.writingSection.pSectionSize;\n    await fd.writeULE64(sectionSize);\n    fd.pos = oldPos;\n    delete fd.writingSection;\n}\n\nasync function startReadUniqueSection(fd, sections, idSection) {\n    if (typeof fd.readingSection !== \"undefined\") throw new Error(\"Already reading a section\");\n    if (!sections[idSection])  throw new Error(fd.fileName + \": Missing section \"+ idSection );\n    if (sections[idSection].length>1) throw new Error(fd.fileName +\": Section Duplicated \" +idSection);\n\n    fd.pos = sections[idSection][0].p;\n\n    fd.readingSection = sections[idSection][0];\n}\n\nasync function endReadSection(fd, noCheck) {\n    if (typeof fd.readingSection === \"undefined\") throw new Error(\"Not reading a section\");\n    if (!noCheck) {\n        if (fd.pos-fd.readingSection.p !=  fd.readingSection.size) throw new Error(\"Invalid section size reading\");\n    }\n    delete fd.readingSection;\n}\n\nasync function writeBigInt(fd, n, n8, pos) {\n    const buff = new Uint8Array(n8);\n    ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(buff, 0, n, n8);\n    await fd.write(buff, pos);\n}\n\nasync function readBigInt(fd, n8, pos) {\n    const buff = await fd.read(n8, pos);\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(buff, 0, n8);\n}\n\nasync function copySection(fdFrom, sections, fdTo, sectionId, size) {\n    if (typeof size === \"undefined\") {\n        size = sections[sectionId][0].size;\n    }\n    const chunkSize = fdFrom.pageSize;\n    await startReadUniqueSection(fdFrom, sections, sectionId);\n    await startWriteSection(fdTo, sectionId);\n    for (let p=0; p<size; p+=chunkSize) {\n        const l = Math.min(size -p, chunkSize);\n        const buff = await fdFrom.read(l);\n        await fdTo.write(buff);\n    }\n    await endWriteSection(fdTo);\n    await endReadSection(fdFrom, size != sections[sectionId][0].size);\n\n}\n\nasync function readSection(fd, sections, idSection, offset, length) {\n\n    offset = (typeof offset === \"undefined\") ? 0 : offset;\n    length = (typeof length === \"undefined\") ? sections[idSection][0].size - offset : length;\n\n    if (offset + length > sections[idSection][0].size) {\n        throw new Error(\"Reading out of the range of the section\");\n    }\n\n    let buff;\n    if (length < (1 << 30) ) {\n        buff = new Uint8Array(length);\n    } else {\n        buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length);\n    }\n\n    await fd.readToBuffer(buff, 0, length, sections[idSection][0].p + offset);\n    return buff;\n}\n\nasync function sectionIsEqual(fd1, sections1, fd2, sections2, idSection) {\n    const MAX_BUFF_SIZE = fd1.pageSize * 16;\n    await startReadUniqueSection(fd1, sections1, idSection);\n    await startReadUniqueSection(fd2, sections2, idSection);\n    if (sections1[idSection][0].size != sections2[idSection][0].size) return false;\n    const totalBytes=sections1[idSection][0].size;\n    for (let i=0; i<totalBytes; i+= MAX_BUFF_SIZE) {\n        const n = Math.min(totalBytes-i, MAX_BUFF_SIZE);\n        const buff1 = await fd1.read(n);\n        const buff2 = await fd2.read(n);\n        for (let j=0; j<n; j++) if (buff1[j] != buff2[j]) return false;\n    }\n    await endReadSection(fd1);\n    await endReadSection(fd2);\n    return true;\n}\n\nconst bls12381r$1 = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r$1 = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nasync function getCurveFromR(r, options) {\n    let curve;\n    // check that options param is defined and that options.singleThread is defined\n    let singleThread = options && options.singleThread;\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(r, bn128r$1)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(r, bls12381r$1)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromQ(q, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(q, bn128q)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(q, bls12381q)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(q)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromName(name, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n\nvar curves = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getCurveFromR: getCurveFromR,\n    getCurveFromQ: getCurveFromQ,\n    getCurveFromName: getCurveFromName\n});\n\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    bytes(data);\n    return data;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n\n// Blake is based on ChaCha permutation.\n// For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n// prettier-ignore\nconst SIGMA = /* @__PURE__ */ new Uint8Array([\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n    12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n    13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n    6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n    10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n]);\nclass BLAKE extends Hash {\n    constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.length = 0;\n        this.pos = 0;\n        this.finished = false;\n        this.destroyed = false;\n        number(blockLen);\n        number(outputLen);\n        number(keyLen);\n        if (outputLen < 0 || outputLen > keyLen)\n            throw new Error('outputLen bigger than keyLen');\n        if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))\n            throw new Error(`key must be up 1..${keyLen} byte long or undefined`);\n        if (opts.salt !== undefined && opts.salt.length !== saltLen)\n            throw new Error(`salt must be ${saltLen} byte long or undefined`);\n        if (opts.personalization !== undefined && opts.personalization.length !== persLen)\n            throw new Error(`personalization must be ${persLen} byte long or undefined`);\n        this.buffer32 = u32((this.buffer = new Uint8Array(blockLen)));\n    }\n    update(data) {\n        exists(this);\n        // Main difference with other hashes: there is flag for last block,\n        // so we cannot process current block before we know that there\n        // is the next one. This significantly complicates logic and reduces ability\n        // to do zero-copy processing\n        const { blockLen, buffer, buffer32 } = this;\n        data = toBytes(data);\n        const len = data.length;\n        const offset = data.byteOffset;\n        const buf = data.buffer;\n        for (let pos = 0; pos < len;) {\n            // If buffer is full and we still have input (don't process last block, same as blake2s)\n            if (this.pos === blockLen) {\n                if (!isLE)\n                    byteSwap32(buffer32);\n                this.compress(buffer32, 0, false);\n                if (!isLE)\n                    byteSwap32(buffer32);\n                this.pos = 0;\n            }\n            const take = Math.min(blockLen - this.pos, len - pos);\n            const dataOffset = offset + pos;\n            // full block && aligned to 4 bytes && not last in input\n            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n                const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n                if (!isLE)\n                    byteSwap32(data32);\n                for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n                    this.length += blockLen;\n                    this.compress(data32, pos32, false);\n                }\n                if (!isLE)\n                    byteSwap32(data32);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            this.length += take;\n            pos += take;\n        }\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        const { pos, buffer32 } = this;\n        this.finished = true;\n        // Padding\n        this.buffer.subarray(pos).fill(0);\n        if (!isLE)\n            byteSwap32(buffer32);\n        this.compress(buffer32, 0, true);\n        if (!isLE)\n            byteSwap32(buffer32);\n        const out32 = u32(out);\n        this.get().forEach((v, i) => (out32[i] = byteSwapIfBE(v)));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        const { buffer, length, finished, destroyed, outputLen, pos } = this;\n        to || (to = new this.constructor({ dkLen: outputLen }));\n        to.set(...this.get());\n        to.length = length;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.outputLen = outputLen;\n        to.buffer.set(buffer);\n        to.pos = pos;\n        return to;\n    }\n}\n\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nvar u64$1 = u64;\n\n// Same as SHA-512 but LE\n// prettier-ignore\nconst B2B_IV = /* @__PURE__ */ new Uint32Array([\n    0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n    0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n// Mixing function G splitted in two halfs\nfunction G1b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64$1.add3L(Al, Bl, Xl);\n    Ah = u64$1.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 32)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64$1.rotr32H(Dh, Dl), Dl: u64$1.rotr32L(Dh, Dl) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64$1.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 24)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64$1.rotrSH(Bh, Bl, 24), Bl: u64$1.rotrSL(Bh, Bl, 24) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nfunction G2b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64$1.add3L(Al, Bl, Xl);\n    Ah = u64$1.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 16)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64$1.rotrSH(Dh, Dl, 16), Dl: u64$1.rotrSL(Dh, Dl, 16) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64$1.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 63)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64$1.rotrBH(Bh, Bl, 63), Bl: u64$1.rotrBL(Bh, Bl, 63) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nclass BLAKE2b extends BLAKE {\n    constructor(opts = {}) {\n        super(128, opts.dkLen === undefined ? 64 : opts.dkLen, opts, 64, 16, 16);\n        // Same as SHA-512, but LE\n        this.v0l = B2B_IV[0] | 0;\n        this.v0h = B2B_IV[1] | 0;\n        this.v1l = B2B_IV[2] | 0;\n        this.v1h = B2B_IV[3] | 0;\n        this.v2l = B2B_IV[4] | 0;\n        this.v2h = B2B_IV[5] | 0;\n        this.v3l = B2B_IV[6] | 0;\n        this.v3h = B2B_IV[7] | 0;\n        this.v4l = B2B_IV[8] | 0;\n        this.v4h = B2B_IV[9] | 0;\n        this.v5l = B2B_IV[10] | 0;\n        this.v5h = B2B_IV[11] | 0;\n        this.v6l = B2B_IV[12] | 0;\n        this.v6h = B2B_IV[13] | 0;\n        this.v7l = B2B_IV[14] | 0;\n        this.v7h = B2B_IV[15] | 0;\n        const keyLength = opts.key ? opts.key.length : 0;\n        this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n        if (opts.salt) {\n            const salt = u32(toBytes(opts.salt));\n            this.v4l ^= byteSwapIfBE(salt[0]);\n            this.v4h ^= byteSwapIfBE(salt[1]);\n            this.v5l ^= byteSwapIfBE(salt[2]);\n            this.v5h ^= byteSwapIfBE(salt[3]);\n        }\n        if (opts.personalization) {\n            const pers = u32(toBytes(opts.personalization));\n            this.v6l ^= byteSwapIfBE(pers[0]);\n            this.v6h ^= byteSwapIfBE(pers[1]);\n            this.v7l ^= byteSwapIfBE(pers[2]);\n            this.v7h ^= byteSwapIfBE(pers[3]);\n        }\n        if (opts.key) {\n            // Pad to blockLen and update\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set(toBytes(opts.key));\n            this.update(tmp);\n        }\n    }\n    // prettier-ignore\n    get() {\n        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n    }\n    // prettier-ignore\n    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {\n        this.v0l = v0l | 0;\n        this.v0h = v0h | 0;\n        this.v1l = v1l | 0;\n        this.v1h = v1h | 0;\n        this.v2l = v2l | 0;\n        this.v2h = v2h | 0;\n        this.v3l = v3l | 0;\n        this.v3h = v3h | 0;\n        this.v4l = v4l | 0;\n        this.v4h = v4h | 0;\n        this.v5l = v5l | 0;\n        this.v5h = v5h | 0;\n        this.v6l = v6l | 0;\n        this.v6h = v6h | 0;\n        this.v7l = v7l | 0;\n        this.v7h = v7h | 0;\n    }\n    compress(msg, offset, isLast) {\n        this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n        BBUF.set(B2B_IV, 16); // Second half from IV.\n        let { h, l } = u64$1.fromBig(BigInt(this.length));\n        BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n        BBUF[25] = B2B_IV[9] ^ h; // High word.\n        // Invert all bits for last block\n        if (isLast) {\n            BBUF[28] = ~BBUF[28];\n            BBUF[29] = ~BBUF[29];\n        }\n        let j = 0;\n        const s = SIGMA;\n        for (let i = 0; i < 12; i++) {\n            G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n            G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n        }\n        this.v0l ^= BBUF[0] ^ BBUF[16];\n        this.v0h ^= BBUF[1] ^ BBUF[17];\n        this.v1l ^= BBUF[2] ^ BBUF[18];\n        this.v1h ^= BBUF[3] ^ BBUF[19];\n        this.v2l ^= BBUF[4] ^ BBUF[20];\n        this.v2h ^= BBUF[5] ^ BBUF[21];\n        this.v3l ^= BBUF[6] ^ BBUF[22];\n        this.v3h ^= BBUF[7] ^ BBUF[23];\n        this.v4l ^= BBUF[8] ^ BBUF[24];\n        this.v4h ^= BBUF[9] ^ BBUF[25];\n        this.v5l ^= BBUF[10] ^ BBUF[26];\n        this.v5h ^= BBUF[11] ^ BBUF[27];\n        this.v6l ^= BBUF[12] ^ BBUF[28];\n        this.v6h ^= BBUF[13] ^ BBUF[29];\n        this.v7l ^= BBUF[14] ^ BBUF[30];\n        this.v7h ^= BBUF[15] ^ BBUF[31];\n        BBUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer32.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * BLAKE2b - optimized for 64-bit platforms. JS doesn't have uint64, so it's slower than BLAKE2s.\n * @param msg - message that would be hashed\n * @param opts - dkLen, key, salt, personalization\n */\nconst blake2b = /* @__PURE__ */ wrapConstructorWithOpts((opts) => new BLAKE2b(opts));\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction formatHash(b, title) {\n    const a = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    let S = \"\";\n    for (let i=0; i<4; i++) {\n        if (i>0) S += \"\\n\";\n        S += \"\\t\\t\";\n        for (let j=0; j<4; j++) {\n            if (j>0) S += \" \";\n            S += a.getUint32(i*16+j*4).toString(16).padStart(8, \"0\");\n        }\n    }\n    if (title) S = title + \"\\n\" + S;\n    return S;\n}\n\nfunction hashIsEqual(h1, h2) {\n    if (h1.byteLength != h2.byteLength) return false;\n    var dv1 = new Int8Array(h1);\n    var dv2 = new Int8Array(h2);\n    for (var i = 0 ; i != h1.byteLength ; i++)\n    {\n        if (dv1[i] != dv2[i]) return false;\n    }\n    return true;\n}\n\nfunction cloneHasher(h) {\n    return h.clone();\n}\n\nfunction fromPartialHash(partial) {\n    // NOTE: this is unsafe and uses internal API\n    const buf = partial.subarray(0, 128);\n    const rest = u32(partial.subarray(128));\n    const res = blake2b.create({ dkLen: 64 });\n    res.buffer.set(buf);\n    (res.v0l = rest[0] | 0), (res.v0h = rest[1] | 0);\n    (res.v1l = rest[2] | 0), (res.v1h = rest[3] | 0);\n    (res.v2l = rest[4] | 0), (res.v2h = rest[5] | 0);\n    (res.v3l = rest[6] | 0), (res.v3h = rest[7] | 0);\n    (res.v4l = rest[8] | 0), (res.v4h = rest[9] | 0);\n    (res.v5l = rest[10] | 0), (res.v5h = rest[11] | 0);\n    (res.v6l = rest[12] | 0), (res.v6h = rest[13] | 0);\n    (res.v7l = rest[14] | 0), (res.v7h = rest[15] | 0);\n    const shift = 2 ** 32;\n    const len = rest[16] + rest[17] * shift;\n    const pos = rest[18] + rest[19] * shift;\n    res.length = len + pos;\n    res.pos = pos;\n    return res;\n}\n\nfunction toPartialHash(hash){\n    // NOTE: this is unsafe and uses internal API\n    const res = new Uint8Array(216);\n    const res32 = u32(res.subarray(128));\n    res.set(hash.buffer);\n    (res32[0] = hash.v0l), (res32[1] = hash.v0h);\n    (res32[2] = hash.v1l), (res32[3] = hash.v1h);\n    (res32[4] = hash.v2l), (res32[5] = hash.v2h);\n    (res32[6] = hash.v3l), (res32[7] = hash.v3h);\n    (res32[8] = hash.v4l), (res32[9] = hash.v4h);\n    (res32[10] = hash.v5l), (res32[11] = hash.v5h);\n    (res32[12] = hash.v6l), (res32[13] = hash.v6h);\n    (res32[14] = hash.v7l), (res32[15] = hash.v7h);\n    res32[18] = hash.pos;\n    res32[16] = hash.length-hash.pos;\n    return res;\n}\n\nasync function sameRatio$2(curve, g1s, g1sx, g2s, g2sx) {\n    if (curve.G1.isZero(g1s)) return false;\n    if (curve.G1.isZero(g1sx)) return false;\n    if (curve.G2.isZero(g2s)) return false;\n    if (curve.G2.isZero(g2sx)) return false;\n    // return curve.F12.eq(curve.pairing(g1s, g2sx), curve.pairing(g1sx, g2s));\n    const res = await curve.pairingEq(g1s, g2sx, curve.G1.neg(g1sx), g2s);\n    return res;\n}\n\n\nfunction askEntropy() {\n    {\n        return window.prompt(\"Enter a random text. (Entropy): \", \"\");\n    }\n}\n\nfunction getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    { // Supported\n        globalThis.crypto.getRandomValues(array);\n    }\n    return array;\n}\n\nasync function sha256digest(data) {\n    { // Supported\n        const buffer = await globalThis.crypto.subtle.digest(\"SHA-256\", data.buffer);\n        return new Uint8Array(buffer);\n    }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n */\nfunction readUInt32BE(data, offset) {\n    return new DataView(data.buffer).getUint32(offset, false);\n}\n\nasync function getRandomRng(entropy) {\n    // Generate a random Rng\n    while (!entropy) {\n        entropy = await askEntropy();\n    }\n    const hasher = blake2b.create(64);\n    hasher.update(getRandomBytes(64));\n    const enc = new TextEncoder(); // always utf-8\n    hasher.update(enc.encode(entropy));\n    const hash = hasher.digest();\n\n    const seed = [];\n    for (let i=0;i<8;i++) {\n        seed[i] = readUInt32BE(hash, i*4);\n    }\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.ChaCha(seed);\n    return rng;\n}\n\nasync function rngFromBeaconParams(beaconHash, numIterationsExp) {\n    let nIterationsInner;\n    let nIterationsOuter;\n    if (numIterationsExp<32) {\n        nIterationsInner = (1 << numIterationsExp) >>> 0;\n        nIterationsOuter = 1;\n    } else {\n        nIterationsInner = 0x100000000;\n        nIterationsOuter = (1 << (numIterationsExp-32)) >>> 0;\n    }\n\n    let curHash = beaconHash;\n    for (let i=0; i<nIterationsOuter; i++) {\n        for (let j=0; j<nIterationsInner; j++) {\n            curHash = await sha256digest(curHash);\n        }\n    }\n\n    const curHashV = new DataView(curHash.buffer, curHash.byteOffset, curHash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = curHashV.getUint32(i*4, false);\n    }\n\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.ChaCha(seed);\n\n    return rng;\n}\n\nfunction hex2ByteArray(s) {\n    if (s instanceof Uint8Array) return s;\n    if (s.slice(0,2) == \"0x\") s= s.slice(2);\n    return new Uint8Array(s.match(/[\\da-f]{2}/gi).map(function (h) {\n        return parseInt(h, 16);\n    }));\n}\n\nfunction byteArray2hex(byteArray) {\n    return Array.prototype.map.call(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nfunction stringifyBigIntsWithField(Fr, o) {\n    if (o instanceof Uint8Array)  {\n        return Fr.toString(o);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigIntsWithField.bind(null, Fr));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach( (k) => {\n            res[k] = stringifyBigIntsWithField(Fr, o[k]);\n        });\n        return res;\n    } else if ((typeof(o) == \"bigint\") || o.eq !== undefined)  {\n        return o.toString(10);\n    } else {\n        return o;\n    }\n}\n\nconst HEADER_ZKEY_SECTION = 1;\n\nconst GROTH16_PROTOCOL_ID = 1;\nconst PLONK_PROTOCOL_ID = 2;\nconst FFLONK_PROTOCOL_ID = 10;\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// FFlonk constants\nconst FF_T_POL_DEG_MIN = 3;\n\n// ZKEY constants\nconst ZKEY_FF_NSECTIONS = 17;\n\nconst ZKEY_FF_HEADER_SECTION = 2;\nconst ZKEY_FF_ADDITIONS_SECTION = 3;\nconst ZKEY_FF_A_MAP_SECTION = 4;\nconst ZKEY_FF_B_MAP_SECTION = 5;\nconst ZKEY_FF_C_MAP_SECTION = 6;\nconst ZKEY_FF_QL_SECTION = 7;\nconst ZKEY_FF_QR_SECTION = 8;\nconst ZKEY_FF_QM_SECTION = 9;\nconst ZKEY_FF_QO_SECTION = 10;\nconst ZKEY_FF_QC_SECTION = 11;\nconst ZKEY_FF_SIGMA1_SECTION = 12;\nconst ZKEY_FF_SIGMA2_SECTION = 13;\nconst ZKEY_FF_SIGMA3_SECTION = 14;\nconst ZKEY_FF_LAGRANGE_SECTION = 15;\nconst ZKEY_FF_PTAU_SECTION = 16;\nconst ZKEY_FF_C0_SECTION = 17;\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function writeHeader(fd, zkey) {\n\n    // Write the header\n    ///////////\n    await startWriteSection(fd, 1);\n    await fd.writeULE32(1); // Groth\n    await endWriteSection(fd);\n\n    // Write the Groth header section\n    ///////////\n\n    const curve = await getCurveFromQ(zkey.q);\n\n    await startWriteSection(fd, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n    await fd.writeULE32(n8q);\n    await writeBigInt(fd, primeQ, n8q);\n    await fd.writeULE32(n8r);\n    await writeBigInt(fd, primeR, n8r);\n    await fd.writeULE32(zkey.nVars);                         // Total number of bars\n    await fd.writeULE32(zkey.nPublic);                       // Total number of public vars (not including ONE)\n    await fd.writeULE32(zkey.domainSize);                  // domainSize\n    await writeG1(fd, curve, zkey.vk_alpha_1);\n    await writeG1(fd, curve, zkey.vk_beta_1);\n    await writeG2(fd, curve, zkey.vk_beta_2);\n    await writeG2(fd, curve, zkey.vk_gamma_2);\n    await writeG1(fd, curve, zkey.vk_delta_1);\n    await writeG2(fd, curve, zkey.vk_delta_2);\n\n    await endWriteSection(fd);\n\n\n}\n\nasync function writeG1(fd, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function writeG2(fd, curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function readG1(fd, curve, toObject) {\n    const buff = await fd.read(curve.G1.F.n8*2);\n    const res = curve.G1.fromRprLEM(buff, 0);\n    return toObject ? curve.G1.toObject(res) : res;\n}\n\nasync function readG2(fd, curve, toObject) {\n    const buff = await fd.read(curve.G2.F.n8*2);\n    const res = curve.G2.fromRprLEM(buff, 0);\n    return toObject ? curve.G2.toObject(res) : res;\n}\n\n\nasync function readHeader$1(fd, sections, toObject, options) {\n    // Read Header\n    /////////////////////\n    await startReadUniqueSection(fd, sections, 1);\n    const protocolId = await fd.readULE32();\n    await endReadSection(fd);\n\n    if (protocolId === GROTH16_PROTOCOL_ID) {\n        return await readHeaderGroth16(fd, sections, toObject, options);\n    } else if (protocolId === PLONK_PROTOCOL_ID) {\n        return await readHeaderPlonk(fd, sections, toObject, options);\n    } else if (protocolId === FFLONK_PROTOCOL_ID) {\n        return await readHeaderFFlonk(fd, sections, toObject, options);\n    } else {\n        throw new Error(\"Protocol not supported: \");\n    }\n}\n\n\n\n\nasync function readHeaderGroth16(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"groth16\";\n\n    // Read Groth Header\n    /////////////////////\n    await startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await readBigInt(fd, n8r);\n    zkey.curve = await getCurveFromQ(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.vk_alpha_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_gamma_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_delta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_delta_2 = await readG2(fd, zkey.curve, toObject);\n    await endReadSection(fd);\n\n    return zkey;\n\n}\n\nasync function readHeaderPlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"plonk\";\n\n    // Read Plonk Header\n    /////////////////////\n    await startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await readBigInt(fd, n8r);\n    zkey.curve = await getCurveFromQ(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.Qm = await readG1(fd, zkey.curve, toObject);\n    zkey.Ql = await readG1(fd, zkey.curve, toObject);\n    zkey.Qr = await readG1(fd, zkey.curve, toObject);\n    zkey.Qo = await readG1(fd, zkey.curve, toObject);\n    zkey.Qc = await readG1(fd, zkey.curve, toObject);\n    zkey.S1 = await readG1(fd, zkey.curve, toObject);\n    zkey.S2 = await readG1(fd, zkey.curve, toObject);\n    zkey.S3 = await readG1(fd, zkey.curve, toObject);\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    await endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readHeaderFFlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"fflonk\";\n    zkey.protocolId = FFLONK_PROTOCOL_ID;\n\n    await startReadUniqueSection(fd, sections, ZKEY_FF_HEADER_SECTION);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await readBigInt(fd, n8q);\n    zkey.curve = await getCurveFromQ(zkey.q, options);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await readBigInt(fd, n8r);\n\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = log2(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.w3 = await fd.read(n8r);\n    zkey.w4 = await fd.read(n8r);\n    zkey.w8 = await fd.read(n8r);\n    zkey.wr = await fd.read(n8r);\n\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    zkey.C0 = await readG1(fd, zkey.curve, toObject);\n\n    await endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readZKey(fileName, toObject) {\n    const {fd, sections} = await readBinFile(fileName, \"zkey\", 1);\n\n    const zkey = await readHeader$1(fd, sections, toObject);\n\n    const Fr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.F1Field(zkey.r);\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.shl(1, zkey.n8r*8), zkey.r);\n    const Rri = Fr.inv(Rr);\n    const Rri2 = Fr.mul(Rri, Rri);\n\n    let curve = await getCurveFromQ(zkey.q);\n\n    // Read IC Section\n    ///////////\n    await startReadUniqueSection(fd, sections, 3);\n    zkey.IC = [];\n    for (let i=0; i<= zkey.nPublic; i++) {\n        const P = await readG1(fd, curve, toObject);\n        zkey.IC.push(P);\n    }\n    await endReadSection(fd);\n\n\n    // Read Coefs\n    ///////////\n    await startReadUniqueSection(fd, sections, 4);\n    const nCCoefs = await fd.readULE32();\n    zkey.ccoefs = [];\n    for (let i=0; i<nCCoefs; i++) {\n        const m = await fd.readULE32();\n        const c = await fd.readULE32();\n        const s = await fd.readULE32();\n        const v = await readFr2();\n        zkey.ccoefs.push({\n            matrix: m,\n            constraint: c,\n            signal: s,\n            value: v\n        });\n    }\n    await endReadSection(fd);\n\n    // Read A points\n    ///////////\n    await startReadUniqueSection(fd, sections, 5);\n    zkey.A = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const A = await readG1(fd, curve, toObject);\n        zkey.A[i] = A;\n    }\n    await endReadSection(fd);\n\n\n    // Read B1\n    ///////////\n    await startReadUniqueSection(fd, sections, 6);\n    zkey.B1 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B1 = await readG1(fd, curve, toObject);\n\n        zkey.B1[i] = B1;\n    }\n    await endReadSection(fd);\n\n\n    // Read B2 points\n    ///////////\n    await startReadUniqueSection(fd, sections, 7);\n    zkey.B2 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B2 = await readG2(fd, curve, toObject);\n        zkey.B2[i] = B2;\n    }\n    await endReadSection(fd);\n\n\n    // Read C points\n    ///////////\n    await startReadUniqueSection(fd, sections, 8);\n    zkey.C = [];\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        const C = await readG1(fd, curve, toObject);\n\n        zkey.C[i] = C;\n    }\n    await endReadSection(fd);\n\n\n    // Read H points\n    ///////////\n    await startReadUniqueSection(fd, sections, 9);\n    zkey.hExps = [];\n    for (let i=0; i<zkey.domainSize; i++) {\n        const H = await readG1(fd, curve, toObject);\n        zkey.hExps.push(H);\n    }\n    await endReadSection(fd);\n\n    await fd.close();\n\n    return zkey;\n\n    async function readFr2(/* toObject */) {\n        const n = await readBigInt(fd, zkey.n8r);\n        return Fr.mul(n, Rri2);\n    }\n\n}\n\n\nasync function readContribution$1(fd, curve, toObject) {\n    const c = {delta:{}};\n    c.deltaAfter = await readG1(fd, curve, toObject);\n    c.delta.g1_s = await readG1(fd, curve, toObject);\n    c.delta.g1_sx = await readG1(fd, curve, toObject);\n    c.delta.g2_spx = await readG2(fd, curve, toObject);\n    c.transcript = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await fd.read(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await fd.read(1);\n            const buffStr = await fd.read(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await fd.read(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await fd.read(1);\n            c.beaconHash = await fd.read(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n}\n\n\nasync function readMPCParams(fd, curve, sections) {\n    await startReadUniqueSection(fd, sections, 10);\n    const res = { contributions: []};\n    res.csHash = await fd.read(64);\n    const n = await fd.readULE32();\n    for (let i=0; i<n; i++) {\n        const c = await readContribution$1(fd, curve);\n        res.contributions.push(c);\n    }\n    await endReadSection(fd);\n\n    return res;\n}\n\nasync function writeContribution$1(fd, curve, c) {\n    await writeG1(fd, curve, c.deltaAfter);\n    await writeG1(fd, curve, c.delta.g1_s);\n    await writeG1(fd, curve, c.delta.g1_sx);\n    await writeG2(fd, curve, c.delta.g2_spx);\n    await fd.write(c.transcript);\n    await fd.writeULE32(c.type || 0);\n\n    const params = [];\n    if (c.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(c.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (c.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(c.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(c.beaconHash.byteLength);\n        for (let i=0; i<c.beaconHash.byteLength; i++) params.push(c.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n}\n\nasync function writeMPCParams(fd, curve, mpcParams) {\n    await startWriteSection(fd, 10);\n    await fd.write(mpcParams.csHash);\n    await fd.writeULE32(mpcParams.contributions.length);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        await writeContribution$1(fd, curve,mpcParams.contributions[i]);\n    }\n    await endWriteSection(fd);\n}\n\nfunction hashG1(hasher, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashG2(hasher,curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashPubKey(hasher, curve, c) {\n    hashG1(hasher, curve, c.deltaAfter);\n    hashG1(hasher, curve, c.delta.g1_s);\n    hashG1(hasher, curve, c.delta.g1_sx);\n    hashG2(hasher, curve, c.delta.g2_spx);\n    hasher.update(c.transcript);\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function write(fd, witness, prime) {\n\n    await startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await writeBigInt(fd, prime, n8);\n    await fd.writeULE32(witness.length);\n    await endWriteSection(fd);\n\n    await startWriteSection(fd, 2);\n    for (let i=0; i<witness.length; i++) {\n        await writeBigInt(fd, witness[i], n8);\n    }\n    await endWriteSection(fd);\n\n\n}\n\nasync function writeBin(fd, witnessBin, prime) {\n\n    await startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await writeBigInt(fd, prime, n8);\n    if (witnessBin.byteLength % n8 != 0) {\n        throw new Error(\"Invalid witness length\");\n    }\n    await fd.writeULE32(witnessBin.byteLength / n8);\n    await endWriteSection(fd);\n\n\n    await startWriteSection(fd, 2);\n    await fd.write(witnessBin);\n    await endWriteSection(fd);\n\n}\n\nasync function readHeader(fd, sections) {\n\n    await startReadUniqueSection(fd, sections, 1);\n    const n8 = await fd.readULE32();\n    const q = await readBigInt(fd, n8);\n    const nWitness = await fd.readULE32();\n    await endReadSection(fd);\n\n    return {n8, q, nWitness};\n\n}\n\nasync function read(fileName) {\n\n    const {fd, sections} = await readBinFile(fileName, \"wtns\", 2);\n\n    const {n8, nWitness} = await readHeader(fd, sections);\n\n    await startReadUniqueSection(fd, sections, 2);\n    const res = [];\n    for (let i=0; i<nWitness; i++) {\n        const v = await readBigInt(fd, n8);\n        res.push(v);\n    }\n    await endReadSection(fd);\n\n    await fd.close();\n\n    return res;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {stringifyBigInts: stringifyBigInts$4} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function groth16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await readBinFile(witnessFileName, \"wtns\", 2);\n\n    const wtns = await readHeader(fdWtns, sectionsWtns);\n\n    const {fd: fdZKey, sections: sectionsZKey} = await readBinFile(zkeyFileName, \"zkey\", 2);\n\n    const zkey = await readHeader$1(fdZKey, sectionsZKey, undefined, options);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);\n    }\n\n    const curve = zkey.curve;\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    const power = log2(zkey.domainSize);\n\n    if (logger) logger.debug(\"Reading Wtns\");\n    const buffWitness = await readSection(fdWtns, sectionsWtns, 2);\n    if (logger) logger.debug(\"Reading Coeffs\");\n    const buffCoeffs = await readSection(fdZKey, sectionsZKey, 4);\n\n    if (logger) logger.debug(\"Building ABC\");\n    const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve, zkey, buffWitness, buffCoeffs, logger);\n\n    const inc = power == Fr.s ? curve.Fr.shift : curve.Fr.w[power+1];\n\n    const buffA = await Fr.ifft(buffA_T, \"\", \"\", logger, \"IFFT_A\");\n    const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);\n    const buffAodd_T = await Fr.fft(buffAodd, \"\", \"\", logger, \"FFT_A\");\n\n    const buffB = await Fr.ifft(buffB_T, \"\", \"\", logger, \"IFFT_B\");\n    const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);\n    const buffBodd_T = await Fr.fft(buffBodd, \"\", \"\", logger, \"FFT_B\");\n\n    const buffC = await Fr.ifft(buffC_T, \"\", \"\", logger, \"IFFT_C\");\n    const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);\n    const buffCodd_T = await Fr.fft(buffCodd, \"\", \"\", logger, \"FFT_C\");\n\n    if (logger) logger.debug(\"Join ABC\");\n    const buffPodd_T = await joinABC(curve, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);\n\n    let proof = {};\n\n    if (logger) logger.debug(\"Reading A Points\");\n    const buffBasesA = await readSection(fdZKey, sectionsZKey, 5);\n    proof.pi_a = await curve.G1.multiExpAffine(buffBasesA, buffWitness, logger, \"multiexp A\");\n\n    if (logger) logger.debug(\"Reading B1 Points\");\n    const buffBasesB1 = await readSection(fdZKey, sectionsZKey, 6);\n    let pib1 = await curve.G1.multiExpAffine(buffBasesB1, buffWitness, logger, \"multiexp B1\");\n\n    if (logger) logger.debug(\"Reading B2 Points\");\n    const buffBasesB2 = await readSection(fdZKey, sectionsZKey, 7);\n    proof.pi_b = await curve.G2.multiExpAffine(buffBasesB2, buffWitness, logger, \"multiexp B2\");\n\n    if (logger) logger.debug(\"Reading C Points\");\n    const buffBasesC = await readSection(fdZKey, sectionsZKey, 8);\n    proof.pi_c = await curve.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic+1)*curve.Fr.n8), logger, \"multiexp C\");\n\n    if (logger) logger.debug(\"Reading H Points\");\n    const buffBasesH = await readSection(fdZKey, sectionsZKey, 9);\n    const resH = await curve.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, \"multiexp H\");\n\n    const r = curve.Fr.random();\n    const s = curve.Fr.random();\n\n    proof.pi_a  = G1.add( proof.pi_a, zkey.vk_alpha_1 );\n    proof.pi_a  = G1.add( proof.pi_a, G1.timesFr( zkey.vk_delta_1, r ));\n\n    proof.pi_b  = G2.add( proof.pi_b, zkey.vk_beta_2 );\n    proof.pi_b  = G2.add( proof.pi_b, G2.timesFr( zkey.vk_delta_2, s ));\n\n    pib1 = G1.add( pib1, zkey.vk_beta_1 );\n    pib1 = G1.add( pib1, G1.timesFr( zkey.vk_delta_1, s ));\n\n    proof.pi_c = G1.add(proof.pi_c, resH);\n\n\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( proof.pi_a, s ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( pib1, r ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( zkey.vk_delta_1, Fr.neg(Fr.mul(r,s) )));\n\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const b = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(b));\n    }\n\n    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));\n    proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));\n    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));\n\n    proof.protocol = \"groth16\";\n    proof.curve = curve.name;\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    proof = stringifyBigInts$4(proof);\n    publicSignals = stringifyBigInts$4(publicSignals);\n\n    return {proof, publicSignals};\n}\n\n\nasync function buildABC1(curve, zkey, witness, coeffs, logger) {\n    const n8 = curve.Fr.n8;\n    const sCoef = 4*3 + zkey.n8r;\n    const nCoef = (coeffs.byteLength-4) / sCoef;\n\n    const outBuffA = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(zkey.domainSize * n8);\n    const outBuffB = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(zkey.domainSize * n8);\n    const outBuffC = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(zkey.domainSize * n8);\n\n    const outBuf = [ outBuffA, outBuffB ];\n    for (let i=0; i<nCoef; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP AB: ${i}/${nCoef}`);\n        const buffCoef = coeffs.slice(4+i*sCoef, 4+i*sCoef+sCoef);\n        const buffCoefV = new DataView(buffCoef.buffer);\n        const m= buffCoefV.getUint32(0, true);\n        const c= buffCoefV.getUint32(4, true);\n        const s= buffCoefV.getUint32(8, true);\n        const coef = buffCoef.slice(12, 12+n8);\n        outBuf[m].set(\n            curve.Fr.add(\n                outBuf[m].slice(c*n8, c*n8+n8),\n                curve.Fr.mul(coef, witness.slice(s*n8, s*n8+n8))\n            ),\n            c*n8\n        );\n    }\n\n    for (let i=0; i<zkey.domainSize; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP C: ${i}/${zkey.domainSize}`);\n        outBuffC.set(\n            curve.Fr.mul(\n                outBuffA.slice(i*n8, i*n8+n8),\n                outBuffB.slice(i*n8, i*n8+n8),\n            ),\n            i*n8\n        );\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n}\n\n/*\nasync function buildABC(curve, zkey, witness, coeffs, logger) {\n    const concurrency = curve.tm.concurrency;\n    const sCoef = 4*3 + zkey.n8r;\n\n    let getUint32;\n\n    if (coeffs instanceof BigBuffer) {\n        const coeffsDV = [];\n        const PAGE_LEN = coeffs.buffers[0].length;\n        for (let i=0; i< coeffs.buffers.length; i++) {\n            coeffsDV.push(new DataView(coeffs.buffers[i].buffer));\n        }\n        getUint32 = function (pos) {\n            return coeffsDV[Math.floor(pos/PAGE_LEN)].getUint32(pos % PAGE_LEN, true);\n        };\n    } else {\n        const coeffsDV = new DataView(coeffs.buffer, coeffs.byteOffset, coeffs.byteLength);\n        getUint32 = function (pos) {\n            return coeffsDV.getUint32(pos, true);\n        };\n    }\n\n    const elementsPerChunk = Math.floor(zkey.domainSize/concurrency);\n    const promises = [];\n\n    const cutPoints = [];\n    for (let i=0; i<concurrency; i++) {\n        cutPoints.push( getCutPoint( Math.floor(i*elementsPerChunk) ));\n    }\n    cutPoints.push(coeffs.byteLength);\n\n    const chunkSize = 2**26;\n    for (let s=0 ; s<zkey.nVars ; s+= chunkSize) {\n        if (logger) logger.debug(`QAP ${s}: ${s}/${zkey.nVars}`);\n        const ns= Math.min(zkey.nVars-s, chunkSize );\n\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = elementsPerChunk;\n            } else {\n                n = zkey.domainSize - i*elementsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: coeffs.slice(cutPoints[i], cutPoints[i+1])});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: witness.slice(s*curve.Fr.n8, (s+ns)*curve.Fr.n8)});\n            task.push({cmd: \"ALLOC\", var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 4, len: n*curve.Fr.n8});\n            task.push({cmd: \"CALL\", fnName: \"qap_buildABC\", params:[\n                {var: 0},\n                {val: (cutPoints[i+1] - cutPoints[i])/sCoef},\n                {var: 1},\n                {var: 2},\n                {var: 3},\n                {var: 4},\n                {val: i*elementsPerChunk},\n                {val: n},\n                {val: s},\n                {val: ns}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 1, var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 2, var: 4, len: n*curve.Fr.n8});\n            promises.push(curve.tm.queueAction(task));\n        }\n    }\n\n    let result = await Promise.all(promises);\n\n    const nGroups = result.length / concurrency;\n    if (nGroups>1) {\n        const promises2 = [];\n        for (let i=0; i<concurrency; i++) {\n            const task=[];\n            task.push({cmd: \"ALLOC\", var: 0, len: result[i][0].byteLength});\n            task.push({cmd: \"ALLOC\", var: 1, len: result[i][0].byteLength});\n            for (let m=0; m<3; m++) {\n                task.push({cmd: \"SET\", var: 0, buff: result[i][m]});\n                for (let s=1; s<nGroups; s++) {\n                    task.push({cmd: \"SET\", var: 1, buff: result[s*concurrency + i][m]});\n                    task.push({cmd: \"CALL\", fnName: \"qap_batchAdd\", params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: result[i][m].length/curve.Fr.n8},\n                        {var: 0}\n                    ]});\n                }\n                task.push({cmd: \"GET\", out: m, var: 0, len: result[i][m].length});\n            }\n            promises2.push(curve.tm.queueAction(task));\n        }\n        result = await Promise.all(promises2);\n    }\n\n    const outBuffA = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuffA.set(result[i][0], p);\n        outBuffB.set(result[i][1], p);\n        outBuffC.set(result[i][2], p);\n        p += result[i][0].byteLength;\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n    function getCutPoint(v) {\n        let m = 0;\n        let n = getUint32(0);\n        while (m < n) {\n            var k = Math.floor((n + m) / 2);\n            const va = getUint32(4 + k*sCoef + 4);\n            if (va > v) {\n                n = k - 1;\n            } else if (va < v) {\n                m = k + 1;\n            } else {\n                n = k;\n            }\n        }\n        return 4 + m*sCoef;\n    }\n}\n*/\n\nasync function joinABC(curve, zkey, a, b, c, logger) {\n    const MAX_CHUNK_SIZE = 1 << 22;\n\n    const n8 = curve.Fr.n8;\n    const nElements = Math.floor(a.byteLength / curve.Fr.n8);\n\n    const promises = [];\n\n    for (let i=0; i<nElements; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`JoinABC: ${i}/${nElements}`);\n        const n= Math.min(nElements - i, MAX_CHUNK_SIZE);\n\n        const task = [];\n\n        const aChunk = a.slice(i*n8, (i + n)*n8 );\n        const bChunk = b.slice(i*n8, (i + n)*n8 );\n        const cChunk = c.slice(i*n8, (i + n)*n8 );\n\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: aChunk});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: bChunk});\n        task.push({cmd: \"ALLOCSET\", var: 2, buff: cChunk});\n        task.push({cmd: \"ALLOC\", var: 3, len: n*n8});\n        task.push({cmd: \"CALL\", fnName: \"qap_joinABC\", params:[\n            {var: 0},\n            {var: 1},\n            {var: 2},\n            {val: n},\n            {var: 3},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"frm_batchFromMontgomery\", params:[\n            {var: 3},\n            {val: n},\n            {var: 3}\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 3, len: n*n8});\n        promises.push(curve.tm.queueAction(task));\n    }\n\n    const result = await Promise.all(promises);\n\n    let outBuff;\n    if (a instanceof ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer) {\n        outBuff = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(a.byteLength);\n    } else {\n        outBuff = new Uint8Array(a.byteLength);\n    }\n\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuff.set(result[i][0], p);\n        p += result[i][0].byteLength;\n    }\n\n    return outBuff;\n}\n\n/*\n\nCopyright 2020 0KIMS association.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nfunction flatArray(a) {\n    let res = [];\n    fillArray(res, a);\n    return res;\n\n    function fillArray(res, a) {\n        if (Array.isArray(a)) {\n            for (let i = 0; i < a.length; i++) {\n                fillArray(res, a[i]);\n            }\n        } else {\n            res.push(a);\n        }\n    }\n}\n\n// Ref https://github.com/iden3/circom/commit/ec6388cf6eb62463539cb4c40cc3ceae9826de19\nfunction normalize(n, prime) {\n    let res = BigInt(n) % prime;\n    if (res < 0) res += prime;\n    return res;\n}\n\nfunction fnvHash(str) {\n    const uint64_max = BigInt(2) ** BigInt(64);\n    let hash = BigInt(\"0xCBF29CE484222325\");\n    for (let i = 0; i < str.length; i++) {\n        hash ^= BigInt(str[i].charCodeAt(0));\n        hash *= BigInt(0x100000001B3);\n        hash %= uint64_max;\n    }\n    let shash = hash.toString(16);\n    let n = 16 - shash.length;\n    shash = \"0\".repeat(n).concat(shash);\n    return shash;\n}\n\n// Note that this pads zeros\nfunction toArray32(s, size) {\n    const res = []; //new Uint32Array(size); //has no unshift\n    let rem = BigInt(s);\n    const radix = BigInt(0x100000000);\n    while (rem) {\n        res.unshift(Number(rem % radix));\n        rem = rem / radix;\n    }\n    if (size) {\n        let i = size - res.length;\n        while (i > 0) {\n            res.unshift(0);\n            i--;\n        }\n    }\n    return res;\n}\n\n/* globals WebAssembly */\n\nasync function builder(code, options) {\n    let instance;\n    let wc;\n    let memory;\n    options = options || {};\n\n    // Only circom 2 implements version lookup through exports in the WASM\n    // We default to `1` and update if we see the `getVersion` export (major version)\n    // These are updated after the instance is instantiated, assuming the functions are available\n    let majorVersion = 1;\n    // After Circom 2.0.7, Blaine added exported functions for getting minor and patch versions\n    let minorVersion = 0;\n    // If we can't look up the patch version, assume the lowest\n    let patchVersion = 0;\n\n    let codeIsWebAssemblyInstance = false;\n\n    // If code is already prepared WebAssembly.Instance, we use it directly\n    if (code instanceof WebAssembly.Instance) {\n        instance = code;\n        codeIsWebAssemblyInstance = true;\n    } else {\n        let memorySize = 32767;\n\n        if (options.memorySize) {\n            // make sure we have int\n            memorySize = parseInt(options.memorySize);\n            if (memorySize < 0) {\n                throw new Error(\"Invalid memory size\");\n            }\n        }\n\n        let memoryAllocated = false;\n        while (!memoryAllocated) {\n            try {\n                memory = new WebAssembly.Memory({initial: memorySize});\n                memoryAllocated = true;\n            } catch (err) {\n                if (memorySize <= 1) {\n                    throw err;\n                }\n                console.warn(\"Could not allocate \" + memorySize * 1024 * 64 + \" bytes. This may cause severe instability. Trying with \" + memorySize * 1024 * 64 / 2 + \" bytes\");\n                memorySize = Math.floor(memorySize / 2);\n            }\n        }\n\n        const wasmModule = await WebAssembly.compile(code);\n\n        let errStr = \"\";\n        let msgStr = \"\";\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            },\n            runtime: {\n                printDebug : function(value) {\n                    console.log(\"printDebug:\", value);\n                },\n                exceptionHandler: function (code) {\n                    let err;\n                    if (code === 1) {\n                        err = \"Signal not found. \";\n                    } else if (code === 2) {\n                        err = \"Too many signals set. \";\n                    } else if (code === 3) {\n                        err = \"Signal already set. \";\n                    } else if (code === 4) {\n                        err = \"Assert Failed. \";\n                    } else if (code === 5) {\n                        err = \"Not enough memory. \";\n                    } else if (code === 6) {\n                        err = \"Input signal array access exceeds the size. \";\n                    } else {\n                        err = \"Unknown error. \";\n                    }\n                    console.error(\"ERROR: \", code, errStr);\n                    throw new Error(err + errStr);\n                },\n                // A new way of logging messages was added in Circom 2.0.7 that requires 2 new imports\n                // `printErrorMessage` and `writeBufferMessage`.\n                printErrorMessage: function () {\n                    errStr += getMessage() + \"\\n\";\n                },\n                writeBufferMessage: function () {\n                    const msg = getMessage();\n                    // Any calls to `log()` will always end with a `\\n`, so that's when we print and reset\n                    if (msg === \"\\n\") {\n                        console.log(msgStr);\n                        msgStr = \"\";\n                    } else {\n                        // If we've buffered other content, put a space in between the items\n                        if (msgStr !== \"\") {\n                            msgStr += \" \";\n                        }\n                        // Then append the message to the message we are creating\n                        msgStr += msg;\n                    }\n                },\n                showSharedRWMemory: function () {\n                    const shared_rw_memory_size = instance.exports.getFieldNumLen32();\n                    const arr = new Uint32Array(shared_rw_memory_size);\n                    for (let j = 0; j < shared_rw_memory_size; j++) {\n                        arr[shared_rw_memory_size - 1 - j] = instance.exports.readSharedRWMemory(j);\n                    }\n\n                    // In circom 2.0.7, they changed the log() function to allow strings and changed the\n                    // output API. This smoothes over the breaking change.\n                    if (majorVersion >= 2 && (minorVersion >= 1 || patchVersion >= 7)) {\n                        // If we've buffered other content, put a space in between the items\n                        if (msgStr !== \"\") {\n                            msgStr += \" \";\n                        }\n                        // Then append the value to the message we are creating\n                        const msg = (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromArray(arr, 0x100000000).toString());\n                        msgStr += msg;\n                    } else {\n                        console.log(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromArray(arr, 0x100000000));\n                    }\n                },\n                error: function (code, pstr, a, b, c, d) {\n                    let errStr;\n                    if (code === 7) {\n                        errStr = p2str(pstr) + \" \" + wc.getFr(b).toString() + \" != \" + wc.getFr(c).toString() + \" \" + p2str(d);\n                    } else if (code === 9) {\n                        errStr = p2str(pstr) + \" \" + wc.getFr(b).toString() + \" \" + p2str(c);\n                    } else if ((code === 5) && (options.sym)) {\n                        errStr = p2str(pstr) + \" \" + options.sym.labelIdx2Name[c];\n                    } else {\n                        errStr = p2str(pstr) + \" \" + a + \" \" + b + \" \" + c + \" \" + d;\n                    }\n                    console.log(\"ERROR: \", code, errStr);\n                    throw new Error(errStr);\n                },\n                log: function (a) {\n                    console.log(wc.getFr(a).toString());\n                },\n                logGetSignal: function (signal, pVal) {\n                    if (options.logGetSignal) {\n                        options.logGetSignal(signal, wc.getFr(pVal));\n                    }\n                },\n                logSetSignal: function (signal, pVal) {\n                    if (options.logSetSignal) {\n                        options.logSetSignal(signal, wc.getFr(pVal));\n                    }\n                },\n                logStartComponent: function (cIdx) {\n                    if (options.logStartComponent) {\n                        options.logStartComponent(cIdx);\n                    }\n                },\n                logFinishComponent: function (cIdx) {\n                    if (options.logFinishComponent) {\n                        options.logFinishComponent(cIdx);\n                    }\n                }\n            }\n        });\n    }\n\n    if (typeof instance.exports.getVersion == \"function\") {\n        majorVersion = instance.exports.getVersion();\n    }\n    if (typeof instance.exports.getMinorVersion == \"function\") {\n        minorVersion = instance.exports.getMinorVersion();\n    }\n    if (typeof instance.exports.getPatchVersion == \"function\") {\n        patchVersion = instance.exports.getPatchVersion();\n    }\n\n    const sanityCheck =\n        options &&\n        (\n            options.sanityCheck ||\n            options.logGetSignal ||\n            options.logSetSignal ||\n            options.logStartComponent ||\n            options.logFinishComponent\n        );\n\n    // We explicitly check for major version 2 in case there's a circom v3 in the future\n    if (majorVersion === 2) {\n        wc = new WitnessCalculatorCircom2(instance, sanityCheck);\n    } else if (majorVersion === 1) {\n        if (codeIsWebAssemblyInstance) {\n            throw new Error('Loading code from WebAssembly instance is not supported for circom version 1');\n        }\n        wc = new WitnessCalculatorCircom1(memory, instance, sanityCheck);\n    } else {\n        throw new Error(`Unsupported circom version: ${majorVersion}`);\n    }\n    return wc;\n\n    function getMessage() {\n        let message = \"\";\n        let c = instance.exports.getMessageChar();\n        while (c !== 0) {\n            message += String.fromCharCode(c);\n            c = instance.exports.getMessageChar();\n        }\n        return message;\n    }\n\n    function p2str(p) {\n        const i8 = new Uint8Array(memory.buffer);\n\n        const bytes = [];\n\n        for (let i = 0; i8[p + i] > 0; i++) bytes.push(i8[p + i]);\n\n        return String.fromCharCode.apply(null, bytes);\n    }\n}\n\nclass WitnessCalculatorCircom1 {\n    constructor(memory, instance, sanityCheck) {\n        this.memory = memory;\n        this.i32 = new Uint32Array(memory.buffer);\n        this.instance = instance;\n\n        this.n32 = (this.instance.exports.getFrLen() >> 2) - 2;\n        const pRawPrime = this.instance.exports.getPRawPrime();\n\n        const arr = new Array(this.n32);\n        for (let i = 0; i < this.n32; i++) {\n            arr[this.n32 - 1 - i] = this.i32[(pRawPrime >> 2) + i];\n        }\n\n        this.prime = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromArray(arr, 0x100000000);\n\n        this.Fr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.F1Field(this.prime);\n\n        this.mask32 = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromString(\"FFFFFFFF\", 16);\n        this.NVars = this.instance.exports.getNVars();\n        this.n64 = Math.floor((this.Fr.bitLength - 1) / 64) + 1;\n        this.R = this.Fr.e(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.shiftLeft(1, this.n64 * 64));\n        this.RInv = this.Fr.inv(this.R);\n        this.sanityCheck = sanityCheck;\n    }\n\n    circom_version() {\n        return 1;\n    }\n\n    async _doCalculateWitness(input, sanityCheck) {\n        this.instance.exports.init((this.sanityCheck || sanityCheck) ? 1 : 0);\n        const pSigOffset = this.allocInt();\n        const pFr = this.allocFr();\n        const keys = Object.keys(input);\n        keys.forEach((k) => {\n            const h = fnvHash(k);\n            const hMSB = parseInt(h.slice(0, 8), 16);\n            const hLSB = parseInt(h.slice(8, 16), 16);\n            try {\n                this.instance.exports.getSignalOffset32(pSigOffset, 0, hMSB, hLSB);\n            } catch (err) {\n                throw new Error(`Signal ${k} is not an input of the circuit.`);\n            }\n            const sigOffset = this.getInt(pSigOffset);\n            const fArr = flatArray(input[k]);\n            for (let i = 0; i < fArr.length; i++) {\n                this.setFr(pFr, fArr[i]);\n                this.instance.exports.setSignal(0, 0, sigOffset + i, pFr);\n            }\n        });\n    }\n\n    async calculateWitness(input, sanityCheck) {\n        const self = this;\n\n        const old0 = self.i32[0];\n        const w = [];\n\n        await self._doCalculateWitness(input, sanityCheck);\n\n        for (let i = 0; i < self.NVars; i++) {\n            const pWitness = self.instance.exports.getPWitness(i);\n            w.push(self.getFr(pWitness));\n        }\n\n        self.i32[0] = old0;\n        return w;\n    }\n\n    async calculateBinWitness(input, sanityCheck) {\n        const self = this;\n\n        const old0 = self.i32[0];\n\n        await self._doCalculateWitness(input, sanityCheck);\n\n        const pWitnessBuffer = self.instance.exports.getWitnessBuffer();\n\n        self.i32[0] = old0;\n\n        const buff = self.memory.buffer.slice(pWitnessBuffer, pWitnessBuffer + (self.NVars * self.n64 * 8));\n        return new Uint8Array(buff);\n    }\n\n    allocInt() {\n        const p = this.i32[0];\n        this.i32[0] = p + 8;\n        return p;\n    }\n\n    allocFr() {\n        const p = this.i32[0];\n        this.i32[0] = p + this.n32 * 4 + 8;\n        return p;\n    }\n\n    getInt(p) {\n        return this.i32[p >> 2];\n    }\n\n    setInt(p, v) {\n        this.i32[p >> 2] = v;\n    }\n\n    getFr(p) {\n        const self = this;\n        const idx = (p >> 2);\n\n        if (self.i32[idx + 1] & 0x80000000) {\n            const arr = new Array(self.n32);\n            for (let i = 0; i < self.n32; i++) {\n                arr[self.n32 - 1 - i] = self.i32[idx + 2 + i];\n            }\n            const res = self.Fr.e(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromArray(arr, 0x100000000));\n            if (self.i32[idx + 1] & 0x40000000) {\n                return fromMontgomery(res);\n            } else {\n                return res;\n            }\n\n        } else {\n            if (self.i32[idx] & 0x80000000) {\n                return self.Fr.e(self.i32[idx] - 0x100000000);\n            } else {\n                return self.Fr.e(self.i32[idx]);\n            }\n        }\n\n        function fromMontgomery(n) {\n            return self.Fr.mul(self.RInv, n);\n        }\n\n    }\n\n\n    setFr(p, v) {\n        const self = this;\n\n        v = self.Fr.e(v);\n\n        const minShort = self.Fr.neg(self.Fr.e(\"80000000\", 16));\n        const maxShort = self.Fr.e(\"7FFFFFFF\", 16);\n\n        if ((self.Fr.geq(v, minShort))\n            && (self.Fr.leq(v, maxShort))) {\n            let a;\n            if (self.Fr.geq(v, self.Fr.zero)) {\n                a = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toNumber(v);\n            } else {\n                a = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toNumber(self.Fr.sub(v, minShort));\n                a = a - 0x80000000;\n                a = 0x100000000 + a;\n            }\n            self.i32[(p >> 2)] = a;\n            self.i32[(p >> 2) + 1] = 0;\n            return;\n        }\n\n        self.i32[(p >> 2)] = 0;\n        self.i32[(p >> 2) + 1] = 0x80000000;\n        const arr = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toArray(v, 0x100000000);\n        for (let i = 0; i < self.n32; i++) {\n            const idx = arr.length - 1 - i;\n\n            if (idx >= 0) {\n                self.i32[(p >> 2) + 2 + i] = arr[idx];\n            } else {\n                self.i32[(p >> 2) + 2 + i] = 0;\n            }\n        }\n    }\n}\n\nclass WitnessCalculatorCircom2 {\n    constructor(instance, sanityCheck) {\n        this.instance = instance;\n\n        this.version = this.instance.exports.getVersion();\n        this.n32 = this.instance.exports.getFieldNumLen32();\n\n        this.instance.exports.getRawPrime();\n        const arr = new Uint32Array(this.n32);\n        for (let i = 0; i < this.n32; i++) {\n            arr[this.n32 - 1 - i] = this.instance.exports.readSharedRWMemory(i);\n        }\n        this.prime = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromArray(arr, 0x100000000);\n\n        this.witnessSize = this.instance.exports.getWitnessSize();\n\n        this.sanityCheck = sanityCheck;\n    }\n\n    circom_version() {\n        return this.instance.exports.getVersion();\n    }\n\n    async _doCalculateWitness(input, sanityCheck) {\n        //input is assumed to be a map from signals to arrays of bigints\n        this.instance.exports.init((this.sanityCheck || sanityCheck) ? 1 : 0);\n        const keys = Object.keys(input);\n        let input_counter = 0;\n        keys.forEach((k) => {\n            const h = fnvHash(k);\n            const hMSB = parseInt(h.slice(0, 8), 16);\n            const hLSB = parseInt(h.slice(8, 16), 16);\n            const fArr = flatArray(input[k]);\n            // Slight deviation from https://github.com/iden3/circom/blob/v2.1.6/code_producers/src/wasm_elements/common/witness_calculator.js\n            // because I don't know when this exported function was added\n            if (typeof this.instance.exports.getInputSignalSize === \"function\") {\n                let signalSize = this.instance.exports.getInputSignalSize(hMSB, hLSB);\n                if (signalSize < 0) {\n                    throw new Error(`Signal ${k} not found\\n`);\n                }\n                if (fArr.length < signalSize) {\n                    throw new Error(`Not enough values for input signal ${k}\\n`);\n                }\n                if (fArr.length > signalSize) {\n                    throw new Error(`Too many values for input signal ${k}\\n`);\n                }\n            }\n            for (let i = 0; i < fArr.length; i++) {\n                const arrFr = toArray32(normalize(fArr[i], this.prime), this.n32);\n                for (let j = 0; j < this.n32; j++) {\n                    this.instance.exports.writeSharedRWMemory(j, arrFr[this.n32 - 1 - j]);\n                }\n                try {\n                    this.instance.exports.setInputSignal(hMSB, hLSB, i);\n                    input_counter++;\n                } catch (err) {\n                    // console.log(`After adding signal ${i} of ${k}`)\n                    throw new Error(err);\n                }\n            }\n\n        });\n        if (input_counter < this.instance.exports.getInputSize()) {\n            throw new Error(`Not all inputs have been set. Only ${input_counter} out of ${this.instance.exports.getInputSize()}`);\n        }\n    }\n\n    async calculateWitness(input, sanityCheck) {\n        const w = [];\n\n        await this._doCalculateWitness(input, sanityCheck);\n\n        for (let i = 0; i < this.witnessSize; i++) {\n            this.instance.exports.getWitness(i);\n            const arr = new Uint32Array(this.n32);\n            for (let j = 0; j < this.n32; j++) {\n                arr[this.n32 - 1 - j] = this.instance.exports.readSharedRWMemory(j);\n            }\n            w.push(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromArray(arr, 0x100000000));\n        }\n\n        return w;\n    }\n\n    async calculateWTNSBin(input, sanityCheck) {\n        const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);\n        const buff = new Uint8Array(buff32.buffer);\n        await this._doCalculateWitness(input, sanityCheck);\n\n        //\"wtns\"\n        buff[0] = \"w\".charCodeAt(0);\n        buff[1] = \"t\".charCodeAt(0);\n        buff[2] = \"n\".charCodeAt(0);\n        buff[3] = \"s\".charCodeAt(0);\n\n        //version 2\n        buff32[1] = 2;\n\n        //number of sections: 2\n        buff32[2] = 2;\n\n        //id section 1\n        buff32[3] = 1;\n\n        const n8 = this.n32 * 4;\n        //id section 1 length in 64bytes\n        const idSection1length = 8 + n8;\n        const idSection1lengthHex = idSection1length.toString(16);\n        buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);\n        buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);\n\n        //this.n32\n        buff32[6] = n8;\n\n        //prime number\n        this.instance.exports.getRawPrime();\n\n        let pos = 7;\n        for (let j = 0; j < this.n32; j++) {\n            buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n        }\n        pos += this.n32;\n\n        // witness size\n        buff32[pos] = this.witnessSize;\n        pos++;\n\n        //id section 2\n        buff32[pos] = 2;\n        pos++;\n\n        // section 2 length\n        const idSection2length = n8 * this.witnessSize;\n        const idSection2lengthHex = idSection2length.toString(16);\n        buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);\n        buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);\n\n        pos += 2;\n        for (let i = 0; i < this.witnessSize; i++) {\n            this.instance.exports.getWitness(i);\n            for (let j = 0; j < this.n32; j++) {\n                buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n            }\n            pos += this.n32;\n        }\n\n        return buff;\n    }\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst { unstringifyBigInts: unstringifyBigInts$b} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {\n    const input = unstringifyBigInts$b(_input);\n\n    const fdWasm = await readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wc = await builder(wasm, options);\n    if (wc.circom_version() === 1) {\n        const w = await wc.calculateBinWitness(input);\n\n        const fdWtns = await createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n        await writeBin(fdWtns, w, wc.prime);\n        await fdWtns.close();\n    } else {\n        const fdWtns = await createOverride(wtnsFileName);\n\n        const w = await wc.calculateWTNSBin(input);\n\n        await fdWtns.write(w);\n        await fdWtns.close();\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {unstringifyBigInts: unstringifyBigInts$a} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function groth16FullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts$a(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await wtnsCalculate(input, wasmFile, wtns, wtnsCalcOptions);\n    return await groth16Prove(zkeyFileName, wtns, logger, proverOptions);\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {unstringifyBigInts: unstringifyBigInts$9} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {\n/*\n    let cpub = vk_verifier.IC[0];\n    for (let s= 0; s< vk_verifier.nPublic; s++) {\n        cpub  = G1.add( cpub, G1.timesScalar( vk_verifier.IC[s+1], publicSignals[s]));\n    }\n*/\n\n    const vk_verifier = unstringifyBigInts$9(_vk_verifier);\n    const proof = unstringifyBigInts$9(_proof);\n    const publicSignals = unstringifyBigInts$9(_publicSignals);\n\n    const curve = await getCurveFromName(vk_verifier.curve);\n\n    const IC0 = curve.G1.fromObject(vk_verifier.IC[0]);\n    const IC = new Uint8Array(curve.G1.F.n8*2 * publicSignals.length);\n    const w = new Uint8Array(curve.Fr.n8 * publicSignals.length);\n\n    if (!publicInputsAreValid$2(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    for (let i=0; i<publicSignals.length; i++) {\n        const buffP = curve.G1.fromObject(vk_verifier.IC[i+1]);\n        IC.set(buffP, i*curve.G1.F.n8*2);\n        ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(w, curve.Fr.n8*i, publicSignals[i], curve.Fr.n8);\n    }\n\n    let cpub = await curve.G1.multiExpAffine(IC, w);\n    cpub = curve.G1.add(cpub, IC0);\n\n    const pi_a = curve.G1.fromObject(proof.pi_a);\n    const pi_b = curve.G2.fromObject(proof.pi_b);\n    const pi_c = curve.G1.fromObject(proof.pi_c);\n\n    if (!isWellConstructed$1(curve, {pi_a, pi_b, pi_c})) {\n        if(logger) logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    const vk_gamma_2 = curve.G2.fromObject(vk_verifier.vk_gamma_2);\n    const vk_delta_2 = curve.G2.fromObject(vk_verifier.vk_delta_2);\n    const vk_alpha_1 = curve.G1.fromObject(vk_verifier.vk_alpha_1);\n    const vk_beta_2 = curve.G2.fromObject(vk_verifier.vk_beta_2);\n\n    const res = await curve.pairingEq(\n        curve.G1.neg(pi_a) , pi_b,\n        cpub , vk_gamma_2,\n        pi_c , vk_delta_2,\n\n        vk_alpha_1, vk_beta_2\n    );\n\n    if (! res) {\n        if (logger) logger.error(\"Invalid proof\");\n        return false;\n    }\n\n    if (logger) logger.info(\"OK!\");\n    return true;\n}\n\nfunction isWellConstructed$1(curve, proof) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    return G1.isValid(proof.pi_a)\n        && G2.isValid(proof.pi_b)\n        && G1.isValid(proof.pi_c);\n}\n\nfunction checkValueBelongToField$2(curve, value) {\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.geq(value, 0) && ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.lt(value, curve.r);\n}\n\nfunction publicInputsAreValid$2(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField$2(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst { unstringifyBigInts: unstringifyBigInts$8} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nfunction p256$2(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function groth16ExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts$8(_proof);\n    const pub = unstringifyBigInts$8(_pub);\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256$2(pub[i]);\n    }\n\n    let S;\n    S=`[${p256$2(proof.pi_a[0])}, ${p256$2(proof.pi_a[1])}],` +\n        `[[${p256$2(proof.pi_b[0][1])}, ${p256$2(proof.pi_b[0][0])}],[${p256$2(proof.pi_b[1][1])}, ${p256$2(proof.pi_b[1][0])}]],` +\n        `[${p256$2(proof.pi_c[0])}, ${p256$2(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar groth16 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    fullProve: groth16FullProve,\n    prove: groth16Prove,\n    verify: groth16Verify,\n    exportSolidityCallData: groth16ExportSolidityCallData\n});\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nfunction hashToG2(curve, hash) {\n    const hashV = new DataView(hash.buffer, hash.byteOffset, hash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = hashV.getUint32(i*4);\n    }\n\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.ChaCha(seed);\n\n    const g2_sp = curve.G2.fromRng(rng);\n\n    return g2_sp;\n}\n\nfunction getG2sp(curve, persinalization, challenge, g1s, g1sx) {\n\n    const h = blake2b.create({ dkLen: 64 });\n    const b1 = new Uint8Array([persinalization]);\n    h.update(b1);\n    h.update(challenge);\n    const b3 = curve.G1.toUncompressed(g1s);\n    h.update( b3);\n    const b4 = curve.G1.toUncompressed(g1sx);\n    h.update( b4);\n    const hash =h.digest();\n\n    return hashToG2(curve, hash);\n}\n\nfunction calculatePubKey(k, curve, personalization, challengeHash, rng ) {\n    k.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    k.g1_sx = curve.G1.toAffine(curve.G1.timesFr(k.g1_s, k.prvKey));\n    k.g2_sp = curve.G2.toAffine(getG2sp(curve, personalization, challengeHash, k.g1_s, k.g1_sx));\n    k.g2_spx = curve.G2.toAffine(curve.G2.timesFr(k.g2_sp, k.prvKey));\n    return k;\n}\n\nfunction createPTauKey(curve, challengeHash, rng) {\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n    key.tau.prvKey = curve.Fr.fromRng(rng);\n    key.alpha.prvKey = curve.Fr.fromRng(rng);\n    key.beta.prvKey = curve.Fr.fromRng(rng);\n    calculatePubKey(key.tau, curve, 0, challengeHash, rng);\n    calculatePubKey(key.alpha, curve, 1, challengeHash, rng);\n    calculatePubKey(key.beta, curve, 2, challengeHash, rng);\n    return key;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function writePTauHeader(fd, curve, power, ceremonyPower) {\n    // Write the header\n    ///////////\n\n    if (! ceremonyPower) ceremonyPower = power;\n    await fd.writeULE32(1); // Header type\n    const pHeaderSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(curve.F1.n64*8);\n\n    const buff = new Uint8Array(curve.F1.n8);\n    ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(buff, 0, curve.q, curve.F1.n8);\n    await fd.write(buff);\n    await fd.writeULE32(power);                    // power\n    await fd.writeULE32(ceremonyPower);               // power\n\n    const headerSize = fd.pos - pHeaderSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(headerSize, pHeaderSize);\n\n    fd.pos = oldPos;\n}\n\nasync function readPTauHeader(fd, sections) {\n    if (!sections[1])  throw new Error(fd.fileName + \": File has no  header\");\n    if (sections[1].length>1) throw new Error(fd.fileName +\": File has more than one header\");\n\n    fd.pos = sections[1][0].p;\n    const n8 = await fd.readULE32();\n    const buff = await fd.read(n8);\n    const q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(buff);\n\n    const curve = await getCurveFromQ(q);\n\n    if (curve.F1.n64*8 != n8) throw new Error(fd.fileName +\": Invalid size\");\n\n    const power = await fd.readULE32();\n    const ceremonyPower = await fd.readULE32();\n\n    if (fd.pos-sections[1][0].p != sections[1][0].size) throw new Error(\"Invalid PTau header size\");\n\n    return {curve, power, ceremonyPower};\n}\n\n\nasync function readPtauPubKey(fd, curve, montgomery) {\n\n    const buff = await fd.read(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n\n    return fromPtauPubKeyRpr(buff, 0, curve, montgomery);\n}\n\nfunction fromPtauPubKeyRpr(buff, pos, curve, montgomery) {\n\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n\n    key.tau.g1_s = readG1();\n    key.tau.g1_sx = readG1();\n    key.alpha.g1_s = readG1();\n    key.alpha.g1_sx = readG1();\n    key.beta.g1_s = readG1();\n    key.beta.g1_sx = readG1();\n    key.tau.g2_spx = readG2();\n    key.alpha.g2_spx = readG2();\n    key.beta.g2_spx = readG2();\n\n    return key;\n\n    function readG1() {\n        let p;\n        if (montgomery) {\n            p = curve.G1.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G1.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G1.F.n8*2;\n        return p;\n    }\n\n    function readG2() {\n        let p;\n        if (montgomery) {\n            p = curve.G2.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G2.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G2.F.n8*2;\n        return p;\n    }\n}\n\nfunction toPtauPubKeyRpr(buff, pos, curve, key, montgomery) {\n\n    writeG1(key.tau.g1_s);\n    writeG1(key.tau.g1_sx);\n    writeG1(key.alpha.g1_s);\n    writeG1(key.alpha.g1_sx);\n    writeG1(key.beta.g1_s);\n    writeG1(key.beta.g1_sx);\n    writeG2(key.tau.g2_spx);\n    writeG2(key.alpha.g2_spx);\n    writeG2(key.beta.g2_spx);\n\n    async function writeG1(p) {\n        if (montgomery) {\n            curve.G1.toRprLEM(buff, pos, p);\n        } else {\n            curve.G1.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F1.n8*2;\n    }\n\n    async function writeG2(p) {\n        if (montgomery) {\n            curve.G2.toRprLEM(buff, pos, p);\n        } else {\n            curve.G2.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F2.n8*2;\n    }\n\n    return buff;\n}\n\nasync function writePtauPubKey(fd, curve, key, montgomery) {\n    const buff = new Uint8Array(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n    toPtauPubKeyRpr(buff, 0, curve, key, montgomery);\n    await fd.write(buff);\n}\n\nasync function readContribution(fd, curve) {\n    const c = {};\n\n    c.tauG1 = await readG1();\n    c.tauG2 = await readG2();\n    c.alphaG1 = await readG1();\n    c.betaG1 = await readG1();\n    c.betaG2 = await readG2();\n    c.key = await readPtauPubKey(fd, curve, true);\n    c.partialHash = await fd.read(216);\n    c.nextChallenge = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n    toPtauPubKeyRpr(buffV, 0, curve, c.key, false);\n\n    const responseHasher =  fromPartialHash(c.partialHash);\n    responseHasher.update(buffV);\n    c.responseHash = responseHasher.digest();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await readDV(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await readDV(1);\n            const buffStr = await readDV(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await readDV(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await readDV(1);\n            c.beaconHash = await readDV(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n\n    async function readG1() {\n        const pBuff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprLEM( pBuff );\n    }\n\n    async function readG2() {\n        const pBuff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprLEM( pBuff );\n    }\n\n    async function readDV(n) {\n        const b = await fd.read(n);\n        return new Uint8Array(b);\n    }\n}\n\nasync function readContributions(fd, curve, sections) {\n    if (!sections[7])  throw new Error(fd.fileName + \": File has no  contributions\");\n    if (sections[7][0].length>1) throw new Error(fd.fileName +\": File has more than one contributions section\");\n\n    fd.pos = sections[7][0].p;\n    const nContributions = await fd.readULE32();\n    const contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = await readContribution(fd, curve);\n        c.id = i+1;\n        contributions.push(c);\n    }\n\n    if (fd.pos-sections[7][0].p != sections[7][0].size) throw new Error(\"Invalid contribution section size\");\n\n    return contributions;\n}\n\nasync function writeContribution(fd, curve, contribution) {\n\n    const buffG1 = new Uint8Array(curve.F1.n8*2);\n    const buffG2 = new Uint8Array(curve.F2.n8*2);\n    await writeG1(contribution.tauG1);\n    await writeG2(contribution.tauG2);\n    await writeG1(contribution.alphaG1);\n    await writeG1(contribution.betaG1);\n    await writeG2(contribution.betaG2);\n    await writePtauPubKey(fd, curve, contribution.key, true);\n    await fd.write(contribution.partialHash);\n    await fd.write(contribution.nextChallenge);\n    await fd.writeULE32(contribution.type || 0);\n\n    const params = [];\n    if (contribution.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(contribution.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (contribution.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(contribution.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(contribution.beaconHash.byteLength);\n        for (let i=0; i<contribution.beaconHash.byteLength; i++) params.push(contribution.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n\n    async function writeG1(p) {\n        curve.G1.toRprLEM(buffG1, 0, p);\n        await fd.write(buffG1);\n    }\n\n    async function writeG2(p) {\n        curve.G2.toRprLEM(buffG2, 0, p);\n        await fd.write(buffG2);\n    }\n\n}\n\nasync function writeContributions(fd, curve, contributions) {\n\n    await fd.writeULE32(7); // Header type\n    const pContributionsSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(contributions.length);\n    for (let i=0; i< contributions.length; i++) {\n        await writeContribution(fd, curve, contributions[i]);\n    }\n    const contributionsSize = fd.pos - pContributionsSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(contributionsSize, pContributionsSize);\n    fd.pos = oldPos;\n}\n\nfunction calculateFirstChallengeHash(curve, power, logger) {\n    if (logger) logger.debug(\"Calculating First Challenge Hash\");\n\n    const hasher = blake2b.create({ dkLen: 64 });\n\n    const vG1 = new Uint8Array(curve.G1.F.n8*2);\n    const vG2 = new Uint8Array(curve.G2.F.n8*2);\n    curve.G1.toRprUncompressed(vG1, 0, curve.G1.g);\n    curve.G2.toRprUncompressed(vG2, 0, curve.G2.g);\n\n    hasher.update(blake2b.create({ dkLen: 64 }).digest());\n\n    let n;\n\n    n=(2 ** power)*2 -1;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG1\");\n    hashBlock(vG1, n);\n    n= 2 ** power;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG2\");\n    hashBlock(vG2, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: alphaTauG1\");\n    hashBlock(vG1, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: betaTauG1\");\n    hashBlock(vG1, n);\n    hasher.update(vG2);\n\n    return hasher.digest();\n\n    function hashBlock(buff, n) {\n        // this block size is a good compromise between speed and the maximum\n        // input size of the Blake2b update method (65,535,720 bytes).\n        const blockSize = 341000;\n        const nBlocks = Math.floor(n / blockSize);\n        const rem = n % blockSize;\n        const bigBuff = new Uint8Array(blockSize * buff.byteLength);\n        for (let i=0; i<blockSize; i++) {\n            bigBuff.set(buff, i*buff.byteLength);\n        }\n        for (let i=0; i<nBlocks; i++) {\n            hasher.update(bigBuff);\n            if (logger) logger.debug(\"Initial hash: \" +i*blockSize);\n        }\n        for (let i=0; i<rem; i++) {\n            hasher.update(buff);\n        }\n    }\n}\n\n\nasync function keyFromBeacon(curve, challengeHash, beaconHash, numIterationsExp) {\n\n    const rng = await rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const key = createPTauKey(curve, challengeHash, rng);\n\n    return key;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function newAccumulator(curve, power, fileName, logger) {\n\n    const fd = await createBinFile(fileName, \"ptau\", 1, 7);\n\n    await writePTauHeader(fd, curve, power, 0);\n\n    const buffG1 = curve.G1.oneAffine;\n    const buffG2 = curve.G2.oneAffine;\n\n    // Write tauG1\n    ///////////\n    await startWriteSection(fd, 2);\n    const nTauG1 = (2 ** power) * 2 -1;\n    for (let i=0; i< nTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG1: \" + i);\n    }\n    await endWriteSection(fd);\n\n    // Write tauG2\n    ///////////\n    await startWriteSection(fd, 3);\n    const nTauG2 = (2 ** power);\n    for (let i=0; i< nTauG2; i++) {\n        await fd.write(buffG2);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG2: \" + i);\n    }\n    await endWriteSection(fd);\n\n    // Write alphaTauG1\n    ///////////\n    await startWriteSection(fd, 4);\n    const nAlfaTauG1 = (2 ** power);\n    for (let i=0; i< nAlfaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"alphaTauG1: \" + i);\n    }\n    await endWriteSection(fd);\n\n    // Write betaTauG1\n    ///////////\n    await startWriteSection(fd, 5);\n    const nBetaTauG1 = (2 ** power);\n    for (let i=0; i< nBetaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"betaTauG1: \" + i);\n    }\n    await endWriteSection(fd);\n\n    // Write betaG2\n    ///////////\n    await startWriteSection(fd, 6);\n    await fd.write(buffG2);\n    await endWriteSection(fd);\n\n    // Contributions\n    ///////////\n    await startWriteSection(fd, 7);\n    await fd.writeULE32(0); // 0 Contributions\n    await endWriteSection(fd);\n\n    await fd.close();\n\n    const firstChallengeHash = calculateFirstChallengeHash(curve, power, logger);\n\n    if (logger) logger.debug(formatHash(blake2b.create({ dkLen: 64 }).digest(), \"Blank Contribution Hash:\"));\n\n    if (logger) logger.info(formatHash(firstChallengeHash, \"First Contribution Hash:\"));\n\n    return firstChallengeHash;\n\n}\n\n// Format of the outpu\n\nasync function exportChallenge(pTauFilename, challengeFilename, logger) {\n    const {fd: fdFrom, sections} = await readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await readPTauHeader(fdFrom, sections);\n\n    const contributions = await readContributions(fdFrom, curve, sections);\n    let lastResponseHash, curChallengeHash;\n    if (contributions.length == 0) {\n        lastResponseHash = blake2b.create({ dkLen: 64 }).digest();\n        curChallengeHash = calculateFirstChallengeHash(curve, power);\n    } else {\n        lastResponseHash = contributions[contributions.length-1].responseHash;\n        curChallengeHash = contributions[contributions.length-1].nextChallenge;\n    }\n\n    if (logger) logger.info(formatHash(lastResponseHash, \"Last Response Hash: \"));\n\n    if (logger) logger.info(formatHash(curChallengeHash, \"New Challenge Hash: \"));\n\n\n    const fdTo = await createOverride(challengeFilename);\n\n    const toHash = blake2b.create({ dkLen: 64 });\n    await fdTo.write(lastResponseHash);\n    toHash.update(lastResponseHash);\n\n    await exportSection(2, \"G1\", (2 ** power) * 2 -1, \"tauG1\");\n    await exportSection(3, \"G2\", (2 ** power)       , \"tauG2\");\n    await exportSection(4, \"G1\", (2 ** power)       , \"alphaTauG1\");\n    await exportSection(5, \"G1\", (2 ** power)       , \"betaTauG1\");\n    await exportSection(6, \"G2\", 1                  , \"betaG2\");\n\n    await fdFrom.close();\n    await fdTo.close();\n\n    const calcCurChallengeHash = toHash.digest();\n\n    if (!hashIsEqual (curChallengeHash, calcCurChallengeHash)) {\n        if (logger) logger.info(formatHash(calcCurChallengeHash, \"Calc Curret Challenge Hash: \"));\n\n        if (logger) logger.error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n        throw new Error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n    }\n\n    return curChallengeHash;\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        await startReadUniqueSection(fdFrom, sections, sectionId);\n        for (let i=0; i< nPoints; i+= nPointsChunk) {\n            if (logger) logger.debug(`Exporting ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n            let buff;\n            buff = await fdFrom.read(n*sG);\n            buff = await G.batchLEMtoU(buff);\n            await fdTo.write(buff);\n            toHash.update(buff);\n        }\n        await endReadSection(fdFrom);\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger) {\n\n    const noHash = new Uint8Array(64);\n    for (let i=0; i<64; i++) noHash[i] = 0xFF;\n\n    const {fd: fdOld, sections} = await readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await readPTauHeader(fdOld, sections);\n    const contributions = await readContributions(fdOld, curve, sections);\n    const currentContribution = {};\n\n    if (name) currentContribution.name = name;\n\n    const sG1 = curve.F1.n8*2;\n    const scG1 = curve.F1.n8; // Compressed size\n    const sG2 = curve.F2.n8*2;\n    const scG2 = curve.F2.n8; // Compressed size\n\n    const fdResponse = await readExisting(contributionFilename);\n\n    if  (fdResponse.totalSize !=\n        64 +                            // Old Hash\n        ((2 ** power)*2-1)*scG1 +\n        (2 ** power)*scG2 +\n        (2 ** power)*scG1 +\n        (2 ** power)*scG1 +\n        scG2 +\n        sG1*6 + sG2*3)\n        throw new Error(\"Size of the contribution is invalid\");\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    const fdNew = await createBinFile(newPTauFilename, \"ptau\", 1, importPoints ? 7: 2);\n    await writePTauHeader(fdNew, curve, power);\n\n    const contributionPreviousHash = await fdResponse.read(64);\n\n    if (hashIsEqual(noHash,lastChallengeHash)) {\n        lastChallengeHash = contributionPreviousHash;\n        contributions[contributions.length-1].nextChallenge = lastChallengeHash;\n    }\n\n    if(!hashIsEqual(contributionPreviousHash,lastChallengeHash))\n        throw new Error(\"Wrong contribution. This contribution is not based on the previous hash\");\n\n    const hasherResponse = blake2b.create({ dkLen: 64 });\n    hasherResponse.update(contributionPreviousHash);\n\n    const startSections = [];\n    let res;\n    res = await processSection(fdResponse, fdNew, \"G1\", 2, (2 ** power) * 2 -1, [1], \"tauG1\");\n    currentContribution.tauG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 3, (2 ** power)       , [1], \"tauG2\");\n    currentContribution.tauG2 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 4, (2 ** power)       , [0], \"alphaG1\");\n    currentContribution.alphaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 5, (2 ** power)       , [0], \"betaG1\");\n    currentContribution.betaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 6, 1                  , [0], \"betaG2\");\n    currentContribution.betaG2 = res[0];\n\n    currentContribution.partialHash = toPartialHash(hasherResponse);\n\n\n    const buffKey = await fdResponse.read(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    currentContribution.key = fromPtauPubKeyRpr(buffKey, 0, curve, false);\n\n    hasherResponse.update(new Uint8Array(buffKey));\n    const hashResponse = hasherResponse.digest();\n\n    if (logger) logger.info(formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    if (importPoints) {\n        const nextChallengeHasher = blake2b.create({ dkLen: 64 });\n        nextChallengeHasher.update(hashResponse);\n\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n        currentContribution.nextChallenge = nextChallengeHasher.digest();\n\n        if (logger) logger.info(formatHash(currentContribution.nextChallenge, \"Next Challenge Hash: \"));\n    } else {\n        currentContribution.nextChallenge = noHash;\n    }\n\n    contributions.push(currentContribution);\n\n    await writeContributions(fdNew, curve, contributions);\n\n    await fdResponse.close();\n    await fdNew.close();\n    await fdOld.close();\n\n    return currentContribution.nextChallenge;\n\n    async function processSection(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n        if (importPoints) {\n            return await processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        } else {\n            return await processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        }\n    }\n\n    async function processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n        const sG = G.F.n8*2;\n\n        const singularPoints = [];\n\n        await startWriteSection(fdTo, sectionId);\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        startSections[sectionId] = fdTo.pos;\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            const buffLEM = await G.batchCtoLEM(buffC);\n\n            await fdTo.write(buffLEM);\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(buffLEM, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        await endWriteSection(fdTo);\n\n        return singularPoints;\n    }\n\n\n    async function processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n\n        const singularPoints = [];\n\n        const nPointsChunk = Math.floor((1<<24)/scG);\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprCompressed(buffC, (sp-i)*scG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        return singularPoints;\n    }\n\n\n    async function hashSection(nextChallengeHasher, fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst sameRatio$1 = sameRatio$2;\n\nasync function verifyContribution(curve, cur, prev, logger) {\n    let sr;\n    if (cur.type == 1) {    // Verify the beacon.\n        const beaconKey = await keyFromBeacon(curve, prev.nextChallenge, cur.beaconHash, cur.numIterationsExp);\n\n        if (!curve.G1.eq(cur.key.tau.g1_s, beaconKey.tau.g1_s)) {\n            if (logger) logger.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.tau.g1_sx, beaconKey.tau.g1_sx)) {\n            if (logger) logger.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.tau.g2_spx, beaconKey.tau.g2_spx)) {\n            if (logger) logger.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.alpha.g1_s, beaconKey.alpha.g1_s)) {\n            if (logger) logger.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.alpha.g1_sx, beaconKey.alpha.g1_sx)) {\n            if (logger) logger.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.alpha.g2_spx, beaconKey.alpha.g2_spx)) {\n            if (logger) logger.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.beta.g1_s, beaconKey.beta.g1_s)) {\n            if (logger) logger.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.beta.g1_sx, beaconKey.beta.g1_sx)) {\n            if (logger) logger.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.beta.g2_spx, beaconKey.beta.g2_spx)) {\n            if (logger) logger.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n    }\n\n    cur.key.tau.g2_sp = curve.G2.toAffine(getG2sp(curve, 0, prev.nextChallenge, cur.key.tau.g1_s, cur.key.tau.g1_sx));\n    cur.key.alpha.g2_sp = curve.G2.toAffine(getG2sp(curve, 1, prev.nextChallenge, cur.key.alpha.g1_s, cur.key.alpha.g1_sx));\n    cur.key.beta.g2_sp = curve.G2.toAffine(getG2sp(curve, 2, prev.nextChallenge, cur.key.beta.g1_s, cur.key.beta.g1_sx));\n\n    sr = await sameRatio$1(curve, cur.key.tau.g1_s, cur.key.tau.g1_sx, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (tau) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio$1(curve, cur.key.alpha.g1_s, cur.key.alpha.g1_sx, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (alpha) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio$1(curve, cur.key.beta.g1_s, cur.key.beta.g1_sx, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (beta) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio$1(curve, prev.tauG1, cur.tauG1, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio$1(curve,  cur.key.tau.g1_s, cur.key.tau.g1_sx, prev.tauG2, cur.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G2. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio$1(curve, prev.alphaG1, cur.alphaG1, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID alpha*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio$1(curve, prev.betaG1, cur.betaG1, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio$1(curve,  cur.key.beta.g1_s, cur.key.beta.g1_sx, prev.betaG2, cur.betaG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G2. challenge #\"+cur.id+\"It does not follow the previous contribution\");\n        return false;\n    }\n\n    if (logger) logger.info(\"Powers Of tau file OK!\");\n    return true;\n}\n\nasync function verify(tauFilename, logger) {\n    let sr;\n\n    const {fd, sections} = await readBinFile(tauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await readPTauHeader(fd, sections);\n    const contrs = await readContributions(fd, curve, sections);\n\n    if (logger) logger.debug(\"power: 2**\" + power);\n    // Verify Last contribution\n\n    if (logger) logger.debug(\"Computing initial contribution hash\");\n    const initialContribution = {\n        tauG1: curve.G1.g,\n        tauG2: curve.G2.g,\n        alphaG1: curve.G1.g,\n        betaG1: curve.G1.g,\n        betaG2: curve.G2.g,\n        nextChallenge: calculateFirstChallengeHash(curve, ceremonyPower, logger),\n        responseHash: blake2b.create({ dkLen: 64 }).digest()\n    };\n\n    if (contrs.length == 0) {\n        if (logger) logger.error(\"This file has no contribution! It cannot be used in production\");\n        return false;\n    }\n\n    let prevContr;\n    if (contrs.length>1) {\n        prevContr = contrs[contrs.length-2];\n    } else {\n        prevContr = initialContribution;\n    }\n    const curContr = contrs[contrs.length-1];\n    if (logger) logger.debug(\"Validating contribution #\"+contrs[contrs.length-1].id);\n    const res = await verifyContribution(curve, curContr, prevContr, logger);\n    if (!res) return false;\n\n\n    const nextContributionHasher = blake2b.create({ dkLen: 64 });\n    nextContributionHasher.update(curContr.responseHash);\n\n    // Verify powers and compute nextChallengeHash\n\n    // await test();\n\n    // Verify Section tau*G1\n    if (logger) logger.debug(\"Verifying powers in tau*G1 section\");\n    const rTau1 = await processSection(2, \"G1\", \"tauG1\", (2 ** power)*2-1, [0, 1], logger);\n    sr = await sameRatio$1(curve, rTau1.R1, rTau1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curve.G1.g, rTau1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G1 section must be the generator\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.tauG1, rTau1.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G1 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // await test();\n\n    // Verify Section tau*G2\n    if (logger) logger.debug(\"Verifying powers in tau*G2 section\");\n    const rTau2 = await processSection(3, \"G2\", \"tauG2\", 2 ** power, [0, 1],  logger);\n    sr = await sameRatio$1(curve, curve.G1.g, curContr.tauG1, rTau2.R1, rTau2.R2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG2 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G2.eq(curve.G2.g, rTau2.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G2 section must be the generator\");\n        return false;\n    }\n    if (!curve.G2.eq(curContr.tauG2, rTau2.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section alpha*tau*G1\n    if (logger) logger.debug(\"Verifying powers in alpha*tau*G1 section\");\n    const rAlphaTauG1 = await processSection(4, \"G1\", \"alphatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio$1(curve, rAlphaTauG1.R1, rAlphaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"alphaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.alphaG1, rAlphaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section beta*tau*G1\n    if (logger) logger.debug(\"Verifying powers in beta*tau*G1 section\");\n    const rBetaTauG1 = await processSection(5, \"G1\", \"betatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio$1(curve, rBetaTauG1.R1, rBetaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"betaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.betaG1, rBetaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    //Verify Beta G2\n    const betaG2 = await processSectionBetaG2(logger);\n    if (!curve.G2.eq(curContr.betaG2, betaG2)) {\n        if (logger) logger.error(\"betaG2 element in betaG2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n\n    const nextContributionHash = nextContributionHasher.digest();\n\n    // Check the nextChallengeHash\n    if (power == ceremonyPower) {\n        if (!hashIsEqual(nextContributionHash,curContr.nextChallenge)) {\n            if (logger) logger.error(\"Hash of the values does not match the next challenge of the last contributor in the contributions section\");\n            return false;\n        }\n    }\n\n    if (logger) logger.info(formatHash(nextContributionHash, \"Next challenge hash: \"));\n\n    // Verify Previous contributions\n\n    printContribution(curContr, prevContr);\n    for (let i = contrs.length-2; i>=0; i--) {\n        const curContr = contrs[i];\n        const prevContr =  (i>0) ? contrs[i-1] : initialContribution;\n        const res = await verifyContribution(curve, curContr, prevContr, logger);\n        if (!res) return false;\n        printContribution(curContr, prevContr);\n    }\n    if (logger) logger.info(\"-----------------------------------------------------\");\n\n    if ((!sections[12]) || (!sections[13]) || (!sections[14]) || (!sections[15])) {\n        if (logger) logger.warn(\n            \"this file does not contain phase2 precalculated values. Please run: \\n\" +\n            \"   snarkjs \\\"powersoftau preparephase2\\\" to prepare this file to be used in the phase2 ceremony.\"\n        );\n    } else {\n        let res;\n        res = await verifyLagrangeEvaluations(\"G1\", 2, 12, \"tauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G2\", 3, 13, \"tauG2\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 4, 14, \"alphaTauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 5, 15, \"betaTauG1\", logger);\n        if (!res) return false;\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"Powers of Tau Ok!\");\n\n    return true;\n\n    function printContribution(curContr, prevContr) {\n        if (!logger) return;\n        logger.info(\"-----------------------------------------------------\");\n        logger.info(`Contribution #${curContr.id}: ${curContr.name ||\"\"}`);\n\n        logger.info(formatHash(curContr.nextChallenge, \"Next Challenge: \"));\n\n        const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n        toPtauPubKeyRpr(buffV, 0, curve, curContr.key, false);\n\n        const responseHasher =  fromPartialHash(curContr.partialHash);\n        responseHasher.update(buffV);\n        const responseHash = responseHasher.digest();\n\n        logger.info(formatHash(responseHash, \"Response Hash:\"));\n\n        logger.info(formatHash(prevContr.nextChallenge, \"Response Hash:\"));\n\n        if (curContr.type == 1) {\n            logger.info(`Beacon generator: ${byteArray2hex(curContr.beaconHash)}`);\n            logger.info(`Beacon iterations Exp: ${curContr.numIterationsExp}`);\n        }\n\n    }\n\n    async function processSectionBetaG2(logger) {\n        const G = curve.G2;\n        const sG = G.F.n8*2;\n        const buffUv = new Uint8Array(sG);\n\n        if (!sections[6])  {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has no BetaG2 section\");\n        }\n        if (sections[6].length>1) {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has more than one GetaG2 section\");\n        }\n        fd.pos = sections[6][0].p;\n\n        const buff = await fd.read(sG);\n        const P = G.fromRprLEM(buff);\n\n        G.toRprUncompressed(buffUv, 0, P);\n        nextContributionHasher.update(buffUv);\n\n        return P;\n    }\n\n    async function processSection(idSection, groupName, sectionName, nPoints, singularPointIndexes, logger) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await startReadUniqueSection(fd, sections, idSection);\n\n        const singularPoints = [];\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        let lastBase = G.zero;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`points relations: ${sectionName}: ${i}/${nPoints} `);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases = await fd.read(n*sG);\n\n            const basesU = await G.batchLEMtoU(bases);\n            nextContributionHasher.update(basesU);\n\n            const scalars = getRandomBytes(4*(n-1));\n\n            if (i>0) {\n                const firstBase = G.fromRprLEM(bases, 0);\n                const r = readUInt32BE(getRandomBytes(4), 0);\n\n                R1 = G.add(R1, G.timesScalar(lastBase, r));\n                R2 = G.add(R2, G.timesScalar(firstBase, r));\n            }\n\n            const r1 = await G.multiExpAffine(bases.slice(0, (n-1)*sG), scalars);\n            const r2 = await G.multiExpAffine(bases.slice(sG), scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n\n            lastBase = G.fromRprLEM( bases, (n-1)*sG);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(bases, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n\n        }\n        await endReadSection(fd);\n\n        return {\n            R1: R1,\n            R2: R2,\n            singularPoints: singularPoints\n        };\n\n    }\n\n    async function verifyLagrangeEvaluations(gName, tauSection, lagrangeSection, sectionName, logger) {\n\n        if (logger) logger.debug(`Verifying phase2 calculated values ${sectionName}...`);\n        const G = curve[gName];\n        const sG = G.F.n8*2;\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = readUInt32BE(getRandomBytes(4), 0);\n        }\n\n        for (let p=0; p<= power; p ++) {\n            const res = await verifyPower(p);\n            if (!res) return false;\n        }\n\n        if (tauSection == 2) {\n            const res = await verifyPower(power+1);\n            if (!res) return false;\n        }\n\n        return true;\n\n        async function verifyPower(p) {\n            if (logger) logger.debug(`Power ${p}...`);\n            const n8r = curve.Fr.n8;\n            const nPoints = 2 ** p;\n            let buff_r = new Uint32Array(nPoints);\n            let buffG;\n\n            let rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.ChaCha(seed);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((p == power+1)&&(i == nPoints-1)) {\n                    buff_r[i] = 0;\n                } else {\n                    buff_r[i] = rng.nextU32();\n                }\n            }\n\n            buff_r = new Uint8Array(buff_r.buffer, buff_r.byteOffset, buff_r.byteLength);\n\n            if (logger) logger.debug(`reading points Powers${p}...`);\n            await startReadUniqueSection(fd, sections, tauSection);\n            buffG = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(nPoints*sG);\n            if (p == power+1) {\n                await fd.readToBuffer(buffG, 0, (nPoints-1)*sG);\n                buffG.set(curve.G1.zeroAffine, (nPoints-1)*sG);\n            } else {\n                await fd.readToBuffer(buffG, 0, nPoints*sG);\n            }\n            await endReadSection(fd, true);\n\n            const resTau = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p);\n\n            buff_r = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(nPoints * n8r);\n\n            rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.ChaCha(seed);\n\n            const buff4 = new Uint8Array(4);\n            const buff4V = new DataView(buff4.buffer);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((i != nPoints-1) || (p != power+1)) {\n                    buff4V.setUint32(0, rng.nextU32(), true);\n                    buff_r.set(buff4, i*n8r);\n                }\n            }\n\n            if (logger) logger.debug(`batchToMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchToMontgomery(buff_r);\n            if (logger) logger.debug(`fft ${p}...`);\n            buff_r = await curve.Fr.fft(buff_r);\n            if (logger) logger.debug(`batchFromMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchFromMontgomery(buff_r);\n\n            if (logger) logger.debug(`reading points Lagrange${p}...`);\n            await startReadUniqueSection(fd, sections, lagrangeSection);\n            fd.pos += sG*((2 ** p)-1);\n            await fd.readToBuffer(buffG, 0, nPoints*sG);\n            await endReadSection(fd, true);\n\n            const resLagrange = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p + \"_transformed\");\n\n            if (!G.eq(resTau, resLagrange)) {\n                if (logger) logger.error(\"Phase2 caclutation does not match with powers of tau\");\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This function creates a new section in the fdTo file with id idSection.\n    It multiplies the points in fdFrom by first, first*inc, first*inc^2, ....\n    nPoint Times.\n    It also updates the newChallengeHasher with the new points\n*/\n\nasync function applyKeyToSection(fdOld, sections, fdNew, idSection, curve, groupName, first, inc, sectionName, logger) {\n    const MAX_CHUNK_SIZE = 1 << 16;\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const nPoints = sections[idSection][0].size / sG;\n\n    await startReadUniqueSection(fdOld, sections,idSection );\n    await startWriteSection(fdNew, idSection);\n\n    let t = first;\n    for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`Applying key: ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints - i, MAX_CHUNK_SIZE);\n        let buff;\n        buff = await fdOld.read(n*sG);\n        buff = await G.batchApplyKey(buff, t, inc);\n        await fdNew.write(buff);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n\n    await endWriteSection(fdNew);\n    await endReadSection(fdOld);\n}\n\n\n\nasync function applyKeyToChallengeSection(fdOld, fdNew, responseHasher, curve, groupName, nPoints, first, inc, formatOut, sectionName, logger) {\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n    let t = first;\n    for (let i=0 ; i<nPoints ; i+= chunkSize) {\n        if (logger) logger.debug(`Applying key ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints-i, chunkSize );\n        const buffInU = await fdOld.read(n * sG);\n        const buffInLEM = await G.batchUtoLEM(buffInU);\n        const buffOutLEM = await G.batchApplyKey(buffInLEM, t, inc);\n        let buffOut;\n        if (formatOut == \"COMPRESSED\") {\n            buffOut = await G.batchLEMtoC(buffOutLEM);\n        } else {\n            buffOut = await G.batchLEMtoU(buffOutLEM);\n        }\n\n        if (responseHasher) responseHasher.update(buffOut);\n        await fdNew.write(buffOut);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function challengeContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    const fdFrom = await readExisting(challengeFilename);\n\n\n    const sG1 = curve.F1.n64*8*2;\n    const sG2 = curve.F2.n64*8*2;\n    const domainSize = (fdFrom.totalSize + sG1 - 64 - sG2) / (4*sG1 + sG2);\n    let e = domainSize;\n    let power = 0;\n    while (e>1) {\n        e = e /2;\n        power += 1;\n    }\n\n    if (2 ** power != domainSize) throw new Error(\"Invalid file size\");\n    if (logger) logger.debug(\"Power to tau size: \"+power);\n\n    const rng = await getRandomRng(entropy);\n\n    const fdTo = await createOverride(responseFileName);\n\n    // Calculate the hash\n    const challengeHasher = blake2b.create({ dkLen: 64 });\n    for (let i=0; i<fdFrom.totalSize; i+= fdFrom.pageSize) {\n        if (logger) logger.debug(`Hashing challenge ${i}/${fdFrom.totalSize}`);\n        const s = Math.min(fdFrom.totalSize - i, fdFrom.pageSize);\n        const buff = await fdFrom.read(s);\n        challengeHasher.update(buff);\n    }\n\n    const claimedHash = await fdFrom.read(64, 0);\n    if (logger) logger.info(formatHash(claimedHash, \"Claimed Previous Response Hash: \"));\n\n    const challengeHash = challengeHasher.digest();\n    if (logger) logger.info(formatHash(challengeHash, \"Current Challenge Hash: \"));\n\n    const key = createPTauKey(curve, challengeHash, rng);\n\n    if (logger) {\n        [\"tau\", \"alpha\", \"beta\"].forEach( (k) => {\n            logger.debug(k + \".g1_s: \" + curve.G1.toString(key[k].g1_s, 16));\n            logger.debug(k + \".g1_sx: \" + curve.G1.toString(key[k].g1_sx, 16));\n            logger.debug(k + \".g2_sp: \" + curve.G2.toString(key[k].g2_sp, 16));\n            logger.debug(k + \".g2_spx: \" + curve.G2.toString(key[k].g2_spx, 16));\n            logger.debug(\"\");\n        });\n    }\n\n    const responseHasher = blake2b.create({ dkLen: 64 });\n\n    await fdTo.write(challengeHash);\n    responseHasher.update(challengeHash);\n\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)*2-1, curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG1\"     , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G2\", (2 ** power)    , curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG2\"     , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.alpha.prvKey, key.tau.prvKey, \"COMPRESSED\", \"alphaTauG1\", logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG1\" , logger );\n    await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve, \"G2\", 1             , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG2\" , logger );\n\n    // Write and hash key\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n    toPtauPubKeyRpr(buffKey, 0, curve, key, false);\n    await fdTo.write(buffKey);\n    responseHasher.update(buffKey);\n    const responseHash = responseHasher.digest();\n    if (logger) logger.info(formatHash(responseHash, \"Contribution Response Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function beacon$1(oldPtauFilename, newPTauFilename, name,  beaconHashStr,numIterationsExp, logger) {\n    const beaconHash = hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections} = await readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        return false;\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 1, // Beacon\n        numIterationsExp: numIterationsExp,\n        beaconHash: beaconHash\n    };\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    curContribution.key = await keyFromBeacon(curve, lastChallengeHash, beaconHash, numIterationsExp);\n\n    const responseHasher = blake2b.create({ dkLen: 64 });\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\", logger );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\", logger );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\", logger );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\", logger );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\", logger );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = toPartialHash(responseHasher);\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = blake2b.create({ dkLen: 64 });\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName, logger) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`applying key${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function contribute(oldPtauFilename, newPTauFilename, name, entropy, logger) {\n\n    const {fd: fdOld, sections} = await readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        throw new Error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 0, // Beacon\n    };\n\n    let lastChallengeHash;\n\n    const rng = await getRandomRng(entropy);\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    // Generate a random key\n\n\n    curContribution.key = createPTauKey(curve, lastChallengeHash, rng);\n\n\n    const responseHasher = blake2b.create({ dkLen: 64 });\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\" );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\" );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\" );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\" );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\" );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = toPartialHash(responseHasher);\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = blake2b.create({ dkLen: 64 });\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\");\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\");\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\");\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\");\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\");\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`processing: ${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if ((logger)&&i) logger.debug(`Hashing ${sectionName}: ` + i);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function preparePhase2(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await readPTauHeader(fdOld, sections);\n\n    const fdNew = await createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await writePTauHeader(fdNew, curve, power);\n\n    await copySection(fdOld, sections, fdNew, 2);\n    await copySection(fdOld, sections, fdNew, 3);\n    await copySection(fdOld, sections, fdNew, 4);\n    await copySection(fdOld, sections, fdNew, 5);\n    await copySection(fdOld, sections, fdNew, 6);\n    await copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await processSection(3, 13, \"G2\", \"tauG2\" );\n    await processSection(4, 14, \"G1\", \"alphaTauG1\" );\n    await processSection(5, 15, \"G1\", \"betaTauG1\" );\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await startWriteSection(fdNew, newSectionId);\n\n        for (let p=0; p<=power; p++) {\n            await processSectionPower(p);\n        }\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await endWriteSection(fdNew);\n\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const sGin = G.F.n8*2;\n\n            let buff;\n            buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(nPoints*sGin);\n\n            await startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await endReadSection(fdOld, true);\n\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function truncate(ptauFilename, template, logger) {\n\n    const {fd: fdOld, sections} = await readBinFile(ptauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await readPTauHeader(fdOld, sections);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    for (let p=1; p<power; p++) {\n        await generateTruncate(p);\n    }\n\n    await fdOld.close();\n\n    return true;\n\n    async function generateTruncate(p) {\n\n        let sP = p.toString();\n        while (sP.length<2) sP = \"0\" + sP;\n\n        if (logger) logger.debug(\"Writing Power: \"+sP);\n\n        const fdNew = await createBinFile(template + sP + \".ptau\", \"ptau\", 1, 11);\n        await writePTauHeader(fdNew, curve, p, ceremonyPower);\n\n        await copySection(fdOld, sections, fdNew, 2, ((2 ** p)*2-1) * sG1 ); // tagG1\n        await copySection(fdOld, sections, fdNew, 3, (2 ** p) * sG2); // tauG2\n        await copySection(fdOld, sections, fdNew, 4, (2 ** p) * sG1); // alfaTauG1\n        await copySection(fdOld, sections, fdNew, 5, (2 ** p) * sG1); // betaTauG1\n        await copySection(fdOld, sections, fdNew, 6,  sG2); // betaTauG2\n        await copySection(fdOld, sections, fdNew, 7); // contributions\n        await copySection(fdOld, sections, fdNew, 12, ((2 ** (p+1))*2 -1) * sG1); // L_tauG1\n        await copySection(fdOld, sections, fdNew, 13, ((2 ** p)*2 -1) * sG2); // L_tauG2\n        await copySection(fdOld, sections, fdNew, 14, ((2 ** p)*2 -1) * sG1); // L_alfaTauG1\n        await copySection(fdOld, sections, fdNew, 15, ((2 ** p)*2 -1) * sG1); // L_betaTauG1\n\n        await fdNew.close();\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function convert(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await readPTauHeader(fdOld, sections);\n\n    const fdNew = await createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await writePTauHeader(fdNew, curve, power);\n\n    // const fdTmp = await fastFile.createOverride(newPTauFilename+ \".tmp\");\n\n    await copySection(fdOld, sections, fdNew, 2);\n    await copySection(fdOld, sections, fdNew, 3);\n    await copySection(fdOld, sections, fdNew, 4);\n    await copySection(fdOld, sections, fdNew, 5);\n    await copySection(fdOld, sections, fdNew, 6);\n    await copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await copySection(fdOld, sections, fdNew, 13);\n    await copySection(fdOld, sections, fdNew, 14);\n    await copySection(fdOld, sections, fdNew, 15);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await startWriteSection(fdNew, newSectionId);\n\n        const size = sections[newSectionId][0].size;\n        const chunkSize = fdOld.pageSize;\n        await startReadUniqueSection(fdOld, sections, newSectionId);\n        for (let p=0; p<size; p+=chunkSize) {\n            const l = Math.min(size -p, chunkSize);\n            const buff = await fdOld.read(l);\n            await fdNew.write(buff);\n        }\n        await endReadSection(fdOld);\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await endWriteSection(fdNew);\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const sGin = G.F.n8*2;\n\n            let buff;\n            buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(nPoints*sGin);\n\n            await startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await endReadSection(fdOld, true);\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    if (i%10000) logger.debug(`sectionName prepare L calc: ${sectionName}, ${i}/${smallM}`);\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t1\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n\n\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function exportJson(pTauFilename, verbose) {\n    const {fd, sections} = await readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await readPTauHeader(fd, sections);\n\n    const pTau = {};\n    pTau.q = curve.q;\n    pTau.power = power;\n    pTau.contributions = await readContributions(fd, curve, sections);\n\n    pTau.tauG1 = await exportSection(2, \"G1\", (2 ** power)*2 -1, \"tauG1\");\n    pTau.tauG2 = await exportSection(3, \"G2\", (2 ** power), \"tauG2\");\n    pTau.alphaTauG1 = await exportSection(4, \"G1\", (2 ** power), \"alphaTauG1\");\n    pTau.betaTauG1 = await exportSection(5, \"G1\", (2 ** power), \"betaTauG1\");\n    pTau.betaG2 = await exportSection(6, \"G2\", 1, \"betaG2\");\n\n    pTau.lTauG1 = await exportLagrange(12, \"G1\", \"lTauG1\");\n    pTau.lTauG2 = await exportLagrange(13, \"G2\", \"lTauG2\");\n    pTau.lAlphaTauG1 = await exportLagrange(14, \"G1\", \"lAlphaTauG2\");\n    pTau.lBetaTauG1 = await exportLagrange(15, \"G1\", \"lBetaTauG2\");\n\n    await fd.close();\n\n    return stringifyBigIntsWithField(curve.Fr, pTau);\n\n\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await startReadUniqueSection(fd, sections, sectionId);\n        for (let i=0; i< nPoints; i++) {\n            if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ` + i);\n            const buff = await fd.read(sG);\n            res.push(G.fromRprLEM(buff, 0));\n        }\n        await endReadSection(fd);\n\n        return res;\n    }\n\n    async function exportLagrange(sectionId, groupName, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await startReadUniqueSection(fd, sections, sectionId);\n        for (let p=0; p<=power; p++) {\n            if (verbose) console.log(`${sectionName}: Power: ${p}`);\n            res[p] = [];\n            const nPoints = (2 ** p);\n            for (let i=0; i<nPoints; i++) {\n                if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ${i}/${nPoints}`);\n                const buff = await fd.read(sG);\n                res[p].push(G.fromRprLEM(buff, 0));\n            }\n        }\n        await endReadSection(fd, true);\n        return res;\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar powersoftau = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    newAccumulator: newAccumulator,\n    exportChallenge: exportChallenge,\n    importResponse: importResponse,\n    verify: verify,\n    challengeContribute: challengeContribute,\n    beacon: beacon$1,\n    contribute: contribute,\n    preparePhase2: preparePhase2,\n    truncate: truncate,\n    convert: convert,\n    exportJson: exportJson\n});\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nfunction r1csPrint(r1cs, syms, logger) {\n    for (let i=0; i<r1cs.constraints.length; i++) {\n        printCostraint(r1cs.constraints[i]);\n    }\n    function printCostraint(c) {\n        const lc2str = (lc) => {\n            let S = \"\";\n            const keys = Object.keys(lc);\n            keys.forEach( (k) => {\n                let name = syms.varIdx2Name[k];\n                if (name == \"one\") name = \"1\";\n\n                let vs = r1cs.curve.Fr.toString(lc[k]);\n                if (vs == \"1\") vs = \"\";  // Do not show ones\n                if (vs == \"-1\") vs = \"-\";  // Do not show ones\n                if ((S!=\"\")&&(vs[0]!=\"-\")) vs = \"+\"+vs;\n                if (S!=\"\") vs = \" \"+vs;\n                S= S + vs   + name;\n            });\n            return S;\n        };\n        const S = `[ ${lc2str(c[0])} ] * [ ${lc2str(c[1])} ] - [ ${lc2str(c[2])} ] = 0`;\n        if (logger) logger.info(S);\n    }\n\n}\n\nconst SUBARRAY_SIZE$1 = 0x40000;\n\nconst BigArrayHandler$1 = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray$1 {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE$1);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE$1) {\n            this.arr[i/SUBARRAY_SIZE$1] = new Array(Math.min(SUBARRAY_SIZE$1, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE$1);\n        const idx2 = idx % SUBARRAY_SIZE$1;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE$1);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE$1);\n        }\n        const idx2 = idx % SUBARRAY_SIZE$1;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray$2();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE$1+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray$2 {\n    constructor( initSize ) {\n        const obj = new _BigArray$1(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler$1);\n        return extObj;\n    }\n}\n\nvar BigArray$3 = BigArray$2;\n\nconst R1CS_FILE_CUSTOM_GATES_LIST_SECTION = 4;\nconst R1CS_FILE_CUSTOM_GATES_USES_SECTION = 5;\n\nasync function readR1csHeader(fd,sections,singleThread) {\n    let options;\n    if (typeof singleThread === \"object\") {\n        options = singleThread;\n    } else if (typeof singleThread === \"undefined\") {\n        options= {\n            singleThread: false,\n        };\n    } else {\n        options = {\n            singleThread: singleThread,\n        };\n    }\n\n    const res = {};\n    await startReadUniqueSection(fd, sections, 1);\n    // Read Header\n    res.n8 = await fd.readULE32();\n    res.prime = await readBigInt(fd, res.n8);\n\n    if (options.F) {\n        if (options.F.p != res.prime) throw new Error(\"Different Prime\");\n        res.F = options.F;\n    } else if (options.getFieldFromPrime) {\n        res.F = await options.getFieldFromPrime(res.prime, options.singleThread);\n    } else if (options.getCurveFromPrime) {\n        res.curve = await options.getCurveFromPrime(res.prime, options.singleThread);\n        res.F = res.curve.Fr;\n    } else {\n        try {\n            res.curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.getCurveFromR)(res.prime, options.singleThread);\n            res.F = res.curve.Fr;\n        } catch (err) {\n            res.F = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.F1Field(res.prime);\n        }\n    }\n\n    res.nVars = await fd.readULE32();\n    res.nOutputs = await fd.readULE32();\n    res.nPubInputs = await fd.readULE32();\n    res.nPrvInputs = await fd.readULE32();\n    res.nLabels = await fd.readULE64();\n    res.nConstraints = await fd.readULE32();\n    res.useCustomGates = typeof sections[R1CS_FILE_CUSTOM_GATES_LIST_SECTION] !== \"undefined\" && sections[R1CS_FILE_CUSTOM_GATES_LIST_SECTION] !== null\n        && typeof sections[R1CS_FILE_CUSTOM_GATES_USES_SECTION] !== \"undefined\" && sections[R1CS_FILE_CUSTOM_GATES_USES_SECTION] !== null;\n\n    await endReadSection(fd);\n\n    return res;\n}\n\nasync function readConstraints(fd,sections, r1cs, logger, loggerCtx) {\n    let options;\n    if (typeof logger === \"object\") {\n        options = logger;\n    } else if (typeof logger === \"undefined\") {\n        options= {};\n    } else {\n        options = {\n            logger: logger,\n            loggerCtx: loggerCtx,\n        };\n    }\n\n    const bR1cs = await readSection(fd, sections, 2);\n    let bR1csPos = 0;\n    let constraints;\n    if (r1cs.nConstraints>1<<20) {\n        constraints = new BigArray$3();\n    } else {\n        constraints = [];\n    }\n    for (let i=0; i<r1cs.nConstraints; i++) {\n        if ((options.logger)&&(i%100000 == 0)) options.logger.info(`${options.loggerCtx}: Loading constraints: ${i}/${r1cs.nConstraints}`);\n        const c = readConstraint();\n        constraints.push(c);\n    }\n    return constraints;\n\n\n    function readConstraint() {\n        const c = [];\n        c[0] = readLC();\n        c[1] = readLC();\n        c[2] = readLC();\n        return c;\n    }\n\n    function readLC() {\n        const lc= {};\n\n        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos+4);\n        bR1csPos += 4;\n        const buffUL32V = new DataView(buffUL32.buffer);\n        const nIdx = buffUL32V.getUint32(0, true);\n\n        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4+r1cs.n8)*nIdx );\n        bR1csPos += (4+r1cs.n8)*nIdx;\n        const buffV = new DataView(buff.buffer);\n        for (let i=0; i<nIdx; i++) {\n            const idx = buffV.getUint32(i*(4+r1cs.n8), true);\n            const val = r1cs.F.fromRprLE(buff, i*(4+r1cs.n8)+4);\n            lc[idx] = val;\n        }\n        return lc;\n    }\n}\n\nasync function readMap(fd, sections, r1cs, logger, loggerCtx) {\n    let options;\n    if (typeof logger === \"object\") {\n        options = logger;\n    } else if (typeof logger === \"undefined\") {\n        options= {};\n    } else {\n        options = {\n            logger: logger,\n            loggerCtx: loggerCtx,\n        };\n    }\n    const bMap = await readSection(fd, sections, 3);\n    let bMapPos = 0;\n    let map;\n\n    if (r1cs.nVars>1<<20) {\n        map = new BigArray$3();\n    } else {\n        map = [];\n    }\n    for (let i=0; i<r1cs.nVars; i++) {\n        if ((options.logger)&&(i%10000 == 0)) options.logger.info(`${options.loggerCtx}: Loading map: ${i}/${r1cs.nVars}`);\n        const idx = readULE64();\n        map.push(idx);\n    }\n\n    return map;\n\n    function readULE64() {\n        const buffULE64 = bMap.slice(bMapPos, bMapPos+8);\n        bMapPos += 8;\n        const buffULE64V = new DataView(buffULE64.buffer);\n        const LSB = buffULE64V.getUint32(0, true);\n        const MSB = buffULE64V.getUint32(4, true);\n\n        return MSB * 0x100000000 + LSB;\n    }\n\n}\n\nasync function readR1csFd(fd, sections, options) {\n    /**\n     * Options properties:\n     *  loadConstraints: <bool> true by default\n     *  loadMap:         <bool> false by default\n     *  loadCustomGates: <bool> true by default\n     */\n\n    if(typeof options !== \"object\") {\n        throw new Error(\"readR1csFd: options must be an object\");\n    }\n\n    options.loadConstraints = \"loadConstraints\" in options ? options.loadConstraints : true;\n    options.loadMap = \"loadMap\" in options ? options.loadMap : false;\n    options.loadCustomGates = \"loadCustomGates\" in options ? options.loadCustomGates : true;\n\n    const res = await readR1csHeader(fd, sections, options);\n\n    if (options.loadConstraints) {\n        res.constraints = await readConstraints(fd, sections, res, options);\n    }\n\n    // Read Labels\n\n    if (options.loadMap) {\n        res.map = await readMap(fd, sections, res, options);\n    }\n\n    if (options.loadCustomGates) {\n        if (res.useCustomGates) {\n            res.customGates = await readCustomGatesListSection(fd, sections, res);\n            res.customGatesUses = await readCustomGatesUsesSection(fd, sections, options);\n        } else {\n            res.customGates = [];\n            res.customGatesUses = [];\n        }\n    }\n    return res;\n}\n\nasync function readR1cs(fileName, loadConstraints, loadMap, singleThread, logger, loggerCtx) {\n    let options;\n    if (typeof loadConstraints === \"object\") {\n        options = loadConstraints;\n    } else if (typeof loadConstraints === \"undefined\") {\n        options= {\n            loadConstraints: true,\n            loadMap: false,\n            loadCustomGates: true\n        };\n    } else {\n        options = {\n            loadConstraints: loadConstraints,\n            loadMap: loadMap,\n            singleThread: singleThread,\n            logger: logger,\n            loggerCtx: loggerCtx\n        };\n    }\n\n    const {fd, sections} = await readBinFile(fileName, \"r1cs\", 1);\n\n    const res = await readR1csFd(fd, sections, options);\n\n    await fd.close();\n\n    return res;\n}\n\nasync function readCustomGatesListSection(fd, sections, res) {\n    await startReadUniqueSection(fd, sections, R1CS_FILE_CUSTOM_GATES_LIST_SECTION);\n\n    let num = await fd.readULE32();\n\n    let customGates = [];\n    for (let i = 0; i < num; i++) {\n        let customGate = {};\n        customGate.templateName = await fd.readString();\n        let numParameters = await fd.readULE32();\n\n        customGate.parameters = Array(numParameters);\n        let buff = await fd.read(res.n8 * numParameters);\n\n        for (let j = 0; j < numParameters; j++) {\n            customGate.parameters[j] = res.F.fromRprLE(buff, j * res.n8, res.n8);        }\n        customGates.push(customGate);\n    }\n    await endReadSection(fd);\n\n    return customGates;\n}\n\nasync function readCustomGatesUsesSection(fd,sections, options) {\n    const bR1cs = await readSection(fd, sections, R1CS_FILE_CUSTOM_GATES_USES_SECTION);\n    const bR1cs32 = new Uint32Array(bR1cs.buffer, bR1cs.byteOffset, bR1cs.byteLength/4);\n    const nCustomGateUses = bR1cs32[0];\n    let bR1csPos = 1;\n    let customGatesUses;\n    if (nCustomGateUses>1<<20) {\n        customGatesUses = new BigArray$3();\n    } else {\n        customGatesUses = [];\n    }\n    for (let i=0; i<nCustomGateUses; i++) {\n        if ((options.logger)&&(i%100000 == 0)) options.logger.info(`${options.loggerCtx}: Loading custom gate uses: ${i}/${nCustomGateUses}`);\n        let c = {};\n        c.id = bR1cs32[bR1csPos++];\n        let numSignals = bR1cs32[bR1csPos++];\n        c.signals = [];\n        for (let j = 0; j < numSignals; j++) {\n            const LSB = bR1cs32[bR1csPos++];\n            const MSB = bR1cs32[bR1csPos++];\n            c.signals.push(MSB * 0x100000000 + LSB);\n        }\n        customGatesUses.push(c);\n    }\n    return customGatesUses;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst bls12381r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nasync function r1csInfo(r1csName, logger) {\n\n    const cir = await readR1cs(r1csName);\n\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(cir.prime, bn128r)) {\n        if (logger) logger.info(\"Curve: bn-128\");\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(cir.prime, bls12381r)) {\n        if (logger) logger.info(\"Curve: bls12-381\");\n    } else {\n        if (logger) logger.info(`Unknown Curve. Prime: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(cir.prime)}`);\n    }\n    if (logger) logger.info(`# of Wires: ${cir.nVars}`);\n    if (logger) logger.info(`# of Constraints: ${cir.nConstraints}`);\n    if (logger) logger.info(`# of Private Inputs: ${cir.nPrvInputs}`);\n    if (logger) logger.info(`# of Public Inputs: ${cir.nPubInputs}`);\n    if (logger) logger.info(`# of Labels: ${cir.nLabels}`);\n    if (logger) logger.info(`# of Outputs: ${cir.nOutputs}`);\n\n    return cir;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function r1csExportJson(r1csFileName, logger) {\n\n    const cir = await readR1cs(r1csFileName, true, true, true, logger);\n    const Fr=cir.curve.Fr;\n    delete cir.curve;\n    delete cir.F;\n\n    return stringifyBigIntsWithField(Fr, cir);\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar r1cs = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    print: r1csPrint,\n    info: r1csInfo,\n    exportJson: r1csExportJson\n});\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function loadSymbols(symFileName) {\n    const sym = {\n        labelIdx2Name: [ \"one\" ],\n        varIdx2Name: [ \"one\" ],\n        componentIdx2Name: []\n    };\n    const fd = await readExisting(symFileName);\n    const buff = await fd.read(fd.totalSize);\n    const symsStr = new TextDecoder(\"utf-8\").decode(buff);\n    const lines = symsStr.split(\"\\n\");\n    for (let i=0; i<lines.length; i++) {\n        const arr = lines[i].split(\",\");\n        if (arr.length!=4) continue;\n        if (sym.varIdx2Name[arr[1]]) {\n            sym.varIdx2Name[arr[1]] += \"|\" + arr[3];\n        } else {\n            sym.varIdx2Name[arr[1]] = arr[3];\n        }\n        sym.labelIdx2Name[arr[0]] = arr[3];\n        if (!sym.componentIdx2Name[arr[2]]) {\n            sym.componentIdx2Name[arr[2]] = extractComponent(arr[3]);\n        }\n    }\n\n    await fd.close();\n\n    return sym;\n\n    function extractComponent(name) {\n        const arr = name.split(\".\");\n        arr.pop(); // Remove the lasr element\n        return arr.join(\".\");\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {unstringifyBigInts: unstringifyBigInts$7} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\n\nasync function wtnsDebug(_input, wasmFileName, wtnsFileName, symName, options, logger) {\n\n    const input = unstringifyBigInts$7(_input);\n\n    const fdWasm = await readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wcOps = {...options, sanityCheck: true};\n    let sym = await loadSymbols(symName);\n    if (options.set) {\n        if (!sym) sym = await loadSymbols(symName);\n        wcOps.logSetSignal= function(labelIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"SET \" + sym.labelIdx2Name[labelIdx] + \" <\" + \"-- \" + value.toString());\n        };\n    }\n    if (options.get) {\n        if (!sym) sym = await loadSymbols(symName);\n        wcOps.logGetSignal= function(varIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"GET \" + sym.labelIdx2Name[varIdx] + \" --\" + \"> \" + value.toString());\n        };\n    }\n    if (options.trigger) {\n        if (!sym) sym = await loadSymbols(symName);\n        wcOps.logStartComponent= function(cIdx) {\n            if (logger) logger.info(\"START: \" + sym.componentIdx2Name[cIdx]);\n        };\n        wcOps.logFinishComponent= function(cIdx) {\n            if (logger) logger.info(\"FINISH: \" + sym.componentIdx2Name[cIdx]);\n        };\n    }\n    wcOps.sym = sym;\n\n    const wc = await builder(wasm, wcOps);\n    const w = await wc.calculateWitness(input, true);\n\n    const fdWtns = await createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n    await write(fdWtns, w, wc.prime);\n\n    await fdWtns.close();\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function wtnsExportJson(wtnsFileName) {\n\n    const w = await read(wtnsFileName);\n\n    return w;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function wtnsCheck(r1csFilename, wtnsFilename, logger) {\n\n    if (logger) logger.info(\"WITNESS CHECKING STARTED\");\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {\n        fd: fdR1cs,\n        sections: sectionsR1cs\n    } = await readBinFile(r1csFilename, \"r1cs\", 1);\n    const r1cs = await readR1csFd(fdR1cs, sectionsR1cs, { loadConstraints: false, loadCustomGates: false });\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await readBinFile(wtnsFilename, \"wtns\", 2);\n    const wtnsHeader = await readHeader(fdWtns, wtnsSections);\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(r1cs.prime, wtnsHeader.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    const buffWitness = await readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    const curve = await getCurveFromR(r1cs.prime);\n    const Fr = curve.Fr;\n    const sFr = Fr.n8;\n\n    const bR1cs = await readSection(fdR1cs, sectionsR1cs, 2);\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  WITNESS CHECK\");\n        logger.info(`  Curve:          ${r1cs.curve.name}`);\n        logger.info(`  Vars (wires):   ${r1cs.nVars}`);\n        logger.info(`  Outputs:        ${r1cs.nOutputs}`);\n        logger.info(`  Public Inputs:  ${r1cs.nPubInputs}`);\n        logger.info(`  Private Inputs: ${r1cs.nPrvInputs}`);\n        logger.info(`  Labels:         ${r1cs.nLabels}`);\n        logger.info(`  Constraints:    ${r1cs.nConstraints}`);\n        logger.info(`  Custom Gates:   ${r1cs.useCustomGates}`);\n        logger.info(\"----------------------------\");\n    }\n\n    if (logger) logger.info(\"> Checking witness correctness\");\n\n    let bR1csPos = 0;\n    let res = true;\n    for (let i = 0; i < r1cs.nConstraints; i++) {\n        if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n            logger.info(` processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n        }\n\n        //Read the three linear combinations of the constraint where A * B - C = 0\n        const lcA = readLC();\n        const lcB = readLC();\n        const lcC = readLC();\n\n        // Evaluate the linear combinations\n        const evalA = EvaluateLinearCombination(lcA);\n        const evalB = EvaluateLinearCombination(lcB);\n        const evalC = EvaluateLinearCombination(lcC);\n\n        // Check that A * B - C == 0\n        if (!Fr.eq(Fr.sub(Fr.mul(evalA, evalB), evalC), Fr.zero)) {\n            logger.warn(\" aborting checking process at constraint \" + i);\n            res = false;\n            break;\n        }\n    }\n\n    fdR1cs.close();\n\n    if (logger) {\n        if (res) {\n            logger.info(\"WITNESS IS CORRECT\");\n            logger.info(\"WITNESS CHECKING FINISHED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"WITNESS IS NOT CORRECT\");\n            logger.warn(\"WITNESS CHECKING FINISHED UNSUCCESSFULLY\");\n        }\n    }\n\n    return res;\n\n    function EvaluateLinearCombination(lc) {\n        let res = Fr.zero;\n\n        const keys = Object.keys(lc);\n        keys.forEach((signalId) => {\n            const signalValue = getWitnessValue(signalId);\n            const signalFactor = lc[signalId];\n\n            res = Fr.add(res, Fr.mul(signalValue, signalFactor));\n        });\n\n        return res;\n    }\n\n    function readLC() {\n        const lc = {};\n\n        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n        bR1csPos += 4;\n        const buffUL32V = new DataView(buffUL32.buffer);\n        const nIdx = buffUL32V.getUint32(0, true);\n\n        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n        bR1csPos += (4 + r1cs.n8) * nIdx;\n        const buffV = new DataView(buff.buffer);\n        for (let i = 0; i < nIdx; i++) {\n            const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n            const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n            lc[idx] = val;\n        }\n        return lc;\n    }\n\n    function getWitnessValue(signalId) {\n        return Fr.fromRprLE(buffWitness.slice(signalId * sFr, signalId * sFr + sFr));\n    }\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar wtns = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    calculate: wtnsCalculate,\n    debug: wtnsDebug,\n    exportJson: wtnsExportJson,\n    check: wtnsCheck\n});\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\nvar BigArray$1 = BigArray;\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function newZKey(r1csName, ptauName, zkeyName, logger) {\n\n    const TAU_G1 = 0;\n    const TAU_G2 = 1;\n    const ALPHATAU_G1 = 2;\n    const BETATAU_G1 = 3;\n    const csHasher = blake2b.create({ dkLen: 64 });\n\n    const {fd: fdPTau, sections: sectionsPTau} = await readBinFile(ptauName, \"ptau\", 1);\n    const {curve, power} = await readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await readBinFile(r1csName, \"r1cs\", 1);\n    const r1cs = await readR1csHeader(fdR1cs, sectionsR1cs, false);\n\n    const fdZKey = await createBinFile(zkeyName, \"zkey\", 1, 10, 1<<22, 1<<24);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    const cirPower = log2(r1cs.nConstraints + r1cs.nPubInputs + r1cs.nOutputs +1 -1) +1;\n\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${r1cs.nConstraints}*2 > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n    const domainSize = 2 ** cirPower;\n\n    // Write the header\n    ///////////\n    await startWriteSection(fdZKey, 1);\n    await fdZKey.writeULE32(1); // Groth\n    await endWriteSection(fdZKey);\n\n    // Write the Groth header section\n    ///////////\n\n    await startWriteSection(fdZKey, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.shl(1, n8r*8), primeR);\n    const R2r = curve.Fr.e(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mul(Rr,Rr), primeR));\n\n    await fdZKey.writeULE32(n8q);\n    await writeBigInt(fdZKey, primeQ, n8q);\n    await fdZKey.writeULE32(n8r);\n    await writeBigInt(fdZKey, primeR, n8r);\n    await fdZKey.writeULE32(r1cs.nVars);                         // Total number of bars\n    await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n    await fdZKey.writeULE32(domainSize);                  // domainSize\n\n    let bAlpha1;\n    bAlpha1 = await fdPTau.read(sG1, sectionsPTau[4][0].p);\n    await fdZKey.write(bAlpha1);\n    bAlpha1 = await curve.G1.batchLEMtoU(bAlpha1);\n    csHasher.update(bAlpha1);\n\n    let bBeta1;\n    bBeta1 = await fdPTau.read(sG1, sectionsPTau[5][0].p);\n    await fdZKey.write(bBeta1);\n    bBeta1 = await curve.G1.batchLEMtoU(bBeta1);\n    csHasher.update(bBeta1);\n\n    let bBeta2;\n    bBeta2 = await fdPTau.read(sG2, sectionsPTau[6][0].p);\n    await fdZKey.write(bBeta2);\n    bBeta2 = await curve.G2.batchLEMtoU(bBeta2);\n    csHasher.update(bBeta2);\n\n    const bg1 = new Uint8Array(sG1);\n    curve.G1.toRprLEM(bg1, 0, curve.G1.g);\n    const bg2 = new Uint8Array(sG2);\n    curve.G2.toRprLEM(bg2, 0, curve.G2.g);\n    const bg1U = new Uint8Array(sG1);\n    curve.G1.toRprUncompressed(bg1U, 0, curve.G1.g);\n    const bg2U = new Uint8Array(sG2);\n    curve.G2.toRprUncompressed(bg2U, 0, curve.G2.g);\n\n    await fdZKey.write(bg2);        // gamma2\n    await fdZKey.write(bg1);        // delta1\n    await fdZKey.write(bg2);        // delta2\n    csHasher.update(bg2U);      // gamma2\n    csHasher.update(bg1U);      // delta1\n    csHasher.update(bg2U);      // delta2\n    await endWriteSection(fdZKey);\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await readSection(fdR1cs, sectionsR1cs, 2);\n\n    const A = new BigArray$1(r1cs.nVars);\n    const B1 = new BigArray$1(r1cs.nVars);\n    const B2 = new BigArray$1(r1cs.nVars);\n    const C = new BigArray$1(r1cs.nVars- nPublic -1);\n    const IC = new Array(nPublic+1);\n\n    if (logger) logger.info(\"Reading tauG1\");\n    let sTauG1 = await readSection(fdPTau, sectionsPTau, 12, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading tauG2\");\n    let sTauG2 = await readSection(fdPTau, sectionsPTau, 13, (domainSize -1)*sG2, domainSize*sG2);\n    if (logger) logger.info(\"Reading alphatauG1\");\n    let sAlphaTauG1 = await readSection(fdPTau, sectionsPTau, 14, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading betatauG1\");\n    let sBetaTauG1 = await readSection(fdPTau, sectionsPTau, 15, (domainSize -1)*sG1, domainSize*sG1);\n\n    await processConstraints();\n\n    await composeAndWritePoints(3, \"G1\", IC, \"IC\");\n\n    await writeHs();\n\n    await hashHPoints();\n\n    await composeAndWritePoints(8, \"G1\", C, \"C\");\n    await composeAndWritePoints(5, \"G1\", A, \"A\");\n    await composeAndWritePoints(6, \"G1\", B1, \"B1\");\n    await composeAndWritePoints(7, \"G2\", B2, \"B2\");\n\n    const csHash = csHasher.digest();\n    // Contributions section\n    await startWriteSection(fdZKey, 10);\n    await fdZKey.write(csHash);\n    await fdZKey.writeULE32(0);\n    await endWriteSection(fdZKey);\n\n    if (logger) logger.info(formatHash(csHash, \"Circuit hash: \"));\n\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    return csHash;\n\n    async function writeHs() {\n        await startWriteSection(fdZKey, 9);\n        const buffOut = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(domainSize*sG1);\n        if (cirPower < curve.Fr.s) {\n            let sTauG1 = await readSection(fdPTau, sectionsPTau, 12, (domainSize*2-1)*sG1, domainSize*2*sG1);\n            for (let i=0; i< domainSize; i++) {\n                if ((logger)&&(i%10000 == 0)) logger.debug(`splitting buffer: ${i}/${domainSize}`);\n                const buff = sTauG1.slice( (i*2+1)*sG1, (i*2+1)*sG1 + sG1 );\n                buffOut.set(buff, i*sG1);\n            }\n        } else if (cirPower == curve.Fr.s) {\n            const o = sectionsPTau[12][0].p + ((2 ** (cirPower+1)) -1)*sG1;\n            await fdPTau.readToBuffer(buffOut, 0, domainSize*sG1, o + domainSize*sG1);\n        } else {\n            if (logger) logger.error(\"Circuit too big\");\n            throw new Error(\"Circuit too big for this curve\");\n        }\n        await fdZKey.write(buffOut);\n        await endWriteSection(fdZKey);\n    }\n\n    async function processConstraints() {\n        const buffCoeff = new Uint8Array(12 + curve.Fr.n8);\n        const buffCoeffV = new DataView(buffCoeff.buffer);\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let r1csPos = 0;\n\n        function r1cs_readULE32() {\n            const buff = sR1cs.slice(r1csPos, r1csPos+4);\n            r1csPos += 4;\n            const buffV = new DataView(buff.buffer);\n            return buffV.getUint32(0, true);\n        }\n\n        const coefs = new BigArray$1();\n        for (let c=0; c<r1cs.nConstraints; c++) {\n            if ((logger)&&(c%10000 == 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            const nA = r1cs_readULE32();\n            for (let i=0; i<nA; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = BETATAU_G1;\n                const l2 = sG1*c;\n                if (typeof A[s] === \"undefined\") A[s] = [];\n                A[s].push([l1t, l1, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l2t, l2, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s - nPublic -1].push([l2t, l2, coefp]);\n                }\n                coefs.push([0, c, s, coefp]);\n            }\n\n            const nB = r1cs_readULE32();\n            for (let i=0; i<nB; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = TAU_G2;\n                const l2 = sG2*c;\n                const l3t = ALPHATAU_G1;\n                const l3 = sG1*c;\n                if (typeof B1[s] === \"undefined\") B1[s] = [];\n                B1[s].push([l1t, l1, coefp]);\n                if (typeof B2[s] === \"undefined\") B2[s] = [];\n                B2[s].push([l2t, l2, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l3t, l3, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l3t, l3, coefp]);\n                }\n\n                coefs.push([1, c, s, coefp]);\n            }\n\n            const nC = r1cs_readULE32();\n            for (let i=0; i<nC; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l1t, l1, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l1t, l1, coefp]);\n                }\n            }\n        }\n\n        for (let s = 0; s <= nPublic ; s++) {\n            const l1t = TAU_G1;\n            const l1 = sG1*(r1cs.nConstraints + s);\n            const l2t = BETATAU_G1;\n            const l2 = sG1*(r1cs.nConstraints + s);\n            if (typeof A[s] === \"undefined\") A[s] = [];\n            A[s].push([l1t, l1, -1]);\n            if (typeof IC[s] === \"undefined\") IC[s] = [];\n            IC[s].push([l2t, l2, -1]);\n            coefs.push([0, r1cs.nConstraints + s, s, -1]);\n        }\n\n\n        await startWriteSection(fdZKey, 4);\n\n        const buffSection = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(coefs.length*(12+curve.Fr.n8) + 4);\n\n        const buff4 = new Uint8Array(4);\n        const buff4V = new DataView(buff4.buffer);\n        buff4V.setUint32(0, coefs.length, true);\n        buffSection.set(buff4);\n        let coefsPos = 4;\n        for (let i=0; i<coefs.length; i++) {\n            if ((logger)&&(i%100000 == 0)) logger.debug(`writing coeffs: ${i}/${coefs.length}`);\n            writeCoef(coefs[i]);\n        }\n\n        await fdZKey.write(buffSection);\n        await endWriteSection(fdZKey);\n\n        function writeCoef(c) {\n            buffCoeffV.setUint32(0, c[0], true);\n            buffCoeffV.setUint32(4, c[1], true);\n            buffCoeffV.setUint32(8, c[2], true);\n            let n;\n            if (c[3]>=0) {\n                n = curve.Fr.fromRprLE(sR1cs.slice(c[3], c[3] + curve.Fr.n8), 0);\n            } else {\n                n = curve.Fr.fromRprLE(bOne, 0);\n            }\n            const nR2 = curve.Fr.mul(n, R2r);\n            curve.Fr.toRprLE(buffCoeff, 12, nR2);\n            buffSection.set(buffCoeff, coefsPos);\n            coefsPos += buffCoeff.length;\n        }\n\n    }\n\n    async function composeAndWritePoints(idSection, groupName, arr, sectionName) {\n        const CHUNK_SIZE= 1<<15;\n        const G = curve[groupName];\n\n        hashU32(arr.length);\n        await startWriteSection(fdZKey, idSection);\n\n        let opPromises = [];\n\n        let i=0;\n        while (i<arr.length) {\n\n            let t=0;\n            while ((i<arr.length)&&(t<curve.tm.concurrency)) {\n                if (logger)  logger.debug(`Writing points start ${sectionName}: ${i}/${arr.length}`);\n                let n = 1;\n                let nP = (arr[i] ? arr[i].length : 0);\n                while ((i + n < arr.length) && (nP + (arr[i+n] ? arr[i+n].length : 0) < CHUNK_SIZE) && (n<CHUNK_SIZE)) {\n                    nP += (arr[i+n] ? arr[i+n].length : 0);\n                    n ++;\n                }\n                const subArr = arr.slice(i, i + n);\n                const _i = i;\n                opPromises.push(composeAndWritePointsThread(groupName, subArr, logger, sectionName).then( (r) => {\n                    if (logger)  logger.debug(`Writing points end ${sectionName}: ${_i}/${arr.length}`);\n                    return r;\n                }));\n                i += n;\n                t++;\n            }\n\n            const result = await Promise.all(opPromises);\n\n            for (let k=0; k<result.length; k++) {\n                await fdZKey.write(result[k][0]);\n                const buff = await G.batchLEMtoU(result[k][0]);\n                csHasher.update(buff);\n            }\n            opPromises = [];\n\n        }\n        await endWriteSection(fdZKey);\n\n    }\n\n    async function composeAndWritePointsThread(groupName, arr, logger, sectionName) {\n        const G = curve[groupName];\n        const sGin = G.F.n8*2;\n        const sGmid = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnExp, fnMultiExp, fnBatchToAffine, fnZero;\n        if (groupName == \"G1\") {\n            fnExp = \"g1m_timesScalarAffine\";\n            fnMultiExp = \"g1m_multiexpAffine\";\n            fnBatchToAffine = \"g1m_batchToAffine\";\n            fnZero = \"g1m_zero\";\n        } else if (groupName == \"G2\") {\n            fnExp = \"g2m_timesScalarAffine\";\n            fnMultiExp = \"g2m_multiexpAffine\";\n            fnBatchToAffine = \"g2m_batchToAffine\";\n            fnZero = \"g2m_zero\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        let acc =0;\n        for (let i=0; i<arr.length; i++) acc += arr[i] ? arr[i].length : 0;\n        let bBases, bScalars;\n        if (acc> 2<<14) {\n            bBases = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(acc*sGin);\n            bScalars = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(acc*curve.Fr.n8);\n        } else {\n            bBases = new Uint8Array(acc*sGin);\n            bScalars = new Uint8Array(acc*curve.Fr.n8);\n        }\n        let pB =0;\n        let pS =0;\n\n        const sBuffs = [\n            sTauG1,\n            sTauG2,\n            sAlphaTauG1,\n            sBetaTauG1\n        ];\n\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let offset = 0;\n        for (let i=0; i<arr.length; i++) {\n            if (!arr[i]) continue;\n            for (let j=0; j<arr[i].length; j++) {\n                if ((logger)&&(j)&&(j%10000 == 0))  logger.debug(`Configuring big array ${sectionName}: ${j}/${arr[i].length}`);\n                bBases.set(\n                    sBuffs[arr[i][j][0]].slice(\n                        arr[i][j][1],\n                        arr[i][j][1] + sGin\n                    ), offset*sGin\n                );\n                if (arr[i][j][2]>=0) {\n                    bScalars.set(\n                        sR1cs.slice(\n                            arr[i][j][2],\n                            arr[i][j][2] + curve.Fr.n8\n                        ),\n                        offset*curve.Fr.n8\n                    );\n                } else {\n                    bScalars.set(bOne, offset*curve.Fr.n8);\n                }\n                offset ++;\n            }\n        }\n\n        if (arr.length>1) {\n            const task = [];\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: bBases});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: bScalars});\n            task.push({cmd: \"ALLOC\", var: 2, len: arr.length*sGmid});\n            pB = 0;\n            pS = 0;\n            let pD =0;\n            for (let i=0; i<arr.length; i++) {\n                if (!arr[i]) {\n                    task.push({cmd: \"CALL\", fnName: fnZero, params: [\n                        {var: 2, offset: pD}\n                    ]});\n                    pD += sGmid;\n                    continue;\n                }\n                if (arr[i].length == 1) {\n                    task.push({cmd: \"CALL\", fnName: fnExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {var: 2, offset: pD}\n                    ]});\n                } else {\n                    task.push({cmd: \"CALL\", fnName: fnMultiExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {val: arr[i].length},\n                        {var: 2, offset: pD}\n                    ]});\n                }\n                pB += sGin*arr[i].length;\n                pS += curve.Fr.n8*arr[i].length;\n                pD += sGmid;\n            }\n            task.push({cmd: \"CALL\", fnName: fnBatchToAffine, params: [\n                {var: 2},\n                {val: arr.length},\n                {var: 2},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: arr.length*sGout});\n\n            const res = await curve.tm.queueAction(task);\n            return res;\n        } else {\n            let res = await G.multiExpAffine(bBases, bScalars, logger, sectionName);\n            res = [ G.toAffine(res) ];\n            return res;\n        }\n    }\n\n\n    async function hashHPoints() {\n        const CHUNK_SIZE = 1<<14;\n\n        hashU32(domainSize-1);\n\n        for (let i=0; i<domainSize-1; i+= CHUNK_SIZE) {\n            if (logger)  logger.debug(`HashingHPoints: ${i}/${domainSize}`);\n            const n = Math.min(domainSize-1, CHUNK_SIZE);\n            await hashHPointsChunk(i, n);\n        }\n    }\n\n    async function hashHPointsChunk(offset, nPoints) {\n        const buff1 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + (offset + domainSize)*sG1);\n        const buff2 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + offset*sG1);\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(hashHPointsThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        for (let i=0; i<result.length; i++) {\n            csHasher.update(result[i][0]);\n        }\n    }\n\n    async function hashHPointsThread(buff1, buff2) {\n        const nPoints = buff1.byteLength/sG1;\n        const sGmid = curve.G1.F.n8*3;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchLEMtoU\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n    function hashU32(n) {\n        const buff = new Uint8Array(4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        buffV.setUint32(0, n, false);\n        csHasher.update(buff);\n    }\n\n}\n\nasync function phase2exportMPCParams(zkeyName, mpcparamsName, logger) {\n\n    const {fd: fdZKey, sections: sectionsZKey} = await readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await readHeader$1(fdZKey, sectionsZKey);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurveFromQ(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const mpcParams = await readMPCParams(fdZKey, curve, sectionsZKey);\n\n    const fdMPCParams = await createOverride(mpcparamsName);\n\n    /////////////////////\n    // Verification Key Section\n    /////////////////////\n    await writeG1(zkey.vk_alpha_1);\n    await writeG1(zkey.vk_beta_1);\n    await writeG2(zkey.vk_beta_2);\n    await writeG2(zkey.vk_gamma_2);\n    await writeG1(zkey.vk_delta_1);\n    await writeG2(zkey.vk_delta_2);\n\n    // IC\n    let buffBasesIC;\n    buffBasesIC = await readSection(fdZKey, sectionsZKey, 3);\n    buffBasesIC = await curve.G1.batchLEMtoU(buffBasesIC);\n\n    await writePointArray(\"G1\", buffBasesIC);\n\n    /////////////////////\n    // h Section\n    /////////////////////\n    const buffBasesH_Lodd = await readSection(fdZKey, sectionsZKey, 9);\n\n    let buffBasesH_Tau;\n    buffBasesH_Tau = await curve.G1.fft(buffBasesH_Lodd, \"affine\", \"jacobian\", logger);\n    buffBasesH_Tau = await curve.G1.batchApplyKey(buffBasesH_Tau, curve.Fr.neg(curve.Fr.e(2)), curve.Fr.w[zkey.power+1], \"jacobian\", \"affine\", logger);\n\n    // Remove last element.  (The degree of H will be always m-2)\n    buffBasesH_Tau = buffBasesH_Tau.slice(0, buffBasesH_Tau.byteLength - sG1);\n    buffBasesH_Tau = await curve.G1.batchLEMtoU(buffBasesH_Tau);\n    await writePointArray(\"G1\", buffBasesH_Tau);\n\n    /////////////////////\n    // L section\n    /////////////////////\n    let buffBasesC;\n    buffBasesC = await readSection(fdZKey, sectionsZKey, 8);\n    buffBasesC = await curve.G1.batchLEMtoU(buffBasesC);\n    await writePointArray(\"G1\", buffBasesC);\n\n    /////////////////////\n    // A Section (C section)\n    /////////////////////\n    let buffBasesA;\n    buffBasesA = await readSection(fdZKey, sectionsZKey, 5);\n    buffBasesA = await curve.G1.batchLEMtoU(buffBasesA);\n    await writePointArray(\"G1\", buffBasesA);\n\n    /////////////////////\n    // B1 Section\n    /////////////////////\n    let buffBasesB1;\n    buffBasesB1 = await readSection(fdZKey, sectionsZKey, 6);\n    buffBasesB1 = await curve.G1.batchLEMtoU(buffBasesB1);\n    await writePointArray(\"G1\", buffBasesB1);\n\n    /////////////////////\n    // B2 Section\n    /////////////////////\n    let buffBasesB2;\n    buffBasesB2 = await readSection(fdZKey, sectionsZKey, 7);\n    buffBasesB2 = await curve.G2.batchLEMtoU(buffBasesB2);\n    await writePointArray(\"G2\", buffBasesB2);\n\n    await fdMPCParams.write(mpcParams.csHash);\n    await writeU32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdMPCParams.write(c.transcript);\n    }\n\n    await fdZKey.close();\n    await fdMPCParams.close();\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writePointArray(groupName, buff) {\n        let sG;\n        if (groupName == \"G1\") {\n            sG = sG1;\n        } else {\n            sG = sG2;\n        }\n\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, buff.byteLength / sG, false);\n\n        await fdMPCParams.write(buffSize);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeU32(n) {\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, n, false);\n\n        await fdMPCParams.write(buffSize);\n    }\n\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function phase2importMPCParams(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger) {\n\n    const {fd: fdZKeyOld, sections: sectionsZKeyOld} = await readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkeyHeader = await readHeader$1(fdZKeyOld, sectionsZKeyOld, false);\n    if (zkeyHeader.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurveFromQ(zkeyHeader.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const oldMPCParams = await readMPCParams(fdZKeyOld, curve, sectionsZKeyOld);\n    const newMPCParams = {};\n\n    const fdMPCParams = await readExisting(mpcparamsName);\n\n    fdMPCParams.pos =\n        sG1*3 + sG2*3 +                     // vKey\n        8 + sG1*zkeyHeader.nVars +              // IC + C\n        4 + sG1*(zkeyHeader.domainSize-1) +     // H\n        4 + sG1*zkeyHeader.nVars +              // A\n        4 + sG1*zkeyHeader.nVars +              // B1\n        4 + sG2*zkeyHeader.nVars;               // B2\n\n    // csHash\n    newMPCParams.csHash =  await fdMPCParams.read(64);\n\n    const nContributions = await fdMPCParams.readUBE32();\n    newMPCParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1(fdMPCParams);\n        c.delta.g1_s = await readG1(fdMPCParams);\n        c.delta.g1_sx = await readG1(fdMPCParams);\n        c.delta.g2_spx = await readG2(fdMPCParams);\n        c.transcript = await fdMPCParams.read(64);\n        if (i<oldMPCParams.contributions.length) {\n            c.type = oldMPCParams.contributions[i].type;\n            if (c.type==1) {\n                c.beaconHash = oldMPCParams.contributions[i].beaconHash;\n                c.numIterationsExp = oldMPCParams.contributions[i].numIterationsExp;\n            }\n            if (oldMPCParams.contributions[i].name) {\n                c.name = oldMPCParams.contributions[i].name;\n            }\n        }\n        newMPCParams.contributions.push(c);\n    }\n\n    if (!hashIsEqual(newMPCParams.csHash, oldMPCParams.csHash)) {\n        if (logger) logger.error(\"Hash of the original circuit does not match with the MPC one\");\n        return false;\n    }\n\n    if (oldMPCParams.contributions.length > newMPCParams.contributions.length) {\n        if (logger) logger.error(\"The impoerted file does not include new contributions\");\n        return false;\n    }\n\n    for (let i=0; i<oldMPCParams.contributions.length; i++) {\n        if (!contributionIsEqual(oldMPCParams.contributions[i], newMPCParams.contributions[i])) {\n            if (logger) logger.error(`Previous contribution ${i} does not match`);\n            return false;\n        }\n    }\n\n\n    // Set the same name to all new contributions\n    if (name) {\n        for (let i=oldMPCParams.contributions.length; i<newMPCParams.contributions.length; i++) {\n            newMPCParams.contributions[i].name = name;\n        }\n    }\n\n    const fdZKeyNew = await createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n    fdMPCParams.pos = 0;\n\n    // Header\n    fdMPCParams.pos += sG1;  // ignore alpha1 (keep original)\n    fdMPCParams.pos += sG1;  // ignore beta1\n    fdMPCParams.pos += sG2;  // ignore beta2\n    fdMPCParams.pos += sG2;  // ignore gamma2\n    zkeyHeader.vk_delta_1 = await readG1(fdMPCParams);\n    zkeyHeader.vk_delta_2 = await readG2(fdMPCParams);\n    await writeHeader(fdZKeyNew, zkeyHeader);\n\n    // IC (Keep original)\n    const nIC = await fdMPCParams.readUBE32();\n    if (nIC != zkeyHeader.nPublic +1) {\n        if (logger) logger.error(\"Invalid number of points in IC\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nPublic+1);\n    await copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 3);\n\n    // Coeffs (Keep original)\n    await copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 4);\n\n    // H Section\n    const nH = await fdMPCParams.readUBE32();\n    if (nH != zkeyHeader.domainSize-1) {\n        if (logger) logger.error(\"Invalid number of points in H\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffH;\n    const buffTauU = await fdMPCParams.read(sG1*(zkeyHeader.domainSize-1));\n    const buffTauLEM = await curve.G1.batchUtoLEM(buffTauU);\n    buffH = new Uint8Array(zkeyHeader.domainSize*sG1);\n    buffH.set(buffTauLEM);   // Let the last one to zero.\n    curve.G1.toRprLEM(buffH, sG1*(zkeyHeader.domainSize-1), curve.G1.zeroAffine);\n    const n2Inv = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n    const wInv = curve.Fr.inv(curve.Fr.w[zkeyHeader.power+1]);\n    buffH = await curve.G1.batchApplyKey(buffH, n2Inv, wInv, \"affine\", \"jacobian\", logger);\n    buffH = await curve.G1.ifft(buffH, \"jacobian\", \"affine\", logger);\n    await startWriteSection(fdZKeyNew, 9);\n    await fdZKeyNew.write(buffH);\n    await endWriteSection(fdZKeyNew);\n\n    // C Section (L section)\n    const nL = await fdMPCParams.readUBE32();\n    if (nL != (zkeyHeader.nVars-zkeyHeader.nPublic-1)) {\n        if (logger) logger.error(\"Invalid number of points in L\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffL;\n    buffL = await fdMPCParams.read(sG1*(zkeyHeader.nVars-zkeyHeader.nPublic-1));\n    buffL = await curve.G1.batchUtoLEM(buffL);\n    await startWriteSection(fdZKeyNew, 8);\n    await fdZKeyNew.write(buffL);\n    await endWriteSection(fdZKeyNew);\n\n    // A Section\n    const nA = await fdMPCParams.readUBE32();\n    if (nA != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in A\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 5);\n\n    // B1 Section\n    const nB1 = await fdMPCParams.readUBE32();\n    if (nB1 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B1\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 6);\n\n    // B2 Section\n    const nB2 = await fdMPCParams.readUBE32();\n    if (nB2 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B2\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG2*(zkeyHeader.nVars);\n    await copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 7);\n\n    await writeMPCParams(fdZKeyNew, curve, newMPCParams);\n\n    await fdMPCParams.close();\n    await fdZKeyNew.close();\n    await fdZKeyOld.close();\n\n    return true;\n\n    async function readG1(fd) {\n        const buff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2(fd) {\n        const buff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n\n    function contributionIsEqual(c1, c2) {\n        if (!curve.G1.eq(c1.deltaAfter   , c2.deltaAfter)) return false;\n        if (!curve.G1.eq(c1.delta.g1_s   , c2.delta.g1_s)) return false;\n        if (!curve.G1.eq(c1.delta.g1_sx  , c2.delta.g1_sx)) return false;\n        if (!curve.G2.eq(c1.delta.g2_spx , c2.delta.g2_spx)) return false;\n        if (!hashIsEqual(c1.transcript, c2.transcript)) return false;\n        return true;\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst sameRatio = sameRatio$2;\n\n\n\nasync function phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger) {\n\n    let sr;\n    const {fd, sections} = await readBinFile(zkeyFileName, \"zkey\", 2);\n    const zkey = await readHeader$1(fd, sections, false);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurveFromQ(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n\n    const mpcParams = await readMPCParams(fd, curve, sections);\n\n    const accumulatedHasher = blake2b.create({ dkLen: 64 });\n    accumulatedHasher.update(mpcParams.csHash);\n    let curDelta = curve.G1.g;\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        const ourHasher = cloneHasher(accumulatedHasher);\n\n        hashG1(ourHasher, curve, c.delta.g1_s);\n        hashG1(ourHasher, curve, c.delta.g1_sx);\n\n        if (!hashIsEqual(ourHasher.digest(), c.transcript)) {\n            console.log(`INVALID(${i}): Inconsistent transcript `);\n            return false;\n        }\n\n        const delta_g2_sp = hashToG2(curve, c.transcript);\n\n        sr = await sameRatio(curve, c.delta.g1_s, c.delta.g1_sx, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): public key G1 and G2 do not have the same ration `);\n            return false;\n        }\n\n        sr = await sameRatio(curve, curDelta, c.deltaAfter, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): deltaAfter does not fillow the public key `);\n            return false;\n        }\n\n        if (c.type == 1) {\n            const rng = await rngFromBeaconParams(c.beaconHash, c.numIterationsExp);\n            const expected_prvKey = curve.Fr.fromRng(rng);\n            const expected_g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n            const expected_g1_sx = curve.G1.toAffine(curve.G1.timesFr(expected_g1_s, expected_prvKey));\n            if (curve.G1.eq(expected_g1_s, c.delta.g1_s) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_s `);\n                return false;\n            }\n            if (curve.G1.eq(expected_g1_sx, c.delta.g1_sx) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_sx `);\n                return false;\n            }\n        }\n\n        hashPubKey(accumulatedHasher, curve, c);\n\n        const contributionHasher = blake2b.create({ dkLen: 64 });\n        hashPubKey(contributionHasher, curve, c);\n\n        c.contributionHash = contributionHasher.digest();\n\n        curDelta = c.deltaAfter;\n    }\n\n\n    const {fd: fdInit, sections: sectionsInit} = await readBinFile(initFileName, \"zkey\", 2);\n    const zkeyInit = await readHeader$1(fdInit, sectionsInit, false);\n\n    if (zkeyInit.protocol != \"groth16\") {\n        throw new Error(\"zkeyinit file is not groth16\");\n    }\n\n    if (  (!ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(zkeyInit.q, zkey.q))\n        ||(!ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(zkeyInit.r, zkey.r))\n        ||(zkeyInit.n8q != zkey.n8q)\n        ||(zkeyInit.n8r != zkey.n8r))\n    {\n        if (logger) logger.error(\"INVALID:  Different curves\");\n        return false;\n    }\n\n    if (  (zkeyInit.nVars != zkey.nVars)\n        ||(zkeyInit.nPublic !=  zkey.nPublic)\n        ||(zkeyInit.domainSize != zkey.domainSize))\n    {\n        if (logger) logger.error(\"INVALID:  Different circuit parameters\");\n        return false;\n    }\n\n    if (!curve.G1.eq(zkey.vk_alpha_1, zkeyInit.vk_alpha_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid alpha1\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_beta_1, zkeyInit.vk_beta_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta1\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_beta_2, zkeyInit.vk_beta_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta2\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_gamma_2, zkeyInit.vk_gamma_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid gamma2\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_delta_1, curDelta)) {\n        if (logger) logger.error(\"INVALID:  Invalid delta1\");\n        return false;\n    }\n    sr = await sameRatio(curve, curve.G1.g, curDelta, curve.G2.g, zkey.vk_delta_2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID:  Invalid delta2\");\n        return false;\n    }\n\n    const mpcParamsInit = await readMPCParams(fdInit, curve, sectionsInit);\n    if (!hashIsEqual(mpcParams.csHash, mpcParamsInit.csHash)) {\n        if (logger) logger.error(\"INVALID:  Circuit does not match\");\n        return false;\n    }\n\n    // Check sizes of sections\n    if (sections[8][0].size != sG1*(zkey.nVars-zkey.nPublic-1)) {\n        if (logger) logger.error(\"INVALID:  Invalid L section size\");\n        return false;\n    }\n\n    if (sections[9][0].size != sG1*(zkey.domainSize)) {\n        if (logger) logger.error(\"INVALID:  Invalid H section size\");\n        return false;\n    }\n\n    let ss;\n    ss = await sectionIsEqual(fd, sections, fdInit, sectionsInit, 3);\n    if (!ss) {\n        if (logger) logger.error(\"INVALID:  IC section is not identical\");\n        return false;\n    }\n\n    ss = await sectionIsEqual(fd, sections, fdInit, sectionsInit, 4);\n    if (!ss) {\n        if (logger) logger.error(\"Coeffs section is not identical\");\n        return false;\n    }\n\n    ss = await sectionIsEqual(fd, sections, fdInit, sectionsInit, 5);\n    if (!ss) {\n        if (logger) logger.error(\"A section is not identical\");\n        return false;\n    }\n\n    ss = await sectionIsEqual(fd, sections, fdInit, sectionsInit, 6);\n    if (!ss) {\n        if (logger) logger.error(\"B1 section is not identical\");\n        return false;\n    }\n\n    ss = await sectionIsEqual(fd, sections, fdInit, sectionsInit, 7);\n    if (!ss) {\n        if (logger) logger.error(\"B2 section is not identical\");\n        return false;\n    }\n\n    // Check L\n    sr = await sectionHasSameRatio(\"G1\", fdInit, sectionsInit, fd, sections, 8, zkey.vk_delta_2, zkeyInit.vk_delta_2, \"L section\");\n    if (sr!==true) {\n        if (logger) logger.error(\"L section does not match\");\n        return false;\n    }\n\n    // Check H\n    sr = await sameRatioH();\n    if (sr!==true) {\n        if (logger) logger.error(\"H section does not match\");\n        return false;\n    }\n\n    if (logger) logger.info(formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n\n    await fd.close();\n    await fdInit.close();\n\n    for (let i=mpcParams.contributions.length-1; i>=0; i--) {\n        const c = mpcParams.contributions[i];\n        if (logger) logger.info(\"-------------------------\");\n        if (logger) logger.info(formatHash(c.contributionHash, `contribution #${i+1} ${c.name ? c.name : \"\"}:`));\n        if (c.type == 1) {\n            if (logger) logger.info(`Beacon generator: ${byteArray2hex(c.beaconHash)}`);\n            if (logger) logger.info(`Beacon iterations Exp: ${c.numIterationsExp}`);\n        }\n    }\n    if (logger) logger.info(\"-------------------------\");\n\n    if (logger) logger.info(\"ZKey Ok!\");\n\n    return true;\n\n\n    async function sectionHasSameRatio(groupName, fd1, sections1, fd2, sections2, idSection, g2sp, g2spx, sectionName) {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await startReadUniqueSection(fd1, sections1, idSection);\n        await startReadUniqueSection(fd2, sections2, idSection);\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        const nPoints = sections1[idSection][0].size / sG;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`Same ratio check ${sectionName}:  ${i}/${nPoints}`);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases1 = await fd1.read(n*sG);\n            const bases2 = await fd2.read(n*sG);\n\n            const scalars = getRandomBytes(4*n);\n\n            const r1 = await G.multiExpAffine(bases1, scalars);\n            const r2 = await G.multiExpAffine(bases2, scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n        }\n        await endReadSection(fd1);\n        await endReadSection(fd2);\n\n        if (nPoints == 0) return true;\n\n        sr = await sameRatio(curve, R1, R2, g2sp, g2spx);\n        if (sr !== true) return false;\n\n        return true;\n    }\n\n    async function sameRatioH() {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve.G1;\n        const Fr = curve.Fr;\n        const sG = G.F.n8*2;\n\n        const {fd: fdPTau, sections: sectionsPTau} = await readBinFile(pTauFileName, \"ptau\", 1);\n\n        let buff_r = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(zkey.domainSize * zkey.n8r);\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = readUInt32BE(getRandomBytes(4), 0);\n        }\n        const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.ChaCha(seed);\n        for (let i=0; i<zkey.domainSize-1; i++) {   // Note that last one is zero\n            const e = Fr.fromRng(rng);\n            Fr.toRprLE(buff_r, i*zkey.n8r, e);\n        }\n        Fr.toRprLE(buff_r, (zkey.domainSize-1)*zkey.n8r, Fr.zero);\n\n        let R1 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(tau):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff1 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + zkey.domainSize*sG + i*sG);\n            const buff2 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + i*sG);\n\n            const buffB = await batchSubtract(buff1, buff2);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buffB, buffS);\n\n            R1 = G.add(R1, r);\n        }\n\n        // Calculate odd coefficients in transformed domain\n\n        buff_r = await Fr.batchToMontgomery(buff_r);\n        // const first = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n        // Works*2   const first = curve.Fr.neg(curve.Fr.e(2));\n\n\n        let first;\n\n        if (zkey.power < Fr.s) {\n            first = Fr.neg(Fr.e(2));\n        } else {\n            const small_m  = 2 ** Fr.s;\n            const shift_to_small_m = Fr.exp(Fr.shift, small_m);\n            first = Fr.sub( shift_to_small_m, Fr.one);\n        }\n\n        // const inc = curve.Fr.inv(curve.PFr.w[zkey.power+1]);\n        const inc = zkey.power < Fr.s ? Fr.w[zkey.power+1] : Fr.shift;\n        buff_r = await Fr.batchApplyKey(buff_r, first, inc);\n        buff_r = await Fr.fft(buff_r);\n        buff_r = await Fr.batchFromMontgomery(buff_r);\n\n        await startReadUniqueSection(fd, sections, 9);\n        let R2 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(lagrange):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff = await fd.read(sG*n);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buff, buffS);\n\n            R2 = G.add(R2, r);\n        }\n        await endReadSection(fd);\n\n        sr = await sameRatio(curve, R1, R2, zkey.vk_delta_2, zkeyInit.vk_delta_2);\n        if (sr !== true) return false;\n\n\n        return true;\n\n    }\n\n    async function batchSubtract(buff1, buff2) {\n        const sG = curve.G1.F.n8*2;\n        const nPoints = buff1.byteLength / sG;\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(batchSubtractThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        const fullBuffOut = new Uint8Array(nPoints*sG);\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    }\n\n\n    async function batchSubtractThread(buff1, buff2) {\n        const sG1 = curve.G1.F.n8*2;\n        const sGmid = curve.G1.F.n8*3;\n        const nPoints = buff1.byteLength/sG1;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function phase2verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger) {\n\n    // const initFileName = \"~\" + zkeyFileName + \".init\";\n    const initFileName = {type: \"bigMem\"};\n    await newZKey(r1csFileName, pTauFileName, initFileName, logger);\n\n    return await phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger);\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function phase2contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger) {\n\n    const {fd: fdOld, sections: sections} = await readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await readHeader$1(fdOld, sections);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await getCurveFromQ(zkey.q);\n\n    const mpcParams = await readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n\n    const rng = await getRandomRng(entropy);\n\n    const transcriptHasher = blake2b.create({ dkLen: 64 });\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 0;\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await writeHeader(fdNew, zkey);\n\n    // IC\n    await copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await applyKeyToSection(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await applyKeyToSection(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = blake2b.create({ dkLen: 64 });\n    hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n    if (logger) logger.info(formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function beacon(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger) {\n    const beaconHash = hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections: sections} = await readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await readHeader$1(fdOld, sections);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n\n    const curve = await getCurveFromQ(zkey.q);\n\n    const mpcParams = await readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n    const rng = await rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const transcriptHasher = blake2b.create({ dkLen: 64 });    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 1;\n    curContribution.numIterationsExp = numIterationsExp;\n    curContribution.beaconHash = beaconHash;\n\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await writeHeader(fdNew, zkey);\n\n    // IC\n    await copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await applyKeyToSection(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await applyKeyToSection(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = blake2b.create({ dkLen: 64 });    hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n\nasync function zkeyExportJson(zkeyFileName) {\n\n    const zKey = await readZKey(zkeyFileName, true);\n    delete zKey.curve;\n    delete zKey.F;\n\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils.stringifyBigInts(zKey);\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nasync function bellmanContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    const rng = await getRandomRng(entropy);\n\n    const delta = curve.Fr.fromRng(rng);\n    const invDelta = curve.Fr.inv(delta);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const fdFrom = await readExisting(challengeFilename);\n    const fdTo = await createOverride(responseFileName);\n\n\n    await copy(sG1); // alpha1\n    await copy(sG1); // beta1\n    await copy(sG2); // beta2\n    await copy(sG2); // gamma2\n    const oldDelta1 = await readG1();\n    const delta1 = curve.G1.timesFr(oldDelta1, delta);\n    await writeG1(delta1);\n    const oldDelta2 = await readG2();\n    const delta2 = curve.G2.timesFr(oldDelta2, delta);\n    await writeG2(delta2);\n\n    // IC\n    const nIC = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nIC);\n    await copy(nIC*sG1);\n\n    // H\n    const nH = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nH);\n    await applyKeyToChallengeSection(fdFrom, fdTo, null, curve, \"G1\", nH, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"H\", logger);\n\n    // L\n    const nL = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nL);\n    await applyKeyToChallengeSection(fdFrom, fdTo, null, curve, \"G1\", nL, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"L\", logger);\n\n    // A\n    const nA = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nA);\n    await copy(nA*sG1);\n\n    // B1\n    const nB1 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB1);\n    await copy(nB1*sG1);\n\n    // B2\n    const nB2 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB2);\n    await copy(nB2*sG2);\n\n\n    //////////\n    /// Read contributions\n    //////////\n    const transcriptHasher = blake2b.create({ dkLen: 64 });\n    const mpcParams = {};\n    // csHash\n    mpcParams.csHash =  await fdFrom.read(64);\n    transcriptHasher.update(mpcParams.csHash);\n\n    const nContributions = await fdFrom.readUBE32();\n    mpcParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1();\n        c.delta.g1_s = await readG1();\n        c.delta.g1_sx = await readG1();\n        c.delta.g2_spx = await readG2();\n        c.transcript = await fdFrom.read(64);\n        mpcParams.contributions.push(c);\n        hashPubKey(transcriptHasher, curve, c);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = delta;\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, delta));\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = hashToG2(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, delta));\n    curContribution.deltaAfter = delta1;\n    curContribution.type = 0;\n    mpcParams.contributions.push(curContribution);\n\n\n    //////////\n    /// Write Contribution\n    //////////\n\n    await fdTo.write(mpcParams.csHash);\n    await fdTo.writeUBE32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdTo.write(c.transcript);\n    }\n\n    const contributionHasher = blake2b.create({ dkLen: 64 });    hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(formatHash(contributionHash, \"Contribution Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n\n    return contributionHash;\n\n    async function copy(nBytes) {\n        const CHUNK_SIZE = fdFrom.pageSize*2;\n        for (let i=0; i<nBytes; i+= CHUNK_SIZE) {\n            const n = Math.min(nBytes -i, CHUNK_SIZE);\n            const buff = await fdFrom.read(n);\n            await fdTo.write(buff);\n        }\n    }\n\n    async function readG1() {\n        const buff = await fdFrom.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2() {\n        const buff = await fdFrom.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst {stringifyBigInts: stringifyBigInts$3} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function zkeyExportVerificationKey(zkeyName, logger) {\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY STARTED\");\n\n    const {fd, sections} = await readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await readHeader$1(fd, sections);\n\n    if (logger) logger.info(\"> Detected protocol: \" + zkey.protocol);\n\n    let res;\n    if (zkey.protocol === \"groth16\") {\n        res = await groth16Vk(zkey, fd, sections);\n    } else if (zkey.protocol === \"plonk\") {\n        res = await plonkVk(zkey);\n    } else if (zkey.protocolId && zkey.protocolId === FFLONK_PROTOCOL_ID) {\n        res = await exportFFlonkVk(zkey);\n    } else {\n        throw new Error(\"zkey file protocol unrecognized\");\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY FINISHED\");\n\n    return res;\n}\n\n\nasync function groth16Vk(zkey, fd, sections) {\n    const curve = await getCurveFromQ(zkey.q);\n    const sG1 = curve.G1.F.n8 * 2;\n\n    const alphaBeta = await curve.pairing(zkey.vk_alpha_1, zkey.vk_beta_2);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n\n        vk_alpha_1: curve.G1.toObject(zkey.vk_alpha_1),\n\n        vk_beta_2: curve.G2.toObject(zkey.vk_beta_2),\n        vk_gamma_2: curve.G2.toObject(zkey.vk_gamma_2),\n        vk_delta_2: curve.G2.toObject(zkey.vk_delta_2),\n\n        vk_alphabeta_12: curve.Gt.toObject(alphaBeta)\n    };\n\n    // Read IC Section\n    ///////////\n    await startReadUniqueSection(fd, sections, 3);\n    vKey.IC = [];\n    for (let i = 0; i <= zkey.nPublic; i++) {\n        const buff = await fd.read(sG1);\n        const P = curve.G1.toObject(buff);\n        vKey.IC.push(P);\n    }\n    await endReadSection(fd);\n\n    vKey = stringifyBigInts$3(vKey);\n\n    return vKey;\n}\n\n\nasync function plonkVk(zkey) {\n    const curve = await getCurveFromQ(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        Qm: curve.G1.toObject(zkey.Qm),\n        Ql: curve.G1.toObject(zkey.Ql),\n        Qr: curve.G1.toObject(zkey.Qr),\n        Qo: curve.G1.toObject(zkey.Qo),\n        Qc: curve.G1.toObject(zkey.Qc),\n        S1: curve.G1.toObject(zkey.S1),\n        S2: curve.G1.toObject(zkey.S2),\n        S3: curve.G1.toObject(zkey.S3),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power])\n    };\n\n    vKey = stringifyBigInts$3(vKey);\n\n    return vKey;\n}\n\nasync function exportFFlonkVk(zkey, logger) {\n    const curve = await getCurveFromQ(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power]),\n        //wW: curve.Fr.toObject(curve.Fr.w[zkey.power + 1]),\n        w3: curve.Fr.toObject(zkey.w3),\n        w4: curve.Fr.toObject(zkey.w4),\n        w8: curve.Fr.toObject(zkey.w8),\n        wr: curve.Fr.toObject(zkey.wr),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        C0: curve.G1.toObject(zkey.C0),\n    };\n\n    return stringifyBigInts$3(vKey);\n}\n\nvar ejs = {};\n\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst {unstringifyBigInts: unstringifyBigInts$6, stringifyBigInts: stringifyBigInts$2} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function fflonkExportSolidityVerifier(vk, templates, logger) {\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER STARTED\");\n\n    const curve = await getCurveFromName(vk.curve);\n\n    // Precompute w3_2, w4_2 and w4_3\n    let w3 = fromVkey(vk.w3);\n    vk.w3_2 = toVkey(curve.Fr.square(w3));\n\n    let w4 = fromVkey(vk.w4);\n    vk.w4_2 = toVkey(curve.Fr.square(w4));\n    vk.w4_3 = toVkey(curve.Fr.mul(curve.Fr.square(w4), w4));\n\n    let w8 = fromVkey(vk.w8);\n    let acc = curve.Fr.one;\n\n    for (let i = 1; i < 8; i++) {\n        acc = curve.Fr.mul(acc, w8);\n        vk[\"w8_\" + i] = toVkey(acc);\n    }\n\n    let template = templates[vk.protocol];\n\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER FINISHED\");\n\n    return ejs.render(template, vk);\n\n    function fromVkey(str) {\n        const val = unstringifyBigInts$6(str);\n        return curve.Fr.fromObject(val);\n    }\n\n    function toVkey(val) {\n        const str = curve.Fr.toObject(val);\n        return stringifyBigInts$2(str);\n    }\n}\n\n// Not ready yet\n// module.exports.generateVerifier_kimleeoh = generateVerifier_kimleeoh;\n\nasync function exportSolidityVerifier(zKeyName, templates, logger) {\n\n    const verificationKey = await zkeyExportVerificationKey(zKeyName, logger);\n\n    if (\"fflonk\" === verificationKey.protocol) {\n        return fflonkExportSolidityVerifier(verificationKey, templates, logger);\n    }\n\n    let template = templates[verificationKey.protocol];\n\n    return ejs.render(template, verificationKey);\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar zkey = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    newZKey: newZKey,\n    exportBellman: phase2exportMPCParams,\n    importBellman: phase2importMPCParams,\n    verifyFromR1cs: phase2verifyFromR1cs,\n    verifyFromInit: phase2verifyFromInit,\n    contribute: phase2contribute,\n    beacon: beacon,\n    exportJson: zkeyExportJson,\n    bellmanContribute: bellmanContribute,\n    exportVerificationKey: zkeyExportVerificationKey,\n    exportSolidityVerifier: exportSolidityVerifier\n});\n\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function plonkSetup(r1csName, ptauName, zkeyName, logger) {\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const {fd: fdPTau, sections: sectionsPTau} = await readBinFile(ptauName, \"ptau\", 1);\n    const {curve, power} = await readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await readBinFile(r1csName, \"r1cs\", 1);\n\n    const r1cs = await readR1csFd(fdR1cs, sectionsR1cs, {loadConstraints: true, loadCustomGates: true});\n\n    const sG1 = curve.G1.F.n8*2;\n    const G1 = curve.G1;\n    const sG2 = curve.G2.F.n8*2;\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n\n    if (logger) logger.info(\"Reading r1cs\");\n    await readSection(fdR1cs, sectionsR1cs, 2);\n\n    const plonkConstraints = new BigArray$1();\n    const plonkAdditions = new BigArray$1();\n    let plonkNVars = r1cs.nVars;\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n\n    await processConstraints(curve.Fr, r1cs, logger);\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const fdZKey = await createBinFile(zkeyName, \"zkey\", 1, 14, 1<<22, 1<<24);\n\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    let cirPower = log2(plonkConstraints.length -1) +1;\n    if (cirPower < 3) cirPower = 3;   // As the t polynomial is n+5 we need at least a power of 4\n    const domainSize = 2 ** cirPower;\n\n    if (logger) logger.info(\"Plonk constraints: \" + plonkConstraints.length);\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${plonkConstraints.length} > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n\n    const LPoints = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(domainSize*sG1);\n    const o = sectionsPTau[12][0].p + ((2 ** (cirPower)) -1)*sG1;\n    await fdPTau.readToBuffer(LPoints, 0, domainSize*sG1, o);\n\n    const [k1, k2] = getK1K2();\n\n    const vk = {};\n\n\n    await writeAdditions(3, \"Additions\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(4, 0, \"Amap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(5, 1, \"Bmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(6, 2, \"Cmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(7, 3, \"Qm\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(8, 4, \"Ql\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(9, 5, \"Qr\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(10, 6, \"Qo\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(11, 7, \"Qc\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeSigma(12, \"sigma\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeLs(13, \"lagrange polynomials\");\n    if (globalThis.gc) {globalThis.gc();}\n\n    // Write PTau points\n    ////////////\n\n    await startWriteSection(fdZKey, 14);\n    const buffOut = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((domainSize+6)*sG1);\n    await fdPTau.readToBuffer(buffOut, 0, (domainSize+6)*sG1, sectionsPTau[2][0].p);\n    await fdZKey.write(buffOut);\n    await endWriteSection(fdZKey);\n    if (globalThis.gc) {globalThis.gc();}\n\n\n    await writeHeaders();\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"Setup Finished\");\n\n    return ;\n\n    async function processConstraints(Fr, r1cs, logger) {\n\n        function normalize(linearComb) {\n            const ss = Object.keys(linearComb);\n            for (let i = 0; i < ss.length; i++) {\n                if (linearComb[ss[i]] == 0n) delete linearComb[ss[i]];\n            }\n        }\n\n        function join(linearComb1, k, linearComb2) {\n            const res = {};\n\n            for (let s in linearComb1) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = Fr.mul(k, linearComb1[s]);\n                } else {\n                    res[s] = Fr.add(res[s], Fr.mul(k, linearComb1[s]));\n                }\n            }\n\n            for (let s in linearComb2) {\n                const val = Fr.neg(linearComb2[s]);\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = val;\n                } else {\n                    res[s] = Fr.add(res[s], val);\n                }\n            }\n            normalize(res);\n            return res;\n        }\n\n        function reduceCoefs(linearComb, maxC) {\n            const res = {\n                k: Fr.zero,\n                s: [],\n                coefs: []\n            };\n            const cs = [];\n\n            for (let s in linearComb) {\n                if (s == 0) {\n                    res.k = Fr.add(res.k, linearComb[s]);\n                } else if (linearComb[s] != 0n) {\n                    cs.push([Number(s), linearComb[s]]);\n                }\n            }\n            while (cs.length > maxC) {\n                const c1 = cs.shift();\n                const c2 = cs.shift();\n\n                const sl = c1[0];\n                const sr = c2[0];\n                const so = plonkNVars++;\n                const qm = Fr.zero;\n                const ql = Fr.neg(c1[1]);\n                const qr = Fr.neg(c2[1]);\n                const qo = Fr.one;\n                const qc = Fr.zero;\n\n                plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n\n                plonkAdditions.push([sl, sr, c1[1], c2[1]]);\n\n                cs.push([so, Fr.one]);\n            }\n            for (let i = 0; i < cs.length; i++) {\n                res.s[i] = cs[i][0];\n                res.coefs[i] = cs[i][1];\n            }\n            while (res.coefs.length < maxC) {\n                res.s.push(0);\n                res.coefs.push(Fr.zero);\n            }\n            return res;\n        }\n\n        function addConstraintSum(lc) {\n            const C = reduceCoefs(lc, 3);\n            const sl = C.s[0];\n            const sr = C.s[1];\n            const so = C.s[2];\n            const qm = Fr.zero;\n            const ql = C.coefs[0];\n            const qr = C.coefs[1];\n            const qo = C.coefs[2];\n            const qc = C.k;\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function addConstraintMul(lcA, lcB, lcC) {\n            const A = reduceCoefs(lcA, 1);\n            const B = reduceCoefs(lcB, 1);\n            const C = reduceCoefs(lcC, 1);\n\n\n            const sl = A.s[0];\n            const sr = B.s[0];\n            const so = C.s[0];\n            const qm = Fr.mul(A.coefs[0], B.coefs[0]);\n            const ql = Fr.mul(A.coefs[0], B.k);\n            const qr = Fr.mul(A.k, B.coefs[0]);\n            const qo = Fr.neg(C.coefs[0]);\n            const qc = Fr.sub(Fr.mul(A.k, B.k), C.k);\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function getLinearCombinationType(lc) {\n            let k = Fr.zero;\n            let n = 0;\n            const ss = Object.keys(lc);\n            for (let i = 0; i < ss.length; i++) {\n                if (lc[ss[i]] == 0n) {\n                    delete lc[ss[i]];\n                } else if (ss[i] == 0) {\n                    k = Fr.add(k, lc[ss[i]]);\n                } else {\n                    n++;\n                }\n            }\n            if (n > 0) return n.toString();\n            if (k != Fr.zero) return \"k\";\n            return \"0\";\n        }\n\n        function process(lcA, lcB, lcC) {\n            const lctA = getLinearCombinationType(lcA);\n            const lctB = getLinearCombinationType(lcB);\n            if ((lctA === \"0\") || (lctB === \"0\")) {\n                normalize(lcC);\n                addConstraintSum(lcC);\n            } else if (lctA === \"k\") {\n                const lcCC = join(lcB, lcA[0], lcC);\n                addConstraintSum(lcCC);\n            } else if (lctB === \"k\") {\n                const lcCC = join(lcA, lcB[0], lcC);\n                addConstraintSum(lcCC);\n            } else {\n                addConstraintMul(lcA, lcB, lcC);\n            }\n        }\n\n        for (let s = 1; s <= nPublic; s++) {\n            const sl = s;\n            const sr = 0;\n            const so = 0;\n            const qm = Fr.zero;\n            const ql = Fr.one;\n            const qr = Fr.zero;\n            const qo = Fr.zero;\n            const qc = Fr.zero;\n\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        for (let c = 0; c < r1cs.constraints.length; c++) {\n            if ((logger) && (c % 10000 === 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            process(...r1cs.constraints[c]);\n        }\n    }\n\n    async function writeWitnessMap(sectionNum, posConstraint, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeQMap(sectionNum, posConstraint, name) {\n        let Q = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(domainSize*n8r);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i*n8r);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await startWriteSection(fdZKey, sectionNum);\n        await writeP4(Q);\n        await endWriteSection(fdZKey);\n        Q = await Fr.batchFromMontgomery(Q);\n        vk[name]= await curve.G1.multiExpAffine(LPoints, Q, logger, \"multiexp \"+name);\n    }\n\n    async function writeP4(buff) {\n        const q = await Fr.ifft(buff);\n        const q4 = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(domainSize*n8r*4);\n        q4.set(q, 0);\n        const Q4 = await Fr.fft(q4);\n        await fdZKey.write(q);\n        await fdZKey.write(Q4);\n    }\n\n    async function writeAdditions(sectionNum, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        const buffOut = new Uint8Array((2*4+2*n8r));\n        const buffOutV = new DataView(buffOut.buffer);\n        for (let i=0; i<plonkAdditions.length; i++) {\n            const addition=plonkAdditions[i];\n            let o=0;\n            buffOutV.setUint32(o, addition[0], true); o+=4;\n            buffOutV.setUint32(o, addition[1], true); o+=4;\n            // The value is stored in Montgomery. stored = v*R\n            // so when montgomery multiplied by the witness, it's result = v*R*w/R = v*w\n            buffOut.set(addition[2], o); o+= n8r;\n            buffOut.set(addition[3], o); o+= n8r;\n            await fdZKey.write(buffOut);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkAdditions.length}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeSigma(sectionNum, name) {\n        const sigma = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(n8r*domainSize*3);\n        const lastAparence =  new BigArray$1(plonkNVars);\n        const firstPos = new BigArray$1(plonkNVars);\n        let w = Fr.one;\n        for (let i=0; i<domainSize;i++) {\n            if (i<plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], domainSize + i);\n                buildSigma(plonkConstraints[i][2], domainSize*2 + i);\n            } else {\n                buildSigma(0, i);\n                buildSigma(0, domainSize + i);\n                buildSigma(0, domainSize*2 + i);\n            }\n            w = Fr.mul(w, Fr.w[cirPower]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name} phase1: ${i}/${plonkConstraints.length}`);\n        }\n        for (let s=0; s<plonkNVars; s++) {\n            if (typeof firstPos[s] !== \"undefined\") {\n                sigma.set(lastAparence[s], firstPos[s]*n8r);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger)&&(s%1000000 == 0)) logger.debug(`writing ${name} phase2: ${s}/${plonkNVars}`);\n        }\n\n        if (globalThis.gc) {globalThis.gc();}\n        await startWriteSection(fdZKey, sectionNum);\n        let S1 = sigma.slice(0, domainSize*n8r);\n        await writeP4(S1);\n        if (globalThis.gc) {globalThis.gc();}\n        let S2 = sigma.slice(domainSize*n8r, domainSize*n8r*2);\n        await writeP4(S2);\n        if (globalThis.gc) {globalThis.gc();}\n        let S3 = sigma.slice(domainSize*n8r*2, domainSize*n8r*3);\n        await writeP4(S3);\n        if (globalThis.gc) {globalThis.gc();}\n        await endWriteSection(fdZKey);\n\n        S1 = await Fr.batchFromMontgomery(S1);\n        S2 = await Fr.batchFromMontgomery(S2);\n        S3 = await Fr.batchFromMontgomery(S3);\n\n        vk.S1= await curve.G1.multiExpAffine(LPoints, S1, logger, \"multiexp S1\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S2= await curve.G1.multiExpAffine(LPoints, S2, logger, \"multiexp S2\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S3= await curve.G1.multiExpAffine(LPoints, S3, logger, \"multiexp S3\");\n        if (globalThis.gc) {globalThis.gc();}\n\n        function buildSigma(s, p) {\n            if (typeof lastAparence[s] === \"undefined\") {\n                firstPos[s] = p;\n            } else {\n                sigma.set(lastAparence[s], p*n8r);\n            }\n            let v;\n            if (p<domainSize) {\n                v = w;\n            } else if (p<2*domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n            lastAparence[s]=v;\n        }\n    }\n\n    async function writeLs(sectionNum, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        const l=Math.max(nPublic, 1);\n        for (let i=0; i<l; i++) {\n            let buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(domainSize*n8r);\n            buff.set(Fr.one, i*n8r);\n            await writeP4(buff);\n            if (logger) logger.debug(`writing ${name} ${i}/${l}`);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeHeaders() {\n\n        // Write the header\n        ///////////\n        await startWriteSection(fdZKey, 1);\n        await fdZKey.writeULE32(2); // Plonk\n        await endWriteSection(fdZKey);\n\n        // Write the Plonk header section\n        ///////////\n\n        await startWriteSection(fdZKey, 2);\n        const primeQ = curve.q;\n        const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n        const primeR = curve.r;\n        const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n        await fdZKey.writeULE32(n8q);\n        await writeBigInt(fdZKey, primeQ, n8q);\n        await fdZKey.writeULE32(n8r);\n        await writeBigInt(fdZKey, primeR, n8r);\n        await fdZKey.writeULE32(plonkNVars);                         // Total number of bars\n        await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n        await fdZKey.writeULE32(domainSize);                  // domainSize\n        await fdZKey.writeULE32(plonkAdditions.length);                  // domainSize\n        await fdZKey.writeULE32(plonkConstraints.length); \n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(G1.toAffine(vk.Qm));\n        await fdZKey.write(G1.toAffine(vk.Ql));\n        await fdZKey.write(G1.toAffine(vk.Qr));\n        await fdZKey.write(G1.toAffine(vk.Qo));\n        await fdZKey.write(G1.toAffine(vk.Qc));\n\n        await fdZKey.write(G1.toAffine(vk.S1));\n        await fdZKey.write(G1.toAffine(vk.S2));\n        await fdZKey.write(G1.toAffine(vk.S3));\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, sectionsPTau[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        await endWriteSection(fdZKey);\n    }\n\n    function getK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize= 2**pow;\n            let w = Fr.one;\n            for (let i=0; i<domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j=0; j<kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass Proof {\n    constructor(curve, logger) {\n        this.curve = curve;\n        this.logger = logger;\n\n        this.resetProof();\n    }\n\n    resetProof() {\n        this.polynomials = {};\n        this.evaluations = {};\n    }\n\n    addPolynomial(key, polynomial) {\n        if (key in this.polynomials) {\n            this.logger.warn(`proof: polynomial.${key} already exist in proof`);\n        }\n        this.polynomials[key] = polynomial;\n    }\n\n    getPolynomial(key) {\n        if (!(key in this.polynomials)) {\n            this.logger.warn(`proof: polynomial ${key} does not exist in proof`);\n        }\n        return this.polynomials[key];\n    }\n\n    addEvaluation(key, evaluation) {\n        if (key in this.evaluations) {\n            this.logger.warn(`proof: evaluations.${key} already exist in proof`);\n        }\n        this.evaluations[key] = evaluation;\n    }\n\n    getEvaluation(key) {\n        if (!(key in this.evaluations)) {\n            this.logger.warn(`proof: evaluation ${key} does not exist in proof`);\n        }\n        return this.evaluations[key];\n    }\n\n    toObjectProof(splitFields = true) {\n        let res = splitFields ? {polynomials: {}, evaluations: {}} : {};\n\n        Object.keys(this.polynomials).forEach(key => {\n            const value = this.curve.G1.toObject(this.polynomials[key]);\n            if(splitFields) {\n                res.polynomials[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        Object.keys(this.evaluations).forEach(key => {\n            const value = this.curve.Fr.toObject(this.evaluations[key]);\n            if(splitFields) {\n                res.evaluations[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        return res;\n    }\n\n    fromObjectProof(objectProof) {\n        this.resetProof();\n\n        Object.keys(objectProof.polynomials).forEach(key => {\n            this.polynomials[key] = this.curve.G1.fromObject(objectProof.polynomials[key]);\n        });\n\n        Object.keys(objectProof.evaluations).forEach(key => {\n            this.evaluations[key] = this.curve.Fr.fromObject(objectProof.evaluations[key]);\n        });\n    }\n}\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        if (!isLE)\n            byteSwap32(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!isLE)\n            byteSwap32(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        exists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        exists(this, false);\n        bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        output(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nconst keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst POLYNOMIAL = 0;\nconst SCALAR = 1;\n\nclass Keccak256Transcript {\n    constructor(curve) {\n        this.G1 = curve.G1;\n        this.Fr = curve.Fr;\n\n        this.reset();\n    }\n\n    reset() {\n        this.data = [];\n    }\n\n    addPolCommitment(polynomialCommitment) {\n        this.data.push({type: POLYNOMIAL, data: polynomialCommitment});\n    }\n\n    addScalar(scalar) {\n        this.data.push({type: SCALAR, data: scalar});\n    }\n\n    getChallenge() {\n        if(0 === this.data.length) {\n            throw new Error(\"Keccak256Transcript: No data to generate a transcript\");\n        }\n\n        let nPolynomials = 0;\n        let nScalars = 0;\n\n        this.data.forEach(element => POLYNOMIAL === element.type ? nPolynomials++ : nScalars++);\n\n        let buffer = new Uint8Array(nScalars * this.Fr.n8 + nPolynomials * this.G1.F.n8 * 2);\n        let offset = 0;\n\n        for (let i = 0; i < this.data.length; i++) {\n            if (POLYNOMIAL === this.data[i].type) {\n                this.G1.toRprUncompressed(buffer, offset, this.data[i].data);\n                offset += this.G1.F.n8 * 2;\n            } else {\n                this.Fr.toRprBE(buffer, offset, this.data[i].data);\n                offset += this.Fr.n8;\n            }\n        }\n\n        const value = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprBE(keccak_256(buffer));\n        return this.Fr.e(value);\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass MulZ {\n    static getZ1(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(-1), Fr.w[2]),\n            Fr.e(-2),\n            Fr.sub(Fr.e(-1), Fr.w[2]),\n        ];\n    }\n\n    static getZ2(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n            Fr.e(4),\n            Fr.sub(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n        ];\n    }\n\n    static getZ3(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n            Fr.e(-8),\n            Fr.sub(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n        ];\n\n    }\n\n    static mul2(a, b, ap, bp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = a_b;\n\n        let a0 = Fr.add(a_bp, ap_b);\n\n        let a1 = ap_bp;\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n        }\n\n        return [r, rz];\n    }\n\n    static mul3(a, b, c, ap, bp, cp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = Fr.mul(a_b, c);\n\n        let a0 = Fr.mul(ap_b, c);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp));\n\n        let a1 = Fr.mul(ap_bp, c);\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp));\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp));\n\n        rz = a0;\n        if (p) {\n            const a2 = Fr.mul(ap_bp, cp);\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n        }\n\n        return [r, rz];\n    }\n\n    static mul4(a, b, c, d, ap, bp, cp, dp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        const Z3 = this.getZ3(Fr);\n\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        const c_d = Fr.mul(c, d);\n        const c_dp = Fr.mul(c, dp);\n        const cp_d = Fr.mul(cp, d);\n        const cp_dp = Fr.mul(cp, dp);\n\n        r = Fr.mul(a_b, c_d);\n\n        let a0 = Fr.mul(ap_b, c_d);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, c_dp));\n\n        let a1 = Fr.mul(ap_bp, c_d);\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp_d));\n        a1 = Fr.add(a1, Fr.mul(ap_b, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp_d));\n        a1 = Fr.add(a1, Fr.mul(a_bp, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_b, cp_dp));\n\n        let a2 = Fr.mul(a_bp, cp_dp);\n        a2 = Fr.add(a2, Fr.mul(ap_b, cp_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, c_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, cp_d));\n\n        let a3 = Fr.mul(ap_bp, cp_dp);\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n            rz = Fr.add(rz, Fr.mul(Z3[p], a3));\n        }\n\n        return [r, rz];\n    }\n}\n\nconst ZKEY_PL_ADDITIONS_SECTION = 3;\nconst ZKEY_PL_A_MAP_SECTION = 4;\nconst ZKEY_PL_B_MAP_SECTION = 5;\nconst ZKEY_PL_C_MAP_SECTION = 6;\nconst ZKEY_PL_QM_SECTION = 7;\nconst ZKEY_PL_QL_SECTION = 8;\nconst ZKEY_PL_QR_SECTION = 9;\nconst ZKEY_PL_QO_SECTION = 10;\nconst ZKEY_PL_QC_SECTION = 11;\nconst ZKEY_PL_SIGMA_SECTION = 12;\nconst ZKEY_PL_LAGRANGE_SECTION = 13;\nconst ZKEY_PL_PTAU_SECTION = 14;\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass Polynomial {\n    constructor(coefficients, curve, logger) {\n        this.coef = coefficients;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    static async fromEvaluations(buffer, curve, logger) {\n        let coefficients = await curve.Fr.ifft(buffer);\n\n        return new Polynomial(coefficients, curve, logger);\n    }\n\n    static fromCoefficientsArray(array, curve, logger) {\n        const Fr = curve.Fr;\n        let buff = array.length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(array.length * Fr.n8) : new Uint8Array(array.length * Fr.n8);\n        for (let i = 0; i < array.length; i++) buff.set(array[i], i * Fr.n8);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    static fromPolynomial(polynomial, curve, logger) {\n        let length = polynomial.length();\n        let Fr = curve.Fr;\n\n        let buff = length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        buff.set(polynomial.coef.slice(), 0);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    isEqual(polynomial) {\n        const degree = this.degree();\n        if (degree !== polynomial.degree()) return false;\n\n        for (let i = 0; i < degree + 1; i++) {\n            if (!this.Fr.eq(this.getCoef(i), polynomial.getCoef(i))) return false;\n        }\n\n        return true;\n    }\n\n    blindCoefficients(blindingFactors) {\n        blindingFactors = blindingFactors || [];\n\n        const blindedCoefficients = (this.length() + blindingFactors.length) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((this.length() + blindingFactors.length) * this.Fr.n8) :\n            new Uint8Array((this.length() + blindingFactors.length) * this.Fr.n8);\n\n        blindedCoefficients.set(this.coef, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            blindedCoefficients.set(\n                this.Fr.add(\n                    blindedCoefficients.slice((this.length() + i) * this.Fr.n8, (this.length() + i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                (this.length() + i) * this.Fr.n8\n            );\n            blindedCoefficients.set(\n                this.Fr.sub(\n                    blindedCoefficients.slice(i * this.Fr.n8, (i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * this.Fr.n8\n            );\n        }\n        this.coef = blindedCoefficients;\n    }\n\n    getCoef(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.coef.byteLength) return this.Fr.zero;\n\n        return this.coef.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    setCoef(index, value) {\n        if (index > (this.length() - 1)) {\n            throw new Error(\"Coef index is not available\");\n        }\n\n        this.coef.set(value, index * this.Fr.n8);\n    }\n\n    static async to4T(buffer, domainSize, blindingFactors, Fr) {\n        blindingFactors = blindingFactors || [];\n        let a = await Fr.ifft(buffer);\n\n        const a4 = (domainSize * 4) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(domainSize * 4 * Fr.n8) : new Uint8Array(domainSize * 4 * Fr.n8);\n        a4.set(a, 0);\n\n        const A4 = await Fr.fft(a4);\n\n        if (blindingFactors.length === 0) {\n            return [a, A4];\n        }\n\n        const a1 = domainSize + blindingFactors.length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((domainSize + blindingFactors.length) * Fr.n8) :\n            new Uint8Array((domainSize + blindingFactors.length) * Fr.n8);\n\n        a1.set(a, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            a1.set(\n                Fr.add(\n                    a1.slice((domainSize + i) * Fr.n8, (domainSize + i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                (domainSize + i) * Fr.n8\n            );\n            a1.set(\n                Fr.sub(\n                    a1.slice(i * Fr.n8, (i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * Fr.n8\n            );\n        }\n\n        return [a1, A4];\n    }\n\n    length() {\n        let length = this.coef.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.coef.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial coefficients buffer has incorrect size\");\n        }\n        if (0 === length) {\n            if (this.logger) {\n                this.logger.warn(\"Polynomial has length zero\");\n            }\n        }\n        return length;\n    }\n\n    degree() {\n        for (let i = this.length() - 1; i > 0; i--) {\n            const i_n8 = i * this.Fr.n8;\n            if (!this.Fr.eq(this.Fr.zero, this.coef.slice(i_n8, i_n8 + this.Fr.n8))) {\n                return i;\n            }\n        }\n\n        return 0;\n    }\n\n    evaluate(point) {\n        let res = this.Fr.zero;\n\n        for (let i = this.degree() + 1; i > 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            const currentCoefficient = this.coef.slice(i_n8 - this.Fr.n8, i_n8);\n            res = this.Fr.add(currentCoefficient, this.Fr.mul(res, point));\n        }\n\n        return res;\n    }\n\n    fastEvaluate(point) {\n        const Fr = this.Fr;\n        let nThreads = 3;\n\n        let nCoefs = this.degree() + 1;\n        let coefsThread = parseInt(nCoefs / nThreads);\n        let residualCoefs = nCoefs - coefsThread * nThreads;\n\n        let res = [];\n        let xN = [];\n\n        xN[0] = Fr.one;\n\n        for (let i = 0; i < nThreads; i++) {\n            res[i] = Fr.zero;\n\n            let nCoefs = i === (nThreads - 1) ? coefsThread + residualCoefs : coefsThread;\n            for (let j = nCoefs; j > 0; j--) {\n                res[i] = Fr.add(this.getCoef((i * coefsThread) + j - 1), Fr.mul(res[i], point));\n\n                if (i === 0) xN[0] = Fr.mul(xN[0], point);\n            }\n        }\n\n        for (let i = 1; i < nThreads; i++) {\n            res[0] = Fr.add(res[0], Fr.mul(xN[i - 1], res[i]));\n            xN[i] = Fr.mul(xN[i - 1], xN[0]);\n        }\n\n        return res[0];\n    }\n\n    add(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.add(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.add(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    sub(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.sub(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.sub(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    mulScalar(value) {\n        for (let i = 0; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            this.coef.set(this.Fr.mul(this.coef.slice(i_n8, i_n8 + this.Fr.n8), value), i_n8);\n        }\n    }\n\n    addScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.add(currentValue, value), 0);\n    }\n\n    subScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.sub(currentValue, value), 0);\n    }\n\n    // Multiply current polynomial by the polynomial (X - value)\n    byXSubValue(value) {\n        const Fr = this.Fr;\n        const resize = !Fr.eq(Fr.zero, this.getCoef(this.length() - 1));\n\n        const length = resize ? this.length() + 1 : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (length - 1) * Fr.n8), 32);\n\n        // Step 1: multiply each coefficient by (-value)\n        this.mulScalar(Fr.neg(value));\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Multiply current polynomial by the polynomial (X^n + value)\n    byXNSubValue(n, value) {\n        const Fr = this.Fr;\n        const resize = !(this.length() - n - 1 >= this.degree());\n\n        const length = resize ? this.length() + n : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (this.degree() + 1) * 32, ), n * 32);\n\n        // Step 1: multiply each coefficient by (- value)\n        this.mulScalar(value);\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Euclidean division\n    divBy(polynomial) {\n        const Fr = this.Fr;\n        const degreeA = this.degree();\n        const degreeB = polynomial.degree();\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = degreeA - degreeB; i >= 0; i--) {\n            this.setCoef(i, Fr.div(polR.getCoef(i + degreeB), polynomial.getCoef(degreeB)));\n            for (let j = 0; j <= degreeB; j++) {\n                polR.setCoef(i + j, Fr.sub(polR.getCoef(i + j), Fr.mul(this.getCoef(i), polynomial.getCoef(j))));\n            }\n        }\n\n        return polR;\n    }\n\n    // Division by a Polynomial of the form (x^m - beta)\n    divByMonic(m, beta) {\n        const Fr = this.Fr;\n\n        let d = this.degree();\n\n        let buffer = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n        let quotient = new Polynomial(buffer, this.curve, this.logger);\n\n        let bArr = [];\n\n        // Add the m leading coefficients of this to quotient\n        for (let i = 0; i < m; i++) {\n            quotient.setCoef((d - i) - m, this.getCoef(d - i));\n            bArr[i] = this.getCoef(d - i);\n        }\n\n        let nThreads = m;\n        for (let k = 0; k < nThreads; k++) {\n            for (let i = d - 2 * m - k; i >= 0; i = i - nThreads) {\n                if (i < 0) break;\n                let idx = k;\n                bArr[idx] = Fr.add(this.getCoef(i + m), Fr.mul(bArr[idx], beta));\n\n                quotient.setCoef(i, bArr[idx]);\n            }\n        }\n\n        this.coef = quotient.coef;\n    }\n\n    divByVanishing(n, beta) {\n        if (this.degree() < n) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = this.length() - 1; i >= n; i--) {\n            let leadingCoef = polR.getCoef(i);\n            if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n            polR.setCoef(i, Fr.zero);\n            polR.setCoef(i - n, Fr.add(polR.getCoef(i - n), Fr.mul(beta, leadingCoef)));\n            this.setCoef(i - n, Fr.add(this.getCoef(i - n), leadingCoef));\n        }\n\n        return polR;\n    }\n\n    divByVanishing2(m, beta) {\n        if (this.degree() < m) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        let nThreads = 3;\n        let nTotal = this.length() - m;\n        let nElementsChunk = Math.floor(nTotal / nThreads);\n        let nElementsLast = nTotal - (nThreads - 1) * nElementsChunk;\n\n        console.log(nTotal);\n        console.log(nElementsChunk + \"  \" + nElementsLast);\n        for (let k = 0; k < nThreads; k++) {\n            console.log(\"> Thread \" + k);\n            for (let i = (k === 0 ? nElementsLast : nElementsChunk); i > 0; i--) {\n                let idxDst = i - 1;\n                if (k !== 0) idxDst += (k - 1) * nElementsChunk + nElementsLast;\n                let idxSrc = idxDst + m;\n\n                let leadingCoef = polR.getCoef(idxSrc);\n                if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n                polR.setCoef(idxSrc, Fr.zero);\n                polR.setCoef(idxDst, Fr.add(polR.getCoef(idxDst), Fr.mul(beta, leadingCoef)));\n                this.setCoef(idxDst, Fr.add(this.getCoef(idxDst), leadingCoef));\n                console.log(idxDst + \" <-- \" + idxSrc);\n            }\n        }\n\n        this.print();\n        return polR;\n    }\n\n    fastDivByVanishing(data) {\n        const Fr = this.Fr;\n\n        for (let i = 0; i < data.length; i++) {\n\n            let m = data[i][0];\n            let beta = data[i][1];\n\n            if (this.degree() < m) {\n                throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n            }\n\n            let nThreads = 5;\n            let nElements = this.length() - m;\n            let nElementsBucket = Math.floor(nElements / nThreads / m);\n            let nElementsChunk = nElementsBucket * m;\n            let nElementsLast = nElements - nThreads * nElementsChunk;\n\n            //In C++ implementation this buffer will be allocated only once outside the loop\n            let polTmp = new Polynomial(this.length() > 2 << 14 ?\n                new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8), this.curve, this.logger);\n\n            let ptr = this.coef;\n            this.coef = polTmp.coef;\n            polTmp.coef = ptr;\n\n            // STEP 1: Setejar els m valors del segent bucket al chunk actual, PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n                let idx0 = (k + 1) * nElementsChunk + nElementsLast;\n                for (let i = 0; i < m; i++) {\n                    this.setCoef(idx0 + i - m, polTmp.getCoef(idx0 + i));\n                }\n\n                for (let i = 0; i < nElementsChunk - m; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                    this.setCoef(offset - m, val);\n                }\n            }\n\n            //STEP 2: Setejar els valors del elements last NO PARALLELITZAR\n            let idx0 = nElementsLast;\n            let pending = nElementsLast;\n            for (let i = 0; i < m && pending; i++) {\n                this.setCoef(idx0 - i - 1, polTmp.getCoef(idx0 + m - i - 1));\n                pending--;\n            }\n\n            for (let i = 0; i < pending; i++) {\n                let offset = idx0 - i - 1;\n                let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                this.setCoef(offset - m, val);\n            }\n\n            //Step 3: calcular acumulats NO  PARALELLITZAR\n\n            let acc = [];\n            let betaPow = Fr.one;\n            for (let i = 0; i < nElementsBucket; i++) {\n                betaPow = Fr.mul(betaPow, beta);\n            }\n            let currentBeta = Fr.one;\n\n            for (let k = nThreads; k > 0; k--) {\n                let idThread = k - 1;\n                let idx0 = idThread * nElementsChunk + nElementsLast;\n                acc[idThread] = [];\n\n                for (let i = 0; i < m; i++) {\n                    acc[idThread][i] = this.getCoef(idx0 + i);\n\n                    if (k !== nThreads) {\n                        acc[idThread][i] = Fr.add(acc[idThread][i], Fr.mul(betaPow, acc[idThread + 1][i]));\n                    }\n                }\n                currentBeta = Fr.mul(currentBeta, betaPow);\n            }\n\n            //STEP 4 recalcular  PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n\n                let idx0 = k * nElementsChunk + nElementsLast;\n                let currentBeta = beta; //Quan hopassem a C++ i ho paralelitzem aquesta variable ha de ser privada\n                let currentM = m - 1;\n\n                let limit = k === 0 ? nElementsLast : nElementsChunk;\n                for (let i = 0; i < limit; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(this.getCoef(offset), Fr.mul(currentBeta, acc[k][currentM]));\n\n                    this.setCoef(offset, val);\n\n                    // To avoid modular operations in each loop...\n                    if (currentM === 0) {\n                        currentM = m - 1;\n                        currentBeta = Fr.mul(currentBeta, beta);\n                    } else {\n                        currentM--;\n                    }\n                }\n            }\n        }\n    }\n\n\n    // Divide polynomial by X - value\n    divByXSubValue(value) {\n        const coefs = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * this.Fr.n8) : new Uint8Array(this.length() * this.Fr.n8);\n\n        coefs.set(this.Fr.zero, (this.length() - 1) * this.Fr.n8);\n        coefs.set(this.coef.slice((this.length() - 1) * this.Fr.n8, this.length() * this.Fr.n8), (this.length() - 2) * this.Fr.n8);\n        for (let i = this.length() - 3; i >= 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            coefs.set(\n                this.Fr.add(\n                    this.coef.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8),\n                    this.Fr.mul(value, coefs.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8))\n                ),\n                i * this.Fr.n8\n            );\n        }\n        if (!this.Fr.eq(\n            this.coef.slice(0, this.Fr.n8),\n            this.Fr.mul(this.Fr.neg(value), coefs.slice(0, this.Fr.n8))\n        )) {\n            throw new Error(\"Polynomial does not divide\");\n        }\n\n        this.coef = coefs;\n    }\n\n    divZh(domainSize, extensions = 4) {\n        for (let i = 0; i < domainSize; i++) {\n            const i_n8 = i * this.Fr.n8;\n            this.coef.set(this.Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8)), i_n8);\n        }\n\n        const upperBound = this.coef.byteLength / this.Fr.n8;\n        for (let i = domainSize; i < upperBound; i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = this.Fr.sub(\n                this.coef.slice((i - domainSize) * this.Fr.n8, (i - domainSize) * this.Fr.n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n            this.coef.set(a, i_n8);\n            if (i > (domainSize * (extensions-1) - extensions)) {\n                if (!this.Fr.isZero(a)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n    divByZerofier(n, beta) {\n        let Fr = this.Fr;\n        const invBeta = Fr.inv(beta);\n        const invBetaNeg = Fr.neg(invBeta);\n\n        let isOne = Fr.eq(Fr.one, invBetaNeg);\n        let isNegOne = Fr.eq(Fr.negone, invBetaNeg);\n\n        if (!isOne) {\n            for (let i = 0; i < n; i++) {\n                const i_n8 = i * this.Fr.n8;\n                let element;\n\n                // If invBetaNeg === -1 we'll save a multiplication changing it by a neg function call\n                if (isNegOne) {\n                    element = Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                } else {\n                    element = Fr.mul(invBetaNeg, this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                }\n\n                this.coef.set(element, i_n8);\n            }\n        }\n\n        isOne = Fr.eq(Fr.one, invBeta);\n        isNegOne = Fr.eq(Fr.negone, invBeta);\n\n        for (let i = n; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n            const i_prev_n8 = (i - n) * this.Fr.n8;\n\n            let element = this.Fr.sub(\n                this.coef.slice(i_prev_n8, i_prev_n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n\n            // If invBeta === 1 we'll not do anything\n            if(!isOne) {\n                // If invBeta === -1 we'll save a multiplication changing it by a neg function call\n                if(isNegOne) {\n                    element = Fr.neg(element);\n                } else {\n                    element = Fr.mul(invBeta, element);\n                }\n            }\n\n            this.coef.set(element, i_n8);\n\n            // Check if polynomial is divisible by checking if n high coefficients are zero\n            if (i > this.length() - n - 1) {\n                if (!this.Fr.isZero(element)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n// function divideByVanishing(f, n, p) {\n//     // polynomial division f(X) / (X^n - 1) with remainder\n//     // very cheap, 0 multiplications\n//     // strategy:\n//     // start with q(X) = 0, r(X) = f(X)\n//     // then start changing q, r while preserving the identity:\n//     // f(X) = q(X) * (X^n - 1) + r(X)\n//     // in every step, move highest-degree term of r into the product\n//     // => r eventually has degree < n and we're done\n//     let q = Array(f.length).fill(0n);\n//     let r = [...f];\n//     for (let i = f.length - 1; i >= n; i--) {\n//         let leadingCoeff = r[i];\n//         if (leadingCoeff === 0n) continue;\n//         r[i] = 0n;\n//         r[i - n] = mod(r[i - n] + leadingCoeff, p);\n//         q[i - n] = mod(q[i - n] + leadingCoeff, p);\n//     }\n//     return [q, r];\n// }\n\n    byX() {\n        const coefs = (this.length() + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.coef.byteLength + this.Fr.n8) : new Uint8Array(this.coef.byteLength + this.Fr.n8);\n        coefs.set(this.Fr.zero, 0);\n        coefs.set(this.coef, this.Fr.n8);\n\n        this.coef = coefs;\n    }\n\n// Compute a new polynomial f(x^n) from f(x)\n// f(x)   = a_0 + a_1x + a_2x^2 + ... + a_jx^j\n// f(x^n) = a_0 + a_1x^n + a_2x^2n + ... + a_jx^jn\n    static\n    async expX(polynomial, n, truncate = false) {\n        const Fr = polynomial.Fr;\n\n        if (n < 1) {\n            // n == 0 not allowed because it has no sense, but if it's necessary we have to return\n            // a zero degree polynomial with a constant coefficient equals to the sum of all the original coefficients\n            throw new Error(\"Compute a new polynomial to a zero or negative number is not allowed\");\n        } else if (1 === n) {\n            return await Polynomial.fromEvaluations(polynomial.coef, curve, polynomial.logger);\n        }\n\n        // length is the length of non-constant coefficients\n        // if truncate === true, the highest zero coefficients (if exist) will be removed\n        const length = truncate ? polynomial.degree() : (polynomial.length() - 1);\n        const bufferDst = (length * n + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((length * n + 1) * Fr.n8) : new Uint8Array((length * n + 1) * Fr.n8);\n\n        // Copy constant coefficient as is because is not related to x\n        bufferDst.set(polynomial.getCoef(0), 0);\n\n        for (let i = 1; i <= length; i++) {\n            const i_sFr = i * Fr.n8;\n\n            const coef = polynomial.getCoef(i);\n            bufferDst.set(coef, i_sFr * n);\n        }\n\n        return new Polynomial(bufferDst, polynomial.curve, polynomial.logger);\n    }\n\n    split(numPols, degPols, blindingFactors) {\n        if (numPols < 1) {\n            throw new Error(`Polynomials can't be split in ${numPols} parts`);\n        } else if (1 === numPols) {\n            return [this];\n        }\n\n        //blinding factors can be void or must have a length of numPols - 1\n        if (0 !== blindingFactors.length && blindingFactors.length < numPols - 1) {\n            throw new Error(`Blinding factors length must be ${numPols - 1}`);\n        }\n\n        const chunkByteLength = (degPols + 1) * this.Fr.n8;\n        let res = [];\n\n        // Check polynomial can be split in numChunks parts of chunkSize bytes...\n        const numRealPols = Math.ceil((this.degree() + 1) * this.Fr.n8 / chunkByteLength);\n        if (numRealPols < numPols) {\n            //throw new Error(`Polynomial is short to be split in ${numPols} parts of ${degPols} coefficients each.`);\n            for (let i = numRealPols; i < numPols; i++) {\n                res[i] = new Polynomial(new Uint8Array(this.Fr.n8), this.curve, this.logger);\n            }\n        }\n\n        numPols = Math.min(numPols, numRealPols);\n        for (let i = 0; i < numPols; i++) {\n            const isLast = (numPols - 1) === i;\n            const byteLength = isLast ? this.coef.byteLength - ((numPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n\n            let buff = (byteLength / this.Fr.n8) > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(byteLength) : new Uint8Array(byteLength);\n            res[i] = new Polynomial(buff, this.curve, this.logger);\n\n            const fr = i * chunkByteLength;\n            const to = isLast ? this.coef.byteLength : (i + 1) * chunkByteLength;\n            res[i].coef.set(this.coef.slice(fr, to), 0);\n\n            // Add a blinding factor as higher degree\n            if (!isLast) {\n                res[i].coef.set(blindingFactors[i], chunkByteLength);\n            }\n\n            // Sub blinding factor to the lowest degree\n            if (0 !== i) {\n                const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n                res[i].coef.set(lowestDegree, 0);\n            }\n\n            if (isLast) {\n                res[i].truncate();\n            }\n        }\n\n        return res;\n\n        // // compute t_low(X)\n        // let polTLow = new BigBuffer((chunkSize + 1) * n8r);\n        // polTLow.set(t.slice(0, zkey.domainSize * n8r), 0);\n        // // Add blinding scalar b_10 as a new coefficient n\n        // polTLow.set(ch.b[10], zkey.domainSize * n8r);\n        //\n        // // compute t_mid(X)\n        // let polTMid = new BigBuffer((zkey.domainSize + 1) * n8r);\n        // polTMid.set(t.slice(zkey.domainSize * n8r, zkey.domainSize * 2 * n8r), 0);\n        // // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        // const lowestMid = Fr.sub(polTMid.slice(0, n8r), ch.b[10]);\n        // polTMid.set(lowestMid, 0);\n        // // Add blinding scalar b_11 as a new coefficient n\n        // polTMid.set(ch.b[11], zkey.domainSize * n8r);\n        //\n        // // compute t_high(X)\n        // let polTHigh = new BigBuffer((zkey.domainSize + 6) * n8r);\n        // polTHigh.set(t.slice(zkey.domainSize * 2 * n8r, (zkey.domainSize * 3 + 6) * n8r), 0);\n        // //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        // const lowestHigh = Fr.sub(polTHigh.slice(0, n8r), ch.b[11]);\n        // polTHigh.set(lowestHigh, 0);\n        //\n        // proof.T1 = await expTau(polTLow, \"multiexp T1\");\n        // proof.T2 = await expTau(polTMid, \"multiexp T2\");\n        // proof.T3 = await expTau(polTHigh, \"multiexp T3\");\n    }\n\n// split2(degPols, blindingFactors) {\n//     let currentDegree = this.degree();\n//     const numFilledPols = Math.ceil((currentDegree + 1) / (degPols + 1));\n//\n//     //blinding factors can be void or must have a length of numPols - 1\n//     if (0 !== blindingFactors.length && blindingFactors.length < numFilledPols - 1) {\n//         throw new Error(`Blinding factors length must be ${numFilledPols - 1}`);\n//     }\n//\n//     const chunkByteLength = (degPols + 1) * this.Fr.n8;\n//\n//     // Check polynomial can be split in numChunks parts of chunkSize bytes...\n//     if (this.coef.byteLength / chunkByteLength <= numFilledPols - 1) {\n//         throw new Error(`Polynomial is short to be split in ${numFilledPols} parts of ${degPols} coefficients each.`);\n//     }\n//\n//     let res = [];\n//     for (let i = 0; i < numFilledPols; i++) {\n//         const isLast = (numFilledPols - 1) === i;\n//         const byteLength = isLast ? (currentDegree + 1) * this.Fr.n8 - ((numFilledPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n//\n//         res[i] = new Polynomial(new BigBuffer(byteLength), this.Fr, this.logger);\n//         const fr = i * chunkByteLength;\n//         const to = isLast ? (currentDegree + 1) * this.Fr.n8 : (i + 1) * chunkByteLength;\n//         res[i].coef.set(this.coef.slice(fr, to), 0);\n//\n//         // Add a blinding factor as higher degree\n//         if (!isLast) {\n//             res[i].coef.set(blindingFactors[i], chunkByteLength);\n//         }\n//\n//         // Sub blinding factor to the lowest degree\n//         if (0 !== i) {\n//             const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n//             res[i].coef.set(lowestDegree, 0);\n//         }\n//     }\n//\n//     return res;\n// }\n\n// merge(pols, overlap = true) {\n//     let length = 0;\n//     for (let i = 0; i < pols.length; i++) {\n//         length += pols[i].length();\n//     }\n//\n//     if (overlap) {\n//         length -= pols.length - 1;\n//     }\n//\n//     let res = new Polynomial(new BigBuffer(length * this.Fr.n8));\n//     for (let i = 0; i < pols.length; i++) {\n//         const byteLength = pols[i].coef.byteLength;\n//         if (0 === i) {\n//             res.coef.set(pols[i].coef, 0);\n//         } else {\n//\n//         }\n//     }\n//\n//     return res;\n// }\n\n    truncate() {\n        const deg = this.degree();\n        if (deg + 1 < this.coef.byteLength / this.Fr.n8) {\n            const newCoefs = (deg + 1) > 2 << 14 ?\n                new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((deg + 1) * this.Fr.n8) : new Uint8Array((deg + 1) * this.Fr.n8);\n\n            newCoefs.set(this.coef.slice(0, (deg + 1) * this.Fr.n8), 0);\n            this.coef = newCoefs;\n        }\n    }\n\n    static lagrangePolynomialInterpolation(xArr, yArr, curve) {\n        const Fr = curve.Fr;\n        let polynomial = computeLagrangePolynomial(0);\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.add(computeLagrangePolynomial(i));\n        }\n\n        return polynomial;\n\n        function computeLagrangePolynomial(i) {\n            let polynomial;\n\n            for (let j = 0; j < xArr.length; j++) {\n                if (j === i) continue;\n\n                if (polynomial === undefined) {\n                    let buff = (xArr.length) > 2 << 14 ?\n                        new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((xArr.length) * Fr.n8) : new Uint8Array((xArr.length) * Fr.n8);\n                    polynomial = new Polynomial(buff, curve);\n                    polynomial.setCoef(0, Fr.neg(xArr[j]));\n                    polynomial.setCoef(1, Fr.one);\n                } else {\n                    polynomial.byXSubValue(xArr[j]);\n                }\n            }\n\n            let denominator = polynomial.evaluate(xArr[i]);\n            denominator = Fr.inv(denominator);\n            const mulFactor = Fr.mul(yArr[i], denominator);\n\n            polynomial.mulScalar(mulFactor);\n\n            return polynomial;\n        }\n    }\n\n    static zerofierPolynomial(xArr, curve) {\n        const Fr = curve.Fr;\n        let buff = (xArr.length + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((xArr.length + 1) * Fr.n8) : new Uint8Array((xArr.length + 1) * Fr.n8);\n        let polynomial = new Polynomial(buff, curve);\n\n        // Build a zerofier polynomial with the following form:\n        // zerofier(X) = (X-xArr[0])(X-xArr[1])...(X-xArr[n])\n        polynomial.setCoef(0, Fr.neg(xArr[0]));\n        polynomial.setCoef(1, Fr.one);\n\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.byXSubValue(xArr[i]);\n        }\n\n        return polynomial;\n    }\n\n    print() {\n        const Fr = this.Fr;\n        let res = \"\";\n        for (let i = this.degree(); i >= 0; i--) {\n            const coef = this.getCoef(i);\n            if (!Fr.eq(Fr.zero, coef)) {\n                if (Fr.isNegative(coef)) {\n                    res += \" - \";\n                } else if (i !== this.degree()) {\n                    res += \" + \";\n                }\n                res += Fr.toString(coef);\n                if (i > 0) {\n                    res += i > 1 ? \"x^\" + i : \"x\";\n                }\n            }\n        }\n        console.log(res);\n    }\n\n    async multiExponentiation(PTau, name) {\n        const n = this.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(this.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass Evaluations {\n    constructor(evaluations, curve, logger) {\n        this.eval = evaluations;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.logger = logger;\n    }\n\n    static async fromPolynomial(polynomial, extension, curve, logger) {\n        const coefficientsN = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(polynomial.length() * extension * curve.Fr.n8);\n        coefficientsN.set(polynomial.coef, 0);\n\n        const evaluations = await curve.Fr.fft(coefficientsN);\n\n        return new Evaluations(evaluations, curve, logger);\n    }\n\n    getEvaluation(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.eval.byteLength) {\n            throw new Error(\"Evaluations.getEvaluation() out of bounds\");\n        }\n\n        return this.eval.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    length() {\n        let length = this.eval.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.eval.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial evaluations buffer has incorrect size\");\n        }\n        if (0 === length) {\n            this.logger.warn(\"Polynomial has length zero\");\n        }\n        return length;\n    }\n}\n\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {stringifyBigInts: stringifyBigInts$1} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n    \nasync function plonk16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await readBinFile(witnessFileName, \"wtns\", 2);\n\n    // Read witness file\n    if (logger) logger.debug(\"> Reading witness file\");\n    const wtns = await readHeader(fdWtns, sectionsWtns);\n\n    // Read zkey file\n    if (logger) logger.debug(\"> Reading zkey file\");\n    const {fd: fdZKey, sections: zkeySections} = await readBinFile(zkeyFileName, \"zkey\", 2);\n\n    const zkey = await readHeader$1(fdZKey, zkeySections, undefined, options);\n    if (zkey.protocol != \"plonk\") {\n        throw new Error(\"zkey file is not plonk\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars -zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n    const sDomain = zkey.domainSize * n8r;\n\n    if (logger) {\n        logger.debug(\"----------------------------\");\n        logger.debug(\"  PLONK PROVE SETTINGS\");\n        logger.debug(`  Curve:         ${curve.name}`);\n        logger.debug(`  Circuit power: ${zkey.power}`);\n        logger.debug(`  Domain size:   ${zkey.domainSize}`);\n        logger.debug(`  Vars:          ${zkey.nVars}`);\n        logger.debug(`  Public vars:   ${zkey.nPublic}`);\n        logger.debug(`  Constraints:   ${zkey.nConstraints}`);\n        logger.debug(`  Additions:     ${zkey.nAdditions}`);\n        logger.debug(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.debug(\"> Reading witness file data\");\n    const buffWitness = await readSection(fdWtns, sectionsWtns, 2);\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(n8r*zkey.nAdditions);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    let challenges = {};\n    let proof = new Proof(curve, logger);\n    const transcript = new Keccak256Transcript(curve);\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_SIGMA_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.debug(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 5 * sDomain);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 10 * sDomain);\n\n    if (logger) logger.debug(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 6 * sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 11 * sDomain);\n\n    if (logger) logger.debug(`> Reading Section ${ZKEY_PL_PTAU_SECTION}. Powers of Tau`);\n    const PTau = await readSection(fdZKey, zkeySections, ZKEY_PL_PTAU_SECTION);\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const pub = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.debug(\"\");\n    if (logger) logger.debug(\"> ROUND 1\");\n    await round1();\n\n    if (logger) logger.debug(\"> ROUND 2\");\n    await round2();\n\n    if (logger) logger.debug(\"> ROUND 3\");\n    await round3();\n\n    if (logger) logger.debug(\"> ROUND 4\");\n    await round4();\n\n    if (logger) logger.debug(\"> ROUND 5\");\n    await round5();\n\n    ///////////////////////\n    // Final adjustments //\n    ///////////////////////\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    // Prepare proof\n    let _proof = proof.toObjectProof(false);\n    _proof.protocol = \"plonk\";\n    _proof.curve = curve.name;\n    \n    if (logger) logger.debug(\"PLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts$1(_proof),\n        publicSignals: stringifyBigInts$1(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.debug(\" Computing additions\");\n        const additionsBuff = await readSection(fdZKey, zkeySections, ZKEY_PL_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + n8r * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.debug(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + n8r);\n            offset += n8r;\n            const factor2 = additionsBuff.slice(offset, offset + n8r);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, n8r * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o+4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        if (idx < zkey.nVars-zkey.nAdditions) {\n            return buffWitness.slice(idx*n8r, idx*n8r+n8r);\n        } else if (idx < zkey.nVars) {\n            return buffInternalWitness.slice((idx - (zkey.nVars-zkey.nAdditions))*n8r, (idx-(zkey.nVars-zkey.nAdditions))*n8r + n8r);\n        } else {\n            return curve.Fr.zero;\n        }\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b1, ..., b11)  F\n        challenges.b = [];\n        for (let i=1; i<=11; i++) {\n            challenges.b[i] = curve.Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.debug(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute [a]_1, [b]_1, [c]_1\n        if (logger) logger.debug(\"> Computing A, B, C MSM\");\n        let commitA = await polynomials.A.multiExponentiation(PTau, \"A\");\n        let commitB = await polynomials.B.multiExponentiation(PTau, \"B\");\n        let commitC = await polynomials.C.multiExponentiation(PTau, \"C\");\n\n        // First output of the prover is ([A]_1, [B]_1, [C]_1)\n        proof.addPolynomial(\"A\", commitA);\n        proof.addPolynomial(\"B\", commitB);\n        proof.addPolynomial(\"C\", commitC);\n\n        return 0;\n    }\n\n    async function computeWirePolynomials() {\n        if (logger) logger.debug(\" Reading data from zkey file\");\n\n        // Build A, B and C evaluations buffer from zkey and witness files\n        buffers.A = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain);\n        buffers.B = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain);\n        buffers.C = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain);\n\n        // Read zkey file to the buffers\n        const aMapBuff = await readSection(fdZKey, zkeySections, ZKEY_PL_A_MAP_SECTION);\n        const bMapBuff = await readSection(fdZKey, zkeySections, ZKEY_PL_B_MAP_SECTION);\n        const cMapBuff = await readSection(fdZKey, zkeySections, ZKEY_PL_C_MAP_SECTION);\n\n        // Compute all witness from signal ids and set them to A,B & C buffers\n        for (let i = 0; i < zkey.nConstraints; i++) {\n            const i_sFr = i * n8r;\n            const offset = i * 4;\n\n            // Compute A value from a signal id\n            const signalIdA = readUInt32(aMapBuff, offset);\n            buffers.A.set(getWitness(signalIdA), i_sFr);\n\n            // Compute B value from a signal id\n            const signalIdB = readUInt32(bMapBuff, offset);\n            buffers.B.set(getWitness(signalIdB), i_sFr);\n\n            // Compute C value from a signal id\n            const signalIdC = readUInt32(cMapBuff, offset);\n            buffers.C.set(getWitness(signalIdC), i_sFr);\n        }\n\n        buffers.A = await Fr.batchToMontgomery(buffers.A);\n        buffers.B = await Fr.batchToMontgomery(buffers.B);\n        buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n        // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n        if (logger) logger.debug(\" Computing A ifft\");\n        polynomials.A = await Polynomial.fromEvaluations(buffers.A, curve, logger);\n        if (logger) logger.debug(\" Computing B ifft\");\n        polynomials.B = await Polynomial.fromEvaluations(buffers.B, curve, logger);\n        if (logger) logger.debug(\" Computing C ifft\");\n        polynomials.C = await Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n        // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n        if (logger) logger.debug(\" Computing A fft\");\n        evaluations.A = await Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n        if (logger) logger.debug(\" Computing B fft\");\n        evaluations.B = await Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n        if (logger) logger.debug(\" Computing C fft\");\n        evaluations.C = await Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n        // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n        polynomials.A.blindCoefficients([challenges.b[2], challenges.b[1]]);\n        polynomials.B.blindCoefficients([challenges.b[4], challenges.b[3]]);\n        polynomials.C.blindCoefficients([challenges.b[6], challenges.b[5]]);\n\n        // Check degrees\n        if (polynomials.A.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"A Polynomial is not well calculated\");\n        }\n        if (polynomials.B.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"B Polynomial is not well calculated\");\n        }\n        if (polynomials.C.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"C Polynomial is not well calculated\");\n        }        \n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.debug(\"> Computing challenges beta and gamma\");\n        transcript.reset();\n\n        transcript.addPolCommitment(zkey.Qm);\n        transcript.addPolCommitment(zkey.Ql);\n        transcript.addPolCommitment(zkey.Qr);\n        transcript.addPolCommitment(zkey.Qo);\n        transcript.addPolCommitment(zkey.Qc);\n        transcript.addPolCommitment(zkey.S1);\n        transcript.addPolCommitment(zkey.S2);\n        transcript.addPolCommitment(zkey.S3);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * n8r, i * n8r + n8r));\n        }\n\n        // Add A, B, C to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"A\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"B\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"C\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.beta: \" + Fr.toString(challenges.beta, 16));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.gamma: \" + Fr.toString(challenges.gamma, 16));\n    \n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.debug(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute permutation [z]_1\n        if (logger) logger.debug(\"> Computing Z MSM\");\n        let commitZ = await polynomials.Z.multiExponentiation(PTau, \"Z\");\n\n        // Second output of the prover is ([Z]_1)\n        proof.addPolynomial(\"Z\", commitZ);\n    }\n\n    async function computeZ() {\n        if (logger) logger.debug(\" Computing Z evaluations\");\n\n        let numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain);\n        let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain);\n\n        // Set the first values to 1\n        numArr.set(Fr.one, 0);\n        denArr.set(Fr.one, 0);\n\n        // Set initial omega\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_n8r = i * n8r;\n            \n            const a = buffers.A.slice(i_n8r, i_n8r + n8r);\n            const b = buffers.B.slice(i_n8r, i_n8r + n8r);\n            const c = buffers.C.slice(i_n8r, i_n8r + n8r);\n\n            // Z(X) := numArr / denArr\n            // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n            const betaw = Fr.mul(challenges.beta, w);\n\n            let n1 = Fr.add(a, betaw);\n            n1 = Fr.add(n1, challenges.gamma);\n\n            let n2 = Fr.add(b, Fr.mul(zkey.k1, betaw));\n            n2 = Fr.add(n2, challenges.gamma);\n\n            let n3 = Fr.add(c, Fr.mul(zkey.k2, betaw));\n            n3 = Fr.add(n3, challenges.gamma);\n\n            let num = Fr.mul(n1, Fr.mul(n2, n3));\n\n            // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n            let d1 = Fr.add(a, Fr.mul(evaluations.Sigma1.getEvaluation(i * 4), challenges.beta));\n            d1 = Fr.add(d1, challenges.gamma);\n\n            let d2 = Fr.add(b, Fr.mul(evaluations.Sigma2.getEvaluation(i * 4), challenges.beta));\n            d2 = Fr.add(d2, challenges.gamma);\n\n            let d3 = Fr.add(c, Fr.mul(evaluations.Sigma3.getEvaluation(i * 4), challenges.beta));\n            d3 = Fr.add(d3, challenges.gamma);\n\n            let den = Fr.mul(d1, Fr.mul(d2, d3));\n\n            // Multiply current num value with the previous one saved in numArr\n            num = Fr.mul(numArr.slice(i_n8r, i_n8r + n8r), num);\n            numArr.set(num, ((i + 1) % zkey.domainSize) * n8r);\n\n            // Multiply current den value with the previous one saved in denArr\n            den = Fr.mul(denArr.slice(i_n8r, i_n8r + n8r), den);\n            denArr.set(den, ((i + 1) % zkey.domainSize) * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        // Compute the inverse of denArr to compute in the next command the\n        // division numArr/denArr by multiplying num  1/denArr\n        denArr = await Fr.batchInverse(denArr);\n\n        // TODO: Do it in assembly and in parallel\n        // Multiply numArr  denArr where denArr was inverted in the previous command\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_sFr = i * n8r;\n\n            const z = Fr.mul(numArr.slice(i_sFr, i_sFr + n8r), denArr.slice(i_sFr, i_sFr + n8r));\n            numArr.set(z, i_sFr);\n        }\n\n        // From now on the values saved on numArr will be Z(X) buffer\n        buffers.Z = numArr;\n\n        if (!Fr.eq(numArr.slice(0, n8r), Fr.one)) {\n            throw new Error(\"Copy constraints does not match\");\n        }\n\n        // Compute polynomial coefficients z(X) from buffers.Z\n        if (logger) logger.debug(\" Computing Z ifft\");\n        polynomials.Z = await Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n        // Compute extended evaluations of z(X) polynomial\n        if (logger) logger.debug(\" Computing Z fft\");\n        evaluations.Z = await Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n        // Blind z(X) polynomial coefficients with blinding scalars b\n        polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n        // Check degree\n        if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n            throw new Error(\"Z Polynomial is not well calculated\");\n        }\n\n        delete buffers.Z;\n    }\n\n    async function round3() {\n        if (logger) logger.debug(\"> Computing challenge alpha\");\n\n        // STEP 3.1 - Compute evaluation challenge alpha  F\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"Z\"));\n\n        challenges.alpha = transcript.getChallenge();\n        challenges.alpha2 = Fr.square(challenges.alpha);\n        if (logger) logger.debug(\" challenges.alpha: \" + Fr.toString(challenges.alpha, 16));\n\n        // Compute quotient polynomial T(X)\n        if (logger) logger.debug(\"> Computing T polynomial\");\n        await computeT();\n\n        // Compute [T1]_1, [T2]_1, [T3]_1\n        if (logger) logger.debug(\"> Computing T MSM\");\n        let commitT1 = await polynomials.T1.multiExponentiation(PTau, \"T1\");\n        let commitT2 = await polynomials.T2.multiExponentiation(PTau, \"T2\");\n        let commitT3 = await polynomials.T3.multiExponentiation(PTau, \"T3\");\n\n        // Third output of the prover is ([T1]_1, [T2]_1, [T3]_1)\n        proof.addPolynomial(\"T1\", commitT1);\n        proof.addPolynomial(\"T2\", commitT2);\n        proof.addPolynomial(\"T3\", commitT3);        \n    }\n\n    async function computeT() {\n        if (logger)\n            logger.debug(` Reading sections ${ZKEY_PL_QL_SECTION}, ${ZKEY_PL_QR_SECTION}` +\n                `, ${ZKEY_PL_QM_SECTION}, ${ZKEY_PL_QO_SECTION}, ${ZKEY_PL_QC_SECTION}. Q selectors`);\n        // Reserve memory for Q's evaluations\n        evaluations.QL = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QR = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QM = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QO = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QC = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QL_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QR_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QM_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QO_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QC_SECTION][0].p + sDomain);\n\n        // Read Lagrange polynomials & evaluations from zkey file\n        evaluations.Lagrange = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4 * zkey.nPublic), curve, logger);\n\n        for (let i = 0; i < zkey.nPublic; i++) {\n            await fdZKey.readToBuffer(evaluations.Lagrange.eval, i * sDomain * 4, sDomain * 4, zkeySections[ZKEY_PL_LAGRANGE_SECTION][0].p + i * 5 * sDomain + sDomain);\n        }\n\n        buffers.T = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4);\n        buffers.Tz = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4);\n\n        if (logger) logger.debug(\" Computing T evaluations\");\n\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize * 4; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0))\n                logger.debug(`      T evaluation ${i}/${zkey.domainSize * 4}`);\n\n            const a = evaluations.A.getEvaluation(i);\n            const b = evaluations.B.getEvaluation(i);\n            const c = evaluations.C.getEvaluation(i);\n            const z = evaluations.Z.getEvaluation(i);\n            const zw = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n            const qm = evaluations.QM.getEvaluation(i);\n            const ql = evaluations.QL.getEvaluation(i);\n            const qr = evaluations.QR.getEvaluation(i);\n            const qo = evaluations.QO.getEvaluation(i);\n            const qc = evaluations.QC.getEvaluation(i);\n            const s1 = evaluations.Sigma1.getEvaluation(i);\n            const s2 = evaluations.Sigma2.getEvaluation(i);\n            const s3 = evaluations.Sigma3.getEvaluation(i);\n\n            const ap = Fr.add(challenges.b[2], Fr.mul(challenges.b[1], w));\n            const bp = Fr.add(challenges.b[4], Fr.mul(challenges.b[3], w));\n            const cp = Fr.add(challenges.b[6], Fr.mul(challenges.b[5], w));\n\n            const w2 = Fr.square(w);\n            const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], w2), Fr.mul(challenges.b[8], w)), challenges.b[9]);\n            const wW = Fr.mul(w, Fr.w[zkey.power]);\n            const wW2 = Fr.square(wW);\n            const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], wW2), Fr.mul(challenges.b[8], wW)), challenges.b[9]);\n\n            let pi = Fr.zero;\n            for (let j = 0; j < zkey.nPublic; j++) {\n                const offset = (j * 4 * zkey.domainSize) + i;\n\n                const lPol = evaluations.Lagrange.getEvaluation(offset);\n                const aVal = buffers.A.slice(j * n8r, (j + 1) * n8r);\n\n                pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n            }\n\n            // e1 := a(X)b(X)qM(X) + a(X)qL(X) + b(X)qR(X) + c(X)qO(X) + PI(X) + qC(X)\n            let [e1, e1z] = MulZ.mul2(a, b, ap, bp, i % 4, Fr);\n            e1 = Fr.mul(e1, qm);\n            e1z = Fr.mul(e1z, qm);\n\n            e1 = Fr.add(e1, Fr.mul(a, ql));\n            e1z = Fr.add(e1z, Fr.mul(ap, ql));\n\n            e1 = Fr.add(e1, Fr.mul(b, qr));\n            e1z = Fr.add(e1z, Fr.mul(bp, qr));\n\n            e1 = Fr.add(e1, Fr.mul(c, qo));\n            e1z = Fr.add(e1z, Fr.mul(cp, qo));\n\n            e1 = Fr.add(e1, pi);\n            e1 = Fr.add(e1, qc);\n\n            // e2 := [(a(X) + X + )(b(X) + k1X + )(c(X) + k2X + )z(X)]\n            const betaw = Fr.mul(challenges.beta, w);\n            let e2a = a;\n            e2a = Fr.add(e2a, betaw);\n            e2a = Fr.add(e2a, challenges.gamma);\n\n            let e2b = b;\n            e2b = Fr.add(e2b, Fr.mul(betaw, zkey.k1));\n            e2b = Fr.add(e2b, challenges.gamma);\n\n            let e2c = c;\n            e2c = Fr.add(e2c, Fr.mul(betaw, zkey.k2));\n            e2c = Fr.add(e2c, challenges.gamma);\n\n            let e2d = z;\n\n            let [e2, e2z] = MulZ.mul4(e2a, e2b, e2c, e2d, ap, bp, cp, zp, i % 4, Fr);\n            e2 = Fr.mul(e2, challenges.alpha);\n            e2z = Fr.mul(e2z, challenges.alpha);\n\n            // e3 := [(a(X) + S1(X) + )(b(X) + S2(X) + )(c(X) + S3(X) + )z(X)]\n            let e3a = a;\n            e3a = Fr.add(e3a, Fr.mul(challenges.beta, s1));\n            e3a = Fr.add(e3a, challenges.gamma);\n\n            let e3b = b;\n            e3b = Fr.add(e3b, Fr.mul(challenges.beta, s2));\n            e3b = Fr.add(e3b, challenges.gamma);\n\n            let e3c = c;\n            e3c = Fr.add(e3c, Fr.mul(challenges.beta, s3));\n            e3c = Fr.add(e3c, challenges.gamma);\n\n            let e3d = zw;\n            let [e3, e3z] = MulZ.mul4(e3a, e3b, e3c, e3d, ap, bp, cp, zWp, i % 4, Fr);\n\n            e3 = Fr.mul(e3, challenges.alpha);\n            e3z = Fr.mul(e3z, challenges.alpha);\n\n            // e4 := ^2(z(X)1)L1(X)\n            let e4 = Fr.sub(z, Fr.one);\n            e4 = Fr.mul(e4, evaluations.Lagrange.getEvaluation(i));\n            e4 = Fr.mul(e4, challenges.alpha2);\n\n            let e4z = Fr.mul(zp, evaluations.Lagrange.getEvaluation(i));\n            e4z = Fr.mul(e4z, challenges.alpha2);\n\n\n            let t = Fr.add(Fr.sub(Fr.add(e1, e2), e3), e4);\n            let tz = Fr.add(Fr.sub(Fr.add(e1z, e2z), e3z), e4z);\n\n            buffers.T.set(t, i * n8r);\n            buffers.Tz.set(tz, i * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power + 2]);\n        }\n\n        // Compute the coefficients of the polynomial T0(X) from buffers.T0\n        if (logger)\n            logger.debug(\" Computing T ifft\");\n        polynomials.T = await Polynomial.fromEvaluations(buffers.T, curve, logger);\n\n        // Divide the polynomial T0 by Z_H(X)\n        if (logger)\n            logger.debug(\" Computing T / ZH\");\n        polynomials.T.divZh(zkey.domainSize, 4);\n\n        // Compute the coefficients of the polynomial Tz(X) from buffers.Tz\n        if (logger)\n            logger.debug(\" Computing Tz ifft\");\n        polynomials.Tz = await Polynomial.fromEvaluations(buffers.Tz, curve, logger);\n\n        // Add the polynomial T1z to T1 to get the final polynomial T1\n        polynomials.T.add(polynomials.Tz);\n\n        // Check degree\n        if (polynomials.T.degree() >= zkey.domainSize * 3 + 6) {\n            throw new Error(\"T Polynomial is not well calculated\");\n        }\n\n        // t(x) has degree 3n + 5, we are going to split t(x) into three smaller polynomials:\n        // T1' and T2'  with a degree < n and T3' with a degree n+5\n        // such that t(x) = T1'(X) + X^n T2'(X) + X^{2n} T3'(X)\n        // To randomize the parts we use blinding scalars b_10 and b_11 in a way that doesn't change t(X):\n        // T1(X) = T1'(X) + b_10 X^n\n        // T2(X) = T2'(X) - b_10 + b_11 X^n\n        // T3(X) = T3'(X) - b_11\n        // such that\n        // t(X) = T1(X) + X^n T2(X) + X^2n T3(X)\n        if (logger) logger.debug(\" Computing T1, T2, T3 polynomials\");\n        polynomials.T1 = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T2 = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T3 = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.T1.coef.set(polynomials.T.coef.slice(0, sDomain), 0);\n        polynomials.T2.coef.set(polynomials.T.coef.slice(sDomain, sDomain * 2), 0);\n        polynomials.T3.coef.set(polynomials.T.coef.slice(sDomain * 2, sDomain * 3 + 6 * n8r), 0);\n\n        // Add blinding scalar b_10 as a new coefficient n\n        polynomials.T1.setCoef(zkey.domainSize, challenges.b[10]);\n\n        // compute t_mid(X)\n        // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        const lowestMid = Fr.sub(polynomials.T2.getCoef(0), challenges.b[10]);\n        polynomials.T2.setCoef(0, lowestMid);\n        polynomials.T2.setCoef(zkey.domainSize, challenges.b[11]);\n\n        // compute t_high(X)\n        //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        const lowestHigh = Fr.sub(polynomials.T3.getCoef(0), challenges.b[11]);\n        polynomials.T3.setCoef(0, lowestHigh);\n    }\n\n    async function round4() {\n        if (logger) logger.debug(\"> Computing challenge xi\");\n\n        // STEP 4.1 - Compute evaluation challenge xi  F\n        transcript.reset();\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"T1\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T2\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T3\"));\n\n        challenges.xi = transcript.getChallenge();\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        \n        if (logger) logger.debug(\" challenges.xi: \" + Fr.toString(challenges.xi, 16));  \n\n        // Fourth output of the prover is ( a(xi), b(xi), c(xi), s1(xi), s2(xi), z(xiw) )\n        proof.addEvaluation(\"eval_a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_zw\", polynomials.Z.evaluate(challenges.xiw));\n    }\n\n    async function round5() {\n        if (logger) logger.debug(\"> Computing challenge v\");\n        \n        // STEP 5.1 - Compute evaluation challenge v  F\n        transcript.reset();\n        transcript.addScalar(challenges.xi);\n        transcript.addScalar(proof.getEvaluation(\"eval_a\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_b\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_c\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s1\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s2\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_zw\"));\n\n        challenges.v = [];\n        challenges.v[1] = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.v: \" + Fr.toString(challenges.v[1], 16));\n\n        for (let i = 2; i < 6; i++) {\n            challenges.v[i] = Fr.mul(challenges.v[i - 1], challenges.v[1]);\n        }\n\n        // STEP 5.2 Compute linearisation polynomial r(X)\n        if (logger) logger.debug(\"> Computing linearisation polynomial R(X)\");\n        await computeR();\n\n        //STEP 5.3 Compute opening proof polynomial Wxi(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxi(X) polynomial\");\n        computeWxi();\n\n        //STEP 5.4 Compute opening proof polynomial Wxiw(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxiw(X) polynomial\");\n        computeWxiw();\n\n        if (logger) logger.debug(\"> Computing Wxi, Wxiw MSM\");\n        let commitWxi = await polynomials.Wxi.multiExponentiation(PTau, \"Wxi\");\n        let commitWxiw = await polynomials.Wxiw.multiExponentiation(PTau, \"Wxiw\");\n\n        // Fifth output of the prover is ([Wxi]_1, [Wxiw]_1)\n        proof.addPolynomial(\"Wxi\", commitWxi);\n        proof.addPolynomial(\"Wxiw\", commitWxiw);\n    }\n\n    async function computeR() {\n        const Fr = curve.Fr;\n    \n        // Reserve memory for Q's polynomials\n        polynomials.QL = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[ZKEY_PL_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[ZKEY_PL_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[ZKEY_PL_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[ZKEY_PL_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[ZKEY_PL_QC_SECTION][0].p);   \n        \n        challenges.xin = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            challenges.xin = Fr.square(challenges.xin);\n        }\n\n        challenges.zh = Fr.sub(challenges.xin, Fr.one);\n\n        const L = [];\n\n        const n = Fr.e(zkey.domainSize);\n        let w = Fr.one;\n        for (let i = 1; i <= Math.max(1, zkey.nPublic); i++) {\n            L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        const eval_l1 = Fr.div(\n            Fr.sub(challenges.xin, Fr.one),\n            Fr.mul(n, Fr.sub(challenges.xi, Fr.one))\n        );\n\n        if (logger) {\n            logger.debug(\"Lagrange Evaluations: \");\n            for (let i=1; i<L.length; i++) {\n                logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));    \n            }\n        }\n\n        let eval_pi = Fr.zero;\n        for (let i=0; i<publicSignals.length; i++) {\n            const w = Fr.e(publicSignals[i]);\n            eval_pi = Fr.sub(eval_pi, Fr.mul(w, L[i+1]));\n        }\n\n        if (logger) logger.debug(\"PI: \" + Fr.toString(eval_pi, 16));\n\n        // Compute constant parts of R(X)\n        const coef_ab = Fr.mul(proof.evaluations.eval_a, proof.evaluations.eval_b);\n\n        let e2a = proof.evaluations.eval_a;\n        const betaxi = Fr.mul(challenges.beta, challenges.xi);\n        e2a = Fr.add(e2a, betaxi);\n        e2a = Fr.add(e2a, challenges.gamma);\n\n        let e2b = proof.evaluations.eval_b;\n        e2b = Fr.add(e2b, Fr.mul(betaxi, zkey.k1));\n        e2b = Fr.add(e2b, challenges.gamma);\n\n        let e2c = proof.evaluations.eval_c;\n        e2c = Fr.add(e2c, Fr.mul(betaxi, zkey.k2));\n        e2c = Fr.add(e2c, challenges.gamma);\n\n        const e2 = Fr.mul(Fr.mul(Fr.mul(e2a, e2b), e2c), challenges.alpha);\n\n        let e3a = proof.evaluations.eval_a;\n        e3a = Fr.add(e3a, Fr.mul(challenges.beta, proof.evaluations.eval_s1));\n        e3a = Fr.add(e3a, challenges.gamma);\n\n        let e3b = proof.evaluations.eval_b;\n        e3b = Fr.add(e3b, Fr.mul(challenges.beta, proof.evaluations.eval_s2));\n        e3b = Fr.add(e3b, challenges.gamma);\n\n        let e3 = Fr.mul(e3a, e3b);\n        e3 = Fr.mul(e3, proof.evaluations.eval_zw);\n        e3 = Fr.mul(e3, challenges.alpha);\n\n        const e4 = Fr.mul(eval_l1, challenges.alpha2);\n\n        polynomials.R = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.R.add(polynomials.QM, coef_ab);\n        polynomials.R.add(polynomials.QL, proof.evaluations.eval_a);\n        polynomials.R.add(polynomials.QR, proof.evaluations.eval_b);\n        polynomials.R.add(polynomials.QO, proof.evaluations.eval_c);\n        polynomials.R.add(polynomials.QC);\n        polynomials.R.add(polynomials.Z, e2);\n        polynomials.R.sub(polynomials.Sigma3, Fr.mul(e3, challenges.beta));\n        polynomials.R.add(polynomials.Z, e4);\n\n        let tmp = Polynomial.fromPolynomial(polynomials.T3, curve, logger);\n        tmp.mulScalar(Fr.square(challenges.xin));\n        tmp.add(polynomials.T2, challenges.xin);\n        tmp.add(polynomials.T1);\n        tmp.mulScalar(challenges.zh);\n\n        polynomials.R.sub(tmp);\n\n        let r0 = Fr.sub(eval_pi, Fr.mul(e3, Fr.add(proof.evaluations.eval_c, challenges.gamma)));\n        r0 = Fr.sub(r0, e4);\n\n        if (logger) logger.debug(\"r0: \" + Fr.toString(r0, 16));\n\n        polynomials.R.addScalar(r0);\n    }\n\n    function computeWxi() {\n        polynomials.Wxi = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain + 6 * n8r), curve, logger);\n\n        polynomials.Wxi.add(polynomials.R);\n        polynomials.Wxi.add(polynomials.A, challenges.v[1]);\n        polynomials.Wxi.add(polynomials.B, challenges.v[2]);\n        polynomials.Wxi.add(polynomials.C, challenges.v[3]);\n        polynomials.Wxi.add(polynomials.Sigma1, challenges.v[4]);\n        polynomials.Wxi.add(polynomials.Sigma2, challenges.v[5]);\n\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[1], proof.evaluations.eval_a));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[2], proof.evaluations.eval_b));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[3], proof.evaluations.eval_c));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[4], proof.evaluations.eval_s1));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[5], proof.evaluations.eval_s2));\n\n        polynomials.Wxi.divByZerofier(1, challenges.xi);\n    }\n\n    async function computeWxiw() {\n        polynomials.Wxiw = Polynomial.fromPolynomial(polynomials.Z, curve, logger);\n        polynomials.Wxiw.subScalar(proof.evaluations.eval_zw);\n\n        polynomials.Wxiw.divByZerofier(1, challenges.xiw);\n    }\n}\n\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {unstringifyBigInts: unstringifyBigInts$5} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function plonkFullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts$5(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await wtnsCalculate(input, wasmFile, wtns, wtnsCalcOptions);\n    return await plonk16Prove(zkeyFileName, wtns, logger, proverOptions);\n}\n\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { unstringifyBigInts: unstringifyBigInts$4 } = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function plonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    let vk_verifier = unstringifyBigInts$4(_vk_verifier);\n    _proof = unstringifyBigInts$4(_proof);\n    let publicSignals = unstringifyBigInts$4(_publicSignals);\n\n    const curve = await getCurveFromName(vk_verifier.curve);\n\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n\n    if (logger) logger.info(\"PLONK VERIFIER STARTED\");\n\n    let proof = fromObjectProof(curve,_proof);\n    vk_verifier = fromObjectVk$1(curve, vk_verifier);\n\n    if (!isWellConstructed(curve, proof)) {\n        logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    if (publicSignals.length != vk_verifier.nPublic) {\n        if (logger) logger.error(\"Invalid number of public inputs\");\n        return false;\n    }\n\n    if (!evaluationsAreValid$1(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid\");\n        return false;\n    }\n\n    if (!publicInputsAreValid$1(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    const challenges = calculatechallenges(curve, proof, publicSignals, vk_verifier);\n    if (logger) {\n        logger.debug(\"beta: \" + Fr.toString(challenges.beta, 16));    \n        logger.debug(\"gamma: \" + Fr.toString(challenges.gamma, 16));    \n        logger.debug(\"alpha: \" + Fr.toString(challenges.alpha, 16));    \n        logger.debug(\"xi: \" + Fr.toString(challenges.xi, 16));\n        for(let i=1;i<6;i++) {\n            if (logger) logger.debug(\"v: \" + Fr.toString(challenges.v[i], 16));\n        }\n        logger.debug(\"u: \" + Fr.toString(challenges.u, 16));    \n    }\n    const L = calculateLagrangeEvaluations(curve, challenges, vk_verifier);\n    if (logger) {\n        for (let i=1; i<L.length; i++) {\n            logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));\n        }\n    }\n    \n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const pi = calculatePI$1(curve, publicSignals, L);\n    if (logger) {\n        logger.debug(\"PI(xi): \" + Fr.toString(pi, 16));\n    }\n    \n    const r0 = calculateR0(curve, proof, challenges, pi, L[1]);\n    if (logger) {\n        logger.debug(\"r0: \" + Fr.toString(r0, 16));\n    }\n\n    const D = calculateD(curve, proof, challenges, vk_verifier, L[1]);\n    if (logger) {\n        logger.debug(\"D: \" + G1.toString(G1.toAffine(D), 16));\n    }\n\n    const F = calculateF(curve, proof, challenges, vk_verifier, D);\n    if (logger) {\n        logger.debug(\"F: \" + G1.toString(G1.toAffine(F), 16));\n    }\n\n    const E = calculateE(curve, proof, challenges, r0);\n    if (logger) {\n        logger.debug(\"E: \" + G1.toString(G1.toAffine(E), 16));\n    }\n\n    const res = await isValidPairing$1(curve, proof, challenges, vk_verifier, E, F);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"OK!\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    return res;\n}\n\n\nfunction fromObjectProof(curve, proof) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    const res = {};\n    res.A = G1.fromObject(proof.A);\n    res.B = G1.fromObject(proof.B);\n    res.C = G1.fromObject(proof.C);\n    res.Z = G1.fromObject(proof.Z);\n    res.T1 = G1.fromObject(proof.T1);\n    res.T2 = G1.fromObject(proof.T2);\n    res.T3 = G1.fromObject(proof.T3);\n    res.eval_a = Fr.fromObject(proof.eval_a);\n    res.eval_b = Fr.fromObject(proof.eval_b);\n    res.eval_c = Fr.fromObject(proof.eval_c);\n    res.eval_zw = Fr.fromObject(proof.eval_zw);\n    res.eval_s1 = Fr.fromObject(proof.eval_s1);\n    res.eval_s2 = Fr.fromObject(proof.eval_s2);\n    res.Wxi = G1.fromObject(proof.Wxi);\n    res.Wxiw = G1.fromObject(proof.Wxiw);\n    return res;\n}\n\nfunction fromObjectVk$1(curve, vk) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n    const Fr = curve.Fr;\n    const res = vk;\n    res.Qm = G1.fromObject(vk.Qm);\n    res.Ql = G1.fromObject(vk.Ql);\n    res.Qr = G1.fromObject(vk.Qr);\n    res.Qo = G1.fromObject(vk.Qo);\n    res.Qc = G1.fromObject(vk.Qc);\n    res.S1 = G1.fromObject(vk.S1);\n    res.S2 = G1.fromObject(vk.S2);\n    res.S3 = G1.fromObject(vk.S3);\n    res.k1 = Fr.fromObject(vk.k1);\n    res.k2 = Fr.fromObject(vk.k2);\n    res.X_2 = G2.fromObject(vk.X_2);\n\n    return res;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    if (!G1.isValid(proof.A)) return false;\n    if (!G1.isValid(proof.B)) return false;\n    if (!G1.isValid(proof.C)) return false;\n    if (!G1.isValid(proof.Z)) return false;\n    if (!G1.isValid(proof.T1)) return false;\n    if (!G1.isValid(proof.T2)) return false;\n    if (!G1.isValid(proof.T3)) return false;\n    if (!G1.isValid(proof.Wxi)) return false;\n    if (!G1.isValid(proof.Wxiw)) return false;\n    return true;\n}\n\nfunction checkValueBelongToField$1(curve, value) {\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.geq(value, 0) && ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid$1(curve, evaluation) {\n    return checkValueBelongToField$1(curve, ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid$1(curve, proof) {\n    return checkEvaluationIsValid$1(curve, proof.eval_a)\n        && checkEvaluationIsValid$1(curve, proof.eval_b)\n        && checkEvaluationIsValid$1(curve, proof.eval_c)\n        && checkEvaluationIsValid$1(curve, proof.eval_s1)\n        && checkEvaluationIsValid$1(curve, proof.eval_s2)\n        && checkEvaluationIsValid$1(curve, proof.eval_zw);\n}\n\nfunction publicInputsAreValid$1(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField$1(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction calculatechallenges(curve, proof, publicSignals, vk) {\n    const Fr = curve.Fr;\n    const res = {};\n    const transcript = new Keccak256Transcript(curve);\n\n    // Challenge round 2: beta and gamma\n    transcript.addPolCommitment(vk.Qm);\n    transcript.addPolCommitment(vk.Ql);\n    transcript.addPolCommitment(vk.Qr);\n    transcript.addPolCommitment(vk.Qo);\n    transcript.addPolCommitment(vk.Qc);\n    transcript.addPolCommitment(vk.S1);\n    transcript.addPolCommitment(vk.S2);\n    transcript.addPolCommitment(vk.S3);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.A);\n    transcript.addPolCommitment(proof.B);\n    transcript.addPolCommitment(proof.C);\n\n    res.beta = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    res.gamma = transcript.getChallenge();\n\n    // Challenge round 3: alpha\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    transcript.addScalar(res.gamma);\n    transcript.addPolCommitment(proof.Z);\n    res.alpha = transcript.getChallenge();\n\n    // Challenge round 4: xi\n    transcript.reset();\n    transcript.addScalar(res.alpha);\n    transcript.addPolCommitment(proof.T1);\n    transcript.addPolCommitment(proof.T2);\n    transcript.addPolCommitment(proof.T3);\n    res.xi = transcript.getChallenge();\n    \n    // Challenge round 5: v\n    transcript.reset();\n    transcript.addScalar(res.xi);\n    transcript.addScalar(proof.eval_a);\n    transcript.addScalar(proof.eval_b);\n    transcript.addScalar(proof.eval_c);\n    transcript.addScalar(proof.eval_s1);\n    transcript.addScalar(proof.eval_s2);\n    transcript.addScalar(proof.eval_zw);\n    res.v = [];\n    res.v[1] = transcript.getChallenge();\n\n    for (let i=2; i<6; i++ ) res.v[i] = Fr.mul(res.v[i-1], res.v[1]);\n\n    // Challenge: u\n    transcript.reset();\n    transcript.addPolCommitment(proof.Wxi);\n    transcript.addPolCommitment(proof.Wxiw);\n    res.u = transcript.getChallenge();\n\n    return res;\n}\n\nfunction calculateLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    let xin = challenges.xi;\n    let domainSize = 1;\n    for (let i=0; i<vk.power; i++) {\n        xin = Fr.square(xin);\n        domainSize *= 2;\n    }\n    challenges.xin = xin;\n\n    challenges.zh = Fr.sub(xin, Fr.one);\n\n    const L = [];\n\n    const n = Fr.e(domainSize);\n    let w = Fr.one;\n    for (let i=1; i<=Math.max(1, vk.nPublic); i++) {\n        L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n        w = Fr.mul(w, Fr.w[vk.power]);\n    }\n\n    return L;\n}\n\nfunction calculatePI$1(curve, publicSignals, L) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i=0; i<publicSignals.length; i++) {        \n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, L[i+1]));\n    }\n    return pi;\n}\n\nfunction calculateR0(curve, proof, challenges, pi, l1) {\n    const Fr = curve.Fr;\n\n    const e1 = pi;\n\n    const e2 = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    let e3a = Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1));\n    e3a = Fr.add(e3a, challenges.gamma);\n\n    let e3b = Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2));\n    e3b = Fr.add(e3b, challenges.gamma);\n\n    let e3c = Fr.add(proof.eval_c, challenges.gamma);\n\n    let e3 = Fr.mul(Fr.mul(e3a, e3b), e3c);\n    e3 = Fr.mul(e3, proof.eval_zw);\n    e3 = Fr.mul(e3, challenges.alpha);\n\n    const r0 = Fr.sub(Fr.sub(e1, e2), e3);\n\n    return r0;\n}\n\nfunction calculateD(curve, proof, challenges, vk, l1) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    \n    let d1 = G1.timesFr(vk.Qm, Fr.mul(proof.eval_a, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Ql, proof.eval_a));\n    d1 = G1.add(d1, G1.timesFr(vk.Qr, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Qo, proof.eval_c));\n    d1 = G1.add(d1, vk.Qc);\n\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n\n    const d2a1 = Fr.add(Fr.add(proof.eval_a, betaxi), challenges.gamma);\n    const d2a2 = Fr.add(Fr.add(proof.eval_b, Fr.mul(betaxi, vk.k1)), challenges.gamma);\n    const d2a3 = Fr.add(Fr.add(proof.eval_c, Fr.mul(betaxi, vk.k2)), challenges.gamma);\n\n    const d2a = Fr.mul(Fr.mul(Fr.mul(d2a1, d2a2), d2a3), challenges.alpha);\n\n    const d2b = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    const d2 = G1.timesFr(proof.Z, Fr.add(Fr.add(d2a, d2b), challenges.u));\n\n    const d3a = Fr.add(Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1)), challenges.gamma);\n    const d3b = Fr.add(Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2)), challenges.gamma);\n    const d3c = Fr.mul(Fr.mul(challenges.alpha, challenges.beta), proof.eval_zw);\n\n    const d3 = G1.timesFr(vk.S3, Fr.mul(Fr.mul(d3a, d3b), d3c));\n    \n    const d4low = proof.T1;\n    const d4mid = G1.timesFr(proof.T2, challenges.xin);\n    const d4high = G1.timesFr(proof.T3, Fr.square(challenges.xin));\n    let d4 = G1.add(d4low, G1.add(d4mid, d4high));\n    d4 = G1.timesFr(d4, challenges.zh);\n\n    const d = G1.sub(G1.sub(G1.add(d1, d2), d3), d4);\n\n    return d;\n}\n\nfunction calculateF(curve, proof, challenges, vk, D) {\n    const G1 = curve.G1;\n\n    let res = G1.add(D, G1.timesFr(proof.A, challenges.v[1]));\n    res = G1.add(res, G1.timesFr(proof.B, challenges.v[2]));\n    res = G1.add(res, G1.timesFr(proof.C, challenges.v[3]));\n    res = G1.add(res, G1.timesFr(vk.S1, challenges.v[4]));\n    res = G1.add(res, G1.timesFr(vk.S2, challenges.v[5]));\n\n    return res;\n}\n\nfunction calculateE(curve, proof, challenges, r0) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let e = Fr.add(Fr.neg(r0), Fr.mul(challenges.v[1], proof.eval_a));\n    e = Fr.add(e, Fr.mul(challenges.v[2], proof.eval_b));\n    e = Fr.add(e, Fr.mul(challenges.v[3], proof.eval_c));\n    e = Fr.add(e, Fr.mul(challenges.v[4], proof.eval_s1));\n    e = Fr.add(e, Fr.mul(challenges.v[5], proof.eval_s2));\n    e = Fr.add(e, Fr.mul(challenges.u, proof.eval_zw));\n\n    const res = G1.timesFr(G1.one, e);\n\n    return res;\n}\n\nasync function isValidPairing$1(curve, proof, challenges, vk, E, F) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let A1 = proof.Wxi;\n    A1 = G1.add(A1, G1.timesFr(proof.Wxiw, challenges.u));\n\n    let B1 = G1.timesFr(proof.Wxi, challenges.xi);\n    const s = Fr.mul(Fr.mul(challenges.u, challenges.xi), Fr.w[vk.power]);\n    B1 = G1.add(B1, G1.timesFr(proof.Wxiw, s));\n    B1 = G1.add(B1, F);\n    B1 = G1.sub(B1, E);\n\n    const res = await curve.pairingEq(\n        G1.neg(A1) , vk.X_2,\n        B1 , curve.G2.one\n    );\n\n    return res;\n}\n\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst { unstringifyBigInts: unstringifyBigInts$3} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nfunction p256$1(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function plonkExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts$3(_proof);\n    const pub = unstringifyBigInts$3(_pub);\n\n    await getCurveFromName(proof.curve);\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256$1(pub[i]);\n    }\n\n    return `[${p256$1(proof.A[0])}, ${p256$1(proof.A[1])},` +\n    `${p256$1(proof.B[0])},${p256$1(proof.B[1])},` +\n    `${p256$1(proof.C[0])},${p256$1(proof.C[1])},` +\n    `${p256$1(proof.Z[0])},${p256$1(proof.Z[1])},` +\n    `${p256$1(proof.T1[0])},${p256$1(proof.T1[1])},` +\n    `${p256$1(proof.T2[0])},${p256$1(proof.T2[1])},` +\n    `${p256$1(proof.T3[0])},${p256$1(proof.T3[1])},` +\n    `${p256$1(proof.Wxi[0])},${p256$1(proof.Wxi[1])},` +\n    `${p256$1(proof.Wxiw[0])},${p256$1(proof.Wxiw[1])},` +\n    `${p256$1(proof.eval_a)},` + \n    `${p256$1(proof.eval_b)},` + \n    `${p256$1(proof.eval_c)},` + \n    `${p256$1(proof.eval_s1)},` + \n    `${p256$1(proof.eval_s2)},` + \n    `${p256$1(proof.eval_zw)}]` + \n    `[${inputs}]`;\n}\n\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar plonk = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setup: plonkSetup,\n    fullProve: plonkFullProve,\n    prove: plonk16Prove,\n    verify: plonkVerify,\n    exportSolidityCallData: plonkExportSolidityCallData\n});\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// We export to zkey the signals and values of the a, b, c, ql, qr, qm, qo and qc\n\n// a, b and c are signals id (32-bit integers)\n// ql, qr, qm, qo and qc are field values\n\nfunction getFFlonkConstantConstraint(signal1, Fr) {\n    return [signal1, 0, 0, Fr.one, Fr.zero, Fr.zero, Fr.zero, Fr.zero];\n}\n\nfunction getFFlonkAdditionConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n\nfunction getFFlonkMultiplicationConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc, Fr) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst LINEAR_COMBINATION_NULLABLE = 0;\nconst LINEAR_COMBINATION_CONSTANT = 1;\nconst LINEAR_COMBINATION_VARIABLE = 2;\n\nclass r1csConstraintProcessor {\n    constructor(Fr, fnGetConstantConstraint, fnGetAdditionConstraint, fnGetMultiplicationConstraint, logger) {\n        this.Fr = Fr;\n        this.logger = logger;\n        this.fnGetAdditionConstraint = fnGetAdditionConstraint;\n        this.fnGetMultiplicationConstraint = fnGetMultiplicationConstraint;\n    }\n\n    processR1csConstraint(settings, lcA, lcB, lcC) {\n        this.normalizeLinearCombination(lcA);\n        this.normalizeLinearCombination(lcB);\n        this.normalizeLinearCombination(lcC);\n\n        const lctA = this.getLinearCombinationType(lcA);\n        const lctB = this.getLinearCombinationType(lcB);\n\n        if ((lctA === LINEAR_COMBINATION_NULLABLE) || (lctB === LINEAR_COMBINATION_NULLABLE)) {\n            return this.processR1csAdditionConstraint(settings, lcC);\n        } else if (lctA === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcB, lcC, lcA[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else if (lctB === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcA, lcC, lcB[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else {\n            return this.processR1csMultiplicationConstraint(settings, lcA, lcB, lcC);\n        }\n    }\n\n    getLinearCombinationType(linCom) {\n        // let k = this.Fr.zero;\n        //\n        // const signalIds = Object.keys(linCom);\n        // for (let i = 0; i < signalIds.length; i++) {\n        //     if (signalIds[i] === \"0\") {\n        //         k = this.Fr.add(k, linCom[signalIds[i]]);\n        //     } else {\n        //         return LINEAR_COMBINATION_VARIABLE;\n        //     }\n        // }\n        //\n        // if (!this.Fr.eq(k, this.Fr.zero)) return LINEAR_COMBINATION_CONSTANT;\n        //\n        // return LINEAR_COMBINATION_NULLABLE;\n\n        let k = this.Fr.zero;\n        let n = 0;\n        const ss = Object.keys(linCom);\n        for (let i = 0; i < ss.length; i++) {\n            if (linCom[ss[i]] == 0n) {\n                delete linCom[ss[i]];\n            } else if (ss[i] == 0) {\n                k = this.Fr.add(k, linCom[ss[i]]);\n            } else {\n                n++;\n            }\n        }\n        if (n > 0) return LINEAR_COMBINATION_VARIABLE;\n        if (!this.Fr.isZero(k)) return LINEAR_COMBINATION_CONSTANT;\n        return LINEAR_COMBINATION_NULLABLE;\n    }\n\n    normalizeLinearCombination(linCom) {\n        const signalIds = Object.keys(linCom);\n        for (let i = 0; i < signalIds.length; i++) {\n            if (this.Fr.isZero(linCom[signalIds[i]])) delete linCom[signalIds[i]];\n        }\n\n        return linCom;\n    }\n\n    joinLinearCombinations(linCom1, linCom2, k) {\n        const res = {};\n\n        for (let s in linCom1) {\n            if (typeof res[s] == \"undefined\") {\n                res[s] = this.Fr.mul(k, linCom1[s]);\n            } else {\n                res[s] = this.Fr.add(res[s], this.Fr.mul(k, linCom1[s]));\n            }\n        }\n\n        for (let s in linCom2) {\n            const val = this.Fr.neg(linCom2[s]);\n            if (typeof res[s] == \"undefined\") {\n                res[s] = val;\n            } else {\n                res[s] = this.Fr.add(res[s], val);\n            }\n        }\n\n        return this.normalizeLinearCombination(res);\n    }\n\n    reduceCoefs(settings, constraintsArr, additionsArr, linCom, maxC) {\n        const res = {\n            k: this.Fr.zero,\n            signals: [],\n            coefs: []\n        };\n        const cs = [];\n\n        for (let signalId in linCom) {\n            if (signalId == 0) {\n                res.k = this.Fr.add(res.k, linCom[signalId]);\n            } else if (linCom[signalId] != 0n) {\n                cs.push([Number(signalId), linCom[signalId]]);\n            }\n        }\n\n        while (cs.length > maxC) {\n            const c1 = cs.shift();\n            const c2 = cs.shift();\n            const so = settings.nVars++;\n\n            const constraints = this.fnGetAdditionConstraint(\n                c1[0], c2[0], so,\n                this.Fr.neg(c1[1]), this.Fr.neg(c2[1]), this.Fr.zero, this.Fr.one, this.Fr.zero);\n\n            constraintsArr.push(constraints);\n            additionsArr.push([c1[0], c2[0], c1[1], c2[1]]);\n\n            cs.push([so, this.Fr.one]);\n        }\n\n        for (let i = 0; i < cs.length; i++) {\n            res.signals[i] = cs[i][0];\n            res.coefs[i] = cs[i][1];\n        }\n\n        while (res.coefs.length < maxC) {\n            res.signals.push(0);\n            res.coefs.push(this.Fr.zero);\n        }\n\n        return res;\n    }\n\n    processR1csAdditionConstraint(settings, linCom) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, linCom, 3);\n\n        const constraints = this.fnGetAdditionConstraint(\n            C.signals[0], C.signals[1], C.signals[2],\n            C.coefs[0], C.coefs[1], this.Fr.zero, C.coefs[2], C.k);\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n\n    processR1csMultiplicationConstraint(settings, lcA, lcB, lcC) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const A = this.reduceCoefs(settings, constraintsArr, additionsArr, lcA, 1);\n        const B = this.reduceCoefs(settings, constraintsArr, additionsArr, lcB, 1);\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, lcC, 1);\n\n        const constraints = this.fnGetMultiplicationConstraint(\n            A.signals[0], B.signals[0], C.signals[0],\n            this.Fr.mul(A.coefs[0], B.k),\n            this.Fr.mul(A.k, B.coefs[0]),\n            this.Fr.mul(A.coefs[0], B.coefs[0]),\n            this.Fr.neg(C.coefs[0]),\n            this.Fr.sub(this.Fr.mul(A.k, B.k), C.k));\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass CPolynomial {\n    constructor(n, curve, logger) {\n        this.n = n;\n        this.polynomials = Array(n).fill(undefined);\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    addPolynomial(position, polynomial) {\n        if (position > this.n - 1) {\n            throw new Error(\"CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1\");\n        }\n\n        this.polynomials[position] = polynomial;\n    }\n\n    degree() {\n        let degrees = this.polynomials.map(\n            (polynomial, index) => polynomial === undefined ? 0 : polynomial.degree() * this.n + index);\n        return Math.max(...degrees);\n    }\n\n    getPolynomial() {\n        let degrees = this.polynomials.map(polynomial => polynomial === undefined ? 0 : polynomial.degree());\n        const maxDegree = this.degree();\n        const lengthBuffer = 2 ** (log2(maxDegree - 1) + 1);\n        const sFr = this.Fr.n8;\n\n        let polynomial = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(lengthBuffer * sFr), this.curve, this.logger);\n\n        for (let i = 0; i < maxDegree; i++) {\n            const i_n8 = i * sFr;\n            const i_sFr = i_n8 * this.n;\n\n            for (let j = 0; j < this.n; j++) {\n                if (this.polynomials[j] !== undefined) {\n                    if (i <= degrees[j]) polynomial.coef.set(this.polynomials[j].coef.slice(i_n8, i_n8 + sFr), i_sFr + j * sFr);\n                }\n            }\n        }\n\n        return polynomial;\n    }\n\n    async multiExponentiation(PTau, name) {\n        let polynomial = this.getPolynomial();\n        const n = polynomial.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(polynomial.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nasync function fflonkSetup(r1csFilename, ptauFilename, zkeyFilename, logger) {\n    if (logger) logger.info(\"FFLONK SETUP STARTED\");\n\n    if (globalThis.gc) globalThis.gc();\n\n    // Read PTau file\n    if (logger) logger.info(\"> Reading PTau file\");\n    const {fd: fdPTau, sections: pTauSections} = await readBinFile(ptauFilename, \"ptau\", 1);\n    if (!pTauSections[12]) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 12 missing.\");\n    }\n\n    // Get curve defined in PTau\n    if (logger) logger.info(\"> Getting curve from PTau settings\");\n    const {curve} = await readPTauHeader(fdPTau, pTauSections);\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {fd: fdR1cs, sections: sectionsR1cs} = await readBinFile(r1csFilename, \"r1cs\", 1);\n    const r1cs = await readR1csFd(fdR1cs, sectionsR1cs, {loadConstraints: false, loadCustomGates: true});\n\n    // Potential error checks\n    if (r1cs.prime !== curve.r) {\n        throw new Error(\"r1cs curve does not match powers of tau ceremony curve\");\n    }\n\n    // Initializations\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sG2 = curve.G2.F.n8 * 2;\n\n    let polynomials = {};\n    let evaluations = {};\n    let PTau;\n\n    let settings = {\n        nVars: r1cs.nVars,\n        nPublic: r1cs.nOutputs + r1cs.nPubInputs\n    };\n\n    const plonkConstraints = new BigArray$1();\n    let plonkAdditions = new BigArray$1();\n\n    // Process constraints inside r1cs\n    if (logger) logger.info(\"> Processing FFlonk constraints\");\n    await computeFFConstraints(curve.Fr, r1cs, logger);\n    if (globalThis.gc) globalThis.gc();\n\n    // As the t polynomial is n+5 we need at least a power of 4\n    //TODO check!!!!\n    // NOTE : plonkConstraints + 2 = #constraints + blinding coefficients for each wire polynomial\n    settings.cirPower = Math.max(FF_T_POL_DEG_MIN, log2((plonkConstraints.length + 2) - 1) + 1);\n    settings.domainSize = 2 ** settings.cirPower;\n\n    if (pTauSections[2][0].size < (settings.domainSize * 9 + 18) * sG1) {\n        throw new Error(\"Powers of Tau is not big enough for this circuit size. Section 2 too small.\");\n    }\n    if (pTauSections[3][0].size < sG2) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 3 too small.\");\n    }\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK SETUP SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${settings.cirPower}`);\n        logger.info(`  Domain size:   ${settings.domainSize}`);\n        logger.info(`  Vars:          ${settings.nVars}`);\n        logger.info(`  Public vars:   ${settings.nPublic}`);\n        logger.info(`  Constraints:   ${plonkConstraints.length}`);\n        logger.info(`  Additions:     ${plonkAdditions.length}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // Compute k1 and k2 to be used in the permutation checks\n    if (logger) logger.info(\"> computing k1 and k2\");\n    const [k1, k2] = computeK1K2();\n\n    // Compute omega 3 (w3) and omega 4 (w4) to be used in the prover and the verifier\n    // w3^3 = 1 and  w4^4 = 1\n    if (logger) logger.info(\"> computing w3\");\n    const w3 = computeW3();\n    if (logger) logger.info(\"> computing w4\");\n    const w4 = computeW4();\n    if (logger) logger.info(\"> computing w8\");\n    const w8 = computeW8();\n    if (logger) logger.info(\"> computing wr\");\n    const wr = getOmegaCubicRoot(settings.cirPower, curve.Fr);\n\n    // Write output zkey file\n    await writeZkeyFile();\n\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"FFLONK SETUP FINISHED\");\n\n    return 0;\n\n    async function computeFFConstraints(Fr, r1cs, logger) {\n        // Add public inputs and outputs\n        for (let i = 0; i < settings.nPublic; i++) {\n            plonkConstraints.push(getFFlonkConstantConstraint(i + 1, Fr));\n        }\n\n        // Add all constraints from r1cs file\n        const r1csProcessor = new r1csConstraintProcessor(Fr, getFFlonkConstantConstraint, getFFlonkAdditionConstraint, getFFlonkMultiplicationConstraint, logger);\n\n        const bR1cs = await readSection(fdR1cs, sectionsR1cs, 2);\n        let bR1csPos = 0;\n        for (let i = 0; i < r1cs.nConstraints; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`    processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n            }\n            const [constraints, additions] = r1csProcessor.processR1csConstraint(settings, ...readConstraint());\n\n            plonkConstraints.push(...constraints);\n            plonkAdditions.push(...additions);\n        }\n\n        function readConstraint() {\n            const c = [];\n            c[0] = readLC();\n            c[1] = readLC();\n            c[2] = readLC();\n            return c;\n        }\n\n        function readLC() {\n            const lc = {};\n\n            const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n            bR1csPos += 4;\n            const buffUL32V = new DataView(buffUL32.buffer);\n            const nIdx = buffUL32V.getUint32(0, true);\n\n            const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n            bR1csPos += (4 + r1cs.n8) * nIdx;\n            const buffV = new DataView(buff.buffer);\n            for (let i = 0; i < nIdx; i++) {\n                const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n                const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n                lc[idx] = val;\n            }\n            return lc;\n        }\n\n        return 0;\n    }\n\n    async function writeZkeyFile() {\n        if (logger) logger.info(\"> Writing the zkey file\");\n        const fdZKey = await createBinFile(zkeyFilename, \"zkey\", 1, ZKEY_FF_NSECTIONS, 1 << 22, 1 << 24);\n\n        if (logger) logger.info(` Writing Section ${HEADER_ZKEY_SECTION}. Zkey Header`);\n        await writeZkeyHeader(fdZKey);\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n        await writeAdditions(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_A_MAP_SECTION}. A Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_A_MAP_SECTION, 0, \"A map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_B_MAP_SECTION}. B Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_B_MAP_SECTION, 1, \"B map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_C_MAP_SECTION}. C Map`);\n        await writeWitnessMap(fdZKey, ZKEY_FF_C_MAP_SECTION, 2, \"C map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QL_SECTION}. QL`);\n        await writeQMap(fdZKey, ZKEY_FF_QL_SECTION, 3, \"QL\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QR_SECTION}. QR`);\n        await writeQMap(fdZKey, ZKEY_FF_QR_SECTION, 4, \"QR\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QM_SECTION}. QM`);\n        await writeQMap(fdZKey, ZKEY_FF_QM_SECTION, 5, \"QM\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QO_SECTION}. QO`);\n        await writeQMap(fdZKey, ZKEY_FF_QO_SECTION, 6, \"QO\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_QC_SECTION}. QC`);\n        await writeQMap(fdZKey, ZKEY_FF_QC_SECTION, 7, \"QC\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Sections ${ZKEY_FF_SIGMA1_SECTION},${ZKEY_FF_SIGMA2_SECTION},${ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n        await writeSigma(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_LAGRANGE_SECTION}. Lagrange Polynomials`);\n        await writeLagrangePolynomials(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n        await writePtau(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_C0_SECTION}. C0`);\n        await writeC0(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${ZKEY_FF_HEADER_SECTION}. FFlonk Header`);\n        await writeFFlonkHeader(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(\"> Writing the zkey file finished\");\n\n        await fdZKey.close();\n    }\n\n    async function writeZkeyHeader(fdZKey) {\n        await startWriteSection(fdZKey, HEADER_ZKEY_SECTION);\n        await fdZKey.writeULE32(FFLONK_PROTOCOL_ID);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeAdditions(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_ADDITIONS_SECTION);\n\n        // Written values are 2 * 32 bit integers (2 * 4 bytes) + 2 field size values ( 2 * sFr bytes)\n        const buffOut = new Uint8Array(8 + 2 * sFr);\n        const buffOutV = new DataView(buffOut.buffer);\n\n        for (let i = 0; i < plonkAdditions.length; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing Additions: ${i}/${plonkAdditions.length}`);\n\n            const addition = plonkAdditions[i];\n\n            buffOutV.setUint32(0, addition[0], true);\n            buffOutV.setUint32(4, addition[1], true);\n            buffOut.set(addition[2], 8);\n            buffOut.set(addition[3], 8 + sFr);\n\n            await fdZKey.write(buffOut);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeWitnessMap(fdZKey, sectionNum, posConstraint, name) {\n        await startWriteSection(fdZKey, sectionNum);\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            if (logger && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing witness ${name}: ${i}/${plonkConstraints.length}`);\n            }\n\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeQMap(fdZKey, sectionNum, posConstraint, name) {\n        // Compute Q from q evaluations\n        let Q = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(settings.domainSize * sFr);\n\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i * sFr);\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing ${name}: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        polynomials[name] = await Polynomial.fromEvaluations(Q, curve, logger);\n        evaluations[name] = await Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n\n        // Write Q coefficients and evaluations\n        await startWriteSection(fdZKey, sectionNum);\n        await fdZKey.write(polynomials[name].coef);\n        await fdZKey.write(evaluations[name].eval);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeSigma(fdZKey) {\n        // Compute sigma\n        const sigma = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sFr * settings.domainSize * 3);\n        const lastSeen = new BigArray$1(settings.nVars);\n        const firstPos = new BigArray$1(settings.nVars);\n\n        let w = Fr.one;\n        for (let i = 0; i < settings.domainSize; i++) {\n            if (i < plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], settings.domainSize + i);\n                buildSigma(plonkConstraints[i][2], settings.domainSize * 2 + i);\n            } else if (i < settings.domainSize - 2) {\n                buildSigma(0, i);\n                buildSigma(0, settings.domainSize + i);\n                buildSigma(0, settings.domainSize * 2 + i);\n            } else {\n                sigma.set(w, i * sFr);\n                sigma.set(Fr.mul(w, k1), (settings.domainSize + i) * sFr);\n                sigma.set(Fr.mul(w, k2), (settings.domainSize * 2 + i) * sFr);\n            }\n\n            w = Fr.mul(w, Fr.w[settings.cirPower]);\n\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing sigma phase1: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        for (let i = 0; i < settings.nVars; i++) {\n            if (typeof firstPos[i] !== \"undefined\") {\n                sigma.set(lastSeen[i], firstPos[i] * sFr);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing sigma phase2: ${i}/${settings.nVars}`);\n        }\n\n        if (globalThis.gc) globalThis.gc();\n\n        // Write sigma coefficients and evaluations\n        for (let i = 0; i < 3; i++) {\n            const sectionId = 0 === i ? ZKEY_FF_SIGMA1_SECTION : 1 === i ? ZKEY_FF_SIGMA2_SECTION : ZKEY_FF_SIGMA3_SECTION;\n\n            let name = \"S\" + (i + 1);\n            polynomials[name] = await Polynomial.fromEvaluations(sigma.slice(settings.domainSize * sFr * i, settings.domainSize * sFr * (i + 1)), curve, logger);\n            evaluations[name] = await Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n            await startWriteSection(fdZKey, sectionId);\n            await fdZKey.write(polynomials[name].coef);\n            await fdZKey.write(evaluations[name].eval);\n            await endWriteSection(fdZKey);\n\n            if (globalThis.gc) globalThis.gc();\n        }\n\n        return 0;\n\n        function buildSigma(signalId, idx) {\n            if (typeof lastSeen[signalId] === \"undefined\") {\n                firstPos[signalId] = idx;\n            } else {\n                sigma.set(lastSeen[signalId], idx * sFr);\n            }\n            let v;\n            if (idx < settings.domainSize) {\n                v = w;\n            } else if (idx < 2 * settings.domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n\n            lastSeen[signalId] = v;\n        }\n    }\n\n    async function writeLagrangePolynomials(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_LAGRANGE_SECTION);\n\n        const l = Math.max(settings.nPublic, 1);\n        for (let i = 0; i < l; i++) {\n            let buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(settings.domainSize * sFr);\n            buff.set(Fr.one, i * sFr);\n\n            await writeP4(fdZKey, buff);\n        }\n        await endWriteSection(fdZKey);\n    }\n\n    async function writePtau(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_PTAU_SECTION);\n\n        // domainSize * 9 + 18 = maximum SRS length needed, specifically to commit C2\n        PTau = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((settings.domainSize * 9 + 18) * sG1);\n        await fdPTau.readToBuffer(PTau, 0, (settings.domainSize * 9 + 18) * sG1, pTauSections[2][0].p);\n\n        await fdZKey.write(PTau);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeC0(fdZKey) {\n        // C0(X) := QL(X^8) + X  QR(X^8) + X^2  QO(X^8) + X^3  QM(X^8) + X^4  QC(X^8)\n        //            + X^5  SIGMA1(X^8) + X^6  SIGMA2(X^8) + X^7  SIGMA3(X^8)\n        let C0 = new CPolynomial(8, curve, logger);\n        C0.addPolynomial(0, polynomials.QL);\n        C0.addPolynomial(1, polynomials.QR);\n        C0.addPolynomial(2, polynomials.QO);\n        C0.addPolynomial(3, polynomials.QM);\n        C0.addPolynomial(4, polynomials.QC);\n        C0.addPolynomial(5, polynomials.S1);\n        C0.addPolynomial(6, polynomials.S2);\n        C0.addPolynomial(7, polynomials.S3);\n\n        polynomials.C0 = C0.getPolynomial();\n\n        // Check degree\n        if (polynomials.C0.degree() >= 8 * settings.domainSize) {\n            throw new Error(\"C0 Polynomial is not well calculated\");\n        }\n\n        await startWriteSection(fdZKey, ZKEY_FF_C0_SECTION);\n        await fdZKey.write(polynomials.C0.coef);\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeFFlonkHeader(fdZKey) {\n        await startWriteSection(fdZKey, ZKEY_FF_HEADER_SECTION);\n\n        const primeQ = curve.q;\n        const n8q = (Math.floor((ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8q);\n        await writeBigInt(fdZKey, primeQ, n8q);\n\n        const primeR = curve.r;\n        const n8r = (Math.floor((ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8r);\n        await writeBigInt(fdZKey, primeR, n8r);\n\n        // Total number of r1cs vars\n        await fdZKey.writeULE32(settings.nVars);\n        // Total number of r1cs public vars = outputs + public inputs\n        await fdZKey.writeULE32(settings.nPublic);\n        await fdZKey.writeULE32(settings.domainSize);\n        await fdZKey.writeULE32(plonkAdditions.length);\n        await fdZKey.writeULE32(plonkConstraints.length);\n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(w3);\n        await fdZKey.write(w4);\n        await fdZKey.write(w8);\n        await fdZKey.write(wr);\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, pTauSections[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        let commitC0 = await polynomials.C0.multiExponentiation(PTau, \"C0\");\n        await fdZKey.write(commitC0);\n\n        await endWriteSection(fdZKey);\n    }\n\n    async function writeP4(fdZKey, buff) {\n        const [coefficients, evaluations4] = await Polynomial.to4T(buff, settings.domainSize, [], Fr);\n        await fdZKey.write(coefficients);\n        await fdZKey.write(evaluations4);\n\n        return [coefficients, evaluations4];\n    }\n\n    function computeK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], settings.cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], settings.cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize = 2 ** pow;\n            let w = Fr.one;\n            for (let i = 0; i < domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j = 0; j < kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n\n    function computeW3() {\n        let generator = Fr.e(31624);\n\n        // Exponent is order(r - 1) / 3\n        let orderRsub1 = 3648040478639879203707734290876212514758060733402672390616367364429301415936n;\n        let exponent = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.div(orderRsub1, ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(3));\n\n        return Fr.exp(generator, exponent);\n    }\n\n    function computeW4() {\n        return Fr.w[2];\n    }\n\n    function computeW8() {\n        return Fr.w[3];\n    }\n\n    function getOmegaCubicRoot(power, Fr) {\n        // Hardcorded 3th-root of Fr.w[28]\n        const firstRoot = Fr.e(467799165886069610036046866799264026481344299079011762026774533774345988080n);\n\n        return Fr.exp(firstRoot, 2 ** (28 - power));\n    }\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { stringifyBigInts } = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\n\nasync function fflonkProve(zkeyFileName, witnessFileName, logger, options) {\n    if (logger) logger.info(\"FFLONK PROVER STARTED\");\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await readBinFile(witnessFileName, \"wtns\", 2);\n    const wtns = await readHeader(fdWtns, wtnsSections);\n\n    //Read zkey file\n    if (logger) logger.info(\"> Reading zkey file\");\n    const {\n        fd: fdZKey,\n        sections: zkeySections\n    } = await readBinFile(zkeyFileName, \"zkey\", 2);\n\n    const zkey = await readHeader$1(fdZKey, zkeySections, undefined, options);\n\n    if (zkey.protocolId !== FFLONK_PROTOCOL_ID) {\n        throw new Error(\"zkey file is not fflonk\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(zkey.r, wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness !== zkey.nVars - zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sDomain = zkey.domainSize * sFr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK PROVE SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${zkey.power}`);\n        logger.info(`  Domain size:   ${zkey.domainSize}`);\n        logger.info(`  Vars:          ${zkey.nVars}`);\n        logger.info(`  Public vars:   ${zkey.nPublic}`);\n        logger.info(`  Constraints:   ${zkey.nConstraints}`);\n        logger.info(`  Additions:     ${zkey.nAdditions}`);\n        logger.info(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.info(\"> Reading witness file data\");\n    const buffWitness = await readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(zkey.nAdditions * sFr);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    // To divide prime fields the Extended Euclidean Algorithm for computing modular inverses is needed.\n    // NOTE: This is the equivalent of compute 1/denominator and then multiply it by the numerator.\n    // The Extended Euclidean Algorithm is expensive in terms of computation.\n    // For the special case where we need to do many modular inverses, there's a simple mathematical trick\n    // that allows us to compute many inverses, called Montgomery batch inversion.\n    // More info: https://vitalik.ca/general/2018/07/21/starks_part_3.html\n    // Montgomery batch inversion reduces the n inverse computations to a single one\n    // To save this (single) inverse computation on-chain, will compute it in proving time and send it to the verifier.\n    // The verifier will have to check:\n    // 1) the denominator is correct multiplying by himself non-inverted -> a * 1/a == 1\n    // 2) compute the rest of the denominators using the Montgomery batch inversion\n    // The inversions are:\n    //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n    //    denominator needed in step 10 and 11 of the verifier\n    //    denominator needed in the verifier when computing L_i^{S1}(X) and L_i^{S2}(X)\n    //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n    let toInverse = {};\n\n    let challenges = {};\n    let roots = {};\n\n    let proof = new Proof(curve, logger);\n\n    if (logger) logger.info(`> Reading Section ${ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.info(`> Reading Sections ${ZKEY_FF_SIGMA1_SECTION},${ZKEY_FF_SIGMA2_SECTION},${ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.info(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA1_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA2_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA3_SECTION][0].p);\n\n    if (logger) logger.info(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA1_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA2_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA3_SECTION][0].p + sDomain);\n\n    if (logger) logger.info(`> Reading Section ${ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n    const PTau = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(zkey.domainSize * 16 * sG1);\n    // domainSize * 9 + 18 = SRS length in the zkey saved in setup process.\n    // it corresponds to the maximum SRS length needed, specifically to commit C2\n    // notice that the reserved buffers size is zkey.domainSize * 16 * sG1 because a power of two buffer size is needed\n    // the remaining buffer not filled from SRS are set to 0\n    await fdZKey.readToBuffer(PTau, 0, (zkey.domainSize * 9 + 18) * sG1, zkeySections[ZKEY_FF_PTAU_SECTION][0].p);\n\n    // START FFLONK PROVER PROTOCOL\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 1. Compute C1(X) polynomial\n    if (logger) logger.info(\"\");\n    if (logger) logger.info(\"> ROUND 1\");\n    await round1();\n\n    delete polynomials.T0;\n    delete evaluations.QL;\n    delete evaluations.QR;\n    delete evaluations.QM;\n    delete evaluations.QO;\n    delete evaluations.QC;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 2. Compute C2(X) polynomial\n    if (logger) logger.info(\"> ROUND 2\");\n    await round2();\n\n    delete buffers.A;\n    delete buffers.B;\n    delete buffers.C;\n    delete evaluations.A;\n    delete evaluations.B;\n    delete evaluations.C;\n    delete evaluations.Sigma1;\n    delete evaluations.Sigma2;\n    delete evaluations.Sigma3;\n    delete evaluations.lagrange1;\n    delete evaluations.Z;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 3. Compute opening evaluations\n    if (logger) logger.info(\"> ROUND 3\");\n    await round3();\n\n    delete polynomials.A;\n    delete polynomials.B;\n    delete polynomials.C;\n    delete polynomials.Z;\n    delete polynomials.T1;\n    delete polynomials.T2;\n    delete polynomials.Sigma1;\n    delete polynomials.Sigma2;\n    delete polynomials.Sigma3;\n    delete polynomials.QL;\n    delete polynomials.QR;\n    delete polynomials.QM;\n    delete polynomials.QC;\n    delete polynomials.QO;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 4. Compute W(X) polynomial\n    if (logger) logger.info(\"> ROUND 4\");\n    await round4();\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 5. Compute W'(X) polynomial\n    if (logger) logger.info(\"> ROUND 5\");\n    await round5();\n\n    delete polynomials.C0;\n    delete polynomials.C1;\n    delete polynomials.C2;\n    delete polynomials.R1;\n    delete polynomials.R2;\n    delete polynomials.F;\n    delete polynomials.L;\n    delete polynomials.ZT;\n    delete polynomials.ZTS2;\n    await fdZKey.close();\n    if (globalThis.gc) globalThis.gc();\n\n    proof.addEvaluation(\"inv\", getMontgomeryBatchedInverse());\n\n    // Prepare proof\n    let _proof = proof.toObjectProof();\n    _proof.protocol = \"fflonk\";\n    _proof.curve = curve.name;\n\n    // Prepare public inputs\n    let publicSignals = [];\n\n    for (let i = 1; i <= zkey.nPublic; i++) {\n        const i_sFr = i * sFr;\n\n        const pub = buffWitness.slice(i_sFr, i_sFr + sFr);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.info(\"FFLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.info(\" Computing additions\");\n        const additionsBuff = await readSection(fdZKey, zkeySections, ZKEY_FF_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + sFr * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + sFr);\n            offset += sFr;\n            const factor2 = additionsBuff.slice(offset, offset + sFr);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, sFr * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o + 4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        let diff = zkey.nVars - zkey.nAdditions;\n        if (idx < diff) {\n            return buffWitness.slice(idx * sFr, idx * sFr + sFr);\n        } else if (idx < zkey.nVars) {\n            const offset = (idx - diff) * sFr;\n            return buffInternalWitness.slice(offset, offset + sFr);\n        }\n\n        return Fr.zero;\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b_1, ..., b9)  F\n        challenges.b = [];\n        for (let i = 1; i <= 9; i++) {\n            challenges.b[i] = Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.info(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute the quotient polynomial T0(X)\n        if (logger) logger.info(\"> Computing T0 polynomial\");\n        await computeT0();\n\n        // STEP 1.4 - Compute the FFT-style combination polynomial C1(X)\n        if (logger) logger.info(\"> Computing C1 polynomial\");\n        await computeC1();\n\n        // The first output of the prover is ([C1]_1)\n        if (logger) logger.info(\"> Computing C1 multi exponentiation\");\n        let commitC1 = await polynomials.C1.multiExponentiation(PTau, \"C1\");\n        proof.addPolynomial(\"C1\", commitC1);\n\n        return 0;\n\n        async function computeWirePolynomials() {\n            if (logger) logger.info(\" Reading data from zkey file\");\n            // Build A, B and C evaluations buffer from zkey and witness files\n            buffers.A = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain);\n            buffers.B = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain);\n            buffers.C = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain);\n\n            // Read zkey sections and fill the buffers\n            const aMapBuff = await readSection(fdZKey, zkeySections, ZKEY_FF_A_MAP_SECTION);\n            const bMapBuff = await readSection(fdZKey, zkeySections, ZKEY_FF_B_MAP_SECTION);\n            const cMapBuff = await readSection(fdZKey, zkeySections, ZKEY_FF_C_MAP_SECTION);\n\n            // Compute all witness from signal ids and set them to A,B & C buffers\n            for (let i = 0; i < zkey.nConstraints; i++) {\n                const i_sFr = i * sFr;\n                const offset = i * 4;\n\n                // Compute A value from a signal id\n                const signalIdA = readUInt32(aMapBuff, offset);\n                buffers.A.set(getWitness(signalIdA), i_sFr);\n\n                // Compute B value from a signal id\n                const signalIdB = readUInt32(bMapBuff, offset);\n                buffers.B.set(getWitness(signalIdB), i_sFr);\n\n                // Compute C value from a signal id\n                const signalIdC = readUInt32(cMapBuff, offset);\n                buffers.C.set(getWitness(signalIdC), i_sFr);\n            }\n\n            // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n            buffers.A.set(challenges.b[1], sDomain - 64);\n            buffers.A.set(challenges.b[2], sDomain - 32);\n            buffers.B.set(challenges.b[3], sDomain - 64);\n            buffers.B.set(challenges.b[4], sDomain - 32);\n            buffers.C.set(challenges.b[5], sDomain - 64);\n            buffers.C.set(challenges.b[6], sDomain - 32);\n\n            buffers.A = await Fr.batchToMontgomery(buffers.A);\n            buffers.B = await Fr.batchToMontgomery(buffers.B);\n            buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n            // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n            if (logger) logger.info(\" Computing A ifft\");\n            polynomials.A = await Polynomial.fromEvaluations(buffers.A, curve, logger);\n            if (logger) logger.info(\" Computing B ifft\");\n            polynomials.B = await Polynomial.fromEvaluations(buffers.B, curve, logger);\n            if (logger) logger.info(\" Computing C ifft\");\n            polynomials.C = await Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n            // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n            if (logger) logger.info(\" Computing A fft\");\n            evaluations.A = await Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n            if (logger) logger.info(\" Computing B fft\");\n            evaluations.B = await Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n            if (logger) logger.info(\" Computing C fft\");\n            evaluations.C = await Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n            // Check degrees\n            if (polynomials.A.degree() >= zkey.domainSize) {\n                throw new Error(\"A Polynomial is not well calculated\");\n            }\n            if (polynomials.B.degree() >= zkey.domainSize) {\n                throw new Error(\"B Polynomial is not well calculated\");\n            }\n            if (polynomials.C.degree() >= zkey.domainSize) {\n                throw new Error(\"C Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeT0() {\n            if (logger) logger.info(` Reading sections ${ZKEY_FF_QL_SECTION}, ${ZKEY_FF_QR_SECTION}` +\n                `, ${ZKEY_FF_QM_SECTION}, ${ZKEY_FF_QO_SECTION}, ${ZKEY_FF_QC_SECTION}. Q selectors`);\n            // Reserve memory for Q's evaluations\n            evaluations.QL = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QR = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QM = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QO = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QC = new Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4), curve, logger);\n\n            // Read Q's evaluations from zkey file\n            await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QL_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QR_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QM_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QO_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QC_SECTION][0].p + sDomain);\n\n            // Read Lagrange polynomials & evaluations from zkey file\n            const lagrangePolynomials = await readSection(fdZKey, zkeySections, ZKEY_FF_LAGRANGE_SECTION);\n            evaluations.lagrange1 = new Evaluations(lagrangePolynomials, curve, logger);\n\n            // Reserve memory for buffers T0\n            buffers.T0 = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4);\n\n            if (logger) logger.info(\" Computing T0 evaluations\");\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`      T0 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                // Get related evaluations to compute current T0 evaluation\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n\n                const ql = evaluations.QL.getEvaluation(i);\n                const qr = evaluations.QR.getEvaluation(i);\n                const qm = evaluations.QM.getEvaluation(i);\n                const qo = evaluations.QO.getEvaluation(i);\n                const qc = evaluations.QC.getEvaluation(i);\n\n                // Compute current public input\n                let pi = Fr.zero;\n                for (let j = 0; j < zkey.nPublic; j++) {\n                    const offset = (j * 5 * zkey.domainSize) + zkey.domainSize + i;\n\n                    const lPol = evaluations.lagrange1.getEvaluation(offset);\n                    const aVal = buffers.A.slice(j * sFr, (j + 1) * sFr);\n\n                    pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n                }\n\n                //T0(X) = [q_L(X)a(X) + q_R(X)b(X) + q_M(X)a(X)b(X) + q_O(X)c(X) + q_C(X) + PI(X)]  1/Z_H(X)\n                // Compute first T0(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                // expression 1 -> q_L(X)a(X)\n                const e1 = Fr.mul(a, ql);\n\n                // expression 2 -> q_R(X)b(X)\n                const e2 = Fr.mul(b, qr);\n\n                // expression 3 -> q_M(X)a(X)b(X)\n                const e3 = Fr.mul(Fr.mul(a, b), qm);\n\n                // expression 4 -> q_O(X)c(X)\n                const e4 = Fr.mul(c, qo);\n\n                // t0 = expressions 1 + expression 2 + expression 3 + expression 4 + qc + pi\n                const t0 = Fr.add(e1, Fr.add(e2, Fr.add(e3, Fr.add(e4, Fr.add(qc, pi)))));\n\n                buffers.T0.set(t0, i * sFr);\n            }\n\n            if (logger) logger.info(\"buffer T0: \" + buffers.T0.byteLength / sFr);\n\n            // Compute the coefficients of the polynomial T0(X) from buffers.T0\n            if (logger) logger.info(\" Computing T0 ifft\");\n            polynomials.T0 = await Polynomial.fromEvaluations(buffers.T0, curve, logger);\n\n            if (logger) logger.info(\"T0 length: \" + polynomials.T0.length());\n            if (logger) logger.info(\"T0 degree: \" + polynomials.T0.degree());\n\n            // Divide the polynomial T0 by Z_H(X)\n            if (logger) logger.info(\" Computing T0 / ZH\");\n            polynomials.T0.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Check degree\n            if (polynomials.T0.degree() >= 2 * zkey.domainSize - 2) {\n                throw new Error(`T0 Polynomial is not well calculated (degree is ${polynomials.T0.degree()} and must be less than ${2 * zkey.domainSize + 2}`);\n            }\n\n            delete buffers.T0;\n        }\n\n        async function computeC1() {\n            let C1 = new CPolynomial(4, curve, logger);\n            C1.addPolynomial(0, polynomials.A);\n            C1.addPolynomial(1, polynomials.B);\n            C1.addPolynomial(2, polynomials.C);\n            C1.addPolynomial(3, polynomials.T0);\n\n            polynomials.C1 = C1.getPolynomial();\n\n            // Check degree\n            if (polynomials.C1.degree() >= 8 * zkey.domainSize - 8) {\n                throw new Error(\"C1 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.info(\"> Computing challenges beta and gamma\");\n        const transcript = new Keccak256Transcript(curve);\n\n        // Add C0 to the transcript\n        transcript.addPolCommitment(zkey.C0);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * sFr, i * sFr + sFr));\n        }\n\n        // Add C1 to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"C1\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.beta: \" + Fr.toString(challenges.beta));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n\n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.info(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute quotient polynomial T1(X) and T2(X)\n        if (logger) logger.info(\"> Computing T1 polynomial\");\n        await computeT1();\n        if (logger) logger.info(\"> Computing T2 polynomial\");\n        await computeT2();\n\n        // STEP 2.4 - Compute the FFT-style combination polynomial C2(X)\n        if (logger) logger.info(\"> Computing C2 polynomial\");\n        await computeC2();\n\n        // The second output of the prover is ([C2]_1)\n        if (logger) logger.info(\"> Computing C2 multi exponentiation\");\n        let commitC2 = await polynomials.C2.multiExponentiation(PTau, \"C2\");\n        proof.addPolynomial(\"C2\", commitC2);\n\n        return 0;\n\n        async function computeZ() {\n            if (logger) logger.info(\" Computing Z evaluations\");\n\n            let numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain);\n            let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain);\n\n            // Set the first values to 1\n            numArr.set(Fr.one, 0);\n            denArr.set(Fr.one, 0);\n\n            // Set initial omega\n            let w = Fr.one;\n            for (let i = 0; i < zkey.domainSize; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    Z evaluation ${i}/${zkey.domainSize}`);\n                const i_sFr = i * sFr;\n\n                // Z(X) := numArr / denArr\n                // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n                const betaw = Fr.mul(challenges.beta, w);\n\n                let num1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                num1 = Fr.add(num1, betaw);\n                num1 = Fr.add(num1, challenges.gamma);\n\n                let num2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                num2 = Fr.add(num2, Fr.mul(zkey.k1, betaw));\n                num2 = Fr.add(num2, challenges.gamma);\n\n                let num3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                num3 = Fr.add(num3, Fr.mul(zkey.k2, betaw));\n                num3 = Fr.add(num3, challenges.gamma);\n\n                let num = Fr.mul(num1, Fr.mul(num2, num3));\n\n                // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n                let den1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                den1 = Fr.add(den1, Fr.mul(challenges.beta, evaluations.Sigma1.getEvaluation(i * 4)));\n                den1 = Fr.add(den1, challenges.gamma);\n\n                let den2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                den2 = Fr.add(den2, Fr.mul(challenges.beta, evaluations.Sigma2.getEvaluation(i * 4)));\n                den2 = Fr.add(den2, challenges.gamma);\n\n                let den3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                den3 = Fr.add(den3, Fr.mul(challenges.beta, evaluations.Sigma3.getEvaluation(i * 4)));\n                den3 = Fr.add(den3, challenges.gamma);\n\n                let den = Fr.mul(den1, Fr.mul(den2, den3));\n\n                // Multiply current num value with the previous one saved in numArr\n                num = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), num);\n                numArr.set(num, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Multiply current den value with the previous one saved in denArr\n                den = Fr.mul(denArr.slice(i_sFr, i_sFr + sFr), den);\n                denArr.set(den, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Next omega\n                w = Fr.mul(w, Fr.w[zkey.power]);\n            }\n            // Compute the inverse of denArr to compute in the next command the\n            // division numArr/denArr by multiplying num  1/denArr\n            denArr = await Fr.batchInverse(denArr);\n\n            // TODO: Do it in assembly and in parallel\n            // Multiply numArr  denArr where denArr was inverted in the previous command\n            for (let i = 0; i < zkey.domainSize; i++) {\n                const i_sFr = i * sFr;\n\n                const z = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), denArr.slice(i_sFr, i_sFr + sFr));\n                numArr.set(z, i_sFr);\n            }\n            // From now on the values saved on numArr will be Z(X) buffer\n            buffers.Z = numArr;\n\n            if (!Fr.eq(numArr.slice(0, sFr), Fr.one)) {\n                throw new Error(\"Copy constraints does not match\");\n            }\n\n            // Compute polynomial coefficients z(X) from buffers.Z\n            if (logger) logger.info(\" Computing Z ifft\");\n            polynomials.Z = await Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n            // Compute extended evaluations of z(X) polynomial\n            if (logger) logger.info(\" Computing Z fft\");\n            evaluations.Z = await Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n            // Blind z(X) polynomial coefficients with blinding scalars b\n            polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n            // Check degree\n            if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n                throw new Error(\"Z Polynomial is not well calculated\");\n            }\n\n            delete buffers.Z;\n        }\n\n        async function computeT1() {\n            if (logger) logger.info(\" Computing T1 evaluations\");\n\n            buffers.T1 = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 2);\n            buffers.T1z = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 2);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 2; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T1 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n\n                const z = evaluations.Z.getEvaluation(i * 2);\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n\n                // T1(X) := (z(X) - 1)  L_1(X)\n                // Compute first T1(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                const lagrange1 = evaluations.lagrange1.getEvaluation(zkey.domainSize + i * 2);\n                let t1 = Fr.mul(Fr.sub(z, Fr.one), lagrange1);\n                let t1z = Fr.mul(zp, lagrange1);\n\n                buffers.T1.set(t1, i * sFr);\n                buffers.T1z.set(t1z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 1]);\n            }\n\n            // Compute the coefficients of the polynomial T1(X) from buffers.T1\n            if (logger) logger.info(\" Computing T1 ifft\");\n            polynomials.T1 = await Polynomial.fromEvaluations(buffers.T1, curve, logger);\n\n            // Divide the polynomial T1 by Z_H(X)\n            polynomials.T1.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T1z(X) from buffers.T1z\n            if (logger) logger.info(\" Computing T1z ifft\");\n            polynomials.T1z = await Polynomial.fromEvaluations(buffers.T1z, curve, logger);\n\n            // Add the polynomial T1z to T1 to get the final polynomial T1\n            polynomials.T1.add(polynomials.T1z);\n\n            // Check degree\n            if (polynomials.T1.degree() >= zkey.domainSize + 2) {\n                throw new Error(\"T1 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T1;\n            delete buffers.T1z;\n            delete polynomials.T1z;\n        }\n\n        async function computeT2() {\n            if (logger) logger.info(\" Computing T2 evaluations\");\n\n            buffers.T2 = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4);\n            buffers.T2z = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 4);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T2 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n                const omegaW = Fr.mul(omega, Fr.w[zkey.power]);\n                const omegaW2 = Fr.square(omegaW);\n\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n                const z = evaluations.Z.getEvaluation(i);\n                const zW = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n                const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omegaW2), Fr.mul(challenges.b[8], omegaW)), challenges.b[9]);\n\n                const sigma1 = evaluations.Sigma1.getEvaluation(i);\n                const sigma2 = evaluations.Sigma2.getEvaluation(i);\n                const sigma3 = evaluations.Sigma3.getEvaluation(i);\n\n                // T2(X) := [ (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                //           -(a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)]  1/Z_H(X)\n                // Compute first T2(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n\n                // expression 1 -> (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                const betaX = Fr.mul(challenges.beta, omega);\n\n                let e11 = Fr.add(a, betaX);\n                e11 = Fr.add(e11, challenges.gamma);\n\n                let e12 = Fr.add(b, Fr.mul(betaX, zkey.k1));\n                e12 = Fr.add(e12, challenges.gamma);\n\n                let e13 = Fr.add(c, Fr.mul(betaX, zkey.k2));\n                e13 = Fr.add(e13, challenges.gamma);\n\n                let e1 = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), z);\n                let e1z = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), zp);\n                // const [e1, e1z] = MulZ.mul4(e11, e12, e13, z, ap, bp, cp, zp, i % 4, Fr);\n\n                // expression 2 -> (a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)\n                let e21 = Fr.add(a, Fr.mul(challenges.beta, sigma1));\n                e21 = Fr.add(e21, challenges.gamma);\n\n                let e22 = Fr.add(b, Fr.mul(challenges.beta, sigma2));\n                e22 = Fr.add(e22, challenges.gamma);\n\n                let e23 = Fr.add(c, Fr.mul(challenges.beta, sigma3));\n                e23 = Fr.add(e23, challenges.gamma);\n\n                let e2 = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zW);\n                let e2z = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zWp);\n                // const [e2, e2z] = MulZ.mul4(e21, e22, e23, zW, ap, bp, cp, zWp, i % 4, Fr);\n\n                let t2 = Fr.sub(e1, e2);\n                let t2z = Fr.sub(e1z, e2z);\n\n                buffers.T2.set(t2, i * sFr);\n                buffers.T2z.set(t2z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 2]);\n            }\n\n            // Compute the coefficients of the polynomial T2(X) from buffers.T2\n            if (logger) logger.info(\" Computing T2 ifft\");\n            polynomials.T2 = await Polynomial.fromEvaluations(buffers.T2, curve, logger);\n\n            // Divide the polynomial T2 by Z_H(X)\n            if (logger) logger.info(\" Computing T2 / ZH\");\n            polynomials.T2.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T2z(X) from buffers.T2z\n            if (logger) logger.info(\" Computing T2z ifft\");\n            polynomials.T2z = await Polynomial.fromEvaluations(buffers.T2z, curve, logger);\n\n            // Add the polynomial T2z to T2 to get the final polynomial T2\n            polynomials.T2.add(polynomials.T2z);\n\n            // Check degree\n            if (polynomials.T2.degree() >= 3 * zkey.domainSize) {\n                throw new Error(\"T2 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T2;\n            delete buffers.T2z;\n            delete polynomials.T2z;\n        }\n\n        async function computeC2() {\n            let C2 = new CPolynomial(3, curve, logger);\n            C2.addPolynomial(0, polynomials.Z);\n            C2.addPolynomial(1, polynomials.T1);\n            C2.addPolynomial(2, polynomials.T2);\n\n            polynomials.C2 = C2.getPolynomial();\n\n            // Check degree\n            if (polynomials.C2.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"C2 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round3() {\n        if (logger) logger.info(\"> Computing challenge xi\");\n        // STEP 3.1 - Compute evaluation challenge xi  S\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"C2\"));\n\n        // Obtain a xi_seeder from the transcript\n        // To force h1^4 = xi, h2^3 = xi and h_3^2 = xi\n        // we compute xi = xi_seeder^12, h1 = xi_seeder^3, h2 = xi_seeder^4 and h3 = xi_seeder^6\n        challenges.xiSeed = transcript.getChallenge();\n        const xiSeed2 = Fr.square(challenges.xiSeed);\n\n        // Compute omega8, omega4 and omega3\n        roots.w8 = [];\n        roots.w8[0] = Fr.one;\n        for (let i = 1; i < 8; i++) {\n            roots.w8[i] = Fr.mul(roots.w8[i - 1], zkey.w8);\n        }\n\n        roots.w4 = [];\n        roots.w4[0] = Fr.one;\n        for (let i = 1; i < 4; i++) {\n            roots.w4[i] = Fr.mul(roots.w4[i - 1], zkey.w4);\n        }\n\n        roots.w3 = [];\n        roots.w3[0] = Fr.one;\n        roots.w3[1] = zkey.w3;\n        roots.w3[2] = Fr.square(zkey.w3);\n\n        // Compute h0 = xiSeeder^3\n        roots.S0 = {};\n        roots.S0.h0w8 = [];\n        roots.S0.h0w8[0] = Fr.mul(xiSeed2, challenges.xiSeed);\n        for (let i = 1; i < 8; i++) {\n            roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], roots.w8[i]);\n        }\n\n        // Compute h1 = xi_seeder^6\n        roots.S1 = {};\n        roots.S1.h1w4 = [];\n        roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n        for (let i = 1; i < 4; i++) {\n            roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], roots.w4[i]);\n        }\n\n        // Compute h2 = xi_seeder^8\n        roots.S2 = {};\n        roots.S2.h2w3 = [];\n        roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n        roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], roots.w3[1]);\n        roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], roots.w3[2]);\n\n        roots.S2.h3w3 = [];\n        // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n        // So, h3 = xi_seeder^8 ^{1/3}\n        roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], zkey.wr);\n        roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], roots.w3[1]);\n        roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], roots.w3[2]);\n\n        // Compute xi = xi_seeder^24\n        challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n\n        if (logger) logger.info(\" challenges.xi: \" + Fr.toString(challenges.xi));\n\n        // Reserve memory for Q's polynomials\n        polynomials.QL = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[ZKEY_FF_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[ZKEY_FF_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[ZKEY_FF_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[ZKEY_FF_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[ZKEY_FF_QC_SECTION][0].p);\n\n        // STEP 3.2 - Compute opening evaluations and add them to the proof (third output of the prover)\n        if (logger) logger.info(\" Computing evaluations\");\n        proof.addEvaluation(\"ql\", polynomials.QL.evaluate(challenges.xi));\n        proof.addEvaluation(\"qr\", polynomials.QR.evaluate(challenges.xi));\n        proof.addEvaluation(\"qm\", polynomials.QM.evaluate(challenges.xi));\n        proof.addEvaluation(\"qo\", polynomials.QO.evaluate(challenges.xi));\n        proof.addEvaluation(\"qc\", polynomials.QC.evaluate(challenges.xi));\n        proof.addEvaluation(\"s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"s3\", polynomials.Sigma3.evaluate(challenges.xi));\n        proof.addEvaluation(\"a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"z\", polynomials.Z.evaluate(challenges.xi));\n\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        proof.addEvaluation(\"zw\", polynomials.Z.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t1w\", polynomials.T1.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t2w\", polynomials.T2.evaluate(challenges.xiw));\n    }\n\n    async function round4() {\n        if (logger) logger.info(\"> Computing challenge alpha\");\n        // STEP 4.1 - Compute challenge alpha  F\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.xiSeed);\n        transcript.addScalar(proof.getEvaluation(\"ql\"));\n        transcript.addScalar(proof.getEvaluation(\"qr\"));\n        transcript.addScalar(proof.getEvaluation(\"qm\"));\n        transcript.addScalar(proof.getEvaluation(\"qo\"));\n        transcript.addScalar(proof.getEvaluation(\"qc\"));\n        transcript.addScalar(proof.getEvaluation(\"s1\"));\n        transcript.addScalar(proof.getEvaluation(\"s2\"));\n        transcript.addScalar(proof.getEvaluation(\"s3\"));\n        transcript.addScalar(proof.getEvaluation(\"a\"));\n        transcript.addScalar(proof.getEvaluation(\"b\"));\n        transcript.addScalar(proof.getEvaluation(\"c\"));\n        transcript.addScalar(proof.getEvaluation(\"z\"));\n        transcript.addScalar(proof.getEvaluation(\"zw\"));\n        transcript.addScalar(proof.getEvaluation(\"t1w\"));\n        transcript.addScalar(proof.getEvaluation(\"t2w\"));\n        challenges.alpha = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n\n        // STEP 4.2 - Compute F(X)\n        if (logger) logger.info(\"> Reading C0 polynomial\");\n        polynomials.C0 = new Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(sDomain * 8), curve, logger);\n        await fdZKey.readToBuffer(polynomials.C0.coef, 0, sDomain * 8, zkeySections[ZKEY_FF_C0_SECTION][0].p);\n\n        if (logger) logger.info(\"> Computing R0 polynomial\");\n        computeR0();\n        if (logger) logger.info(\"> Computing R1 polynomial\");\n        computeR1();\n        if (logger) logger.info(\"> Computing R2 polynomial\");\n        computeR2();\n\n        if (logger) logger.info(\"> Computing F polynomial\");\n        await computeF();\n\n        // The fourth output of the prover is ([W1]_1), where W1:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W1 multi exponentiation\");\n        let commitW1 = await polynomials.F.multiExponentiation(PTau, \"W1\");\n        proof.addPolynomial(\"W1\", commitW1);\n\n        return 0;\n\n        function computeR0() {\n            // COMPUTE R0\n            // Compute the coefficients of R0(X) from 8 evaluations using lagrange interpolation. R0(X)  F_{<8}[X]\n            // We decide to use Lagrange interpolations because the R0 degree is very small (deg(R0)===7),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R0 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7]],\n                [polynomials.C0.evaluate(roots.S0.h0w8[0]), polynomials.C0.evaluate(roots.S0.h0w8[1]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[2]), polynomials.C0.evaluate(roots.S0.h0w8[3]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[4]), polynomials.C0.evaluate(roots.S0.h0w8[5]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[6]), polynomials.C0.evaluate(roots.S0.h0w8[7])], curve);\n\n            // Check the degree of r0(X) < 8\n            if (polynomials.R0.degree() > 7) {\n                throw new Error(\"R0 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR1() {\n            // COMPUTE R1\n            // Compute the coefficients of R1(X) from 4 evaluations using lagrange interpolation. R1(X)  F_{<4}[X]\n            // We decide to use Lagrange interpolations because the R1 degree is very small (deg(R1)===3),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R1 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3]],\n                [polynomials.C1.evaluate(roots.S1.h1w4[0]), polynomials.C1.evaluate(roots.S1.h1w4[1]),\n                    polynomials.C1.evaluate(roots.S1.h1w4[2]), polynomials.C1.evaluate(roots.S1.h1w4[3])], curve);\n\n            // Check the degree of r1(X) < 4\n            if (polynomials.R1.degree() > 3) {\n                throw new Error(\"R1 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR2() {\n            // COMPUTE R2\n            // Compute the coefficients of r2(X) from 6 evaluations using lagrange interpolation. r2(X)  F_{<6}[X]\n            // We decide to use Lagrange interpolations because the R2.degree is very small (deg(R2)===5),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R2 = Polynomial.lagrangePolynomialInterpolation(\n                [roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]],\n                [polynomials.C2.evaluate(roots.S2.h2w3[0]), polynomials.C2.evaluate(roots.S2.h2w3[1]),\n                    polynomials.C2.evaluate(roots.S2.h2w3[2]), polynomials.C2.evaluate(roots.S2.h3w3[0]),\n                    polynomials.C2.evaluate(roots.S2.h3w3[1]), polynomials.C2.evaluate(roots.S2.h3w3[2])], curve);\n\n            // Check the degree of r2(X) < 6\n            if (polynomials.R2.degree() > 5) {\n                throw new Error(\"R2 Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeF() {\n            if (logger) logger.info(\" Computing F polynomial\");\n\n            // COMPUTE F(X)\n            polynomials.F = Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.F.sub(polynomials.R0);\n            polynomials.F.divByZerofier(8, challenges.xi);\n\n            let f2 = Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            f2.sub(polynomials.R1);\n            f2.mulScalar(challenges.alpha);\n            f2.divByZerofier(4, challenges.xi);\n\n            let f3 = Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            f3.sub(polynomials.R2);\n            f3.mulScalar(Fr.square(challenges.alpha));\n            f3.divByZerofier(3, challenges.xi);\n            f3.divByZerofier(3, challenges.xiw);\n\n            polynomials.F.add(f2);\n            polynomials.F.add(f3);\n\n            if (polynomials.F.degree() >= 9 * zkey.domainSize - 6) {\n                throw new Error(\"F Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round5() {\n        if (logger) logger.info(\"> Computing challenge y\");\n\n        // STEP 5.1 - Compute random evaluation point y  F\n        const transcript = new Keccak256Transcript(curve);\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"W1\"));\n\n        challenges.y = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.y: \" + Fr.toString(challenges.y));\n\n        // STEP 5.2 - Compute L(X)\n        if (logger) logger.info(\"> Computing L polynomial\");\n        await computeL();\n\n        if (logger) logger.info(\"> Computing ZTS2 polynomial\");\n        await computeZTS2();\n\n        let ZTS2Y = polynomials.ZTS2.evaluate(challenges.y);\n        ZTS2Y = Fr.inv(ZTS2Y);\n        polynomials.L.mulScalar(ZTS2Y);\n\n        const polDividend = Polynomial.fromCoefficientsArray([Fr.neg(challenges.y), Fr.one], curve);\n        if (logger) logger.info(\"> Computing W' = L / ZTS2 polynomial\");\n        const polRemainder = polynomials.L.divBy(polDividend);\n\n        //Check polReminder degree is equal to zero\n        if (polRemainder.degree() > 0) {\n            throw new Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${polRemainder.degree()} and should be 0`);\n        }\n\n        if (polynomials.L.degree() >= 9 * zkey.domainSize - 1) {\n            throw new Error(\"Degree of L(X)/(ZTS2(y)(X-y)) is not correct\");\n        }\n\n        // The fifth output of the prover is ([W2]_1), where W2:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W' multi exponentiation\");\n        let commitW2 = await polynomials.L.multiExponentiation(PTau, \"W2\");\n        proof.addPolynomial(\"W2\", commitW2);\n\n        return 0;\n\n        async function computeL() {\n            if (logger) logger.info(\" Computing L polynomial\");\n\n            const evalR0Y = polynomials.R0.evaluate(challenges.y);\n            const evalR1Y = polynomials.R1.evaluate(challenges.y);\n            const evalR2Y = polynomials.R2.evaluate(challenges.y);\n\n            let mulL0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n            for (let i = 1; i < 8; i++) {\n                mulL0 = Fr.mul(mulL0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n            }\n\n            let mulL1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n            for (let i = 1; i < 4; i++) {\n                mulL1 = Fr.mul(mulL1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n            }\n\n            let mulL2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n            for (let i = 1; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n            }\n            for (let i = 0; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n            }\n\n            let preL0 = Fr.mul(mulL1, mulL2);\n            let preL1 = Fr.mul(challenges.alpha, Fr.mul(mulL0, mulL2));\n            let preL2 = Fr.mul(Fr.square(challenges.alpha), Fr.mul(mulL0, mulL1));\n\n            toInverse[\"denH1\"] = mulL1;\n            toInverse[\"denH2\"] = mulL2;\n\n            // COMPUTE L(X)\n            polynomials.L = Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.L.subScalar(evalR0Y);\n            polynomials.L.mulScalar(preL0);\n\n            let l2 = Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            l2.subScalar(evalR1Y);\n            l2.mulScalar(preL1);\n\n            let l3 = Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            l3.subScalar(evalR2Y);\n            l3.mulScalar(preL2);\n\n            polynomials.L.add(l2);\n            polynomials.L.add(l3);\n\n            if (logger) logger.info(\"> Computing ZT polynomial\");\n            await computeZT();\n\n            const evalZTY = polynomials.ZT.evaluate(challenges.y);\n            polynomials.F.mulScalar(evalZTY);\n            polynomials.L.sub(polynomials.F);\n\n            // Check degree\n            if (polynomials.L.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"L Polynomial is not well calculated\");\n            }\n\n            delete buffers.L;\n        }\n\n        async function computeZT() {\n            polynomials.ZT = Polynomial.zerofierPolynomial(\n                [\n                    roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7],\n                    roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n\n        async function computeZTS2() {\n            polynomials.ZTS2 = Polynomial.zerofierPolynomial(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n    }\n\n    function getMontgomeryBatchedInverse() {\n        //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n        let xiN = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            xiN = Fr.square(xiN);\n        }\n        toInverse[\"zh\"] = Fr.sub(xiN, Fr.one);\n\n        //    denominator needed in step 10 and 11 of the verifier\n        //     toInverse.denH1 & toInverse.denH2  -> Computed in round5, computeL()\n\n        //    denominator needed in the verifier when computing L_i^{S0}(X), L_i^{S1}(X) and L_i^{S2}(X)\n        computeLiS0(toInverse, roots.S0.h0w8, challenges.y, curve);\n\n        computeLiS1(toInverse, roots.S1.h1w4, challenges.y, curve);\n\n        computeLiS2(toInverse, roots.S2.h2w3, roots.S2.h3w3, challenges.y, challenges.xi, challenges.xiw, curve);\n\n        //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n        const size = Math.max(1, zkey.nPublic);\n\n        let w = Fr.one;\n        for (let i = 0; i < size; i++) {\n            toInverse[\"Li_\" + (i + 1)] = Fr.mul(Fr.e(zkey.domainSize), Fr.sub(challenges.xi, w));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        let mulAccumulator = Fr.one;\n        for (const element of Object.values(toInverse)) {\n            if(Array.isArray(element)) {\n                for (const subElement of element) {\n                    mulAccumulator = Fr.mul(mulAccumulator, subElement);\n                }\n            } else {\n                mulAccumulator = Fr.mul(mulAccumulator, element);\n            }\n        }\n        return Fr.inv(mulAccumulator);\n\n        \n        function computeLiS0(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS0_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n            }\n        \n            return Li;\n        }\n\n        function computeLiS1(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS1_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n\n            }\n        \n            return Li;\n        }\n\n        function computeLiS2(toInverse, S2, S2p, value, xi, xiw, curve) {\n            const Fr = curve.Fr;\n        \n            const Li = [];\n        \n            const _3h2 = Fr.mul(Fr.e(3), S2[0]);\n            const xisubxiw = Fr.sub(xi, xiw);\n            let den1 = Fr.mul(_3h2, xisubxiw);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2[2 * i % 3];\n                const den3 = Fr.sub(value, S2[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1)]] = Fr.mul(den1,Fr.mul(den2, den3));\n                \n            }\n        \n            const _3h3 = Fr.mul(Fr.e(3), S2p[0]);\n            const xiwsubxi = Fr.sub(xiw, xi);\n            den1 = Fr.mul(_3h3, xiwsubxi);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2p[2 * i % 3];\n                const den3 = Fr.sub(value, S2p[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1 + 3)]] = Fr.mul(den1,Fr.mul(den2, den3));    \n            }\n        \n            return Li;\n        }\n    }\n}\n\n/*\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\nconst {unstringifyBigInts: unstringifyBigInts$2} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function fflonkFullProve(_input, wasmFilename, zkeyFilename, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts$2(_input);\n\n    const wtns= {type: \"mem\"};\n\n    // Compute the witness\n    await wtnsCalculate(input, wasmFilename, wtns, wtnsCalcOptions);\n\n    // Compute the proof\n    return await fflonkProve(zkeyFilename, wtns, logger, proverOptions);\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { unstringifyBigInts: unstringifyBigInts$1 } = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function fflonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    if (logger) logger.info(\"FFLONK VERIFIER STARTED\");\n\n    _vk_verifier = unstringifyBigInts$1(_vk_verifier);\n    _proof = unstringifyBigInts$1(_proof);\n\n    const curve = await getCurveFromName(_vk_verifier.curve);\n\n    const vk = fromObjectVk(curve, _vk_verifier);\n\n    // TODO ??? Compute wr^3 and check if it matches with w\n\n    const proof = new Proof(curve, logger);\n    proof.fromObjectProof(_proof);\n\n    const publicSignals = unstringifyBigInts$1(_publicSignals);\n\n    if (publicSignals.length !== vk.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const Fr = curve.Fr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK VERIFY SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${vk.power}`);\n        logger.info(`  Domain size:   ${2 ** vk.power}`);\n        logger.info(`  Public vars:   ${vk.nPublic}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // STEP 1 - Validate that all polynomial commitments  G_1\n    if (logger) logger.info(\"> Checking commitments belong to G1\");\n    if (!commitmentsBelongToG1(curve, proof, vk)) {\n        if (logger) logger.error(\"Proof commitments are not valid\");\n        return false;\n    }\n\n    // STEP 2 - Validate that all evaluations  F\n    if (logger) logger.info(\"> Checking evaluations belong to F\");\n    if (!evaluationsAreValid(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid.\");\n        return false;\n    }\n\n    // STEP 3 - Validate that w_i  F for i  [l]\n    if (logger) logger.info(\"> Checking public inputs belong to F\");\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    // STEP 4 - Compute the challenges: beta, gamma, xi, alpha and y  F\n    // as in prover description, from the common preprocessed inputs, public inputs and elements of _SNARK\n    if (logger) logger.info(\"> Computing challenges\");\n    const { challenges, roots } = computeChallenges(curve, proof, vk, publicSignals, logger);\n\n    // STEP 5 - Compute the zero polynomial evaluation Z_H(xi) = xi^n - 1\n    if (logger) logger.info(\"> Computing Zero polynomial evaluation Z_H(xi)\");\n    challenges.zh = Fr.sub(challenges.xiN, Fr.one);\n    challenges.invzh = Fr.inv(challenges.zh);\n\n    // STEP 6 - Compute the lagrange polynomial evaluation L_1(xi)\n    if (logger) logger.info(\"> Computing Lagrange evaluations\");\n    const lagrangeEvals = await computeLagrangeEvaluations(curve, challenges, vk);\n\n    // STEP 7 - Compute public input evaluation PI(xi)\n    if (logger) logger.info(\"> Computing polynomial identities PI(X)\");\n    const pi = calculatePI(curve, publicSignals, lagrangeEvals);\n\n    // STEP 8 - Compute polynomial r0  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r0(y)\");\n    const r0 = computeR0(proof, challenges, roots, curve, logger);\n\n    // STEP 9 - Compute polynomial r1  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r1(y)\");\n    const r1 = computeR1(proof, challenges, roots, pi, curve, logger);\n\n    // STEP 9 - Compute polynomial r2  F_{<6}[X]\n    if (logger) logger.info(\"> Computing r2(y)\");\n    const r2 = computeR2(proof, challenges, roots, lagrangeEvals[1], vk, curve, logger);\n\n    if (logger) logger.info(\"> Computing F\");\n    const F = computeF(curve, proof, vk, challenges, roots);\n\n    if (logger) logger.info(\"> Computing E\");\n    const E = computeE(curve, proof, challenges, vk, r0, r1, r2);\n\n    if (logger) logger.info(\"> Computing J\");\n    const J = computeJ(curve, proof, challenges);\n\n    if (logger) logger.info(\"> Validate all evaluations with a pairing\");\n    const res = await isValidPairing(curve, proof, challenges, vk, F, E, J);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"PROOF VERIFIED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    if (logger) logger.info(\"FFLONK VERIFIER FINISHED\");\n\n    return res;\n\n}\n\nfunction fromObjectVk(curve, vk) {\n    const res = vk;\n    res.k1 = curve.Fr.fromObject(vk.k1);\n    res.k2 = curve.Fr.fromObject(vk.k2);\n    res.w = curve.Fr.fromObject(vk.w);\n    // res.wW = curve.Fr.fromObject(vk.wW);\n    res.w3 = curve.Fr.fromObject(vk.w3);\n    res.w4 = curve.Fr.fromObject(vk.w4);\n    res.w8 = curve.Fr.fromObject(vk.w8);\n    res.wr = curve.Fr.fromObject(vk.wr);\n    res.X_2 = curve.G2.fromObject(vk.X_2);\n    res.C0 = curve.G1.fromObject(vk.C0);\n    return res;\n}\n\nfunction commitmentsBelongToG1(curve, proof, vk) {\n    const G1 = curve.G1;\n    return G1.isValid(proof.polynomials.C1)\n        && G1.isValid(proof.polynomials.C2)\n        && G1.isValid(proof.polynomials.W1)\n        && G1.isValid(proof.polynomials.W2)\n        && G1.isValid(vk.C0);\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.geq(value, 0) && ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid(curve, evaluation) {\n    return checkValueBelongToField(curve, ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid(curve, proof) {\n    return checkEvaluationIsValid(curve, proof.evaluations.ql)\n        && checkEvaluationIsValid(curve, proof.evaluations.qr)\n        && checkEvaluationIsValid(curve, proof.evaluations.qm)\n        && checkEvaluationIsValid(curve, proof.evaluations.qo)\n        && checkEvaluationIsValid(curve, proof.evaluations.qc)\n        && checkEvaluationIsValid(curve, proof.evaluations.s1)\n        && checkEvaluationIsValid(curve, proof.evaluations.s2)\n        && checkEvaluationIsValid(curve, proof.evaluations.s3)\n        && checkEvaluationIsValid(curve, proof.evaluations.a)\n        && checkEvaluationIsValid(curve, proof.evaluations.b)\n        && checkEvaluationIsValid(curve, proof.evaluations.c)\n        && checkEvaluationIsValid(curve, proof.evaluations.z)\n        && checkEvaluationIsValid(curve, proof.evaluations.zw)\n        && checkEvaluationIsValid(curve, proof.evaluations.t1w)\n        && checkEvaluationIsValid(curve, proof.evaluations.t2w);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction computeChallenges(curve, proof, vk, publicSignals, logger) {\n    const Fr = curve.Fr;\n\n    const challenges = {};\n    const roots = {};\n    const transcript = new Keccak256Transcript(curve);\n\n    // Add C0 to the transcript\n    transcript.addPolCommitment(vk.C0);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.polynomials.C1);\n    challenges.beta = transcript.getChallenge();\n    transcript.reset();\n\n    transcript.addScalar(challenges.beta);\n    challenges.gamma = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.gamma);\n    transcript.addPolCommitment(proof.polynomials.C2);\n    const xiSeed = transcript.getChallenge();\n    const xiSeed2 = Fr.square(xiSeed);\n\n    let w8 = [];\n    w8[1] = vk.w8;\n    w8[2] = Fr.square(vk.w8);\n    w8[3] = Fr.mul(w8[2], vk.w8);\n    w8[4] = Fr.mul(w8[3], vk.w8);\n    w8[5] = Fr.mul(w8[4], vk.w8);\n    w8[6] = Fr.mul(w8[5], vk.w8);\n    w8[7] = Fr.mul(w8[6], vk.w8);\n    let w4 = [];\n    w4[1] = vk.w4;\n    w4[2] = Fr.square(vk.w4);\n    w4[3] = Fr.mul(w4[2], vk.w4);\n    let w3 = [];\n    w3[1] = vk.w3;\n    w3[2] = Fr.square(vk.w3);\n\n    // const w4_2 = Fr.square(vk.w4);\n    // const w4_3 = Fr.mul(w4_2, vk.w4);\n    // const w3_2 = Fr.square(vk.w3);\n\n    // Compute h0 = xiSeeder^3\n    roots.S0 = {};\n    roots.S0.h0w8 = [];\n    roots.S0.h0w8[0] = Fr.mul(xiSeed2, xiSeed);\n    for (let i = 1; i < 8; i++) {\n        roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], w8[i]);\n    }\n\n    // Compute h1 = xi_seeder^6\n    roots.S1 = {};\n    roots.S1.h1w4 = [];\n    roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n    for (let i = 1; i < 4; i++) {\n        roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], w4[i]);\n    }\n\n    // Compute h2 = xi_seeder^8\n    roots.S2 = {};\n    roots.S2.h2w3 = [];\n    roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n    roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], w3[1]);\n    roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], w3[2]);\n\n    roots.S2.h3w3 = [];\n    // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n    // So, h3 = xi_seeder^8 ^{1/3}\n    roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], vk.wr);\n    roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], w3[1]);\n    roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], w3[2]);\n\n    // Compute xi = xi_seeder^12\n    challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n    challenges.xiw = Fr.mul(challenges.xi, Fr.w[vk.power]);\n\n    challenges.xiN = challenges.xi;\n    vk.domainSize = 1;\n    for (let i = 0; i < vk.power; i++) {\n        challenges.xiN = Fr.square(challenges.xiN);\n        vk.domainSize *= 2;\n    }\n\n    transcript.reset();\n    transcript.addScalar(xiSeed);\n    transcript.addScalar(proof.evaluations.ql);\n    transcript.addScalar(proof.evaluations.qr);\n    transcript.addScalar(proof.evaluations.qm);\n    transcript.addScalar(proof.evaluations.qo);\n    transcript.addScalar(proof.evaluations.qc);\n    transcript.addScalar(proof.evaluations.s1);\n    transcript.addScalar(proof.evaluations.s2);\n    transcript.addScalar(proof.evaluations.s3);\n    transcript.addScalar(proof.evaluations.a);\n    transcript.addScalar(proof.evaluations.b);\n    transcript.addScalar(proof.evaluations.c);\n    transcript.addScalar(proof.evaluations.z);\n    transcript.addScalar(proof.evaluations.zw);\n    transcript.addScalar(proof.evaluations.t1w);\n    transcript.addScalar(proof.evaluations.t2w);\n    challenges.alpha = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.alpha);\n    transcript.addPolCommitment(proof.polynomials.W1);\n    challenges.y = transcript.getChallenge();\n\n    if (logger) {\n        logger.info(\" challenges.beta:  \" + Fr.toString(challenges.beta));\n        logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n        logger.info(\" challenges.xi:    \" + Fr.toString(challenges.xi));\n        logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n        logger.info(\" challenges.y:     \" + Fr.toString(challenges.y));\n    }\n\n    return { challenges: challenges, roots: roots };\n}\n\nasync function computeLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    const size = Math.max(1, vk.nPublic);\n    const numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(size * Fr.n8);\n    let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(size * Fr.n8);\n\n    let w = Fr.one;\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        numArr.set(Fr.mul(w, challenges.zh), i_sFr);\n        denArr.set(Fr.mul(Fr.e(vk.domainSize), Fr.sub(challenges.xi, w)), i_sFr);\n        w = Fr.mul(w, vk.w);\n    }\n\n    denArr = await Fr.batchInverse(denArr);\n\n    let L = [];\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        L[i + 1] = Fr.mul(numArr.slice(i_sFr, i_sFr + Fr.n8), denArr.slice(i_sFr, i_sFr + Fr.n8));\n    }\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, lagrangeEvals) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i = 0; i < publicSignals.length; i++) {\n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, lagrangeEvals[i + 1]));\n    }\n    return pi;\n}\n\nfunction computeR0(proof, challenges, roots, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S0.h0w8, challenges.y, challenges.xi, curve);\n\n    // r0(y) = _1^8 C_0(h_0 _8^{i-1}) L_i(y). To this end we need to compute\n\n    // Compute the 8 C0 values\n    if (logger) logger.info(\" Computing r0(y)\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 8; i++) {\n        let coefValues = [];\n        coefValues[1] = roots.S0.h0w8[i];\n        for (let j = 2; j < 8; j++) {\n            coefValues[j] = Fr.mul(coefValues[j - 1], roots.S0.h0w8[i]);\n        }\n\n        let c0 = Fr.add(proof.evaluations.ql, Fr.mul(proof.evaluations.qr, coefValues[1]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qo, coefValues[2]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qm, coefValues[3]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qc, coefValues[4]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s1, coefValues[5]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s2, coefValues[6]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s3, coefValues[7]));\n\n        res = Fr.add(res, Fr.mul(c0, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR1(proof, challenges, roots, pi, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S1.h1w4, challenges.y, challenges.xi, curve);\n\n    // r1(y) = _1^4 C_1(h_1 _4^{i-1}) L_i(y). To this end we need to compute\n    // Z1 = {C1(h_1}, C1(h_1 _4), C1(h_1 _4^2), C1(h_1 _4^3)}\n    // where C_1(h_1 _4^{i-1}) = eval.a + h_1 _4^i eval.b + (h_1 _4^i)^2 eval.c + (h_1 _4^i)^3 T0(xi),\n    // where T0(xi) = [ qLa + qRb + qMab + qOc + qC + PI(xi) ] / Z_H(xi)\n\n    // Compute T0(xi)\n    if (logger) logger.info(\" Computing T0(xi)\");\n    let t0 = Fr.mul(proof.evaluations.ql, proof.evaluations.a);\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qr, proof.evaluations.b));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qm, Fr.mul(proof.evaluations.a, proof.evaluations.b)));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qo, proof.evaluations.c));\n    t0 = Fr.add(t0, proof.evaluations.qc);\n    t0 = Fr.add(t0, pi);\n    t0 = Fr.mul(t0, challenges.invzh);\n\n    // Compute the 4 C1 values\n    if (logger) logger.info(\" Computing C1(h_1_4^i) values\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 4; i++) {\n        let c1 = proof.evaluations.a;\n        c1 = Fr.add(c1, Fr.mul(roots.S1.h1w4[i], proof.evaluations.b));\n        const h1w4Squared = Fr.square(roots.S1.h1w4[i]);\n        c1 = Fr.add(c1, Fr.mul(h1w4Squared, proof.evaluations.c));\n        c1 = Fr.add(c1, Fr.mul(Fr.mul(h1w4Squared, roots.S1.h1w4[i]), t0));\n\n        res = Fr.add(res, Fr.mul(c1, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR2(proof, challenges, roots, lagrange1, vk, curve, logger) {\n    const Fr = curve.Fr;\n\n    const LiS2 = computeLagrangeLiS2([roots.S2.h2w3, roots.S2.h3w3], challenges.y, challenges.xi, challenges.xiw, curve);\n\n    // r2(y) = _1^3 C_2(h_2 _3^{i-1}) L_i(y) + _1^3 C_2(h_3 _3^{i-1}) L_{i+3}(y). To this end we need to compute\n    // Z2 = {[C2(h_2}, C2(h_2 _3), C2(h_2 _3^2)], [C2(h_3}, C2(h_3 _3), C2(h_3 _3^2)]}\n    // where C_2(h_2 _3^{i-1}) = eval.z + h_2 _2^i T1(xi) + (h_2 _3^i)^2 T2(xi),\n    // where C_2(h_3 _3^{i-1}) = eval.z + h_3 _2^i T1(xi) + (h_3 _3^i)^2 T2(xi),\n    // where T1(xi) = [ L_1(xi)(z-1)] / Z_H(xi)\n    // and T2(xi) = [  (a + betaxi + gamma)(b + betaxik1 + gamma)(c + betaxik2 + gamma)z\n    //               - (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)z  ] / Z_H(xi)\n\n    // Compute T1(xi)\n    if (logger) logger.info(\" Computing T1(xi)\");\n    let t1 = Fr.sub(proof.evaluations.z, Fr.one);\n    t1 = Fr.mul(t1, lagrange1);\n    t1 = Fr.mul(t1, challenges.invzh);\n\n    // Compute T2(xi)\n    if (logger) logger.info(\" Computing T2(xi)\");\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n    const t211 = Fr.add(proof.evaluations.a, Fr.add(betaxi, challenges.gamma));\n    const t212 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(betaxi, vk.k1), challenges.gamma));\n    const t213 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(betaxi, vk.k2), challenges.gamma));\n    const t21 = Fr.mul(t211, Fr.mul(t212, Fr.mul(t213, proof.evaluations.z)));\n\n    const t221 = Fr.add(proof.evaluations.a, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s1), challenges.gamma));\n    const t222 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s2), challenges.gamma));\n    const t223 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s3), challenges.gamma));\n    const t22 = Fr.mul(t221, Fr.mul(t222, Fr.mul(t223, proof.evaluations.zw)));\n\n    let t2 = Fr.sub(t21, t22);\n    t2 = Fr.mul(t2, challenges.invzh);\n\n    // Compute the 6 C2 values\n    if (logger) logger.info(\" Computing C2(h_2_3^i) values\");\n    let res = Fr.zero;\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.z, Fr.mul(roots.S2.h2w3[i], t1));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h2w3[i]), t2));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i]));\n    }\n\n    if (logger) logger.info(\" Computing C2(h_3_3^i) values\");\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.zw, Fr.mul(roots.S2.h3w3[i], proof.evaluations.t1w));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h3w3[i]), proof.evaluations.t2w));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i + 3]));\n    }\n\n    return res;\n}\n\nfunction computeF(curve, proof, vk, challenges, roots) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let mulH0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n    for (let i = 1; i < 8; i++) {\n        mulH0 = Fr.mul(mulH0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n    }\n\n    challenges.temp = mulH0;\n\n    let mulH1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n    for (let i = 1; i < 4; i++) {\n        mulH1 = Fr.mul(mulH1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n    }\n\n    let mulH2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n    for (let i = 1; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n    }\n    for (let i = 0; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n    }\n\n    challenges.quotient1 = Fr.mul(challenges.alpha, Fr.div(mulH0, mulH1));\n    challenges.quotient2 = Fr.mul(Fr.square(challenges.alpha), Fr.div(mulH0, mulH2));\n\n    let F2 = G1.timesFr(proof.polynomials.C1, challenges.quotient1);\n    let F3 = G1.timesFr(proof.polynomials.C2, challenges.quotient2);\n\n    return G1.add(vk.C0, G1.add(F2, F3));\n}\n\nfunction computeE(curve, proof, challenges, vk, r0, r1, r2) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let E2 = Fr.mul(r1, challenges.quotient1);\n    let E3 = Fr.mul(r2, challenges.quotient2);\n\n    return G1.timesFr(G1.one, Fr.add(r0, Fr.add(E2, E3)));\n}\n\nfunction computeJ(curve, proof, challenges) {\n    const G1 = curve.G1;\n\n    return G1.timesFr(proof.polynomials.W1, challenges.temp);\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, F, E, J) {\n    const G1 = curve.G1;\n\n    let A1 = G1.timesFr(proof.polynomials.W2, challenges.y);\n    A1 = G1.add(G1.sub(G1.sub(F, E), J), A1);\n    const A2 = curve.G2.one;\n\n    const B1 = proof.polynomials.W2;\n    const B2 = vk.X_2;\n\n    return await curve.pairingEq(G1.neg(A1), A2, B1, B2);\n}\n\n\nfunction computeLagrangeLiSi(roots, x, xi, curve) {\n    const Fr = curve.Fr;\n    const len = roots.length;\n\n    const num = Fr.sub(Fr.exp(x, len), xi);\n    const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n\n    const Li = [];\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[((len - 1) * i) % len];\n        const den3 = Fr.sub(x, roots[i]);\n\n        Li[i] = Fr.div(num, Fr.mul(Fr.mul(den1, den2), den3));\n    }\n\n    return Li;\n}\n\nfunction computeLagrangeLiS2(roots, value, xi0, xi1, curve) {\n    const Fr = curve.Fr;\n\n    const Li = [];\n\n    const len = roots[0].length;\n    const n = len * roots.length;\n\n    const num1 = Fr.exp(value, n);\n    const num2 = Fr.mul(Fr.add(xi0, xi1), Fr.exp(value, len));\n    const num3 = Fr.mul(xi0, xi1);\n    const num = Fr.add(Fr.sub(num1, num2), num3);\n\n    let den1 = Fr.mul(Fr.mul(Fr.e(len), roots[0][0]), Fr.sub(xi0, xi1));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[0][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[0][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i] = Fr.div(num, den);\n    }\n\n    den1 = Fr.mul(Fr.mul(Fr.e(len), roots[1][0]), Fr.sub(xi1, xi0));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[1][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[1][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i + len] = Fr.div(num, den);\n    }\n\n    return Li;\n}\n\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\" + nstr;\n    nstr = `0x${nstr}`;\n    return nstr;\n}\n\nasync function fflonkExportCallData(_pub, _proof) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    await getCurveFromName(proof.curve);\n\n    let inputs = \"\";\n    for (let i = 0; i < pub.length; i++) {\n        if (inputs !== \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.polynomials.C1[0])}, ${p256(proof.polynomials.C1[1])},` +\n    `${p256(proof.polynomials.C2[0])},${p256(proof.polynomials.C2[1])},` +\n    `${p256(proof.polynomials.W1[0])},${p256(proof.polynomials.W1[1])},` +\n    `${p256(proof.polynomials.W2[0])},${p256(proof.polynomials.W2[1])},` +\n    `${p256(proof.evaluations.ql)},${p256(proof.evaluations.qr)},${p256(proof.evaluations.qm)},` +\n    `${p256(proof.evaluations.qo)},${p256(proof.evaluations.qc)},${p256(proof.evaluations.s1)},` +\n    `${p256(proof.evaluations.s2)},${p256(proof.evaluations.s3)},${p256(proof.evaluations.a)},` +\n    `${p256(proof.evaluations.b)},${p256(proof.evaluations.c)},${p256(proof.evaluations.z)},` +\n    `${p256(proof.evaluations.zw)},${p256(proof.evaluations.t1w)},${p256(proof.evaluations.t2w)},` +\n    `${p256(proof.evaluations.inv)}],` +\n    `[${inputs}]`;\n}\n\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar fflonk = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setup: fflonkSetup,\n    prove: fflonkProve,\n    fullProve: fflonkFullProve,\n    verify: fflonkVerify,\n    exportSolidityVerifier: fflonkExportSolidityVerifier,\n    exportSolidityCallData: fflonkExportCallData\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zbmFya2pzL2J1aWxkL2Jyb3dzZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFzSTs7QUFFdEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hELDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGFBQWE7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx1REFBdUQsVUFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7O0FBRXZCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQU07O0FBRXBDO0FBQ0EsOEJBQThCLGdEQUFNOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCw2REFBNkQ7QUFDN0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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QUFzRDs7QUFFdEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnREFBTTs7QUFFcEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxZQUFZO0FBQ1o7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtC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TTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esb0RBQW9ELFdBQVc7QUFDL0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWSxJQUFJLG1CQUFtQjs7QUFFeEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw2Q0FBNkMsbUNBQW1DO0FBQ2hGLGtEQUFrRCwwQkFBMEI7QUFDNUU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qix3QkFBd0Isa0JBQWtCOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFB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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbURBQVM7QUFDckQsNENBQTRDLG1EQUFTO0FBQ3JELDRDQUE0QyxtREFBUzs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtREFBUztBQUNyRCw0Q0FBNEMsbURBQVM7QUFDckQsNENBQTRDLG1EQUFTO0FBQ3JELDRDQUE0QyxtREFBUztBQUNyRCw0Q0FBNEMsbURBQVM7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QyxpQ0FBaUMsRUFBRTtBQUNuQztBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxtREFBUzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxtREFBUzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBDQUEwQyxFQUFFLCtDQUFLOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVEsMkNBQTJDLEVBQUUsK0NBQUs7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyw2QkFBNkIsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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RUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLDhCQUE4QixJQUFJLDhCQUE4QjtBQUMvRSxPQUFPLDhCQUE4QixHQUFHLDhCQUE4QjtBQUN0RSxPQUFPLDhCQUE4QixHQUFHLDhCQUE4QjtBQUN0RSxPQUFPLDhCQUE4QixHQUFHLDhCQUE4QjtBQUN0RSxPQUFPLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLDJCQUEyQjtBQUM5RixPQUFPLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLDJCQUEyQjtBQUM5RixPQUFPLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLDBCQUEwQjtBQUM3RixPQUFPLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQjtBQUMzRixPQUFPLDJCQUEyQixHQUFHLDRCQUE0QixHQUFHLDRCQUE0QjtBQUNoRyxPQUFPLDRCQUE0QjtBQUNuQyxRQUFRLE9BQU87QUFDZjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUUrRiIsInNvdXJjZXMiOlsiL2hvbWUvbmVvL2dpdC96bmVwMTcvd2ViL25vZGVfbW9kdWxlcy9zbmFya2pzL2J1aWxkL2Jyb3dzZXIuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNjYWxhciwgQmlnQnVmZmVyLCBidWlsZEJuMTI4LCBidWlsZEJsczEyMzgxLCBDaGFDaGEsIEYxRmllbGQsIHV0aWxzLCBnZXRDdXJ2ZUZyb21SIGFzIGdldEN1cnZlRnJvbVIkMSB9IGZyb20gJ2ZmamF2YXNjcmlwdCc7XG5cbnZhciBmcyA9IHt9O1xuXG5hc3luYyBmdW5jdGlvbiBvcGVuKGZpbGVOYW1lLCBvcGVuRmxhZ3MsIGNhY2hlU2l6ZSwgcGFnZVNpemUpIHtcbiAgICBjYWNoZVNpemUgPSBjYWNoZVNpemUgfHwgNDA5Nio2NDtcbiAgICBpZiAodHlwZW9mIG9wZW5GbGFncyAhPT0gXCJudW1iZXJcIiAmJiBbXCJ3K1wiLCBcInd4K1wiLCBcInJcIiwgXCJheCtcIiwgXCJhK1wiXS5pbmRleE9mKG9wZW5GbGFncykgPDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3BlbiBvcHRpb25cIik7XG4gICAgY29uc3QgZmQgPWF3YWl0IGZzLnByb21pc2VzLm9wZW4oZmlsZU5hbWUsIG9wZW5GbGFncyk7XG5cbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZkLnN0YXQoKTtcblxuICAgIHJldHVybiAgbmV3IEZhc3RGaWxlKGZkLCBzdGF0cywgY2FjaGVTaXplLCBwYWdlU2l6ZSwgZmlsZU5hbWUpO1xufVxuXG5cbmNsYXNzIEZhc3RGaWxlIHtcblxuICAgIGNvbnN0cnVjdG9yKGZkLCBzdGF0cywgY2FjaGVTaXplLCBwYWdlU2l6ZSwgZmlsZU5hbWUpIHtcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IGZpbGVOYW1lO1xuICAgICAgICB0aGlzLmZkID0gZmQ7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IHBhZ2VTaXplIHx8ICgxIDw8IDgpO1xuICAgICAgICB3aGlsZSAodGhpcy5wYWdlU2l6ZSA8IHN0YXRzLmJsa3NpemUpIHtcbiAgICAgICAgICAgIHRoaXMucGFnZVNpemUgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFsU2l6ZSA9IHN0YXRzLnNpemU7XG4gICAgICAgIHRoaXMudG90YWxQYWdlcyA9IE1hdGguZmxvb3IoKHN0YXRzLnNpemUgLTEpIC8gdGhpcy5wYWdlU2l6ZSkrMTtcbiAgICAgICAgdGhpcy5tYXhQYWdlc0xvYWRlZCA9IE1hdGguZmxvb3IoIGNhY2hlU2l6ZSAvIHRoaXMucGFnZVNpemUpKzE7XG4gICAgICAgIHRoaXMucGFnZXMgPSB7fTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9hZHMgPSBbXTtcbiAgICAgICAgdGhpcy53cml0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF2QnVmZnMgPSBbXTtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0ge307XG4gICAgfVxuXG4gICAgX2xvYWRQYWdlKHApIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IFAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+IHtcbiAgICAgICAgICAgIHNlbGYucGVuZGluZ0xvYWRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhZ2U6IHAsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICByZWplY3Q6IHJlamVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLl9fc3RhdHVzUGFnZShcIkFmdGVyIExvYWQgcmVxdWVzdDogXCIsIHApO1xuICAgICAgICByZXR1cm4gUDtcbiAgICB9XG5cbiAgICBfX3N0YXR1c1BhZ2UocywgcCkge1xuICAgICAgICBjb25zdCBsb2dFbnRyeSA9IFtdO1xuICAgICAgICBjb25zdCBzZWxmPXRoaXM7XG4gICAgICAgIGlmICghc2VsZi5sb2dIaXN0b3J5KSByZXR1cm47XG4gICAgICAgIGxvZ0VudHJ5LnB1c2goXCI9PVwiICsgcysgXCIgXCIgK3ApO1xuICAgICAgICBsZXQgUyA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxzZWxmLnBlbmRpbmdMb2Fkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNlbGYucGVuZGluZ0xvYWRzW2ldLnBhZ2UgPT0gcCkgUyA9IFMgKyBcIiBcIiArIGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFMpIGxvZ0VudHJ5LnB1c2goXCJQZW5kaW5nIGxvYWRzOlwiK1MpO1xuICAgICAgICBpZiAodHlwZW9mIHNlbGYucGFnZXNbcF0gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IHNlbGYucGFnZXNbcF07XG4gICAgICAgICAgICBsb2dFbnRyeS5wdXNoKFwiTG9hZGVkXCIpO1xuICAgICAgICAgICAgbG9nRW50cnkucHVzaChcInBlbmRpbmdPcHM6IFwiK3BhZ2UucGVuZGluZ09wcyk7XG4gICAgICAgICAgICBpZiAocGFnZS5sb2FkaW5nKSBsb2dFbnRyeS5wdXNoKFwibG9hZGluZzogXCIrcGFnZS5sb2FkaW5nKTtcbiAgICAgICAgICAgIGlmIChwYWdlLndyaXRpbmcpIGxvZ0VudHJ5LnB1c2goXCJ3cml0aW5nXCIpO1xuICAgICAgICAgICAgaWYgKHBhZ2UuZGlydHkpIGxvZ0VudHJ5LnB1c2goXCJkaXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dFbnRyeS5wdXNoKFwiPT1cIik7XG5cbiAgICAgICAgaWYgKCFzZWxmLmhpc3RvcnlbcF0pIHNlbGYuaGlzdG9yeVtwXSA9IFtdO1xuICAgICAgICBzZWxmLmhpc3RvcnlbcF0ucHVzaChsb2dFbnRyeSk7XG4gICAgfVxuXG4gICAgX19wcmludEhpc3RvcnkocCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmhpc3RvcnlbcF0pIGNvbnNvbGUubG9nKFwiRW1wdHkgSGlzdG9yeSBcIiwgcCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSGlzdG9yeSBcIitwKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHNlbGYuaGlzdG9yeVtwXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHNlbGYuaGlzdG9yeVtwXVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLT4gXCIgKyBzZWxmLmhpc3RvcnlbcF1baV1bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cblxuICAgIF90cmlnZ2VyTG9hZCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHNlbGYucmVhZGluZykgcmV0dXJuO1xuICAgICAgICBpZiAoc2VsZi5wZW5kaW5nTG9hZHMubGVuZ3RoPT0wKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgcGFnZUlkeHMgPSBPYmplY3Qua2V5cyhzZWxmLnBhZ2VzKTtcblxuICAgICAgICBjb25zdCBkZWxldGFibGVQYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGFnZUlkeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBzZWxmLnBhZ2VzW3BhcnNlSW50KHBhZ2VJZHhzW2ldKV07XG4gICAgICAgICAgICBpZiAoKHBhZ2UuZGlydHkgPT0gZmFsc2UpJiYocGFnZS5wZW5kaW5nT3BzPT0wKSYmKCFwYWdlLndyaXRpbmcpJiYoIXBhZ2UubG9hZGluZykpIGRlbGV0YWJsZVBhZ2VzLnB1c2gocGFyc2VJbnQocGFnZUlkeHNbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmcmVlUGFnZXMgPSBzZWxmLm1heFBhZ2VzTG9hZGVkIC0gcGFnZUlkeHMubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuXG4gICAgICAgIC8vIHdoaWxlIHBlbmRpbmcgbG9hZHMgYW5kXG4gICAgICAgIC8vICAgICB0aGUgcGFnZSBpcyBsb2FkZWQgb3IgSSBjYW4gcmVjb3ZlciBvbmUuXG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgIChzZWxmLnBlbmRpbmdMb2Fkcy5sZW5ndGg+MCkgJiZcbiAgICAgICAgICAgICggICAodHlwZW9mIHNlbGYucGFnZXNbc2VsZi5wZW5kaW5nTG9hZHNbMF0ucGFnZV0gIT0gXCJ1bmRlZmluZWRcIiApXG4gICAgICAgICAgICAgIHx8KCAgKGZyZWVQYWdlcz4wKVxuICAgICAgICAgICAgICAgICB8fChkZWxldGFibGVQYWdlcy5sZW5ndGg+MCkpKSkge1xuICAgICAgICAgICAgY29uc3QgbG9hZCA9IHNlbGYucGVuZGluZ0xvYWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYucGFnZXNbbG9hZC5wYWdlXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wYWdlc1tsb2FkLnBhZ2VdLnBlbmRpbmdPcHMgKys7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gZGVsZXRhYmxlUGFnZXMuaW5kZXhPZihsb2FkLnBhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChpZHg+PTApIGRlbGV0YWJsZVBhZ2VzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnBhZ2VzW2xvYWQucGFnZV0ubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhZ2VzW2xvYWQucGFnZV0ubG9hZGluZy5wdXNoKGxvYWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLl9fc3RhdHVzUGFnZShcIkFmdGVyIExvYWQgKGNhY2hlZCk6IFwiLCBsb2FkLnBhZ2UpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmcmVlUGFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJlZVBhZ2VzLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnAgPSBkZWxldGFibGVQYWdlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9fc3RhdHVzUGFnZShcIkJlZm9yZSBVbmxvYWQ6IFwiLCBmcCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXZCdWZmcy51bnNoaWZ0KHNlbGYucGFnZXNbZnBdKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYucGFnZXNbZnBdO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9fc3RhdHVzUGFnZShcIkFmdGVyIFVubG9hZDogXCIsIGZwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobG9hZC5wYWdlPj1zZWxmLnRvdGFsUGFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWdlc1tsb2FkLnBhZ2VdID0gZ2V0TmV3UGFnZSgpO1xuICAgICAgICAgICAgICAgICAgICBsb2FkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fX3N0YXR1c1BhZ2UoXCJBZnRlciBMb2FkIChuZXcpOiBcIiwgbG9hZC5wYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhZ2VzW2xvYWQucGFnZV0gPSBnZXROZXdQYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFnZXNbbG9hZC5wYWdlXS5sb2FkaW5nID0gW2xvYWRdO1xuICAgICAgICAgICAgICAgICAgICBvcHMucHVzaChzZWxmLmZkLnJlYWQoc2VsZi5wYWdlc1tsb2FkLnBhZ2VdLmJ1ZmYsIDAsIHNlbGYucGFnZVNpemUsIGxvYWQucGFnZSpzZWxmLnBhZ2VTaXplKS50aGVuKChyZXMpPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWdlc1tsb2FkLnBhZ2VdLnNpemUgPSByZXMuYnl0ZXNSZWFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9hZGluZyA9IHNlbGYucGFnZXNbbG9hZC5wYWdlXS5sb2FkaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYucGFnZXNbbG9hZC5wYWdlXS5sb2FkaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGxvYWRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nW2ldLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19zdGF0dXNQYWdlKFwiQWZ0ZXIgTG9hZCAobG9hZGVkKTogXCIsIGxvYWQucGFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX19zdGF0dXNQYWdlKFwiQWZ0ZXIgTG9hZCAobG9hZGluZyk6IFwiLCBsb2FkLnBhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAob3BzLmxlbmd0aD4xKSBjb25zb2xlLmxvZyhvcHMubGVuZ3RoKTtcblxuICAgICAgICBQcm9taXNlLmFsbChvcHMpLnRoZW4oICgpID0+IHtcbiAgICAgICAgICAgIHNlbGYucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbGYucGVuZGluZ0xvYWRzLmxlbmd0aD4wKSBzZXRJbW1lZGlhdGUoc2VsZi5fdHJpZ2dlckxvYWQuYmluZChzZWxmKSk7XG4gICAgICAgICAgICBzZWxmLl90cnlDbG9zZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBnZXROZXdQYWdlKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuYXZCdWZmcy5sZW5ndGg+MCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBzZWxmLmF2QnVmZnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBwLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcC5wZW5kaW5nT3BzID0gMTtcbiAgICAgICAgICAgICAgICBwLnNpemUgPTA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYnVmZjogbmV3IFVpbnQ4QXJyYXkoc2VsZi5wYWdlU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdPcHM6IDEsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIF90cmlnZ2VyV3JpdGUoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi53cml0aW5nKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgcGFnZUlkeHMgPSBPYmplY3Qua2V5cyhzZWxmLnBhZ2VzKTtcblxuICAgICAgICBjb25zdCBvcHMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGFnZUlkeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBzZWxmLnBhZ2VzW3BhcnNlSW50KHBhZ2VJZHhzW2ldKV07XG4gICAgICAgICAgICBpZiAocGFnZS5kaXJ0eSkge1xuICAgICAgICAgICAgICAgIHBhZ2UuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwYWdlLndyaXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYud3JpdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goIHNlbGYuZmQud3JpdGUocGFnZS5idWZmLCAwLCBwYWdlLnNpemUsIHBhcnNlSW50KHBhZ2VJZHhzW2ldKSpzZWxmLnBhZ2VTaXplKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZS53cml0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1IgV3JpdGluZzogXCIrZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdHJ5Q2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi53cml0aW5nKSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChvcHMpLnRoZW4oICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLndyaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoc2VsZi5fdHJpZ2dlcldyaXRlLmJpbmQoc2VsZikpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3RyeUNsb3NlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucGVuZGluZ0xvYWRzLmxlbmd0aD4wKSBzZXRJbW1lZGlhdGUoc2VsZi5fdHJpZ2dlckxvYWQuYmluZChzZWxmKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXREaXJ0eVBhZ2UoKSB7XG4gICAgICAgIGZvciAobGV0IHAgaW4gdGhpcy5wYWdlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFnZXNbcF0uZGlydHkpIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBhc3luYyB3cml0ZShidWZmLCBwb3MpIHtcbiAgICAgICAgaWYgKGJ1ZmYuYnl0ZUxlbmd0aCA9PSAwKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuLypcbiAgICAgICAgaWYgKGJ1ZmYuYnl0ZUxlbmd0aCA+IHNlbGYucGFnZVNpemUqc2VsZi5tYXhQYWdlc0xvYWRlZCowLjgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlU2l6ZSA9IE1hdGguZmxvb3IoYnVmZi5ieXRlTGVuZ3RoICogMS4xKTtcbiAgICAgICAgICAgIHRoaXMubWF4UGFnZXNMb2FkZWQgPSBNYXRoLmZsb29yKCBjYWNoZVNpemUgLyBzZWxmLnBhZ2VTaXplKSsxO1xuICAgICAgICB9XG4qL1xuICAgICAgICBpZiAodHlwZW9mIHBvcyA9PSBcInVuZGVmaW5lZFwiKSBwb3MgPSBzZWxmLnBvcztcbiAgICAgICAgc2VsZi5wb3MgPSBwb3MrYnVmZi5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAoc2VsZi50b3RhbFNpemUgPCBwb3MgKyBidWZmLmJ5dGVMZW5ndGgpIHNlbGYudG90YWxTaXplID0gcG9zICsgYnVmZi5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAoc2VsZi5wZW5kaW5nQ2xvc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcml0aW5nIGEgY2xvc2luZyBmaWxlXCIpO1xuICAgICAgICBjb25zdCBmaXJzdFBhZ2UgPSBNYXRoLmZsb29yKHBvcyAvIHNlbGYucGFnZVNpemUpO1xuICAgICAgICBjb25zdCBsYXN0UGFnZSA9IE1hdGguZmxvb3IoKHBvcyArIGJ1ZmYuYnl0ZUxlbmd0aCAtMSkgLyBzZWxmLnBhZ2VTaXplKTtcblxuICAgICAgICBjb25zdCBwYWdlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT1maXJzdFBhZ2U7IGk8PWxhc3RQYWdlOyBpKyspIHBhZ2VQcm9taXNlcy5wdXNoKHNlbGYuX2xvYWRQYWdlKGkpKTtcbiAgICAgICAgc2VsZi5fdHJpZ2dlckxvYWQoKTtcblxuICAgICAgICBsZXQgcCA9IGZpcnN0UGFnZTtcbiAgICAgICAgbGV0IG8gPSBwb3MgJSBzZWxmLnBhZ2VTaXplO1xuICAgICAgICBsZXQgciA9IGJ1ZmYuYnl0ZUxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHI+MCkge1xuICAgICAgICAgICAgYXdhaXQgcGFnZVByb21pc2VzW3AtZmlyc3RQYWdlXTtcbiAgICAgICAgICAgIGNvbnN0IGwgPSAobytyID4gc2VsZi5wYWdlU2l6ZSkgPyAoc2VsZi5wYWdlU2l6ZSAtbykgOiByO1xuICAgICAgICAgICAgY29uc3Qgc3JjVmlldyA9IGJ1ZmYuc2xpY2UoIGJ1ZmYuYnl0ZUxlbmd0aCAtIHIsIGJ1ZmYuYnl0ZUxlbmd0aCAtIHIgKyBsKTtcbiAgICAgICAgICAgIGNvbnN0IGRzdFZpZXcgPSBuZXcgVWludDhBcnJheShzZWxmLnBhZ2VzW3BdLmJ1ZmYuYnVmZmVyLCBvLCBsKTtcbiAgICAgICAgICAgIGRzdFZpZXcuc2V0KHNyY1ZpZXcpO1xuICAgICAgICAgICAgc2VsZi5wYWdlc1twXS5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLnBhZ2VzW3BdLnBlbmRpbmdPcHMgLS07XG4gICAgICAgICAgICBzZWxmLnBhZ2VzW3BdLnNpemUgPSBNYXRoLm1heChvK2wsIHNlbGYucGFnZXNbcF0uc2l6ZSk7XG4gICAgICAgICAgICBpZiAocD49c2VsZi50b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50b3RhbFBhZ2VzID0gcCsxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgciA9IHItbDtcbiAgICAgICAgICAgIHAgKys7XG4gICAgICAgICAgICBvID0gMDtcbiAgICAgICAgICAgIGlmICghc2VsZi53cml0aW5nKSBzZXRJbW1lZGlhdGUoc2VsZi5fdHJpZ2dlcldyaXRlLmJpbmQoc2VsZikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZChsZW4sIHBvcykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBhd2FpdCBzZWxmLnJlYWRUb0J1ZmZlcihidWZmLCAwLCBsZW4sIHBvcyk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZFRvQnVmZmVyKGJ1ZmZEc3QsIG9mZnNldCwgbGVuLCBwb3MpIHtcbiAgICAgICAgaWYgKGxlbiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChsZW4gPiBzZWxmLnBhZ2VTaXplKnNlbGYubWF4UGFnZXNMb2FkZWQqMC44KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZVNpemUgPSBNYXRoLmZsb29yKGxlbiAqIDEuMSk7XG4gICAgICAgICAgICB0aGlzLm1heFBhZ2VzTG9hZGVkID0gTWF0aC5mbG9vciggY2FjaGVTaXplIC8gc2VsZi5wYWdlU2l6ZSkrMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBvcyA9PSBcInVuZGVmaW5lZFwiKSBwb3MgPSBzZWxmLnBvcztcbiAgICAgICAgc2VsZi5wb3MgPSBwb3MrbGVuO1xuICAgICAgICBpZiAoc2VsZi5wZW5kaW5nQ2xvc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkaW5nIGEgY2xvc2luZyBmaWxlXCIpO1xuICAgICAgICBjb25zdCBmaXJzdFBhZ2UgPSBNYXRoLmZsb29yKHBvcyAvIHNlbGYucGFnZVNpemUpO1xuICAgICAgICBjb25zdCBsYXN0UGFnZSA9IE1hdGguZmxvb3IoKHBvcyArIGxlbiAtMSkgLyBzZWxmLnBhZ2VTaXplKTtcblxuICAgICAgICBjb25zdCBwYWdlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT1maXJzdFBhZ2U7IGk8PWxhc3RQYWdlOyBpKyspIHBhZ2VQcm9taXNlcy5wdXNoKHNlbGYuX2xvYWRQYWdlKGkpKTtcblxuICAgICAgICBzZWxmLl90cmlnZ2VyTG9hZCgpO1xuXG4gICAgICAgIGxldCBwID0gZmlyc3RQYWdlO1xuICAgICAgICBsZXQgbyA9IHBvcyAlIHNlbGYucGFnZVNpemU7XG4gICAgICAgIC8vIFJlbWFpbmluZyBieXRlcyB0byByZWFkXG4gICAgICAgIGxldCByID0gcG9zICsgbGVuID4gc2VsZi50b3RhbFNpemUgPyBsZW4gLSAocG9zICsgbGVuIC0gc2VsZi50b3RhbFNpemUpOiBsZW47XG4gICAgICAgIHdoaWxlIChyPjApIHtcbiAgICAgICAgICAgIGF3YWl0IHBhZ2VQcm9taXNlc1twIC0gZmlyc3RQYWdlXTtcbiAgICAgICAgICAgIHNlbGYuX19zdGF0dXNQYWdlKFwiQWZ0ZXIgQXdhaXQgKHJlYWQpOiBcIiwgcCk7XG5cbiAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGNvcHkgZnJvbSB0aGlzIHBhZ2VcbiAgICAgICAgICAgIGNvbnN0IGwgPSAobytyID4gc2VsZi5wYWdlU2l6ZSkgPyAoc2VsZi5wYWdlU2l6ZSAtbykgOiByO1xuICAgICAgICAgICAgY29uc3Qgc3JjVmlldyA9IG5ldyBVaW50OEFycmF5KHNlbGYucGFnZXNbcF0uYnVmZi5idWZmZXIsIHNlbGYucGFnZXNbcF0uYnVmZi5ieXRlT2Zmc2V0ICsgbywgbCk7XG4gICAgICAgICAgICBidWZmRHN0LnNldChzcmNWaWV3LCBvZmZzZXQrbGVuLXIpO1xuICAgICAgICAgICAgc2VsZi5wYWdlc1twXS5wZW5kaW5nT3BzIC0tO1xuXG4gICAgICAgICAgICBzZWxmLl9fc3RhdHVzUGFnZShcIkFmdGVyIE9wIGRvbmU6IFwiLCBwKTtcblxuICAgICAgICAgICAgciA9IHItbDtcbiAgICAgICAgICAgIHAgKys7XG4gICAgICAgICAgICBvID0gMDtcbiAgICAgICAgICAgIGlmIChzZWxmLnBlbmRpbmdMb2Fkcy5sZW5ndGg+MCkgc2V0SW1tZWRpYXRlKHNlbGYuX3RyaWdnZXJMb2FkLmJpbmQoc2VsZikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb3MgPSBwb3MgKyBsZW47XG5cbiAgICB9XG5cblxuICAgIF90cnlDbG9zZSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5wZW5kaW5nQ2xvc2UpIHJldHVybjtcbiAgICAgICAgaWYgKHNlbGYuZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYucGVuZGluZ0Nsb3NlUmVqZWN0KHNlbGYuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSBzZWxmLl9nZXREaXJ0eVBhZ2UoKTtcbiAgICAgICAgaWYgKChwPj0wKSB8fCAoc2VsZi53cml0aW5nKSB8fCAoc2VsZi5yZWFkaW5nKSB8fCAoc2VsZi5wZW5kaW5nTG9hZHMubGVuZ3RoPjApKSByZXR1cm47XG4gICAgICAgIHNlbGYucGVuZGluZ0Nsb3NlKCk7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5wZW5kaW5nQ2xvc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbG9zaW5nIHRoZSBmaWxlIHR3aWNlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5wZW5kaW5nQ2xvc2UgPSByZXNvbHZlO1xuICAgICAgICAgICAgc2VsZi5wZW5kaW5nQ2xvc2VSZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICBzZWxmLl90cnlDbG9zZSgpO1xuICAgICAgICB9KS50aGVuKCgpPT4ge1xuICAgICAgICAgICAgc2VsZi5mZC5jbG9zZSgpO1xuICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBzZWxmLmZkLmNsb3NlKCk7XG4gICAgICAgICAgICB0aHJvdyAoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzY2FyZCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGF3YWl0IHNlbGYuY2xvc2UoKTtcbiAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMudW5saW5rKHRoaXMuZmlsZU5hbWUpO1xuICAgIH1cblxuICAgIGFzeW5jIHdyaXRlVUxFMzIodiwgcG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCB0bXBCdWZmMzIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgdG1wQnVmZjMydiA9IG5ldyBEYXRhVmlldyh0bXBCdWZmMzIuYnVmZmVyKTtcblxuICAgICAgICB0bXBCdWZmMzJ2LnNldFVpbnQzMigwLCB2LCB0cnVlKTtcblxuICAgICAgICBhd2FpdCBzZWxmLndyaXRlKHRtcEJ1ZmYzMiwgcG9zKTtcbiAgICB9XG5cbiAgICBhc3luYyB3cml0ZVVCRTMyKHYsIHBvcykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICBjb25zdCB0bXBCdWZmMzIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgdG1wQnVmZjMydiA9IG5ldyBEYXRhVmlldyh0bXBCdWZmMzIuYnVmZmVyKTtcblxuICAgICAgICB0bXBCdWZmMzJ2LnNldFVpbnQzMigwLCB2LCBmYWxzZSk7XG5cbiAgICAgICAgYXdhaXQgc2VsZi53cml0ZSh0bXBCdWZmMzIsIHBvcyk7XG4gICAgfVxuXG5cbiAgICBhc3luYyB3cml0ZVVMRTY0KHYsIHBvcykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICBjb25zdCB0bXBCdWZmNjQgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICAgICAgY29uc3QgdG1wQnVmZjY0diA9IG5ldyBEYXRhVmlldyh0bXBCdWZmNjQuYnVmZmVyKTtcblxuICAgICAgICB0bXBCdWZmNjR2LnNldFVpbnQzMigwLCB2ICYgMHhGRkZGRkZGRiwgdHJ1ZSk7XG4gICAgICAgIHRtcEJ1ZmY2NHYuc2V0VWludDMyKDQsIE1hdGguZmxvb3IodiAvIDB4MTAwMDAwMDAwKSAsIHRydWUpO1xuXG4gICAgICAgIGF3YWl0IHNlbGYud3JpdGUodG1wQnVmZjY0LCBwb3MpO1xuICAgIH1cblxuICAgIGFzeW5jIHJlYWRVTEUzMihwb3MpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGIgPSBhd2FpdCBzZWxmLnJlYWQoNCwgcG9zKTtcblxuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQzMkFycmF5KGIuYnVmZmVyKTtcblxuICAgICAgICByZXR1cm4gdmlld1swXTtcbiAgICB9XG5cbiAgICBhc3luYyByZWFkVUJFMzIocG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBiID0gYXdhaXQgc2VsZi5yZWFkKDQsIHBvcyk7XG5cbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhiLmJ1ZmZlcik7XG5cbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDMyKDAsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBhc3luYyByZWFkVUxFNjQocG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBiID0gYXdhaXQgc2VsZi5yZWFkKDgsIHBvcyk7XG5cbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50MzJBcnJheShiLmJ1ZmZlcik7XG5cbiAgICAgICAgcmV0dXJuIHZpZXdbMV0gKiAweDEwMDAwMDAwMCArIHZpZXdbMF07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZFN0cmluZyhwb3MpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHNlbGYucGVuZGluZ0Nsb3NlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkaW5nIGEgY2xvc2luZyBmaWxlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IHR5cGVvZiBwb3MgPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYucG9zIDogcG9zO1xuICAgICAgICBsZXQgY3VycmVudFBhZ2UgPSBNYXRoLmZsb29yKGN1cnJlbnRQb3NpdGlvbiAvIHNlbGYucGFnZVNpemUpO1xuXG4gICAgICAgIGxldCBlbmRPZlN0cmluZ0ZvdW5kID0gZmFsc2U7XG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuXG4gICAgICAgIHdoaWxlICghZW5kT2ZTdHJpbmdGb3VuZCkge1xuICAgICAgICAgICAgLy9SZWFkIHBhZ2VcbiAgICAgICAgICAgIGxldCBwYWdlUHJvbWlzZSA9IHNlbGYuX2xvYWRQYWdlKGN1cnJlbnRQYWdlKTtcbiAgICAgICAgICAgIHNlbGYuX3RyaWdnZXJMb2FkKCk7XG4gICAgICAgICAgICBhd2FpdCBwYWdlUHJvbWlzZTtcbiAgICAgICAgICAgIHNlbGYuX19zdGF0dXNQYWdlKFwiQWZ0ZXIgQXdhaXQgKHJlYWQpOiBcIiwgY3VycmVudFBhZ2UpO1xuXG4gICAgICAgICAgICBsZXQgb2Zmc2V0T25QYWdlID0gY3VycmVudFBvc2l0aW9uICUgc2VsZi5wYWdlU2l6ZTtcblxuICAgICAgICAgICAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgc2VsZi5wYWdlc1tjdXJyZW50UGFnZV0uYnVmZi5idWZmZXIsXG4gICAgICAgICAgICAgICAgc2VsZi5wYWdlc1tjdXJyZW50UGFnZV0uYnVmZi5ieXRlT2Zmc2V0ICsgb2Zmc2V0T25QYWdlLFxuICAgICAgICAgICAgICAgIHNlbGYucGFnZVNpemUgLSBvZmZzZXRPblBhZ2VcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxldCBpbmRleEVuZE9mU3RyaW5nID0gZGF0YUFycmF5LmZpbmRJbmRleChlbGVtZW50ID0+IGVsZW1lbnQgPT09IDApO1xuICAgICAgICAgICAgZW5kT2ZTdHJpbmdGb3VuZCA9IGluZGV4RW5kT2ZTdHJpbmcgIT09IC0xO1xuXG4gICAgICAgICAgICBpZiAoZW5kT2ZTdHJpbmdGb3VuZCkge1xuICAgICAgICAgICAgICAgIHN0ciArPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YUFycmF5LnNsaWNlKDAsIGluZGV4RW5kT2ZTdHJpbmcpKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBvcyA9IGN1cnJlbnRQYWdlICogdGhpcy5wYWdlU2l6ZSArIG9mZnNldE9uUGFnZSArIGluZGV4RW5kT2ZTdHJpbmcgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGFBcnJheSk7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3MgPSBjdXJyZW50UGFnZSAqIHRoaXMucGFnZVNpemUgKyBvZmZzZXRPblBhZ2UgKyBkYXRhQXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnBhZ2VzW2N1cnJlbnRQYWdlXS5wZW5kaW5nT3BzLS07XG4gICAgICAgICAgICBzZWxmLl9fc3RhdHVzUGFnZShcIkFmdGVyIE9wIGRvbmU6IFwiLCBjdXJyZW50UGFnZSk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IHNlbGYucG9zO1xuICAgICAgICAgICAgY3VycmVudFBhZ2UrKztcblxuICAgICAgICAgICAgaWYgKHNlbGYucGVuZGluZ0xvYWRzLmxlbmd0aCA+IDApIHNldEltbWVkaWF0ZShzZWxmLl90cmlnZ2VyTG9hZC5iaW5kKHNlbGYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOZXckMShvKSB7XG4gICAgY29uc3QgaW5pdGlhbFNpemUgPSBvLmluaXRpYWxTaXplIHx8IDE8PDIwO1xuICAgIGNvbnN0IGZkID0gbmV3IE1lbUZpbGUoKTtcbiAgICBmZC5vID0gbztcbiAgICBmZC5vLmRhdGEgPSBuZXcgVWludDhBcnJheShpbml0aWFsU2l6ZSk7XG4gICAgZmQuYWxsb2NTaXplID0gaW5pdGlhbFNpemU7XG4gICAgZmQudG90YWxTaXplID0gMDtcbiAgICBmZC5yZWFkT25seSA9IGZhbHNlO1xuICAgIGZkLnBvcyA9IDA7XG4gICAgcmV0dXJuIGZkO1xufVxuXG5mdW5jdGlvbiByZWFkRXhpc3RpbmckMihvKSB7XG4gICAgY29uc3QgZmQgPSBuZXcgTWVtRmlsZSgpO1xuICAgIGZkLm8gPSBvO1xuICAgIGZkLmFsbG9jU2l6ZSA9IG8uZGF0YS5ieXRlTGVuZ3RoO1xuICAgIGZkLnRvdGFsU2l6ZSA9IG8uZGF0YS5ieXRlTGVuZ3RoO1xuICAgIGZkLnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICBmZC5wb3MgPSAwO1xuICAgIHJldHVybiBmZDtcbn1cblxuY29uc3QgdG1wQnVmZjMyJDEgPSBuZXcgVWludDhBcnJheSg0KTtcbmNvbnN0IHRtcEJ1ZmYzMnYkMSA9IG5ldyBEYXRhVmlldyh0bXBCdWZmMzIkMS5idWZmZXIpO1xuY29uc3QgdG1wQnVmZjY0JDEgPSBuZXcgVWludDhBcnJheSg4KTtcbmNvbnN0IHRtcEJ1ZmY2NHYkMSA9IG5ldyBEYXRhVmlldyh0bXBCdWZmNjQkMS5idWZmZXIpO1xuXG5jbGFzcyBNZW1GaWxlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gMSA8PCAxNDsgIC8vIGZvciBjb21wYXRpYmlsaXR5XG4gICAgfVxuXG4gICAgX3Jlc2l6ZUlmTmVlZGVkKG5ld0xlbikge1xuICAgICAgICBpZiAobmV3TGVuID4gdGhpcy5hbGxvY1NpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FsbG9jU2l6ZSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIHRoaXMuYWxsb2NTaXplICsgKDEgPDwgMjApLFxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5hbGxvY1NpemUgKiAxLjEpLFxuICAgICAgICAgICAgICAgIG5ld0xlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdBbGxvY1NpemUpO1xuICAgICAgICAgICAgbmV3RGF0YS5zZXQodGhpcy5vLmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5vLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICAgICAgdGhpcy5hbGxvY1NpemUgPSBuZXdBbGxvY1NpemU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB3cml0ZShidWZmLCBwb3MpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9dGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBwb3MgPT0gXCJ1bmRlZmluZWRcIikgcG9zID0gc2VsZi5wb3M7XG4gICAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB0aHJvdyBuZXcgRXJyb3IoXCJXcml0aW5nIGEgcmVhZCBvbmx5IGZpbGVcIik7XG5cbiAgICAgICAgdGhpcy5fcmVzaXplSWZOZWVkZWQocG9zICsgYnVmZi5ieXRlTGVuZ3RoKTtcblxuICAgICAgICB0aGlzLm8uZGF0YS5zZXQoYnVmZi5zbGljZSgpLCBwb3MpO1xuXG4gICAgICAgIGlmIChwb3MgKyBidWZmLmJ5dGVMZW5ndGggPiB0aGlzLnRvdGFsU2l6ZSkgdGhpcy50b3RhbFNpemUgPSBwb3MgKyBidWZmLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgdGhpcy5wb3MgPSBwb3MgKyBidWZmLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZFRvQnVmZmVyKGJ1ZmZEZXN0LCBvZmZzZXQsIGxlbiwgcG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHBvcyA9PSBcInVuZGVmaW5lZFwiKSBwb3MgPSBzZWxmLnBvcztcbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGlmIChwb3MgKyBsZW4gPiB0aGlzLnRvdGFsU2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwiUmVhZGluZyBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUlmTmVlZGVkKHBvcyArIGxlbik7XG5cbiAgICAgICAgY29uc3QgYnVmZlNyYyA9IG5ldyBVaW50OEFycmF5KHRoaXMuby5kYXRhLmJ1ZmZlciwgdGhpcy5vLmRhdGEuYnl0ZU9mZnNldCArIHBvcywgbGVuKTtcblxuICAgICAgICBidWZmRGVzdC5zZXQoYnVmZlNyYywgb2Zmc2V0KTtcblxuICAgICAgICB0aGlzLnBvcyA9IHBvcyArIGxlbjtcbiAgICB9XG5cbiAgICBhc3luYyByZWFkKGxlbiwgcG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBhd2FpdCBzZWxmLnJlYWRUb0J1ZmZlcihidWZmLCAwLCBsZW4sIHBvcyk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLm8uZGF0YS5ieXRlTGVuZ3RoICE9IHRoaXMudG90YWxTaXplKSB7XG4gICAgICAgICAgICB0aGlzLm8uZGF0YSA9IHRoaXMuby5kYXRhLnNsaWNlKDAsIHRoaXMudG90YWxTaXplKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGRpc2NhcmQoKSB7XG4gICAgfVxuXG5cbiAgICBhc3luYyB3cml0ZVVMRTMyKHYsIHBvcykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICB0bXBCdWZmMzJ2JDEuc2V0VWludDMyKDAsIHYsIHRydWUpO1xuXG4gICAgICAgIGF3YWl0IHNlbGYud3JpdGUodG1wQnVmZjMyJDEsIHBvcyk7XG4gICAgfVxuXG4gICAgYXN5bmMgd3JpdGVVQkUzMih2LCBwb3MpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdG1wQnVmZjMydiQxLnNldFVpbnQzMigwLCB2LCBmYWxzZSk7XG5cbiAgICAgICAgYXdhaXQgc2VsZi53cml0ZSh0bXBCdWZmMzIkMSwgcG9zKTtcbiAgICB9XG5cblxuICAgIGFzeW5jIHdyaXRlVUxFNjQodiwgcG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRtcEJ1ZmY2NHYkMS5zZXRVaW50MzIoMCwgdiAmIDB4RkZGRkZGRkYsIHRydWUpO1xuICAgICAgICB0bXBCdWZmNjR2JDEuc2V0VWludDMyKDQsIE1hdGguZmxvb3IodiAvIDB4MTAwMDAwMDAwKSAsIHRydWUpO1xuXG4gICAgICAgIGF3YWl0IHNlbGYud3JpdGUodG1wQnVmZjY0JDEsIHBvcyk7XG4gICAgfVxuXG5cbiAgICBhc3luYyByZWFkVUxFMzIocG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBiID0gYXdhaXQgc2VsZi5yZWFkKDQsIHBvcyk7XG5cbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50MzJBcnJheShiLmJ1ZmZlcik7XG5cbiAgICAgICAgcmV0dXJuIHZpZXdbMF07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZFVCRTMyKHBvcykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgYiA9IGF3YWl0IHNlbGYucmVhZCg0LCBwb3MpO1xuXG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYi5idWZmZXIpO1xuXG4gICAgICAgIHJldHVybiB2aWV3LmdldFVpbnQzMigwLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZFVMRTY0KHBvcykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgYiA9IGF3YWl0IHNlbGYucmVhZCg4LCBwb3MpO1xuXG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDMyQXJyYXkoYi5idWZmZXIpO1xuXG4gICAgICAgIHJldHVybiB2aWV3WzFdICogMHgxMDAwMDAwMDAgKyB2aWV3WzBdO1xuICAgIH1cblxuICAgIGFzeW5jIHJlYWRTdHJpbmcocG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSB0eXBlb2YgcG9zID09IFwidW5kZWZpbmVkXCIgPyBzZWxmLnBvcyA6IHBvcztcblxuICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uID4gdGhpcy50b3RhbFNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhZGluZyBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVzaXplSWZOZWVkZWQocG9zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgIHNlbGYuby5kYXRhLmJ1ZmZlcixcbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbixcbiAgICAgICAgICAgIHRoaXMudG90YWxTaXplIC0gY3VycmVudFBvc2l0aW9uXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IGluZGV4RW5kT2ZTdHJpbmcgPSBkYXRhQXJyYXkuZmluZEluZGV4KGVsZW1lbnQgPT4gZWxlbWVudCA9PT0gMCk7XG4gICAgICAgIGxldCBlbmRPZlN0cmluZ0ZvdW5kID0gaW5kZXhFbmRPZlN0cmluZyAhPT0gLTE7XG5cbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgIGlmIChlbmRPZlN0cmluZ0ZvdW5kKSB7XG4gICAgICAgICAgICBzdHIgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YUFycmF5LnNsaWNlKDAsIGluZGV4RW5kT2ZTdHJpbmcpKTtcbiAgICAgICAgICAgIHNlbGYucG9zID0gY3VycmVudFBvc2l0aW9uICsgaW5kZXhFbmRPZlN0cmluZyArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnBvcyA9IGN1cnJlbnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn1cblxuY29uc3QgUEFHRV9TSVpFID0gMTw8MjI7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ldyhvKSB7XG4gICAgY29uc3QgaW5pdGlhbFNpemUgPSBvLmluaXRpYWxTaXplIHx8IDA7XG4gICAgY29uc3QgZmQgPSBuZXcgQmlnTWVtRmlsZSgpO1xuICAgIGZkLm8gPSBvO1xuICAgIGNvbnN0IG5QYWdlcyA9IGluaXRpYWxTaXplID8gTWF0aC5mbG9vcigoaW5pdGlhbFNpemUgLSAxKSAvIFBBR0VfU0laRSkrMSA6IDA7XG4gICAgZmQuby5kYXRhID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5QYWdlcy0xOyBpKyspIHtcbiAgICAgICAgZmQuby5kYXRhLnB1c2goIG5ldyBVaW50OEFycmF5KFBBR0VfU0laRSkpO1xuICAgIH1cbiAgICBpZiAoblBhZ2VzKSBmZC5vLmRhdGEucHVzaCggbmV3IFVpbnQ4QXJyYXkoaW5pdGlhbFNpemUgLSBQQUdFX1NJWkUqKG5QYWdlcy0xKSkpO1xuICAgIGZkLnRvdGFsU2l6ZSA9IDA7XG4gICAgZmQucmVhZE9ubHkgPSBmYWxzZTtcbiAgICBmZC5wb3MgPSAwO1xuICAgIHJldHVybiBmZDtcbn1cblxuZnVuY3Rpb24gcmVhZEV4aXN0aW5nJDEobykge1xuICAgIGNvbnN0IGZkID0gbmV3IEJpZ01lbUZpbGUoKTtcbiAgICBmZC5vID0gbztcbiAgICBmZC50b3RhbFNpemUgPSAoby5kYXRhLmxlbmd0aC0xKSogUEFHRV9TSVpFICsgby5kYXRhW28uZGF0YS5sZW5ndGgtMV0uYnl0ZUxlbmd0aDtcbiAgICBmZC5yZWFkT25seSA9IHRydWU7XG4gICAgZmQucG9zID0gMDtcbiAgICByZXR1cm4gZmQ7XG59XG5cbmNvbnN0IHRtcEJ1ZmYzMiA9IG5ldyBVaW50OEFycmF5KDQpO1xuY29uc3QgdG1wQnVmZjMydiA9IG5ldyBEYXRhVmlldyh0bXBCdWZmMzIuYnVmZmVyKTtcbmNvbnN0IHRtcEJ1ZmY2NCA9IG5ldyBVaW50OEFycmF5KDgpO1xuY29uc3QgdG1wQnVmZjY0diA9IG5ldyBEYXRhVmlldyh0bXBCdWZmNjQuYnVmZmVyKTtcblxuY2xhc3MgQmlnTWVtRmlsZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IDEgPDwgMTQ7ICAvLyBmb3IgY29tcGF0aWJpbGl0eVxuICAgIH1cblxuICAgIF9yZXNpemVJZk5lZWRlZChuZXdMZW4pIHtcblxuICAgICAgICBpZiAobmV3TGVuIDw9IHRoaXMudG90YWxTaXplKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHRocm93IG5ldyBFcnJvcihcIlJlYWRpbmcgb3V0IG9mIGZpbGUgYm91bmRzXCIpO1xuXG4gICAgICAgIGNvbnN0IG5QYWdlcyA9IE1hdGguZmxvb3IoKG5ld0xlbiAtIDEpIC8gUEFHRV9TSVpFKSsxO1xuICAgICAgICBmb3IgKGxldCBpPSBNYXRoLm1heCh0aGlzLm8uZGF0YS5sZW5ndGgtMSwgMCk7IGk8blBhZ2VzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSBpPG5QYWdlcy0xID8gUEFHRV9TSVpFIDogbmV3TGVuIC0gKG5QYWdlcy0xKSpQQUdFX1NJWkU7XG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IFVpbnQ4QXJyYXkobmV3U2l6ZSk7XG4gICAgICAgICAgICBpZiAoaSA9PSB0aGlzLm8uZGF0YS5sZW5ndGgtMSkgcC5zZXQodGhpcy5vLmRhdGFbaV0pO1xuICAgICAgICAgICAgdGhpcy5vLmRhdGFbaV0gPSBwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxTaXplID0gbmV3TGVuO1xuICAgIH1cblxuICAgIGFzeW5jIHdyaXRlKGJ1ZmYsIHBvcykge1xuICAgICAgICBjb25zdCBzZWxmID10aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHBvcyA9PSBcInVuZGVmaW5lZFwiKSBwb3MgPSBzZWxmLnBvcztcbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHRocm93IG5ldyBFcnJvcihcIldyaXRpbmcgYSByZWFkIG9ubHkgZmlsZVwiKTtcblxuICAgICAgICB0aGlzLl9yZXNpemVJZk5lZWRlZChwb3MgKyBidWZmLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IGZpcnN0UGFnZSA9IE1hdGguZmxvb3IocG9zIC8gUEFHRV9TSVpFKTtcblxuICAgICAgICBsZXQgcCA9IGZpcnN0UGFnZTtcbiAgICAgICAgbGV0IG8gPSBwb3MgJSBQQUdFX1NJWkU7XG4gICAgICAgIGxldCByID0gYnVmZi5ieXRlTGVuZ3RoO1xuICAgICAgICB3aGlsZSAocj4wKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gKG8rciA+IFBBR0VfU0laRSkgPyAoUEFHRV9TSVpFIC1vKSA6IHI7XG4gICAgICAgICAgICBjb25zdCBzcmNWaWV3ID0gYnVmZi5zbGljZShidWZmLmJ5dGVMZW5ndGggLSByLCBidWZmLmJ5dGVMZW5ndGggLSByICsgbCk7XG4gICAgICAgICAgICBjb25zdCBkc3RWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc2VsZi5vLmRhdGFbcF0uYnVmZmVyLCBvLCBsKTtcbiAgICAgICAgICAgIGRzdFZpZXcuc2V0KHNyY1ZpZXcpO1xuICAgICAgICAgICAgciA9IHItbDtcbiAgICAgICAgICAgIHAgKys7XG4gICAgICAgICAgICBvID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9zID0gcG9zICsgYnVmZi5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIGFzeW5jIHJlYWRUb0J1ZmZlcihidWZmRHN0LCBvZmZzZXQsIGxlbiwgcG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHBvcyA9PSBcInVuZGVmaW5lZFwiKSBwb3MgPSBzZWxmLnBvcztcbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGlmIChwb3MgKyBsZW4gPiB0aGlzLnRvdGFsU2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwiUmVhZGluZyBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUlmTmVlZGVkKHBvcyArIGxlbik7XG5cbiAgICAgICAgY29uc3QgZmlyc3RQYWdlID0gTWF0aC5mbG9vcihwb3MgLyBQQUdFX1NJWkUpO1xuXG4gICAgICAgIGxldCBwID0gZmlyc3RQYWdlO1xuICAgICAgICBsZXQgbyA9IHBvcyAlIFBBR0VfU0laRTtcbiAgICAgICAgLy8gUmVtYWluaW5nIGJ5dGVzIHRvIHJlYWRcbiAgICAgICAgbGV0IHIgPSBsZW47XG4gICAgICAgIHdoaWxlIChyPjApIHtcbiAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGNvcHkgZnJvbSB0aGlzIHBhZ2VcbiAgICAgICAgICAgIGNvbnN0IGwgPSAobytyID4gUEFHRV9TSVpFKSA/IChQQUdFX1NJWkUgLW8pIDogcjtcbiAgICAgICAgICAgIGNvbnN0IHNyY1ZpZXcgPSBuZXcgVWludDhBcnJheShzZWxmLm8uZGF0YVtwXS5idWZmZXIsIG8sIGwpO1xuICAgICAgICAgICAgYnVmZkRzdC5zZXQoc3JjVmlldywgb2Zmc2V0K2xlbi1yKTtcbiAgICAgICAgICAgIHIgPSByLWw7XG4gICAgICAgICAgICBwICsrO1xuICAgICAgICAgICAgbyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvcyA9IHBvcyArIGxlbjtcbiAgICB9XG5cbiAgICBhc3luYyByZWFkKGxlbiwgcG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcblxuICAgICAgICBhd2FpdCBzZWxmLnJlYWRUb0J1ZmZlcihidWZmLCAwLCBsZW4sIHBvcyk7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzY2FyZCgpIHtcbiAgICB9XG5cblxuICAgIGFzeW5jIHdyaXRlVUxFMzIodiwgcG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRtcEJ1ZmYzMnYuc2V0VWludDMyKDAsIHYsIHRydWUpO1xuXG4gICAgICAgIGF3YWl0IHNlbGYud3JpdGUodG1wQnVmZjMyLCBwb3MpO1xuICAgIH1cblxuICAgIGFzeW5jIHdyaXRlVUJFMzIodiwgcG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRtcEJ1ZmYzMnYuc2V0VWludDMyKDAsIHYsIGZhbHNlKTtcblxuICAgICAgICBhd2FpdCBzZWxmLndyaXRlKHRtcEJ1ZmYzMiwgcG9zKTtcbiAgICB9XG5cblxuICAgIGFzeW5jIHdyaXRlVUxFNjQodiwgcG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRtcEJ1ZmY2NHYuc2V0VWludDMyKDAsIHYgJiAweEZGRkZGRkZGLCB0cnVlKTtcbiAgICAgICAgdG1wQnVmZjY0di5zZXRVaW50MzIoNCwgTWF0aC5mbG9vcih2IC8gMHgxMDAwMDAwMDApICwgdHJ1ZSk7XG5cbiAgICAgICAgYXdhaXQgc2VsZi53cml0ZSh0bXBCdWZmNjQsIHBvcyk7XG4gICAgfVxuXG5cbiAgICBhc3luYyByZWFkVUxFMzIocG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBiID0gYXdhaXQgc2VsZi5yZWFkKDQsIHBvcyk7XG5cbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50MzJBcnJheShiLmJ1ZmZlcik7XG5cbiAgICAgICAgcmV0dXJuIHZpZXdbMF07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZFVCRTMyKHBvcykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgYiA9IGF3YWl0IHNlbGYucmVhZCg0LCBwb3MpO1xuXG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYi5idWZmZXIpO1xuXG4gICAgICAgIHJldHVybiB2aWV3LmdldFVpbnQzMigwLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZFVMRTY0KHBvcykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgYiA9IGF3YWl0IHNlbGYucmVhZCg4LCBwb3MpO1xuXG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDMyQXJyYXkoYi5idWZmZXIpO1xuXG4gICAgICAgIHJldHVybiB2aWV3WzFdICogMHgxMDAwMDAwMDAgKyB2aWV3WzBdO1xuICAgIH1cblxuICAgIGFzeW5jIHJlYWRTdHJpbmcocG9zKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBmaXhlZFNpemUgPSAyMDQ4O1xuXG4gICAgICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSB0eXBlb2YgcG9zID09IFwidW5kZWZpbmVkXCIgPyBzZWxmLnBvcyA6IHBvcztcblxuICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uID4gdGhpcy50b3RhbFNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhZGluZyBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVzaXplSWZOZWVkZWQocG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBlbmRPZlN0cmluZ0ZvdW5kID0gZmFsc2U7XG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuXG4gICAgICAgIHdoaWxlICghZW5kT2ZTdHJpbmdGb3VuZCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRQYWdlID0gTWF0aC5mbG9vcihjdXJyZW50UG9zaXRpb24gLyBQQUdFX1NJWkUpO1xuICAgICAgICAgICAgbGV0IG9mZnNldE9uUGFnZSA9IGN1cnJlbnRQb3NpdGlvbiAlIFBBR0VfU0laRTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuby5kYXRhW2N1cnJlbnRQYWdlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1JcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZWFkTGVuZ3RoID0gTWF0aC5taW4oZml4ZWRTaXplLCBzZWxmLm8uZGF0YVtjdXJyZW50UGFnZV0ubGVuZ3RoIC0gb2Zmc2V0T25QYWdlKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBVaW50OEFycmF5KHNlbGYuby5kYXRhW2N1cnJlbnRQYWdlXS5idWZmZXIsIG9mZnNldE9uUGFnZSwgcmVhZExlbmd0aCk7XG5cbiAgICAgICAgICAgIGxldCBpbmRleEVuZE9mU3RyaW5nID0gZGF0YUFycmF5LmZpbmRJbmRleChlbGVtZW50ID0+IGVsZW1lbnQgPT09IDApO1xuICAgICAgICAgICAgZW5kT2ZTdHJpbmdGb3VuZCA9IGluZGV4RW5kT2ZTdHJpbmcgIT09IC0xO1xuXG4gICAgICAgICAgICBpZiAoZW5kT2ZTdHJpbmdGb3VuZCkge1xuICAgICAgICAgICAgICAgIHN0ciArPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YUFycmF5LnNsaWNlKDAsIGluZGV4RW5kT2ZTdHJpbmcpKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBvcyA9IGN1cnJlbnRQYWdlICogUEFHRV9TSVpFICsgb2Zmc2V0T25QYWdlICsgaW5kZXhFbmRPZlN0cmluZyArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciArPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YUFycmF5KTtcbiAgICAgICAgICAgICAgICBzZWxmLnBvcyA9IGN1cnJlbnRQYWdlICogUEFHRV9TSVpFICsgb2Zmc2V0T25QYWdlICsgZGF0YUFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uID0gc2VsZi5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59XG5cbmNvbnN0IE9fVFJVTkMgPSAxMDI0O1xuY29uc3QgT19DUkVBVCA9IDUxMjtcbmNvbnN0IE9fUkRXUiA9IDI7XG5jb25zdCBPX1JET05MWSA9IDA7XG5cbi8qIGdsb2JhbCBmZXRjaCAqL1xuXG5jb25zdCBERUZBVUxUX0NBQ0hFX1NJWkUgPSAoMSA8PCAxNik7XG5jb25zdCBERUZBVUxUX1BBR0VfU0laRSA9ICgxIDw8IDEzKTtcblxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVPdmVycmlkZShvLCBiLCBjKSB7XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG8gPSB7XG4gICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgIGZpbGVOYW1lOiBvLFxuICAgICAgICAgICAgY2FjaGVTaXplOiBiIHx8IERFRkFVTFRfQ0FDSEVfU0laRSxcbiAgICAgICAgICAgIHBhZ2VTaXplOiBjIHx8IERFRkFVTFRfUEFHRV9TSVpFXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvLnR5cGUgPT0gXCJmaWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG9wZW4oby5maWxlTmFtZSwgT19UUlVOQyB8IE9fQ1JFQVQgfCBPX1JEV1IsIG8uY2FjaGVTaXplLCBvLnBhZ2VTaXplKTtcbiAgICB9IGVsc2UgaWYgKG8udHlwZSA9PSBcIm1lbVwiKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVOZXckMShvKTtcbiAgICB9IGVsc2UgaWYgKG8udHlwZSA9PSBcImJpZ01lbVwiKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVOZXcobyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBGYXN0RmlsZSB0eXBlOiBcIitvLnR5cGUpO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEV4aXN0aW5nKG8sIGIsIGMpIHtcbiAgICBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgbyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwibWVtXCIsXG4gICAgICAgICAgICBkYXRhOiBvXG4gICAgICAgIH07XG4gICAgfVxuICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmV0Y2gobykudGhlbiggZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoYWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibWVtXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogYnVmZlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoby50eXBlID09IFwiZmlsZVwiKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBvcGVuKG8uZmlsZU5hbWUsIE9fUkRPTkxZLCBvLmNhY2hlU2l6ZSwgby5wYWdlU2l6ZSk7XG4gICAgfSBlbHNlIGlmIChvLnR5cGUgPT0gXCJtZW1cIikge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVhZEV4aXN0aW5nJDIobyk7XG4gICAgfSBlbHNlIGlmIChvLnR5cGUgPT0gXCJiaWdNZW1cIikge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVhZEV4aXN0aW5nJDEobyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBGYXN0RmlsZSB0eXBlOiBcIitvLnR5cGUpO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEJpbkZpbGUoZmlsZU5hbWUsIHR5cGUsIG1heFZlcnNpb24sIGNhY2hlU2l6ZSwgcGFnZVNpemUpIHtcblxuICAgIGNvbnN0IGZkID0gYXdhaXQgcmVhZEV4aXN0aW5nKGZpbGVOYW1lKTtcblxuICAgIGNvbnN0IGIgPSBhd2FpdCBmZC5yZWFkKDQpO1xuICAgIGxldCByZWFkZWRUeXBlID0gXCJcIjtcbiAgICBmb3IgKGxldCBpPTA7IGk8NDsgaSsrKSByZWFkZWRUeXBlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYltpXSk7XG5cbiAgICBpZiAocmVhZGVkVHlwZSAhPSB0eXBlKSB0aHJvdyBuZXcgRXJyb3IoZmlsZU5hbWUgKyBcIjogSW52YWxpZCBGaWxlIGZvcm1hdFwiKTtcblxuICAgIGxldCB2ID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG5cbiAgICBpZiAodj5tYXhWZXJzaW9uKSB0aHJvdyBuZXcgRXJyb3IoXCJWZXJzaW9uIG5vdCBzdXBwb3J0ZWRcIik7XG5cbiAgICBjb25zdCBuU2VjdGlvbnMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcblxuICAgIC8vIFNjYW4gc2VjdGlvbnNcbiAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8blNlY3Rpb25zOyBpKyspIHtcbiAgICAgICAgbGV0IGh0ID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgICAgIGxldCBobCA9IGF3YWl0IGZkLnJlYWRVTEU2NCgpO1xuICAgICAgICBpZiAodHlwZW9mIHNlY3Rpb25zW2h0XSA9PSBcInVuZGVmaW5lZFwiKSBzZWN0aW9uc1todF0gPSBbXTtcbiAgICAgICAgc2VjdGlvbnNbaHRdLnB1c2goe1xuICAgICAgICAgICAgcDogZmQucG9zLFxuICAgICAgICAgICAgc2l6ZTogaGxcbiAgICAgICAgfSk7XG4gICAgICAgIGZkLnBvcyArPSBobDtcbiAgICB9XG5cbiAgICByZXR1cm4ge2ZkLCBzZWN0aW9uc307XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUJpbkZpbGUoZmlsZU5hbWUsIHR5cGUsIHZlcnNpb24sIG5TZWN0aW9ucywgY2FjaGVTaXplLCBwYWdlU2l6ZSkge1xuXG4gICAgY29uc3QgZmQgPSBhd2FpdCBjcmVhdGVPdmVycmlkZShmaWxlTmFtZSwgY2FjaGVTaXplLCBwYWdlU2l6ZSk7XG5cbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPDQ7IGkrKykgYnVmZltpXSA9IHR5cGUuY2hhckNvZGVBdChpKTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmLCAwKTsgLy8gTWFnaWMgXCJyMWNzXCJcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIodmVyc2lvbik7IC8vIFZlcnNpb25cbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKG5TZWN0aW9ucyk7IC8vIE51bWJlciBvZiBTZWN0aW9uc1xuXG4gICAgcmV0dXJuIGZkO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzdGFydFdyaXRlU2VjdGlvbihmZCwgaWRTZWN0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBmZC53cml0aW5nU2VjdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSB3cml0aW5nIGEgc2VjdGlvblwiKTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGlkU2VjdGlvbik7IC8vIEhlYWRlciB0eXBlXG4gICAgZmQud3JpdGluZ1NlY3Rpb24gPSB7XG4gICAgICAgIHBTZWN0aW9uU2l6ZTogZmQucG9zXG4gICAgfTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KDApOyAvLyBUZW1wb3JhbGx5IHNldCB0byAwIGxlbmd0aFxufVxuXG5hc3luYyBmdW5jdGlvbiBlbmRXcml0ZVNlY3Rpb24oZmQpIHtcbiAgICBpZiAodHlwZW9mIGZkLndyaXRpbmdTZWN0aW9uID09PSBcInVuZGVmaW5lZFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgd3JpdGluZyBhIHNlY3Rpb25cIik7XG5cbiAgICBjb25zdCBzZWN0aW9uU2l6ZSA9IGZkLnBvcyAtIGZkLndyaXRpbmdTZWN0aW9uLnBTZWN0aW9uU2l6ZSAtIDg7XG4gICAgY29uc3Qgb2xkUG9zID0gZmQucG9zO1xuICAgIGZkLnBvcyA9IGZkLndyaXRpbmdTZWN0aW9uLnBTZWN0aW9uU2l6ZTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KHNlY3Rpb25TaXplKTtcbiAgICBmZC5wb3MgPSBvbGRQb3M7XG4gICAgZGVsZXRlIGZkLndyaXRpbmdTZWN0aW9uO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgaWRTZWN0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBmZC5yZWFkaW5nU2VjdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSByZWFkaW5nIGEgc2VjdGlvblwiKTtcbiAgICBpZiAoIXNlY3Rpb25zW2lkU2VjdGlvbl0pICB0aHJvdyBuZXcgRXJyb3IoZmQuZmlsZU5hbWUgKyBcIjogTWlzc2luZyBzZWN0aW9uIFwiKyBpZFNlY3Rpb24gKTtcbiAgICBpZiAoc2VjdGlvbnNbaWRTZWN0aW9uXS5sZW5ndGg+MSkgdGhyb3cgbmV3IEVycm9yKGZkLmZpbGVOYW1lICtcIjogU2VjdGlvbiBEdXBsaWNhdGVkIFwiICtpZFNlY3Rpb24pO1xuXG4gICAgZmQucG9zID0gc2VjdGlvbnNbaWRTZWN0aW9uXVswXS5wO1xuXG4gICAgZmQucmVhZGluZ1NlY3Rpb24gPSBzZWN0aW9uc1tpZFNlY3Rpb25dWzBdO1xufVxuXG5hc3luYyBmdW5jdGlvbiBlbmRSZWFkU2VjdGlvbihmZCwgbm9DaGVjaykge1xuICAgIGlmICh0eXBlb2YgZmQucmVhZGluZ1NlY3Rpb24gPT09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIk5vdCByZWFkaW5nIGEgc2VjdGlvblwiKTtcbiAgICBpZiAoIW5vQ2hlY2spIHtcbiAgICAgICAgaWYgKGZkLnBvcy1mZC5yZWFkaW5nU2VjdGlvbi5wICE9ICBmZC5yZWFkaW5nU2VjdGlvbi5zaXplKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlY3Rpb24gc2l6ZSByZWFkaW5nXCIpO1xuICAgIH1cbiAgICBkZWxldGUgZmQucmVhZGluZ1NlY3Rpb247XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQmlnSW50KGZkLCBuLCBuOCwgcG9zKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KG44KTtcbiAgICBTY2FsYXIudG9ScHJMRShidWZmLCAwLCBuLCBuOCk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZiwgcG9zKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEJpZ0ludChmZCwgbjgsIHBvcykge1xuICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKG44LCBwb3MpO1xuICAgIHJldHVybiBTY2FsYXIuZnJvbVJwckxFKGJ1ZmYsIDAsIG44KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29weVNlY3Rpb24oZmRGcm9tLCBzZWN0aW9ucywgZmRUbywgc2VjdGlvbklkLCBzaXplKSB7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNpemUgPSBzZWN0aW9uc1tzZWN0aW9uSWRdWzBdLnNpemU7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rU2l6ZSA9IGZkRnJvbS5wYWdlU2l6ZTtcbiAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkRnJvbSwgc2VjdGlvbnMsIHNlY3Rpb25JZCk7XG4gICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRUbywgc2VjdGlvbklkKTtcbiAgICBmb3IgKGxldCBwPTA7IHA8c2l6ZTsgcCs9Y2h1bmtTaXplKSB7XG4gICAgICAgIGNvbnN0IGwgPSBNYXRoLm1pbihzaXplIC1wLCBjaHVua1NpemUpO1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmRGcm9tLnJlYWQobCk7XG4gICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZik7XG4gICAgfVxuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFRvKTtcbiAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZEZyb20sIHNpemUgIT0gc2VjdGlvbnNbc2VjdGlvbklkXVswXS5zaXplKTtcblxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkU2VjdGlvbihmZCwgc2VjdGlvbnMsIGlkU2VjdGlvbiwgb2Zmc2V0LCBsZW5ndGgpIHtcblxuICAgIG9mZnNldCA9ICh0eXBlb2Ygb2Zmc2V0ID09PSBcInVuZGVmaW5lZFwiKSA/IDAgOiBvZmZzZXQ7XG4gICAgbGVuZ3RoID0gKHR5cGVvZiBsZW5ndGggPT09IFwidW5kZWZpbmVkXCIpID8gc2VjdGlvbnNbaWRTZWN0aW9uXVswXS5zaXplIC0gb2Zmc2V0IDogbGVuZ3RoO1xuXG4gICAgaWYgKG9mZnNldCArIGxlbmd0aCA+IHNlY3Rpb25zW2lkU2VjdGlvbl1bMF0uc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkaW5nIG91dCBvZiB0aGUgcmFuZ2Ugb2YgdGhlIHNlY3Rpb25cIik7XG4gICAgfVxuXG4gICAgbGV0IGJ1ZmY7XG4gICAgaWYgKGxlbmd0aCA8ICgxIDw8IDMwKSApIHtcbiAgICAgICAgYnVmZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZiA9IG5ldyBCaWdCdWZmZXIobGVuZ3RoKTtcbiAgICB9XG5cbiAgICBhd2FpdCBmZC5yZWFkVG9CdWZmZXIoYnVmZiwgMCwgbGVuZ3RoLCBzZWN0aW9uc1tpZFNlY3Rpb25dWzBdLnAgKyBvZmZzZXQpO1xuICAgIHJldHVybiBidWZmO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzZWN0aW9uSXNFcXVhbChmZDEsIHNlY3Rpb25zMSwgZmQyLCBzZWN0aW9uczIsIGlkU2VjdGlvbikge1xuICAgIGNvbnN0IE1BWF9CVUZGX1NJWkUgPSBmZDEucGFnZVNpemUgKiAxNjtcbiAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkMSwgc2VjdGlvbnMxLCBpZFNlY3Rpb24pO1xuICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQyLCBzZWN0aW9uczIsIGlkU2VjdGlvbik7XG4gICAgaWYgKHNlY3Rpb25zMVtpZFNlY3Rpb25dWzBdLnNpemUgIT0gc2VjdGlvbnMyW2lkU2VjdGlvbl1bMF0uc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHRvdGFsQnl0ZXM9c2VjdGlvbnMxW2lkU2VjdGlvbl1bMF0uc2l6ZTtcbiAgICBmb3IgKGxldCBpPTA7IGk8dG90YWxCeXRlczsgaSs9IE1BWF9CVUZGX1NJWkUpIHtcbiAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKHRvdGFsQnl0ZXMtaSwgTUFYX0JVRkZfU0laRSk7XG4gICAgICAgIGNvbnN0IGJ1ZmYxID0gYXdhaXQgZmQxLnJlYWQobik7XG4gICAgICAgIGNvbnN0IGJ1ZmYyID0gYXdhaXQgZmQyLnJlYWQobik7XG4gICAgICAgIGZvciAobGV0IGo9MDsgajxuOyBqKyspIGlmIChidWZmMVtqXSAhPSBidWZmMltqXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZDEpO1xuICAgIGF3YWl0IGVuZFJlYWRTZWN0aW9uKGZkMik7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IGJsczEyMzgxciQxID0gU2NhbGFyLmUoXCI3M2VkYTc1MzI5OWQ3ZDQ4MzMzOWQ4MDgwOWExZDgwNTUzYmRhNDAyZmZmZTViZmVmZmZmZmZmZjAwMDAwMDAxXCIsIDE2KTtcbmNvbnN0IGJuMTI4ciQxID0gU2NhbGFyLmUoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODU0ODM2NDQwMDQxNjAzNDM0MzY5ODIwNDE4NjU3NTgwODQ5NTYxN1wiKTtcblxuY29uc3QgYmxzMTIzODFxID0gU2NhbGFyLmUoXCIxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJcIiwgMTYpO1xuY29uc3QgYm4xMjhxID0gU2NhbGFyLmUoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODY5NjMxMTE1NzI5NzgyMzY2MjY4OTAzNzg5NDY0NTIyNjIwODU4M1wiKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0Q3VydmVGcm9tUihyLCBvcHRpb25zKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIC8vIGNoZWNrIHRoYXQgb3B0aW9ucyBwYXJhbSBpcyBkZWZpbmVkIGFuZCB0aGF0IG9wdGlvbnMuc2luZ2xlVGhyZWFkIGlzIGRlZmluZWRcbiAgICBsZXQgc2luZ2xlVGhyZWFkID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpbmdsZVRocmVhZDtcbiAgICBpZiAoU2NhbGFyLmVxKHIsIGJuMTI4ciQxKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQm4xMjgoc2luZ2xlVGhyZWFkKTtcbiAgICB9IGVsc2UgaWYgKFNjYWxhci5lcShyLCBibHMxMjM4MXIkMSkpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke1NjYWxhci50b1N0cmluZyhyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZlO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRDdXJ2ZUZyb21RKHEsIG9wdGlvbnMpIHtcbiAgICBsZXQgY3VydmU7XG4gICAgbGV0IHNpbmdsZVRocmVhZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaW5nbGVUaHJlYWQ7XG4gICAgaWYgKFNjYWxhci5lcShxLCBibjEyOHEpKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbjEyOChzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSBpZiAoU2NhbGFyLmVxKHEsIGJsczEyMzgxcSkpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke1NjYWxhci50b1N0cmluZyhxKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZlO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRDdXJ2ZUZyb21OYW1lKG5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgY3VydmU7XG4gICAgbGV0IHNpbmdsZVRocmVhZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaW5nbGVUaHJlYWQ7XG4gICAgY29uc3Qgbm9ybU5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIGlmIChbXCJCTjEyOFwiLCBcIkJOMjU0XCIsIFwiQUxUQk4xMjhcIl0uaW5kZXhPZihub3JtTmFtZSkgPj0gMCkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQm4xMjgoc2luZ2xlVGhyZWFkKTtcbiAgICB9IGVsc2UgaWYgKFtcIkJMUzEyMzgxXCJdLmluZGV4T2Yobm9ybU5hbWUpID49IDApIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJ2ZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobikge1xuICAgICAgICByZXR1cm4gbi50b1VwcGVyQ2FzZSgpLm1hdGNoKC9bQS1aYS16MC05XSsvZykuam9pbihcIlwiKTtcbiAgICB9XG5cbn1cblxudmFyIGN1cnZlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0Q3VydmVGcm9tUjogZ2V0Q3VydmVGcm9tUixcbiAgICBnZXRDdXJ2ZUZyb21ROiBnZXRDdXJ2ZUZyb21RLFxuICAgIGdldEN1cnZlRnJvbU5hbWU6IGdldEN1cnZlRnJvbU5hbWVcbn0pO1xuXG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgbm90ICR7bn1gKTtcbn1cbi8vIGNvcGllZCBmcm9tIHV0aWxzXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5cbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuLy8gVGhlIGJ5dGUgc3dhcCBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3QgYnl0ZVN3YXAgPSAod29yZCkgPT4gKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcbiAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpO1xuLy8gQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtXG5jb25zdCBieXRlU3dhcElmQkUgPSBpc0xFID8gKG4pID0+IG4gOiAobikgPT4gYnl0ZVN3YXAobik7XG4vLyBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5XG5mdW5jdGlvbiBieXRlU3dhcDMyKGFycikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGJ5dGVTd2FwKGFycltpXSk7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5mdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5cbi8vIEJsYWtlIGlzIGJhc2VkIG9uIENoYUNoYSBwZXJtdXRhdGlvbi5cbi8vIEZvciBCTEFLRTJiLCB0aGUgdHdvIGV4dHJhIHBlcm11dGF0aW9ucyBmb3Igcm91bmRzIDEwIGFuZCAxMSBhcmUgU0lHTUFbMTAuLjExXSA9IFNJR01BWzAuLjFdLlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSUdNQSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheShbXG4gICAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzLFxuICAgIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDQsXG4gICAgNywgOSwgMywgMSwgMTMsIDEyLCAxMSwgMTQsIDIsIDYsIDUsIDEwLCA0LCAwLCAxNSwgOCxcbiAgICA5LCAwLCA1LCA3LCAyLCA0LCAxMCwgMTUsIDE0LCAxLCAxMSwgMTIsIDYsIDgsIDMsIDEzLFxuICAgIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDksXG4gICAgMTIsIDUsIDEsIDE1LCAxNCwgMTMsIDQsIDEwLCAwLCA3LCA2LCAzLCA5LCAyLCA4LCAxMSxcbiAgICAxMywgMTEsIDcsIDE0LCAxMiwgMSwgMywgOSwgNSwgMCwgMTUsIDQsIDgsIDYsIDIsIDEwLFxuICAgIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsXG4gICAgMTAsIDIsIDgsIDQsIDcsIDYsIDEsIDUsIDE1LCAxMSwgOSwgMTQsIDMsIDEyLCAxMywgMCxcbiAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAgIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG5dKTtcbmNsYXNzIEJMQUtFIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgb3B0cyA9IHt9LCBrZXlMZW4sIHNhbHRMZW4sIHBlcnNMZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgbnVtYmVyKGJsb2NrTGVuKTtcbiAgICAgICAgbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIG51bWJlcihrZXlMZW4pO1xuICAgICAgICBpZiAob3V0cHV0TGVuIDwgMCB8fCBvdXRwdXRMZW4gPiBrZXlMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dExlbiBiaWdnZXIgdGhhbiBrZXlMZW4nKTtcbiAgICAgICAgaWYgKG9wdHMua2V5ICE9PSB1bmRlZmluZWQgJiYgKG9wdHMua2V5Lmxlbmd0aCA8IDEgfHwgb3B0cy5rZXkubGVuZ3RoID4ga2V5TGVuKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihga2V5IG11c3QgYmUgdXAgMS4uJHtrZXlMZW59IGJ5dGUgbG9uZyBvciB1bmRlZmluZWRgKTtcbiAgICAgICAgaWYgKG9wdHMuc2FsdCAhPT0gdW5kZWZpbmVkICYmIG9wdHMuc2FsdC5sZW5ndGggIT09IHNhbHRMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNhbHQgbXVzdCBiZSAke3NhbHRMZW59IGJ5dGUgbG9uZyBvciB1bmRlZmluZWRgKTtcbiAgICAgICAgaWYgKG9wdHMucGVyc29uYWxpemF0aW9uICE9PSB1bmRlZmluZWQgJiYgb3B0cy5wZXJzb25hbGl6YXRpb24ubGVuZ3RoICE9PSBwZXJzTGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwZXJzb25hbGl6YXRpb24gbXVzdCBiZSAke3BlcnNMZW59IGJ5dGUgbG9uZyBvciB1bmRlZmluZWRgKTtcbiAgICAgICAgdGhpcy5idWZmZXIzMiA9IHUzMigodGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbikpKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICAvLyBNYWluIGRpZmZlcmVuY2Ugd2l0aCBvdGhlciBoYXNoZXM6IHRoZXJlIGlzIGZsYWcgZm9yIGxhc3QgYmxvY2ssXG4gICAgICAgIC8vIHNvIHdlIGNhbm5vdCBwcm9jZXNzIGN1cnJlbnQgYmxvY2sgYmVmb3JlIHdlIGtub3cgdGhhdCB0aGVyZVxuICAgICAgICAvLyBpcyB0aGUgbmV4dCBvbmUuIFRoaXMgc2lnbmlmaWNhbnRseSBjb21wbGljYXRlcyBsb2dpYyBhbmQgcmVkdWNlcyBhYmlsaXR5XG4gICAgICAgIC8vIHRvIGRvIHplcm8tY29weSBwcm9jZXNzaW5nXG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgYnVmZmVyMzIgfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0O1xuICAgICAgICBjb25zdCBidWYgPSBkYXRhLmJ1ZmZlcjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgLy8gSWYgYnVmZmVyIGlzIGZ1bGwgYW5kIHdlIHN0aWxsIGhhdmUgaW5wdXQgKGRvbid0IHByb2Nlc3MgbGFzdCBibG9jaywgc2FtZSBhcyBibGFrZTJzKVxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGlmICghaXNMRSlcbiAgICAgICAgICAgICAgICAgICAgYnl0ZVN3YXAzMihidWZmZXIzMik7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzcyhidWZmZXIzMiwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICghaXNMRSlcbiAgICAgICAgICAgICAgICAgICAgYnl0ZVN3YXAzMihidWZmZXIzMik7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhT2Zmc2V0ID0gb2Zmc2V0ICsgcG9zO1xuICAgICAgICAgICAgLy8gZnVsbCBibG9jayAmJiBhbGlnbmVkIHRvIDQgYnl0ZXMgJiYgbm90IGxhc3QgaW4gaW5wdXRcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbiAmJiAhKGRhdGFPZmZzZXQgJSA0KSAmJiBwb3MgKyB0YWtlIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YTMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZiwgZGF0YU9mZnNldCwgTWF0aC5mbG9vcigobGVuIC0gcG9zKSAvIDQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTEUpXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVTd2FwMzIoZGF0YTMyKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MzMiA9IDA7IHBvcyArIGJsb2NrTGVuIDwgbGVuOyBwb3MzMiArPSBidWZmZXIzMi5sZW5ndGgsIHBvcyArPSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCArPSBibG9ja0xlbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzcyhkYXRhMzIsIHBvczMyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNMRSlcbiAgICAgICAgICAgICAgICAgICAgYnl0ZVN3YXAzMihkYXRhMzIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGNvbnN0IHsgcG9zLCBidWZmZXIzMiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICBpZiAoIWlzTEUpXG4gICAgICAgICAgICBieXRlU3dhcDMyKGJ1ZmZlcjMyKTtcbiAgICAgICAgdGhpcy5jb21wcmVzcyhidWZmZXIzMiwgMCwgdHJ1ZSk7XG4gICAgICAgIGlmICghaXNMRSlcbiAgICAgICAgICAgIGJ5dGVTd2FwMzIoYnVmZmVyMzIpO1xuICAgICAgICBjb25zdCBvdXQzMiA9IHUzMihvdXQpO1xuICAgICAgICB0aGlzLmdldCgpLmZvckVhY2goKHYsIGkpID0+IChvdXQzMltpXSA9IGJ5dGVTd2FwSWZCRSh2KSkpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgb3V0cHV0TGVuLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHsgZGtMZW46IG91dHB1dExlbiB9KSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5cbmNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG52YXIgdTY0JDEgPSB1NjQ7XG5cbi8vIFNhbWUgYXMgU0hBLTUxMiBidXQgTEVcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgQjJCX0lWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHhmM2JjYzkwOCwgMHg2YTA5ZTY2NywgMHg4NGNhYTczYiwgMHhiYjY3YWU4NSwgMHhmZTk0ZjgyYiwgMHgzYzZlZjM3MiwgMHg1ZjFkMzZmMSwgMHhhNTRmZjUzYSxcbiAgICAweGFkZTY4MmQxLCAweDUxMGU1MjdmLCAweDJiM2U2YzFmLCAweDliMDU2ODhjLCAweGZiNDFiZDZiLCAweDFmODNkOWFiLCAweDEzN2UyMTc5LCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXJcbmNvbnN0IEJCVUYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDMyKTtcbi8vIE1peGluZyBmdW5jdGlvbiBHIHNwbGl0dGVkIGluIHR3byBoYWxmc1xuZnVuY3Rpb24gRzFiKGEsIGIsIGMsIGQsIG1zZywgeCkge1xuICAgIC8vIE5PVEU6IFYgaXMgTEUgaGVyZVxuICAgIGNvbnN0IFhsID0gbXNnW3hdLCBYaCA9IG1zZ1t4ICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBBbCA9IEJCVUZbMiAqIGFdLCBBaCA9IEJCVUZbMiAqIGEgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IEJsID0gQkJVRlsyICogYl0sIEJoID0gQkJVRlsyICogYiArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgQ2wgPSBCQlVGWzIgKiBjXSwgQ2ggPSBCQlVGWzIgKiBjICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBEbCA9IEJCVUZbMiAqIGRdLCBEaCA9IEJCVUZbMiAqIGQgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgLy8gdlthXSA9ICh2W2FdICsgdltiXSArIHgpIHwgMDtcbiAgICBsZXQgbGwgPSB1NjQkMS5hZGQzTChBbCwgQmwsIFhsKTtcbiAgICBBaCA9IHU2NCQxLmFkZDNIKGxsLCBBaCwgQmgsIFhoKTtcbiAgICBBbCA9IGxsIHwgMDtcbiAgICAvLyB2W2RdID0gcm90cih2W2RdIF4gdlthXSwgMzIpXG4gICAgKHsgRGgsIERsIH0gPSB7IERoOiBEaCBeIEFoLCBEbDogRGwgXiBBbCB9KTtcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IHU2NCQxLnJvdHIzMkgoRGgsIERsKSwgRGw6IHU2NCQxLnJvdHIzMkwoRGgsIERsKSB9KTtcbiAgICAvLyB2W2NdID0gKHZbY10gKyB2W2RdKSB8IDA7XG4gICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQkMS5hZGQoQ2gsIENsLCBEaCwgRGwpKTtcbiAgICAvLyB2W2JdID0gcm90cih2W2JdIF4gdltjXSwgMjQpXG4gICAgKHsgQmgsIEJsIH0gPSB7IEJoOiBCaCBeIENoLCBCbDogQmwgXiBDbCB9KTtcbiAgICAoeyBCaCwgQmwgfSA9IHsgQmg6IHU2NCQxLnJvdHJTSChCaCwgQmwsIDI0KSwgQmw6IHU2NCQxLnJvdHJTTChCaCwgQmwsIDI0KSB9KTtcbiAgICAoQkJVRlsyICogYV0gPSBBbCksIChCQlVGWzIgKiBhICsgMV0gPSBBaCk7XG4gICAgKEJCVUZbMiAqIGJdID0gQmwpLCAoQkJVRlsyICogYiArIDFdID0gQmgpO1xuICAgIChCQlVGWzIgKiBjXSA9IENsKSwgKEJCVUZbMiAqIGMgKyAxXSA9IENoKTtcbiAgICAoQkJVRlsyICogZF0gPSBEbCksIChCQlVGWzIgKiBkICsgMV0gPSBEaCk7XG59XG5mdW5jdGlvbiBHMmIoYSwgYiwgYywgZCwgbXNnLCB4KSB7XG4gICAgLy8gTk9URTogViBpcyBMRSBoZXJlXG4gICAgY29uc3QgWGwgPSBtc2dbeF0sIFhoID0gbXNnW3ggKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IEFsID0gQkJVRlsyICogYV0sIEFoID0gQkJVRlsyICogYSArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgQmwgPSBCQlVGWzIgKiBiXSwgQmggPSBCQlVGWzIgKiBiICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBDbCA9IEJCVUZbMiAqIGNdLCBDaCA9IEJCVUZbMiAqIGMgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IERsID0gQkJVRlsyICogZF0sIERoID0gQkJVRlsyICogZCArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAvLyB2W2FdID0gKHZbYV0gKyB2W2JdICsgeCkgfCAwO1xuICAgIGxldCBsbCA9IHU2NCQxLmFkZDNMKEFsLCBCbCwgWGwpO1xuICAgIEFoID0gdTY0JDEuYWRkM0gobGwsIEFoLCBCaCwgWGgpO1xuICAgIEFsID0gbGwgfCAwO1xuICAgIC8vIHZbZF0gPSByb3RyKHZbZF0gXiB2W2FdLCAxNilcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IERoIF4gQWgsIERsOiBEbCBeIEFsIH0pO1xuICAgICh7IERoLCBEbCB9ID0geyBEaDogdTY0JDEucm90clNIKERoLCBEbCwgMTYpLCBEbDogdTY0JDEucm90clNMKERoLCBEbCwgMTYpIH0pO1xuICAgIC8vIHZbY10gPSAodltjXSArIHZbZF0pIHwgMDtcbiAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NCQxLmFkZChDaCwgQ2wsIERoLCBEbCkpO1xuICAgIC8vIHZbYl0gPSByb3RyKHZbYl0gXiB2W2NdLCA2MylcbiAgICAoeyBCaCwgQmwgfSA9IHsgQmg6IEJoIF4gQ2gsIEJsOiBCbCBeIENsIH0pO1xuICAgICh7IEJoLCBCbCB9ID0geyBCaDogdTY0JDEucm90ckJIKEJoLCBCbCwgNjMpLCBCbDogdTY0JDEucm90ckJMKEJoLCBCbCwgNjMpIH0pO1xuICAgIChCQlVGWzIgKiBhXSA9IEFsKSwgKEJCVUZbMiAqIGEgKyAxXSA9IEFoKTtcbiAgICAoQkJVRlsyICogYl0gPSBCbCksIChCQlVGWzIgKiBiICsgMV0gPSBCaCk7XG4gICAgKEJCVUZbMiAqIGNdID0gQ2wpLCAoQkJVRlsyICogYyArIDFdID0gQ2gpO1xuICAgIChCQlVGWzIgKiBkXSA9IERsKSwgKEJCVUZbMiAqIGQgKyAxXSA9IERoKTtcbn1cbmNsYXNzIEJMQUtFMmIgZXh0ZW5kcyBCTEFLRSB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKDEyOCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gNjQgOiBvcHRzLmRrTGVuLCBvcHRzLCA2NCwgMTYsIDE2KTtcbiAgICAgICAgLy8gU2FtZSBhcyBTSEEtNTEyLCBidXQgTEVcbiAgICAgICAgdGhpcy52MGwgPSBCMkJfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLnYwaCA9IEIyQl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMudjFsID0gQjJCX0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy52MWggPSBCMkJfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLnYybCA9IEIyQl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMudjJoID0gQjJCX0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy52M2wgPSBCMkJfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLnYzaCA9IEIyQl9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMudjRsID0gQjJCX0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy52NGggPSBCMkJfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLnY1bCA9IEIyQl9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLnY1aCA9IEIyQl9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLnY2bCA9IEIyQl9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLnY2aCA9IEIyQl9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLnY3bCA9IEIyQl9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLnY3aCA9IEIyQl9JVlsxNV0gfCAwO1xuICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBvcHRzLmtleSA/IG9wdHMua2V5Lmxlbmd0aCA6IDA7XG4gICAgICAgIHRoaXMudjBsIF49IHRoaXMub3V0cHV0TGVuIHwgKGtleUxlbmd0aCA8PCA4KSB8ICgweDAxIDw8IDE2KSB8ICgweDAxIDw8IDI0KTtcbiAgICAgICAgaWYgKG9wdHMuc2FsdCkge1xuICAgICAgICAgICAgY29uc3Qgc2FsdCA9IHUzMih0b0J5dGVzKG9wdHMuc2FsdCkpO1xuICAgICAgICAgICAgdGhpcy52NGwgXj0gYnl0ZVN3YXBJZkJFKHNhbHRbMF0pO1xuICAgICAgICAgICAgdGhpcy52NGggXj0gYnl0ZVN3YXBJZkJFKHNhbHRbMV0pO1xuICAgICAgICAgICAgdGhpcy52NWwgXj0gYnl0ZVN3YXBJZkJFKHNhbHRbMl0pO1xuICAgICAgICAgICAgdGhpcy52NWggXj0gYnl0ZVN3YXBJZkJFKHNhbHRbM10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnBlcnNvbmFsaXphdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcGVycyA9IHUzMih0b0J5dGVzKG9wdHMucGVyc29uYWxpemF0aW9uKSk7XG4gICAgICAgICAgICB0aGlzLnY2bCBePSBieXRlU3dhcElmQkUocGVyc1swXSk7XG4gICAgICAgICAgICB0aGlzLnY2aCBePSBieXRlU3dhcElmQkUocGVyc1sxXSk7XG4gICAgICAgICAgICB0aGlzLnY3bCBePSBieXRlU3dhcElmQkUocGVyc1syXSk7XG4gICAgICAgICAgICB0aGlzLnY3aCBePSBieXRlU3dhcElmQkUocGVyc1szXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMua2V5KSB7XG4gICAgICAgICAgICAvLyBQYWQgdG8gYmxvY2tMZW4gYW5kIHVwZGF0ZVxuICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5ibG9ja0xlbik7XG4gICAgICAgICAgICB0bXAuc2V0KHRvQnl0ZXMob3B0cy5rZXkpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRtcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBsZXQgeyB2MGwsIHYwaCwgdjFsLCB2MWgsIHYybCwgdjJoLCB2M2wsIHYzaCwgdjRsLCB2NGgsIHY1bCwgdjVoLCB2NmwsIHY2aCwgdjdsLCB2N2ggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbdjBsLCB2MGgsIHYxbCwgdjFoLCB2MmwsIHYyaCwgdjNsLCB2M2gsIHY0bCwgdjRoLCB2NWwsIHY1aCwgdjZsLCB2NmgsIHY3bCwgdjdoXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KHYwbCwgdjBoLCB2MWwsIHYxaCwgdjJsLCB2MmgsIHYzbCwgdjNoLCB2NGwsIHY0aCwgdjVsLCB2NWgsIHY2bCwgdjZoLCB2N2wsIHY3aCkge1xuICAgICAgICB0aGlzLnYwbCA9IHYwbCB8IDA7XG4gICAgICAgIHRoaXMudjBoID0gdjBoIHwgMDtcbiAgICAgICAgdGhpcy52MWwgPSB2MWwgfCAwO1xuICAgICAgICB0aGlzLnYxaCA9IHYxaCB8IDA7XG4gICAgICAgIHRoaXMudjJsID0gdjJsIHwgMDtcbiAgICAgICAgdGhpcy52MmggPSB2MmggfCAwO1xuICAgICAgICB0aGlzLnYzbCA9IHYzbCB8IDA7XG4gICAgICAgIHRoaXMudjNoID0gdjNoIHwgMDtcbiAgICAgICAgdGhpcy52NGwgPSB2NGwgfCAwO1xuICAgICAgICB0aGlzLnY0aCA9IHY0aCB8IDA7XG4gICAgICAgIHRoaXMudjVsID0gdjVsIHwgMDtcbiAgICAgICAgdGhpcy52NWggPSB2NWggfCAwO1xuICAgICAgICB0aGlzLnY2bCA9IHY2bCB8IDA7XG4gICAgICAgIHRoaXMudjZoID0gdjZoIHwgMDtcbiAgICAgICAgdGhpcy52N2wgPSB2N2wgfCAwO1xuICAgICAgICB0aGlzLnY3aCA9IHY3aCB8IDA7XG4gICAgfVxuICAgIGNvbXByZXNzKG1zZywgb2Zmc2V0LCBpc0xhc3QpIHtcbiAgICAgICAgdGhpcy5nZXQoKS5mb3JFYWNoKCh2LCBpKSA9PiAoQkJVRltpXSA9IHYpKTsgLy8gRmlyc3QgaGFsZiBmcm9tIHN0YXRlLlxuICAgICAgICBCQlVGLnNldChCMkJfSVYsIDE2KTsgLy8gU2Vjb25kIGhhbGYgZnJvbSBJVi5cbiAgICAgICAgbGV0IHsgaCwgbCB9ID0gdTY0JDEuZnJvbUJpZyhCaWdJbnQodGhpcy5sZW5ndGgpKTtcbiAgICAgICAgQkJVRlsyNF0gPSBCMkJfSVZbOF0gXiBsOyAvLyBMb3cgd29yZCBvZiB0aGUgb2Zmc2V0LlxuICAgICAgICBCQlVGWzI1XSA9IEIyQl9JVls5XSBeIGg7IC8vIEhpZ2ggd29yZC5cbiAgICAgICAgLy8gSW52ZXJ0IGFsbCBiaXRzIGZvciBsYXN0IGJsb2NrXG4gICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgIEJCVUZbMjhdID0gfkJCVUZbMjhdO1xuICAgICAgICAgICAgQkJVRlsyOV0gPSB+QkJVRlsyOV07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBjb25zdCBzID0gU0lHTUE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgRzFiKDAsIDQsIDgsIDEyLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzJiKDAsIDQsIDgsIDEyLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzFiKDEsIDUsIDksIDEzLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzJiKDEsIDUsIDksIDEzLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzFiKDIsIDYsIDEwLCAxNCwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyYigyLCA2LCAxMCwgMTQsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMWIoMywgNywgMTEsIDE1LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzJiKDMsIDcsIDExLCAxNSwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcxYigwLCA1LCAxMCwgMTUsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMmIoMCwgNSwgMTAsIDE1LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzFiKDEsIDYsIDExLCAxMiwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyYigxLCA2LCAxMSwgMTIsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMWIoMiwgNywgOCwgMTMsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMmIoMiwgNywgOCwgMTMsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMWIoMywgNCwgOSwgMTQsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMmIoMywgNCwgOSwgMTQsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52MGwgXj0gQkJVRlswXSBeIEJCVUZbMTZdO1xuICAgICAgICB0aGlzLnYwaCBePSBCQlVGWzFdIF4gQkJVRlsxN107XG4gICAgICAgIHRoaXMudjFsIF49IEJCVUZbMl0gXiBCQlVGWzE4XTtcbiAgICAgICAgdGhpcy52MWggXj0gQkJVRlszXSBeIEJCVUZbMTldO1xuICAgICAgICB0aGlzLnYybCBePSBCQlVGWzRdIF4gQkJVRlsyMF07XG4gICAgICAgIHRoaXMudjJoIF49IEJCVUZbNV0gXiBCQlVGWzIxXTtcbiAgICAgICAgdGhpcy52M2wgXj0gQkJVRls2XSBeIEJCVUZbMjJdO1xuICAgICAgICB0aGlzLnYzaCBePSBCQlVGWzddIF4gQkJVRlsyM107XG4gICAgICAgIHRoaXMudjRsIF49IEJCVUZbOF0gXiBCQlVGWzI0XTtcbiAgICAgICAgdGhpcy52NGggXj0gQkJVRls5XSBeIEJCVUZbMjVdO1xuICAgICAgICB0aGlzLnY1bCBePSBCQlVGWzEwXSBeIEJCVUZbMjZdO1xuICAgICAgICB0aGlzLnY1aCBePSBCQlVGWzExXSBeIEJCVUZbMjddO1xuICAgICAgICB0aGlzLnY2bCBePSBCQlVGWzEyXSBeIEJCVUZbMjhdO1xuICAgICAgICB0aGlzLnY2aCBePSBCQlVGWzEzXSBeIEJCVUZbMjldO1xuICAgICAgICB0aGlzLnY3bCBePSBCQlVGWzE0XSBeIEJCVUZbMzBdO1xuICAgICAgICB0aGlzLnY3aCBePSBCQlVGWzE1XSBeIEJCVUZbMzFdO1xuICAgICAgICBCQlVGLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idWZmZXIzMi5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG4vKipcbiAqIEJMQUtFMmIgLSBvcHRpbWl6ZWQgZm9yIDY0LWJpdCBwbGF0Zm9ybXMuIEpTIGRvZXNuJ3QgaGF2ZSB1aW50NjQsIHNvIGl0J3Mgc2xvd2VyIHRoYW4gQkxBS0Uycy5cbiAqIEBwYXJhbSBtc2cgLSBtZXNzYWdlIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKiBAcGFyYW0gb3B0cyAtIGRrTGVuLCBrZXksIHNhbHQsIHBlcnNvbmFsaXphdGlvblxuICovXG5jb25zdCBibGFrZTJiID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKChvcHRzKSA9PiBuZXcgQkxBS0UyYihvcHRzKSk7XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuZnVuY3Rpb24gbG9nMiggViApXG57XG4gICAgcmV0dXJuKCAoICggViAmIDB4RkZGRjAwMDAgKSAhPT0gMCA/ICggViAmPSAweEZGRkYwMDAwLCAxNiApIDogMCApIHwgKCAoIFYgJiAweEZGMDBGRjAwICkgIT09IDAgPyAoIFYgJj0gMHhGRjAwRkYwMCwgOCApIDogMCApIHwgKCAoIFYgJiAweEYwRjBGMEYwICkgIT09IDAgPyAoIFYgJj0gMHhGMEYwRjBGMCwgNCApIDogMCApIHwgKCAoIFYgJiAweENDQ0NDQ0NDICkgIT09IDAgPyAoIFYgJj0gMHhDQ0NDQ0NDQywgMiApIDogMCApIHwgKCAoIFYgJiAweEFBQUFBQUFBICkgIT09IDAgKSApO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEhhc2goYiwgdGl0bGUpIHtcbiAgICBjb25zdCBhID0gbmV3IERhdGFWaWV3KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgbGV0IFMgPSBcIlwiO1xuICAgIGZvciAobGV0IGk9MDsgaTw0OyBpKyspIHtcbiAgICAgICAgaWYgKGk+MCkgUyArPSBcIlxcblwiO1xuICAgICAgICBTICs9IFwiXFx0XFx0XCI7XG4gICAgICAgIGZvciAobGV0IGo9MDsgajw0OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqPjApIFMgKz0gXCIgXCI7XG4gICAgICAgICAgICBTICs9IGEuZ2V0VWludDMyKGkqMTYraio0KS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aXRsZSkgUyA9IHRpdGxlICsgXCJcXG5cIiArIFM7XG4gICAgcmV0dXJuIFM7XG59XG5cbmZ1bmN0aW9uIGhhc2hJc0VxdWFsKGgxLCBoMikge1xuICAgIGlmIChoMS5ieXRlTGVuZ3RoICE9IGgyLmJ5dGVMZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZHYxID0gbmV3IEludDhBcnJheShoMSk7XG4gICAgdmFyIGR2MiA9IG5ldyBJbnQ4QXJyYXkoaDIpO1xuICAgIGZvciAodmFyIGkgPSAwIDsgaSAhPSBoMS5ieXRlTGVuZ3RoIDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKGR2MVtpXSAhPSBkdjJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNsb25lSGFzaGVyKGgpIHtcbiAgICByZXR1cm4gaC5jbG9uZSgpO1xufVxuXG5mdW5jdGlvbiBmcm9tUGFydGlhbEhhc2gocGFydGlhbCkge1xuICAgIC8vIE5PVEU6IHRoaXMgaXMgdW5zYWZlIGFuZCB1c2VzIGludGVybmFsIEFQSVxuICAgIGNvbnN0IGJ1ZiA9IHBhcnRpYWwuc3ViYXJyYXkoMCwgMTI4KTtcbiAgICBjb25zdCByZXN0ID0gdTMyKHBhcnRpYWwuc3ViYXJyYXkoMTI4KSk7XG4gICAgY29uc3QgcmVzID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgcmVzLmJ1ZmZlci5zZXQoYnVmKTtcbiAgICAocmVzLnYwbCA9IHJlc3RbMF0gfCAwKSwgKHJlcy52MGggPSByZXN0WzFdIHwgMCk7XG4gICAgKHJlcy52MWwgPSByZXN0WzJdIHwgMCksIChyZXMudjFoID0gcmVzdFszXSB8IDApO1xuICAgIChyZXMudjJsID0gcmVzdFs0XSB8IDApLCAocmVzLnYyaCA9IHJlc3RbNV0gfCAwKTtcbiAgICAocmVzLnYzbCA9IHJlc3RbNl0gfCAwKSwgKHJlcy52M2ggPSByZXN0WzddIHwgMCk7XG4gICAgKHJlcy52NGwgPSByZXN0WzhdIHwgMCksIChyZXMudjRoID0gcmVzdFs5XSB8IDApO1xuICAgIChyZXMudjVsID0gcmVzdFsxMF0gfCAwKSwgKHJlcy52NWggPSByZXN0WzExXSB8IDApO1xuICAgIChyZXMudjZsID0gcmVzdFsxMl0gfCAwKSwgKHJlcy52NmggPSByZXN0WzEzXSB8IDApO1xuICAgIChyZXMudjdsID0gcmVzdFsxNF0gfCAwKSwgKHJlcy52N2ggPSByZXN0WzE1XSB8IDApO1xuICAgIGNvbnN0IHNoaWZ0ID0gMiAqKiAzMjtcbiAgICBjb25zdCBsZW4gPSByZXN0WzE2XSArIHJlc3RbMTddICogc2hpZnQ7XG4gICAgY29uc3QgcG9zID0gcmVzdFsxOF0gKyByZXN0WzE5XSAqIHNoaWZ0O1xuICAgIHJlcy5sZW5ndGggPSBsZW4gKyBwb3M7XG4gICAgcmVzLnBvcyA9IHBvcztcbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiB0b1BhcnRpYWxIYXNoKGhhc2gpe1xuICAgIC8vIE5PVEU6IHRoaXMgaXMgdW5zYWZlIGFuZCB1c2VzIGludGVybmFsIEFQSVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KDIxNik7XG4gICAgY29uc3QgcmVzMzIgPSB1MzIocmVzLnN1YmFycmF5KDEyOCkpO1xuICAgIHJlcy5zZXQoaGFzaC5idWZmZXIpO1xuICAgIChyZXMzMlswXSA9IGhhc2gudjBsKSwgKHJlczMyWzFdID0gaGFzaC52MGgpO1xuICAgIChyZXMzMlsyXSA9IGhhc2gudjFsKSwgKHJlczMyWzNdID0gaGFzaC52MWgpO1xuICAgIChyZXMzMls0XSA9IGhhc2gudjJsKSwgKHJlczMyWzVdID0gaGFzaC52MmgpO1xuICAgIChyZXMzMls2XSA9IGhhc2gudjNsKSwgKHJlczMyWzddID0gaGFzaC52M2gpO1xuICAgIChyZXMzMls4XSA9IGhhc2gudjRsKSwgKHJlczMyWzldID0gaGFzaC52NGgpO1xuICAgIChyZXMzMlsxMF0gPSBoYXNoLnY1bCksIChyZXMzMlsxMV0gPSBoYXNoLnY1aCk7XG4gICAgKHJlczMyWzEyXSA9IGhhc2gudjZsKSwgKHJlczMyWzEzXSA9IGhhc2gudjZoKTtcbiAgICAocmVzMzJbMTRdID0gaGFzaC52N2wpLCAocmVzMzJbMTVdID0gaGFzaC52N2gpO1xuICAgIHJlczMyWzE4XSA9IGhhc2gucG9zO1xuICAgIHJlczMyWzE2XSA9IGhhc2gubGVuZ3RoLWhhc2gucG9zO1xuICAgIHJldHVybiByZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNhbWVSYXRpbyQyKGN1cnZlLCBnMXMsIGcxc3gsIGcycywgZzJzeCkge1xuICAgIGlmIChjdXJ2ZS5HMS5pc1plcm8oZzFzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjdXJ2ZS5HMS5pc1plcm8oZzFzeCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY3VydmUuRzIuaXNaZXJvKGcycykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY3VydmUuRzIuaXNaZXJvKGcyc3gpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGN1cnZlLkYxMi5lcShjdXJ2ZS5wYWlyaW5nKGcxcywgZzJzeCksIGN1cnZlLnBhaXJpbmcoZzFzeCwgZzJzKSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUucGFpcmluZ0VxKGcxcywgZzJzeCwgY3VydmUuRzEubmVnKGcxc3gpLCBnMnMpO1xuICAgIHJldHVybiByZXM7XG59XG5cblxuZnVuY3Rpb24gYXNrRW50cm9weSgpIHtcbiAgICB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucHJvbXB0KFwiRW50ZXIgYSByYW5kb20gdGV4dC4gKEVudHJvcHkpOiBcIiwgXCJcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhuKSB7XG4gICAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgeyAvLyBTdXBwb3J0ZWRcbiAgICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5hc3luYyBmdW5jdGlvbiBzaGEyNTZkaWdlc3QoZGF0YSkge1xuICAgIHsgLy8gU3VwcG9ydGVkXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtMjU2XCIsIGRhdGEuYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICovXG5mdW5jdGlvbiByZWFkVUludDMyQkUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlcikuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRSYW5kb21SbmcoZW50cm9weSkge1xuICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIFJuZ1xuICAgIHdoaWxlICghZW50cm9weSkge1xuICAgICAgICBlbnRyb3B5ID0gYXdhaXQgYXNrRW50cm9weSgpO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSg2NCk7XG4gICAgaGFzaGVyLnVwZGF0ZShnZXRSYW5kb21CeXRlcyg2NCkpO1xuICAgIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpOyAvLyBhbHdheXMgdXRmLThcbiAgICBoYXNoZXIudXBkYXRlKGVuYy5lbmNvZGUoZW50cm9weSkpO1xuICAgIGNvbnN0IGhhc2ggPSBoYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBjb25zdCBzZWVkID0gW107XG4gICAgZm9yIChsZXQgaT0wO2k8ODtpKyspIHtcbiAgICAgICAgc2VlZFtpXSA9IHJlYWRVSW50MzJCRShoYXNoLCBpKjQpO1xuICAgIH1cbiAgICBjb25zdCBybmcgPSBuZXcgQ2hhQ2hhKHNlZWQpO1xuICAgIHJldHVybiBybmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJuZ0Zyb21CZWFjb25QYXJhbXMoYmVhY29uSGFzaCwgbnVtSXRlcmF0aW9uc0V4cCkge1xuICAgIGxldCBuSXRlcmF0aW9uc0lubmVyO1xuICAgIGxldCBuSXRlcmF0aW9uc091dGVyO1xuICAgIGlmIChudW1JdGVyYXRpb25zRXhwPDMyKSB7XG4gICAgICAgIG5JdGVyYXRpb25zSW5uZXIgPSAoMSA8PCBudW1JdGVyYXRpb25zRXhwKSA+Pj4gMDtcbiAgICAgICAgbkl0ZXJhdGlvbnNPdXRlciA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbkl0ZXJhdGlvbnNJbm5lciA9IDB4MTAwMDAwMDAwO1xuICAgICAgICBuSXRlcmF0aW9uc091dGVyID0gKDEgPDwgKG51bUl0ZXJhdGlvbnNFeHAtMzIpKSA+Pj4gMDtcbiAgICB9XG5cbiAgICBsZXQgY3VySGFzaCA9IGJlYWNvbkhhc2g7XG4gICAgZm9yIChsZXQgaT0wOyBpPG5JdGVyYXRpb25zT3V0ZXI7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqPTA7IGo8bkl0ZXJhdGlvbnNJbm5lcjsgaisrKSB7XG4gICAgICAgICAgICBjdXJIYXNoID0gYXdhaXQgc2hhMjU2ZGlnZXN0KGN1ckhhc2gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY3VySGFzaFYgPSBuZXcgRGF0YVZpZXcoY3VySGFzaC5idWZmZXIsIGN1ckhhc2guYnl0ZU9mZnNldCwgY3VySGFzaC5ieXRlTGVuZ3RoKTtcbiAgICBjb25zdCBzZWVkID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPDg7IGkrKykge1xuICAgICAgICBzZWVkW2ldID0gY3VySGFzaFYuZ2V0VWludDMyKGkqNCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHJuZyA9IG5ldyBDaGFDaGEoc2VlZCk7XG5cbiAgICByZXR1cm4gcm5nO1xufVxuXG5mdW5jdGlvbiBoZXgyQnl0ZUFycmF5KHMpIHtcbiAgICBpZiAocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHJldHVybiBzO1xuICAgIGlmIChzLnNsaWNlKDAsMikgPT0gXCIweFwiKSBzPSBzLnNsaWNlKDIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShzLm1hdGNoKC9bXFxkYS1mXXsyfS9naSkubWFwKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChoLCAxNik7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiBieXRlQXJyYXkyaGV4KGJ5dGVBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYnl0ZUFycmF5LCBmdW5jdGlvbihieXRlKSB7XG4gICAgICAgIHJldHVybiAoXCIwXCIgKyAoYnl0ZSAmIDB4RkYpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQoRnIsIG8pIHtcbiAgICBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICB7XG4gICAgICAgIHJldHVybiBGci50b1N0cmluZyhvKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQuYmluZChudWxsLCBGcikpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG8pO1xuICAgICAgICBrZXlzLmZvckVhY2goIChrKSA9PiB7XG4gICAgICAgICAgICByZXNba10gPSBzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkKEZyLCBvW2tdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mKG8pID09IFwiYmlnaW50XCIpIHx8IG8uZXEgIT09IHVuZGVmaW5lZCkgIHtcbiAgICAgICAgcmV0dXJuIG8udG9TdHJpbmcoMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cblxuY29uc3QgSEVBREVSX1pLRVlfU0VDVElPTiA9IDE7XG5cbmNvbnN0IEdST1RIMTZfUFJPVE9DT0xfSUQgPSAxO1xuY29uc3QgUExPTktfUFJPVE9DT0xfSUQgPSAyO1xuY29uc3QgRkZMT05LX1BST1RPQ09MX0lEID0gMTA7XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIEZGbG9uayBjb25zdGFudHNcbmNvbnN0IEZGX1RfUE9MX0RFR19NSU4gPSAzO1xuXG4vLyBaS0VZIGNvbnN0YW50c1xuY29uc3QgWktFWV9GRl9OU0VDVElPTlMgPSAxNztcblxuY29uc3QgWktFWV9GRl9IRUFERVJfU0VDVElPTiA9IDI7XG5jb25zdCBaS0VZX0ZGX0FERElUSU9OU19TRUNUSU9OID0gMztcbmNvbnN0IFpLRVlfRkZfQV9NQVBfU0VDVElPTiA9IDQ7XG5jb25zdCBaS0VZX0ZGX0JfTUFQX1NFQ1RJT04gPSA1O1xuY29uc3QgWktFWV9GRl9DX01BUF9TRUNUSU9OID0gNjtcbmNvbnN0IFpLRVlfRkZfUUxfU0VDVElPTiA9IDc7XG5jb25zdCBaS0VZX0ZGX1FSX1NFQ1RJT04gPSA4O1xuY29uc3QgWktFWV9GRl9RTV9TRUNUSU9OID0gOTtcbmNvbnN0IFpLRVlfRkZfUU9fU0VDVElPTiA9IDEwO1xuY29uc3QgWktFWV9GRl9RQ19TRUNUSU9OID0gMTE7XG5jb25zdCBaS0VZX0ZGX1NJR01BMV9TRUNUSU9OID0gMTI7XG5jb25zdCBaS0VZX0ZGX1NJR01BMl9TRUNUSU9OID0gMTM7XG5jb25zdCBaS0VZX0ZGX1NJR01BM19TRUNUSU9OID0gMTQ7XG5jb25zdCBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04gPSAxNTtcbmNvbnN0IFpLRVlfRkZfUFRBVV9TRUNUSU9OID0gMTY7XG5jb25zdCBaS0VZX0ZGX0MwX1NFQ1RJT04gPSAxNztcblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVIZWFkZXIoZmQsIHprZXkpIHtcblxuICAgIC8vIFdyaXRlIHRoZSBoZWFkZXJcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAxKTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDEpOyAvLyBHcm90aFxuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSB0aGUgR3JvdGggaGVhZGVyIHNlY3Rpb25cbiAgICAvLy8vLy8vLy8vL1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21RKHprZXkucSk7XG5cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZCwgMik7XG4gICAgY29uc3QgcHJpbWVRID0gY3VydmUucTtcbiAgICBjb25zdCBuOHEgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVSKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihuOHEpO1xuICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkLCBwcmltZVEsIG44cSk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihuOHIpO1xuICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkLCBwcmltZVIsIG44cik7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMih6a2V5Lm5WYXJzKTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIGJhcnNcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHprZXkublB1YmxpYyk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcHVibGljIHZhcnMgKG5vdCBpbmNsdWRpbmcgT05FKVxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoemtleS5kb21haW5TaXplKTsgICAgICAgICAgICAgICAgICAvLyBkb21haW5TaXplXG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkudmtfYWxwaGFfMSk7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkudmtfYmV0YV8xKTtcbiAgICBhd2FpdCB3cml0ZUcyKGZkLCBjdXJ2ZSwgemtleS52a19iZXRhXzIpO1xuICAgIGF3YWl0IHdyaXRlRzIoZmQsIGN1cnZlLCB6a2V5LnZrX2dhbW1hXzIpO1xuICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LnZrX2RlbHRhXzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoZmQsIGN1cnZlLCB6a2V5LnZrX2RlbHRhXzIpO1xuXG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEoZmQsIGN1cnZlLCBwKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcxLkYubjgqMik7XG4gICAgY3VydmUuRzEudG9ScHJMRU0oYnVmZiwgMCwgcCk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIoZmQsIGN1cnZlLCBwKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcyLkYubjgqMik7XG4gICAgY3VydmUuRzIudG9ScHJMRU0oYnVmZiwgMCwgcCk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzEuRi5uOCoyKTtcbiAgICBjb25zdCByZXMgPSBjdXJ2ZS5HMS5mcm9tUnByTEVNKGJ1ZmYsIDApO1xuICAgIHJldHVybiB0b09iamVjdCA/IGN1cnZlLkcxLnRvT2JqZWN0KHJlcykgOiByZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRHMihmZCwgY3VydmUsIHRvT2JqZWN0KSB7XG4gICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzIuRi5uOCoyKTtcbiAgICBjb25zdCByZXMgPSBjdXJ2ZS5HMi5mcm9tUnByTEVNKGJ1ZmYsIDApO1xuICAgIHJldHVybiB0b09iamVjdCA/IGN1cnZlLkcyLnRvT2JqZWN0KHJlcykgOiByZXM7XG59XG5cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlciQxKGZkLCBzZWN0aW9ucywgdG9PYmplY3QsIG9wdGlvbnMpIHtcbiAgICAvLyBSZWFkIEhlYWRlclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAxKTtcbiAgICBjb25zdCBwcm90b2NvbElkID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgaWYgKHByb3RvY29sSWQgPT09IEdST1RIMTZfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRIZWFkZXJHcm90aDE2KGZkLCBzZWN0aW9ucywgdG9PYmplY3QsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xJZCA9PT0gUExPTktfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWRIZWFkZXJQbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHByb3RvY29sSWQgPT09IEZGTE9OS19QUk9UT0NPTF9JRCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVhZEhlYWRlckZGbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm90b2NvbCBub3Qgc3VwcG9ydGVkOiBcIik7XG4gICAgfVxufVxuXG5cblxuXG5hc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyR3JvdGgxNihmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgemtleSA9IHt9O1xuXG4gICAgemtleS5wcm90b2NvbCA9IFwiZ3JvdGgxNlwiO1xuXG4gICAgLy8gUmVhZCBHcm90aCBIZWFkZXJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMik7XG4gICAgY29uc3QgbjhxID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uOHEgPSBuOHE7XG4gICAgemtleS5xID0gYXdhaXQgcmVhZEJpZ0ludChmZCwgbjhxKTtcblxuICAgIGNvbnN0IG44ciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhyID0gbjhyO1xuICAgIHprZXkuciA9IGF3YWl0IHJlYWRCaWdJbnQoZmQsIG44cik7XG4gICAgemtleS5jdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbVEoemtleS5xLCBvcHRpb25zKTtcbiAgICB6a2V5Lm5WYXJzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uUHVibGljID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5kb21haW5TaXplID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5wb3dlciA9IGxvZzIoemtleS5kb21haW5TaXplKTtcbiAgICB6a2V5LnZrX2FscGhhXzEgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LnZrX2JldGFfMSA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfYmV0YV8yID0gYXdhaXQgcmVhZEcyKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS52a19nYW1tYV8yID0gYXdhaXQgcmVhZEcyKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS52a19kZWx0YV8xID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS52a19kZWx0YV8yID0gYXdhaXQgcmVhZEcyKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgcmV0dXJuIHprZXk7XG5cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlclBsb25rKGZkLCBzZWN0aW9ucywgdG9PYmplY3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB6a2V5ID0ge307XG5cbiAgICB6a2V5LnByb3RvY29sID0gXCJwbG9ua1wiO1xuXG4gICAgLy8gUmVhZCBQbG9uayBIZWFkZXJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMik7XG4gICAgY29uc3QgbjhxID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uOHEgPSBuOHE7XG4gICAgemtleS5xID0gYXdhaXQgcmVhZEJpZ0ludChmZCwgbjhxKTtcblxuICAgIGNvbnN0IG44ciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhyID0gbjhyO1xuICAgIHprZXkuciA9IGF3YWl0IHJlYWRCaWdJbnQoZmQsIG44cik7XG4gICAgemtleS5jdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbVEoemtleS5xLCBvcHRpb25zKTtcbiAgICB6a2V5Lm5WYXJzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uUHVibGljID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5kb21haW5TaXplID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5wb3dlciA9IGxvZzIoemtleS5kb21haW5TaXplKTtcbiAgICB6a2V5Lm5BZGRpdGlvbnMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm5Db25zdHJhaW50cyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkuazEgPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS5rMiA9IGF3YWl0IGZkLnJlYWQobjhyKTtcblxuICAgIHprZXkuUW0gPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlFsID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5RciA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUW8gPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlFjID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5TMSA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUzIgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlMzID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5YXzIgPSBhd2FpdCByZWFkRzIoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcblxuICAgIGF3YWl0IGVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiB6a2V5O1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyRkZsb25rKGZkLCBzZWN0aW9ucywgdG9PYmplY3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB6a2V5ID0ge307XG5cbiAgICB6a2V5LnByb3RvY29sID0gXCJmZmxvbmtcIjtcbiAgICB6a2V5LnByb3RvY29sSWQgPSBGRkxPTktfUFJPVE9DT0xfSUQ7XG5cbiAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgWktFWV9GRl9IRUFERVJfU0VDVElPTik7XG4gICAgY29uc3QgbjhxID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uOHEgPSBuOHE7XG4gICAgemtleS5xID0gYXdhaXQgcmVhZEJpZ0ludChmZCwgbjhxKTtcbiAgICB6a2V5LmN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUSh6a2V5LnEsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgbjhyID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uOHIgPSBuOHI7XG4gICAgemtleS5yID0gYXdhaXQgcmVhZEJpZ0ludChmZCwgbjhyKTtcblxuICAgIHprZXkublZhcnMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm5QdWJsaWMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5LmRvbWFpblNpemUgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5LnBvd2VyID0gbG9nMih6a2V5LmRvbWFpblNpemUpO1xuICAgIHprZXkubkFkZGl0aW9ucyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubkNvbnN0cmFpbnRzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG5cbiAgICB6a2V5LmsxID0gYXdhaXQgZmQucmVhZChuOHIpO1xuICAgIHprZXkuazIgPSBhd2FpdCBmZC5yZWFkKG44cik7XG5cbiAgICB6a2V5LnczID0gYXdhaXQgZmQucmVhZChuOHIpO1xuICAgIHprZXkudzQgPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS53OCA9IGF3YWl0IGZkLnJlYWQobjhyKTtcbiAgICB6a2V5LndyID0gYXdhaXQgZmQucmVhZChuOHIpO1xuXG4gICAgemtleS5YXzIgPSBhd2FpdCByZWFkRzIoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcblxuICAgIHprZXkuQzAgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcblxuICAgIGF3YWl0IGVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiB6a2V5O1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkWktleShmaWxlTmFtZSwgdG9PYmplY3QpIHtcbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IHJlYWRCaW5GaWxlKGZpbGVOYW1lLCBcInprZXlcIiwgMSk7XG5cbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgcmVhZEhlYWRlciQxKGZkLCBzZWN0aW9ucywgdG9PYmplY3QpO1xuXG4gICAgY29uc3QgRnIgPSBuZXcgRjFGaWVsZCh6a2V5LnIpO1xuICAgIGNvbnN0IFJyID0gU2NhbGFyLm1vZChTY2FsYXIuc2hsKDEsIHprZXkubjhyKjgpLCB6a2V5LnIpO1xuICAgIGNvbnN0IFJyaSA9IEZyLmludihScik7XG4gICAgY29uc3QgUnJpMiA9IEZyLm11bChScmksIFJyaSk7XG5cbiAgICBsZXQgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21RKHprZXkucSk7XG5cbiAgICAvLyBSZWFkIElDIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAzKTtcbiAgICB6a2V5LklDID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPD0gemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgY29uc3QgUCA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICAgICAgemtleS5JQy5wdXNoKFApO1xuICAgIH1cbiAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQ29lZnNcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA0KTtcbiAgICBjb25zdCBuQ0NvZWZzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5jY29lZnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bkNDb2VmczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG0gPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICAgICAgY29uc3QgYyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgICAgICBjb25zdCBzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgICAgIGNvbnN0IHYgPSBhd2FpdCByZWFkRnIyKCk7XG4gICAgICAgIHprZXkuY2NvZWZzLnB1c2goe1xuICAgICAgICAgICAgbWF0cml4OiBtLFxuICAgICAgICAgICAgY29uc3RyYWludDogYyxcbiAgICAgICAgICAgIHNpZ25hbDogcyxcbiAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICAvLyBSZWFkIEEgcG9pbnRzXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgNSk7XG4gICAgemtleS5BID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBjb25zdCBBID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgICAgICB6a2V5LkFbaV0gPSBBO1xuICAgIH1cbiAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQjFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA2KTtcbiAgICB6a2V5LkIxID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBjb25zdCBCMSA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcblxuICAgICAgICB6a2V5LkIxW2ldID0gQjE7XG4gICAgfVxuICAgIGF3YWl0IGVuZFJlYWRTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gUmVhZCBCMiBwb2ludHNcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA3KTtcbiAgICB6a2V5LkIyID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBjb25zdCBCMiA9IGF3YWl0IHJlYWRHMihmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICAgICAgemtleS5CMltpXSA9IEIyO1xuICAgIH1cbiAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQyBwb2ludHNcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA4KTtcbiAgICB6a2V5LkMgPSBbXTtcbiAgICBmb3IgKGxldCBpPXprZXkublB1YmxpYysxOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBjb25zdCBDID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuXG4gICAgICAgIHprZXkuQ1tpXSA9IEM7XG4gICAgfVxuICAgIGF3YWl0IGVuZFJlYWRTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gUmVhZCBIIHBvaW50c1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDkpO1xuICAgIHprZXkuaEV4cHMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgY29uc3QgSCA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICAgICAgemtleS5oRXhwcy5wdXNoKEgpO1xuICAgIH1cbiAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHprZXk7XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRnIyKC8qIHRvT2JqZWN0ICovKSB7XG4gICAgICAgIGNvbnN0IG4gPSBhd2FpdCByZWFkQmlnSW50KGZkLCB6a2V5Lm44cik7XG4gICAgICAgIHJldHVybiBGci5tdWwobiwgUnJpMik7XG4gICAgfVxuXG59XG5cblxuYXN5bmMgZnVuY3Rpb24gcmVhZENvbnRyaWJ1dGlvbiQxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpIHtcbiAgICBjb25zdCBjID0ge2RlbHRhOnt9fTtcbiAgICBjLmRlbHRhQWZ0ZXIgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgYy5kZWx0YS5nMV9zID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMuZGVsdGEuZzFfc3ggPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgYy5kZWx0YS5nMl9zcHggPSBhd2FpdCByZWFkRzIoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgYy50cmFuc2NyaXB0ID0gYXdhaXQgZmQucmVhZCg2NCk7XG4gICAgYy50eXBlID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG5cbiAgICBjb25zdCBwYXJhbUxlbmd0aCA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGN1clBvcyA9IGZkLnBvcztcbiAgICBsZXQgbGFzdFR5cGUgPTA7XG4gICAgd2hpbGUgKGZkLnBvcy1jdXJQb3MgPCBwYXJhbUxlbmd0aCkge1xuICAgICAgICBjb25zdCBidWZmVHlwZSA9IGF3YWl0IGZkLnJlYWQoMSk7XG4gICAgICAgIGlmIChidWZmVHlwZVswXTw9IGxhc3RUeXBlKSB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIGluIHRoZSBjb250cmlidXRpb24gbXVzdCBiZSBzb3J0ZWRcIik7XG4gICAgICAgIGxhc3RUeXBlID0gYnVmZlR5cGVbMF07XG4gICAgICAgIGlmIChidWZmVHlwZVswXT09MSkgeyAgICAgLy8gTmFtZVxuICAgICAgICAgICAgY29uc3QgYnVmZkxlbiA9IGF3YWl0IGZkLnJlYWQoMSk7XG4gICAgICAgICAgICBjb25zdCBidWZmU3RyID0gYXdhaXQgZmQucmVhZChidWZmTGVuWzBdKTtcbiAgICAgICAgICAgIGMubmFtZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWZmU3RyKTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmVHlwZVswXT09Mikge1xuICAgICAgICAgICAgY29uc3QgYnVmZkV4cCA9IGF3YWl0IGZkLnJlYWQoMSk7XG4gICAgICAgICAgICBjLm51bUl0ZXJhdGlvbnNFeHAgPSBidWZmRXhwWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZUeXBlWzBdPT0zKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmTGVuID0gYXdhaXQgZmQucmVhZCgxKTtcbiAgICAgICAgICAgIGMuYmVhY29uSGFzaCA9IGF3YWl0IGZkLnJlYWQoYnVmZkxlblswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbm90IHJlY29nbml6ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZkLnBvcyAhPSBjdXJQb3MgKyBwYXJhbUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbn1cblxuXG5hc3luYyBmdW5jdGlvbiByZWFkTVBDUGFyYW1zKGZkLCBjdXJ2ZSwgc2VjdGlvbnMpIHtcbiAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMTApO1xuICAgIGNvbnN0IHJlcyA9IHsgY29udHJpYnV0aW9uczogW119O1xuICAgIHJlcy5jc0hhc2ggPSBhd2FpdCBmZC5yZWFkKDY0KTtcbiAgICBjb25zdCBuID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPG47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbiQxKGZkLCBjdXJ2ZSk7XG4gICAgICAgIHJlcy5jb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuICAgIGF3YWl0IGVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQ29udHJpYnV0aW9uJDEoZmQsIGN1cnZlLCBjKSB7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIGMuZGVsdGFBZnRlcik7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIGMuZGVsdGEuZzFfcyk7XG4gICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIGMuZGVsdGEuZzFfc3gpO1xuICAgIGF3YWl0IHdyaXRlRzIoZmQsIGN1cnZlLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgYXdhaXQgZmQud3JpdGUoYy50cmFuc2NyaXB0KTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGMudHlwZSB8fCAwKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGlmIChjLm5hbWUpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goMSk7ICAgICAgLy8gUGFyYW0gTmFtZVxuICAgICAgICBjb25zdCBuYW1lRGF0YSA9IG5ldyBUZXh0RW5jb2RlcihcInV0Zi04XCIpLmVuY29kZShjLm5hbWUuc3Vic3RyaW5nKDAsNjQpKTtcbiAgICAgICAgcGFyYW1zLnB1c2gobmFtZURhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuYW1lRGF0YS5ieXRlTGVuZ3RoOyBpKyspIHBhcmFtcy5wdXNoKG5hbWVEYXRhW2ldKTtcbiAgICB9XG4gICAgaWYgKGMudHlwZSA9PSAxKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKDIpOyAgICAgIC8vIFBhcmFtIG51bUl0ZXJhdGlvbnNFeHBcbiAgICAgICAgcGFyYW1zLnB1c2goYy5udW1JdGVyYXRpb25zRXhwKTtcblxuICAgICAgICBwYXJhbXMucHVzaCgzKTsgICAgICAvLyBCZWFjb24gSGFzaFxuICAgICAgICBwYXJhbXMucHVzaChjLmJlYWNvbkhhc2guYnl0ZUxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjLmJlYWNvbkhhc2guYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChjLmJlYWNvbkhhc2hbaV0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxlbmd0aD4wKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc0J1ZmYgPSBuZXcgVWludDhBcnJheShwYXJhbXMpO1xuICAgICAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHBhcmFtc0J1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlKHBhcmFtc0J1ZmYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoMCk7XG4gICAgfVxuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlTVBDUGFyYW1zKGZkLCBjdXJ2ZSwgbXBjUGFyYW1zKSB7XG4gICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDEwKTtcbiAgICBhd2FpdCBmZC53cml0ZShtcGNQYXJhbXMuY3NIYXNoKTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHdyaXRlQ29udHJpYnV0aW9uJDEoZmQsIGN1cnZlLG1wY1BhcmFtcy5jb250cmlidXRpb25zW2ldKTtcbiAgICB9XG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkKTtcbn1cblxuZnVuY3Rpb24gaGFzaEcxKGhhc2hlciwgY3VydmUsIHApIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKTtcbiAgICBjdXJ2ZS5HMS50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBwKTtcbiAgICBoYXNoZXIudXBkYXRlKGJ1ZmYpO1xufVxuXG5mdW5jdGlvbiBoYXNoRzIoaGFzaGVyLGN1cnZlLCBwKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcyLkYubjgqMik7XG4gICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgcCk7XG4gICAgaGFzaGVyLnVwZGF0ZShidWZmKTtcbn1cblxuZnVuY3Rpb24gaGFzaFB1YktleShoYXNoZXIsIGN1cnZlLCBjKSB7XG4gICAgaGFzaEcxKGhhc2hlciwgY3VydmUsIGMuZGVsdGFBZnRlcik7XG4gICAgaGFzaEcxKGhhc2hlciwgY3VydmUsIGMuZGVsdGEuZzFfcyk7XG4gICAgaGFzaEcxKGhhc2hlciwgY3VydmUsIGMuZGVsdGEuZzFfc3gpO1xuICAgIGhhc2hHMihoYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgaGFzaGVyLnVwZGF0ZShjLnRyYW5zY3JpcHQpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlKGZkLCB3aXRuZXNzLCBwcmltZSkge1xuXG4gICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDEpO1xuICAgIGNvbnN0IG44ID0gKE1hdGguZmxvb3IoIChTY2FsYXIuYml0TGVuZ3RoKHByaW1lKSAtIDEpIC8gNjQpICsxKSo4O1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobjgpO1xuICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkLCBwcmltZSwgbjgpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIod2l0bmVzcy5sZW5ndGgpO1xuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZCwgMik7XG4gICAgZm9yIChsZXQgaT0wOyBpPHdpdG5lc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVCaWdJbnQoZmQsIHdpdG5lc3NbaV0sIG44KTtcbiAgICB9XG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQmluKGZkLCB3aXRuZXNzQmluLCBwcmltZSkge1xuXG4gICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDEpO1xuICAgIGNvbnN0IG44ID0gKE1hdGguZmxvb3IoIChTY2FsYXIuYml0TGVuZ3RoKHByaW1lKSAtIDEpIC8gNjQpICsxKSo4O1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobjgpO1xuICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkLCBwcmltZSwgbjgpO1xuICAgIGlmICh3aXRuZXNzQmluLmJ5dGVMZW5ndGggJSBuOCAhPSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2l0bmVzcyBsZW5ndGhcIik7XG4gICAgfVxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIod2l0bmVzc0Jpbi5ieXRlTGVuZ3RoIC8gbjgpO1xuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZCk7XG5cblxuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAyKTtcbiAgICBhd2FpdCBmZC53cml0ZSh3aXRuZXNzQmluKTtcbiAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFkZXIoZmQsIHNlY3Rpb25zKSB7XG5cbiAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMSk7XG4gICAgY29uc3QgbjggPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBxID0gYXdhaXQgcmVhZEJpZ0ludChmZCwgbjgpO1xuICAgIGNvbnN0IG5XaXRuZXNzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgcmV0dXJuIHtuOCwgcSwgbldpdG5lc3N9O1xuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWQoZmlsZU5hbWUpIHtcblxuICAgIGNvbnN0IHtmZCwgc2VjdGlvbnN9ID0gYXdhaXQgcmVhZEJpbkZpbGUoZmlsZU5hbWUsIFwid3Ruc1wiLCAyKTtcblxuICAgIGNvbnN0IHtuOCwgbldpdG5lc3N9ID0gYXdhaXQgcmVhZEhlYWRlcihmZCwgc2VjdGlvbnMpO1xuXG4gICAgYXdhaXQgc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDIpO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxuV2l0bmVzczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBhd2FpdCByZWFkQmlnSW50KGZkLCBuOCk7XG4gICAgICAgIHJlcy5wdXNoKHYpO1xuICAgIH1cbiAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbmNvbnN0IHtzdHJpbmdpZnlCaWdJbnRzOiBzdHJpbmdpZnlCaWdJbnRzJDR9ID0gdXRpbHM7XG5cbmFzeW5jIGZ1bmN0aW9uIGdyb3RoMTZQcm92ZSh6a2V5RmlsZU5hbWUsIHdpdG5lc3NGaWxlTmFtZSwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2ZkOiBmZFd0bnMsIHNlY3Rpb25zOiBzZWN0aW9uc1d0bnN9ID0gYXdhaXQgcmVhZEJpbkZpbGUod2l0bmVzc0ZpbGVOYW1lLCBcInd0bnNcIiwgMik7XG5cbiAgICBjb25zdCB3dG5zID0gYXdhaXQgcmVhZEhlYWRlcihmZFd0bnMsIHNlY3Rpb25zV3Rucyk7XG5cbiAgICBjb25zdCB7ZmQ6IGZkWktleSwgc2VjdGlvbnM6IHNlY3Rpb25zWktleX0gPSBhd2FpdCByZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyKTtcblxuICAgIGNvbnN0IHprZXkgPSBhd2FpdCByZWFkSGVhZGVyJDEoZmRaS2V5LCBzZWN0aW9uc1pLZXksIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgaWYgKCFTY2FsYXIuZXEoemtleS5yLCAgd3Rucy5xKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJ2ZSBvZiB0aGUgd2l0bmVzcyBkb2VzIG5vdCBtYXRjaCB0aGUgY3VydmUgb2YgdGhlIHByb3Zpbmcga2V5XCIpO1xuICAgIH1cblxuICAgIGlmICh3dG5zLm5XaXRuZXNzICE9IHprZXkublZhcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHdpdG5lc3MgbGVuZ3RoLiBDaXJjdWl0OiAke3prZXkublZhcnN9LCB3aXRuZXNzOiAke3d0bnMubldpdG5lc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSB6a2V5LmN1cnZlO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBHMiA9IGN1cnZlLkcyO1xuXG4gICAgY29uc3QgcG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIFd0bnNcIik7XG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCByZWFkU2VjdGlvbihmZFd0bnMsIHNlY3Rpb25zV3RucywgMik7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiUmVhZGluZyBDb2VmZnNcIik7XG4gICAgY29uc3QgYnVmZkNvZWZmcyA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA0KTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkJ1aWxkaW5nIEFCQ1wiKTtcbiAgICBjb25zdCBbYnVmZkFfVCwgYnVmZkJfVCwgYnVmZkNfVF0gPSBhd2FpdCBidWlsZEFCQzEoY3VydmUsIHprZXksIGJ1ZmZXaXRuZXNzLCBidWZmQ29lZmZzLCBsb2dnZXIpO1xuXG4gICAgY29uc3QgaW5jID0gcG93ZXIgPT0gRnIucyA/IGN1cnZlLkZyLnNoaWZ0IDogY3VydmUuRnIud1twb3dlcisxXTtcblxuICAgIGNvbnN0IGJ1ZmZBID0gYXdhaXQgRnIuaWZmdChidWZmQV9ULCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiSUZGVF9BXCIpO1xuICAgIGNvbnN0IGJ1ZmZBb2RkID0gYXdhaXQgRnIuYmF0Y2hBcHBseUtleShidWZmQSwgRnIuZSgxKSwgaW5jKTtcbiAgICBjb25zdCBidWZmQW9kZF9UID0gYXdhaXQgRnIuZmZ0KGJ1ZmZBb2RkLCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiRkZUX0FcIik7XG5cbiAgICBjb25zdCBidWZmQiA9IGF3YWl0IEZyLmlmZnQoYnVmZkJfVCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIklGRlRfQlwiKTtcbiAgICBjb25zdCBidWZmQm9kZCA9IGF3YWl0IEZyLmJhdGNoQXBwbHlLZXkoYnVmZkIsIEZyLmUoMSksIGluYyk7XG4gICAgY29uc3QgYnVmZkJvZGRfVCA9IGF3YWl0IEZyLmZmdChidWZmQm9kZCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIkZGVF9CXCIpO1xuXG4gICAgY29uc3QgYnVmZkMgPSBhd2FpdCBGci5pZmZ0KGJ1ZmZDX1QsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJJRkZUX0NcIik7XG4gICAgY29uc3QgYnVmZkNvZGQgPSBhd2FpdCBGci5iYXRjaEFwcGx5S2V5KGJ1ZmZDLCBGci5lKDEpLCBpbmMpO1xuICAgIGNvbnN0IGJ1ZmZDb2RkX1QgPSBhd2FpdCBGci5mZnQoYnVmZkNvZGQsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJGRlRfQ1wiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkpvaW4gQUJDXCIpO1xuICAgIGNvbnN0IGJ1ZmZQb2RkX1QgPSBhd2FpdCBqb2luQUJDKGN1cnZlLCB6a2V5LCBidWZmQW9kZF9ULCBidWZmQm9kZF9ULCBidWZmQ29kZF9ULCBsb2dnZXIpO1xuXG4gICAgbGV0IHByb29mID0ge307XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEEgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0EgPSBhd2FpdCByZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNSk7XG4gICAgcHJvb2YucGlfYSA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0EsIGJ1ZmZXaXRuZXNzLCBsb2dnZXIsIFwibXVsdGlleHAgQVwiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQjEgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0IxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDYpO1xuICAgIGxldCBwaWIxID0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoYnVmZkJhc2VzQjEsIGJ1ZmZXaXRuZXNzLCBsb2dnZXIsIFwibXVsdGlleHAgQjFcIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEIyIFBvaW50c1wiKTtcbiAgICBjb25zdCBidWZmQmFzZXNCMiA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA3KTtcbiAgICBwcm9vZi5waV9iID0gYXdhaXQgY3VydmUuRzIubXVsdGlFeHBBZmZpbmUoYnVmZkJhc2VzQjIsIGJ1ZmZXaXRuZXNzLCBsb2dnZXIsIFwibXVsdGlleHAgQjJcIik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIEMgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0MgPSBhd2FpdCByZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgOCk7XG4gICAgcHJvb2YucGlfYyA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0MsIGJ1ZmZXaXRuZXNzLnNsaWNlKCh6a2V5Lm5QdWJsaWMrMSkqY3VydmUuRnIubjgpLCBsb2dnZXIsIFwibXVsdGlleHAgQ1wiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgSCBQb2ludHNcIik7XG4gICAgY29uc3QgYnVmZkJhc2VzSCA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA5KTtcbiAgICBjb25zdCByZXNIID0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoYnVmZkJhc2VzSCwgYnVmZlBvZGRfVCwgbG9nZ2VyLCBcIm11bHRpZXhwIEhcIik7XG5cbiAgICBjb25zdCByID0gY3VydmUuRnIucmFuZG9tKCk7XG4gICAgY29uc3QgcyA9IGN1cnZlLkZyLnJhbmRvbSgpO1xuXG4gICAgcHJvb2YucGlfYSAgPSBHMS5hZGQoIHByb29mLnBpX2EsIHprZXkudmtfYWxwaGFfMSApO1xuICAgIHByb29mLnBpX2EgID0gRzEuYWRkKCBwcm9vZi5waV9hLCBHMS50aW1lc0ZyKCB6a2V5LnZrX2RlbHRhXzEsIHIgKSk7XG5cbiAgICBwcm9vZi5waV9iICA9IEcyLmFkZCggcHJvb2YucGlfYiwgemtleS52a19iZXRhXzIgKTtcbiAgICBwcm9vZi5waV9iICA9IEcyLmFkZCggcHJvb2YucGlfYiwgRzIudGltZXNGciggemtleS52a19kZWx0YV8yLCBzICkpO1xuXG4gICAgcGliMSA9IEcxLmFkZCggcGliMSwgemtleS52a19iZXRhXzEgKTtcbiAgICBwaWIxID0gRzEuYWRkKCBwaWIxLCBHMS50aW1lc0ZyKCB6a2V5LnZrX2RlbHRhXzEsIHMgKSk7XG5cbiAgICBwcm9vZi5waV9jID0gRzEuYWRkKHByb29mLnBpX2MsIHJlc0gpO1xuXG5cbiAgICBwcm9vZi5waV9jICA9IEcxLmFkZCggcHJvb2YucGlfYywgRzEudGltZXNGciggcHJvb2YucGlfYSwgcyApKTtcbiAgICBwcm9vZi5waV9jICA9IEcxLmFkZCggcHJvb2YucGlfYywgRzEudGltZXNGciggcGliMSwgciApKTtcbiAgICBwcm9vZi5waV9jICA9IEcxLmFkZCggcHJvb2YucGlfYywgRzEudGltZXNGciggemtleS52a19kZWx0YV8xLCBGci5uZWcoRnIubXVsKHIscykgKSkpO1xuXG5cbiAgICBsZXQgcHVibGljU2lnbmFscyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaT0xOyBpPD0gemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgY29uc3QgYiA9IGJ1ZmZXaXRuZXNzLnNsaWNlKGkqRnIubjgsIGkqRnIubjgrRnIubjgpO1xuICAgICAgICBwdWJsaWNTaWduYWxzLnB1c2goU2NhbGFyLmZyb21ScHJMRShiKSk7XG4gICAgfVxuXG4gICAgcHJvb2YucGlfYSA9IEcxLnRvT2JqZWN0KEcxLnRvQWZmaW5lKHByb29mLnBpX2EpKTtcbiAgICBwcm9vZi5waV9iID0gRzIudG9PYmplY3QoRzIudG9BZmZpbmUocHJvb2YucGlfYikpO1xuICAgIHByb29mLnBpX2MgPSBHMS50b09iamVjdChHMS50b0FmZmluZShwcm9vZi5waV9jKSk7XG5cbiAgICBwcm9vZi5wcm90b2NvbCA9IFwiZ3JvdGgxNlwiO1xuICAgIHByb29mLmN1cnZlID0gY3VydmUubmFtZTtcblxuICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIGF3YWl0IGZkV3Rucy5jbG9zZSgpO1xuXG4gICAgcHJvb2YgPSBzdHJpbmdpZnlCaWdJbnRzJDQocHJvb2YpO1xuICAgIHB1YmxpY1NpZ25hbHMgPSBzdHJpbmdpZnlCaWdJbnRzJDQocHVibGljU2lnbmFscyk7XG5cbiAgICByZXR1cm4ge3Byb29mLCBwdWJsaWNTaWduYWxzfTtcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBidWlsZEFCQzEoY3VydmUsIHprZXksIHdpdG5lc3MsIGNvZWZmcywgbG9nZ2VyKSB7XG4gICAgY29uc3QgbjggPSBjdXJ2ZS5Gci5uODtcbiAgICBjb25zdCBzQ29lZiA9IDQqMyArIHprZXkubjhyO1xuICAgIGNvbnN0IG5Db2VmID0gKGNvZWZmcy5ieXRlTGVuZ3RoLTQpIC8gc0NvZWY7XG5cbiAgICBjb25zdCBvdXRCdWZmQSA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogbjgpO1xuICAgIGNvbnN0IG91dEJ1ZmZCID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBuOCk7XG4gICAgY29uc3Qgb3V0QnVmZkMgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIG44KTtcblxuICAgIGNvbnN0IG91dEJ1ZiA9IFsgb3V0QnVmZkEsIG91dEJ1ZmZCIF07XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Db2VmOyBpKyspIHtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYFFBUCBBQjogJHtpfS8ke25Db2VmfWApO1xuICAgICAgICBjb25zdCBidWZmQ29lZiA9IGNvZWZmcy5zbGljZSg0K2kqc0NvZWYsIDQraSpzQ29lZitzQ29lZik7XG4gICAgICAgIGNvbnN0IGJ1ZmZDb2VmViA9IG5ldyBEYXRhVmlldyhidWZmQ29lZi5idWZmZXIpO1xuICAgICAgICBjb25zdCBtPSBidWZmQ29lZlYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBjb25zdCBjPSBidWZmQ29lZlYuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgICAgICBjb25zdCBzPSBidWZmQ29lZlYuZ2V0VWludDMyKDgsIHRydWUpO1xuICAgICAgICBjb25zdCBjb2VmID0gYnVmZkNvZWYuc2xpY2UoMTIsIDEyK244KTtcbiAgICAgICAgb3V0QnVmW21dLnNldChcbiAgICAgICAgICAgIGN1cnZlLkZyLmFkZChcbiAgICAgICAgICAgICAgICBvdXRCdWZbbV0uc2xpY2UoYypuOCwgYypuOCtuOCksXG4gICAgICAgICAgICAgICAgY3VydmUuRnIubXVsKGNvZWYsIHdpdG5lc3Muc2xpY2UocypuOCwgcypuOCtuOCkpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYypuOFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1ZyhgUUFQIEM6ICR7aX0vJHt6a2V5LmRvbWFpblNpemV9YCk7XG4gICAgICAgIG91dEJ1ZmZDLnNldChcbiAgICAgICAgICAgIGN1cnZlLkZyLm11bChcbiAgICAgICAgICAgICAgICBvdXRCdWZmQS5zbGljZShpKm44LCBpKm44K244KSxcbiAgICAgICAgICAgICAgICBvdXRCdWZmQi5zbGljZShpKm44LCBpKm44K244KSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBpKm44XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtvdXRCdWZmQSwgb3V0QnVmZkIsIG91dEJ1ZmZDXTtcblxufVxuXG4vKlxuYXN5bmMgZnVuY3Rpb24gYnVpbGRBQkMoY3VydmUsIHprZXksIHdpdG5lc3MsIGNvZWZmcywgbG9nZ2VyKSB7XG4gICAgY29uc3QgY29uY3VycmVuY3kgPSBjdXJ2ZS50bS5jb25jdXJyZW5jeTtcbiAgICBjb25zdCBzQ29lZiA9IDQqMyArIHprZXkubjhyO1xuXG4gICAgbGV0IGdldFVpbnQzMjtcblxuICAgIGlmIChjb2VmZnMgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgY29lZmZzRFYgPSBbXTtcbiAgICAgICAgY29uc3QgUEFHRV9MRU4gPSBjb2VmZnMuYnVmZmVyc1swXS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgY29lZmZzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvZWZmc0RWLnB1c2gobmV3IERhdGFWaWV3KGNvZWZmcy5idWZmZXJzW2ldLmJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgICAgIGdldFVpbnQzMiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2VmZnNEVltNYXRoLmZsb29yKHBvcy9QQUdFX0xFTildLmdldFVpbnQzMihwb3MgJSBQQUdFX0xFTiwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29lZmZzRFYgPSBuZXcgRGF0YVZpZXcoY29lZmZzLmJ1ZmZlciwgY29lZmZzLmJ5dGVPZmZzZXQsIGNvZWZmcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgZ2V0VWludDMyID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvZWZmc0RWLmdldFVpbnQzMihwb3MsIHRydWUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRzUGVyQ2h1bmsgPSBNYXRoLmZsb29yKHprZXkuZG9tYWluU2l6ZS9jb25jdXJyZW5jeSk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcblxuICAgIGNvbnN0IGN1dFBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxjb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgIGN1dFBvaW50cy5wdXNoKCBnZXRDdXRQb2ludCggTWF0aC5mbG9vcihpKmVsZW1lbnRzUGVyQ2h1bmspICkpO1xuICAgIH1cbiAgICBjdXRQb2ludHMucHVzaChjb2VmZnMuYnl0ZUxlbmd0aCk7XG5cbiAgICBjb25zdCBjaHVua1NpemUgPSAyKioyNjtcbiAgICBmb3IgKGxldCBzPTAgOyBzPHprZXkublZhcnMgOyBzKz0gY2h1bmtTaXplKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgUUFQICR7c306ICR7c30vJHt6a2V5Lm5WYXJzfWApO1xuICAgICAgICBjb25zdCBucz0gTWF0aC5taW4oemtleS5uVmFycy1zLCBjaHVua1NpemUgKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBlbGVtZW50c1BlckNodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gemtleS5kb21haW5TaXplIC0gaSplbGVtZW50c1BlckNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG5cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogY29lZmZzLnNsaWNlKGN1dFBvaW50c1tpXSwgY3V0UG9pbnRzW2krMV0pfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IHdpdG5lc3Muc2xpY2UocypjdXJ2ZS5Gci5uOCwgKHMrbnMpKmN1cnZlLkZyLm44KX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMywgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDQsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwicWFwX2J1aWxkQUJDXCIsIHBhcmFtczpbXG4gICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAge3ZhbDogKGN1dFBvaW50c1tpKzFdIC0gY3V0UG9pbnRzW2ldKS9zQ29lZn0sXG4gICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICAgICAge3ZhcjogM30sXG4gICAgICAgICAgICAgICAge3ZhcjogNH0sXG4gICAgICAgICAgICAgICAge3ZhbDogaSplbGVtZW50c1BlckNodW5rfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICB7dmFsOiBzfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBuc31cbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAxLCB2YXI6IDMsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMiwgdmFyOiA0LCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goY3VydmUudG0ucXVldWVBY3Rpb24odGFzaykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgIGNvbnN0IG5Hcm91cHMgPSByZXN1bHQubGVuZ3RoIC8gY29uY3VycmVuY3k7XG4gICAgaWYgKG5Hcm91cHM+MSkge1xuICAgICAgICBjb25zdCBwcm9taXNlczIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2s9W107XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDAsIGxlbjogcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMSwgbGVuOiByZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgbT0wOyBtPDM7IG0rKykge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIlNFVFwiLCB2YXI6IDAsIGJ1ZmY6IHJlc3VsdFtpXVttXX0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHM9MTsgczxuR3JvdXBzOyBzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiU0VUXCIsIHZhcjogMSwgYnVmZjogcmVzdWx0W3MqY29uY3VycmVuY3kgKyBpXVttXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJxYXBfYmF0Y2hBZGRcIiwgcGFyYW1zOltcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiByZXN1bHRbaV1bbV0ubGVuZ3RoL2N1cnZlLkZyLm44fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogbSwgdmFyOiAwLCBsZW46IHJlc3VsdFtpXVttXS5sZW5ndGh9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzMi5wdXNoKGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlczIpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dEJ1ZmZBID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBjdXJ2ZS5Gci5uOCk7XG4gICAgY29uc3Qgb3V0QnVmZkIgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIGN1cnZlLkZyLm44KTtcbiAgICBjb25zdCBvdXRCdWZmQyA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogY3VydmUuRnIubjgpO1xuICAgIGxldCBwPTA7XG4gICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRCdWZmQS5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgb3V0QnVmZkIuc2V0KHJlc3VsdFtpXVsxXSwgcCk7XG4gICAgICAgIG91dEJ1ZmZDLnNldChyZXN1bHRbaV1bMl0sIHApO1xuICAgICAgICBwICs9IHJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBbb3V0QnVmZkEsIG91dEJ1ZmZCLCBvdXRCdWZmQ107XG5cbiAgICBmdW5jdGlvbiBnZXRDdXRQb2ludCh2KSB7XG4gICAgICAgIGxldCBtID0gMDtcbiAgICAgICAgbGV0IG4gPSBnZXRVaW50MzIoMCk7XG4gICAgICAgIHdoaWxlIChtIDwgbikge1xuICAgICAgICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKChuICsgbSkgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHZhID0gZ2V0VWludDMyKDQgKyBrKnNDb2VmICsgNCk7XG4gICAgICAgICAgICBpZiAodmEgPiB2KSB7XG4gICAgICAgICAgICAgICAgbiA9IGsgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YSA8IHYpIHtcbiAgICAgICAgICAgICAgICBtID0gayArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiA0ICsgbSpzQ29lZjtcbiAgICB9XG59XG4qL1xuXG5hc3luYyBmdW5jdGlvbiBqb2luQUJDKGN1cnZlLCB6a2V5LCBhLCBiLCBjLCBsb2dnZXIpIHtcbiAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDEgPDwgMjI7XG5cbiAgICBjb25zdCBuOCA9IGN1cnZlLkZyLm44O1xuICAgIGNvbnN0IG5FbGVtZW50cyA9IE1hdGguZmxvb3IoYS5ieXRlTGVuZ3RoIC8gY3VydmUuRnIubjgpO1xuXG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxuRWxlbWVudHM7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBKb2luQUJDOiAke2l9LyR7bkVsZW1lbnRzfWApO1xuICAgICAgICBjb25zdCBuPSBNYXRoLm1pbihuRWxlbWVudHMgLSBpLCBNQVhfQ0hVTktfU0laRSk7XG5cbiAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgIGNvbnN0IGFDaHVuayA9IGEuc2xpY2UoaSpuOCwgKGkgKyBuKSpuOCApO1xuICAgICAgICBjb25zdCBiQ2h1bmsgPSBiLnNsaWNlKGkqbjgsIChpICsgbikqbjggKTtcbiAgICAgICAgY29uc3QgY0NodW5rID0gYy5zbGljZShpKm44LCAoaSArIG4pKm44ICk7XG5cbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBhQ2h1bmt9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBiQ2h1bmt9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAyLCBidWZmOiBjQ2h1bmt9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAzLCBsZW46IG4qbjh9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwicWFwX2pvaW5BQkNcIiwgcGFyYW1zOltcbiAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAge3ZhcjogM30sXG4gICAgICAgIF19KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwiZnJtX2JhdGNoRnJvbU1vbnRnb21lcnlcIiwgcGFyYW1zOltcbiAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICAgICAge3ZhbDogbn0sXG4gICAgICAgICAgICB7dmFyOiAzfVxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMywgbGVuOiBuKm44fSk7XG4gICAgICAgIHByb21pc2VzLnB1c2goY3VydmUudG0ucXVldWVBY3Rpb24odGFzaykpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgIGxldCBvdXRCdWZmO1xuICAgIGlmIChhIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgIG91dEJ1ZmYgPSBuZXcgQmlnQnVmZmVyKGEuYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0QnVmZiA9IG5ldyBVaW50OEFycmF5KGEuYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgbGV0IHA9MDtcbiAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dEJ1ZmYuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgIHAgKz0gcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dEJ1ZmY7XG59XG5cbi8qXG5cbkNvcHlyaWdodCAyMDIwIDBLSU1TIGFzc29jaWF0aW9uLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZnVuY3Rpb24gZmxhdEFycmF5KGEpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgZmlsbEFycmF5KHJlcywgYSk7XG4gICAgcmV0dXJuIHJlcztcblxuICAgIGZ1bmN0aW9uIGZpbGxBcnJheShyZXMsIGEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZpbGxBcnJheShyZXMsIGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnB1c2goYSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFJlZiBodHRwczovL2dpdGh1Yi5jb20vaWRlbjMvY2lyY29tL2NvbW1pdC9lYzYzODhjZjZlYjYyNDYzNTM5Y2I0YzQwY2MzY2VhZTk4MjZkZTE5XG5mdW5jdGlvbiBub3JtYWxpemUobiwgcHJpbWUpIHtcbiAgICBsZXQgcmVzID0gQmlnSW50KG4pICUgcHJpbWU7XG4gICAgaWYgKHJlcyA8IDApIHJlcyArPSBwcmltZTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBmbnZIYXNoKHN0cikge1xuICAgIGNvbnN0IHVpbnQ2NF9tYXggPSBCaWdJbnQoMikgKiogQmlnSW50KDY0KTtcbiAgICBsZXQgaGFzaCA9IEJpZ0ludChcIjB4Q0JGMjlDRTQ4NDIyMjMyNVwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBoYXNoIF49IEJpZ0ludChzdHJbaV0uY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIGhhc2ggKj0gQmlnSW50KDB4MTAwMDAwMDAxQjMpO1xuICAgICAgICBoYXNoICU9IHVpbnQ2NF9tYXg7XG4gICAgfVxuICAgIGxldCBzaGFzaCA9IGhhc2gudG9TdHJpbmcoMTYpO1xuICAgIGxldCBuID0gMTYgLSBzaGFzaC5sZW5ndGg7XG4gICAgc2hhc2ggPSBcIjBcIi5yZXBlYXQobikuY29uY2F0KHNoYXNoKTtcbiAgICByZXR1cm4gc2hhc2g7XG59XG5cbi8vIE5vdGUgdGhhdCB0aGlzIHBhZHMgemVyb3NcbmZ1bmN0aW9uIHRvQXJyYXkzMihzLCBzaXplKSB7XG4gICAgY29uc3QgcmVzID0gW107IC8vbmV3IFVpbnQzMkFycmF5KHNpemUpOyAvL2hhcyBubyB1bnNoaWZ0XG4gICAgbGV0IHJlbSA9IEJpZ0ludChzKTtcbiAgICBjb25zdCByYWRpeCA9IEJpZ0ludCgweDEwMDAwMDAwMCk7XG4gICAgd2hpbGUgKHJlbSkge1xuICAgICAgICByZXMudW5zaGlmdChOdW1iZXIocmVtICUgcmFkaXgpKTtcbiAgICAgICAgcmVtID0gcmVtIC8gcmFkaXg7XG4gICAgfVxuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGxldCBpID0gc2l6ZSAtIHJlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICAgICAgcmVzLnVuc2hpZnQoMCk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLyogZ2xvYmFscyBXZWJBc3NlbWJseSAqL1xuXG5hc3luYyBmdW5jdGlvbiBidWlsZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgbGV0IHdjO1xuICAgIGxldCBtZW1vcnk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBPbmx5IGNpcmNvbSAyIGltcGxlbWVudHMgdmVyc2lvbiBsb29rdXAgdGhyb3VnaCBleHBvcnRzIGluIHRoZSBXQVNNXG4gICAgLy8gV2UgZGVmYXVsdCB0byBgMWAgYW5kIHVwZGF0ZSBpZiB3ZSBzZWUgdGhlIGBnZXRWZXJzaW9uYCBleHBvcnQgKG1ham9yIHZlcnNpb24pXG4gICAgLy8gVGhlc2UgYXJlIHVwZGF0ZWQgYWZ0ZXIgdGhlIGluc3RhbmNlIGlzIGluc3RhbnRpYXRlZCwgYXNzdW1pbmcgdGhlIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlXG4gICAgbGV0IG1ham9yVmVyc2lvbiA9IDE7XG4gICAgLy8gQWZ0ZXIgQ2lyY29tIDIuMC43LCBCbGFpbmUgYWRkZWQgZXhwb3J0ZWQgZnVuY3Rpb25zIGZvciBnZXR0aW5nIG1pbm9yIGFuZCBwYXRjaCB2ZXJzaW9uc1xuICAgIGxldCBtaW5vclZlcnNpb24gPSAwO1xuICAgIC8vIElmIHdlIGNhbid0IGxvb2sgdXAgdGhlIHBhdGNoIHZlcnNpb24sIGFzc3VtZSB0aGUgbG93ZXN0XG4gICAgbGV0IHBhdGNoVmVyc2lvbiA9IDA7XG5cbiAgICBsZXQgY29kZUlzV2ViQXNzZW1ibHlJbnN0YW5jZSA9IGZhbHNlO1xuXG4gICAgLy8gSWYgY29kZSBpcyBhbHJlYWR5IHByZXBhcmVkIFdlYkFzc2VtYmx5Lkluc3RhbmNlLCB3ZSB1c2UgaXQgZGlyZWN0bHlcbiAgICBpZiAoY29kZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lkluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlID0gY29kZTtcbiAgICAgICAgY29kZUlzV2ViQXNzZW1ibHlJbnN0YW5jZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG1lbW9yeVNpemUgPSAzMjc2NztcblxuICAgICAgICBpZiAob3B0aW9ucy5tZW1vcnlTaXplKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBpbnRcbiAgICAgICAgICAgIG1lbW9yeVNpemUgPSBwYXJzZUludChvcHRpb25zLm1lbW9yeVNpemUpO1xuICAgICAgICAgICAgaWYgKG1lbW9yeVNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtZW1vcnkgc2l6ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZW1vcnlBbGxvY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKCFtZW1vcnlBbGxvY2F0ZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDogbWVtb3J5U2l6ZX0pO1xuICAgICAgICAgICAgICAgIG1lbW9yeUFsbG9jYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVtb3J5U2l6ZSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGFsbG9jYXRlIFwiICsgbWVtb3J5U2l6ZSAqIDEwMjQgKiA2NCArIFwiIGJ5dGVzLiBUaGlzIG1heSBjYXVzZSBzZXZlcmUgaW5zdGFiaWxpdHkuIFRyeWluZyB3aXRoIFwiICsgbWVtb3J5U2l6ZSAqIDEwMjQgKiA2NCAvIDIgKyBcIiBieXRlc1wiKTtcbiAgICAgICAgICAgICAgICBtZW1vcnlTaXplID0gTWF0aC5mbG9vcihtZW1vcnlTaXplIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3YXNtTW9kdWxlID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShjb2RlKTtcblxuICAgICAgICBsZXQgZXJyU3RyID0gXCJcIjtcbiAgICAgICAgbGV0IG1zZ1N0ciA9IFwiXCI7XG5cbiAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh3YXNtTW9kdWxlLCB7XG4gICAgICAgICAgICBlbnY6IHtcbiAgICAgICAgICAgICAgICBcIm1lbW9yeVwiOiBtZW1vcnlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAgICAgcHJpbnREZWJ1ZyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJpbnREZWJ1ZzpcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uSGFuZGxlcjogZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IFwiU2lnbmFsIG5vdCBmb3VuZC4gXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJUb28gbWFueSBzaWduYWxzIHNldC4gXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJTaWduYWwgYWxyZWFkeSBzZXQuIFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IFwiQXNzZXJ0IEZhaWxlZC4gXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJOb3QgZW5vdWdoIG1lbW9yeS4gXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJJbnB1dCBzaWduYWwgYXJyYXkgYWNjZXNzIGV4Y2VlZHMgdGhlIHNpemUuIFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJVbmtub3duIGVycm9yLiBcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRVJST1I6IFwiLCBjb2RlLCBlcnJTdHIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyICsgZXJyU3RyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEEgbmV3IHdheSBvZiBsb2dnaW5nIG1lc3NhZ2VzIHdhcyBhZGRlZCBpbiBDaXJjb20gMi4wLjcgdGhhdCByZXF1aXJlcyAyIG5ldyBpbXBvcnRzXG4gICAgICAgICAgICAgICAgLy8gYHByaW50RXJyb3JNZXNzYWdlYCBhbmQgYHdyaXRlQnVmZmVyTWVzc2FnZWAuXG4gICAgICAgICAgICAgICAgcHJpbnRFcnJvck1lc3NhZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyICs9IGdldE1lc3NhZ2UoKSArIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3cml0ZUJ1ZmZlck1lc3NhZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gZ2V0TWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBbnkgY2FsbHMgdG8gYGxvZygpYCB3aWxsIGFsd2F5cyBlbmQgd2l0aCBhIGBcXG5gLCBzbyB0aGF0J3Mgd2hlbiB3ZSBwcmludCBhbmQgcmVzZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZyA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnU3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1N0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBidWZmZXJlZCBvdGhlciBjb250ZW50LCBwdXQgYSBzcGFjZSBpbiBiZXR3ZWVuIHRoZSBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1zZ1N0ciAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1N0ciArPSBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gYXBwZW5kIHRoZSBtZXNzYWdlIHRvIHRoZSBtZXNzYWdlIHdlIGFyZSBjcmVhdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnU3RyICs9IG1zZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2hvd1NoYXJlZFJXTWVtb3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlZF9yd19tZW1vcnlfc2l6ZSA9IGluc3RhbmNlLmV4cG9ydHMuZ2V0RmllbGROdW1MZW4zMigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDMyQXJyYXkoc2hhcmVkX3J3X21lbW9yeV9zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaGFyZWRfcndfbWVtb3J5X3NpemU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW3NoYXJlZF9yd19tZW1vcnlfc2l6ZSAtIDEgLSBqXSA9IGluc3RhbmNlLmV4cG9ydHMucmVhZFNoYXJlZFJXTWVtb3J5KGopO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2lyY29tIDIuMC43LCB0aGV5IGNoYW5nZWQgdGhlIGxvZygpIGZ1bmN0aW9uIHRvIGFsbG93IHN0cmluZ3MgYW5kIGNoYW5nZWQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIG91dHB1dCBBUEkuIFRoaXMgc21vb3RoZXMgb3ZlciB0aGUgYnJlYWtpbmcgY2hhbmdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAobWFqb3JWZXJzaW9uID49IDIgJiYgKG1pbm9yVmVyc2lvbiA+PSAxIHx8IHBhdGNoVmVyc2lvbiA+PSA3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYnVmZmVyZWQgb3RoZXIgY29udGVudCwgcHV0IGEgc3BhY2UgaW4gYmV0d2VlbiB0aGUgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtc2dTdHIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2dTdHIgKz0gXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIGFwcGVuZCB0aGUgdmFsdWUgdG8gdGhlIG1lc3NhZ2Ugd2UgYXJlIGNyZWF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAoU2NhbGFyLmZyb21BcnJheShhcnIsIDB4MTAwMDAwMDAwKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1N0ciArPSBtc2c7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhTY2FsYXIuZnJvbUFycmF5KGFyciwgMHgxMDAwMDAwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChjb2RlLCBwc3RyLCBhLCBiLCBjLCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJTdHI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSBwMnN0cihwc3RyKSArIFwiIFwiICsgd2MuZ2V0RnIoYikudG9TdHJpbmcoKSArIFwiICE9IFwiICsgd2MuZ2V0RnIoYykudG9TdHJpbmcoKSArIFwiIFwiICsgcDJzdHIoZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gcDJzdHIocHN0cikgKyBcIiBcIiArIHdjLmdldEZyKGIpLnRvU3RyaW5nKCkgKyBcIiBcIiArIHAyc3RyKGMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChjb2RlID09PSA1KSAmJiAob3B0aW9ucy5zeW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSBwMnN0cihwc3RyKSArIFwiIFwiICsgb3B0aW9ucy5zeW0ubGFiZWxJZHgyTmFtZVtjXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9IHAyc3RyKHBzdHIpICsgXCIgXCIgKyBhICsgXCIgXCIgKyBiICsgXCIgXCIgKyBjICsgXCIgXCIgKyBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IFwiLCBjb2RlLCBlcnJTdHIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyU3RyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvZzogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cod2MuZ2V0RnIoYSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsb2dHZXRTaWduYWw6IGZ1bmN0aW9uIChzaWduYWwsIHBWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nR2V0U2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZ0dldFNpZ25hbChzaWduYWwsIHdjLmdldEZyKHBWYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbG9nU2V0U2lnbmFsOiBmdW5jdGlvbiAoc2lnbmFsLCBwVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvZ1NldFNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2dTZXRTaWduYWwoc2lnbmFsLCB3Yy5nZXRGcihwVmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvZ1N0YXJ0Q29tcG9uZW50OiBmdW5jdGlvbiAoY0lkeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dTdGFydENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2dTdGFydENvbXBvbmVudChjSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbG9nRmluaXNoQ29tcG9uZW50OiBmdW5jdGlvbiAoY0lkeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dGaW5pc2hDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nRmluaXNoQ29tcG9uZW50KGNJZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmV4cG9ydHMuZ2V0VmVyc2lvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbWFqb3JWZXJzaW9uID0gaW5zdGFuY2UuZXhwb3J0cy5nZXRWZXJzaW9uKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZXhwb3J0cy5nZXRNaW5vclZlcnNpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG1pbm9yVmVyc2lvbiA9IGluc3RhbmNlLmV4cG9ydHMuZ2V0TWlub3JWZXJzaW9uKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZXhwb3J0cy5nZXRQYXRjaFZlcnNpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHBhdGNoVmVyc2lvbiA9IGluc3RhbmNlLmV4cG9ydHMuZ2V0UGF0Y2hWZXJzaW9uKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2FuaXR5Q2hlY2sgPVxuICAgICAgICBvcHRpb25zICYmXG4gICAgICAgIChcbiAgICAgICAgICAgIG9wdGlvbnMuc2FuaXR5Q2hlY2sgfHxcbiAgICAgICAgICAgIG9wdGlvbnMubG9nR2V0U2lnbmFsIHx8XG4gICAgICAgICAgICBvcHRpb25zLmxvZ1NldFNpZ25hbCB8fFxuICAgICAgICAgICAgb3B0aW9ucy5sb2dTdGFydENvbXBvbmVudCB8fFxuICAgICAgICAgICAgb3B0aW9ucy5sb2dGaW5pc2hDb21wb25lbnRcbiAgICAgICAgKTtcblxuICAgIC8vIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIG1ham9yIHZlcnNpb24gMiBpbiBjYXNlIHRoZXJlJ3MgYSBjaXJjb20gdjMgaW4gdGhlIGZ1dHVyZVxuICAgIGlmIChtYWpvclZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgd2MgPSBuZXcgV2l0bmVzc0NhbGN1bGF0b3JDaXJjb20yKGluc3RhbmNlLCBzYW5pdHlDaGVjayk7XG4gICAgfSBlbHNlIGlmIChtYWpvclZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgaWYgKGNvZGVJc1dlYkFzc2VtYmx5SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGluZyBjb2RlIGZyb20gV2ViQXNzZW1ibHkgaW5zdGFuY2UgaXMgbm90IHN1cHBvcnRlZCBmb3IgY2lyY29tIHZlcnNpb24gMScpO1xuICAgICAgICB9XG4gICAgICAgIHdjID0gbmV3IFdpdG5lc3NDYWxjdWxhdG9yQ2lyY29tMShtZW1vcnksIGluc3RhbmNlLCBzYW5pdHlDaGVjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaXJjb20gdmVyc2lvbjogJHttYWpvclZlcnNpb259YCk7XG4gICAgfVxuICAgIHJldHVybiB3YztcblxuICAgIGZ1bmN0aW9uIGdldE1lc3NhZ2UoKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgbGV0IGMgPSBpbnN0YW5jZS5leHBvcnRzLmdldE1lc3NhZ2VDaGFyKCk7XG4gICAgICAgIHdoaWxlIChjICE9PSAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICBjID0gaW5zdGFuY2UuZXhwb3J0cy5nZXRNZXNzYWdlQ2hhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHAyc3RyKHApIHtcbiAgICAgICAgY29uc3QgaTggPSBuZXcgVWludDhBcnJheShtZW1vcnkuYnVmZmVyKTtcblxuICAgICAgICBjb25zdCBieXRlcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpOFtwICsgaV0gPiAwOyBpKyspIGJ5dGVzLnB1c2goaThbcCArIGldKTtcblxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG4gICAgfVxufVxuXG5jbGFzcyBXaXRuZXNzQ2FsY3VsYXRvckNpcmNvbTEge1xuICAgIGNvbnN0cnVjdG9yKG1lbW9yeSwgaW5zdGFuY2UsIHNhbml0eUNoZWNrKSB7XG4gICAgICAgIHRoaXMubWVtb3J5ID0gbWVtb3J5O1xuICAgICAgICB0aGlzLmkzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuXG4gICAgICAgIHRoaXMubjMyID0gKHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRGckxlbigpID4+IDIpIC0gMjtcbiAgICAgICAgY29uc3QgcFJhd1ByaW1lID0gdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldFBSYXdQcmltZSgpO1xuXG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSh0aGlzLm4zMik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uMzI7IGkrKykge1xuICAgICAgICAgICAgYXJyW3RoaXMubjMyIC0gMSAtIGldID0gdGhpcy5pMzJbKHBSYXdQcmltZSA+PiAyKSArIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmltZSA9IFNjYWxhci5mcm9tQXJyYXkoYXJyLCAweDEwMDAwMDAwMCk7XG5cbiAgICAgICAgdGhpcy5GciA9IG5ldyBGMUZpZWxkKHRoaXMucHJpbWUpO1xuXG4gICAgICAgIHRoaXMubWFzazMyID0gU2NhbGFyLmZyb21TdHJpbmcoXCJGRkZGRkZGRlwiLCAxNik7XG4gICAgICAgIHRoaXMuTlZhcnMgPSB0aGlzLmluc3RhbmNlLmV4cG9ydHMuZ2V0TlZhcnMoKTtcbiAgICAgICAgdGhpcy5uNjQgPSBNYXRoLmZsb29yKCh0aGlzLkZyLmJpdExlbmd0aCAtIDEpIC8gNjQpICsgMTtcbiAgICAgICAgdGhpcy5SID0gdGhpcy5Gci5lKFNjYWxhci5zaGlmdExlZnQoMSwgdGhpcy5uNjQgKiA2NCkpO1xuICAgICAgICB0aGlzLlJJbnYgPSB0aGlzLkZyLmludih0aGlzLlIpO1xuICAgICAgICB0aGlzLnNhbml0eUNoZWNrID0gc2FuaXR5Q2hlY2s7XG4gICAgfVxuXG4gICAgY2lyY29tX3ZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGFzeW5jIF9kb0NhbGN1bGF0ZVdpdG5lc3MoaW5wdXQsIHNhbml0eUNoZWNrKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5pbml0KCh0aGlzLnNhbml0eUNoZWNrIHx8IHNhbml0eUNoZWNrKSA/IDEgOiAwKTtcbiAgICAgICAgY29uc3QgcFNpZ09mZnNldCA9IHRoaXMuYWxsb2NJbnQoKTtcbiAgICAgICAgY29uc3QgcEZyID0gdGhpcy5hbGxvY0ZyKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbnB1dCk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaCA9IGZudkhhc2goayk7XG4gICAgICAgICAgICBjb25zdCBoTVNCID0gcGFyc2VJbnQoaC5zbGljZSgwLCA4KSwgMTYpO1xuICAgICAgICAgICAgY29uc3QgaExTQiA9IHBhcnNlSW50KGguc2xpY2UoOCwgMTYpLCAxNik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRTaWduYWxPZmZzZXQzMihwU2lnT2Zmc2V0LCAwLCBoTVNCLCBoTFNCKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2lnbmFsICR7a30gaXMgbm90IGFuIGlucHV0IG9mIHRoZSBjaXJjdWl0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnT2Zmc2V0ID0gdGhpcy5nZXRJbnQocFNpZ09mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBmQXJyID0gZmxhdEFycmF5KGlucHV0W2tdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZkFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RnIocEZyLCBmQXJyW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLmV4cG9ydHMuc2V0U2lnbmFsKDAsIDAsIHNpZ09mZnNldCArIGksIHBGcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbGN1bGF0ZVdpdG5lc3MoaW5wdXQsIHNhbml0eUNoZWNrKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IG9sZDAgPSBzZWxmLmkzMlswXTtcbiAgICAgICAgY29uc3QgdyA9IFtdO1xuXG4gICAgICAgIGF3YWl0IHNlbGYuX2RvQ2FsY3VsYXRlV2l0bmVzcyhpbnB1dCwgc2FuaXR5Q2hlY2spO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi5OVmFyczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwV2l0bmVzcyA9IHNlbGYuaW5zdGFuY2UuZXhwb3J0cy5nZXRQV2l0bmVzcyhpKTtcbiAgICAgICAgICAgIHcucHVzaChzZWxmLmdldEZyKHBXaXRuZXNzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmkzMlswXSA9IG9sZDA7XG4gICAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbGN1bGF0ZUJpbldpdG5lc3MoaW5wdXQsIHNhbml0eUNoZWNrKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IG9sZDAgPSBzZWxmLmkzMlswXTtcblxuICAgICAgICBhd2FpdCBzZWxmLl9kb0NhbGN1bGF0ZVdpdG5lc3MoaW5wdXQsIHNhbml0eUNoZWNrKTtcblxuICAgICAgICBjb25zdCBwV2l0bmVzc0J1ZmZlciA9IHNlbGYuaW5zdGFuY2UuZXhwb3J0cy5nZXRXaXRuZXNzQnVmZmVyKCk7XG5cbiAgICAgICAgc2VsZi5pMzJbMF0gPSBvbGQwO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBzZWxmLm1lbW9yeS5idWZmZXIuc2xpY2UocFdpdG5lc3NCdWZmZXIsIHBXaXRuZXNzQnVmZmVyICsgKHNlbGYuTlZhcnMgKiBzZWxmLm42NCAqIDgpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmYpO1xuICAgIH1cblxuICAgIGFsbG9jSW50KCkge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5pMzJbMF07XG4gICAgICAgIHRoaXMuaTMyWzBdID0gcCArIDg7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGFsbG9jRnIoKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmkzMlswXTtcbiAgICAgICAgdGhpcy5pMzJbMF0gPSBwICsgdGhpcy5uMzIgKiA0ICsgODtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgZ2V0SW50KHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaTMyW3AgPj4gMl07XG4gICAgfVxuXG4gICAgc2V0SW50KHAsIHYpIHtcbiAgICAgICAgdGhpcy5pMzJbcCA+PiAyXSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0RnIocCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgaWR4ID0gKHAgPj4gMik7XG5cbiAgICAgICAgaWYgKHNlbGYuaTMyW2lkeCArIDFdICYgMHg4MDAwMDAwMCkge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KHNlbGYubjMyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi5uMzI7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltzZWxmLm4zMiAtIDEgLSBpXSA9IHNlbGYuaTMyW2lkeCArIDIgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHNlbGYuRnIuZShTY2FsYXIuZnJvbUFycmF5KGFyciwgMHgxMDAwMDAwMDApKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmkzMltpZHggKyAxXSAmIDB4NDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbU1vbnRnb21lcnkocmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlbGYuaTMyW2lkeF0gJiAweDgwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuRnIuZShzZWxmLmkzMltpZHhdIC0gMHgxMDAwMDAwMDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5Gci5lKHNlbGYuaTMyW2lkeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZnJvbU1vbnRnb21lcnkobikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuRnIubXVsKHNlbGYuUkludiwgbik7XG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgc2V0RnIocCwgdikge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICB2ID0gc2VsZi5Gci5lKHYpO1xuXG4gICAgICAgIGNvbnN0IG1pblNob3J0ID0gc2VsZi5Gci5uZWcoc2VsZi5Gci5lKFwiODAwMDAwMDBcIiwgMTYpKTtcbiAgICAgICAgY29uc3QgbWF4U2hvcnQgPSBzZWxmLkZyLmUoXCI3RkZGRkZGRlwiLCAxNik7XG5cbiAgICAgICAgaWYgKChzZWxmLkZyLmdlcSh2LCBtaW5TaG9ydCkpXG4gICAgICAgICAgICAmJiAoc2VsZi5Gci5sZXEodiwgbWF4U2hvcnQpKSkge1xuICAgICAgICAgICAgbGV0IGE7XG4gICAgICAgICAgICBpZiAoc2VsZi5Gci5nZXEodiwgc2VsZi5Gci56ZXJvKSkge1xuICAgICAgICAgICAgICAgIGEgPSBTY2FsYXIudG9OdW1iZXIodik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGEgPSBTY2FsYXIudG9OdW1iZXIoc2VsZi5Gci5zdWIodiwgbWluU2hvcnQpKTtcbiAgICAgICAgICAgICAgICBhID0gYSAtIDB4ODAwMDAwMDA7XG4gICAgICAgICAgICAgICAgYSA9IDB4MTAwMDAwMDAwICsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuaTMyWyhwID4+IDIpXSA9IGE7XG4gICAgICAgICAgICBzZWxmLmkzMlsocCA+PiAyKSArIDFdID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuaTMyWyhwID4+IDIpXSA9IDA7XG4gICAgICAgIHNlbGYuaTMyWyhwID4+IDIpICsgMV0gPSAweDgwMDAwMDAwO1xuICAgICAgICBjb25zdCBhcnIgPSBTY2FsYXIudG9BcnJheSh2LCAweDEwMDAwMDAwMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi5uMzI7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gYXJyLmxlbmd0aCAtIDEgLSBpO1xuXG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmkzMlsocCA+PiAyKSArIDIgKyBpXSA9IGFycltpZHhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmkzMlsocCA+PiAyKSArIDIgKyBpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFdpdG5lc3NDYWxjdWxhdG9yQ2lyY29tMiB7XG4gICAgY29uc3RydWN0b3IoaW5zdGFuY2UsIHNhbml0eUNoZWNrKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcblxuICAgICAgICB0aGlzLnZlcnNpb24gPSB0aGlzLmluc3RhbmNlLmV4cG9ydHMuZ2V0VmVyc2lvbigpO1xuICAgICAgICB0aGlzLm4zMiA9IHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRGaWVsZE51bUxlbjMyKCk7XG5cbiAgICAgICAgdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldFJhd1ByaW1lKCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50MzJBcnJheSh0aGlzLm4zMik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uMzI7IGkrKykge1xuICAgICAgICAgICAgYXJyW3RoaXMubjMyIC0gMSAtIGldID0gdGhpcy5pbnN0YW5jZS5leHBvcnRzLnJlYWRTaGFyZWRSV01lbW9yeShpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByaW1lID0gU2NhbGFyLmZyb21BcnJheShhcnIsIDB4MTAwMDAwMDAwKTtcblxuICAgICAgICB0aGlzLndpdG5lc3NTaXplID0gdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldFdpdG5lc3NTaXplKCk7XG5cbiAgICAgICAgdGhpcy5zYW5pdHlDaGVjayA9IHNhbml0eUNoZWNrO1xuICAgIH1cblxuICAgIGNpcmNvbV92ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldFZlcnNpb24oKTtcbiAgICB9XG5cbiAgICBhc3luYyBfZG9DYWxjdWxhdGVXaXRuZXNzKGlucHV0LCBzYW5pdHlDaGVjaykge1xuICAgICAgICAvL2lucHV0IGlzIGFzc3VtZWQgdG8gYmUgYSBtYXAgZnJvbSBzaWduYWxzIHRvIGFycmF5cyBvZiBiaWdpbnRzXG4gICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5pbml0KCh0aGlzLnNhbml0eUNoZWNrIHx8IHNhbml0eUNoZWNrKSA/IDEgOiAwKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGlucHV0KTtcbiAgICAgICAgbGV0IGlucHV0X2NvdW50ZXIgPSAwO1xuICAgICAgICBrZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGggPSBmbnZIYXNoKGspO1xuICAgICAgICAgICAgY29uc3QgaE1TQiA9IHBhcnNlSW50KGguc2xpY2UoMCwgOCksIDE2KTtcbiAgICAgICAgICAgIGNvbnN0IGhMU0IgPSBwYXJzZUludChoLnNsaWNlKDgsIDE2KSwgMTYpO1xuICAgICAgICAgICAgY29uc3QgZkFyciA9IGZsYXRBcnJheShpbnB1dFtrXSk7XG4gICAgICAgICAgICAvLyBTbGlnaHQgZGV2aWF0aW9uIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2lkZW4zL2NpcmNvbS9ibG9iL3YyLjEuNi9jb2RlX3Byb2R1Y2Vycy9zcmMvd2FzbV9lbGVtZW50cy9jb21tb24vd2l0bmVzc19jYWxjdWxhdG9yLmpzXG4gICAgICAgICAgICAvLyBiZWNhdXNlIEkgZG9uJ3Qga25vdyB3aGVuIHRoaXMgZXhwb3J0ZWQgZnVuY3Rpb24gd2FzIGFkZGVkXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRJbnB1dFNpZ25hbFNpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxldCBzaWduYWxTaXplID0gdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldElucHV0U2lnbmFsU2l6ZShoTVNCLCBoTFNCKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsU2l6ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWduYWwgJHtrfSBub3QgZm91bmRcXG5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZBcnIubGVuZ3RoIDwgc2lnbmFsU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBlbm91Z2ggdmFsdWVzIGZvciBpbnB1dCBzaWduYWwgJHtrfVxcbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZkFyci5sZW5ndGggPiBzaWduYWxTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIG1hbnkgdmFsdWVzIGZvciBpbnB1dCBzaWduYWwgJHtrfVxcbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZkFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyckZyID0gdG9BcnJheTMyKG5vcm1hbGl6ZShmQXJyW2ldLCB0aGlzLnByaW1lKSwgdGhpcy5uMzIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5uMzI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLmV4cG9ydHMud3JpdGVTaGFyZWRSV01lbW9yeShqLCBhcnJGclt0aGlzLm4zMiAtIDEgLSBqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5zZXRJbnB1dFNpZ25hbChoTVNCLCBoTFNCLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfY291bnRlcisrO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgQWZ0ZXIgYWRkaW5nIHNpZ25hbCAke2l9IG9mICR7a31gKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnB1dF9jb3VudGVyIDwgdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldElucHV0U2l6ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhbGwgaW5wdXRzIGhhdmUgYmVlbiBzZXQuIE9ubHkgJHtpbnB1dF9jb3VudGVyfSBvdXQgb2YgJHt0aGlzLmluc3RhbmNlLmV4cG9ydHMuZ2V0SW5wdXRTaXplKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBjYWxjdWxhdGVXaXRuZXNzKGlucHV0LCBzYW5pdHlDaGVjaykge1xuICAgICAgICBjb25zdCB3ID0gW107XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fZG9DYWxjdWxhdGVXaXRuZXNzKGlucHV0LCBzYW5pdHlDaGVjayk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndpdG5lc3NTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRXaXRuZXNzKGkpO1xuICAgICAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMubjMyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5uMzI7IGorKykge1xuICAgICAgICAgICAgICAgIGFyclt0aGlzLm4zMiAtIDEgLSBqXSA9IHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5yZWFkU2hhcmVkUldNZW1vcnkoaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3LnB1c2goU2NhbGFyLmZyb21BcnJheShhcnIsIDB4MTAwMDAwMDAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdztcbiAgICB9XG5cbiAgICBhc3luYyBjYWxjdWxhdGVXVE5TQmluKGlucHV0LCBzYW5pdHlDaGVjaykge1xuICAgICAgICBjb25zdCBidWZmMzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy53aXRuZXNzU2l6ZSAqIHRoaXMubjMyICsgdGhpcy5uMzIgKyAxMSk7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShidWZmMzIuYnVmZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZG9DYWxjdWxhdGVXaXRuZXNzKGlucHV0LCBzYW5pdHlDaGVjayk7XG5cbiAgICAgICAgLy9cInd0bnNcIlxuICAgICAgICBidWZmWzBdID0gXCJ3XCIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgYnVmZlsxXSA9IFwidFwiLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGJ1ZmZbMl0gPSBcIm5cIi5jaGFyQ29kZUF0KDApO1xuICAgICAgICBidWZmWzNdID0gXCJzXCIuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAvL3ZlcnNpb24gMlxuICAgICAgICBidWZmMzJbMV0gPSAyO1xuXG4gICAgICAgIC8vbnVtYmVyIG9mIHNlY3Rpb25zOiAyXG4gICAgICAgIGJ1ZmYzMlsyXSA9IDI7XG5cbiAgICAgICAgLy9pZCBzZWN0aW9uIDFcbiAgICAgICAgYnVmZjMyWzNdID0gMTtcblxuICAgICAgICBjb25zdCBuOCA9IHRoaXMubjMyICogNDtcbiAgICAgICAgLy9pZCBzZWN0aW9uIDEgbGVuZ3RoIGluIDY0Ynl0ZXNcbiAgICAgICAgY29uc3QgaWRTZWN0aW9uMWxlbmd0aCA9IDggKyBuODtcbiAgICAgICAgY29uc3QgaWRTZWN0aW9uMWxlbmd0aEhleCA9IGlkU2VjdGlvbjFsZW5ndGgudG9TdHJpbmcoMTYpO1xuICAgICAgICBidWZmMzJbNF0gPSBwYXJzZUludChpZFNlY3Rpb24xbGVuZ3RoSGV4LnNsaWNlKDAsIDgpLCAxNik7XG4gICAgICAgIGJ1ZmYzMls1XSA9IHBhcnNlSW50KGlkU2VjdGlvbjFsZW5ndGhIZXguc2xpY2UoOCwgMTYpLCAxNik7XG5cbiAgICAgICAgLy90aGlzLm4zMlxuICAgICAgICBidWZmMzJbNl0gPSBuODtcblxuICAgICAgICAvL3ByaW1lIG51bWJlclxuICAgICAgICB0aGlzLmluc3RhbmNlLmV4cG9ydHMuZ2V0UmF3UHJpbWUoKTtcblxuICAgICAgICBsZXQgcG9zID0gNztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLm4zMjsgaisrKSB7XG4gICAgICAgICAgICBidWZmMzJbcG9zICsgal0gPSB0aGlzLmluc3RhbmNlLmV4cG9ydHMucmVhZFNoYXJlZFJXTWVtb3J5KGopO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSB0aGlzLm4zMjtcblxuICAgICAgICAvLyB3aXRuZXNzIHNpemVcbiAgICAgICAgYnVmZjMyW3Bvc10gPSB0aGlzLndpdG5lc3NTaXplO1xuICAgICAgICBwb3MrKztcblxuICAgICAgICAvL2lkIHNlY3Rpb24gMlxuICAgICAgICBidWZmMzJbcG9zXSA9IDI7XG4gICAgICAgIHBvcysrO1xuXG4gICAgICAgIC8vIHNlY3Rpb24gMiBsZW5ndGhcbiAgICAgICAgY29uc3QgaWRTZWN0aW9uMmxlbmd0aCA9IG44ICogdGhpcy53aXRuZXNzU2l6ZTtcbiAgICAgICAgY29uc3QgaWRTZWN0aW9uMmxlbmd0aEhleCA9IGlkU2VjdGlvbjJsZW5ndGgudG9TdHJpbmcoMTYpO1xuICAgICAgICBidWZmMzJbcG9zXSA9IHBhcnNlSW50KGlkU2VjdGlvbjJsZW5ndGhIZXguc2xpY2UoMCwgOCksIDE2KTtcbiAgICAgICAgYnVmZjMyW3BvcyArIDFdID0gcGFyc2VJbnQoaWRTZWN0aW9uMmxlbmd0aEhleC5zbGljZSg4LCAxNiksIDE2KTtcblxuICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndpdG5lc3NTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRXaXRuZXNzKGkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLm4zMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgYnVmZjMyW3BvcyArIGpdID0gdGhpcy5pbnN0YW5jZS5leHBvcnRzLnJlYWRTaGFyZWRSV01lbW9yeShqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSB0aGlzLm4zMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH1cblxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuY29uc3QgeyB1bnN0cmluZ2lmeUJpZ0ludHM6IHVuc3RyaW5naWZ5QmlnSW50cyRifSA9IHV0aWxzO1xuXG5hc3luYyBmdW5jdGlvbiB3dG5zQ2FsY3VsYXRlKF9pbnB1dCwgd2FzbUZpbGVOYW1lLCB3dG5zRmlsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyRiKF9pbnB1dCk7XG5cbiAgICBjb25zdCBmZFdhc20gPSBhd2FpdCByZWFkRXhpc3Rpbmcod2FzbUZpbGVOYW1lKTtcbiAgICBjb25zdCB3YXNtID0gYXdhaXQgZmRXYXNtLnJlYWQoZmRXYXNtLnRvdGFsU2l6ZSk7XG4gICAgYXdhaXQgZmRXYXNtLmNsb3NlKCk7XG5cbiAgICBjb25zdCB3YyA9IGF3YWl0IGJ1aWxkZXIod2FzbSwgb3B0aW9ucyk7XG4gICAgaWYgKHdjLmNpcmNvbV92ZXJzaW9uKCkgPT09IDEpIHtcbiAgICAgICAgY29uc3QgdyA9IGF3YWl0IHdjLmNhbGN1bGF0ZUJpbldpdG5lc3MoaW5wdXQpO1xuXG4gICAgICAgIGNvbnN0IGZkV3RucyA9IGF3YWl0IGNyZWF0ZUJpbkZpbGUod3Ruc0ZpbGVOYW1lLCBcInd0bnNcIiwgMiwgMik7XG5cbiAgICAgICAgYXdhaXQgd3JpdGVCaW4oZmRXdG5zLCB3LCB3Yy5wcmltZSk7XG4gICAgICAgIGF3YWl0IGZkV3Rucy5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZkV3RucyA9IGF3YWl0IGNyZWF0ZU92ZXJyaWRlKHd0bnNGaWxlTmFtZSk7XG5cbiAgICAgICAgY29uc3QgdyA9IGF3YWl0IHdjLmNhbGN1bGF0ZVdUTlNCaW4oaW5wdXQpO1xuXG4gICAgICAgIGF3YWl0IGZkV3Rucy53cml0ZSh3KTtcbiAgICAgICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzJGF9ID0gdXRpbHM7XG5cbmFzeW5jIGZ1bmN0aW9uIGdyb3RoMTZGdWxsUHJvdmUoX2lucHV0LCB3YXNtRmlsZSwgemtleUZpbGVOYW1lLCBsb2dnZXIsIHd0bnNDYWxjT3B0aW9ucywgcHJvdmVyT3B0aW9ucykge1xuICAgIGNvbnN0IGlucHV0ID0gdW5zdHJpbmdpZnlCaWdJbnRzJGEoX2lucHV0KTtcblxuICAgIGNvbnN0IHd0bnM9IHtcbiAgICAgICAgdHlwZTogXCJtZW1cIlxuICAgIH07XG4gICAgYXdhaXQgd3Ruc0NhbGN1bGF0ZShpbnB1dCwgd2FzbUZpbGUsIHd0bnMsIHd0bnNDYWxjT3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IGdyb3RoMTZQcm92ZSh6a2V5RmlsZU5hbWUsIHd0bnMsIGxvZ2dlciwgcHJvdmVyT3B0aW9ucyk7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzOiB1bnN0cmluZ2lmeUJpZ0ludHMkOX0gPSB1dGlscztcblxuYXN5bmMgZnVuY3Rpb24gZ3JvdGgxNlZlcmlmeShfdmtfdmVyaWZpZXIsIF9wdWJsaWNTaWduYWxzLCBfcHJvb2YsIGxvZ2dlcikge1xuLypcbiAgICBsZXQgY3B1YiA9IHZrX3ZlcmlmaWVyLklDWzBdO1xuICAgIGZvciAobGV0IHM9IDA7IHM8IHZrX3ZlcmlmaWVyLm5QdWJsaWM7IHMrKykge1xuICAgICAgICBjcHViICA9IEcxLmFkZCggY3B1YiwgRzEudGltZXNTY2FsYXIoIHZrX3ZlcmlmaWVyLklDW3MrMV0sIHB1YmxpY1NpZ25hbHNbc10pKTtcbiAgICB9XG4qL1xuXG4gICAgY29uc3QgdmtfdmVyaWZpZXIgPSB1bnN0cmluZ2lmeUJpZ0ludHMkOShfdmtfdmVyaWZpZXIpO1xuICAgIGNvbnN0IHByb29mID0gdW5zdHJpbmdpZnlCaWdJbnRzJDkoX3Byb29mKTtcbiAgICBjb25zdCBwdWJsaWNTaWduYWxzID0gdW5zdHJpbmdpZnlCaWdJbnRzJDkoX3B1YmxpY1NpZ25hbHMpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21OYW1lKHZrX3ZlcmlmaWVyLmN1cnZlKTtcblxuICAgIGNvbnN0IElDMCA9IGN1cnZlLkcxLmZyb21PYmplY3QodmtfdmVyaWZpZXIuSUNbMF0pO1xuICAgIGNvbnN0IElDID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyICogcHVibGljU2lnbmFscy5sZW5ndGgpO1xuICAgIGNvbnN0IHcgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5Gci5uOCAqIHB1YmxpY1NpZ25hbHMubGVuZ3RoKTtcblxuICAgIGlmICghcHVibGljSW5wdXRzQXJlVmFsaWQkMihjdXJ2ZSwgcHVibGljU2lnbmFscykpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUHVibGljIGlucHV0cyBhcmUgbm90IHZhbGlkLlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGk9MDsgaTxwdWJsaWNTaWduYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZQID0gY3VydmUuRzEuZnJvbU9iamVjdCh2a192ZXJpZmllci5JQ1tpKzFdKTtcbiAgICAgICAgSUMuc2V0KGJ1ZmZQLCBpKmN1cnZlLkcxLkYubjgqMik7XG4gICAgICAgIFNjYWxhci50b1JwckxFKHcsIGN1cnZlLkZyLm44KmksIHB1YmxpY1NpZ25hbHNbaV0sIGN1cnZlLkZyLm44KTtcbiAgICB9XG5cbiAgICBsZXQgY3B1YiA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKElDLCB3KTtcbiAgICBjcHViID0gY3VydmUuRzEuYWRkKGNwdWIsIElDMCk7XG5cbiAgICBjb25zdCBwaV9hID0gY3VydmUuRzEuZnJvbU9iamVjdChwcm9vZi5waV9hKTtcbiAgICBjb25zdCBwaV9iID0gY3VydmUuRzIuZnJvbU9iamVjdChwcm9vZi5waV9iKTtcbiAgICBjb25zdCBwaV9jID0gY3VydmUuRzEuZnJvbU9iamVjdChwcm9vZi5waV9jKTtcblxuICAgIGlmICghaXNXZWxsQ29uc3RydWN0ZWQkMShjdXJ2ZSwge3BpX2EsIHBpX2IsIHBpX2N9KSkge1xuICAgICAgICBpZihsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlByb29mIGNvbW1pdG1lbnRzIGFyZSBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmtfZ2FtbWFfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfZ2FtbWFfMik7XG4gICAgY29uc3QgdmtfZGVsdGFfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfZGVsdGFfMik7XG4gICAgY29uc3QgdmtfYWxwaGFfMSA9IGN1cnZlLkcxLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfYWxwaGFfMSk7XG4gICAgY29uc3QgdmtfYmV0YV8yID0gY3VydmUuRzIuZnJvbU9iamVjdCh2a192ZXJpZmllci52a19iZXRhXzIpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUucGFpcmluZ0VxKFxuICAgICAgICBjdXJ2ZS5HMS5uZWcocGlfYSkgLCBwaV9iLFxuICAgICAgICBjcHViICwgdmtfZ2FtbWFfMixcbiAgICAgICAgcGlfYyAsIHZrX2RlbHRhXzIsXG5cbiAgICAgICAgdmtfYWxwaGFfMSwgdmtfYmV0YV8yXG4gICAgKTtcblxuICAgIGlmICghIHJlcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHByb29mXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJPSyFcIik7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzV2VsbENvbnN0cnVjdGVkJDEoY3VydmUsIHByb29mKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBHMiA9IGN1cnZlLkcyO1xuXG4gICAgcmV0dXJuIEcxLmlzVmFsaWQocHJvb2YucGlfYSlcbiAgICAgICAgJiYgRzIuaXNWYWxpZChwcm9vZi5waV9iKVxuICAgICAgICAmJiBHMS5pc1ZhbGlkKHByb29mLnBpX2MpO1xufVxuXG5mdW5jdGlvbiBjaGVja1ZhbHVlQmVsb25nVG9GaWVsZCQyKGN1cnZlLCB2YWx1ZSkge1xuICAgIHJldHVybiBTY2FsYXIuZ2VxKHZhbHVlLCAwKSAmJiBTY2FsYXIubHQodmFsdWUsIGN1cnZlLnIpO1xufVxuXG5mdW5jdGlvbiBwdWJsaWNJbnB1dHNBcmVWYWxpZCQyKGN1cnZlLCBwdWJsaWNJbnB1dHMpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHVibGljSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKCFjaGVja1ZhbHVlQmVsb25nVG9GaWVsZCQyKGN1cnZlLCBwdWJsaWNJbnB1dHNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCB7IHVuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzJDh9ID0gdXRpbHM7XG5cbmZ1bmN0aW9uIHAyNTYkMihuKSB7XG4gICAgbGV0IG5zdHIgPSBuLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAobnN0ci5sZW5ndGggPCA2NCkgbnN0ciA9IFwiMFwiK25zdHI7XG4gICAgbnN0ciA9IGBcIjB4JHtuc3RyfVwiYDtcbiAgICByZXR1cm4gbnN0cjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ3JvdGgxNkV4cG9ydFNvbGlkaXR5Q2FsbERhdGEoX3Byb29mLCBfcHViKSB7XG4gICAgY29uc3QgcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMkOChfcHJvb2YpO1xuICAgIGNvbnN0IHB1YiA9IHVuc3RyaW5naWZ5QmlnSW50cyQ4KF9wdWIpO1xuXG4gICAgbGV0IGlucHV0cyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaT0wOyBpPHB1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRzICE9IFwiXCIpIGlucHV0cyA9IGlucHV0cyArIFwiLFwiO1xuICAgICAgICBpbnB1dHMgPSBpbnB1dHMgKyBwMjU2JDIocHViW2ldKTtcbiAgICB9XG5cbiAgICBsZXQgUztcbiAgICBTPWBbJHtwMjU2JDIocHJvb2YucGlfYVswXSl9LCAke3AyNTYkMihwcm9vZi5waV9hWzFdKX1dLGAgK1xuICAgICAgICBgW1ske3AyNTYkMihwcm9vZi5waV9iWzBdWzFdKX0sICR7cDI1NiQyKHByb29mLnBpX2JbMF1bMF0pfV0sWyR7cDI1NiQyKHByb29mLnBpX2JbMV1bMV0pfSwgJHtwMjU2JDIocHJvb2YucGlfYlsxXVswXSl9XV0sYCArXG4gICAgICAgIGBbJHtwMjU2JDIocHJvb2YucGlfY1swXSl9LCAke3AyNTYkMihwcm9vZi5waV9jWzFdKX1dLGAgK1xuICAgICAgICBgWyR7aW5wdXRzfV1gO1xuXG4gICAgcmV0dXJuIFM7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbnZhciBncm90aDE2ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBmdWxsUHJvdmU6IGdyb3RoMTZGdWxsUHJvdmUsXG4gICAgcHJvdmU6IGdyb3RoMTZQcm92ZSxcbiAgICB2ZXJpZnk6IGdyb3RoMTZWZXJpZnksXG4gICAgZXhwb3J0U29saWRpdHlDYWxsRGF0YTogZ3JvdGgxNkV4cG9ydFNvbGlkaXR5Q2FsbERhdGFcbn0pO1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5mdW5jdGlvbiBoYXNoVG9HMihjdXJ2ZSwgaGFzaCkge1xuICAgIGNvbnN0IGhhc2hWID0gbmV3IERhdGFWaWV3KGhhc2guYnVmZmVyLCBoYXNoLmJ5dGVPZmZzZXQsIGhhc2guYnl0ZUxlbmd0aCk7XG4gICAgY29uc3Qgc2VlZCA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTw4OyBpKyspIHtcbiAgICAgICAgc2VlZFtpXSA9IGhhc2hWLmdldFVpbnQzMihpKjQpO1xuICAgIH1cblxuICAgIGNvbnN0IHJuZyA9IG5ldyBDaGFDaGEoc2VlZCk7XG5cbiAgICBjb25zdCBnMl9zcCA9IGN1cnZlLkcyLmZyb21Sbmcocm5nKTtcblxuICAgIHJldHVybiBnMl9zcDtcbn1cblxuZnVuY3Rpb24gZ2V0RzJzcChjdXJ2ZSwgcGVyc2luYWxpemF0aW9uLCBjaGFsbGVuZ2UsIGcxcywgZzFzeCkge1xuXG4gICAgY29uc3QgaCA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIGNvbnN0IGIxID0gbmV3IFVpbnQ4QXJyYXkoW3BlcnNpbmFsaXphdGlvbl0pO1xuICAgIGgudXBkYXRlKGIxKTtcbiAgICBoLnVwZGF0ZShjaGFsbGVuZ2UpO1xuICAgIGNvbnN0IGIzID0gY3VydmUuRzEudG9VbmNvbXByZXNzZWQoZzFzKTtcbiAgICBoLnVwZGF0ZSggYjMpO1xuICAgIGNvbnN0IGI0ID0gY3VydmUuRzEudG9VbmNvbXByZXNzZWQoZzFzeCk7XG4gICAgaC51cGRhdGUoIGI0KTtcbiAgICBjb25zdCBoYXNoID1oLmRpZ2VzdCgpO1xuXG4gICAgcmV0dXJuIGhhc2hUb0cyKGN1cnZlLCBoYXNoKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUHViS2V5KGssIGN1cnZlLCBwZXJzb25hbGl6YXRpb24sIGNoYWxsZW5nZUhhc2gsIHJuZyApIHtcbiAgICBrLmcxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgIGsuZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGsuZzFfcywgay5wcnZLZXkpKTtcbiAgICBrLmcyX3NwID0gY3VydmUuRzIudG9BZmZpbmUoZ2V0RzJzcChjdXJ2ZSwgcGVyc29uYWxpemF0aW9uLCBjaGFsbGVuZ2VIYXNoLCBrLmcxX3MsIGsuZzFfc3gpKTtcbiAgICBrLmcyX3NweCA9IGN1cnZlLkcyLnRvQWZmaW5lKGN1cnZlLkcyLnRpbWVzRnIoay5nMl9zcCwgay5wcnZLZXkpKTtcbiAgICByZXR1cm4gaztcbn1cblxuZnVuY3Rpb24gY3JlYXRlUFRhdUtleShjdXJ2ZSwgY2hhbGxlbmdlSGFzaCwgcm5nKSB7XG4gICAgY29uc3Qga2V5ID0ge1xuICAgICAgICB0YXU6IHt9LFxuICAgICAgICBhbHBoYToge30sXG4gICAgICAgIGJldGE6IHt9XG4gICAgfTtcbiAgICBrZXkudGF1LnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBrZXkuYWxwaGEucHJ2S2V5ID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgIGtleS5iZXRhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBjYWxjdWxhdGVQdWJLZXkoa2V5LnRhdSwgY3VydmUsIDAsIGNoYWxsZW5nZUhhc2gsIHJuZyk7XG4gICAgY2FsY3VsYXRlUHViS2V5KGtleS5hbHBoYSwgY3VydmUsIDEsIGNoYWxsZW5nZUhhc2gsIHJuZyk7XG4gICAgY2FsY3VsYXRlUHViS2V5KGtleS5iZXRhLCBjdXJ2ZSwgMiwgY2hhbGxlbmdlSGFzaCwgcm5nKTtcbiAgICByZXR1cm4ga2V5O1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiB3cml0ZVBUYXVIZWFkZXIoZmQsIGN1cnZlLCBwb3dlciwgY2VyZW1vbnlQb3dlcikge1xuICAgIC8vIFdyaXRlIHRoZSBoZWFkZXJcbiAgICAvLy8vLy8vLy8vL1xuXG4gICAgaWYgKCEgY2VyZW1vbnlQb3dlcikgY2VyZW1vbnlQb3dlciA9IHBvd2VyO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoMSk7IC8vIEhlYWRlciB0eXBlXG4gICAgY29uc3QgcEhlYWRlclNpemUgPSBmZC5wb3M7XG4gICAgYXdhaXQgZmQud3JpdGVVTEU2NCgwKTsgLy8gVGVtcG9yYWxseSBzZXQgdG8gMCBsZW5ndGhcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY3VydmUuRjEubjY0KjgpO1xuXG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkYxLm44KTtcbiAgICBTY2FsYXIudG9ScHJMRShidWZmLCAwLCBjdXJ2ZS5xLCBjdXJ2ZS5GMS5uOCk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZik7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihwb3dlcik7ICAgICAgICAgICAgICAgICAgICAvLyBwb3dlclxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoY2VyZW1vbnlQb3dlcik7ICAgICAgICAgICAgICAgLy8gcG93ZXJcblxuICAgIGNvbnN0IGhlYWRlclNpemUgPSBmZC5wb3MgLSBwSGVhZGVyU2l6ZSAtIDg7XG5cbiAgICBjb25zdCBvbGRQb3MgPSBmZC5wb3M7XG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KGhlYWRlclNpemUsIHBIZWFkZXJTaXplKTtcblxuICAgIGZkLnBvcyA9IG9sZFBvcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZFBUYXVIZWFkZXIoZmQsIHNlY3Rpb25zKSB7XG4gICAgaWYgKCFzZWN0aW9uc1sxXSkgIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArIFwiOiBGaWxlIGhhcyBubyAgaGVhZGVyXCIpO1xuICAgIGlmIChzZWN0aW9uc1sxXS5sZW5ndGg+MSkgdGhyb3cgbmV3IEVycm9yKGZkLmZpbGVOYW1lICtcIjogRmlsZSBoYXMgbW9yZSB0aGFuIG9uZSBoZWFkZXJcIik7XG5cbiAgICBmZC5wb3MgPSBzZWN0aW9uc1sxXVswXS5wO1xuICAgIGNvbnN0IG44ID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQobjgpO1xuICAgIGNvbnN0IHEgPSBTY2FsYXIuZnJvbVJwckxFKGJ1ZmYpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21RKHEpO1xuXG4gICAgaWYgKGN1cnZlLkYxLm42NCo4ICE9IG44KSB0aHJvdyBuZXcgRXJyb3IoZmQuZmlsZU5hbWUgK1wiOiBJbnZhbGlkIHNpemVcIik7XG5cbiAgICBjb25zdCBwb3dlciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGNlcmVtb255UG93ZXIgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcblxuICAgIGlmIChmZC5wb3Mtc2VjdGlvbnNbMV1bMF0ucCAhPSBzZWN0aW9uc1sxXVswXS5zaXplKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBUYXUgaGVhZGVyIHNpemVcIik7XG5cbiAgICByZXR1cm4ge2N1cnZlLCBwb3dlciwgY2VyZW1vbnlQb3dlcn07XG59XG5cblxuYXN5bmMgZnVuY3Rpb24gcmVhZFB0YXVQdWJLZXkoZmQsIGN1cnZlLCBtb250Z29tZXJ5KSB7XG5cbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5GMS5uOCoyKjYgKyBjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgcmV0dXJuIGZyb21QdGF1UHViS2V5UnByKGJ1ZmYsIDAsIGN1cnZlLCBtb250Z29tZXJ5KTtcbn1cblxuZnVuY3Rpb24gZnJvbVB0YXVQdWJLZXlScHIoYnVmZiwgcG9zLCBjdXJ2ZSwgbW9udGdvbWVyeSkge1xuXG4gICAgY29uc3Qga2V5ID0ge1xuICAgICAgICB0YXU6IHt9LFxuICAgICAgICBhbHBoYToge30sXG4gICAgICAgIGJldGE6IHt9XG4gICAgfTtcblxuICAgIGtleS50YXUuZzFfcyA9IHJlYWRHMSgpO1xuICAgIGtleS50YXUuZzFfc3ggPSByZWFkRzEoKTtcbiAgICBrZXkuYWxwaGEuZzFfcyA9IHJlYWRHMSgpO1xuICAgIGtleS5hbHBoYS5nMV9zeCA9IHJlYWRHMSgpO1xuICAgIGtleS5iZXRhLmcxX3MgPSByZWFkRzEoKTtcbiAgICBrZXkuYmV0YS5nMV9zeCA9IHJlYWRHMSgpO1xuICAgIGtleS50YXUuZzJfc3B4ID0gcmVhZEcyKCk7XG4gICAga2V5LmFscGhhLmcyX3NweCA9IHJlYWRHMigpO1xuICAgIGtleS5iZXRhLmcyX3NweCA9IHJlYWRHMigpO1xuXG4gICAgcmV0dXJuIGtleTtcblxuICAgIGZ1bmN0aW9uIHJlYWRHMSgpIHtcbiAgICAgICAgbGV0IHA7XG4gICAgICAgIGlmIChtb250Z29tZXJ5KSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzEuZnJvbVJwckxFTSggYnVmZiwgcG9zICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzEuZnJvbVJwclVuY29tcHJlc3NlZCggYnVmZiwgcG9zICk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGN1cnZlLkcxLkYubjgqMjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZEcyKCkge1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgaWYgKG1vbnRnb21lcnkpIHtcbiAgICAgICAgICAgIHAgPSBjdXJ2ZS5HMi5mcm9tUnByTEVNKCBidWZmLCBwb3MgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBjdXJ2ZS5HMi5mcm9tUnByVW5jb21wcmVzc2VkKCBidWZmLCBwb3MgKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY3VydmUuRzIuRi5uOCoyO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvUHRhdVB1YktleVJwcihidWZmLCBwb3MsIGN1cnZlLCBrZXksIG1vbnRnb21lcnkpIHtcblxuICAgIHdyaXRlRzEoa2V5LnRhdS5nMV9zKTtcbiAgICB3cml0ZUcxKGtleS50YXUuZzFfc3gpO1xuICAgIHdyaXRlRzEoa2V5LmFscGhhLmcxX3MpO1xuICAgIHdyaXRlRzEoa2V5LmFscGhhLmcxX3N4KTtcbiAgICB3cml0ZUcxKGtleS5iZXRhLmcxX3MpO1xuICAgIHdyaXRlRzEoa2V5LmJldGEuZzFfc3gpO1xuICAgIHdyaXRlRzIoa2V5LnRhdS5nMl9zcHgpO1xuICAgIHdyaXRlRzIoa2V5LmFscGhhLmcyX3NweCk7XG4gICAgd3JpdGVHMihrZXkuYmV0YS5nMl9zcHgpO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMShwKSB7XG4gICAgICAgIGlmIChtb250Z29tZXJ5KSB7XG4gICAgICAgICAgICBjdXJ2ZS5HMS50b1JwckxFTShidWZmLCBwb3MsIHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgcG9zLCBwKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY3VydmUuRjEubjgqMjtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUcyKHApIHtcbiAgICAgICAgaWYgKG1vbnRnb21lcnkpIHtcbiAgICAgICAgICAgIGN1cnZlLkcyLnRvUnByTEVNKGJ1ZmYsIHBvcywgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZChidWZmLCBwb3MsIHApO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjdXJ2ZS5GMi5uOCoyO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZVB0YXVQdWJLZXkoZmQsIGN1cnZlLCBrZXksIG1vbnRnb21lcnkpIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMio2ICsgY3VydmUuRjIubjgqMiozKTtcbiAgICB0b1B0YXVQdWJLZXlScHIoYnVmZiwgMCwgY3VydmUsIGtleSwgbW9udGdvbWVyeSk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDb250cmlidXRpb24oZmQsIGN1cnZlKSB7XG4gICAgY29uc3QgYyA9IHt9O1xuXG4gICAgYy50YXVHMSA9IGF3YWl0IHJlYWRHMSgpO1xuICAgIGMudGF1RzIgPSBhd2FpdCByZWFkRzIoKTtcbiAgICBjLmFscGhhRzEgPSBhd2FpdCByZWFkRzEoKTtcbiAgICBjLmJldGFHMSA9IGF3YWl0IHJlYWRHMSgpO1xuICAgIGMuYmV0YUcyID0gYXdhaXQgcmVhZEcyKCk7XG4gICAgYy5rZXkgPSBhd2FpdCByZWFkUHRhdVB1YktleShmZCwgY3VydmUsIHRydWUpO1xuICAgIGMucGFydGlhbEhhc2ggPSBhd2FpdCBmZC5yZWFkKDIxNik7XG4gICAgYy5uZXh0Q2hhbGxlbmdlID0gYXdhaXQgZmQucmVhZCg2NCk7XG4gICAgYy50eXBlID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG5cbiAgICBjb25zdCBidWZmViAgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIqNitjdXJ2ZS5HMi5GLm44KjIqMyk7XG4gICAgdG9QdGF1UHViS2V5UnByKGJ1ZmZWLCAwLCBjdXJ2ZSwgYy5rZXksIGZhbHNlKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSGFzaGVyID0gIGZyb21QYXJ0aWFsSGFzaChjLnBhcnRpYWxIYXNoKTtcbiAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZlYpO1xuICAgIGMucmVzcG9uc2VIYXNoID0gcmVzcG9uc2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBjb25zdCBwYXJhbUxlbmd0aCA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGN1clBvcyA9IGZkLnBvcztcbiAgICBsZXQgbGFzdFR5cGUgPTA7XG4gICAgd2hpbGUgKGZkLnBvcy1jdXJQb3MgPCBwYXJhbUxlbmd0aCkge1xuICAgICAgICBjb25zdCBidWZmVHlwZSA9IGF3YWl0IHJlYWREVigxKTtcbiAgICAgICAgaWYgKGJ1ZmZUeXBlWzBdPD0gbGFzdFR5cGUpIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlcnMgaW4gdGhlIGNvbnRyaWJ1dGlvbiBtdXN0IGJlIHNvcnRlZFwiKTtcbiAgICAgICAgbGFzdFR5cGUgPSBidWZmVHlwZVswXTtcbiAgICAgICAgaWYgKGJ1ZmZUeXBlWzBdPT0xKSB7ICAgICAvLyBOYW1lXG4gICAgICAgICAgICBjb25zdCBidWZmTGVuID0gYXdhaXQgcmVhZERWKDEpO1xuICAgICAgICAgICAgY29uc3QgYnVmZlN0ciA9IGF3YWl0IHJlYWREVihidWZmTGVuWzBdKTtcbiAgICAgICAgICAgIGMubmFtZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWZmU3RyKTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmVHlwZVswXT09Mikge1xuICAgICAgICAgICAgY29uc3QgYnVmZkV4cCA9IGF3YWl0IHJlYWREVigxKTtcbiAgICAgICAgICAgIGMubnVtSXRlcmF0aW9uc0V4cCA9IGJ1ZmZFeHBbMF07XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZlR5cGVbMF09PTMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMZW4gPSBhd2FpdCByZWFkRFYoMSk7XG4gICAgICAgICAgICBjLmJlYWNvbkhhc2ggPSBhd2FpdCByZWFkRFYoYnVmZkxlblswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbm90IHJlY29nbml6ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZkLnBvcyAhPSBjdXJQb3MgKyBwYXJhbUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRHMSgpIHtcbiAgICAgICAgY29uc3QgcEJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkcxLkYubjgqMik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5HMS5mcm9tUnByTEVNKCBwQnVmZiApO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRHMigpIHtcbiAgICAgICAgY29uc3QgcEJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkcyLkYubjgqMik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5HMi5mcm9tUnByTEVNKCBwQnVmZiApO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWREVihuKSB7XG4gICAgICAgIGNvbnN0IGIgPSBhd2FpdCBmZC5yZWFkKG4pO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkQ29udHJpYnV0aW9ucyhmZCwgY3VydmUsIHNlY3Rpb25zKSB7XG4gICAgaWYgKCFzZWN0aW9uc1s3XSkgIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArIFwiOiBGaWxlIGhhcyBubyAgY29udHJpYnV0aW9uc1wiKTtcbiAgICBpZiAoc2VjdGlvbnNbN11bMF0ubGVuZ3RoPjEpIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArXCI6IEZpbGUgaGFzIG1vcmUgdGhhbiBvbmUgY29udHJpYnV0aW9ucyBzZWN0aW9uXCIpO1xuXG4gICAgZmQucG9zID0gc2VjdGlvbnNbN11bMF0ucDtcbiAgICBjb25zdCBuQ29udHJpYnV0aW9ucyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bkNvbnRyaWJ1dGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbihmZCwgY3VydmUpO1xuICAgICAgICBjLmlkID0gaSsxO1xuICAgICAgICBjb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgaWYgKGZkLnBvcy1zZWN0aW9uc1s3XVswXS5wICE9IHNlY3Rpb25zWzddWzBdLnNpemUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29udHJpYnV0aW9uIHNlY3Rpb24gc2l6ZVwiKTtcblxuICAgIHJldHVybiBjb250cmlidXRpb25zO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsIGNvbnRyaWJ1dGlvbikge1xuXG4gICAgY29uc3QgYnVmZkcxID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMik7XG4gICAgY29uc3QgYnVmZkcyID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjIubjgqMik7XG4gICAgYXdhaXQgd3JpdGVHMShjb250cmlidXRpb24udGF1RzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoY29udHJpYnV0aW9uLnRhdUcyKTtcbiAgICBhd2FpdCB3cml0ZUcxKGNvbnRyaWJ1dGlvbi5hbHBoYUcxKTtcbiAgICBhd2FpdCB3cml0ZUcxKGNvbnRyaWJ1dGlvbi5iZXRhRzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoY29udHJpYnV0aW9uLmJldGFHMik7XG4gICAgYXdhaXQgd3JpdGVQdGF1UHViS2V5KGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9uLmtleSwgdHJ1ZSk7XG4gICAgYXdhaXQgZmQud3JpdGUoY29udHJpYnV0aW9uLnBhcnRpYWxIYXNoKTtcbiAgICBhd2FpdCBmZC53cml0ZShjb250cmlidXRpb24ubmV4dENoYWxsZW5nZSk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb250cmlidXRpb24udHlwZSB8fCAwKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGlmIChjb250cmlidXRpb24ubmFtZSkge1xuICAgICAgICBwYXJhbXMucHVzaCgxKTsgICAgICAvLyBQYXJhbSBOYW1lXG4gICAgICAgIGNvbnN0IG5hbWVEYXRhID0gbmV3IFRleHRFbmNvZGVyKFwidXRmLThcIikuZW5jb2RlKGNvbnRyaWJ1dGlvbi5uYW1lLnN1YnN0cmluZygwLDY0KSk7XG4gICAgICAgIHBhcmFtcy5wdXNoKG5hbWVEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bmFtZURhdGEuYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChuYW1lRGF0YVtpXSk7XG4gICAgfVxuICAgIGlmIChjb250cmlidXRpb24udHlwZSA9PSAxKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKDIpOyAgICAgIC8vIFBhcmFtIG51bUl0ZXJhdGlvbnNFeHBcbiAgICAgICAgcGFyYW1zLnB1c2goY29udHJpYnV0aW9uLm51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgICAgIHBhcmFtcy5wdXNoKDMpOyAgICAgIC8vIEJlYWNvbiBIYXNoXG4gICAgICAgIHBhcmFtcy5wdXNoKGNvbnRyaWJ1dGlvbi5iZWFjb25IYXNoLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29udHJpYnV0aW9uLmJlYWNvbkhhc2guYnl0ZUxlbmd0aDsgaSsrKSBwYXJhbXMucHVzaChjb250cmlidXRpb24uYmVhY29uSGFzaFtpXSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGVuZ3RoPjApIHtcbiAgICAgICAgY29uc3QgcGFyYW1zQnVmZiA9IG5ldyBVaW50OEFycmF5KHBhcmFtcyk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIocGFyYW1zQnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUocGFyYW1zQnVmZik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMigwKTtcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEocCkge1xuICAgICAgICBjdXJ2ZS5HMS50b1JwckxFTShidWZmRzEsIDAsIHApO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzEpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIocCkge1xuICAgICAgICBjdXJ2ZS5HMi50b1JwckxFTShidWZmRzIsIDAsIHApO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShidWZmRzIpO1xuICAgIH1cblxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRyaWJ1dGlvbnMoZmQsIGN1cnZlLCBjb250cmlidXRpb25zKSB7XG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDcpOyAvLyBIZWFkZXIgdHlwZVxuICAgIGNvbnN0IHBDb250cmlidXRpb25zU2l6ZSA9IGZkLnBvcztcbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KDApOyAvLyBUZW1wb3JhbGx5IHNldCB0byAwIGxlbmd0aFxuXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb250cmlidXRpb25zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPCBjb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHdyaXRlQ29udHJpYnV0aW9uKGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9uc1tpXSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnNTaXplID0gZmQucG9zIC0gcENvbnRyaWJ1dGlvbnNTaXplIC0gODtcblxuICAgIGNvbnN0IG9sZFBvcyA9IGZkLnBvcztcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFNjQoY29udHJpYnV0aW9uc1NpemUsIHBDb250cmlidXRpb25zU2l6ZSk7XG4gICAgZmQucG9zID0gb2xkUG9zO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVGaXJzdENoYWxsZW5nZUhhc2goY3VydmUsIHBvd2VyLCBsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDYWxjdWxhdGluZyBGaXJzdCBDaGFsbGVuZ2UgSGFzaFwiKTtcblxuICAgIGNvbnN0IGhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuXG4gICAgY29uc3QgdkcxID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKTtcbiAgICBjb25zdCB2RzIgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMi5GLm44KjIpO1xuICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKHZHMSwgMCwgY3VydmUuRzEuZyk7XG4gICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQodkcyLCAwLCBjdXJ2ZS5HMi5nKTtcblxuICAgIGhhc2hlci51cGRhdGUoYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSkuZGlnZXN0KCkpO1xuXG4gICAgbGV0IG47XG5cbiAgICBuPSgyICoqIHBvd2VyKSoyIC0xO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNhbGN1bGF0ZSBJbml0aWFsIEhhc2g6IHRhdUcxXCIpO1xuICAgIGhhc2hCbG9jayh2RzEsIG4pO1xuICAgIG49IDIgKiogcG93ZXI7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQ2FsY3VsYXRlIEluaXRpYWwgSGFzaDogdGF1RzJcIik7XG4gICAgaGFzaEJsb2NrKHZHMiwgbik7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQ2FsY3VsYXRlIEluaXRpYWwgSGFzaDogYWxwaGFUYXVHMVwiKTtcbiAgICBoYXNoQmxvY2sodkcxLCBuKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDYWxjdWxhdGUgSW5pdGlhbCBIYXNoOiBiZXRhVGF1RzFcIik7XG4gICAgaGFzaEJsb2NrKHZHMSwgbik7XG4gICAgaGFzaGVyLnVwZGF0ZSh2RzIpO1xuXG4gICAgcmV0dXJuIGhhc2hlci5kaWdlc3QoKTtcblxuICAgIGZ1bmN0aW9uIGhhc2hCbG9jayhidWZmLCBuKSB7XG4gICAgICAgIC8vIHRoaXMgYmxvY2sgc2l6ZSBpcyBhIGdvb2QgY29tcHJvbWlzZSBiZXR3ZWVuIHNwZWVkIGFuZCB0aGUgbWF4aW11bVxuICAgICAgICAvLyBpbnB1dCBzaXplIG9mIHRoZSBCbGFrZTJiIHVwZGF0ZSBtZXRob2QgKDY1LDUzNSw3MjAgYnl0ZXMpLlxuICAgICAgICBjb25zdCBibG9ja1NpemUgPSAzNDEwMDA7XG4gICAgICAgIGNvbnN0IG5CbG9ja3MgPSBNYXRoLmZsb29yKG4gLyBibG9ja1NpemUpO1xuICAgICAgICBjb25zdCByZW0gPSBuICUgYmxvY2tTaXplO1xuICAgICAgICBjb25zdCBiaWdCdWZmID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tTaXplICogYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGJsb2NrU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBiaWdCdWZmLnNldChidWZmLCBpKmJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5CbG9ja3M7IGkrKykge1xuICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShiaWdCdWZmKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkluaXRpYWwgaGFzaDogXCIgK2kqYmxvY2tTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVtOyBpKyspIHtcbiAgICAgICAgICAgIGhhc2hlci51cGRhdGUoYnVmZik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuYXN5bmMgZnVuY3Rpb24ga2V5RnJvbUJlYWNvbihjdXJ2ZSwgY2hhbGxlbmdlSGFzaCwgYmVhY29uSGFzaCwgbnVtSXRlcmF0aW9uc0V4cCkge1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgcm5nRnJvbUJlYWNvblBhcmFtcyhiZWFjb25IYXNoLCBudW1JdGVyYXRpb25zRXhwKTtcblxuICAgIGNvbnN0IGtleSA9IGNyZWF0ZVBUYXVLZXkoY3VydmUsIGNoYWxsZW5nZUhhc2gsIHJuZyk7XG5cbiAgICByZXR1cm4ga2V5O1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBuZXdBY2N1bXVsYXRvcihjdXJ2ZSwgcG93ZXIsIGZpbGVOYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IGZkID0gYXdhaXQgY3JlYXRlQmluRmlsZShmaWxlTmFtZSwgXCJwdGF1XCIsIDEsIDcpO1xuXG4gICAgYXdhaXQgd3JpdGVQVGF1SGVhZGVyKGZkLCBjdXJ2ZSwgcG93ZXIsIDApO1xuXG4gICAgY29uc3QgYnVmZkcxID0gY3VydmUuRzEub25lQWZmaW5lO1xuICAgIGNvbnN0IGJ1ZmZHMiA9IGN1cnZlLkcyLm9uZUFmZmluZTtcblxuICAgIC8vIFdyaXRlIHRhdUcxXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZCwgMik7XG4gICAgY29uc3QgblRhdUcxID0gKDIgKiogcG93ZXIpICogMiAtMTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IG5UYXVHMTsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmZHMSk7XG4gICAgICAgIGlmICgobG9nZ2VyKSYmKChpJTEwMDAwMCkgPT0gMCkmJmkpIGxvZ2dlci5sb2coXCJ0YXVHMTogXCIgKyBpKTtcbiAgICB9XG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIHRhdUcyXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZCwgMyk7XG4gICAgY29uc3QgblRhdUcyID0gKDIgKiogcG93ZXIpO1xuICAgIGZvciAobGV0IGk9MDsgaTwgblRhdUcyOyBpKyspIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUoYnVmZkcyKTtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoKGklMTAwMDAwKSA9PSAwKSYmaSkgbG9nZ2VyLmxvZyhcInRhdUcyOiBcIiArIGkpO1xuICAgIH1cbiAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgYWxwaGFUYXVHMVxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDQpO1xuICAgIGNvbnN0IG5BbGZhVGF1RzEgPSAoMiAqKiBwb3dlcik7XG4gICAgZm9yIChsZXQgaT0wOyBpPCBuQWxmYVRhdUcxOyBpKyspIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUoYnVmZkcxKTtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoKGklMTAwMDAwKSA9PSAwKSYmaSkgbG9nZ2VyLmxvZyhcImFscGhhVGF1RzE6IFwiICsgaSk7XG4gICAgfVxuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSBiZXRhVGF1RzFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA1KTtcbiAgICBjb25zdCBuQmV0YVRhdUcxID0gKDIgKiogcG93ZXIpO1xuICAgIGZvciAobGV0IGk9MDsgaTwgbkJldGFUYXVHMTsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmZHMSk7XG4gICAgICAgIGlmICgobG9nZ2VyKSYmKChpJTEwMDAwMCkgPT0gMCkmJmkpIGxvZ2dlci5sb2coXCJiZXRhVGF1RzE6IFwiICsgaSk7XG4gICAgfVxuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSBiZXRhRzJcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA2KTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmRzIpO1xuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBDb250cmlidXRpb25zXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZCwgNyk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMigwKTsgLy8gMCBDb250cmlidXRpb25zXG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICBjb25zdCBmaXJzdENoYWxsZW5nZUhhc2ggPSBjYWxjdWxhdGVGaXJzdENoYWxsZW5nZUhhc2goY3VydmUsIHBvd2VyLCBsb2dnZXIpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGZvcm1hdEhhc2goYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSkuZGlnZXN0KCksIFwiQmxhbmsgQ29udHJpYnV0aW9uIEhhc2g6XCIpKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goZmlyc3RDaGFsbGVuZ2VIYXNoLCBcIkZpcnN0IENvbnRyaWJ1dGlvbiBIYXNoOlwiKSk7XG5cbiAgICByZXR1cm4gZmlyc3RDaGFsbGVuZ2VIYXNoO1xuXG59XG5cbi8vIEZvcm1hdCBvZiB0aGUgb3V0cHVcblxuYXN5bmMgZnVuY3Rpb24gZXhwb3J0Q2hhbGxlbmdlKHBUYXVGaWxlbmFtZSwgY2hhbGxlbmdlRmlsZW5hbWUsIGxvZ2dlcikge1xuICAgIGNvbnN0IHtmZDogZmRGcm9tLCBzZWN0aW9uc30gPSBhd2FpdCByZWFkQmluRmlsZShwVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcblxuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgcmVhZFBUYXVIZWFkZXIoZmRGcm9tLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBjb250cmlidXRpb25zID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbnMoZmRGcm9tLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuICAgIGxldCBsYXN0UmVzcG9uc2VIYXNoLCBjdXJDaGFsbGVuZ2VIYXNoO1xuICAgIGlmIChjb250cmlidXRpb25zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGxhc3RSZXNwb25zZUhhc2ggPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KS5kaWdlc3QoKTtcbiAgICAgICAgY3VyQ2hhbGxlbmdlSGFzaCA9IGNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RSZXNwb25zZUhhc2ggPSBjb250cmlidXRpb25zW2NvbnRyaWJ1dGlvbnMubGVuZ3RoLTFdLnJlc3BvbnNlSGFzaDtcbiAgICAgICAgY3VyQ2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZTtcbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGxhc3RSZXNwb25zZUhhc2gsIFwiTGFzdCBSZXNwb25zZSBIYXNoOiBcIikpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChjdXJDaGFsbGVuZ2VIYXNoLCBcIk5ldyBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuXG4gICAgY29uc3QgZmRUbyA9IGF3YWl0IGNyZWF0ZU92ZXJyaWRlKGNoYWxsZW5nZUZpbGVuYW1lKTtcblxuICAgIGNvbnN0IHRvSGFzaCA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIGF3YWl0IGZkVG8ud3JpdGUobGFzdFJlc3BvbnNlSGFzaCk7XG4gICAgdG9IYXNoLnVwZGF0ZShsYXN0UmVzcG9uc2VIYXNoKTtcblxuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oMiwgXCJHMVwiLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIpO1xuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oMywgXCJHMlwiLCAoMiAqKiBwb3dlcikgICAgICAgLCBcInRhdUcyXCIpO1xuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oNCwgXCJHMVwiLCAoMiAqKiBwb3dlcikgICAgICAgLCBcImFscGhhVGF1RzFcIik7XG4gICAgYXdhaXQgZXhwb3J0U2VjdGlvbig1LCBcIkcxXCIsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIpO1xuICAgIGF3YWl0IGV4cG9ydFNlY3Rpb24oNiwgXCJHMlwiLCAxICAgICAgICAgICAgICAgICAgLCBcImJldGFHMlwiKTtcblxuICAgIGF3YWl0IGZkRnJvbS5jbG9zZSgpO1xuICAgIGF3YWl0IGZkVG8uY2xvc2UoKTtcblxuICAgIGNvbnN0IGNhbGNDdXJDaGFsbGVuZ2VIYXNoID0gdG9IYXNoLmRpZ2VzdCgpO1xuXG4gICAgaWYgKCFoYXNoSXNFcXVhbCAoY3VyQ2hhbGxlbmdlSGFzaCwgY2FsY0N1ckNoYWxsZW5nZUhhc2gpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goY2FsY0N1ckNoYWxsZW5nZUhhc2gsIFwiQ2FsYyBDdXJyZXQgQ2hhbGxlbmdlIEhhc2g6IFwiKSk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUFRhdSBmaWxlIGlzIGNvcnJ1cHRlZC4gQ2FsY3VsYXRlZCBuZXcgY2hhbGxlbmdlIGhhc2ggZG9lcyBub3QgbWF0Y2ggd2l0aCB0aGUgZWNsYXJlZCBvbmVcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBUYXUgZmlsZSBpcyBjb3JydXB0ZWQuIENhbGN1bGF0ZWQgbmV3IGNoYWxsZW5nZSBoYXNoIGRvZXMgbm90IG1hdGNoIHdpdGggdGhlIGVjbGFyZWQgb25lXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJDaGFsbGVuZ2VIYXNoO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gZXhwb3J0U2VjdGlvbihzZWN0aW9uSWQsIGdyb3VwTmFtZSwgblBvaW50cywgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zRyk7XG5cbiAgICAgICAgYXdhaXQgc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZEZyb20sIHNlY3Rpb25zLCBzZWN0aW9uSWQpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkrPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgRXhwb3J0aW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG4gICAgICAgICAgICBsZXQgYnVmZjtcbiAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChuKnNHKTtcbiAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmJhdGNoTEVNdG9VKGJ1ZmYpO1xuICAgICAgICAgICAgYXdhaXQgZmRUby53cml0ZShidWZmKTtcbiAgICAgICAgICAgIHRvSGFzaC51cGRhdGUoYnVmZik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmRGcm9tKTtcbiAgICB9XG5cblxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBpbXBvcnRSZXNwb25zZShvbGRQdGF1RmlsZW5hbWUsIGNvbnRyaWJ1dGlvbkZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIG5hbWUsIGltcG9ydFBvaW50cywgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBub0hhc2ggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPDY0OyBpKyspIG5vSGFzaFtpXSA9IDB4RkY7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCByZWFkQmluRmlsZShvbGRQdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY29udHJpYnV0aW9ucyA9IGF3YWl0IHJlYWRDb250cmlidXRpb25zKGZkT2xkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuICAgIGNvbnN0IGN1cnJlbnRDb250cmlidXRpb24gPSB7fTtcblxuICAgIGlmIChuYW1lKSBjdXJyZW50Q29udHJpYnV0aW9uLm5hbWUgPSBuYW1lO1xuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRjEubjgqMjtcbiAgICBjb25zdCBzY0cxID0gY3VydmUuRjEubjg7IC8vIENvbXByZXNzZWQgc2l6ZVxuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkYyLm44KjI7XG4gICAgY29uc3Qgc2NHMiA9IGN1cnZlLkYyLm44OyAvLyBDb21wcmVzc2VkIHNpemVcblxuICAgIGNvbnN0IGZkUmVzcG9uc2UgPSBhd2FpdCByZWFkRXhpc3RpbmcoY29udHJpYnV0aW9uRmlsZW5hbWUpO1xuXG4gICAgaWYgIChmZFJlc3BvbnNlLnRvdGFsU2l6ZSAhPVxuICAgICAgICA2NCArICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9sZCBIYXNoXG4gICAgICAgICgoMiAqKiBwb3dlcikqMi0xKSpzY0cxICtcbiAgICAgICAgKDIgKiogcG93ZXIpKnNjRzIgK1xuICAgICAgICAoMiAqKiBwb3dlcikqc2NHMSArXG4gICAgICAgICgyICoqIHBvd2VyKSpzY0cxICtcbiAgICAgICAgc2NHMiArXG4gICAgICAgIHNHMSo2ICsgc0cyKjMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpemUgb2YgdGhlIGNvbnRyaWJ1dGlvbiBpcyBpbnZhbGlkXCIpO1xuXG4gICAgbGV0IGxhc3RDaGFsbGVuZ2VIYXNoO1xuXG4gICAgaWYgKGNvbnRyaWJ1dGlvbnMubGVuZ3RoPjApIHtcbiAgICAgICAgbGFzdENoYWxsZW5nZUhhc2ggPSBjb250cmlidXRpb25zW2NvbnRyaWJ1dGlvbnMubGVuZ3RoLTFdLm5leHRDaGFsbGVuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdENoYWxsZW5nZUhhc2ggPSBjYWxjdWxhdGVGaXJzdENoYWxsZW5nZUhhc2goY3VydmUsIHBvd2VyLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgY3JlYXRlQmluRmlsZShuZXdQVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxLCBpbXBvcnRQb2ludHMgPyA3OiAyKTtcbiAgICBhd2FpdCB3cml0ZVBUYXVIZWFkZXIoZmROZXcsIGN1cnZlLCBwb3dlcik7XG5cbiAgICBjb25zdCBjb250cmlidXRpb25QcmV2aW91c0hhc2ggPSBhd2FpdCBmZFJlc3BvbnNlLnJlYWQoNjQpO1xuXG4gICAgaWYgKGhhc2hJc0VxdWFsKG5vSGFzaCxsYXN0Q2hhbGxlbmdlSGFzaCkpIHtcbiAgICAgICAgbGFzdENoYWxsZW5nZUhhc2ggPSBjb250cmlidXRpb25QcmV2aW91c0hhc2g7XG4gICAgICAgIGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZSA9IGxhc3RDaGFsbGVuZ2VIYXNoO1xuICAgIH1cblxuICAgIGlmKCFoYXNoSXNFcXVhbChjb250cmlidXRpb25QcmV2aW91c0hhc2gsbGFzdENoYWxsZW5nZUhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBjb250cmlidXRpb24uIFRoaXMgY29udHJpYnV0aW9uIGlzIG5vdCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgaGFzaFwiKTtcblxuICAgIGNvbnN0IGhhc2hlclJlc3BvbnNlID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgaGFzaGVyUmVzcG9uc2UudXBkYXRlKGNvbnRyaWJ1dGlvblByZXZpb3VzSGFzaCk7XG5cbiAgICBjb25zdCBzdGFydFNlY3Rpb25zID0gW107XG4gICAgbGV0IHJlcztcbiAgICByZXMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbihmZFJlc3BvbnNlLCBmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBbMV0sIFwidGF1RzFcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi50YXVHMSA9IHJlc1swXTtcbiAgICByZXMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbihmZFJlc3BvbnNlLCBmZE5ldywgXCJHMlwiLCAzLCAoMiAqKiBwb3dlcikgICAgICAgLCBbMV0sIFwidGF1RzJcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi50YXVHMiA9IHJlc1swXTtcbiAgICByZXMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbihmZFJlc3BvbnNlLCBmZE5ldywgXCJHMVwiLCA0LCAoMiAqKiBwb3dlcikgICAgICAgLCBbMF0sIFwiYWxwaGFHMVwiKTtcbiAgICBjdXJyZW50Q29udHJpYnV0aW9uLmFscGhhRzEgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzFcIiwgNSwgKDIgKiogcG93ZXIpICAgICAgICwgWzBdLCBcImJldGFHMVwiKTtcbiAgICBjdXJyZW50Q29udHJpYnV0aW9uLmJldGFHMSA9IHJlc1swXTtcbiAgICByZXMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbihmZFJlc3BvbnNlLCBmZE5ldywgXCJHMlwiLCA2LCAxICAgICAgICAgICAgICAgICAgLCBbMF0sIFwiYmV0YUcyXCIpO1xuICAgIGN1cnJlbnRDb250cmlidXRpb24uYmV0YUcyID0gcmVzWzBdO1xuXG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5wYXJ0aWFsSGFzaCA9IHRvUGFydGlhbEhhc2goaGFzaGVyUmVzcG9uc2UpO1xuXG5cbiAgICBjb25zdCBidWZmS2V5ID0gYXdhaXQgZmRSZXNwb25zZS5yZWFkKGN1cnZlLkYxLm44KjIqNitjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5rZXkgPSBmcm9tUHRhdVB1YktleVJwcihidWZmS2V5LCAwLCBjdXJ2ZSwgZmFsc2UpO1xuXG4gICAgaGFzaGVyUmVzcG9uc2UudXBkYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZLZXkpKTtcbiAgICBjb25zdCBoYXNoUmVzcG9uc2UgPSBoYXNoZXJSZXNwb25zZS5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goaGFzaFJlc3BvbnNlLCBcIkNvbnRyaWJ1dGlvbiBSZXNwb25zZSBIYXNoIGltcG9ydGVkOiBcIikpO1xuXG4gICAgaWYgKGltcG9ydFBvaW50cykge1xuICAgICAgICBjb25zdCBuZXh0Q2hhbGxlbmdlSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGhhc2hSZXNwb25zZSk7XG5cbiAgICAgICAgYXdhaXQgaGFzaFNlY3Rpb24obmV4dENoYWxsZW5nZUhhc2hlciwgZmROZXcsIFwiRzFcIiwgMiwgKDIgKiogcG93ZXIpICogMiAtMSwgXCJ0YXVHMVwiLCBsb2dnZXIpO1xuICAgICAgICBhd2FpdCBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZE5ldywgXCJHMlwiLCAzLCAoMiAqKiBwb3dlcikgICAgICAgLCBcInRhdUcyXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcxXCIsIDQsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgICAgICBhd2FpdCBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZE5ldywgXCJHMVwiLCA1LCAoMiAqKiBwb3dlcikgICAgICAgLCBcImJldGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgICAgICBhd2FpdCBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZE5ldywgXCJHMlwiLCA2LCAxICAgICAgICAgICAgICAgICAgLCBcImJldGFHMlwiLCBsb2dnZXIpO1xuXG4gICAgICAgIGN1cnJlbnRDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSA9IG5leHRDaGFsbGVuZ2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChjdXJyZW50Q29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Q29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2UgPSBub0hhc2g7XG4gICAgfVxuXG4gICAgY29udHJpYnV0aW9ucy5wdXNoKGN1cnJlbnRDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgd3JpdGVDb250cmlidXRpb25zKGZkTmV3LCBjdXJ2ZSwgY29udHJpYnV0aW9ucyk7XG5cbiAgICBhd2FpdCBmZFJlc3BvbnNlLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIGN1cnJlbnRDb250cmlidXRpb24ubmV4dENoYWxsZW5nZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uKGZkRnJvbSwgZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNpbmd1bGFyUG9pbnRJbmRleGVzLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBpZiAoaW1wb3J0UG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvY2Vzc1NlY3Rpb25JbXBvcnRQb2ludHMoZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm9jZXNzU2VjdGlvbk5vSW1wb3J0UG9pbnRzKGZkRnJvbSwgZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNpbmd1bGFyUG9pbnRJbmRleGVzLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbkltcG9ydFBvaW50cyhmZEZyb20sIGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzaW5ndWxhclBvaW50SW5kZXhlcywgc2VjdGlvbk5hbWUpIHtcblxuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc2NHID0gRy5GLm44O1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHNpbmd1bGFyUG9pbnRzID0gW107XG5cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRUbywgc2VjdGlvbklkKTtcbiAgICAgICAgY29uc3QgblBvaW50c0NodW5rID0gTWF0aC5mbG9vcigoMTw8MjQpL3NHKTtcblxuICAgICAgICBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF0gPSBmZFRvLnBvcztcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkgKz0gblBvaW50c0NodW5rKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEltcG9ydGluZyAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cy1pLCBuUG9pbnRzQ2h1bmspO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmQyA9IGF3YWl0IGZkRnJvbS5yZWFkKG4gKiBzY0cpO1xuICAgICAgICAgICAgaGFzaGVyUmVzcG9uc2UudXBkYXRlKGJ1ZmZDKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZkxFTSA9IGF3YWl0IEcuYmF0Y2hDdG9MRU0oYnVmZkMpO1xuXG4gICAgICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmZMRU0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHNpbmd1bGFyUG9pbnRJbmRleGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3AgPSBzaW5ndWxhclBvaW50SW5kZXhlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoKHNwID49aSkgJiYgKHNwIDwgaStuKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBQID0gRy5mcm9tUnByTEVNKGJ1ZmZMRU0sIChzcC1pKSpzRyk7XG4gICAgICAgICAgICAgICAgICAgIHNpbmd1bGFyUG9pbnRzLnB1c2goUCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkVG8pO1xuXG4gICAgICAgIHJldHVybiBzaW5ndWxhclBvaW50cztcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uTm9JbXBvcnRQb2ludHMoZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKSB7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNjRyA9IEcuRi5uODtcblxuICAgICAgICBjb25zdCBzaW5ndWxhclBvaW50cyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zY0cpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgblBvaW50czsgaSArPSBuUG9pbnRzQ2h1bmspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSW1wb3J0aW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDID0gYXdhaXQgZmRGcm9tLnJlYWQobiAqIHNjRyk7XG4gICAgICAgICAgICBoYXNoZXJSZXNwb25zZS51cGRhdGUoYnVmZkMpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8c2luZ3VsYXJQb2ludEluZGV4ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcCA9IHNpbmd1bGFyUG9pbnRJbmRleGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICgoc3AgPj1pKSAmJiAoc3AgPCBpK24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJDb21wcmVzc2VkKGJ1ZmZDLCAoc3AtaSkqc2NHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2luZ3VsYXJQb2ludHM7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIGNvbnN0IG9sZFBvcyA9IGZkVG8ucG9zO1xuICAgICAgICBmZFRvLnBvcyA9IHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkgKz0gblBvaW50c0NodW5rKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEhhc2hpbmcgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMtaSwgblBvaW50c0NodW5rKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZkxFTSA9IGF3YWl0IGZkVG8ucmVhZChuICogc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmVSA9IGF3YWl0IEcuYmF0Y2hMRU10b1UoYnVmZkxFTSk7XG5cbiAgICAgICAgICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGJ1ZmZVKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZkVG8ucG9zID0gb2xkUG9zO1xuICAgIH1cblxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuY29uc3Qgc2FtZVJhdGlvJDEgPSBzYW1lUmF0aW8kMjtcblxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5Q29udHJpYnV0aW9uKGN1cnZlLCBjdXIsIHByZXYsIGxvZ2dlcikge1xuICAgIGxldCBzcjtcbiAgICBpZiAoY3VyLnR5cGUgPT0gMSkgeyAgICAvLyBWZXJpZnkgdGhlIGJlYWNvbi5cbiAgICAgICAgY29uc3QgYmVhY29uS2V5ID0gYXdhaXQga2V5RnJvbUJlYWNvbihjdXJ2ZSwgcHJldi5uZXh0Q2hhbGxlbmdlLCBjdXIuYmVhY29uSGFzaCwgY3VyLm51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS50YXUuZzFfcywgYmVhY29uS2V5LnRhdS5nMV9zKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5ICh0YXVHMV9zKSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkudGF1LmcxX3N4LCBiZWFjb25LZXkudGF1LmcxX3N4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5ICh0YXVHMV9zeCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXIua2V5LnRhdS5nMl9zcHgsIGJlYWNvbktleS50YXUuZzJfc3B4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5ICh0YXVHMl9zcHgpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LmFscGhhLmcxX3MsIGJlYWNvbktleS5hbHBoYS5nMV9zKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChhbHBoYUcxX3MpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS5hbHBoYS5nMV9zeCwgYmVhY29uS2V5LmFscGhhLmcxX3N4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChhbHBoYUcxX3N4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcyLmVxKGN1ci5rZXkuYWxwaGEuZzJfc3B4LCBiZWFjb25LZXkuYWxwaGEuZzJfc3B4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChhbHBoYUcyX3NweCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkuYmV0YS5nMV9zLCBiZWFjb25LZXkuYmV0YS5nMV9zKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChiZXRhRzFfcykgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LmJldGEuZzFfc3gsIGJlYWNvbktleS5iZXRhLmcxX3N4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChiZXRhRzFfc3gpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzIuZXEoY3VyLmtleS5iZXRhLmcyX3NweCwgYmVhY29uS2V5LmJldGEuZzJfc3B4KSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBCRUFDT04ga2V5IChiZXRhRzJfc3B4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGN1ci5rZXkudGF1LmcyX3NwID0gY3VydmUuRzIudG9BZmZpbmUoZ2V0RzJzcChjdXJ2ZSwgMCwgcHJldi5uZXh0Q2hhbGxlbmdlLCBjdXIua2V5LnRhdS5nMV9zLCBjdXIua2V5LnRhdS5nMV9zeCkpO1xuICAgIGN1ci5rZXkuYWxwaGEuZzJfc3AgPSBjdXJ2ZS5HMi50b0FmZmluZShnZXRHMnNwKGN1cnZlLCAxLCBwcmV2Lm5leHRDaGFsbGVuZ2UsIGN1ci5rZXkuYWxwaGEuZzFfcywgY3VyLmtleS5hbHBoYS5nMV9zeCkpO1xuICAgIGN1ci5rZXkuYmV0YS5nMl9zcCA9IGN1cnZlLkcyLnRvQWZmaW5lKGdldEcyc3AoY3VydmUsIDIsIHByZXYubmV4dENoYWxsZW5nZSwgY3VyLmtleS5iZXRhLmcxX3MsIGN1ci5rZXkuYmV0YS5nMV9zeCkpO1xuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8kMShjdXJ2ZSwgY3VyLmtleS50YXUuZzFfcywgY3VyLmtleS50YXUuZzFfc3gsIGN1ci5rZXkudGF1LmcyX3NwLCBjdXIua2V5LnRhdS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGtleSAodGF1KSBpbiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCBjdXIua2V5LmFscGhhLmcxX3MsIGN1ci5rZXkuYWxwaGEuZzFfc3gsIGN1ci5rZXkuYWxwaGEuZzJfc3AsIGN1ci5rZXkuYWxwaGEuZzJfc3B4KTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCBrZXkgKGFscGhhKSBpbiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCBjdXIua2V5LmJldGEuZzFfcywgY3VyLmtleS5iZXRhLmcxX3N4LCBjdXIua2V5LmJldGEuZzJfc3AsIGN1ci5rZXkuYmV0YS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGtleSAoYmV0YSkgaW4gY2hhbGxlbmdlICNcIitjdXIuaWQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8kMShjdXJ2ZSwgcHJldi50YXVHMSwgY3VyLnRhdUcxLCBjdXIua2V5LnRhdS5nMl9zcCwgY3VyLmtleS50YXUuZzJfc3B4KTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCB0YXUqRzEuIGNoYWxsZW5nZSAjXCIrY3VyLmlkK1wiIEl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8kMShjdXJ2ZSwgIGN1ci5rZXkudGF1LmcxX3MsIGN1ci5rZXkudGF1LmcxX3N4LCBwcmV2LnRhdUcyLCBjdXIudGF1RzIpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIHRhdSpHMi4gY2hhbGxlbmdlICNcIitjdXIuaWQrXCIgSXQgZG9lcyBub3QgZm9sbG93IHRoZSBwcmV2aW91cyBjb250cmlidXRpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCBwcmV2LmFscGhhRzEsIGN1ci5hbHBoYUcxLCBjdXIua2V5LmFscGhhLmcyX3NwLCBjdXIua2V5LmFscGhhLmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgYWxwaGEqRzEuIGNoYWxsZW5nZSAjXCIrY3VyLmlkK1wiIEl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8kMShjdXJ2ZSwgcHJldi5iZXRhRzEsIGN1ci5iZXRhRzEsIGN1ci5rZXkuYmV0YS5nMl9zcCwgY3VyLmtleS5iZXRhLmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgYmV0YSpHMS4gY2hhbGxlbmdlICNcIitjdXIuaWQrXCIgSXQgZG9lcyBub3QgZm9sbG93IHRoZSBwcmV2aW91cyBjb250cmlidXRpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCAgY3VyLmtleS5iZXRhLmcxX3MsIGN1ci5rZXkuYmV0YS5nMV9zeCwgcHJldi5iZXRhRzIsIGN1ci5iZXRhRzIpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGJldGEqRzIuIGNoYWxsZW5nZSAjXCIrY3VyLmlkK1wiSXQgZG9lcyBub3QgZm9sbG93IHRoZSBwcmV2aW91cyBjb250cmlidXRpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlBvd2VycyBPZiB0YXUgZmlsZSBPSyFcIik7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeSh0YXVGaWxlbmFtZSwgbG9nZ2VyKSB7XG4gICAgbGV0IHNyO1xuXG4gICAgY29uc3Qge2ZkLCBzZWN0aW9uc30gPSBhd2FpdCByZWFkQmluRmlsZSh0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9ID0gYXdhaXQgcmVhZFBUYXVIZWFkZXIoZmQsIHNlY3Rpb25zKTtcbiAgICBjb25zdCBjb250cnMgPSBhd2FpdCByZWFkQ29udHJpYnV0aW9ucyhmZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcInBvd2VyOiAyKipcIiArIHBvd2VyKTtcbiAgICAvLyBWZXJpZnkgTGFzdCBjb250cmlidXRpb25cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNvbXB1dGluZyBpbml0aWFsIGNvbnRyaWJ1dGlvbiBoYXNoXCIpO1xuICAgIGNvbnN0IGluaXRpYWxDb250cmlidXRpb24gPSB7XG4gICAgICAgIHRhdUcxOiBjdXJ2ZS5HMS5nLFxuICAgICAgICB0YXVHMjogY3VydmUuRzIuZyxcbiAgICAgICAgYWxwaGFHMTogY3VydmUuRzEuZyxcbiAgICAgICAgYmV0YUcxOiBjdXJ2ZS5HMS5nLFxuICAgICAgICBiZXRhRzI6IGN1cnZlLkcyLmcsXG4gICAgICAgIG5leHRDaGFsbGVuZ2U6IGNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgY2VyZW1vbnlQb3dlciwgbG9nZ2VyKSxcbiAgICAgICAgcmVzcG9uc2VIYXNoOiBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KS5kaWdlc3QoKVxuICAgIH07XG5cbiAgICBpZiAoY29udHJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlRoaXMgZmlsZSBoYXMgbm8gY29udHJpYnV0aW9uISBJdCBjYW5ub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHByZXZDb250cjtcbiAgICBpZiAoY29udHJzLmxlbmd0aD4xKSB7XG4gICAgICAgIHByZXZDb250ciA9IGNvbnRyc1tjb250cnMubGVuZ3RoLTJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZDb250ciA9IGluaXRpYWxDb250cmlidXRpb247XG4gICAgfVxuICAgIGNvbnN0IGN1ckNvbnRyID0gY29udHJzW2NvbnRycy5sZW5ndGgtMV07XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmFsaWRhdGluZyBjb250cmlidXRpb24gI1wiK2NvbnRyc1tjb250cnMubGVuZ3RoLTFdLmlkKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcblxuXG4gICAgY29uc3QgbmV4dENvbnRyaWJ1dGlvbkhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIG5leHRDb250cmlidXRpb25IYXNoZXIudXBkYXRlKGN1ckNvbnRyLnJlc3BvbnNlSGFzaCk7XG5cbiAgICAvLyBWZXJpZnkgcG93ZXJzIGFuZCBjb21wdXRlIG5leHRDaGFsbGVuZ2VIYXNoXG5cbiAgICAvLyBhd2FpdCB0ZXN0KCk7XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiB0YXUqRzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIHRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJUYXUxID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgXCJHMVwiLCBcInRhdUcxXCIsICgyICoqIHBvd2VyKSoyLTEsIFswLCAxXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCByVGF1MS5SMSwgclRhdTEuUjIsIGN1cnZlLkcyLmcsIGN1ckNvbnRyLnRhdUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwidGF1RzEgc2VjdGlvbi4gUG93ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcxLmVxKGN1cnZlLkcxLmcsIHJUYXUxLnNpbmd1bGFyUG9pbnRzWzBdKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJGaXJzdCBlbGVtZW50IG9mIHRhdSpHMSBzZWN0aW9uIG11c3QgYmUgdGhlIGdlbmVyYXRvclwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ckNvbnRyLnRhdUcxLCByVGF1MS5zaW5ndWxhclBvaW50c1sxXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiU2Vjb25kIGVsZW1lbnQgb2YgdGF1KkcxIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2ggdGhlIG9uZSBpbiB0aGUgY29udHJpYnV0aW9uIHNlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBhd2FpdCB0ZXN0KCk7XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiB0YXUqRzJcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIHRhdSpHMiBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJUYXUyID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMywgXCJHMlwiLCBcInRhdUcyXCIsIDIgKiogcG93ZXIsIFswLCAxXSwgIGxvZ2dlcik7XG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8kMShjdXJ2ZSwgY3VydmUuRzEuZywgY3VyQ29udHIudGF1RzEsIHJUYXUyLlIxLCByVGF1Mi5SMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcInRhdUcyIHNlY3Rpb24uIFBvd2VycyBkbyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXJ2ZS5HMi5nLCByVGF1Mi5zaW5ndWxhclBvaW50c1swXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiRmlyc3QgZWxlbWVudCBvZiB0YXUqRzIgc2VjdGlvbiBtdXN0IGJlIHRoZSBnZW5lcmF0b3JcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXJDb250ci50YXVHMiwgclRhdTIuc2luZ3VsYXJQb2ludHNbMV0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlNlY29uZCBlbGVtZW50IG9mIHRhdSpHMiBzZWN0aW9uIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IFNlY3Rpb24gYWxwaGEqdGF1KkcxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiBhbHBoYSp0YXUqRzEgc2VjdGlvblwiKTtcbiAgICBjb25zdCByQWxwaGFUYXVHMSA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDQsIFwiRzFcIiwgXCJhbHBoYXRhdUcxXCIsIDIgKiogcG93ZXIsIFswXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCByQWxwaGFUYXVHMS5SMSwgckFscGhhVGF1RzEuUjIsIGN1cnZlLkcyLmcsIGN1ckNvbnRyLnRhdUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiYWxwaGFUYXVHMSBzZWN0aW9uLiBQb3dlcnMgZG8gbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoY3VyQ29udHIuYWxwaGFHMSwgckFscGhhVGF1RzEuc2luZ3VsYXJQb2ludHNbMF0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkZpcnN0IGVsZW1lbnQgb2YgYWxwaGEqdGF1KkcxIHNlY3Rpb24gKGFscGhhKkcxKSBkb2VzIG5vdCBtYXRjaCB0aGUgb25lIGluIHRoZSBjb250cmlidXRpb24gc2VjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSBTZWN0aW9uIGJldGEqdGF1KkcxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiBiZXRhKnRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJCZXRhVGF1RzEgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig1LCBcIkcxXCIsIFwiYmV0YXRhdUcxXCIsIDIgKiogcG93ZXIsIFswXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyQxKGN1cnZlLCByQmV0YVRhdUcxLlIxLCByQmV0YVRhdUcxLlIyLCBjdXJ2ZS5HMi5nLCBjdXJDb250ci50YXVHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcImJldGFUYXVHMSBzZWN0aW9uLiBQb3dlcnMgZG8gbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoY3VyQ29udHIuYmV0YUcxLCByQmV0YVRhdUcxLnNpbmd1bGFyUG9pbnRzWzBdKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJGaXJzdCBlbGVtZW50IG9mIGJldGEqdGF1KkcxIHNlY3Rpb24gKGJldGEqRzEpIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy9WZXJpZnkgQmV0YSBHMlxuICAgIGNvbnN0IGJldGFHMiA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uQmV0YUcyKGxvZ2dlcik7XG4gICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXJDb250ci5iZXRhRzIsIGJldGFHMikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiYmV0YUcyIGVsZW1lbnQgaW4gYmV0YUcyIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2ggdGhlIG9uZSBpbiB0aGUgY29udHJpYnV0aW9uIHNlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIGNvbnN0IG5leHRDb250cmlidXRpb25IYXNoID0gbmV4dENvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgIC8vIENoZWNrIHRoZSBuZXh0Q2hhbGxlbmdlSGFzaFxuICAgIGlmIChwb3dlciA9PSBjZXJlbW9ueVBvd2VyKSB7XG4gICAgICAgIGlmICghaGFzaElzRXF1YWwobmV4dENvbnRyaWJ1dGlvbkhhc2gsY3VyQ29udHIubmV4dENoYWxsZW5nZSkpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkhhc2ggb2YgdGhlIHZhbHVlcyBkb2VzIG5vdCBtYXRjaCB0aGUgbmV4dCBjaGFsbGVuZ2Ugb2YgdGhlIGxhc3QgY29udHJpYnV0b3IgaW4gdGhlIGNvbnRyaWJ1dGlvbnMgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2gobmV4dENvbnRyaWJ1dGlvbkhhc2gsIFwiTmV4dCBjaGFsbGVuZ2UgaGFzaDogXCIpKTtcblxuICAgIC8vIFZlcmlmeSBQcmV2aW91cyBjb250cmlidXRpb25zXG5cbiAgICBwcmludENvbnRyaWJ1dGlvbihjdXJDb250ciwgcHJldkNvbnRyKTtcbiAgICBmb3IgKGxldCBpID0gY29udHJzLmxlbmd0aC0yOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY3VyQ29udHIgPSBjb250cnNbaV07XG4gICAgICAgIGNvbnN0IHByZXZDb250ciA9ICAoaT4wKSA/IGNvbnRyc1tpLTFdIDogaW5pdGlhbENvbnRyaWJ1dGlvbjtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdmVyaWZ5Q29udHJpYnV0aW9uKGN1cnZlLCBjdXJDb250ciwgcHJldkNvbnRyLCBsb2dnZXIpO1xuICAgICAgICBpZiAoIXJlcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwcmludENvbnRyaWJ1dGlvbihjdXJDb250ciwgcHJldkNvbnRyKTtcbiAgICB9XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcblxuICAgIGlmICgoIXNlY3Rpb25zWzEyXSkgfHwgKCFzZWN0aW9uc1sxM10pIHx8ICghc2VjdGlvbnNbMTRdKSB8fCAoIXNlY3Rpb25zWzE1XSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBcInRoaXMgZmlsZSBkb2VzIG5vdCBjb250YWluIHBoYXNlMiBwcmVjYWxjdWxhdGVkIHZhbHVlcy4gUGxlYXNlIHJ1bjogXFxuXCIgK1xuICAgICAgICAgICAgXCIgICBzbmFya2pzIFxcXCJwb3dlcnNvZnRhdSBwcmVwYXJlcGhhc2UyXFxcIiB0byBwcmVwYXJlIHRoaXMgZmlsZSB0byBiZSB1c2VkIGluIHRoZSBwaGFzZTIgY2VyZW1vbnkuXCJcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICByZXMgPSBhd2FpdCB2ZXJpZnlMYWdyYW5nZUV2YWx1YXRpb25zKFwiRzFcIiwgMiwgMTIsIFwidGF1RzFcIiwgbG9nZ2VyKTtcbiAgICAgICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmVzID0gYXdhaXQgdmVyaWZ5TGFncmFuZ2VFdmFsdWF0aW9ucyhcIkcyXCIsIDMsIDEzLCBcInRhdUcyXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJlcyA9IGF3YWl0IHZlcmlmeUxhZ3JhbmdlRXZhbHVhdGlvbnMoXCJHMVwiLCA0LCAxNCwgXCJhbHBoYVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJlcyA9IGF3YWl0IHZlcmlmeUxhZ3JhbmdlRXZhbHVhdGlvbnMoXCJHMVwiLCA1LCAxNSwgXCJiZXRhVGF1RzFcIiwgbG9nZ2VyKTtcbiAgICAgICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJQb3dlcnMgb2YgVGF1IE9rIVwiKTtcblxuICAgIHJldHVybiB0cnVlO1xuXG4gICAgZnVuY3Rpb24gcHJpbnRDb250cmlidXRpb24oY3VyQ29udHIsIHByZXZDb250cikge1xuICAgICAgICBpZiAoIWxvZ2dlcikgcmV0dXJuO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgQ29udHJpYnV0aW9uICMke2N1ckNvbnRyLmlkfTogJHtjdXJDb250ci5uYW1lIHx8XCJcIn1gKTtcblxuICAgICAgICBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGN1ckNvbnRyLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2U6IFwiKSk7XG5cbiAgICAgICAgY29uc3QgYnVmZlYgID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKjYrY3VydmUuRzIuRi5uOCoyKjMpO1xuICAgICAgICB0b1B0YXVQdWJLZXlScHIoYnVmZlYsIDAsIGN1cnZlLCBjdXJDb250ci5rZXksIGZhbHNlKTtcblxuICAgICAgICBjb25zdCByZXNwb25zZUhhc2hlciA9ICBmcm9tUGFydGlhbEhhc2goY3VyQ29udHIucGFydGlhbEhhc2gpO1xuICAgICAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZlYpO1xuICAgICAgICBjb25zdCByZXNwb25zZUhhc2ggPSByZXNwb25zZUhhc2hlci5kaWdlc3QoKTtcblxuICAgICAgICBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKHJlc3BvbnNlSGFzaCwgXCJSZXNwb25zZSBIYXNoOlwiKSk7XG5cbiAgICAgICAgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChwcmV2Q29udHIubmV4dENoYWxsZW5nZSwgXCJSZXNwb25zZSBIYXNoOlwiKSk7XG5cbiAgICAgICAgaWYgKGN1ckNvbnRyLnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEJlYWNvbiBnZW5lcmF0b3I6ICR7Ynl0ZUFycmF5MmhleChjdXJDb250ci5iZWFjb25IYXNoKX1gKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBCZWFjb24gaXRlcmF0aW9ucyBFeHA6ICR7Y3VyQ29udHIubnVtSXRlcmF0aW9uc0V4cH1gKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb25CZXRhRzIobG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZS5HMjtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgYnVmZlV2ID0gbmV3IFVpbnQ4QXJyYXkoc0cpO1xuXG4gICAgICAgIGlmICghc2VjdGlvbnNbNl0pICB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGaWxlIGhhcyBubyBCZXRhRzIgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGUgaGFzIG5vIEJldGFHMiBzZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWN0aW9uc1s2XS5sZW5ndGg+MSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmlsZSBoYXMgbm8gQmV0YUcyIHNlY3Rpb25cIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIGhhcyBtb3JlIHRoYW4gb25lIEdldGFHMiBzZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZkLnBvcyA9IHNlY3Rpb25zWzZdWzBdLnA7XG5cbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoc0cpO1xuICAgICAgICBjb25zdCBQID0gRy5mcm9tUnByTEVNKGJ1ZmYpO1xuXG4gICAgICAgIEcudG9ScHJVbmNvbXByZXNzZWQoYnVmZlV2LCAwLCBQKTtcbiAgICAgICAgbmV4dENvbnRyaWJ1dGlvbkhhc2hlci51cGRhdGUoYnVmZlV2KTtcblxuICAgICAgICByZXR1cm4gUDtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihpZFNlY3Rpb24sIGdyb3VwTmFtZSwgc2VjdGlvbk5hbWUsIG5Qb2ludHMsIHNpbmd1bGFyUG9pbnRJbmRleGVzLCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxPDwxNjtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBpZFNlY3Rpb24pO1xuXG4gICAgICAgIGNvbnN0IHNpbmd1bGFyUG9pbnRzID0gW107XG5cbiAgICAgICAgbGV0IFIxID0gRy56ZXJvO1xuICAgICAgICBsZXQgUjIgPSBHLnplcm87XG5cbiAgICAgICAgbGV0IGxhc3RCYXNlID0gRy56ZXJvO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHBvaW50cyByZWxhdGlvbnM6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c30gYCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzID0gYXdhaXQgZmQucmVhZChuKnNHKTtcblxuICAgICAgICAgICAgY29uc3QgYmFzZXNVID0gYXdhaXQgRy5iYXRjaExFTXRvVShiYXNlcyk7XG4gICAgICAgICAgICBuZXh0Q29udHJpYnV0aW9uSGFzaGVyLnVwZGF0ZShiYXNlc1UpO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsYXJzID0gZ2V0UmFuZG9tQnl0ZXMoNCoobi0xKSk7XG5cbiAgICAgICAgICAgIGlmIChpPjApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEJhc2UgPSBHLmZyb21ScHJMRU0oYmFzZXMsIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByZWFkVUludDMyQkUoZ2V0UmFuZG9tQnl0ZXMoNCksIDApO1xuXG4gICAgICAgICAgICAgICAgUjEgPSBHLmFkZChSMSwgRy50aW1lc1NjYWxhcihsYXN0QmFzZSwgcikpO1xuICAgICAgICAgICAgICAgIFIyID0gRy5hZGQoUjIsIEcudGltZXNTY2FsYXIoZmlyc3RCYXNlLCByKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHIxID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiYXNlcy5zbGljZSgwLCAobi0xKSpzRyksIHNjYWxhcnMpO1xuICAgICAgICAgICAgY29uc3QgcjIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJhc2VzLnNsaWNlKHNHKSwgc2NhbGFycyk7XG5cbiAgICAgICAgICAgIFIxID0gRy5hZGQoUjEsIHIxKTtcbiAgICAgICAgICAgIFIyID0gRy5hZGQoUjIsIHIyKTtcblxuICAgICAgICAgICAgbGFzdEJhc2UgPSBHLmZyb21ScHJMRU0oIGJhc2VzLCAobi0xKSpzRyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxzaW5ndWxhclBvaW50SW5kZXhlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwID0gc2luZ3VsYXJQb2ludEluZGV4ZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKChzcCA+PWkpICYmIChzcCA8IGkrbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgUCA9IEcuZnJvbVJwckxFTShiYXNlcywgKHNwLWkpKnNHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFIxOiBSMSxcbiAgICAgICAgICAgIFIyOiBSMixcbiAgICAgICAgICAgIHNpbmd1bGFyUG9pbnRzOiBzaW5ndWxhclBvaW50c1xuICAgICAgICB9O1xuXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5TGFncmFuZ2VFdmFsdWF0aW9ucyhnTmFtZSwgdGF1U2VjdGlvbiwgbGFncmFuZ2VTZWN0aW9uLCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBWZXJpZnlpbmcgcGhhc2UyIGNhbGN1bGF0ZWQgdmFsdWVzICR7c2VjdGlvbk5hbWV9Li4uYCk7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtnTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3Qgc2VlZD0gbmV3IEFycmF5KDgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgICAgICBzZWVkW2ldID0gcmVhZFVJbnQzMkJFKGdldFJhbmRvbUJ5dGVzKDQpLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHA9MDsgcDw9IHBvd2VyOyBwICsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlQb3dlcihwKTtcbiAgICAgICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGF1U2VjdGlvbiA9PSAyKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlQb3dlcihwb3dlcisxKTtcbiAgICAgICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiB2ZXJpZnlQb3dlcihwKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYFBvd2VyICR7cH0uLi5gKTtcbiAgICAgICAgICAgIGNvbnN0IG44ciA9IGN1cnZlLkZyLm44O1xuICAgICAgICAgICAgY29uc3QgblBvaW50cyA9IDIgKiogcDtcbiAgICAgICAgICAgIGxldCBidWZmX3IgPSBuZXcgVWludDMyQXJyYXkoblBvaW50cyk7XG4gICAgICAgICAgICBsZXQgYnVmZkc7XG5cbiAgICAgICAgICAgIGxldCBybmcgPSBuZXcgQ2hhQ2hhKHNlZWQpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYENyZWF0aW5nIHJhbmRvbSBudW1iZXJzIFBvd2VycyR7cH0uLi5gKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHAgPT0gcG93ZXIrMSkmJihpID09IG5Qb2ludHMtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZl9yW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmX3JbaV0gPSBybmcubmV4dFUzMigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZl9yID0gbmV3IFVpbnQ4QXJyYXkoYnVmZl9yLmJ1ZmZlciwgYnVmZl9yLmJ5dGVPZmZzZXQsIGJ1ZmZfci5ieXRlTGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGByZWFkaW5nIHBvaW50cyBQb3dlcnMke3B9Li4uYCk7XG4gICAgICAgICAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgdGF1U2VjdGlvbik7XG4gICAgICAgICAgICBidWZmRyA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzRyk7XG4gICAgICAgICAgICBpZiAocCA9PSBwb3dlcisxKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmQucmVhZFRvQnVmZmVyKGJ1ZmZHLCAwLCAoblBvaW50cy0xKSpzRyk7XG4gICAgICAgICAgICAgICAgYnVmZkcuc2V0KGN1cnZlLkcxLnplcm9BZmZpbmUsIChuUG9pbnRzLTEpKnNHKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmQucmVhZFRvQnVmZmVyKGJ1ZmZHLCAwLCBuUG9pbnRzKnNHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGVuZFJlYWRTZWN0aW9uKGZkLCB0cnVlKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzVGF1ID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShidWZmRywgYnVmZl9yLCBsb2dnZXIsIHNlY3Rpb25OYW1lICsgXCJfXCIgKyBwKTtcblxuICAgICAgICAgICAgYnVmZl9yID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzICogbjhyKTtcblxuICAgICAgICAgICAgcm5nID0gbmV3IENoYUNoYShzZWVkKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZjQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmY0ViA9IG5ldyBEYXRhVmlldyhidWZmNC5idWZmZXIpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYENyZWF0aW5nIHJhbmRvbSBudW1iZXJzIFBvd2VycyR7cH0uLi5gKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKGkgIT0gblBvaW50cy0xKSB8fCAocCAhPSBwb3dlcisxKSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmNFYuc2V0VWludDMyKDAsIHJuZy5uZXh0VTMyKCksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBidWZmX3Iuc2V0KGJ1ZmY0LCBpKm44cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYGJhdGNoVG9Nb250Z29tZXJ5ICR7cH0uLi5gKTtcbiAgICAgICAgICAgIGJ1ZmZfciA9IGF3YWl0IGN1cnZlLkZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZfcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYGZmdCAke3B9Li4uYCk7XG4gICAgICAgICAgICBidWZmX3IgPSBhd2FpdCBjdXJ2ZS5Gci5mZnQoYnVmZl9yKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgYmF0Y2hGcm9tTW9udGdvbWVyeSAke3B9Li4uYCk7XG4gICAgICAgICAgICBidWZmX3IgPSBhd2FpdCBjdXJ2ZS5Gci5iYXRjaEZyb21Nb250Z29tZXJ5KGJ1ZmZfcik7XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgcmVhZGluZyBwb2ludHMgTGFncmFuZ2Uke3B9Li4uYCk7XG4gICAgICAgICAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgbGFncmFuZ2VTZWN0aW9uKTtcbiAgICAgICAgICAgIGZkLnBvcyArPSBzRyooKDIgKiogcCktMSk7XG4gICAgICAgICAgICBhd2FpdCBmZC5yZWFkVG9CdWZmZXIoYnVmZkcsIDAsIG5Qb2ludHMqc0cpO1xuICAgICAgICAgICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmQsIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCByZXNMYWdyYW5nZSA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZkcsIGJ1ZmZfciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiX1wiICsgcCArIFwiX3RyYW5zZm9ybWVkXCIpO1xuXG4gICAgICAgICAgICBpZiAoIUcuZXEocmVzVGF1LCByZXNMYWdyYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQaGFzZTIgY2FjbHV0YXRpb24gZG9lcyBub3QgbWF0Y2ggd2l0aCBwb3dlcnMgb2YgdGF1XCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8qXG4gICAgVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgbmV3IHNlY3Rpb24gaW4gdGhlIGZkVG8gZmlsZSB3aXRoIGlkIGlkU2VjdGlvbi5cbiAgICBJdCBtdWx0aXBsaWVzIHRoZSBwb2ludHMgaW4gZmRGcm9tIGJ5IGZpcnN0LCBmaXJzdCppbmMsIGZpcnN0KmluY14yLCAuLi4uXG4gICAgblBvaW50IFRpbWVzLlxuICAgIEl0IGFsc28gdXBkYXRlcyB0aGUgbmV3Q2hhbGxlbmdlSGFzaGVyIHdpdGggdGhlIG5ldyBwb2ludHNcbiovXG5cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5S2V5VG9TZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIGlkU2VjdGlvbiwgY3VydmUsIGdyb3VwTmFtZSwgZmlyc3QsIGluYywgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuICAgIGNvbnN0IE1BWF9DSFVOS19TSVpFID0gMSA8PCAxNjtcbiAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgIGNvbnN0IG5Qb2ludHMgPSBzZWN0aW9uc1tpZFNlY3Rpb25dWzBdLnNpemUgLyBzRztcblxuICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLGlkU2VjdGlvbiApO1xuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkTmV3LCBpZFNlY3Rpb24pO1xuXG4gICAgbGV0IHQgPSBmaXJzdDtcbiAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSArPSBNQVhfQ0hVTktfU0laRSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEFwcGx5aW5nIGtleTogJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICBjb25zdCBuPSBNYXRoLm1pbihuUG9pbnRzIC0gaSwgTUFYX0NIVU5LX1NJWkUpO1xuICAgICAgICBsZXQgYnVmZjtcbiAgICAgICAgYnVmZiA9IGF3YWl0IGZkT2xkLnJlYWQobipzRyk7XG4gICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmJhdGNoQXBwbHlLZXkoYnVmZiwgdCwgaW5jKTtcbiAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgIHQgPSBjdXJ2ZS5Gci5tdWwodCwgY3VydmUuRnIuZXhwKGluYywgbikpO1xuICAgIH1cblxuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZE5ldyk7XG4gICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmRPbGQpO1xufVxuXG5cblxuYXN5bmMgZnVuY3Rpb24gYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRPbGQsIGZkTmV3LCByZXNwb25zZUhhc2hlciwgY3VydmUsIGdyb3VwTmFtZSwgblBvaW50cywgZmlyc3QsIGluYywgZm9ybWF0T3V0LCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLmZsb29yKCgxPDwyMCkgLyBzRyk7ICAgLy8gMTI4TWIgY2h1bmtzXG4gICAgbGV0IHQgPSBmaXJzdDtcbiAgICBmb3IgKGxldCBpPTAgOyBpPG5Qb2ludHMgOyBpKz0gY2h1bmtTaXplKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgQXBwbHlpbmcga2V5ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4oblBvaW50cy1pLCBjaHVua1NpemUgKTtcbiAgICAgICAgY29uc3QgYnVmZkluVSA9IGF3YWl0IGZkT2xkLnJlYWQobiAqIHNHKTtcbiAgICAgICAgY29uc3QgYnVmZkluTEVNID0gYXdhaXQgRy5iYXRjaFV0b0xFTShidWZmSW5VKTtcbiAgICAgICAgY29uc3QgYnVmZk91dExFTSA9IGF3YWl0IEcuYmF0Y2hBcHBseUtleShidWZmSW5MRU0sIHQsIGluYyk7XG4gICAgICAgIGxldCBidWZmT3V0O1xuICAgICAgICBpZiAoZm9ybWF0T3V0ID09IFwiQ09NUFJFU1NFRFwiKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gYXdhaXQgRy5iYXRjaExFTXRvQyhidWZmT3V0TEVNKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQgPSBhd2FpdCBHLmJhdGNoTEVNdG9VKGJ1ZmZPdXRMRU0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlSGFzaGVyKSByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZk91dCk7XG4gICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmZPdXQpO1xuICAgICAgICB0ID0gY3VydmUuRnIubXVsKHQsIGN1cnZlLkZyLmV4cChpbmMsIG4pKTtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIGNoYWxsZW5nZUNvbnRyaWJ1dGUoY3VydmUsIGNoYWxsZW5nZUZpbGVuYW1lLCByZXNwb25zZUZpbGVOYW1lLCBlbnRyb3B5LCBsb2dnZXIpIHtcbiAgICBjb25zdCBmZEZyb20gPSBhd2FpdCByZWFkRXhpc3RpbmcoY2hhbGxlbmdlRmlsZW5hbWUpO1xuXG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5GMS5uNjQqOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkYyLm42NCo4KjI7XG4gICAgY29uc3QgZG9tYWluU2l6ZSA9IChmZEZyb20udG90YWxTaXplICsgc0cxIC0gNjQgLSBzRzIpIC8gKDQqc0cxICsgc0cyKTtcbiAgICBsZXQgZSA9IGRvbWFpblNpemU7XG4gICAgbGV0IHBvd2VyID0gMDtcbiAgICB3aGlsZSAoZT4xKSB7XG4gICAgICAgIGUgPSBlIC8yO1xuICAgICAgICBwb3dlciArPSAxO1xuICAgIH1cblxuICAgIGlmICgyICoqIHBvd2VyICE9IGRvbWFpblNpemUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZmlsZSBzaXplXCIpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlBvd2VyIHRvIHRhdSBzaXplOiBcIitwb3dlcik7XG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBnZXRSYW5kb21SbmcoZW50cm9weSk7XG5cbiAgICBjb25zdCBmZFRvID0gYXdhaXQgY3JlYXRlT3ZlcnJpZGUocmVzcG9uc2VGaWxlTmFtZSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGhhc2hcbiAgICBjb25zdCBjaGFsbGVuZ2VIYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTtcbiAgICBmb3IgKGxldCBpPTA7IGk8ZmRGcm9tLnRvdGFsU2l6ZTsgaSs9IGZkRnJvbS5wYWdlU2l6ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEhhc2hpbmcgY2hhbGxlbmdlICR7aX0vJHtmZEZyb20udG90YWxTaXplfWApO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5taW4oZmRGcm9tLnRvdGFsU2l6ZSAtIGksIGZkRnJvbS5wYWdlU2l6ZSk7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChzKTtcbiAgICAgICAgY2hhbGxlbmdlSGFzaGVyLnVwZGF0ZShidWZmKTtcbiAgICB9XG5cbiAgICBjb25zdCBjbGFpbWVkSGFzaCA9IGF3YWl0IGZkRnJvbS5yZWFkKDY0LCAwKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGNsYWltZWRIYXNoLCBcIkNsYWltZWQgUHJldmlvdXMgUmVzcG9uc2UgSGFzaDogXCIpKTtcblxuICAgIGNvbnN0IGNoYWxsZW5nZUhhc2ggPSBjaGFsbGVuZ2VIYXNoZXIuZGlnZXN0KCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChjaGFsbGVuZ2VIYXNoLCBcIkN1cnJlbnQgQ2hhbGxlbmdlIEhhc2g6IFwiKSk7XG5cbiAgICBjb25zdCBrZXkgPSBjcmVhdGVQVGF1S2V5KGN1cnZlLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBbXCJ0YXVcIiwgXCJhbHBoYVwiLCBcImJldGFcIl0uZm9yRWFjaCggKGspID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhrICsgXCIuZzFfczogXCIgKyBjdXJ2ZS5HMS50b1N0cmluZyhrZXlba10uZzFfcywgMTYpKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhrICsgXCIuZzFfc3g6IFwiICsgY3VydmUuRzEudG9TdHJpbmcoa2V5W2tdLmcxX3N4LCAxNikpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGsgKyBcIi5nMl9zcDogXCIgKyBjdXJ2ZS5HMi50b1N0cmluZyhrZXlba10uZzJfc3AsIDE2KSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoayArIFwiLmcyX3NweDogXCIgKyBjdXJ2ZS5HMi50b1N0cmluZyhrZXlba10uZzJfc3B4LCAxNikpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZUhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuXG4gICAgYXdhaXQgZmRUby53cml0ZShjaGFsbGVuZ2VIYXNoKTtcbiAgICByZXNwb25zZUhhc2hlci51cGRhdGUoY2hhbGxlbmdlSGFzaCk7XG5cbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIHJlc3BvbnNlSGFzaGVyLCBjdXJ2ZSwgXCJHMVwiLCAoMiAqKiBwb3dlcikqMi0xLCBjdXJ2ZS5Gci5vbmUgICAgLCBrZXkudGF1LnBydktleSwgXCJDT01QUkVTU0VEXCIsIFwidGF1RzFcIiAgICAgLCBsb2dnZXIgKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIHJlc3BvbnNlSGFzaGVyLCBjdXJ2ZSwgXCJHMlwiLCAoMiAqKiBwb3dlcikgICAgLCBjdXJ2ZS5Gci5vbmUgICAgLCBrZXkudGF1LnBydktleSwgXCJDT01QUkVTU0VEXCIsIFwidGF1RzJcIiAgICAgLCBsb2dnZXIgKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIHJlc3BvbnNlSGFzaGVyLCBjdXJ2ZSwgXCJHMVwiLCAoMiAqKiBwb3dlcikgICAgLCBrZXkuYWxwaGEucHJ2S2V5LCBrZXkudGF1LnBydktleSwgXCJDT01QUkVTU0VEXCIsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIgKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIHJlc3BvbnNlSGFzaGVyLCBjdXJ2ZSwgXCJHMVwiLCAoMiAqKiBwb3dlcikgICAgLCBrZXkuYmV0YS5wcnZLZXkgLCBrZXkudGF1LnBydktleSwgXCJDT01QUkVTU0VEXCIsIFwiYmV0YVRhdUcxXCIgLCBsb2dnZXIgKTtcbiAgICBhd2FpdCBhcHBseUtleVRvQ2hhbGxlbmdlU2VjdGlvbihmZEZyb20sIGZkVG8sIHJlc3BvbnNlSGFzaGVyLCBjdXJ2ZSwgXCJHMlwiLCAxICAgICAgICAgICAgICwga2V5LmJldGEucHJ2S2V5ICwga2V5LnRhdS5wcnZLZXksIFwiQ09NUFJFU1NFRFwiLCBcImJldGFUYXVHMlwiICwgbG9nZ2VyICk7XG5cbiAgICAvLyBXcml0ZSBhbmQgaGFzaCBrZXlcbiAgICBjb25zdCBidWZmS2V5ID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMio2K2N1cnZlLkYyLm44KjIqMyk7XG4gICAgdG9QdGF1UHViS2V5UnByKGJ1ZmZLZXksIDAsIGN1cnZlLCBrZXksIGZhbHNlKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmZLZXkpO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmS2V5KTtcbiAgICBjb25zdCByZXNwb25zZUhhc2ggPSByZXNwb25zZUhhc2hlci5kaWdlc3QoKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKHJlc3BvbnNlSGFzaCwgXCJDb250cmlidXRpb24gUmVzcG9uc2UgSGFzaDogXCIpKTtcblxuICAgIGF3YWl0IGZkVG8uY2xvc2UoKTtcbiAgICBhd2FpdCBmZEZyb20uY2xvc2UoKTtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuYXN5bmMgZnVuY3Rpb24gYmVhY29uJDEob2xkUHRhdUZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIG5hbWUsICBiZWFjb25IYXNoU3RyLG51bUl0ZXJhdGlvbnNFeHAsIGxvZ2dlcikge1xuICAgIGNvbnN0IGJlYWNvbkhhc2ggPSBoZXgyQnl0ZUFycmF5KGJlYWNvbkhhc2hTdHIpO1xuICAgIGlmICggICAoYmVhY29uSGFzaC5ieXRlTGVuZ3RoID09IDApXG4gICAgICAgIHx8IChiZWFjb25IYXNoLmJ5dGVMZW5ndGgqMiAhPWJlYWNvbkhhc2hTdHIubGVuZ3RoKSlcbiAgICB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgQmVhY29uIEhhc2guIChJdCBtdXN0IGJlIGEgdmFsaWQgaGV4YWRlY2ltYWwgc2VxdWVuY2UpXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiZWFjb25IYXNoLmxlbmd0aD49MjU2KSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIk1heGltdW0gbGVuZ3RoIG9mIGJlYWNvbiBoYXNoIGlzIDI1NSBieXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG51bUl0ZXJhdGlvbnNFeHAgPSBwYXJzZUludChudW1JdGVyYXRpb25zRXhwKTtcbiAgICBpZiAoKG51bUl0ZXJhdGlvbnNFeHA8MTApfHwobnVtSXRlcmF0aW9uc0V4cD42MykpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1JdGVyYXRpb25zRXhwLiAoTXVzdCBiZSBiZXR3ZWVuIDEwIGFuZCA2MylcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IHJlYWRCaW5GaWxlKG9sZFB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9ID0gYXdhaXQgcmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcbiAgICBpZiAocG93ZXIgIT0gY2VyZW1vbnlQb3dlcikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJUaGlzIGZpbGUgaGFzIGJlZW4gcmVkdWNlZC4gWW91IGNhbm5vdCBjb250cmlidXRlIGludG8gYSByZWR1Y2VkIGZpbGUuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzZWN0aW9uc1sxMl0pIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLndhcm4oXCJDb250cmlidXRpbmcgaW50byBhIGZpbGUgdGhhdCBoYXMgcGhhc2UyIGNhbGN1bGF0ZWQuIFlvdSB3aWxsIGhhdmUgdG8gcHJlcGFyZSBwaGFzZTIgYWdhaW4uXCIpO1xuICAgIH1cbiAgICBjb25zdCBjb250cmlidXRpb25zID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbnMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiAxLCAvLyBCZWFjb25cbiAgICAgICAgbnVtSXRlcmF0aW9uc0V4cDogbnVtSXRlcmF0aW9uc0V4cCxcbiAgICAgICAgYmVhY29uSGFzaDogYmVhY29uSGFzaFxuICAgIH07XG5cbiAgICBsZXQgbGFzdENoYWxsZW5nZUhhc2g7XG5cbiAgICBpZiAoY29udHJpYnV0aW9ucy5sZW5ndGg+MCkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgY3VyQ29udHJpYnV0aW9uLmtleSA9IGF3YWl0IGtleUZyb21CZWFjb24oY3VydmUsIGxhc3RDaGFsbGVuZ2VIYXNoLCBiZWFjb25IYXNoLCBudW1JdGVyYXRpb25zRXhwKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGxhc3RDaGFsbGVuZ2VIYXNoKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgY3JlYXRlQmluRmlsZShuZXdQVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxLCA3KTtcbiAgICBhd2FpdCB3cml0ZVBUYXVIZWFkZXIoZmROZXcsIGN1cnZlLCBwb3dlcik7XG5cbiAgICBjb25zdCBzdGFydFNlY3Rpb25zID0gW107XG5cbiAgICBsZXQgZmlyc3RQb2ludHM7XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbigyLCBcIkcxXCIsICAoMiAqKiBwb3dlcikgKiAyIC0xLCBjdXJ2ZS5Gci5lKDEpLCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwidGF1RzFcIiwgbG9nZ2VyICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLnRhdUcxID0gZmlyc3RQb2ludHNbMV07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbigzLCBcIkcyXCIsICAoMiAqKiBwb3dlcikgLCBjdXJ2ZS5Gci5lKDEpLCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwidGF1RzJcIiwgbG9nZ2VyICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLnRhdUcyID0gZmlyc3RQb2ludHNbMV07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig0LCBcIkcxXCIsICAoMiAqKiBwb3dlcikgLCBjdXJDb250cmlidXRpb24ua2V5LmFscGhhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImFscGhhVGF1RzFcIiwgbG9nZ2VyICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmFscGhhRzEgPSBmaXJzdFBvaW50c1swXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDUsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAsIGN1ckNvbnRyaWJ1dGlvbi5rZXkuYmV0YS5wcnZLZXksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJiZXRhVGF1RzFcIiwgbG9nZ2VyICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmJldGFHMSA9IGZpcnN0UG9pbnRzWzBdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNiwgXCJHMlwiLCAgMSwgY3VyQ29udHJpYnV0aW9uLmtleS5iZXRhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImJldGFUYXVHMlwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYmV0YUcyID0gZmlyc3RQb2ludHNbMF07XG5cbiAgICBjdXJDb250cmlidXRpb24ucGFydGlhbEhhc2ggPSB0b1BhcnRpYWxIYXNoKHJlc3BvbnNlSGFzaGVyKTtcblxuICAgIGNvbnN0IGJ1ZmZLZXkgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCoyKjYrY3VydmUuRjIubjgqMiozKTtcblxuICAgIHRvUHRhdVB1YktleVJwcihidWZmS2V5LCAwLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmtleSwgZmFsc2UpO1xuXG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZLZXkpKTtcbiAgICBjb25zdCBoYXNoUmVzcG9uc2UgPSByZXNwb25zZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goaGFzaFJlc3BvbnNlLCBcIkNvbnRyaWJ1dGlvbiBSZXNwb25zZSBIYXNoIGltcG9ydGVkOiBcIikpO1xuXG4gICAgY29uc3QgbmV4dENoYWxsZW5nZUhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGhhc2hSZXNwb25zZSk7XG5cbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgXCJ0YXVHMlwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDQsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgXCJiZXRhRzJcIiwgbG9nZ2VyKTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlID0gbmV4dENoYWxsZW5nZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goY3VyQ29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuICAgIGNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgd3JpdGVDb250cmlidXRpb25zKGZkTmV3LCBjdXJ2ZSwgY29udHJpYnV0aW9ucyk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICByZXR1cm4gaGFzaFJlc3BvbnNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIE5Qb2ludHMsIGZpcnN0LCBpbmMsIHNlY3Rpb25OYW1lLCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZkT2xkLnBvcyA9IHNlY3Rpb25zW3NlY3Rpb25JZF1bMF0ucDtcblxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZE5ldywgc2VjdGlvbklkKTtcblxuICAgICAgICBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF0gPSBmZE5ldy5wb3M7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGguZmxvb3IoKDE8PDIwKSAvIHNHKTsgICAvLyAxMjhNYiBjaHVua3NcbiAgICAgICAgbGV0IHQgPSBmaXJzdDtcbiAgICAgICAgZm9yIChsZXQgaT0wIDsgaTxOUG9pbnRzIDsgaSs9IGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBhcHBseWluZyBrZXkke3NlY3Rpb25OYW1lfTogJHtpfS8ke05Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuPSBNYXRoLm1pbihOUG9pbnRzLWksIGNodW5rU2l6ZSApO1xuICAgICAgICAgICAgY29uc3QgYnVmZkluID0gYXdhaXQgZmRPbGQucmVhZChuICogc0cpO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dExFTSA9IGF3YWl0IEcuYmF0Y2hBcHBseUtleShidWZmSW4sIHQsIGluYyk7XG5cbiAgICAgICAgICAgIC8qIENvZGUgdG8gdGVzdCB0aGUgY2FzZSB3aGVyZSB3ZSBkb24ndCBoYXZlIHRoZSAyXm0tMiBjb21wb25lbnRcbiAgICAgICAgICAgIGlmIChzZWN0aW9uTmFtZT09IFwidGF1RzFcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ6ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXRMRU0uc2V0KGJ6LCA2NCooKDIgKiogcG93ZXIpIC0gMSApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VXcml0ZSA9IGZkTmV3LndyaXRlKGJ1ZmZPdXRMRU0pO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dEMgPSBhd2FpdCBHLmJhdGNoTEVNdG9DKGJ1ZmZPdXRMRU0pO1xuXG4gICAgICAgICAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZk91dEMpO1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZVdyaXRlO1xuICAgICAgICAgICAgaWYgKGk9PTApICAgLy8gUmV0dXJuIHRoZSAyIGZpcnN0IHBvaW50cy5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8TWF0aC5taW4oMiwgTlBvaW50cyk7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goRy5mcm9tUnByTEVNKGJ1ZmZPdXRMRU0sIGoqc0cpKTtcbiAgICAgICAgICAgIHQgPSBjdXJ2ZS5Gci5tdWwodCwgY3VydmUuRnIuZXhwKGluYywgbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFzaFNlY3Rpb24oZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNlY3Rpb25OYW1lLCBsb2dnZXIpIHtcblxuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgblBvaW50c0NodW5rID0gTWF0aC5mbG9vcigoMTw8MjQpL3NHKTtcblxuICAgICAgICBjb25zdCBvbGRQb3MgPSBmZFRvLnBvcztcbiAgICAgICAgZmRUby5wb3MgPSBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF07XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPCBuUG9pbnRzOyBpICs9IG5Qb2ludHNDaHVuaykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMRU0gPSBhd2FpdCBmZFRvLnJlYWQobiAqIHNHKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZlUgPSBhd2FpdCBHLmJhdGNoTEVNdG9VKGJ1ZmZMRU0pO1xuXG4gICAgICAgICAgICBuZXh0Q2hhbGxlbmdlSGFzaGVyLnVwZGF0ZShidWZmVSk7XG4gICAgICAgIH1cblxuICAgICAgICBmZFRvLnBvcyA9IG9sZFBvcztcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnRyaWJ1dGUob2xkUHRhdUZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIG5hbWUsIGVudHJvcHksIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgcmVhZEJpbkZpbGUob2xkUHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlciwgY2VyZW1vbnlQb3dlcn0gPSBhd2FpdCByZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuICAgIGlmIChwb3dlciAhPSBjZXJlbW9ueVBvd2VyKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlRoaXMgZmlsZSBoYXMgYmVlbiByZWR1Y2VkLiBZb3UgY2Fubm90IGNvbnRyaWJ1dGUgaW50byBhIHJlZHVjZWQgZmlsZS5cIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZmlsZSBoYXMgYmVlbiByZWR1Y2VkLiBZb3UgY2Fubm90IGNvbnRyaWJ1dGUgaW50byBhIHJlZHVjZWQgZmlsZS5cIik7XG4gICAgfVxuICAgIGlmIChzZWN0aW9uc1sxMl0pIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLndhcm4oXCJXQVJOSU5HOiBDb250cmlidXRpbmcgaW50byBhIGZpbGUgdGhhdCBoYXMgcGhhc2UyIGNhbGN1bGF0ZWQuIFlvdSB3aWxsIGhhdmUgdG8gcHJlcGFyZSBwaGFzZTIgYWdhaW4uXCIpO1xuICAgIH1cbiAgICBjb25zdCBjb250cmlidXRpb25zID0gYXdhaXQgcmVhZENvbnRyaWJ1dGlvbnMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiAwLCAvLyBCZWFjb25cbiAgICB9O1xuXG4gICAgbGV0IGxhc3RDaGFsbGVuZ2VIYXNoO1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgZ2V0UmFuZG9tUm5nKGVudHJvcHkpO1xuXG4gICAgaWYgKGNvbnRyaWJ1dGlvbnMubGVuZ3RoPjApIHtcbiAgICAgICAgbGFzdENoYWxsZW5nZUhhc2ggPSBjb250cmlidXRpb25zW2NvbnRyaWJ1dGlvbnMubGVuZ3RoLTFdLm5leHRDaGFsbGVuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdENoYWxsZW5nZUhhc2ggPSBjYWxjdWxhdGVGaXJzdENoYWxsZW5nZUhhc2goY3VydmUsIHBvd2VyLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIGtleVxuXG5cbiAgICBjdXJDb250cmlidXRpb24ua2V5ID0gY3JlYXRlUFRhdUtleShjdXJ2ZSwgbGFzdENoYWxsZW5nZUhhc2gsIHJuZyk7XG5cblxuICAgIGNvbnN0IHJlc3BvbnNlSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGxhc3RDaGFsbGVuZ2VIYXNoKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgY3JlYXRlQmluRmlsZShuZXdQVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxLCA3KTtcbiAgICBhd2FpdCB3cml0ZVBUYXVIZWFkZXIoZmROZXcsIGN1cnZlLCBwb3dlcik7XG5cbiAgICBjb25zdCBzdGFydFNlY3Rpb25zID0gW107XG5cbiAgICBsZXQgZmlyc3RQb2ludHM7XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbigyLCBcIkcxXCIsICAoMiAqKiBwb3dlcikgKiAyIC0xLCBjdXJ2ZS5Gci5lKDEpLCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwidGF1RzFcIiApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50YXVHMSA9IGZpcnN0UG9pbnRzWzFdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMywgXCJHMlwiLCAgKDIgKiogcG93ZXIpICwgY3VydmUuRnIuZSgxKSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcInRhdUcyXCIgKTtcbiAgICBjdXJDb250cmlidXRpb24udGF1RzIgPSBmaXJzdFBvaW50c1sxXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDQsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAsIGN1ckNvbnRyaWJ1dGlvbi5rZXkuYWxwaGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYWxwaGFUYXVHMVwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmFscGhhRzEgPSBmaXJzdFBvaW50c1swXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDUsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAsIGN1ckNvbnRyaWJ1dGlvbi5rZXkuYmV0YS5wcnZLZXksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJiZXRhVGF1RzFcIiApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5iZXRhRzEgPSBmaXJzdFBvaW50c1swXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDYsIFwiRzJcIiwgIDEsIGN1ckNvbnRyaWJ1dGlvbi5rZXkuYmV0YS5wcnZLZXksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJiZXRhVGF1RzJcIiApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5iZXRhRzIgPSBmaXJzdFBvaW50c1swXTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5wYXJ0aWFsSGFzaCA9IHRvUGFydGlhbEhhc2gocmVzcG9uc2VIYXNoZXIpO1xuXG4gICAgY29uc3QgYnVmZktleSA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkYxLm44KjIqNitjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgdG9QdGF1UHViS2V5UnByKGJ1ZmZLZXksIDAsIGN1cnZlLCBjdXJDb250cmlidXRpb24ua2V5LCBmYWxzZSk7XG5cbiAgICByZXNwb25zZUhhc2hlci51cGRhdGUobmV3IFVpbnQ4QXJyYXkoYnVmZktleSkpO1xuICAgIGNvbnN0IGhhc2hSZXNwb25zZSA9IHJlc3BvbnNlSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChoYXNoUmVzcG9uc2UsIFwiQ29udHJpYnV0aW9uIFJlc3BvbnNlIEhhc2ggaW1wb3J0ZWQ6IFwiKSk7XG5cbiAgICBjb25zdCBuZXh0Q2hhbGxlbmdlSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgbmV4dENoYWxsZW5nZUhhc2hlci51cGRhdGUoaGFzaFJlc3BvbnNlKTtcblxuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDIsICgyICoqIHBvd2VyKSAqIDIgLTEsIFwidGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgXCJ0YXVHMlwiKTtcbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCA0LCAoMiAqKiBwb3dlcikgICAgICAgLCBcImFscGhhVGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzFcIiwgNSwgKDIgKiogcG93ZXIpICAgICAgICwgXCJiZXRhVGF1RzFcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgXCJiZXRhRzJcIik7XG5cbiAgICBjdXJDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSA9IG5leHRDaGFsbGVuZ2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGN1ckNvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlLCBcIk5leHQgQ2hhbGxlbmdlIEhhc2g6IFwiKSk7XG5cbiAgICBjb250cmlidXRpb25zLnB1c2goY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGF3YWl0IHdyaXRlQ29udHJpYnV0aW9ucyhmZE5ldywgY3VydmUsIGNvbnRyaWJ1dGlvbnMpO1xuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIGhhc2hSZXNwb25zZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uKHNlY3Rpb25JZCwgZ3JvdXBOYW1lLCBOUG9pbnRzLCBmaXJzdCwgaW5jLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZmRPbGQucG9zID0gc2VjdGlvbnNbc2VjdGlvbklkXVswXS5wO1xuXG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkTmV3LCBzZWN0aW9uSWQpO1xuXG4gICAgICAgIHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXSA9IGZkTmV3LnBvcztcblxuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5mbG9vcigoMTw8MjApIC8gc0cpOyAgIC8vIDEyOE1iIGNodW5rc1xuICAgICAgICBsZXQgdCA9IGZpcnN0O1xuICAgICAgICBmb3IgKGxldCBpPTAgOyBpPE5Qb2ludHMgOyBpKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHByb2Nlc3Npbmc6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7TlBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG49IE1hdGgubWluKE5Qb2ludHMtaSwgY2h1bmtTaXplICk7XG4gICAgICAgICAgICBjb25zdCBidWZmSW4gPSBhd2FpdCBmZE9sZC5yZWFkKG4gKiBzRyk7XG4gICAgICAgICAgICBjb25zdCBidWZmT3V0TEVNID0gYXdhaXQgRy5iYXRjaEFwcGx5S2V5KGJ1ZmZJbiwgdCwgaW5jKTtcblxuICAgICAgICAgICAgLyogQ29kZSB0byB0ZXN0IHRoZSBjYXNlIHdoZXJlIHdlIGRvbid0IGhhdmUgdGhlIDJebS0yIGNvbXBvbmVudFxuICAgICAgICAgICAgaWYgKHNlY3Rpb25OYW1lPT0gXCJ0YXVHMVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnogPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgICAgICAgICAgICAgYnVmZk91dExFTS5zZXQoYnosIDY0KigoMiAqKiBwb3dlcikgLSAxICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZVdyaXRlID0gZmROZXcud3JpdGUoYnVmZk91dExFTSk7XG4gICAgICAgICAgICBjb25zdCBidWZmT3V0QyA9IGF3YWl0IEcuYmF0Y2hMRU10b0MoYnVmZk91dExFTSk7XG5cbiAgICAgICAgICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmT3V0Qyk7XG4gICAgICAgICAgICBhd2FpdCBwcm9taXNlV3JpdGU7XG4gICAgICAgICAgICBpZiAoaT09MCkgICAvLyBSZXR1cm4gdGhlIDIgZmlyc3QgcG9pbnRzLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxNYXRoLm1pbigyLCBOUG9pbnRzKTsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChHLmZyb21ScHJMRU0oYnVmZk91dExFTSwgaipzRykpO1xuICAgICAgICAgICAgdCA9IGN1cnZlLkZyLm11bCh0LCBjdXJ2ZS5Gci5leHAoaW5jLCBuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmROZXcpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoU2VjdGlvbihmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2VjdGlvbk5hbWUpIHtcblxuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgblBvaW50c0NodW5rID0gTWF0aC5mbG9vcigoMTw8MjQpL3NHKTtcblxuICAgICAgICBjb25zdCBvbGRQb3MgPSBmZFRvLnBvcztcbiAgICAgICAgZmRUby5wb3MgPSBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF07XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPCBuUG9pbnRzOyBpICs9IG5Qb2ludHNDaHVuaykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiZpKSBsb2dnZXIuZGVidWcoYEhhc2hpbmcgJHtzZWN0aW9uTmFtZX06IGAgKyBpKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMRU0gPSBhd2FpdCBmZFRvLnJlYWQobiAqIHNHKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZlUgPSBhd2FpdCBHLmJhdGNoTEVNdG9VKGJ1ZmZMRU0pO1xuXG4gICAgICAgICAgICBuZXh0Q2hhbGxlbmdlSGFzaGVyLnVwZGF0ZShidWZmVSk7XG4gICAgICAgIH1cblxuICAgICAgICBmZFRvLnBvcyA9IG9sZFBvcztcbiAgICB9XG5cblxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlUGhhc2UyKG9sZFB0YXVGaWxlbmFtZSwgbmV3UFRhdUZpbGVuYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IHJlYWRCaW5GaWxlKG9sZFB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgcmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgY3JlYXRlQmluRmlsZShuZXdQVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxLCAxMSk7XG4gICAgYXdhaXQgd3JpdGVQVGF1SGVhZGVyKGZkTmV3LCBjdXJ2ZSwgcG93ZXIpO1xuXG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMik7XG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMyk7XG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNCk7XG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNSk7XG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNik7XG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNyk7XG5cbiAgICBhd2FpdCBwcm9jZXNzU2VjdGlvbigyLCAxMiwgXCJHMVwiLCBcInRhdUcxXCIgKTtcbiAgICBhd2FpdCBwcm9jZXNzU2VjdGlvbigzLCAxMywgXCJHMlwiLCBcInRhdUcyXCIgKTtcbiAgICBhd2FpdCBwcm9jZXNzU2VjdGlvbig0LCAxNCwgXCJHMVwiLCBcImFscGhhVGF1RzFcIiApO1xuICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uKDUsIDE1LCBcIkcxXCIsIFwiYmV0YVRhdUcxXCIgKTtcblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcblxuICAgIC8vIGF3YWl0IGZzLnByb21pc2VzLnVubGluayhuZXdQVGF1RmlsZW5hbWUrIFwiLnRtcFwiKTtcblxuICAgIHJldHVybjtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uKG9sZFNlY3Rpb25JZCwgbmV3U2VjdGlvbklkLCBHc3RyLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJTdGFydGluZyBzZWN0aW9uOiBcIitzZWN0aW9uTmFtZSk7XG5cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmROZXcsIG5ld1NlY3Rpb25JZCk7XG5cbiAgICAgICAgZm9yIChsZXQgcD0wOyBwPD1wb3dlcjsgcCsrKSB7XG4gICAgICAgICAgICBhd2FpdCBwcm9jZXNzU2VjdGlvblBvd2VyKHApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9sZFNlY3Rpb25JZCA9PSAyKSB7XG4gICAgICAgICAgICBhd2FpdCBwcm9jZXNzU2VjdGlvblBvd2VyKHBvd2VyKzEpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcblxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uUG93ZXIocCkge1xuICAgICAgICAgICAgY29uc3QgblBvaW50cyA9IDIgKiogcDtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtHc3RyXTtcbiAgICAgICAgICAgIGNvbnN0IHNHaW4gPSBHLkYubjgqMjtcblxuICAgICAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgICAgICBidWZmID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNHaW4pO1xuXG4gICAgICAgICAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgb2xkU2VjdGlvbklkKTtcbiAgICAgICAgICAgIGlmICgob2xkU2VjdGlvbklkID09IDIpJiYocD09cG93ZXIrMSkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE9sZC5yZWFkVG9CdWZmZXIoYnVmZiwgMCwoblBvaW50cy0xKSpzR2luICk7XG4gICAgICAgICAgICAgICAgYnVmZi5zZXQoY3VydmUuRzEuemVyb0FmZmluZSwgKG5Qb2ludHMtMSkqc0dpbiApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE9sZC5yZWFkVG9CdWZmZXIoYnVmZiwgMCxuUG9pbnRzKnNHaW4gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGVuZFJlYWRTZWN0aW9uKGZkT2xkLCB0cnVlKTtcblxuXG4gICAgICAgICAgICBidWZmID0gYXdhaXQgRy5sYWdyYW5nZUV2YWx1YXRpb25zKGJ1ZmYsIFwiYWZmaW5lXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUpO1xuICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG5cbi8qXG4gICAgICAgICAgICBpZiAocCA8PSBjdXJ2ZS5Gci5zKSB7XG4gICAgICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcuaWZmdChidWZmLCBcImFmZmluZVwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZShidWZmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocCA9PSBjdXJ2ZS5Gci5zKzEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbWFsbE0gPSAxPDxjdXJ2ZS5Gci5zO1xuICAgICAgICAgICAgICAgIGxldCB0MCA9IG5ldyBCaWdCdWZmZXIoIHNtYWxsTSAqIHNHbWlkICk7XG4gICAgICAgICAgICAgICAgbGV0IHQxID0gbmV3IEJpZ0J1ZmZlciggc21hbGxNICogc0dtaWQgKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNoaWZ0X3RvX3NtYWxsX20gPSBGci5leHAoRnIuc2hpZnQsIHNtYWxsTSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25lX292ZXJfZGVub20gPSBGci5pbnYoRnIuc3ViKHNoaWZ0X3RvX3NtYWxsX20sIEZyLm9uZSkpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHNJbnZBY2MgPSBGci5vbmU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHNtYWxsTTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpID0gIGJ1ZmYuc2xpY2UoaSpzR2luLCAoaSsxKSpzR2luKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1pID0gYnVmZi5zbGljZSgoaStzbWFsbE0pKnNHaW4sIChpK3NtYWxsTSsxKSpzR2luKTtcblxuICAgICAgICAgICAgICAgICAgICB0MC5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRy5zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcudGltZXNGcih0aSAsIHNoaWZ0X3RvX3NtYWxsX20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bWlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZV9vdmVyX2Rlbm9tXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSpzR21pZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0MS5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRy5zdWIoIHRtaSwgdGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZyLm11bChzSW52QWNjLCBvbmVfb3Zlcl9kZW5vbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpKnNHbWlkXG4gICAgICAgICAgICAgICAgICAgICk7XG5cblxuICAgICAgICAgICAgICAgICAgICBzSW52QWNjID0gRnIubXVsKHNJbnZBY2MsIEZyLnNoaWZ0SW52KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdDAgPSBhd2FpdCBHLmlmZnQodDAsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiIHQwXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKHQwKTtcbiAgICAgICAgICAgICAgICB0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdDEgPSBhd2FpdCBHLmlmZnQodDEsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiIHQwXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKHQxKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQb3dlciB0b28gYmlnXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VyIHRvIGJpZ1wiKTtcbiAgICAgICAgICAgIH1cbiovXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIHRydW5jYXRlKHB0YXVGaWxlbmFtZSwgdGVtcGxhdGUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgcmVhZEJpbkZpbGUocHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlciwgY2VyZW1vbnlQb3dlcn0gPSBhd2FpdCByZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcblxuICAgIGZvciAobGV0IHA9MTsgcDxwb3dlcjsgcCsrKSB7XG4gICAgICAgIGF3YWl0IGdlbmVyYXRlVHJ1bmNhdGUocCk7XG4gICAgfVxuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcblxuICAgIHJldHVybiB0cnVlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUcnVuY2F0ZShwKSB7XG5cbiAgICAgICAgbGV0IHNQID0gcC50b1N0cmluZygpO1xuICAgICAgICB3aGlsZSAoc1AubGVuZ3RoPDIpIHNQID0gXCIwXCIgKyBzUDtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJXcml0aW5nIFBvd2VyOiBcIitzUCk7XG5cbiAgICAgICAgY29uc3QgZmROZXcgPSBhd2FpdCBjcmVhdGVCaW5GaWxlKHRlbXBsYXRlICsgc1AgKyBcIi5wdGF1XCIsIFwicHRhdVwiLCAxLCAxMSk7XG4gICAgICAgIGF3YWl0IHdyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHAsIGNlcmVtb255UG93ZXIpO1xuXG4gICAgICAgIGF3YWl0IGNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDIsICgoMiAqKiBwKSoyLTEpICogc0cxICk7IC8vIHRhZ0cxXG4gICAgICAgIGF3YWl0IGNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDMsICgyICoqIHApICogc0cyKTsgLy8gdGF1RzJcbiAgICAgICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNCwgKDIgKiogcCkgKiBzRzEpOyAvLyBhbGZhVGF1RzFcbiAgICAgICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNSwgKDIgKiogcCkgKiBzRzEpOyAvLyBiZXRhVGF1RzFcbiAgICAgICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNiwgIHNHMik7IC8vIGJldGFUYXVHMlxuICAgICAgICBhd2FpdCBjb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA3KTsgLy8gY29udHJpYnV0aW9uc1xuICAgICAgICBhd2FpdCBjb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxMiwgKCgyICoqIChwKzEpKSoyIC0xKSAqIHNHMSk7IC8vIExfdGF1RzFcbiAgICAgICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTMsICgoMiAqKiBwKSoyIC0xKSAqIHNHMik7IC8vIExfdGF1RzJcbiAgICAgICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTQsICgoMiAqKiBwKSoyIC0xKSAqIHNHMSk7IC8vIExfYWxmYVRhdUcxXG4gICAgICAgIGF3YWl0IGNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDE1LCAoKDIgKiogcCkqMiAtMSkgKiBzRzEpOyAvLyBMX2JldGFUYXVHMVxuXG4gICAgICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG4gICAgfVxuXG5cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuYXN5bmMgZnVuY3Rpb24gY29udmVydChvbGRQdGF1RmlsZW5hbWUsIG5ld1BUYXVGaWxlbmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCByZWFkQmluRmlsZShvbGRQdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGNyZWF0ZUJpbkZpbGUobmV3UFRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSwgMTEpO1xuICAgIGF3YWl0IHdyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIC8vIGNvbnN0IGZkVG1wID0gYXdhaXQgZmFzdEZpbGUuY3JlYXRlT3ZlcnJpZGUobmV3UFRhdUZpbGVuYW1lKyBcIi50bXBcIik7XG5cbiAgICBhd2FpdCBjb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAyKTtcbiAgICBhd2FpdCBjb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAzKTtcbiAgICBhd2FpdCBjb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA0KTtcbiAgICBhd2FpdCBjb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1KTtcbiAgICBhd2FpdCBjb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA2KTtcbiAgICBhd2FpdCBjb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA3KTtcblxuICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uKDIsIDEyLCBcIkcxXCIsIFwidGF1RzFcIiApO1xuICAgIGF3YWl0IGNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDEzKTtcbiAgICBhd2FpdCBjb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxNCk7XG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTUpO1xuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuXG4gICAgLy8gYXdhaXQgZnMucHJvbWlzZXMudW5saW5rKG5ld1BUYXVGaWxlbmFtZSsgXCIudG1wXCIpO1xuXG4gICAgcmV0dXJuO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24ob2xkU2VjdGlvbklkLCBuZXdTZWN0aW9uSWQsIEdzdHIsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlN0YXJ0aW5nIHNlY3Rpb246IFwiK3NlY3Rpb25OYW1lKTtcblxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZE5ldywgbmV3U2VjdGlvbklkKTtcblxuICAgICAgICBjb25zdCBzaXplID0gc2VjdGlvbnNbbmV3U2VjdGlvbklkXVswXS5zaXplO1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBmZE9sZC5wYWdlU2l6ZTtcbiAgICAgICAgYXdhaXQgc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIG5ld1NlY3Rpb25JZCk7XG4gICAgICAgIGZvciAobGV0IHA9MDsgcDxzaXplOyBwKz1jaHVua1NpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBNYXRoLm1pbihzaXplIC1wLCBjaHVua1NpemUpO1xuICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkT2xkLnJlYWQobCk7XG4gICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZShidWZmKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZE9sZCk7XG5cbiAgICAgICAgaWYgKG9sZFNlY3Rpb25JZCA9PSAyKSB7XG4gICAgICAgICAgICBhd2FpdCBwcm9jZXNzU2VjdGlvblBvd2VyKHBvd2VyKzEpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkTmV3KTtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvblBvd2VyKHApIHtcbiAgICAgICAgICAgIGNvbnN0IG5Qb2ludHMgPSAyICoqIHA7XG4gICAgICAgICAgICBjb25zdCBHID0gY3VydmVbR3N0cl07XG4gICAgICAgICAgICBjb25zdCBzR2luID0gRy5GLm44KjI7XG5cbiAgICAgICAgICAgIGxldCBidWZmO1xuICAgICAgICAgICAgYnVmZiA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzR2luKTtcblxuICAgICAgICAgICAgYXdhaXQgc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIG9sZFNlY3Rpb25JZCk7XG4gICAgICAgICAgICBpZiAoKG9sZFNlY3Rpb25JZCA9PSAyKSYmKHA9PXBvd2VyKzEpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRPbGQucmVhZFRvQnVmZmVyKGJ1ZmYsIDAsKG5Qb2ludHMtMSkqc0dpbiApO1xuICAgICAgICAgICAgICAgIGJ1ZmYuc2V0KGN1cnZlLkcxLnplcm9BZmZpbmUsIChuUG9pbnRzLTEpKnNHaW4gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRPbGQucmVhZFRvQnVmZmVyKGJ1ZmYsIDAsblBvaW50cypzR2luICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZE9sZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmxhZ3JhbmdlRXZhbHVhdGlvbnMoYnVmZiwgXCJhZmZpbmVcIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZShidWZmKTtcblxuLypcbiAgICAgICAgICAgIGlmIChwIDw9IGN1cnZlLkZyLnMpIHtcbiAgICAgICAgICAgICAgICBidWZmID0gYXdhaXQgRy5pZmZ0KGJ1ZmYsIFwiYWZmaW5lXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwID09IGN1cnZlLkZyLnMrMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNtYWxsTSA9IDE8PGN1cnZlLkZyLnM7XG4gICAgICAgICAgICAgICAgbGV0IHQwID0gbmV3IEJpZ0J1ZmZlciggc21hbGxNICogc0dtaWQgKTtcbiAgICAgICAgICAgICAgICBsZXQgdDEgPSBuZXcgQmlnQnVmZmVyKCBzbWFsbE0gKiBzR21pZCApO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hpZnRfdG9fc21hbGxfbSA9IEZyLmV4cChGci5zaGlmdCwgc21hbGxNKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbmVfb3Zlcl9kZW5vbSA9IEZyLmludihGci5zdWIoc2hpZnRfdG9fc21hbGxfbSwgRnIub25lKSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgc0ludkFjYyA9IEZyLm9uZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8c21hbGxNOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGklMTAwMDApIGxvZ2dlci5kZWJ1Zyhgc2VjdGlvbk5hbWUgcHJlcGFyZSBMIGNhbGM6ICR7c2VjdGlvbk5hbWV9LCAke2l9LyR7c21hbGxNfWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aSA9ICBidWZmLnNsaWNlKGkqc0dpbiwgKGkrMSkqc0dpbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtaSA9IGJ1ZmYuc2xpY2UoKGkrc21hbGxNKSpzR2luLCAoaStzbWFsbE0rMSkqc0dpbik7XG5cbiAgICAgICAgICAgICAgICAgICAgdDAuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcuc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIodGkgLCBzaGlmdF90b19zbWFsbF9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmVfb3Zlcl9kZW5vbVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkqc0dtaWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdDEuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcuc3ViKCB0bWksIHRpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGci5tdWwoc0ludkFjYywgb25lX292ZXJfZGVub20pXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSpzR21pZFxuICAgICAgICAgICAgICAgICAgICApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgc0ludkFjYyA9IEZyLm11bChzSW52QWNjLCBGci5zaGlmdEludik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQwID0gYXdhaXQgRy5pZmZ0KHQwLCBcImphY29iaWFuXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIiB0MFwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZSh0MCk7XG4gICAgICAgICAgICAgICAgdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHQxID0gYXdhaXQgRy5pZmZ0KHQxLCBcImphY29iaWFuXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUgKyBcIiB0MVwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZSh0MSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUG93ZXIgdG9vIGJpZ1wiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3dlciB0byBiaWdcIik7XG4gICAgICAgICAgICB9XG4qL1xuICAgICAgICB9XG5cblxuICAgIH1cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuYXN5bmMgZnVuY3Rpb24gZXhwb3J0SnNvbihwVGF1RmlsZW5hbWUsIHZlcmJvc2UpIHtcbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IHJlYWRCaW5GaWxlKHBUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuXG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCByZWFkUFRhdUhlYWRlcihmZCwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgcFRhdSA9IHt9O1xuICAgIHBUYXUucSA9IGN1cnZlLnE7XG4gICAgcFRhdS5wb3dlciA9IHBvd2VyO1xuICAgIHBUYXUuY29udHJpYnV0aW9ucyA9IGF3YWl0IHJlYWRDb250cmlidXRpb25zKGZkLCBjdXJ2ZSwgc2VjdGlvbnMpO1xuXG4gICAgcFRhdS50YXVHMSA9IGF3YWl0IGV4cG9ydFNlY3Rpb24oMiwgXCJHMVwiLCAoMiAqKiBwb3dlcikqMiAtMSwgXCJ0YXVHMVwiKTtcbiAgICBwVGF1LnRhdUcyID0gYXdhaXQgZXhwb3J0U2VjdGlvbigzLCBcIkcyXCIsICgyICoqIHBvd2VyKSwgXCJ0YXVHMlwiKTtcbiAgICBwVGF1LmFscGhhVGF1RzEgPSBhd2FpdCBleHBvcnRTZWN0aW9uKDQsIFwiRzFcIiwgKDIgKiogcG93ZXIpLCBcImFscGhhVGF1RzFcIik7XG4gICAgcFRhdS5iZXRhVGF1RzEgPSBhd2FpdCBleHBvcnRTZWN0aW9uKDUsIFwiRzFcIiwgKDIgKiogcG93ZXIpLCBcImJldGFUYXVHMVwiKTtcbiAgICBwVGF1LmJldGFHMiA9IGF3YWl0IGV4cG9ydFNlY3Rpb24oNiwgXCJHMlwiLCAxLCBcImJldGFHMlwiKTtcblxuICAgIHBUYXUubFRhdUcxID0gYXdhaXQgZXhwb3J0TGFncmFuZ2UoMTIsIFwiRzFcIiwgXCJsVGF1RzFcIik7XG4gICAgcFRhdS5sVGF1RzIgPSBhd2FpdCBleHBvcnRMYWdyYW5nZSgxMywgXCJHMlwiLCBcImxUYXVHMlwiKTtcbiAgICBwVGF1LmxBbHBoYVRhdUcxID0gYXdhaXQgZXhwb3J0TGFncmFuZ2UoMTQsIFwiRzFcIiwgXCJsQWxwaGFUYXVHMlwiKTtcbiAgICBwVGF1LmxCZXRhVGF1RzEgPSBhd2FpdCBleHBvcnRMYWdyYW5nZSgxNSwgXCJHMVwiLCBcImxCZXRhVGF1RzJcIik7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQoY3VydmUuRnIsIHBUYXUpO1xuXG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGV4cG9ydFNlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIG5Qb2ludHMsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgc2VjdGlvbklkKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPCBuUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgodmVyYm9zZSkmJmkmJihpJTEwMDAwID09IDApKSBjb25zb2xlLmxvZyhgJHtzZWN0aW9uTmFtZX06IGAgKyBpKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKHNHKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKEcuZnJvbVJwckxFTShidWZmLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZXhwb3J0TGFncmFuZ2Uoc2VjdGlvbklkLCBncm91cE5hbWUsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgc2VjdGlvbklkKTtcbiAgICAgICAgZm9yIChsZXQgcD0wOyBwPD1wb3dlcjsgcCsrKSB7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSkgY29uc29sZS5sb2coYCR7c2VjdGlvbk5hbWV9OiBQb3dlcjogJHtwfWApO1xuICAgICAgICAgICAgcmVzW3BdID0gW107XG4gICAgICAgICAgICBjb25zdCBuUG9pbnRzID0gKDIgKiogcCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh2ZXJib3NlKSYmaSYmKGklMTAwMDAgPT0gMCkpIGNvbnNvbGUubG9nKGAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoc0cpO1xuICAgICAgICAgICAgICAgIHJlc1twXS5wdXNoKEcuZnJvbVJwckxFTShidWZmLCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmQsIHRydWUpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbnZhciBwb3dlcnNvZnRhdSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmV3QWNjdW11bGF0b3I6IG5ld0FjY3VtdWxhdG9yLFxuICAgIGV4cG9ydENoYWxsZW5nZTogZXhwb3J0Q2hhbGxlbmdlLFxuICAgIGltcG9ydFJlc3BvbnNlOiBpbXBvcnRSZXNwb25zZSxcbiAgICB2ZXJpZnk6IHZlcmlmeSxcbiAgICBjaGFsbGVuZ2VDb250cmlidXRlOiBjaGFsbGVuZ2VDb250cmlidXRlLFxuICAgIGJlYWNvbjogYmVhY29uJDEsXG4gICAgY29udHJpYnV0ZTogY29udHJpYnV0ZSxcbiAgICBwcmVwYXJlUGhhc2UyOiBwcmVwYXJlUGhhc2UyLFxuICAgIHRydW5jYXRlOiB0cnVuY2F0ZSxcbiAgICBjb252ZXJ0OiBjb252ZXJ0LFxuICAgIGV4cG9ydEpzb246IGV4cG9ydEpzb25cbn0pO1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5mdW5jdGlvbiByMWNzUHJpbnQocjFjcywgc3ltcywgbG9nZ2VyKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpPHIxY3MuY29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJpbnRDb3N0cmFpbnQocjFjcy5jb25zdHJhaW50c1tpXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByaW50Q29zdHJhaW50KGMpIHtcbiAgICAgICAgY29uc3QgbGMyc3RyID0gKGxjKSA9PiB7XG4gICAgICAgICAgICBsZXQgUyA9IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobGMpO1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKCAoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gc3ltcy52YXJJZHgyTmFtZVtrXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcIm9uZVwiKSBuYW1lID0gXCIxXCI7XG5cbiAgICAgICAgICAgICAgICBsZXQgdnMgPSByMWNzLmN1cnZlLkZyLnRvU3RyaW5nKGxjW2tdKTtcbiAgICAgICAgICAgICAgICBpZiAodnMgPT0gXCIxXCIpIHZzID0gXCJcIjsgIC8vIERvIG5vdCBzaG93IG9uZXNcbiAgICAgICAgICAgICAgICBpZiAodnMgPT0gXCItMVwiKSB2cyA9IFwiLVwiOyAgLy8gRG8gbm90IHNob3cgb25lc1xuICAgICAgICAgICAgICAgIGlmICgoUyE9XCJcIikmJih2c1swXSE9XCItXCIpKSB2cyA9IFwiK1wiK3ZzO1xuICAgICAgICAgICAgICAgIGlmIChTIT1cIlwiKSB2cyA9IFwiIFwiK3ZzO1xuICAgICAgICAgICAgICAgIFM9IFMgKyB2cyAgICsgbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFM7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IFMgPSBgWyAke2xjMnN0cihjWzBdKX0gXSAqIFsgJHtsYzJzdHIoY1sxXSl9IF0gLSBbICR7bGMyc3RyKGNbMl0pfSBdID0gMGA7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFMpO1xuICAgIH1cblxufVxuXG5jb25zdCBTVUJBUlJBWV9TSVpFJDEgPSAweDQwMDAwO1xuXG5jb25zdCBCaWdBcnJheUhhbmRsZXIkMSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKG9iaiwgcHJvcCkge1xuICAgICAgICBpZiAoIWlzTmFOKHByb3ApKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmdldEVsZW1lbnQocHJvcCk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gb2JqW3Byb3BdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihvYmosIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNOYU4ocHJvcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouc2V0RWxlbWVudChwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY2xhc3MgX0JpZ0FycmF5JDEge1xuICAgIGNvbnN0cnVjdG9yIChpbml0U2l6ZSkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGluaXRTaXplIHx8IDA7XG4gICAgICAgIHRoaXMuYXJyID0gbmV3IEFycmF5KFNVQkFSUkFZX1NJWkUkMSk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGluaXRTaXplOyBpKz1TVUJBUlJBWV9TSVpFJDEpIHtcbiAgICAgICAgICAgIHRoaXMuYXJyW2kvU1VCQVJSQVlfU0laRSQxXSA9IG5ldyBBcnJheShNYXRoLm1pbihTVUJBUlJBWV9TSVpFJDEsIGluaXRTaXplIC0gaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwdXNoICgpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50ICh0aGlzLmxlbmd0aCwgYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNsaWNlIChmLCB0KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSh0LWYpO1xuICAgICAgICBmb3IgKGxldCBpPWY7IGk8IHQ7IGkrKykgYXJyW2ktZl0gPSB0aGlzLmdldEVsZW1lbnQoaSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGdldEVsZW1lbnQoaWR4KSB7XG4gICAgICAgIGlkeCA9IHBhcnNlSW50KGlkeCk7XG4gICAgICAgIGNvbnN0IGlkeDEgPSBNYXRoLmZsb29yKGlkeCAvIFNVQkFSUkFZX1NJWkUkMSk7XG4gICAgICAgIGNvbnN0IGlkeDIgPSBpZHggJSBTVUJBUlJBWV9TSVpFJDE7XG4gICAgICAgIHJldHVybiB0aGlzLmFycltpZHgxXSA/IHRoaXMuYXJyW2lkeDFdW2lkeDJdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXRFbGVtZW50KGlkeCwgdmFsdWUpIHtcbiAgICAgICAgaWR4ID0gcGFyc2VJbnQoaWR4KTtcbiAgICAgICAgY29uc3QgaWR4MSA9IE1hdGguZmxvb3IoaWR4IC8gU1VCQVJSQVlfU0laRSQxKTtcbiAgICAgICAgaWYgKCF0aGlzLmFycltpZHgxXSkge1xuICAgICAgICAgICAgdGhpcy5hcnJbaWR4MV0gPSBuZXcgQXJyYXkoU1VCQVJSQVlfU0laRSQxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZHgyID0gaWR4ICUgU1VCQVJSQVlfU0laRSQxO1xuICAgICAgICB0aGlzLmFycltpZHgxXVtpZHgyXSA9IHZhbHVlO1xuICAgICAgICBpZiAoaWR4ID49IHRoaXMubGVuZ3RoKSB0aGlzLmxlbmd0aCA9IGlkeCsxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0S2V5cygpIHtcbiAgICAgICAgY29uc3QgbmV3QSA9IG5ldyBCaWdBcnJheSQyKCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLmFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJyW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHRoaXMuYXJyW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5hcnJbaV1bal0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0EucHVzaChpKlNVQkFSUkFZX1NJWkUkMStqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3QTtcbiAgICB9XG59XG5cbmNsYXNzIEJpZ0FycmF5JDIge1xuICAgIGNvbnN0cnVjdG9yKCBpbml0U2l6ZSApIHtcbiAgICAgICAgY29uc3Qgb2JqID0gbmV3IF9CaWdBcnJheSQxKGluaXRTaXplKTtcbiAgICAgICAgY29uc3QgZXh0T2JqID0gbmV3IFByb3h5KG9iaiwgQmlnQXJyYXlIYW5kbGVyJDEpO1xuICAgICAgICByZXR1cm4gZXh0T2JqO1xuICAgIH1cbn1cblxudmFyIEJpZ0FycmF5JDMgPSBCaWdBcnJheSQyO1xuXG5jb25zdCBSMUNTX0ZJTEVfQ1VTVE9NX0dBVEVTX0xJU1RfU0VDVElPTiA9IDQ7XG5jb25zdCBSMUNTX0ZJTEVfQ1VTVE9NX0dBVEVTX1VTRVNfU0VDVElPTiA9IDU7XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRSMWNzSGVhZGVyKGZkLHNlY3Rpb25zLHNpbmdsZVRocmVhZCkge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygc2luZ2xlVGhyZWFkID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzaW5nbGVUaHJlYWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2luZ2xlVGhyZWFkID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG9wdGlvbnM9IHtcbiAgICAgICAgICAgIHNpbmdsZVRocmVhZDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNpbmdsZVRocmVhZDogc2luZ2xlVGhyZWFkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAxKTtcbiAgICAvLyBSZWFkIEhlYWRlclxuICAgIHJlcy5uOCA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHJlcy5wcmltZSA9IGF3YWl0IHJlYWRCaWdJbnQoZmQsIHJlcy5uOCk7XG5cbiAgICBpZiAob3B0aW9ucy5GKSB7XG4gICAgICAgIGlmIChvcHRpb25zLkYucCAhPSByZXMucHJpbWUpIHRocm93IG5ldyBFcnJvcihcIkRpZmZlcmVudCBQcmltZVwiKTtcbiAgICAgICAgcmVzLkYgPSBvcHRpb25zLkY7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmdldEZpZWxkRnJvbVByaW1lKSB7XG4gICAgICAgIHJlcy5GID0gYXdhaXQgb3B0aW9ucy5nZXRGaWVsZEZyb21QcmltZShyZXMucHJpbWUsIG9wdGlvbnMuc2luZ2xlVGhyZWFkKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZ2V0Q3VydmVGcm9tUHJpbWUpIHtcbiAgICAgICAgcmVzLmN1cnZlID0gYXdhaXQgb3B0aW9ucy5nZXRDdXJ2ZUZyb21QcmltZShyZXMucHJpbWUsIG9wdGlvbnMuc2luZ2xlVGhyZWFkKTtcbiAgICAgICAgcmVzLkYgPSByZXMuY3VydmUuRnI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcy5jdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbVIkMShyZXMucHJpbWUsIG9wdGlvbnMuc2luZ2xlVGhyZWFkKTtcbiAgICAgICAgICAgIHJlcy5GID0gcmVzLmN1cnZlLkZyO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcy5GID0gbmV3IEYxRmllbGQocmVzLnByaW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlcy5uVmFycyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHJlcy5uT3V0cHV0cyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHJlcy5uUHViSW5wdXRzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgcmVzLm5QcnZJbnB1dHMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICByZXMubkxhYmVscyA9IGF3YWl0IGZkLnJlYWRVTEU2NCgpO1xuICAgIHJlcy5uQ29uc3RyYWludHMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICByZXMudXNlQ3VzdG9tR2F0ZXMgPSB0eXBlb2Ygc2VjdGlvbnNbUjFDU19GSUxFX0NVU1RPTV9HQVRFU19MSVNUX1NFQ1RJT05dICE9PSBcInVuZGVmaW5lZFwiICYmIHNlY3Rpb25zW1IxQ1NfRklMRV9DVVNUT01fR0FURVNfTElTVF9TRUNUSU9OXSAhPT0gbnVsbFxuICAgICAgICAmJiB0eXBlb2Ygc2VjdGlvbnNbUjFDU19GSUxFX0NVU1RPTV9HQVRFU19VU0VTX1NFQ1RJT05dICE9PSBcInVuZGVmaW5lZFwiICYmIHNlY3Rpb25zW1IxQ1NfRklMRV9DVVNUT01fR0FURVNfVVNFU19TRUNUSU9OXSAhPT0gbnVsbDtcblxuICAgIGF3YWl0IGVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDb25zdHJhaW50cyhmZCxzZWN0aW9ucywgcjFjcywgbG9nZ2VyLCBsb2dnZXJDdHgpIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIGxvZ2dlciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvcHRpb25zID0gbG9nZ2VyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxvZ2dlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvcHRpb25zPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgbG9nZ2VyOiBsb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJDdHg6IGxvZ2dlckN0eCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBiUjFjcyA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkLCBzZWN0aW9ucywgMik7XG4gICAgbGV0IGJSMWNzUG9zID0gMDtcbiAgICBsZXQgY29uc3RyYWludHM7XG4gICAgaWYgKHIxY3MubkNvbnN0cmFpbnRzPjE8PDIwKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gbmV3IEJpZ0FycmF5JDMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdHJhaW50cyA9IFtdO1xuICAgIH1cbiAgICBmb3IgKGxldCBpPTA7IGk8cjFjcy5uQ29uc3RyYWludHM7IGkrKykge1xuICAgICAgICBpZiAoKG9wdGlvbnMubG9nZ2VyKSYmKGklMTAwMDAwID09IDApKSBvcHRpb25zLmxvZ2dlci5pbmZvKGAke29wdGlvbnMubG9nZ2VyQ3R4fTogTG9hZGluZyBjb25zdHJhaW50czogJHtpfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICBjb25zdCBjID0gcmVhZENvbnN0cmFpbnQoKTtcbiAgICAgICAgY29uc3RyYWludHMucHVzaChjKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuXG5cbiAgICBmdW5jdGlvbiByZWFkQ29uc3RyYWludCgpIHtcbiAgICAgICAgY29uc3QgYyA9IFtdO1xuICAgICAgICBjWzBdID0gcmVhZExDKCk7XG4gICAgICAgIGNbMV0gPSByZWFkTEMoKTtcbiAgICAgICAgY1syXSA9IHJlYWRMQygpO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkTEMoKSB7XG4gICAgICAgIGNvbnN0IGxjPSB7fTtcblxuICAgICAgICBjb25zdCBidWZmVUwzMiA9IGJSMWNzLnNsaWNlKGJSMWNzUG9zLCBiUjFjc1Bvcys0KTtcbiAgICAgICAgYlIxY3NQb3MgKz0gNDtcbiAgICAgICAgY29uc3QgYnVmZlVMMzJWID0gbmV3IERhdGFWaWV3KGJ1ZmZVTDMyLmJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IG5JZHggPSBidWZmVUwzMlYuZ2V0VWludDMyKDAsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBiUjFjcy5zbGljZShiUjFjc1BvcywgYlIxY3NQb3MgKyAoNCtyMWNzLm44KSpuSWR4ICk7XG4gICAgICAgIGJSMWNzUG9zICs9ICg0K3IxY3MubjgpKm5JZHg7XG4gICAgICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5JZHg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gYnVmZlYuZ2V0VWludDMyKGkqKDQrcjFjcy5uOCksIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsID0gcjFjcy5GLmZyb21ScHJMRShidWZmLCBpKig0K3IxY3MubjgpKzQpO1xuICAgICAgICAgICAgbGNbaWR4XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGM7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkTWFwKGZkLCBzZWN0aW9ucywgcjFjcywgbG9nZ2VyLCBsb2dnZXJDdHgpIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIGxvZ2dlciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvcHRpb25zID0gbG9nZ2VyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxvZ2dlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvcHRpb25zPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgbG9nZ2VyOiBsb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXJDdHg6IGxvZ2dlckN0eCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYk1hcCA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkLCBzZWN0aW9ucywgMyk7XG4gICAgbGV0IGJNYXBQb3MgPSAwO1xuICAgIGxldCBtYXA7XG5cbiAgICBpZiAocjFjcy5uVmFycz4xPDwyMCkge1xuICAgICAgICBtYXAgPSBuZXcgQmlnQXJyYXkkMygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcCA9IFtdO1xuICAgIH1cbiAgICBmb3IgKGxldCBpPTA7IGk8cjFjcy5uVmFyczsgaSsrKSB7XG4gICAgICAgIGlmICgob3B0aW9ucy5sb2dnZXIpJiYoaSUxMDAwMCA9PSAwKSkgb3B0aW9ucy5sb2dnZXIuaW5mbyhgJHtvcHRpb25zLmxvZ2dlckN0eH06IExvYWRpbmcgbWFwOiAke2l9LyR7cjFjcy5uVmFyc31gKTtcbiAgICAgICAgY29uc3QgaWR4ID0gcmVhZFVMRTY0KCk7XG4gICAgICAgIG1hcC5wdXNoKGlkeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcblxuICAgIGZ1bmN0aW9uIHJlYWRVTEU2NCgpIHtcbiAgICAgICAgY29uc3QgYnVmZlVMRTY0ID0gYk1hcC5zbGljZShiTWFwUG9zLCBiTWFwUG9zKzgpO1xuICAgICAgICBiTWFwUG9zICs9IDg7XG4gICAgICAgIGNvbnN0IGJ1ZmZVTEU2NFYgPSBuZXcgRGF0YVZpZXcoYnVmZlVMRTY0LmJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IExTQiA9IGJ1ZmZVTEU2NFYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBjb25zdCBNU0IgPSBidWZmVUxFNjRWLmdldFVpbnQzMig0LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gTVNCICogMHgxMDAwMDAwMDAgKyBMU0I7XG4gICAgfVxuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRSMWNzRmQoZmQsIHNlY3Rpb25zLCBvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogT3B0aW9ucyBwcm9wZXJ0aWVzOlxuICAgICAqICBsb2FkQ29uc3RyYWludHM6IDxib29sPiB0cnVlIGJ5IGRlZmF1bHRcbiAgICAgKiAgbG9hZE1hcDogICAgICAgICA8Ym9vbD4gZmFsc2UgYnkgZGVmYXVsdFxuICAgICAqICBsb2FkQ3VzdG9tR2F0ZXM6IDxib29sPiB0cnVlIGJ5IGRlZmF1bHRcbiAgICAgKi9cblxuICAgIGlmKHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlYWRSMWNzRmQ6IG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5sb2FkQ29uc3RyYWludHMgPSBcImxvYWRDb25zdHJhaW50c1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLmxvYWRDb25zdHJhaW50cyA6IHRydWU7XG4gICAgb3B0aW9ucy5sb2FkTWFwID0gXCJsb2FkTWFwXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMubG9hZE1hcCA6IGZhbHNlO1xuICAgIG9wdGlvbnMubG9hZEN1c3RvbUdhdGVzID0gXCJsb2FkQ3VzdG9tR2F0ZXNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5sb2FkQ3VzdG9tR2F0ZXMgOiB0cnVlO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVhZFIxY3NIZWFkZXIoZmQsIHNlY3Rpb25zLCBvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLmxvYWRDb25zdHJhaW50cykge1xuICAgICAgICByZXMuY29uc3RyYWludHMgPSBhd2FpdCByZWFkQ29uc3RyYWludHMoZmQsIHNlY3Rpb25zLCByZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIFJlYWQgTGFiZWxzXG5cbiAgICBpZiAob3B0aW9ucy5sb2FkTWFwKSB7XG4gICAgICAgIHJlcy5tYXAgPSBhd2FpdCByZWFkTWFwKGZkLCBzZWN0aW9ucywgcmVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sb2FkQ3VzdG9tR2F0ZXMpIHtcbiAgICAgICAgaWYgKHJlcy51c2VDdXN0b21HYXRlcykge1xuICAgICAgICAgICAgcmVzLmN1c3RvbUdhdGVzID0gYXdhaXQgcmVhZEN1c3RvbUdhdGVzTGlzdFNlY3Rpb24oZmQsIHNlY3Rpb25zLCByZXMpO1xuICAgICAgICAgICAgcmVzLmN1c3RvbUdhdGVzVXNlcyA9IGF3YWl0IHJlYWRDdXN0b21HYXRlc1VzZXNTZWN0aW9uKGZkLCBzZWN0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMuY3VzdG9tR2F0ZXMgPSBbXTtcbiAgICAgICAgICAgIHJlcy5jdXN0b21HYXRlc1VzZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkUjFjcyhmaWxlTmFtZSwgbG9hZENvbnN0cmFpbnRzLCBsb2FkTWFwLCBzaW5nbGVUaHJlYWQsIGxvZ2dlciwgbG9nZ2VyQ3R4KSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBsb2FkQ29uc3RyYWludHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IGxvYWRDb25zdHJhaW50cztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2FkQ29uc3RyYWludHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgb3B0aW9ucz0ge1xuICAgICAgICAgICAgbG9hZENvbnN0cmFpbnRzOiB0cnVlLFxuICAgICAgICAgICAgbG9hZE1hcDogZmFsc2UsXG4gICAgICAgICAgICBsb2FkQ3VzdG9tR2F0ZXM6IHRydWVcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgbG9hZENvbnN0cmFpbnRzOiBsb2FkQ29uc3RyYWludHMsXG4gICAgICAgICAgICBsb2FkTWFwOiBsb2FkTWFwLFxuICAgICAgICAgICAgc2luZ2xlVGhyZWFkOiBzaW5nbGVUaHJlYWQsXG4gICAgICAgICAgICBsb2dnZXI6IGxvZ2dlcixcbiAgICAgICAgICAgIGxvZ2dlckN0eDogbG9nZ2VyQ3R4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qge2ZkLCBzZWN0aW9uc30gPSBhd2FpdCByZWFkQmluRmlsZShmaWxlTmFtZSwgXCJyMWNzXCIsIDEpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVhZFIxY3NGZChmZCwgc2VjdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDdXN0b21HYXRlc0xpc3RTZWN0aW9uKGZkLCBzZWN0aW9ucywgcmVzKSB7XG4gICAgYXdhaXQgc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIFIxQ1NfRklMRV9DVVNUT01fR0FURVNfTElTVF9TRUNUSU9OKTtcblxuICAgIGxldCBudW0gPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcblxuICAgIGxldCBjdXN0b21HYXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgbGV0IGN1c3RvbUdhdGUgPSB7fTtcbiAgICAgICAgY3VzdG9tR2F0ZS50ZW1wbGF0ZU5hbWUgPSBhd2FpdCBmZC5yZWFkU3RyaW5nKCk7XG4gICAgICAgIGxldCBudW1QYXJhbWV0ZXJzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG5cbiAgICAgICAgY3VzdG9tR2F0ZS5wYXJhbWV0ZXJzID0gQXJyYXkobnVtUGFyYW1ldGVycyk7XG4gICAgICAgIGxldCBidWZmID0gYXdhaXQgZmQucmVhZChyZXMubjggKiBudW1QYXJhbWV0ZXJzKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVBhcmFtZXRlcnM7IGorKykge1xuICAgICAgICAgICAgY3VzdG9tR2F0ZS5wYXJhbWV0ZXJzW2pdID0gcmVzLkYuZnJvbVJwckxFKGJ1ZmYsIGogKiByZXMubjgsIHJlcy5uOCk7ICAgICAgICB9XG4gICAgICAgIGN1c3RvbUdhdGVzLnB1c2goY3VzdG9tR2F0ZSk7XG4gICAgfVxuICAgIGF3YWl0IGVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiBjdXN0b21HYXRlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEN1c3RvbUdhdGVzVXNlc1NlY3Rpb24oZmQsc2VjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBiUjFjcyA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkLCBzZWN0aW9ucywgUjFDU19GSUxFX0NVU1RPTV9HQVRFU19VU0VTX1NFQ1RJT04pO1xuICAgIGNvbnN0IGJSMWNzMzIgPSBuZXcgVWludDMyQXJyYXkoYlIxY3MuYnVmZmVyLCBiUjFjcy5ieXRlT2Zmc2V0LCBiUjFjcy5ieXRlTGVuZ3RoLzQpO1xuICAgIGNvbnN0IG5DdXN0b21HYXRlVXNlcyA9IGJSMWNzMzJbMF07XG4gICAgbGV0IGJSMWNzUG9zID0gMTtcbiAgICBsZXQgY3VzdG9tR2F0ZXNVc2VzO1xuICAgIGlmIChuQ3VzdG9tR2F0ZVVzZXM+MTw8MjApIHtcbiAgICAgICAgY3VzdG9tR2F0ZXNVc2VzID0gbmV3IEJpZ0FycmF5JDMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjdXN0b21HYXRlc1VzZXMgPSBbXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaT0wOyBpPG5DdXN0b21HYXRlVXNlczsgaSsrKSB7XG4gICAgICAgIGlmICgob3B0aW9ucy5sb2dnZXIpJiYoaSUxMDAwMDAgPT0gMCkpIG9wdGlvbnMubG9nZ2VyLmluZm8oYCR7b3B0aW9ucy5sb2dnZXJDdHh9OiBMb2FkaW5nIGN1c3RvbSBnYXRlIHVzZXM6ICR7aX0vJHtuQ3VzdG9tR2F0ZVVzZXN9YCk7XG4gICAgICAgIGxldCBjID0ge307XG4gICAgICAgIGMuaWQgPSBiUjFjczMyW2JSMWNzUG9zKytdO1xuICAgICAgICBsZXQgbnVtU2lnbmFscyA9IGJSMWNzMzJbYlIxY3NQb3MrK107XG4gICAgICAgIGMuc2lnbmFscyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVNpZ25hbHM7IGorKykge1xuICAgICAgICAgICAgY29uc3QgTFNCID0gYlIxY3MzMltiUjFjc1BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IE1TQiA9IGJSMWNzMzJbYlIxY3NQb3MrK107XG4gICAgICAgICAgICBjLnNpZ25hbHMucHVzaChNU0IgKiAweDEwMDAwMDAwMCArIExTQik7XG4gICAgICAgIH1cbiAgICAgICAgY3VzdG9tR2F0ZXNVc2VzLnB1c2goYyk7XG4gICAgfVxuICAgIHJldHVybiBjdXN0b21HYXRlc1VzZXM7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNvbnN0IGJsczEyMzgxciA9IFNjYWxhci5lKFwiNzNlZGE3NTMyOTlkN2Q0ODMzMzlkODA4MDlhMWQ4MDU1M2JkYTQwMmZmZmU1YmZlZmZmZmZmZmYwMDAwMDAwMVwiLCAxNik7XG5jb25zdCBibjEyOHIgPSBTY2FsYXIuZShcIjIxODg4MjQyODcxODM5Mjc1MjIyMjQ2NDA1NzQ1MjU3Mjc1MDg4NTQ4MzY0NDAwNDE2MDM0MzQzNjk4MjA0MTg2NTc1ODA4NDk1NjE3XCIpO1xuXG5hc3luYyBmdW5jdGlvbiByMWNzSW5mbyhyMWNzTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBjaXIgPSBhd2FpdCByZWFkUjFjcyhyMWNzTmFtZSk7XG5cbiAgICBpZiAoU2NhbGFyLmVxKGNpci5wcmltZSwgYm4xMjhyKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkN1cnZlOiBibi0xMjhcIik7XG4gICAgfSBlbHNlIGlmIChTY2FsYXIuZXEoY2lyLnByaW1lLCBibHMxMjM4MXIpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiQ3VydmU6IGJsczEyLTM4MVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgVW5rbm93biBDdXJ2ZS4gUHJpbWU6ICR7U2NhbGFyLnRvU3RyaW5nKGNpci5wcmltZSl9YCk7XG4gICAgfVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIFdpcmVzOiAke2Npci5uVmFyc31gKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgIyBvZiBDb25zdHJhaW50czogJHtjaXIubkNvbnN0cmFpbnRzfWApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIFByaXZhdGUgSW5wdXRzOiAke2Npci5uUHJ2SW5wdXRzfWApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIFB1YmxpYyBJbnB1dHM6ICR7Y2lyLm5QdWJJbnB1dHN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgTGFiZWxzOiAke2Npci5uTGFiZWxzfWApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIE91dHB1dHM6ICR7Y2lyLm5PdXRwdXRzfWApO1xuXG4gICAgcmV0dXJuIGNpcjtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuXG5hc3luYyBmdW5jdGlvbiByMWNzRXhwb3J0SnNvbihyMWNzRmlsZU5hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3QgY2lyID0gYXdhaXQgcmVhZFIxY3MocjFjc0ZpbGVOYW1lLCB0cnVlLCB0cnVlLCB0cnVlLCBsb2dnZXIpO1xuICAgIGNvbnN0IEZyPWNpci5jdXJ2ZS5GcjtcbiAgICBkZWxldGUgY2lyLmN1cnZlO1xuICAgIGRlbGV0ZSBjaXIuRjtcblxuICAgIHJldHVybiBzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkKEZyLCBjaXIpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG52YXIgcjFjcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgcHJpbnQ6IHIxY3NQcmludCxcbiAgICBpbmZvOiByMWNzSW5mbyxcbiAgICBleHBvcnRKc29uOiByMWNzRXhwb3J0SnNvblxufSk7XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRTeW1ib2xzKHN5bUZpbGVOYW1lKSB7XG4gICAgY29uc3Qgc3ltID0ge1xuICAgICAgICBsYWJlbElkeDJOYW1lOiBbIFwib25lXCIgXSxcbiAgICAgICAgdmFySWR4Mk5hbWU6IFsgXCJvbmVcIiBdLFxuICAgICAgICBjb21wb25lbnRJZHgyTmFtZTogW11cbiAgICB9O1xuICAgIGNvbnN0IGZkID0gYXdhaXQgcmVhZEV4aXN0aW5nKHN5bUZpbGVOYW1lKTtcbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChmZC50b3RhbFNpemUpO1xuICAgIGNvbnN0IHN5bXNTdHIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKS5kZWNvZGUoYnVmZik7XG4gICAgY29uc3QgbGluZXMgPSBzeW1zU3RyLnNwbGl0KFwiXFxuXCIpO1xuICAgIGZvciAobGV0IGk9MDsgaTxsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBsaW5lc1tpXS5zcGxpdChcIixcIik7XG4gICAgICAgIGlmIChhcnIubGVuZ3RoIT00KSBjb250aW51ZTtcbiAgICAgICAgaWYgKHN5bS52YXJJZHgyTmFtZVthcnJbMV1dKSB7XG4gICAgICAgICAgICBzeW0udmFySWR4Mk5hbWVbYXJyWzFdXSArPSBcInxcIiArIGFyclszXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN5bS52YXJJZHgyTmFtZVthcnJbMV1dID0gYXJyWzNdO1xuICAgICAgICB9XG4gICAgICAgIHN5bS5sYWJlbElkeDJOYW1lW2FyclswXV0gPSBhcnJbM107XG4gICAgICAgIGlmICghc3ltLmNvbXBvbmVudElkeDJOYW1lW2FyclsyXV0pIHtcbiAgICAgICAgICAgIHN5bS5jb21wb25lbnRJZHgyTmFtZVthcnJbMl1dID0gZXh0cmFjdENvbXBvbmVudChhcnJbM10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIHJldHVybiBzeW07XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0Q29tcG9uZW50KG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXJyID0gbmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgIGFyci5wb3AoKTsgLy8gUmVtb3ZlIHRoZSBsYXNyIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIGFyci5qb2luKFwiLlwiKTtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzOiB1bnN0cmluZ2lmeUJpZ0ludHMkN30gPSB1dGlscztcblxuXG5hc3luYyBmdW5jdGlvbiB3dG5zRGVidWcoX2lucHV0LCB3YXNtRmlsZU5hbWUsIHd0bnNGaWxlTmFtZSwgc3ltTmFtZSwgb3B0aW9ucywgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyQ3KF9pbnB1dCk7XG5cbiAgICBjb25zdCBmZFdhc20gPSBhd2FpdCByZWFkRXhpc3Rpbmcod2FzbUZpbGVOYW1lKTtcbiAgICBjb25zdCB3YXNtID0gYXdhaXQgZmRXYXNtLnJlYWQoZmRXYXNtLnRvdGFsU2l6ZSk7XG4gICAgYXdhaXQgZmRXYXNtLmNsb3NlKCk7XG5cbiAgICBjb25zdCB3Y09wcyA9IHsuLi5vcHRpb25zLCBzYW5pdHlDaGVjazogdHJ1ZX07XG4gICAgbGV0IHN5bSA9IGF3YWl0IGxvYWRTeW1ib2xzKHN5bU5hbWUpO1xuICAgIGlmIChvcHRpb25zLnNldCkge1xuICAgICAgICBpZiAoIXN5bSkgc3ltID0gYXdhaXQgbG9hZFN5bWJvbHMoc3ltTmFtZSk7XG4gICAgICAgIHdjT3BzLmxvZ1NldFNpZ25hbD0gZnVuY3Rpb24obGFiZWxJZHgsIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaGUgbGluZSBiZWxvdyBzcGxpdHMgdGhlIGFycm93IGxvZyBpbnRvIDIgc3RyaW5ncyB0byBhdm9pZCBzb21lIFNlY3VyZSBFQ01BU2NyaXB0IGlzc3Vlc1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJTRVQgXCIgKyBzeW0ubGFiZWxJZHgyTmFtZVtsYWJlbElkeF0gKyBcIiA8XCIgKyBcIi0tIFwiICsgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmdldCkge1xuICAgICAgICBpZiAoIXN5bSkgc3ltID0gYXdhaXQgbG9hZFN5bWJvbHMoc3ltTmFtZSk7XG4gICAgICAgIHdjT3BzLmxvZ0dldFNpZ25hbD0gZnVuY3Rpb24odmFySWR4LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIGxpbmUgYmVsb3cgc3BsaXRzIHRoZSBhcnJvdyBsb2cgaW50byAyIHN0cmluZ3MgdG8gYXZvaWQgc29tZSBTZWN1cmUgRUNNQVNjcmlwdCBpc3N1ZXNcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiR0VUIFwiICsgc3ltLmxhYmVsSWR4Mk5hbWVbdmFySWR4XSArIFwiIC0tXCIgKyBcIj4gXCIgKyB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlcikge1xuICAgICAgICBpZiAoIXN5bSkgc3ltID0gYXdhaXQgbG9hZFN5bWJvbHMoc3ltTmFtZSk7XG4gICAgICAgIHdjT3BzLmxvZ1N0YXJ0Q29tcG9uZW50PSBmdW5jdGlvbihjSWR4KSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlNUQVJUOiBcIiArIHN5bS5jb21wb25lbnRJZHgyTmFtZVtjSWR4XSk7XG4gICAgICAgIH07XG4gICAgICAgIHdjT3BzLmxvZ0ZpbmlzaENvbXBvbmVudD0gZnVuY3Rpb24oY0lkeCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGSU5JU0g6IFwiICsgc3ltLmNvbXBvbmVudElkeDJOYW1lW2NJZHhdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgd2NPcHMuc3ltID0gc3ltO1xuXG4gICAgY29uc3Qgd2MgPSBhd2FpdCBidWlsZGVyKHdhc20sIHdjT3BzKTtcbiAgICBjb25zdCB3ID0gYXdhaXQgd2MuY2FsY3VsYXRlV2l0bmVzcyhpbnB1dCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBmZFd0bnMgPSBhd2FpdCBjcmVhdGVCaW5GaWxlKHd0bnNGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDIpO1xuXG4gICAgYXdhaXQgd3JpdGUoZmRXdG5zLCB3LCB3Yy5wcmltZSk7XG5cbiAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuYXN5bmMgZnVuY3Rpb24gd3Ruc0V4cG9ydEpzb24od3Ruc0ZpbGVOYW1lKSB7XG5cbiAgICBjb25zdCB3ID0gYXdhaXQgcmVhZCh3dG5zRmlsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHc7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIHd0bnNDaGVjayhyMWNzRmlsZW5hbWUsIHd0bnNGaWxlbmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIldJVE5FU1MgQ0hFQ0tJTkcgU1RBUlRFRFwiKTtcblxuICAgIC8vIFJlYWQgcjFjcyBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgcjFjcyBmaWxlXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZmQ6IGZkUjFjcyxcbiAgICAgICAgc2VjdGlvbnM6IHNlY3Rpb25zUjFjc1xuICAgIH0gPSBhd2FpdCByZWFkQmluRmlsZShyMWNzRmlsZW5hbWUsIFwicjFjc1wiLCAxKTtcbiAgICBjb25zdCByMWNzID0gYXdhaXQgcmVhZFIxY3NGZChmZFIxY3MsIHNlY3Rpb25zUjFjcywgeyBsb2FkQ29uc3RyYWludHM6IGZhbHNlLCBsb2FkQ3VzdG9tR2F0ZXM6IGZhbHNlIH0pO1xuXG4gICAgLy8gUmVhZCB3aXRuZXNzIGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyB3aXRuZXNzIGZpbGVcIik7XG4gICAgY29uc3Qge1xuICAgICAgICBmZDogZmRXdG5zLFxuICAgICAgICBzZWN0aW9uczogd3Ruc1NlY3Rpb25zXG4gICAgfSA9IGF3YWl0IHJlYWRCaW5GaWxlKHd0bnNGaWxlbmFtZSwgXCJ3dG5zXCIsIDIpO1xuICAgIGNvbnN0IHd0bnNIZWFkZXIgPSBhd2FpdCByZWFkSGVhZGVyKGZkV3Rucywgd3Ruc1NlY3Rpb25zKTtcblxuICAgIGlmICghU2NhbGFyLmVxKHIxY3MucHJpbWUsIHd0bnNIZWFkZXIucSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VydmUgb2YgdGhlIHdpdG5lc3MgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnZlIG9mIHRoZSBwcm92aW5nIGtleVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmV2l0bmVzcyA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkV3Rucywgd3Ruc1NlY3Rpb25zLCAyKTtcbiAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUihyMWNzLnByaW1lKTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHNGciA9IEZyLm44O1xuXG4gICAgY29uc3QgYlIxY3MgPSBhd2FpdCByZWFkU2VjdGlvbihmZFIxY3MsIHNlY3Rpb25zUjFjcywgMik7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCIgIFdJVE5FU1MgQ0hFQ0tcIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEN1cnZlOiAgICAgICAgICAke3IxY3MuY3VydmUubmFtZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgVmFycyAod2lyZXMpOiAgICR7cjFjcy5uVmFyc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgT3V0cHV0czogICAgICAgICR7cjFjcy5uT3V0cHV0c31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHVibGljIElucHV0czogICR7cjFjcy5uUHViSW5wdXRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBQcml2YXRlIElucHV0czogJHtyMWNzLm5QcnZJbnB1dHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIExhYmVsczogICAgICAgICAke3IxY3MubkxhYmVsc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ29uc3RyYWludHM6ICAgICR7cjFjcy5uQ29uc3RyYWludHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEN1c3RvbSBHYXRlczogICAke3IxY3MudXNlQ3VzdG9tR2F0ZXN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ2hlY2tpbmcgd2l0bmVzcyBjb3JyZWN0bmVzc1wiKTtcblxuICAgIGxldCBiUjFjc1BvcyA9IDA7XG4gICAgbGV0IHJlcyA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByMWNzLm5Db25zdHJhaW50czsgaSsrKSB7XG4gICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgwrfCt8K3IHByb2Nlc3NpbmcgcjFjcyBjb25zdHJhaW50cyAke2l9LyR7cjFjcy5uQ29uc3RyYWludHN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1JlYWQgdGhlIHRocmVlIGxpbmVhciBjb21iaW5hdGlvbnMgb2YgdGhlIGNvbnN0cmFpbnQgd2hlcmUgQSAqIEIgLSBDID0gMFxuICAgICAgICBjb25zdCBsY0EgPSByZWFkTEMoKTtcbiAgICAgICAgY29uc3QgbGNCID0gcmVhZExDKCk7XG4gICAgICAgIGNvbnN0IGxjQyA9IHJlYWRMQygpO1xuXG4gICAgICAgIC8vIEV2YWx1YXRlIHRoZSBsaW5lYXIgY29tYmluYXRpb25zXG4gICAgICAgIGNvbnN0IGV2YWxBID0gRXZhbHVhdGVMaW5lYXJDb21iaW5hdGlvbihsY0EpO1xuICAgICAgICBjb25zdCBldmFsQiA9IEV2YWx1YXRlTGluZWFyQ29tYmluYXRpb24obGNCKTtcbiAgICAgICAgY29uc3QgZXZhbEMgPSBFdmFsdWF0ZUxpbmVhckNvbWJpbmF0aW9uKGxjQyk7XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBBICogQiAtIEMgPT0gMFxuICAgICAgICBpZiAoIUZyLmVxKEZyLnN1YihGci5tdWwoZXZhbEEsIGV2YWxCKSwgZXZhbEMpLCBGci56ZXJvKSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCLCt8K3wrcgYWJvcnRpbmcgY2hlY2tpbmcgcHJvY2VzcyBhdCBjb25zdHJhaW50IFwiICsgaSk7XG4gICAgICAgICAgICByZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmRSMWNzLmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiV0lUTkVTUyBJUyBDT1JSRUNUXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJXSVRORVNTIENIRUNLSU5HIEZJTklTSEVEIFNVQ0NFU1NGVUxMWVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiV0lUTkVTUyBJUyBOT1QgQ09SUkVDVFwiKTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiV0lUTkVTUyBDSEVDS0lORyBGSU5JU0hFRCBVTlNVQ0NFU1NGVUxMWVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG5cbiAgICBmdW5jdGlvbiBFdmFsdWF0ZUxpbmVhckNvbWJpbmF0aW9uKGxjKSB7XG4gICAgICAgIGxldCByZXMgPSBGci56ZXJvO1xuXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhsYyk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoc2lnbmFsSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbFZhbHVlID0gZ2V0V2l0bmVzc1ZhbHVlKHNpZ25hbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbEZhY3RvciA9IGxjW3NpZ25hbElkXTtcblxuICAgICAgICAgICAgcmVzID0gRnIuYWRkKHJlcywgRnIubXVsKHNpZ25hbFZhbHVlLCBzaWduYWxGYWN0b3IpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkTEMoKSB7XG4gICAgICAgIGNvbnN0IGxjID0ge307XG5cbiAgICAgICAgY29uc3QgYnVmZlVMMzIgPSBiUjFjcy5zbGljZShiUjFjc1BvcywgYlIxY3NQb3MgKyA0KTtcbiAgICAgICAgYlIxY3NQb3MgKz0gNDtcbiAgICAgICAgY29uc3QgYnVmZlVMMzJWID0gbmV3IERhdGFWaWV3KGJ1ZmZVTDMyLmJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IG5JZHggPSBidWZmVUwzMlYuZ2V0VWludDMyKDAsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBiUjFjcy5zbGljZShiUjFjc1BvcywgYlIxY3NQb3MgKyAoNCArIHIxY3MubjgpICogbklkeCk7XG4gICAgICAgIGJSMWNzUG9zICs9ICg0ICsgcjFjcy5uOCkgKiBuSWR4O1xuICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbklkeDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBidWZmVi5nZXRVaW50MzIoaSAqICg0ICsgcjFjcy5uOCksIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsID0gcjFjcy5GLmZyb21ScHJMRShidWZmLCBpICogKDQgKyByMWNzLm44KSArIDQpO1xuICAgICAgICAgICAgbGNbaWR4XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2l0bmVzc1ZhbHVlKHNpZ25hbElkKSB7XG4gICAgICAgIHJldHVybiBGci5mcm9tUnByTEUoYnVmZldpdG5lc3Muc2xpY2Uoc2lnbmFsSWQgKiBzRnIsIHNpZ25hbElkICogc0ZyICsgc0ZyKSk7XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG52YXIgd3RucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY2FsY3VsYXRlOiB3dG5zQ2FsY3VsYXRlLFxuICAgIGRlYnVnOiB3dG5zRGVidWcsXG4gICAgZXhwb3J0SnNvbjogd3Ruc0V4cG9ydEpzb24sXG4gICAgY2hlY2s6IHd0bnNDaGVja1xufSk7XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNvbnN0IFNVQkFSUkFZX1NJWkUgPSAweDQwMDAwO1xuXG5jb25zdCBCaWdBcnJheUhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbihvYmosIHByb3ApIHtcbiAgICAgICAgaWYgKCFpc05hTihwcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5nZXRFbGVtZW50KHByb3ApO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIG9ialtwcm9wXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24ob2JqLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzTmFOKHByb3ApKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnNldEVsZW1lbnQocHJvcCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNsYXNzIF9CaWdBcnJheSB7XG4gICAgY29uc3RydWN0b3IgKGluaXRTaXplKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gaW5pdFNpemUgfHwgMDtcbiAgICAgICAgdGhpcy5hcnIgPSBuZXcgQXJyYXkoU1VCQVJSQVlfU0laRSk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGluaXRTaXplOyBpKz1TVUJBUlJBWV9TSVpFKSB7XG4gICAgICAgICAgICB0aGlzLmFycltpL1NVQkFSUkFZX1NJWkVdID0gbmV3IEFycmF5KE1hdGgubWluKFNVQkFSUkFZX1NJWkUsIGluaXRTaXplIC0gaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwdXNoICgpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50ICh0aGlzLmxlbmd0aCwgYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNsaWNlIChmLCB0KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSh0LWYpO1xuICAgICAgICBmb3IgKGxldCBpPWY7IGk8IHQ7IGkrKykgYXJyW2ktZl0gPSB0aGlzLmdldEVsZW1lbnQoaSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGdldEVsZW1lbnQoaWR4KSB7XG4gICAgICAgIGlkeCA9IHBhcnNlSW50KGlkeCk7XG4gICAgICAgIGNvbnN0IGlkeDEgPSBNYXRoLmZsb29yKGlkeCAvIFNVQkFSUkFZX1NJWkUpO1xuICAgICAgICBjb25zdCBpZHgyID0gaWR4ICUgU1VCQVJSQVlfU0laRTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyW2lkeDFdID8gdGhpcy5hcnJbaWR4MV1baWR4Ml0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldEVsZW1lbnQoaWR4LCB2YWx1ZSkge1xuICAgICAgICBpZHggPSBwYXJzZUludChpZHgpO1xuICAgICAgICBjb25zdCBpZHgxID0gTWF0aC5mbG9vcihpZHggLyBTVUJBUlJBWV9TSVpFKTtcbiAgICAgICAgaWYgKCF0aGlzLmFycltpZHgxXSkge1xuICAgICAgICAgICAgdGhpcy5hcnJbaWR4MV0gPSBuZXcgQXJyYXkoU1VCQVJSQVlfU0laRSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWR4MiA9IGlkeCAlIFNVQkFSUkFZX1NJWkU7XG4gICAgICAgIHRoaXMuYXJyW2lkeDFdW2lkeDJdID0gdmFsdWU7XG4gICAgICAgIGlmIChpZHggPj0gdGhpcy5sZW5ndGgpIHRoaXMubGVuZ3RoID0gaWR4KzE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICBjb25zdCBuZXdBID0gbmV3IEJpZ0FycmF5KCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLmFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJyW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHRoaXMuYXJyW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5hcnJbaV1bal0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0EucHVzaChpKlNVQkFSUkFZX1NJWkUraik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0E7XG4gICAgfVxufVxuXG5jbGFzcyBCaWdBcnJheSB7XG4gICAgY29uc3RydWN0b3IoIGluaXRTaXplICkge1xuICAgICAgICBjb25zdCBvYmogPSBuZXcgX0JpZ0FycmF5KGluaXRTaXplKTtcbiAgICAgICAgY29uc3QgZXh0T2JqID0gbmV3IFByb3h5KG9iaiwgQmlnQXJyYXlIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGV4dE9iajtcbiAgICB9XG59XG5cbnZhciBCaWdBcnJheSQxID0gQmlnQXJyYXk7XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuYXN5bmMgZnVuY3Rpb24gbmV3WktleShyMWNzTmFtZSwgcHRhdU5hbWUsIHprZXlOYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IFRBVV9HMSA9IDA7XG4gICAgY29uc3QgVEFVX0cyID0gMTtcbiAgICBjb25zdCBBTFBIQVRBVV9HMSA9IDI7XG4gICAgY29uc3QgQkVUQVRBVV9HMSA9IDM7XG4gICAgY29uc3QgY3NIYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTtcblxuICAgIGNvbnN0IHtmZDogZmRQVGF1LCBzZWN0aW9uczogc2VjdGlvbnNQVGF1fSA9IGF3YWl0IHJlYWRCaW5GaWxlKHB0YXVOYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCByZWFkUFRhdUhlYWRlcihmZFBUYXUsIHNlY3Rpb25zUFRhdSk7XG4gICAgY29uc3Qge2ZkOiBmZFIxY3MsIHNlY3Rpb25zOiBzZWN0aW9uc1IxY3N9ID0gYXdhaXQgcmVhZEJpbkZpbGUocjFjc05hbWUsIFwicjFjc1wiLCAxKTtcbiAgICBjb25zdCByMWNzID0gYXdhaXQgcmVhZFIxY3NIZWFkZXIoZmRSMWNzLCBzZWN0aW9uc1IxY3MsIGZhbHNlKTtcblxuICAgIGNvbnN0IGZkWktleSA9IGF3YWl0IGNyZWF0ZUJpbkZpbGUoemtleU5hbWUsIFwiemtleVwiLCAxLCAxMCwgMTw8MjIsIDE8PDI0KTtcblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5HMi5GLm44KjI7XG5cbiAgICBpZiAocjFjcy5wcmltZSAhPSBjdXJ2ZS5yKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcInIxY3MgY3VydmUgZG9lcyBub3QgbWF0Y2ggcG93ZXJzIG9mIHRhdSBjZXJlbW9ueSBjdXJ2ZVwiKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGNvbnN0IGNpclBvd2VyID0gbG9nMihyMWNzLm5Db25zdHJhaW50cyArIHIxY3MublB1YklucHV0cyArIHIxY3Mubk91dHB1dHMgKzEgLTEpICsxO1xuXG4gICAgaWYgKGNpclBvd2VyID4gcG93ZXIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBjaXJjdWl0IHRvbyBiaWcgZm9yIHRoaXMgcG93ZXIgb2YgdGF1IGNlcmVtb255LiAke3IxY3MubkNvbnN0cmFpbnRzfSoyID4gMioqJHtwb3dlcn1gKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmICghc2VjdGlvbnNQVGF1WzEyXSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQb3dlcnMgb2YgdGF1IGlzIG5vdCBwcmVwYXJlZC5cIik7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBjb25zdCBuUHVibGljID0gcjFjcy5uT3V0cHV0cyArIHIxY3MublB1YklucHV0cztcbiAgICBjb25zdCBkb21haW5TaXplID0gMiAqKiBjaXJQb3dlcjtcblxuICAgIC8vIFdyaXRlIHRoZSBoZWFkZXJcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMSk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoMSk7IC8vIEdyb3RoXG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAvLyBXcml0ZSB0aGUgR3JvdGggaGVhZGVyIHNlY3Rpb25cbiAgICAvLy8vLy8vLy8vL1xuXG4gICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAyKTtcbiAgICBjb25zdCBwcmltZVEgPSBjdXJ2ZS5xO1xuICAgIGNvbnN0IG44cSA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZVEpIC0gMSkgLyA2NCkgKzEpKjg7XG5cbiAgICBjb25zdCBwcmltZVIgPSBjdXJ2ZS5yO1xuICAgIGNvbnN0IG44ciA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZVIpIC0gMSkgLyA2NCkgKzEpKjg7XG4gICAgY29uc3QgUnIgPSBTY2FsYXIubW9kKFNjYWxhci5zaGwoMSwgbjhyKjgpLCBwcmltZVIpO1xuICAgIGNvbnN0IFIyciA9IGN1cnZlLkZyLmUoU2NhbGFyLm1vZChTY2FsYXIubXVsKFJyLFJyKSwgcHJpbWVSKSk7XG5cbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHEpO1xuICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkWktleSwgcHJpbWVRLCBuOHEpO1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG44cik7XG4gICAgYXdhaXQgd3JpdGVCaWdJbnQoZmRaS2V5LCBwcmltZVIsIG44cik7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocjFjcy5uVmFycyk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBiYXJzXG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoblB1YmxpYyk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcHVibGljIHZhcnMgKG5vdCBpbmNsdWRpbmcgT05FKVxuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKGRvbWFpblNpemUpOyAgICAgICAgICAgICAgICAgIC8vIGRvbWFpblNpemVcblxuICAgIGxldCBiQWxwaGExO1xuICAgIGJBbHBoYTEgPSBhd2FpdCBmZFBUYXUucmVhZChzRzEsIHNlY3Rpb25zUFRhdVs0XVswXS5wKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoYkFscGhhMSk7XG4gICAgYkFscGhhMSA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJBbHBoYTEpO1xuICAgIGNzSGFzaGVyLnVwZGF0ZShiQWxwaGExKTtcblxuICAgIGxldCBiQmV0YTE7XG4gICAgYkJldGExID0gYXdhaXQgZmRQVGF1LnJlYWQoc0cxLCBzZWN0aW9uc1BUYXVbNV1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJCZXRhMSk7XG4gICAgYkJldGExID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYkJldGExKTtcbiAgICBjc0hhc2hlci51cGRhdGUoYkJldGExKTtcblxuICAgIGxldCBiQmV0YTI7XG4gICAgYkJldGEyID0gYXdhaXQgZmRQVGF1LnJlYWQoc0cyLCBzZWN0aW9uc1BUYXVbNl1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJCZXRhMik7XG4gICAgYkJldGEyID0gYXdhaXQgY3VydmUuRzIuYmF0Y2hMRU10b1UoYkJldGEyKTtcbiAgICBjc0hhc2hlci51cGRhdGUoYkJldGEyKTtcblxuICAgIGNvbnN0IGJnMSA9IG5ldyBVaW50OEFycmF5KHNHMSk7XG4gICAgY3VydmUuRzEudG9ScHJMRU0oYmcxLCAwLCBjdXJ2ZS5HMS5nKTtcbiAgICBjb25zdCBiZzIgPSBuZXcgVWludDhBcnJheShzRzIpO1xuICAgIGN1cnZlLkcyLnRvUnByTEVNKGJnMiwgMCwgY3VydmUuRzIuZyk7XG4gICAgY29uc3QgYmcxVSA9IG5ldyBVaW50OEFycmF5KHNHMSk7XG4gICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQoYmcxVSwgMCwgY3VydmUuRzEuZyk7XG4gICAgY29uc3QgYmcyVSA9IG5ldyBVaW50OEFycmF5KHNHMik7XG4gICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYmcyVSwgMCwgY3VydmUuRzIuZyk7XG5cbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoYmcyKTsgICAgICAgIC8vIGdhbW1hMlxuICAgIGF3YWl0IGZkWktleS53cml0ZShiZzEpOyAgICAgICAgLy8gZGVsdGExXG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJnMik7ICAgICAgICAvLyBkZWx0YTJcbiAgICBjc0hhc2hlci51cGRhdGUoYmcyVSk7ICAgICAgLy8gZ2FtbWEyXG4gICAgY3NIYXNoZXIudXBkYXRlKGJnMVUpOyAgICAgIC8vIGRlbHRhMVxuICAgIGNzSGFzaGVyLnVwZGF0ZShiZzJVKTsgICAgICAvLyBkZWx0YTJcbiAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUmVhZGluZyByMWNzXCIpO1xuICAgIGxldCBzUjFjcyA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkUjFjcywgc2VjdGlvbnNSMWNzLCAyKTtcblxuICAgIGNvbnN0IEEgPSBuZXcgQmlnQXJyYXkkMShyMWNzLm5WYXJzKTtcbiAgICBjb25zdCBCMSA9IG5ldyBCaWdBcnJheSQxKHIxY3MublZhcnMpO1xuICAgIGNvbnN0IEIyID0gbmV3IEJpZ0FycmF5JDEocjFjcy5uVmFycyk7XG4gICAgY29uc3QgQyA9IG5ldyBCaWdBcnJheSQxKHIxY3MublZhcnMtIG5QdWJsaWMgLTEpO1xuICAgIGNvbnN0IElDID0gbmV3IEFycmF5KG5QdWJsaWMrMSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgdGF1RzFcIik7XG4gICAgbGV0IHNUYXVHMSA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkUFRhdSwgc2VjdGlvbnNQVGF1LCAxMiwgKGRvbWFpblNpemUgLTEpKnNHMSwgZG9tYWluU2l6ZSpzRzEpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUmVhZGluZyB0YXVHMlwiKTtcbiAgICBsZXQgc1RhdUcyID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDEzLCAoZG9tYWluU2l6ZSAtMSkqc0cyLCBkb21haW5TaXplKnNHMik7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIGFscGhhdGF1RzFcIik7XG4gICAgbGV0IHNBbHBoYVRhdUcxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDE0LCAoZG9tYWluU2l6ZSAtMSkqc0cxLCBkb21haW5TaXplKnNHMSk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIGJldGF0YXVHMVwiKTtcbiAgICBsZXQgc0JldGFUYXVHMSA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkUFRhdSwgc2VjdGlvbnNQVGF1LCAxNSwgKGRvbWFpblNpemUgLTEpKnNHMSwgZG9tYWluU2l6ZSpzRzEpO1xuXG4gICAgYXdhaXQgcHJvY2Vzc0NvbnN0cmFpbnRzKCk7XG5cbiAgICBhd2FpdCBjb21wb3NlQW5kV3JpdGVQb2ludHMoMywgXCJHMVwiLCBJQywgXCJJQ1wiKTtcblxuICAgIGF3YWl0IHdyaXRlSHMoKTtcblxuICAgIGF3YWl0IGhhc2hIUG9pbnRzKCk7XG5cbiAgICBhd2FpdCBjb21wb3NlQW5kV3JpdGVQb2ludHMoOCwgXCJHMVwiLCBDLCBcIkNcIik7XG4gICAgYXdhaXQgY29tcG9zZUFuZFdyaXRlUG9pbnRzKDUsIFwiRzFcIiwgQSwgXCJBXCIpO1xuICAgIGF3YWl0IGNvbXBvc2VBbmRXcml0ZVBvaW50cyg2LCBcIkcxXCIsIEIxLCBcIkIxXCIpO1xuICAgIGF3YWl0IGNvbXBvc2VBbmRXcml0ZVBvaW50cyg3LCBcIkcyXCIsIEIyLCBcIkIyXCIpO1xuXG4gICAgY29uc3QgY3NIYXNoID0gY3NIYXNoZXIuZGlnZXN0KCk7XG4gICAgLy8gQ29udHJpYnV0aW9ucyBzZWN0aW9uXG4gICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAxMCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGNzSGFzaCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoMCk7XG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGNzSGFzaCwgXCJDaXJjdWl0IGhhc2g6IFwiKSk7XG5cblxuICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIGF3YWl0IGZkUjFjcy5jbG9zZSgpO1xuICAgIGF3YWl0IGZkUFRhdS5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIGNzSGFzaDtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlSHMoKSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgOSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZPdXQgPSBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUqc0cxKTtcbiAgICAgICAgaWYgKGNpclBvd2VyIDwgY3VydmUuRnIucykge1xuICAgICAgICAgICAgbGV0IHNUYXVHMSA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkUFRhdSwgc2VjdGlvbnNQVGF1LCAxMiwgKGRvbWFpblNpemUqMi0xKSpzRzEsIGRvbWFpblNpemUqMipzRzEpO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPCBkb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHNwbGl0dGluZyBidWZmZXI6ICR7aX0vJHtkb21haW5TaXplfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBzVGF1RzEuc2xpY2UoIChpKjIrMSkqc0cxLCAoaSoyKzEpKnNHMSArIHNHMSApO1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXQuc2V0KGJ1ZmYsIGkqc0cxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaXJQb3dlciA9PSBjdXJ2ZS5Gci5zKSB7XG4gICAgICAgICAgICBjb25zdCBvID0gc2VjdGlvbnNQVGF1WzEyXVswXS5wICsgKCgyICoqIChjaXJQb3dlcisxKSkgLTEpKnNHMTtcbiAgICAgICAgICAgIGF3YWl0IGZkUFRhdS5yZWFkVG9CdWZmZXIoYnVmZk91dCwgMCwgZG9tYWluU2l6ZSpzRzEsIG8gKyBkb21haW5TaXplKnNHMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJDaXJjdWl0IHRvbyBiaWdcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWl0IHRvbyBiaWcgZm9yIHRoaXMgY3VydmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJ1ZmZPdXQpO1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ29uc3RyYWludHMoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZDb2VmZiA9IG5ldyBVaW50OEFycmF5KDEyICsgY3VydmUuRnIubjgpO1xuICAgICAgICBjb25zdCBidWZmQ29lZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmZDb2VmZi5idWZmZXIpO1xuICAgICAgICBjb25zdCBiT25lID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRnIubjgpO1xuICAgICAgICBjdXJ2ZS5Gci50b1JwckxFKGJPbmUsIDAsIGN1cnZlLkZyLmUoMSkpO1xuXG4gICAgICAgIGxldCByMWNzUG9zID0gMDtcblxuICAgICAgICBmdW5jdGlvbiByMWNzX3JlYWRVTEUzMigpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBzUjFjcy5zbGljZShyMWNzUG9zLCByMWNzUG9zKzQpO1xuICAgICAgICAgICAgcjFjc1BvcyArPSA0O1xuICAgICAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZWLmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvZWZzID0gbmV3IEJpZ0FycmF5JDEoKTtcbiAgICAgICAgZm9yIChsZXQgYz0wOyBjPHIxY3MubkNvbnN0cmFpbnRzOyBjKyspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGMlMTAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1ZyhgcHJvY2Vzc2luZyBjb25zdHJhaW50czogJHtjfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbkEgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5BOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2VmcCA9IHIxY3NQb3M7XG4gICAgICAgICAgICAgICAgcjFjc1BvcyArPSBjdXJ2ZS5Gci5uODtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGwxdCA9IFRBVV9HMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsMSA9IHNHMSpjO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwydCA9IEJFVEFUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEFbc10gPT09IFwidW5kZWZpbmVkXCIpIEFbc10gPSBbXTtcbiAgICAgICAgICAgICAgICBBW3NdLnB1c2goW2wxdCwgbDEsIGNvZWZwXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocyA8PSBuUHVibGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICAgICAgICAgIElDW3NdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBDW3MtIG5QdWJsaWMgLTFdID09PSBcInVuZGVmaW5lZFwiKSBDW3MtIG5QdWJsaWMgLTFdID0gW107XG4gICAgICAgICAgICAgICAgICAgIENbcyAtIG5QdWJsaWMgLTFdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZWZzLnB1c2goWzAsIGMsIHMsIGNvZWZwXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5CID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuQjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29lZnAgPSByMWNzUG9zO1xuICAgICAgICAgICAgICAgIHIxY3NQb3MgKz0gY3VydmUuRnIubjg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsMXQgPSBUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDEgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBjb25zdCBsMnQgPSBUQVVfRzI7XG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBzRzIqYztcbiAgICAgICAgICAgICAgICBjb25zdCBsM3QgPSBBTFBIQVRBVV9HMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsMyA9IHNHMSpjO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQjFbc10gPT09IFwidW5kZWZpbmVkXCIpIEIxW3NdID0gW107XG4gICAgICAgICAgICAgICAgQjFbc10ucHVzaChbbDF0LCBsMSwgY29lZnBdKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEIyW3NdID09PSBcInVuZGVmaW5lZFwiKSBCMltzXSA9IFtdO1xuICAgICAgICAgICAgICAgIEIyW3NdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocyA8PSBuUHVibGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICAgICAgICAgIElDW3NdLnB1c2goW2wzdCwgbDMsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBDW3MtIG5QdWJsaWMgLTFdID09PSBcInVuZGVmaW5lZFwiKSBDW3MtIG5QdWJsaWMgLTFdID0gW107XG4gICAgICAgICAgICAgICAgICAgIENbcy0gblB1YmxpYyAtMV0ucHVzaChbbDN0LCBsMywgY29lZnBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2Vmcy5wdXNoKFsxLCBjLCBzLCBjb2VmcF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuQyA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZWZwID0gcjFjc1BvcztcbiAgICAgICAgICAgICAgICByMWNzUG9zICs9IGN1cnZlLkZyLm44O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbDF0ID0gVEFVX0cxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwxID0gc0cxKmM7XG4gICAgICAgICAgICAgICAgaWYgKHMgPD0gblB1YmxpYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIElDW3NdID09PSBcInVuZGVmaW5lZFwiKSBJQ1tzXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBJQ1tzXS5wdXNoKFtsMXQsIGwxLCBjb2VmcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQ1tzLSBuUHVibGljIC0xXSA9PT0gXCJ1bmRlZmluZWRcIikgQ1tzLSBuUHVibGljIC0xXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBDW3MtIG5QdWJsaWMgLTFdLnB1c2goW2wxdCwgbDEsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPD0gblB1YmxpYyA7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgbDF0ID0gVEFVX0cxO1xuICAgICAgICAgICAgY29uc3QgbDEgPSBzRzEqKHIxY3MubkNvbnN0cmFpbnRzICsgcyk7XG4gICAgICAgICAgICBjb25zdCBsMnQgPSBCRVRBVEFVX0cxO1xuICAgICAgICAgICAgY29uc3QgbDIgPSBzRzEqKHIxY3MubkNvbnN0cmFpbnRzICsgcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEFbc10gPT09IFwidW5kZWZpbmVkXCIpIEFbc10gPSBbXTtcbiAgICAgICAgICAgIEFbc10ucHVzaChbbDF0LCBsMSwgLTFdKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICBJQ1tzXS5wdXNoKFtsMnQsIGwyLCAtMV0pO1xuICAgICAgICAgICAgY29lZnMucHVzaChbMCwgcjFjcy5uQ29uc3RyYWludHMgKyBzLCBzLCAtMV0pO1xuICAgICAgICB9XG5cblxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDQpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmZTZWN0aW9uID0gbmV3IEJpZ0J1ZmZlcihjb2Vmcy5sZW5ndGgqKDEyK2N1cnZlLkZyLm44KSArIDQpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmY0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IGJ1ZmY0ViA9IG5ldyBEYXRhVmlldyhidWZmNC5idWZmZXIpO1xuICAgICAgICBidWZmNFYuc2V0VWludDMyKDAsIGNvZWZzLmxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgIGJ1ZmZTZWN0aW9uLnNldChidWZmNCk7XG4gICAgICAgIGxldCBjb2Vmc1BvcyA9IDQ7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb2Vmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyBjb2VmZnM6ICR7aX0vJHtjb2Vmcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB3cml0ZUNvZWYoY29lZnNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJ1ZmZTZWN0aW9uKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDb2VmKGMpIHtcbiAgICAgICAgICAgIGJ1ZmZDb2VmZlYuc2V0VWludDMyKDAsIGNbMF0sIHRydWUpO1xuICAgICAgICAgICAgYnVmZkNvZWZmVi5zZXRVaW50MzIoNCwgY1sxXSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmQ29lZmZWLnNldFVpbnQzMig4LCBjWzJdLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGNbM10+PTApIHtcbiAgICAgICAgICAgICAgICBuID0gY3VydmUuRnIuZnJvbVJwckxFKHNSMWNzLnNsaWNlKGNbM10sIGNbM10gKyBjdXJ2ZS5Gci5uOCksIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gY3VydmUuRnIuZnJvbVJwckxFKGJPbmUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgblIyID0gY3VydmUuRnIubXVsKG4sIFIycik7XG4gICAgICAgICAgICBjdXJ2ZS5Gci50b1JwckxFKGJ1ZmZDb2VmZiwgMTIsIG5SMik7XG4gICAgICAgICAgICBidWZmU2VjdGlvbi5zZXQoYnVmZkNvZWZmLCBjb2Vmc1Bvcyk7XG4gICAgICAgICAgICBjb2Vmc1BvcyArPSBidWZmQ29lZmYubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wb3NlQW5kV3JpdGVQb2ludHMoaWRTZWN0aW9uLCBncm91cE5hbWUsIGFyciwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgQ0hVTktfU0laRT0gMTw8MTU7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuXG4gICAgICAgIGhhc2hVMzIoYXJyLmxlbmd0aCk7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgaWRTZWN0aW9uKTtcblxuICAgICAgICBsZXQgb3BQcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGxldCBpPTA7XG4gICAgICAgIHdoaWxlIChpPGFyci5sZW5ndGgpIHtcblxuICAgICAgICAgICAgbGV0IHQ9MDtcbiAgICAgICAgICAgIHdoaWxlICgoaTxhcnIubGVuZ3RoKSYmKHQ8Y3VydmUudG0uY29uY3VycmVuY3kpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgIGxvZ2dlci5kZWJ1ZyhgV3JpdGluZyBwb2ludHMgc3RhcnQgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHthcnIubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIGxldCBuID0gMTtcbiAgICAgICAgICAgICAgICBsZXQgblAgPSAoYXJyW2ldID8gYXJyW2ldLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoaSArIG4gPCBhcnIubGVuZ3RoKSAmJiAoblAgKyAoYXJyW2krbl0gPyBhcnJbaStuXS5sZW5ndGggOiAwKSA8IENIVU5LX1NJWkUpICYmIChuPENIVU5LX1NJWkUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5QICs9IChhcnJbaStuXSA/IGFycltpK25dLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgICAgICAgICBuICsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdWJBcnIgPSBhcnIuc2xpY2UoaSwgaSArIG4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9pID0gaTtcbiAgICAgICAgICAgICAgICBvcFByb21pc2VzLnB1c2goY29tcG9zZUFuZFdyaXRlUG9pbnRzVGhyZWFkKGdyb3VwTmFtZSwgc3ViQXJyLCBsb2dnZXIsIHNlY3Rpb25OYW1lKS50aGVuKCAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSAgbG9nZ2VyLmRlYnVnKGBXcml0aW5nIHBvaW50cyBlbmQgJHtzZWN0aW9uTmFtZX06ICR7X2l9LyR7YXJyLmxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGkgKz0gbjtcbiAgICAgICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBrPTA7IGs8cmVzdWx0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHJlc3VsdFtrXVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IEcuYmF0Y2hMRU10b1UocmVzdWx0W2tdWzBdKTtcbiAgICAgICAgICAgICAgICBjc0hhc2hlci51cGRhdGUoYnVmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcFByb21pc2VzID0gW107XG5cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXBvc2VBbmRXcml0ZVBvaW50c1RocmVhZChncm91cE5hbWUsIGFyciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0dpbiA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBzR21pZCA9IEcuRi5uOCozO1xuICAgICAgICBjb25zdCBzR291dCA9IEcuRi5uOCoyO1xuICAgICAgICBsZXQgZm5FeHAsIGZuTXVsdGlFeHAsIGZuQmF0Y2hUb0FmZmluZSwgZm5aZXJvO1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgZm5FeHAgPSBcImcxbV90aW1lc1NjYWxhckFmZmluZVwiO1xuICAgICAgICAgICAgZm5NdWx0aUV4cCA9IFwiZzFtX211bHRpZXhwQWZmaW5lXCI7XG4gICAgICAgICAgICBmbkJhdGNoVG9BZmZpbmUgPSBcImcxbV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICBmblplcm8gPSBcImcxbV96ZXJvXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgZm5FeHAgPSBcImcybV90aW1lc1NjYWxhckFmZmluZVwiO1xuICAgICAgICAgICAgZm5NdWx0aUV4cCA9IFwiZzJtX211bHRpZXhwQWZmaW5lXCI7XG4gICAgICAgICAgICBmbkJhdGNoVG9BZmZpbmUgPSBcImcybV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICBmblplcm8gPSBcImcybV96ZXJvXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY2MgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIGFjYyArPSBhcnJbaV0gPyBhcnJbaV0ubGVuZ3RoIDogMDtcbiAgICAgICAgbGV0IGJCYXNlcywgYlNjYWxhcnM7XG4gICAgICAgIGlmIChhY2M+IDI8PDE0KSB7XG4gICAgICAgICAgICBiQmFzZXMgPSBuZXcgQmlnQnVmZmVyKGFjYypzR2luKTtcbiAgICAgICAgICAgIGJTY2FsYXJzID0gbmV3IEJpZ0J1ZmZlcihhY2MqY3VydmUuRnIubjgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYkJhc2VzID0gbmV3IFVpbnQ4QXJyYXkoYWNjKnNHaW4pO1xuICAgICAgICAgICAgYlNjYWxhcnMgPSBuZXcgVWludDhBcnJheShhY2MqY3VydmUuRnIubjgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwQiA9MDtcbiAgICAgICAgbGV0IHBTID0wO1xuXG4gICAgICAgIGNvbnN0IHNCdWZmcyA9IFtcbiAgICAgICAgICAgIHNUYXVHMSxcbiAgICAgICAgICAgIHNUYXVHMixcbiAgICAgICAgICAgIHNBbHBoYVRhdUcxLFxuICAgICAgICAgICAgc0JldGFUYXVHMVxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGJPbmUgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGN1cnZlLkZyLnRvUnByTEUoYk9uZSwgMCwgY3VydmUuRnIuZSgxKSk7XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghYXJyW2ldKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxhcnJbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihqKSYmKGolMTAwMDAgPT0gMCkpICBsb2dnZXIuZGVidWcoYENvbmZpZ3VyaW5nIGJpZyBhcnJheSAke3NlY3Rpb25OYW1lfTogJHtqfS8ke2FycltpXS5sZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgYkJhc2VzLnNldChcbiAgICAgICAgICAgICAgICAgICAgc0J1ZmZzW2FycltpXVtqXVswXV0uc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMV0gKyBzR2luXG4gICAgICAgICAgICAgICAgICAgICksIG9mZnNldCpzR2luXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldW2pdWzJdPj0wKSB7XG4gICAgICAgICAgICAgICAgICAgIGJTY2FsYXJzLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIHNSMWNzLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXVtqXVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMl0gKyBjdXJ2ZS5Gci5uOFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCpjdXJ2ZS5Gci5uOFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJTY2FsYXJzLnNldChiT25lLCBvZmZzZXQqY3VydmUuRnIubjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJCYXNlc30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBiU2NhbGFyc30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IGFyci5sZW5ndGgqc0dtaWR9KTtcbiAgICAgICAgICAgIHBCID0gMDtcbiAgICAgICAgICAgIHBTID0gMDtcbiAgICAgICAgICAgIGxldCBwRCA9MDtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycltpXSkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5aZXJvLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogcER9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICAgICAgcEQgKz0gc0dtaWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkV4cCwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwLCBvZmZzZXQ6IHBCfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogcFN9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogY3VydmUuRnIubjh9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMiwgb2Zmc2V0OiBwRH1cbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk11bHRpRXhwLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDAsIG9mZnNldDogcEJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMSwgb2Zmc2V0OiBwU30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBjdXJ2ZS5Gci5uOH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBhcnJbaV0ubGVuZ3RofSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogcER9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcEIgKz0gc0dpbiphcnJbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBTICs9IGN1cnZlLkZyLm44KmFycltpXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcEQgKz0gc0dtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5CYXRjaFRvQWZmaW5lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBhcnIubGVuZ3RofSxcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBhcnIubGVuZ3RoKnNHb3V0fSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJCYXNlcywgYlNjYWxhcnMsIGxvZ2dlciwgc2VjdGlvbk5hbWUpO1xuICAgICAgICAgICAgcmVzID0gWyBHLnRvQWZmaW5lKHJlcykgXTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhc2hIUG9pbnRzKCkge1xuICAgICAgICBjb25zdCBDSFVOS19TSVpFID0gMTw8MTQ7XG5cbiAgICAgICAgaGFzaFUzMihkb21haW5TaXplLTEpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxkb21haW5TaXplLTE7IGkrPSBDSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSAgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nSFBvaW50czogJHtpfS8ke2RvbWFpblNpemV9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oZG9tYWluU2l6ZS0xLCBDSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGF3YWl0IGhhc2hIUG9pbnRzQ2h1bmsoaSwgbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoSFBvaW50c0NodW5rKG9mZnNldCwgblBvaW50cykge1xuICAgICAgICBjb25zdCBidWZmMSA9IGF3YWl0IGZkUFRhdS5yZWFkKG5Qb2ludHMgKnNHMSwgc2VjdGlvbnNQVGF1WzJdWzBdLnAgKyAob2Zmc2V0ICsgZG9tYWluU2l6ZSkqc0cxKTtcbiAgICAgICAgY29uc3QgYnVmZjIgPSBhd2FpdCBmZFBUYXUucmVhZChuUG9pbnRzICpzRzEsIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgb2Zmc2V0KnNHMSk7XG4gICAgICAgIGNvbnN0IGNvbmN1cnJlbmN5PSBjdXJ2ZS50bS5jb25jdXJyZW5jeTtcbiAgICAgICAgY29uc3QgblBvaW50c1BlclRocmVhZCA9IE1hdGguZmxvb3IoblBvaW50cyAvIGNvbmN1cnJlbmN5KTtcbiAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzUGVyVGhyZWFkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqblBvaW50c1BlclRocmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuPT0wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3Qgc3ViQnVmZjEgPSBidWZmMS5zbGljZShpKm5Qb2ludHNQZXJUaHJlYWQqc0cxLCAoaSpuUG9pbnRzUGVyVGhyZWFkK24pKnNHMSk7XG4gICAgICAgICAgICBjb25zdCBzdWJCdWZmMiA9IGJ1ZmYyLnNsaWNlKGkqblBvaW50c1BlclRocmVhZCpzRzEsIChpKm5Qb2ludHNQZXJUaHJlYWQrbikqc0cxKTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChoYXNoSFBvaW50c1RocmVhZChzdWJCdWZmMSwgc3ViQnVmZjIpKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3NIYXNoZXIudXBkYXRlKHJlc3VsdFtpXVswXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoSFBvaW50c1RocmVhZChidWZmMSwgYnVmZjIpIHtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGgvc0cxO1xuICAgICAgICBjb25zdCBzR21pZCA9IGN1cnZlLkcxLkYubjgqMztcbiAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJ1ZmYxfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYnVmZjJ9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IG5Qb2ludHMqc0dtaWR9KTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgdGFzay5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbWQ6IFwiQ0FMTFwiLFxuICAgICAgICAgICAgICAgIGZuTmFtZTogXCJnMW1fc3ViQWZmaW5lXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDAsIG9mZnNldDogaSpzRzF9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAxLCBvZmZzZXQ6IGkqc0cxfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMiwgb2Zmc2V0OiBpKnNHbWlkfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJnMW1fYmF0Y2hUb0FmZmluZVwiLCBwYXJhbXM6IFtcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAge3ZhbDogblBvaW50c30sXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgXX0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJnMW1fYmF0Y2hMRU10b1VcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIHt2YWw6IG5Qb2ludHN9LFxuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgIF19KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAyLCBsZW46IG5Qb2ludHMqc0cxfSk7XG5cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUudG0ucXVldWVBY3Rpb24odGFzayk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNoVTMyKG4pIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0LCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICBidWZmVi5zZXRVaW50MzIoMCwgbiwgZmFsc2UpO1xuICAgICAgICBjc0hhc2hlci51cGRhdGUoYnVmZik7XG4gICAgfVxuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBoYXNlMmV4cG9ydE1QQ1BhcmFtcyh6a2V5TmFtZSwgbXBjcGFyYW1zTmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB7ZmQ6IGZkWktleSwgc2VjdGlvbnM6IHNlY3Rpb25zWktleX0gPSBhd2FpdCByZWFkQmluRmlsZSh6a2V5TmFtZSwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXkgPSBhd2FpdCByZWFkSGVhZGVyJDEoZmRaS2V5LCBzZWN0aW9uc1pLZXkpO1xuICAgIGlmICh6a2V5LnByb3RvY29sICE9IFwiZ3JvdGgxNlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbVEoemtleS5xKTtcbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuXG4gICAgY29uc3QgbXBjUGFyYW1zID0gYXdhaXQgcmVhZE1QQ1BhcmFtcyhmZFpLZXksIGN1cnZlLCBzZWN0aW9uc1pLZXkpO1xuXG4gICAgY29uc3QgZmRNUENQYXJhbXMgPSBhd2FpdCBjcmVhdGVPdmVycmlkZShtcGNwYXJhbXNOYW1lKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFZlcmlmaWNhdGlvbiBLZXkgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGF3YWl0IHdyaXRlRzEoemtleS52a19hbHBoYV8xKTtcbiAgICBhd2FpdCB3cml0ZUcxKHprZXkudmtfYmV0YV8xKTtcbiAgICBhd2FpdCB3cml0ZUcyKHprZXkudmtfYmV0YV8yKTtcbiAgICBhd2FpdCB3cml0ZUcyKHprZXkudmtfZ2FtbWFfMik7XG4gICAgYXdhaXQgd3JpdGVHMSh6a2V5LnZrX2RlbHRhXzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoemtleS52a19kZWx0YV8yKTtcblxuICAgIC8vIElDXG4gICAgbGV0IGJ1ZmZCYXNlc0lDO1xuICAgIGJ1ZmZCYXNlc0lDID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDMpO1xuICAgIGJ1ZmZCYXNlc0lDID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzSUMpO1xuXG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzFcIiwgYnVmZkJhc2VzSUMpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gaCBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgY29uc3QgYnVmZkJhc2VzSF9Mb2RkID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDkpO1xuXG4gICAgbGV0IGJ1ZmZCYXNlc0hfVGF1O1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuZmZ0KGJ1ZmZCYXNlc0hfTG9kZCwgXCJhZmZpbmVcIiwgXCJqYWNvYmlhblwiLCBsb2dnZXIpO1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hBcHBseUtleShidWZmQmFzZXNIX1RhdSwgY3VydmUuRnIubmVnKGN1cnZlLkZyLmUoMikpLCBjdXJ2ZS5Gci53W3prZXkucG93ZXIrMV0sIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyKTtcblxuICAgIC8vIFJlbW92ZSBsYXN0IGVsZW1lbnQuICAoVGhlIGRlZ3JlZSBvZiBIIHdpbGwgYmUgYWx3YXlzIG0tMilcbiAgICBidWZmQmFzZXNIX1RhdSA9IGJ1ZmZCYXNlc0hfVGF1LnNsaWNlKDAsIGJ1ZmZCYXNlc0hfVGF1LmJ5dGVMZW5ndGggLSBzRzEpO1xuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzSF9UYXUpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0hfVGF1KTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEwgc2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGxldCBidWZmQmFzZXNDO1xuICAgIGJ1ZmZCYXNlc0MgPSBhd2FpdCByZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgOCk7XG4gICAgYnVmZkJhc2VzQyA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJ1ZmZCYXNlc0MpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0MpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQSBTZWN0aW9uIChDIHNlY3Rpb24pXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgbGV0IGJ1ZmZCYXNlc0E7XG4gICAgYnVmZkJhc2VzQSA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA1KTtcbiAgICBidWZmQmFzZXNBID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzQSk7XG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzFcIiwgYnVmZkJhc2VzQSk7XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBCMSBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgbGV0IGJ1ZmZCYXNlc0IxO1xuICAgIGJ1ZmZCYXNlc0IxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDYpO1xuICAgIGJ1ZmZCYXNlc0IxID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hMRU10b1UoYnVmZkJhc2VzQjEpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0IxKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEIyIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBsZXQgYnVmZkJhc2VzQjI7XG4gICAgYnVmZkJhc2VzQjIgPSBhd2FpdCByZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNyk7XG4gICAgYnVmZkJhc2VzQjIgPSBhd2FpdCBjdXJ2ZS5HMi5iYXRjaExFTXRvVShidWZmQmFzZXNCMik7XG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzJcIiwgYnVmZkJhc2VzQjIpO1xuXG4gICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgYXdhaXQgd3JpdGVVMzIobXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV07XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YUFmdGVyKTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhLmcxX3MpO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGEuZzFfc3gpO1xuICAgICAgICBhd2FpdCB3cml0ZUcyKGMuZGVsdGEuZzJfc3B4KTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYy50cmFuc2NyaXB0KTtcbiAgICB9XG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE1QQ1BhcmFtcy5jbG9zZSgpO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMShQKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgICAgICBjdXJ2ZS5HMS50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBQKTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYnVmZik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMihQKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRzIpO1xuICAgICAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBQKTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYnVmZik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVQb2ludEFycmF5KGdyb3VwTmFtZSwgYnVmZikge1xuICAgICAgICBsZXQgc0c7XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBzRyA9IHNHMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNHID0gc0cyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZlNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgYnVmZlNpemVWID0gbmV3IERhdGFWaWV3KGJ1ZmZTaXplLmJ1ZmZlciwgYnVmZlNpemUuYnl0ZU9mZnNldCwgYnVmZlNpemUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGJ1ZmZTaXplVi5zZXRVaW50MzIoMCwgYnVmZi5ieXRlTGVuZ3RoIC8gc0csIGZhbHNlKTtcblxuICAgICAgICBhd2FpdCBmZE1QQ1BhcmFtcy53cml0ZShidWZmU2l6ZSk7XG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlVTMyKG4pIHtcbiAgICAgICAgY29uc3QgYnVmZlNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgYnVmZlNpemVWID0gbmV3IERhdGFWaWV3KGJ1ZmZTaXplLmJ1ZmZlciwgYnVmZlNpemUuYnl0ZU9mZnNldCwgYnVmZlNpemUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGJ1ZmZTaXplVi5zZXRVaW50MzIoMCwgbiwgZmFsc2UpO1xuXG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmZTaXplKTtcbiAgICB9XG5cblxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIHBoYXNlMmltcG9ydE1QQ1BhcmFtcyh6a2V5TmFtZU9sZCwgbXBjcGFyYW1zTmFtZSwgemtleU5hbWVOZXcsIG5hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZFpLZXlPbGQsIHNlY3Rpb25zOiBzZWN0aW9uc1pLZXlPbGR9ID0gYXdhaXQgcmVhZEJpbkZpbGUoemtleU5hbWVPbGQsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5SGVhZGVyID0gYXdhaXQgcmVhZEhlYWRlciQxKGZkWktleU9sZCwgc2VjdGlvbnNaS2V5T2xkLCBmYWxzZSk7XG4gICAgaWYgKHprZXlIZWFkZXIucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUSh6a2V5SGVhZGVyLnEpO1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5HMi5GLm44KjI7XG5cbiAgICBjb25zdCBvbGRNUENQYXJhbXMgPSBhd2FpdCByZWFkTVBDUGFyYW1zKGZkWktleU9sZCwgY3VydmUsIHNlY3Rpb25zWktleU9sZCk7XG4gICAgY29uc3QgbmV3TVBDUGFyYW1zID0ge307XG5cbiAgICBjb25zdCBmZE1QQ1BhcmFtcyA9IGF3YWl0IHJlYWRFeGlzdGluZyhtcGNwYXJhbXNOYW1lKTtcblxuICAgIGZkTVBDUGFyYW1zLnBvcyA9XG4gICAgICAgIHNHMSozICsgc0cyKjMgKyAgICAgICAgICAgICAgICAgICAgIC8vIHZLZXlcbiAgICAgICAgOCArIHNHMSp6a2V5SGVhZGVyLm5WYXJzICsgICAgICAgICAgICAgIC8vIElDICsgQ1xuICAgICAgICA0ICsgc0cxKih6a2V5SGVhZGVyLmRvbWFpblNpemUtMSkgKyAgICAgLy8gSFxuICAgICAgICA0ICsgc0cxKnprZXlIZWFkZXIublZhcnMgKyAgICAgICAgICAgICAgLy8gQVxuICAgICAgICA0ICsgc0cxKnprZXlIZWFkZXIublZhcnMgKyAgICAgICAgICAgICAgLy8gQjFcbiAgICAgICAgNCArIHNHMip6a2V5SGVhZGVyLm5WYXJzOyAgICAgICAgICAgICAgIC8vIEIyXG5cbiAgICAvLyBjc0hhc2hcbiAgICBuZXdNUENQYXJhbXMuY3NIYXNoID0gIGF3YWl0IGZkTVBDUGFyYW1zLnJlYWQoNjQpO1xuXG4gICAgY29uc3QgbkNvbnRyaWJ1dGlvbnMgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkVUJFMzIoKTtcbiAgICBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxuQ29udHJpYnV0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSB7IGRlbHRhOnt9IH07XG4gICAgICAgIGMuZGVsdGFBZnRlciA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMuZGVsdGEuZzFfcyA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMuZGVsdGEuZzFfc3ggPSBhd2FpdCByZWFkRzEoZmRNUENQYXJhbXMpO1xuICAgICAgICBjLmRlbHRhLmcyX3NweCA9IGF3YWl0IHJlYWRHMihmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMudHJhbnNjcmlwdCA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWQoNjQpO1xuICAgICAgICBpZiAoaTxvbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGMudHlwZSA9IG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLnR5cGU7XG4gICAgICAgICAgICBpZiAoYy50eXBlPT0xKSB7XG4gICAgICAgICAgICAgICAgYy5iZWFjb25IYXNoID0gb2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0uYmVhY29uSGFzaDtcbiAgICAgICAgICAgICAgICBjLm51bUl0ZXJhdGlvbnNFeHAgPSBvbGRNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXS5udW1JdGVyYXRpb25zRXhwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjLm5hbWUgPSBvbGRNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNoSXNFcXVhbChuZXdNUENQYXJhbXMuY3NIYXNoLCBvbGRNUENQYXJhbXMuY3NIYXNoKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJIYXNoIG9mIHRoZSBvcmlnaW5hbCBjaXJjdWl0IGRvZXMgbm90IG1hdGNoIHdpdGggdGhlIE1QQyBvbmVcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoID4gbmV3TVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlRoZSBpbXBvZXJ0ZWQgZmlsZSBkb2VzIG5vdCBpbmNsdWRlIG5ldyBjb250cmlidXRpb25zXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaT0wOyBpPG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghY29udHJpYnV0aW9uSXNFcXVhbChvbGRNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXSwgbmV3TVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0pKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYFByZXZpb3VzIGNvbnRyaWJ1dGlvbiAke2l9IGRvZXMgbm90IG1hdGNoYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIFNldCB0aGUgc2FtZSBuYW1lIHRvIGFsbCBuZXcgY29udHJpYnV0aW9uc1xuICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGZvciAobGV0IGk9b2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpPG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXS5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZkWktleU5ldyA9IGF3YWl0IGNyZWF0ZUJpbkZpbGUoemtleU5hbWVOZXcsIFwiemtleVwiLCAxLCAxMCk7XG4gICAgZmRNUENQYXJhbXMucG9zID0gMDtcblxuICAgIC8vIEhlYWRlclxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzE7ICAvLyBpZ25vcmUgYWxwaGExIChrZWVwIG9yaWdpbmFsKVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzE7ICAvLyBpZ25vcmUgYmV0YTFcbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cyOyAgLy8gaWdub3JlIGJldGEyXG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMjsgIC8vIGlnbm9yZSBnYW1tYTJcbiAgICB6a2V5SGVhZGVyLnZrX2RlbHRhXzEgPSBhd2FpdCByZWFkRzEoZmRNUENQYXJhbXMpO1xuICAgIHprZXlIZWFkZXIudmtfZGVsdGFfMiA9IGF3YWl0IHJlYWRHMihmZE1QQ1BhcmFtcyk7XG4gICAgYXdhaXQgd3JpdGVIZWFkZXIoZmRaS2V5TmV3LCB6a2V5SGVhZGVyKTtcblxuICAgIC8vIElDIChLZWVwIG9yaWdpbmFsKVxuICAgIGNvbnN0IG5JQyA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuSUMgIT0gemtleUhlYWRlci5uUHVibGljICsxKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBJQ1wiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cxKih6a2V5SGVhZGVyLm5QdWJsaWMrMSk7XG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgMyk7XG5cbiAgICAvLyBDb2VmZnMgKEtlZXAgb3JpZ2luYWwpXG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgNCk7XG5cbiAgICAvLyBIIFNlY3Rpb25cbiAgICBjb25zdCBuSCA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuSCAhPSB6a2V5SGVhZGVyLmRvbWFpblNpemUtMSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gSFwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYnVmZkg7XG4gICAgY29uc3QgYnVmZlRhdVUgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkKHNHMSooemtleUhlYWRlci5kb21haW5TaXplLTEpKTtcbiAgICBjb25zdCBidWZmVGF1TEVNID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hVdG9MRU0oYnVmZlRhdVUpO1xuICAgIGJ1ZmZIID0gbmV3IFVpbnQ4QXJyYXkoemtleUhlYWRlci5kb21haW5TaXplKnNHMSk7XG4gICAgYnVmZkguc2V0KGJ1ZmZUYXVMRU0pOyAgIC8vIExldCB0aGUgbGFzdCBvbmUgdG8gemVyby5cbiAgICBjdXJ2ZS5HMS50b1JwckxFTShidWZmSCwgc0cxKih6a2V5SGVhZGVyLmRvbWFpblNpemUtMSksIGN1cnZlLkcxLnplcm9BZmZpbmUpO1xuICAgIGNvbnN0IG4ySW52ID0gY3VydmUuRnIubmVnKGN1cnZlLkZyLmludihjdXJ2ZS5Gci5lKDIpKSk7XG4gICAgY29uc3Qgd0ludiA9IGN1cnZlLkZyLmludihjdXJ2ZS5Gci53W3prZXlIZWFkZXIucG93ZXIrMV0pO1xuICAgIGJ1ZmZIID0gYXdhaXQgY3VydmUuRzEuYmF0Y2hBcHBseUtleShidWZmSCwgbjJJbnYsIHdJbnYsIFwiYWZmaW5lXCIsIFwiamFjb2JpYW5cIiwgbG9nZ2VyKTtcbiAgICBidWZmSCA9IGF3YWl0IGN1cnZlLkcxLmlmZnQoYnVmZkgsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyKTtcbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXlOZXcsIDkpO1xuICAgIGF3YWl0IGZkWktleU5ldy53cml0ZShidWZmSCk7XG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleU5ldyk7XG5cbiAgICAvLyBDIFNlY3Rpb24gKEwgc2VjdGlvbilcbiAgICBjb25zdCBuTCA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuTCAhPSAoemtleUhlYWRlci5uVmFycy16a2V5SGVhZGVyLm5QdWJsaWMtMSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExcIik7XG4gICAgICAgIGF3YWl0IGZkWktleU5ldy5kaXNjYXJkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGJ1ZmZMO1xuICAgIGJ1ZmZMID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZChzRzEqKHprZXlIZWFkZXIublZhcnMtemtleUhlYWRlci5uUHVibGljLTEpKTtcbiAgICBidWZmTCA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoVXRvTEVNKGJ1ZmZMKTtcbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXlOZXcsIDgpO1xuICAgIGF3YWl0IGZkWktleU5ldy53cml0ZShidWZmTCk7XG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleU5ldyk7XG5cbiAgICAvLyBBIFNlY3Rpb25cbiAgICBjb25zdCBuQSA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuQSAhPSB6a2V5SGVhZGVyLm5WYXJzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBBXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXlOZXcuZGlzY2FyZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzEqKHprZXlIZWFkZXIublZhcnMpO1xuICAgIGF3YWl0IGNvcHlTZWN0aW9uKGZkWktleU9sZCwgc2VjdGlvbnNaS2V5T2xkLCBmZFpLZXlOZXcsIDUpO1xuXG4gICAgLy8gQjEgU2VjdGlvblxuICAgIGNvbnN0IG5CMSA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuQjEgIT0gemtleUhlYWRlci5uVmFycykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gQjFcIik7XG4gICAgICAgIGF3YWl0IGZkWktleU5ldy5kaXNjYXJkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMSooemtleUhlYWRlci5uVmFycyk7XG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRaS2V5T2xkLCBzZWN0aW9uc1pLZXlPbGQsIGZkWktleU5ldywgNik7XG5cbiAgICAvLyBCMiBTZWN0aW9uXG4gICAgY29uc3QgbkIyID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5CMiAhPSB6a2V5SGVhZGVyLm5WYXJzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBCMlwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cyKih6a2V5SGVhZGVyLm5WYXJzKTtcbiAgICBhd2FpdCBjb3B5U2VjdGlvbihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmRaS2V5TmV3LCA3KTtcblxuICAgIGF3YWl0IHdyaXRlTVBDUGFyYW1zKGZkWktleU5ldywgY3VydmUsIG5ld01QQ1BhcmFtcyk7XG5cbiAgICBhd2FpdCBmZE1QQ1BhcmFtcy5jbG9zZSgpO1xuICAgIGF3YWl0IGZkWktleU5ldy5jbG9zZSgpO1xuICAgIGF3YWl0IGZkWktleU9sZC5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzEoZmQpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlLkcxLmZyb21ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcyKGZkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkcyLkYubjgqMik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5HMi5mcm9tUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY29udHJpYnV0aW9uSXNFcXVhbChjMSwgYzIpIHtcbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjMS5kZWx0YUFmdGVyICAgLCBjMi5kZWx0YUFmdGVyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGMxLmRlbHRhLmcxX3MgICAsIGMyLmRlbHRhLmcxX3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoYzEuZGVsdGEuZzFfc3ggICwgYzIuZGVsdGEuZzFfc3gpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghY3VydmUuRzIuZXEoYzEuZGVsdGEuZzJfc3B4ICwgYzIuZGVsdGEuZzJfc3B4KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWhhc2hJc0VxdWFsKGMxLnRyYW5zY3JpcHQsIGMyLnRyYW5zY3JpcHQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCBzYW1lUmF0aW8gPSBzYW1lUmF0aW8kMjtcblxuXG5cbmFzeW5jIGZ1bmN0aW9uIHBoYXNlMnZlcmlmeUZyb21Jbml0KGluaXRGaWxlTmFtZSwgcFRhdUZpbGVOYW1lLCB6a2V5RmlsZU5hbWUsIGxvZ2dlcikge1xuXG4gICAgbGV0IHNyO1xuICAgIGNvbnN0IHtmZCwgc2VjdGlvbnN9ID0gYXdhaXQgcmVhZEJpbkZpbGUoemtleUZpbGVOYW1lLCBcInprZXlcIiwgMik7XG4gICAgY29uc3QgemtleSA9IGF3YWl0IHJlYWRIZWFkZXIkMShmZCwgc2VjdGlvbnMsIGZhbHNlKTtcbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21RKHprZXkucSk7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuXG4gICAgY29uc3QgbXBjUGFyYW1zID0gYXdhaXQgcmVhZE1QQ1BhcmFtcyhmZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGFjY3VtdWxhdGVkSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7XG4gICAgYWNjdW11bGF0ZWRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGxldCBjdXJEZWx0YSA9IGN1cnZlLkcxLmc7XG4gICAgZm9yIChsZXQgaT0wOyBpPG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXTtcbiAgICAgICAgY29uc3Qgb3VySGFzaGVyID0gY2xvbmVIYXNoZXIoYWNjdW11bGF0ZWRIYXNoZXIpO1xuXG4gICAgICAgIGhhc2hHMShvdXJIYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcxX3MpO1xuICAgICAgICBoYXNoRzEob3VySGFzaGVyLCBjdXJ2ZSwgYy5kZWx0YS5nMV9zeCk7XG5cbiAgICAgICAgaWYgKCFoYXNoSXNFcXVhbChvdXJIYXNoZXIuZGlnZXN0KCksIGMudHJhbnNjcmlwdCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJTlZBTElEKCR7aX0pOiBJbmNvbnNpc3RlbnQgdHJhbnNjcmlwdCBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlbHRhX2cyX3NwID0gaGFzaFRvRzIoY3VydmUsIGMudHJhbnNjcmlwdCk7XG5cbiAgICAgICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIGMuZGVsdGEuZzFfcywgYy5kZWx0YS5nMV9zeCwgZGVsdGFfZzJfc3AsIGMuZGVsdGEuZzJfc3B4KTtcbiAgICAgICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgSU5WQUxJRCgke2l9KTogcHVibGljIGtleSBHMSBhbmQgRzIgZG8gbm90IGhhdmUgdGhlIHNhbWUgcmF0aW9uIGApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIGN1ckRlbHRhLCBjLmRlbHRhQWZ0ZXIsIGRlbHRhX2cyX3NwLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYElOVkFMSUQoJHtpfSk6IGRlbHRhQWZ0ZXIgZG9lcyBub3QgZmlsbG93IHRoZSBwdWJsaWMga2V5IGApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMudHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBybmcgPSBhd2FpdCBybmdGcm9tQmVhY29uUGFyYW1zKGMuYmVhY29uSGFzaCwgYy5udW1JdGVyYXRpb25zRXhwKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkX3BydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkX2cxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRfZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGV4cGVjdGVkX2cxX3MsIGV4cGVjdGVkX3BydktleSkpO1xuICAgICAgICAgICAgaWYgKGN1cnZlLkcxLmVxKGV4cGVjdGVkX2cxX3MsIGMuZGVsdGEuZzFfcykgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSU5WQUxJRCgke2l9KTogS2V5IG9mIHRoZSBiZWFjb24gZG9lcyBub3QgbWF0Y2guIGcxX3MgYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnZlLkcxLmVxKGV4cGVjdGVkX2cxX3N4LCBjLmRlbHRhLmcxX3N4KSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJTlZBTElEKCR7aX0pOiBLZXkgb2YgdGhlIGJlYWNvbiBkb2VzIG5vdCBtYXRjaC4gZzFfc3ggYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaGFzaFB1YktleShhY2N1bXVsYXRlZEhhc2hlciwgY3VydmUsIGMpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgICAgICBoYXNoUHViS2V5KGNvbnRyaWJ1dGlvbkhhc2hlciwgY3VydmUsIGMpO1xuXG4gICAgICAgIGMuY29udHJpYnV0aW9uSGFzaCA9IGNvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgICAgICBjdXJEZWx0YSA9IGMuZGVsdGFBZnRlcjtcbiAgICB9XG5cblxuICAgIGNvbnN0IHtmZDogZmRJbml0LCBzZWN0aW9uczogc2VjdGlvbnNJbml0fSA9IGF3YWl0IHJlYWRCaW5GaWxlKGluaXRGaWxlTmFtZSwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXlJbml0ID0gYXdhaXQgcmVhZEhlYWRlciQxKGZkSW5pdCwgc2VjdGlvbnNJbml0LCBmYWxzZSk7XG5cbiAgICBpZiAoemtleUluaXQucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleWluaXQgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cbiAgICBpZiAoICAoIVNjYWxhci5lcSh6a2V5SW5pdC5xLCB6a2V5LnEpKVxuICAgICAgICB8fCghU2NhbGFyLmVxKHprZXlJbml0LnIsIHprZXkucikpXG4gICAgICAgIHx8KHprZXlJbml0Lm44cSAhPSB6a2V5Lm44cSlcbiAgICAgICAgfHwoemtleUluaXQubjhyICE9IHprZXkubjhyKSlcbiAgICB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBEaWZmZXJlbnQgY3VydmVzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCAgKHprZXlJbml0Lm5WYXJzICE9IHprZXkublZhcnMpXG4gICAgICAgIHx8KHprZXlJbml0Lm5QdWJsaWMgIT0gIHprZXkublB1YmxpYylcbiAgICAgICAgfHwoemtleUluaXQuZG9tYWluU2l6ZSAhPSB6a2V5LmRvbWFpblNpemUpKVxuICAgIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIERpZmZlcmVudCBjaXJjdWl0IHBhcmFtZXRlcnNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWN1cnZlLkcxLmVxKHprZXkudmtfYWxwaGFfMSwgemtleUluaXQudmtfYWxwaGFfMSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgYWxwaGExXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoemtleS52a19iZXRhXzEsIHprZXlJbml0LnZrX2JldGFfMSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgYmV0YTFcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMi5lcSh6a2V5LnZrX2JldGFfMiwgemtleUluaXQudmtfYmV0YV8yKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBiZXRhMlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKHprZXkudmtfZ2FtbWFfMiwgemtleUluaXQudmtfZ2FtbWFfMikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZ2FtbWEyXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoemtleS52a19kZWx0YV8xLCBjdXJEZWx0YSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZGVsdGExXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJ2ZS5HMS5nLCBjdXJEZWx0YSwgY3VydmUuRzIuZywgemtleS52a19kZWx0YV8yKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZGVsdGEyXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbXBjUGFyYW1zSW5pdCA9IGF3YWl0IHJlYWRNUENQYXJhbXMoZmRJbml0LCBjdXJ2ZSwgc2VjdGlvbnNJbml0KTtcbiAgICBpZiAoIWhhc2hJc0VxdWFsKG1wY1BhcmFtcy5jc0hhc2gsIG1wY1BhcmFtc0luaXQuY3NIYXNoKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgQ2lyY3VpdCBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHNpemVzIG9mIHNlY3Rpb25zXG4gICAgaWYgKHNlY3Rpb25zWzhdWzBdLnNpemUgIT0gc0cxKih6a2V5Lm5WYXJzLXprZXkublB1YmxpYy0xKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBMIHNlY3Rpb24gc2l6ZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzZWN0aW9uc1s5XVswXS5zaXplICE9IHNHMSooemtleS5kb21haW5TaXplKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBIIHNlY3Rpb24gc2l6ZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBzcztcbiAgICBzcyA9IGF3YWl0IHNlY3Rpb25Jc0VxdWFsKGZkLCBzZWN0aW9ucywgZmRJbml0LCBzZWN0aW9uc0luaXQsIDMpO1xuICAgIGlmICghc3MpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIElDIHNlY3Rpb24gaXMgbm90IGlkZW50aWNhbFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNzID0gYXdhaXQgc2VjdGlvbklzRXF1YWwoZmQsIHNlY3Rpb25zLCBmZEluaXQsIHNlY3Rpb25zSW5pdCwgNCk7XG4gICAgaWYgKCFzcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJDb2VmZnMgc2VjdGlvbiBpcyBub3QgaWRlbnRpY2FsXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3MgPSBhd2FpdCBzZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA1KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkEgc2VjdGlvbiBpcyBub3QgaWRlbnRpY2FsXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3MgPSBhd2FpdCBzZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA2KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkIxIHNlY3Rpb24gaXMgbm90IGlkZW50aWNhbFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNzID0gYXdhaXQgc2VjdGlvbklzRXF1YWwoZmQsIHNlY3Rpb25zLCBmZEluaXQsIHNlY3Rpb25zSW5pdCwgNyk7XG4gICAgaWYgKCFzcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJCMiBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBMXG4gICAgc3IgPSBhd2FpdCBzZWN0aW9uSGFzU2FtZVJhdGlvKFwiRzFcIiwgZmRJbml0LCBzZWN0aW9uc0luaXQsIGZkLCBzZWN0aW9ucywgOCwgemtleS52a19kZWx0YV8yLCB6a2V5SW5pdC52a19kZWx0YV8yLCBcIkwgc2VjdGlvblwiKTtcbiAgICBpZiAoc3IhPT10cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkwgc2VjdGlvbiBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIEhcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpb0goKTtcbiAgICBpZiAoc3IhPT10cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkggc2VjdGlvbiBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2gobXBjUGFyYW1zLmNzSGFzaCwgXCJDaXJjdWl0IEhhc2g6IFwiKSk7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkSW5pdC5jbG9zZSgpO1xuXG4gICAgZm9yIChsZXQgaT1tcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGMgPSBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGMuY29udHJpYnV0aW9uSGFzaCwgYGNvbnRyaWJ1dGlvbiAjJHtpKzF9ICR7Yy5uYW1lID8gYy5uYW1lIDogXCJcIn06YCkpO1xuICAgICAgICBpZiAoYy50eXBlID09IDEpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGBCZWFjb24gZ2VuZXJhdG9yOiAke2J5dGVBcnJheTJoZXgoYy5iZWFjb25IYXNoKX1gKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGBCZWFjb24gaXRlcmF0aW9ucyBFeHA6ICR7Yy5udW1JdGVyYXRpb25zRXhwfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiWktleSBPayFcIik7XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gc2VjdGlvbkhhc1NhbWVSYXRpbyhncm91cE5hbWUsIGZkMSwgc2VjdGlvbnMxLCBmZDIsIHNlY3Rpb25zMiwgaWRTZWN0aW9uLCBnMnNwLCBnMnNweCwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxPDwyMDtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQxLCBzZWN0aW9uczEsIGlkU2VjdGlvbik7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQyLCBzZWN0aW9uczIsIGlkU2VjdGlvbik7XG5cbiAgICAgICAgbGV0IFIxID0gRy56ZXJvO1xuICAgICAgICBsZXQgUjIgPSBHLnplcm87XG5cbiAgICAgICAgY29uc3QgblBvaW50cyA9IHNlY3Rpb25zMVtpZFNlY3Rpb25dWzBdLnNpemUgLyBzRztcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSArPSBNQVhfQ0hVTktfU0laRSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBTYW1lIHJhdGlvIGNoZWNrICR7c2VjdGlvbk5hbWV9OiAgJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzMSA9IGF3YWl0IGZkMS5yZWFkKG4qc0cpO1xuICAgICAgICAgICAgY29uc3QgYmFzZXMyID0gYXdhaXQgZmQyLnJlYWQobipzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNjYWxhcnMgPSBnZXRSYW5kb21CeXRlcyg0Km4pO1xuXG4gICAgICAgICAgICBjb25zdCByMSA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYmFzZXMxLCBzY2FsYXJzKTtcbiAgICAgICAgICAgIGNvbnN0IHIyID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiYXNlczIsIHNjYWxhcnMpO1xuXG4gICAgICAgICAgICBSMSA9IEcuYWRkKFIxLCByMSk7XG4gICAgICAgICAgICBSMiA9IEcuYWRkKFIyLCByMik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmQxKTtcbiAgICAgICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmQyKTtcblxuICAgICAgICBpZiAoblBvaW50cyA9PSAwKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgUjEsIFIyLCBnMnNwLCBnMnNweCk7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHNhbWVSYXRpb0goKSB7XG4gICAgICAgIGNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTw8MjA7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZS5HMTtcbiAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcblxuICAgICAgICBjb25zdCB7ZmQ6IGZkUFRhdSwgc2VjdGlvbnM6IHNlY3Rpb25zUFRhdX0gPSBhd2FpdCByZWFkQmluRmlsZShwVGF1RmlsZU5hbWUsIFwicHRhdVwiLCAxKTtcblxuICAgICAgICBsZXQgYnVmZl9yID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiB6a2V5Lm44cik7XG5cbiAgICAgICAgY29uc3Qgc2VlZD0gbmV3IEFycmF5KDgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgICAgICBzZWVkW2ldID0gcmVhZFVJbnQzMkJFKGdldFJhbmRvbUJ5dGVzKDQpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBybmcgPSBuZXcgQ2hhQ2hhKHNlZWQpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplLTE7IGkrKykgeyAgIC8vIE5vdGUgdGhhdCBsYXN0IG9uZSBpcyB6ZXJvXG4gICAgICAgICAgICBjb25zdCBlID0gRnIuZnJvbVJuZyhybmcpO1xuICAgICAgICAgICAgRnIudG9ScHJMRShidWZmX3IsIGkqemtleS5uOHIsIGUpO1xuICAgICAgICB9XG4gICAgICAgIEZyLnRvUnByTEUoYnVmZl9yLCAoemtleS5kb21haW5TaXplLTEpKnprZXkubjhyLCBGci56ZXJvKTtcblxuICAgICAgICBsZXQgUjEgPSBHLnplcm87XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemU7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSCBWZXJpZmljYXRpb24odGF1KTogICR7aX0vJHt6a2V5LmRvbWFpblNpemV9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oemtleS5kb21haW5TaXplIC0gaSwgTUFYX0NIVU5LX1NJWkUpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmMSA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHKm4sIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgemtleS5kb21haW5TaXplKnNHICsgaSpzRyk7XG4gICAgICAgICAgICBjb25zdCBidWZmMiA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHKm4sIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgaSpzRyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZCID0gYXdhaXQgYmF0Y2hTdWJ0cmFjdChidWZmMSwgYnVmZjIpO1xuICAgICAgICAgICAgY29uc3QgYnVmZlMgPSBidWZmX3Iuc2xpY2UoaSp6a2V5Lm44ciwgKGkrbikqemtleS5uOHIpO1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZkIsIGJ1ZmZTKTtcblxuICAgICAgICAgICAgUjEgPSBHLmFkZChSMSwgcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgb2RkIGNvZWZmaWNpZW50cyBpbiB0cmFuc2Zvcm1lZCBkb21haW5cblxuICAgICAgICBidWZmX3IgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmX3IpO1xuICAgICAgICAvLyBjb25zdCBmaXJzdCA9IGN1cnZlLkZyLm5lZyhjdXJ2ZS5Gci5pbnYoY3VydmUuRnIuZSgyKSkpO1xuICAgICAgICAvLyBXb3JrcyoyICAgY29uc3QgZmlyc3QgPSBjdXJ2ZS5Gci5uZWcoY3VydmUuRnIuZSgyKSk7XG5cblxuICAgICAgICBsZXQgZmlyc3Q7XG5cbiAgICAgICAgaWYgKHprZXkucG93ZXIgPCBGci5zKSB7XG4gICAgICAgICAgICBmaXJzdCA9IEZyLm5lZyhGci5lKDIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNtYWxsX20gID0gMiAqKiBGci5zO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRfdG9fc21hbGxfbSA9IEZyLmV4cChGci5zaGlmdCwgc21hbGxfbSk7XG4gICAgICAgICAgICBmaXJzdCA9IEZyLnN1Yiggc2hpZnRfdG9fc21hbGxfbSwgRnIub25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnN0IGluYyA9IGN1cnZlLkZyLmludihjdXJ2ZS5QRnIud1t6a2V5LnBvd2VyKzFdKTtcbiAgICAgICAgY29uc3QgaW5jID0gemtleS5wb3dlciA8IEZyLnMgPyBGci53W3prZXkucG93ZXIrMV0gOiBGci5zaGlmdDtcbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuYmF0Y2hBcHBseUtleShidWZmX3IsIGZpcnN0LCBpbmMpO1xuICAgICAgICBidWZmX3IgPSBhd2FpdCBGci5mZnQoYnVmZl9yKTtcbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShidWZmX3IpO1xuXG4gICAgICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA5KTtcbiAgICAgICAgbGV0IFIyID0gRy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEggVmVyaWZpY2F0aW9uKGxhZ3JhbmdlKTogICR7aX0vJHt6a2V5LmRvbWFpblNpemV9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oemtleS5kb21haW5TaXplIC0gaSwgTUFYX0NIVU5LX1NJWkUpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRypuKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZTID0gYnVmZl9yLnNsaWNlKGkqemtleS5uOHIsIChpK24pKnprZXkubjhyKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJ1ZmYsIGJ1ZmZTKTtcblxuICAgICAgICAgICAgUjIgPSBHLmFkZChSMiwgcik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBSMSwgUjIsIHprZXkudmtfZGVsdGFfMiwgemtleUluaXQudmtfZGVsdGFfMik7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBiYXRjaFN1YnRyYWN0KGJ1ZmYxLCBidWZmMikge1xuICAgICAgICBjb25zdCBzRyA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGggLyBzRztcbiAgICAgICAgY29uc3QgY29uY3VycmVuY3k9IGN1cnZlLnRtLmNvbmN1cnJlbmN5O1xuICAgICAgICBjb25zdCBuUG9pbnRzUGVyVGhyZWFkID0gTWF0aC5mbG9vcihuUG9pbnRzIC8gY29uY3VycmVuY3kpO1xuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGlmIChpPCBjb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHNQZXJUaHJlYWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzIC0gaSpuUG9pbnRzUGVyVGhyZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBzdWJCdWZmMSA9IGJ1ZmYxLnNsaWNlKGkqblBvaW50c1BlclRocmVhZCpzRzEsIChpKm5Qb2ludHNQZXJUaHJlYWQrbikqc0cxKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YkJ1ZmYyID0gYnVmZjIuc2xpY2UoaSpuUG9pbnRzUGVyVGhyZWFkKnNHMSwgKGkqblBvaW50c1BlclRocmVhZCtuKSpzRzEpO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKGJhdGNoU3VidHJhY3RUaHJlYWQoc3ViQnVmZjEsIHN1YkJ1ZmYyKSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGNvbnN0IGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzRyk7XG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dC5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bGxCdWZmT3V0O1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gYmF0Y2hTdWJ0cmFjdFRocmVhZChidWZmMSwgYnVmZjIpIHtcbiAgICAgICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgICAgICBjb25zdCBzR21pZCA9IGN1cnZlLkcxLkYubjgqMztcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGgvc0cxO1xuICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYnVmZjF9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBidWZmMn0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDIsIGxlbjogblBvaW50cypzR21pZH0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICB0YXNrLnB1c2goe1xuICAgICAgICAgICAgICAgIGNtZDogXCJDQUxMXCIsXG4gICAgICAgICAgICAgICAgZm5OYW1lOiBcImcxbV9zdWJBZmZpbmVcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMCwgb2Zmc2V0OiBpKnNHMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogaSpzRzF9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAyLCBvZmZzZXQ6IGkqc0dtaWR9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcImcxbV9iYXRjaFRvQWZmaW5lXCIsIHBhcmFtczogW1xuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICB7dmFsOiBuUG9pbnRzfSxcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBuUG9pbnRzKnNHMX0pO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmFzeW5jIGZ1bmN0aW9uIHBoYXNlMnZlcmlmeUZyb21SMWNzKHIxY3NGaWxlTmFtZSwgcFRhdUZpbGVOYW1lLCB6a2V5RmlsZU5hbWUsIGxvZ2dlcikge1xuXG4gICAgLy8gY29uc3QgaW5pdEZpbGVOYW1lID0gXCJ+XCIgKyB6a2V5RmlsZU5hbWUgKyBcIi5pbml0XCI7XG4gICAgY29uc3QgaW5pdEZpbGVOYW1lID0ge3R5cGU6IFwiYmlnTWVtXCJ9O1xuICAgIGF3YWl0IG5ld1pLZXkocjFjc0ZpbGVOYW1lLCBwVGF1RmlsZU5hbWUsIGluaXRGaWxlTmFtZSwgbG9nZ2VyKTtcblxuICAgIHJldHVybiBhd2FpdCBwaGFzZTJ2ZXJpZnlGcm9tSW5pdChpbml0RmlsZU5hbWUsIHBUYXVGaWxlTmFtZSwgemtleUZpbGVOYW1lLCBsb2dnZXIpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBwaGFzZTJjb250cmlidXRlKHprZXlOYW1lT2xkLCB6a2V5TmFtZU5ldywgbmFtZSwgZW50cm9weSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uczogc2VjdGlvbnN9ID0gYXdhaXQgcmVhZEJpbkZpbGUoemtleU5hbWVPbGQsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgcmVhZEhlYWRlciQxKGZkT2xkLCBzZWN0aW9ucyk7XG4gICAgaWYgKHprZXkucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUSh6a2V5LnEpO1xuXG4gICAgY29uc3QgbXBjUGFyYW1zID0gYXdhaXQgcmVhZE1QQ1BhcmFtcyhmZE9sZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgY3JlYXRlQmluRmlsZSh6a2V5TmFtZU5ldywgXCJ6a2V5XCIsIDEsIDEwKTtcblxuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgZ2V0UmFuZG9tUm5nKGVudHJvcHkpO1xuXG4gICAgY29uc3QgdHJhbnNjcmlwdEhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pO1xuICAgIHRyYW5zY3JpcHRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoYXNoUHViS2V5KHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLmZyb21Sbmcocm5nKSk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4ID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcywgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSkpO1xuICAgIGhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MpO1xuICAgIGhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4KTtcbiAgICBjdXJDb250cmlidXRpb24udHJhbnNjcmlwdCA9IHRyYW5zY3JpcHRIYXNoZXIuZGlnZXN0KCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NwID0gaGFzaFRvRzIoY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0KTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3B4ID0gY3VydmUuRzIudG9BZmZpbmUoY3VydmUuRzIudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpKTtcblxuICAgIHprZXkudmtfZGVsdGFfMSA9IGN1cnZlLkcxLnRpbWVzRnIoemtleS52a19kZWx0YV8xLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KTtcbiAgICB6a2V5LnZrX2RlbHRhXzIgPSBjdXJ2ZS5HMi50aW1lc0ZyKHprZXkudmtfZGVsdGFfMiwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG5cbiAgICBjdXJDb250cmlidXRpb24uZGVsdGFBZnRlciA9IHprZXkudmtfZGVsdGFfMTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi50eXBlID0gMDtcbiAgICBpZiAobmFtZSkgY3VyQ29udHJpYnV0aW9uLm5hbWUgPSBuYW1lO1xuXG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgd3JpdGVIZWFkZXIoZmROZXcsIHprZXkpO1xuXG4gICAgLy8gSUNcbiAgICBhd2FpdCBjb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAzKTtcblxuICAgIC8vIENvZWZmcyAoS2VlcCBvcmlnaW5hbClcbiAgICBhd2FpdCBjb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA0KTtcblxuICAgIC8vIEEgU2VjdGlvblxuICAgIGF3YWl0IGNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDUpO1xuXG4gICAgLy8gQjEgU2VjdGlvblxuICAgIGF3YWl0IGNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDYpO1xuXG4gICAgLy8gQjIgU2VjdGlvblxuICAgIGF3YWl0IGNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDcpO1xuXG4gICAgY29uc3QgaW52RGVsdGEgPSBjdXJ2ZS5Gci5pbnYoY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOCwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiTCBTZWN0aW9uXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOSwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiSCBTZWN0aW9uXCIsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCB3cml0ZU1QQ1BhcmFtcyhmZE5ldywgY3VydmUsIG1wY1BhcmFtcyk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICBjb25zdCBjb250cmlidXRpb25IYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTtcbiAgICBoYXNoUHViS2V5KGNvbnRyaWJ1dGlvbkhhc2hlciwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbik7XG5cbiAgICBjb25zdCBjb250cmlidXRpb25IYXNoID0gY29udHJpYnV0aW9uSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChtcGNQYXJhbXMuY3NIYXNoLCBcIkNpcmN1aXQgSGFzaDogXCIpKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGNvbnRyaWJ1dGlvbkhhc2gsIFwiQ29udHJpYnV0aW9uIEhhc2g6IFwiKSk7XG5cbiAgICByZXR1cm4gY29udHJpYnV0aW9uSGFzaDtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuXG5hc3luYyBmdW5jdGlvbiBiZWFjb24oemtleU5hbWVPbGQsIHprZXlOYW1lTmV3LCBuYW1lLCBiZWFjb25IYXNoU3RyLCBudW1JdGVyYXRpb25zRXhwLCBsb2dnZXIpIHtcbiAgICBjb25zdCBiZWFjb25IYXNoID0gaGV4MkJ5dGVBcnJheShiZWFjb25IYXNoU3RyKTtcbiAgICBpZiAoICAgKGJlYWNvbkhhc2guYnl0ZUxlbmd0aCA9PSAwKVxuICAgICAgICB8fCAoYmVhY29uSGFzaC5ieXRlTGVuZ3RoKjIgIT1iZWFjb25IYXNoU3RyLmxlbmd0aCkpXG4gICAge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIEJlYWNvbiBIYXNoLiAoSXQgbXVzdCBiZSBhIHZhbGlkIGhleGFkZWNpbWFsIHNlcXVlbmNlKVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYmVhY29uSGFzaC5sZW5ndGg+PTI1Nikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJNYXhpbXVtIGxlbmd0aCBvZiBiZWFjb24gaGFzaCBpcyAyNTUgYnl0ZXNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBudW1JdGVyYXRpb25zRXhwID0gcGFyc2VJbnQobnVtSXRlcmF0aW9uc0V4cCk7XG4gICAgaWYgKChudW1JdGVyYXRpb25zRXhwPDEwKXx8KG51bUl0ZXJhdGlvbnNFeHA+NjMpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtSXRlcmF0aW9uc0V4cC4gKE11c3QgYmUgYmV0d2VlbiAxMCBhbmQgNjMpXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uczogc2VjdGlvbnN9ID0gYXdhaXQgcmVhZEJpbkZpbGUoemtleU5hbWVPbGQsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgcmVhZEhlYWRlciQxKGZkT2xkLCBzZWN0aW9ucyk7XG5cbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbVEoemtleS5xKTtcblxuICAgIGNvbnN0IG1wY1BhcmFtcyA9IGF3YWl0IHJlYWRNUENQYXJhbXMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGNyZWF0ZUJpbkZpbGUoemtleU5hbWVOZXcsIFwiemtleVwiLCAxLCAxMCk7XG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBybmdGcm9tQmVhY29uUGFyYW1zKGJlYWNvbkhhc2gsIG51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgY29uc3QgdHJhbnNjcmlwdEhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pOyAgICB0cmFuc2NyaXB0SGFzaGVyLnVwZGF0ZShtcGNQYXJhbXMuY3NIYXNoKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGFzaFB1YktleSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0pO1xuICAgIH1cblxuICAgIGNvbnN0IGN1ckNvbnRyaWJ1dGlvbiA9IHt9O1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YSA9IHt9O1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzRnIoY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpKTtcbiAgICBoYXNoRzEodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zKTtcbiAgICBoYXNoRzEodHJhbnNjcmlwdEhhc2hlciwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zeCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLnRyYW5zY3JpcHQgPSB0cmFuc2NyaXB0SGFzaGVyLmRpZ2VzdCgpO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMl9zcCA9IGhhc2hUb0cyKGN1cnZlLCBjdXJDb250cmlidXRpb24udHJhbnNjcmlwdCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NweCA9IGN1cnZlLkcyLnRvQWZmaW5lKGN1cnZlLkcyLnRpbWVzRnIoY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NwLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KSk7XG5cbiAgICB6a2V5LnZrX2RlbHRhXzEgPSBjdXJ2ZS5HMS50aW1lc0ZyKHprZXkudmtfZGVsdGFfMSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG4gICAgemtleS52a19kZWx0YV8yID0gY3VydmUuRzIudGltZXNGcih6a2V5LnZrX2RlbHRhXzIsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhQWZ0ZXIgPSB6a2V5LnZrX2RlbHRhXzE7XG5cbiAgICBjdXJDb250cmlidXRpb24udHlwZSA9IDE7XG4gICAgY3VyQ29udHJpYnV0aW9uLm51bUl0ZXJhdGlvbnNFeHAgPSBudW1JdGVyYXRpb25zRXhwO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5iZWFjb25IYXNoID0gYmVhY29uSGFzaDtcblxuICAgIGlmIChuYW1lKSBjdXJDb250cmlidXRpb24ubmFtZSA9IG5hbWU7XG5cbiAgICBtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5wdXNoKGN1ckNvbnRyaWJ1dGlvbik7XG5cbiAgICBhd2FpdCB3cml0ZUhlYWRlcihmZE5ldywgemtleSk7XG5cbiAgICAvLyBJQ1xuICAgIGF3YWl0IGNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDMpO1xuXG4gICAgLy8gQ29lZmZzIChLZWVwIG9yaWdpbmFsKVxuICAgIGF3YWl0IGNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDQpO1xuXG4gICAgLy8gQSBTZWN0aW9uXG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNSk7XG5cbiAgICAvLyBCMSBTZWN0aW9uXG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNik7XG5cbiAgICAvLyBCMiBTZWN0aW9uXG4gICAgYXdhaXQgY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNyk7XG5cbiAgICBjb25zdCBpbnZEZWx0YSA9IGN1cnZlLkZyLmludihjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KTtcbiAgICBhd2FpdCBhcHBseUtleVRvU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA4LCBjdXJ2ZSwgXCJHMVwiLCBpbnZEZWx0YSwgY3VydmUuRnIuZSgxKSwgXCJMIFNlY3Rpb25cIiwgbG9nZ2VyKTtcbiAgICBhd2FpdCBhcHBseUtleVRvU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA5LCBjdXJ2ZSwgXCJHMVwiLCBpbnZEZWx0YSwgY3VydmUuRnIuZSgxKSwgXCJIIFNlY3Rpb25cIiwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IHdyaXRlTVBDUGFyYW1zKGZkTmV3LCBjdXJ2ZSwgbXBjUGFyYW1zKTtcblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2hlciA9IGJsYWtlMmIuY3JlYXRlKHsgZGtMZW46IDY0IH0pOyAgICBoYXNoUHViS2V5KGNvbnRyaWJ1dGlvbkhhc2hlciwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbik7XG5cbiAgICBjb25zdCBjb250cmlidXRpb25IYXNoID0gY29udHJpYnV0aW9uSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oZm9ybWF0SGFzaChjb250cmlidXRpb25IYXNoLCBcIkNvbnRyaWJ1dGlvbiBIYXNoOiBcIikpO1xuXG4gICAgcmV0dXJuIGNvbnRyaWJ1dGlvbkhhc2g7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHprZXlFeHBvcnRKc29uKHprZXlGaWxlTmFtZSkge1xuXG4gICAgY29uc3QgektleSA9IGF3YWl0IHJlYWRaS2V5KHprZXlGaWxlTmFtZSwgdHJ1ZSk7XG4gICAgZGVsZXRlIHpLZXkuY3VydmU7XG4gICAgZGVsZXRlIHpLZXkuRjtcblxuICAgIHJldHVybiB1dGlscy5zdHJpbmdpZnlCaWdJbnRzKHpLZXkpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBiZWxsbWFuQ29udHJpYnV0ZShjdXJ2ZSwgY2hhbGxlbmdlRmlsZW5hbWUsIHJlc3BvbnNlRmlsZU5hbWUsIGVudHJvcHksIGxvZ2dlcikge1xuICAgIGNvbnN0IHJuZyA9IGF3YWl0IGdldFJhbmRvbVJuZyhlbnRyb3B5KTtcblxuICAgIGNvbnN0IGRlbHRhID0gY3VydmUuRnIuZnJvbVJuZyhybmcpO1xuICAgIGNvbnN0IGludkRlbHRhID0gY3VydmUuRnIuaW52KGRlbHRhKTtcblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5HMi5GLm44KjI7XG5cbiAgICBjb25zdCBmZEZyb20gPSBhd2FpdCByZWFkRXhpc3RpbmcoY2hhbGxlbmdlRmlsZW5hbWUpO1xuICAgIGNvbnN0IGZkVG8gPSBhd2FpdCBjcmVhdGVPdmVycmlkZShyZXNwb25zZUZpbGVOYW1lKTtcblxuXG4gICAgYXdhaXQgY29weShzRzEpOyAvLyBhbHBoYTFcbiAgICBhd2FpdCBjb3B5KHNHMSk7IC8vIGJldGExXG4gICAgYXdhaXQgY29weShzRzIpOyAvLyBiZXRhMlxuICAgIGF3YWl0IGNvcHkoc0cyKTsgLy8gZ2FtbWEyXG4gICAgY29uc3Qgb2xkRGVsdGExID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgY29uc3QgZGVsdGExID0gY3VydmUuRzEudGltZXNGcihvbGREZWx0YTEsIGRlbHRhKTtcbiAgICBhd2FpdCB3cml0ZUcxKGRlbHRhMSk7XG4gICAgY29uc3Qgb2xkRGVsdGEyID0gYXdhaXQgcmVhZEcyKCk7XG4gICAgY29uc3QgZGVsdGEyID0gY3VydmUuRzIudGltZXNGcihvbGREZWx0YTIsIGRlbHRhKTtcbiAgICBhd2FpdCB3cml0ZUcyKGRlbHRhMik7XG5cbiAgICAvLyBJQ1xuICAgIGNvbnN0IG5JQyA9IGF3YWl0IGZkRnJvbS5yZWFkVUJFMzIoKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlVUJFMzIobklDKTtcbiAgICBhd2FpdCBjb3B5KG5JQypzRzEpO1xuXG4gICAgLy8gSFxuICAgIGNvbnN0IG5IID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuSCk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRGcm9tLCBmZFRvLCBudWxsLCBjdXJ2ZSwgXCJHMVwiLCBuSCwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiVU5DT01QUkVTU0VEXCIsIFwiSFwiLCBsb2dnZXIpO1xuXG4gICAgLy8gTFxuICAgIGNvbnN0IG5MID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuTCk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRGcm9tLCBmZFRvLCBudWxsLCBjdXJ2ZSwgXCJHMVwiLCBuTCwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiVU5DT01QUkVTU0VEXCIsIFwiTFwiLCBsb2dnZXIpO1xuXG4gICAgLy8gQVxuICAgIGNvbnN0IG5BID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuQSk7XG4gICAgYXdhaXQgY29weShuQSpzRzEpO1xuXG4gICAgLy8gQjFcbiAgICBjb25zdCBuQjEgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5CMSk7XG4gICAgYXdhaXQgY29weShuQjEqc0cxKTtcblxuICAgIC8vIEIyXG4gICAgY29uc3QgbkIyID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuQjIpO1xuICAgIGF3YWl0IGNvcHkobkIyKnNHMik7XG5cblxuICAgIC8vLy8vLy8vLy9cbiAgICAvLy8gUmVhZCBjb250cmlidXRpb25zXG4gICAgLy8vLy8vLy8vL1xuICAgIGNvbnN0IHRyYW5zY3JpcHRIYXNoZXIgPSBibGFrZTJiLmNyZWF0ZSh7IGRrTGVuOiA2NCB9KTtcbiAgICBjb25zdCBtcGNQYXJhbXMgPSB7fTtcbiAgICAvLyBjc0hhc2hcbiAgICBtcGNQYXJhbXMuY3NIYXNoID0gIGF3YWl0IGZkRnJvbS5yZWFkKDY0KTtcbiAgICB0cmFuc2NyaXB0SGFzaGVyLnVwZGF0ZShtcGNQYXJhbXMuY3NIYXNoKTtcblxuICAgIGNvbnN0IG5Db250cmlidXRpb25zID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIG1wY1BhcmFtcy5jb250cmlidXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Db250cmlidXRpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHsgZGVsdGE6e30gfTtcbiAgICAgICAgYy5kZWx0YUFmdGVyID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgICAgIGMuZGVsdGEuZzFfcyA9IGF3YWl0IHJlYWRHMSgpO1xuICAgICAgICBjLmRlbHRhLmcxX3N4ID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgICAgIGMuZGVsdGEuZzJfc3B4ID0gYXdhaXQgcmVhZEcyKCk7XG4gICAgICAgIGMudHJhbnNjcmlwdCA9IGF3YWl0IGZkRnJvbS5yZWFkKDY0KTtcbiAgICAgICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjKTtcbiAgICAgICAgaGFzaFB1YktleSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgYyk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSA9IGRlbHRhO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEuZnJvbVJuZyhybmcpKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zLCBkZWx0YSkpO1xuICAgIGhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MpO1xuICAgIGhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4KTtcbiAgICBjdXJDb250cmlidXRpb24udHJhbnNjcmlwdCA9IHRyYW5zY3JpcHRIYXNoZXIuZGlnZXN0KCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NwID0gaGFzaFRvRzIoY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0KTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3B4ID0gY3VydmUuRzIudG9BZmZpbmUoY3VydmUuRzIudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AsIGRlbHRhKSk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhQWZ0ZXIgPSBkZWx0YTE7XG4gICAgY3VyQ29udHJpYnV0aW9uLnR5cGUgPSAwO1xuICAgIG1wY1BhcmFtcy5jb250cmlidXRpb25zLnB1c2goY3VyQ29udHJpYnV0aW9uKTtcblxuXG4gICAgLy8vLy8vLy8vL1xuICAgIC8vLyBXcml0ZSBDb250cmlidXRpb25cbiAgICAvLy8vLy8vLy8vXG5cbiAgICBhd2FpdCBmZFRvLndyaXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaT0wOyBpPG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhQWZ0ZXIpO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGEuZzFfcyk7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YS5nMV9zeCk7XG4gICAgICAgIGF3YWl0IHdyaXRlRzIoYy5kZWx0YS5nMl9zcHgpO1xuICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGMudHJhbnNjcmlwdCk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaGVyID0gYmxha2UyYi5jcmVhdGUoeyBka0xlbjogNjQgfSk7ICAgIGhhc2hQdWJLZXkoY29udHJpYnV0aW9uSGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2ggPSBjb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhmb3JtYXRIYXNoKGNvbnRyaWJ1dGlvbkhhc2gsIFwiQ29udHJpYnV0aW9uIEhhc2g6IFwiKSk7XG5cbiAgICBhd2FpdCBmZFRvLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRGcm9tLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gY29udHJpYnV0aW9uSGFzaDtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvcHkobkJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IENIVU5LX1NJWkUgPSBmZEZyb20ucGFnZVNpemUqMjtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5CeXRlczsgaSs9IENIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuQnl0ZXMgLWksIENIVU5LX1NJWkUpO1xuICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkRnJvbS5yZWFkKG4pO1xuICAgICAgICAgICAgYXdhaXQgZmRUby53cml0ZShidWZmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRHMSgpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkRnJvbS5yZWFkKGN1cnZlLkcxLkYubjgqMik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5HMS5mcm9tUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDApO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRHMigpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkRnJvbS5yZWFkKGN1cnZlLkcyLkYubjgqMik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5HMi5mcm9tUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDApO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzEoUCkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc0cxKTtcbiAgICAgICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgUCk7XG4gICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMihQKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRzIpO1xuICAgICAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBQKTtcbiAgICAgICAgYXdhaXQgZmRUby53cml0ZShidWZmKTtcbiAgICB9XG5cblxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCB7c3RyaW5naWZ5QmlnSW50czogc3RyaW5naWZ5QmlnSW50cyQzfSA9IHV0aWxzO1xuXG5hc3luYyBmdW5jdGlvbiB6a2V5RXhwb3J0VmVyaWZpY2F0aW9uS2V5KHprZXlOYW1lLCBsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkVYUE9SVCBWRVJJRklDQVRJT04gS0VZIFNUQVJURURcIik7XG5cbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IHJlYWRCaW5GaWxlKHprZXlOYW1lLCBcInprZXlcIiwgMik7XG4gICAgY29uc3QgemtleSA9IGF3YWl0IHJlYWRIZWFkZXIkMShmZCwgc2VjdGlvbnMpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IERldGVjdGVkIHByb3RvY29sOiBcIiArIHprZXkucHJvdG9jb2wpO1xuXG4gICAgbGV0IHJlcztcbiAgICBpZiAoemtleS5wcm90b2NvbCA9PT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgcmVzID0gYXdhaXQgZ3JvdGgxNlZrKHprZXksIGZkLCBzZWN0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh6a2V5LnByb3RvY29sID09PSBcInBsb25rXCIpIHtcbiAgICAgICAgcmVzID0gYXdhaXQgcGxvbmtWayh6a2V5KTtcbiAgICB9IGVsc2UgaWYgKHprZXkucHJvdG9jb2xJZCAmJiB6a2V5LnByb3RvY29sSWQgPT09IEZGTE9OS19QUk9UT0NPTF9JRCkge1xuICAgICAgICByZXMgPSBhd2FpdCBleHBvcnRGRmxvbmtWayh6a2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgcHJvdG9jb2wgdW5yZWNvZ25pemVkXCIpO1xuICAgIH1cblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkVYUE9SVCBWRVJJRklDQVRJT04gS0VZIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBncm90aDE2VmsoemtleSwgZmQsIHNlY3Rpb25zKSB7XG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21RKHprZXkucSk7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCAqIDI7XG5cbiAgICBjb25zdCBhbHBoYUJldGEgPSBhd2FpdCBjdXJ2ZS5wYWlyaW5nKHprZXkudmtfYWxwaGFfMSwgemtleS52a19iZXRhXzIpO1xuXG4gICAgbGV0IHZLZXkgPSB7XG4gICAgICAgIHByb3RvY29sOiB6a2V5LnByb3RvY29sLFxuICAgICAgICBjdXJ2ZTogY3VydmUubmFtZSxcbiAgICAgICAgblB1YmxpYzogemtleS5uUHVibGljLFxuXG4gICAgICAgIHZrX2FscGhhXzE6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkudmtfYWxwaGFfMSksXG5cbiAgICAgICAgdmtfYmV0YV8yOiBjdXJ2ZS5HMi50b09iamVjdCh6a2V5LnZrX2JldGFfMiksXG4gICAgICAgIHZrX2dhbW1hXzI6IGN1cnZlLkcyLnRvT2JqZWN0KHprZXkudmtfZ2FtbWFfMiksXG4gICAgICAgIHZrX2RlbHRhXzI6IGN1cnZlLkcyLnRvT2JqZWN0KHprZXkudmtfZGVsdGFfMiksXG5cbiAgICAgICAgdmtfYWxwaGFiZXRhXzEyOiBjdXJ2ZS5HdC50b09iamVjdChhbHBoYUJldGEpXG4gICAgfTtcblxuICAgIC8vIFJlYWQgSUMgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDMpO1xuICAgIHZLZXkuSUMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRzEpO1xuICAgICAgICBjb25zdCBQID0gY3VydmUuRzEudG9PYmplY3QoYnVmZik7XG4gICAgICAgIHZLZXkuSUMucHVzaChQKTtcbiAgICB9XG4gICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgdktleSA9IHN0cmluZ2lmeUJpZ0ludHMkMyh2S2V5KTtcblxuICAgIHJldHVybiB2S2V5O1xufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIHBsb25rVmsoemtleSkge1xuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUSh6a2V5LnEpO1xuXG4gICAgbGV0IHZLZXkgPSB7XG4gICAgICAgIHByb3RvY29sOiB6a2V5LnByb3RvY29sLFxuICAgICAgICBjdXJ2ZTogY3VydmUubmFtZSxcbiAgICAgICAgblB1YmxpYzogemtleS5uUHVibGljLFxuICAgICAgICBwb3dlcjogemtleS5wb3dlcixcblxuICAgICAgICBrMTogY3VydmUuRnIudG9PYmplY3QoemtleS5rMSksXG4gICAgICAgIGsyOiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5LmsyKSxcblxuICAgICAgICBRbTogY3VydmUuRzEudG9PYmplY3QoemtleS5RbSksXG4gICAgICAgIFFsOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlFsKSxcbiAgICAgICAgUXI6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUXIpLFxuICAgICAgICBRbzogY3VydmUuRzEudG9PYmplY3QoemtleS5RbyksXG4gICAgICAgIFFjOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlFjKSxcbiAgICAgICAgUzE6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUzEpLFxuICAgICAgICBTMjogY3VydmUuRzEudG9PYmplY3QoemtleS5TMiksXG4gICAgICAgIFMzOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlMzKSxcblxuICAgICAgICBYXzI6IGN1cnZlLkcyLnRvT2JqZWN0KHprZXkuWF8yKSxcblxuICAgICAgICB3OiBjdXJ2ZS5Gci50b09iamVjdChjdXJ2ZS5Gci53W3prZXkucG93ZXJdKVxuICAgIH07XG5cbiAgICB2S2V5ID0gc3RyaW5naWZ5QmlnSW50cyQzKHZLZXkpO1xuXG4gICAgcmV0dXJuIHZLZXk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4cG9ydEZGbG9ua1ZrKHprZXksIGxvZ2dlcikge1xuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tUSh6a2V5LnEpO1xuXG4gICAgbGV0IHZLZXkgPSB7XG4gICAgICAgIHByb3RvY29sOiB6a2V5LnByb3RvY29sLFxuICAgICAgICBjdXJ2ZTogY3VydmUubmFtZSxcbiAgICAgICAgblB1YmxpYzogemtleS5uUHVibGljLFxuICAgICAgICBwb3dlcjogemtleS5wb3dlcixcblxuICAgICAgICBrMTogY3VydmUuRnIudG9PYmplY3QoemtleS5rMSksXG4gICAgICAgIGsyOiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5LmsyKSxcblxuICAgICAgICB3OiBjdXJ2ZS5Gci50b09iamVjdChjdXJ2ZS5Gci53W3prZXkucG93ZXJdKSxcbiAgICAgICAgLy93VzogY3VydmUuRnIudG9PYmplY3QoY3VydmUuRnIud1t6a2V5LnBvd2VyICsgMV0pLFxuICAgICAgICB3MzogY3VydmUuRnIudG9PYmplY3QoemtleS53MyksXG4gICAgICAgIHc0OiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5Lnc0KSxcbiAgICAgICAgdzg6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkudzgpLFxuICAgICAgICB3cjogY3VydmUuRnIudG9PYmplY3QoemtleS53ciksXG5cbiAgICAgICAgWF8yOiBjdXJ2ZS5HMi50b09iamVjdCh6a2V5LlhfMiksXG5cbiAgICAgICAgQzA6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuQzApLFxuICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5QmlnSW50cyQzKHZLZXkpO1xufVxuXG52YXIgZWpzID0ge307XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNvbnN0IHt1bnN0cmluZ2lmeUJpZ0ludHM6IHVuc3RyaW5naWZ5QmlnSW50cyQ2LCBzdHJpbmdpZnlCaWdJbnRzOiBzdHJpbmdpZnlCaWdJbnRzJDJ9ID0gdXRpbHM7XG5cbmFzeW5jIGZ1bmN0aW9uIGZmbG9ua0V4cG9ydFNvbGlkaXR5VmVyaWZpZXIodmssIHRlbXBsYXRlcywgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgRVhQT1JUIFNPTElESVRZIFZFUklGSUVSIFNUQVJURURcIik7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbU5hbWUodmsuY3VydmUpO1xuXG4gICAgLy8gUHJlY29tcHV0ZSB3M18yLCB3NF8yIGFuZCB3NF8zXG4gICAgbGV0IHczID0gZnJvbVZrZXkodmsudzMpO1xuICAgIHZrLnczXzIgPSB0b1ZrZXkoY3VydmUuRnIuc3F1YXJlKHczKSk7XG5cbiAgICBsZXQgdzQgPSBmcm9tVmtleSh2ay53NCk7XG4gICAgdmsudzRfMiA9IHRvVmtleShjdXJ2ZS5Gci5zcXVhcmUodzQpKTtcbiAgICB2ay53NF8zID0gdG9Wa2V5KGN1cnZlLkZyLm11bChjdXJ2ZS5Gci5zcXVhcmUodzQpLCB3NCkpO1xuXG4gICAgbGV0IHc4ID0gZnJvbVZrZXkodmsudzgpO1xuICAgIGxldCBhY2MgPSBjdXJ2ZS5Gci5vbmU7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICBhY2MgPSBjdXJ2ZS5Gci5tdWwoYWNjLCB3OCk7XG4gICAgICAgIHZrW1widzhfXCIgKyBpXSA9IHRvVmtleShhY2MpO1xuICAgIH1cblxuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1t2ay5wcm90b2NvbF07XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBFWFBPUlQgU09MSURJVFkgVkVSSUZJRVIgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4gZWpzLnJlbmRlcih0ZW1wbGF0ZSwgdmspO1xuXG4gICAgZnVuY3Rpb24gZnJvbVZrZXkoc3RyKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHVuc3RyaW5naWZ5QmlnSW50cyQ2KHN0cik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZhbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Wa2V5KHZhbCkge1xuICAgICAgICBjb25zdCBzdHIgPSBjdXJ2ZS5Gci50b09iamVjdCh2YWwpO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5QmlnSW50cyQyKHN0cik7XG4gICAgfVxufVxuXG4vLyBOb3QgcmVhZHkgeWV0XG4vLyBtb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZVZlcmlmaWVyX2tpbWxlZW9oID0gZ2VuZXJhdGVWZXJpZmllcl9raW1sZWVvaDtcblxuYXN5bmMgZnVuY3Rpb24gZXhwb3J0U29saWRpdHlWZXJpZmllcih6S2V5TmFtZSwgdGVtcGxhdGVzLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHZlcmlmaWNhdGlvbktleSA9IGF3YWl0IHprZXlFeHBvcnRWZXJpZmljYXRpb25LZXkoektleU5hbWUsIGxvZ2dlcik7XG5cbiAgICBpZiAoXCJmZmxvbmtcIiA9PT0gdmVyaWZpY2F0aW9uS2V5LnByb3RvY29sKSB7XG4gICAgICAgIHJldHVybiBmZmxvbmtFeHBvcnRTb2xpZGl0eVZlcmlmaWVyKHZlcmlmaWNhdGlvbktleSwgdGVtcGxhdGVzLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1t2ZXJpZmljYXRpb25LZXkucHJvdG9jb2xdO1xuXG4gICAgcmV0dXJuIGVqcy5yZW5kZXIodGVtcGxhdGUsIHZlcmlmaWNhdGlvbktleSk7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbnZhciB6a2V5ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuZXdaS2V5OiBuZXdaS2V5LFxuICAgIGV4cG9ydEJlbGxtYW46IHBoYXNlMmV4cG9ydE1QQ1BhcmFtcyxcbiAgICBpbXBvcnRCZWxsbWFuOiBwaGFzZTJpbXBvcnRNUENQYXJhbXMsXG4gICAgdmVyaWZ5RnJvbVIxY3M6IHBoYXNlMnZlcmlmeUZyb21SMWNzLFxuICAgIHZlcmlmeUZyb21Jbml0OiBwaGFzZTJ2ZXJpZnlGcm9tSW5pdCxcbiAgICBjb250cmlidXRlOiBwaGFzZTJjb250cmlidXRlLFxuICAgIGJlYWNvbjogYmVhY29uLFxuICAgIGV4cG9ydEpzb246IHprZXlFeHBvcnRKc29uLFxuICAgIGJlbGxtYW5Db250cmlidXRlOiBiZWxsbWFuQ29udHJpYnV0ZSxcbiAgICBleHBvcnRWZXJpZmljYXRpb25LZXk6IHprZXlFeHBvcnRWZXJpZmljYXRpb25LZXksXG4gICAgZXhwb3J0U29saWRpdHlWZXJpZmllcjogZXhwb3J0U29saWRpdHlWZXJpZmllclxufSk7XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuYXN5bmMgZnVuY3Rpb24gcGxvbmtTZXR1cChyMWNzTmFtZSwgcHRhdU5hbWUsIHprZXlOYW1lLCBsb2dnZXIpIHtcblxuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cblxuICAgIGNvbnN0IHtmZDogZmRQVGF1LCBzZWN0aW9uczogc2VjdGlvbnNQVGF1fSA9IGF3YWl0IHJlYWRCaW5GaWxlKHB0YXVOYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCByZWFkUFRhdUhlYWRlcihmZFBUYXUsIHNlY3Rpb25zUFRhdSk7XG4gICAgY29uc3Qge2ZkOiBmZFIxY3MsIHNlY3Rpb25zOiBzZWN0aW9uc1IxY3N9ID0gYXdhaXQgcmVhZEJpbkZpbGUocjFjc05hbWUsIFwicjFjc1wiLCAxKTtcblxuICAgIGNvbnN0IHIxY3MgPSBhd2FpdCByZWFkUjFjc0ZkKGZkUjFjcywgc2VjdGlvbnNSMWNzLCB7bG9hZENvbnN0cmFpbnRzOiB0cnVlLCBsb2FkQ3VzdG9tR2F0ZXM6IHRydWV9KTtcblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IG44ciA9IGN1cnZlLkZyLm44O1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIHIxY3NcIik7XG4gICAgYXdhaXQgcmVhZFNlY3Rpb24oZmRSMWNzLCBzZWN0aW9uc1IxY3MsIDIpO1xuXG4gICAgY29uc3QgcGxvbmtDb25zdHJhaW50cyA9IG5ldyBCaWdBcnJheSQxKCk7XG4gICAgY29uc3QgcGxvbmtBZGRpdGlvbnMgPSBuZXcgQmlnQXJyYXkkMSgpO1xuICAgIGxldCBwbG9ua05WYXJzID0gcjFjcy5uVmFycztcblxuICAgIGNvbnN0IG5QdWJsaWMgPSByMWNzLm5PdXRwdXRzICsgcjFjcy5uUHViSW5wdXRzO1xuXG4gICAgYXdhaXQgcHJvY2Vzc0NvbnN0cmFpbnRzKGN1cnZlLkZyLCByMWNzLCBsb2dnZXIpO1xuXG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuXG4gICAgY29uc3QgZmRaS2V5ID0gYXdhaXQgY3JlYXRlQmluRmlsZSh6a2V5TmFtZSwgXCJ6a2V5XCIsIDEsIDE0LCAxPDwyMiwgMTw8MjQpO1xuXG5cbiAgICBpZiAocjFjcy5wcmltZSAhPSBjdXJ2ZS5yKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcInIxY3MgY3VydmUgZG9lcyBub3QgbWF0Y2ggcG93ZXJzIG9mIHRhdSBjZXJlbW9ueSBjdXJ2ZVwiKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGxldCBjaXJQb3dlciA9IGxvZzIocGxvbmtDb25zdHJhaW50cy5sZW5ndGggLTEpICsxO1xuICAgIGlmIChjaXJQb3dlciA8IDMpIGNpclBvd2VyID0gMzsgICAvLyBBcyB0aGUgdCBwb2x5bm9taWFsIGlzIG4rNSB3ZSBuZWVkIGF0IGxlYXN0IGEgcG93ZXIgb2YgNFxuICAgIGNvbnN0IGRvbWFpblNpemUgPSAyICoqIGNpclBvd2VyO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJQbG9uayBjb25zdHJhaW50czogXCIgKyBwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCk7XG4gICAgaWYgKGNpclBvd2VyID4gcG93ZXIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBjaXJjdWl0IHRvbyBiaWcgZm9yIHRoaXMgcG93ZXIgb2YgdGF1IGNlcmVtb255LiAke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofSA+IDIqKiR7cG93ZXJ9YCk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoIXNlY3Rpb25zUFRhdVsxMl0pIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUG93ZXJzIG9mIHRhdSBpcyBub3QgcHJlcGFyZWQuXCIpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG5cbiAgICBjb25zdCBMUG9pbnRzID0gbmV3IEJpZ0J1ZmZlcihkb21haW5TaXplKnNHMSk7XG4gICAgY29uc3QgbyA9IHNlY3Rpb25zUFRhdVsxMl1bMF0ucCArICgoMiAqKiAoY2lyUG93ZXIpKSAtMSkqc0cxO1xuICAgIGF3YWl0IGZkUFRhdS5yZWFkVG9CdWZmZXIoTFBvaW50cywgMCwgZG9tYWluU2l6ZSpzRzEsIG8pO1xuXG4gICAgY29uc3QgW2sxLCBrMl0gPSBnZXRLMUsyKCk7XG5cbiAgICBjb25zdCB2ayA9IHt9O1xuXG5cbiAgICBhd2FpdCB3cml0ZUFkZGl0aW9ucygzLCBcIkFkZGl0aW9uc1wiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKDQsIDAsIFwiQW1hcFwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKDUsIDEsIFwiQm1hcFwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKDYsIDIsIFwiQ21hcFwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVRTWFwKDcsIDMsIFwiUW1cIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlUU1hcCg4LCA0LCBcIlFsXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVFNYXAoOSwgNSwgXCJRclwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVRTWFwKDEwLCA2LCBcIlFvXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVFNYXAoMTEsIDcsIFwiUWNcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlU2lnbWEoMTIsIFwic2lnbWFcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlTHMoMTMsIFwibGFncmFuZ2UgcG9seW5vbWlhbHNcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuXG4gICAgLy8gV3JpdGUgUFRhdSBwb2ludHNcbiAgICAvLy8vLy8vLy8vLy9cblxuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMTQpO1xuICAgIGNvbnN0IGJ1ZmZPdXQgPSBuZXcgQmlnQnVmZmVyKChkb21haW5TaXplKzYpKnNHMSk7XG4gICAgYXdhaXQgZmRQVGF1LnJlYWRUb0J1ZmZlcihidWZmT3V0LCAwLCAoZG9tYWluU2l6ZSs2KSpzRzEsIHNlY3Rpb25zUFRhdVsyXVswXS5wKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoYnVmZk91dCk7XG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuXG5cbiAgICBhd2FpdCB3cml0ZUhlYWRlcnMoKTtcblxuICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIGF3YWl0IGZkUjFjcy5jbG9zZSgpO1xuICAgIGF3YWl0IGZkUFRhdS5jbG9zZSgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJTZXR1cCBGaW5pc2hlZFwiKTtcblxuICAgIHJldHVybiA7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ29uc3RyYWludHMoRnIsIHIxY3MsIGxvZ2dlcikge1xuXG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShsaW5lYXJDb21iKSB7XG4gICAgICAgICAgICBjb25zdCBzcyA9IE9iamVjdC5rZXlzKGxpbmVhckNvbWIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lYXJDb21iW3NzW2ldXSA9PSAwbikgZGVsZXRlIGxpbmVhckNvbWJbc3NbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gam9pbihsaW5lYXJDb21iMSwgaywgbGluZWFyQ29tYjIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIGxpbmVhckNvbWIxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNbc10gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXNbc10gPSBGci5tdWwoaywgbGluZWFyQ29tYjFbc10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tzXSA9IEZyLmFkZChyZXNbc10sIEZyLm11bChrLCBsaW5lYXJDb21iMVtzXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgcyBpbiBsaW5lYXJDb21iMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IEZyLm5lZyhsaW5lYXJDb21iMltzXSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNbc10gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXNbc10gPSB2YWw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3NdID0gRnIuYWRkKHJlc1tzXSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWxpemUocmVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWR1Y2VDb2VmcyhsaW5lYXJDb21iLCBtYXhDKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICAgICAgazogRnIuemVybyxcbiAgICAgICAgICAgICAgICBzOiBbXSxcbiAgICAgICAgICAgICAgICBjb2VmczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIGxpbmVhckNvbWIpIHtcbiAgICAgICAgICAgICAgICBpZiAocyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5rID0gRnIuYWRkKHJlcy5rLCBsaW5lYXJDb21iW3NdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVhckNvbWJbc10gIT0gMG4pIHtcbiAgICAgICAgICAgICAgICAgICAgY3MucHVzaChbTnVtYmVyKHMpLCBsaW5lYXJDb21iW3NdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNzLmxlbmd0aCA+IG1heEMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjMSA9IGNzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYzIgPSBjcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2wgPSBjMVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzciA9IGMyWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvID0gcGxvbmtOVmFycysrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFtID0gRnIuemVybztcbiAgICAgICAgICAgICAgICBjb25zdCBxbCA9IEZyLm5lZyhjMVsxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcXIgPSBGci5uZWcoYzJbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFvID0gRnIub25lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFjID0gRnIuemVybztcblxuICAgICAgICAgICAgICAgIHBsb25rQ29uc3RyYWludHMucHVzaChbc2wsIHNyLCBzbywgcW0sIHFsLCBxciwgcW8sIHFjXSk7XG5cbiAgICAgICAgICAgICAgICBwbG9ua0FkZGl0aW9ucy5wdXNoKFtzbCwgc3IsIGMxWzFdLCBjMlsxXV0pO1xuXG4gICAgICAgICAgICAgICAgY3MucHVzaChbc28sIEZyLm9uZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlcy5zW2ldID0gY3NbaV1bMF07XG4gICAgICAgICAgICAgICAgcmVzLmNvZWZzW2ldID0gY3NbaV1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocmVzLmNvZWZzLmxlbmd0aCA8IG1heEMpIHtcbiAgICAgICAgICAgICAgICByZXMucy5wdXNoKDApO1xuICAgICAgICAgICAgICAgIHJlcy5jb2Vmcy5wdXNoKEZyLnplcm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZENvbnN0cmFpbnRTdW0obGMpIHtcbiAgICAgICAgICAgIGNvbnN0IEMgPSByZWR1Y2VDb2VmcyhsYywgMyk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IEMuc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNyID0gQy5zWzFdO1xuICAgICAgICAgICAgY29uc3Qgc28gPSBDLnNbMl07XG4gICAgICAgICAgICBjb25zdCBxbSA9IEZyLnplcm87XG4gICAgICAgICAgICBjb25zdCBxbCA9IEMuY29lZnNbMF07XG4gICAgICAgICAgICBjb25zdCBxciA9IEMuY29lZnNbMV07XG4gICAgICAgICAgICBjb25zdCBxbyA9IEMuY29lZnNbMl07XG4gICAgICAgICAgICBjb25zdCBxYyA9IEMuaztcbiAgICAgICAgICAgIHBsb25rQ29uc3RyYWludHMucHVzaChbc2wsIHNyLCBzbywgcW0sIHFsLCBxciwgcW8sIHFjXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDb25zdHJhaW50TXVsKGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgICAgIGNvbnN0IEEgPSByZWR1Y2VDb2VmcyhsY0EsIDEpO1xuICAgICAgICAgICAgY29uc3QgQiA9IHJlZHVjZUNvZWZzKGxjQiwgMSk7XG4gICAgICAgICAgICBjb25zdCBDID0gcmVkdWNlQ29lZnMobGNDLCAxKTtcblxuXG4gICAgICAgICAgICBjb25zdCBzbCA9IEEuc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNyID0gQi5zWzBdO1xuICAgICAgICAgICAgY29uc3Qgc28gPSBDLnNbMF07XG4gICAgICAgICAgICBjb25zdCBxbSA9IEZyLm11bChBLmNvZWZzWzBdLCBCLmNvZWZzWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHFsID0gRnIubXVsKEEuY29lZnNbMF0sIEIuayk7XG4gICAgICAgICAgICBjb25zdCBxciA9IEZyLm11bChBLmssIEIuY29lZnNbMF0pO1xuICAgICAgICAgICAgY29uc3QgcW8gPSBGci5uZWcoQy5jb2Vmc1swXSk7XG4gICAgICAgICAgICBjb25zdCBxYyA9IEZyLnN1YihGci5tdWwoQS5rLCBCLmspLCBDLmspO1xuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKFtzbCwgc3IsIHNvLCBxbSwgcWwsIHFyLCBxbywgcWNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsYykge1xuICAgICAgICAgICAgbGV0IGsgPSBGci56ZXJvO1xuICAgICAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAgICAgY29uc3Qgc3MgPSBPYmplY3Qua2V5cyhsYyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxjW3NzW2ldXSA9PSAwbikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGNbc3NbaV1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3NbaV0gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrID0gRnIuYWRkKGssIGxjW3NzW2ldXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuID4gMCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChrICE9IEZyLnplcm8pIHJldHVybiBcImtcIjtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3MobGNBLCBsY0IsIGxjQykge1xuICAgICAgICAgICAgY29uc3QgbGN0QSA9IGdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsY0EpO1xuICAgICAgICAgICAgY29uc3QgbGN0QiA9IGdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsY0IpO1xuICAgICAgICAgICAgaWYgKChsY3RBID09PSBcIjBcIikgfHwgKGxjdEIgPT09IFwiMFwiKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZShsY0MpO1xuICAgICAgICAgICAgICAgIGFkZENvbnN0cmFpbnRTdW0obGNDKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGN0QSA9PT0gXCJrXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsY0NDID0gam9pbihsY0IsIGxjQVswXSwgbGNDKTtcbiAgICAgICAgICAgICAgICBhZGRDb25zdHJhaW50U3VtKGxjQ0MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsY3RCID09PSBcImtcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxjQ0MgPSBqb2luKGxjQSwgbGNCWzBdLCBsY0MpO1xuICAgICAgICAgICAgICAgIGFkZENvbnN0cmFpbnRTdW0obGNDQyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZENvbnN0cmFpbnRNdWwobGNBLCBsY0IsIGxjQyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBzID0gMTsgcyA8PSBuUHVibGljOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gcztcbiAgICAgICAgICAgIGNvbnN0IHNyID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNvID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHFtID0gRnIuemVybztcbiAgICAgICAgICAgIGNvbnN0IHFsID0gRnIub25lO1xuICAgICAgICAgICAgY29uc3QgcXIgPSBGci56ZXJvO1xuICAgICAgICAgICAgY29uc3QgcW8gPSBGci56ZXJvO1xuICAgICAgICAgICAgY29uc3QgcWMgPSBGci56ZXJvO1xuXG4gICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goW3NsLCBzciwgc28sIHFtLCBxbCwgcXIsIHFvLCBxY10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCByMWNzLmNvbnN0cmFpbnRzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGMgJSAxMDAwMCA9PT0gMCkpIGxvZ2dlci5kZWJ1ZyhgcHJvY2Vzc2luZyBjb25zdHJhaW50czogJHtjfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICAgICAgcHJvY2VzcyguLi5yMWNzLmNvbnN0cmFpbnRzW2NdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlV2l0bmVzc01hcChzZWN0aW9uTnVtLCBwb3NDb25zdHJhaW50LCBuYW1lKSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihwbG9ua0NvbnN0cmFpbnRzW2ldW3Bvc0NvbnN0cmFpbnRdKTtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGB3cml0aW5nICR7bmFtZX06ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVFNYXAoc2VjdGlvbk51bSwgcG9zQ29uc3RyYWludCwgbmFtZSkge1xuICAgICAgICBsZXQgUSA9IG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgUS5zZXQocGxvbmtDb25zdHJhaW50c1tpXVtwb3NDb25zdHJhaW50XSwgaSpuOHIpO1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfTogJHtpfS8ke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGF3YWl0IHdyaXRlUDQoUSk7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgICAgICBRID0gYXdhaXQgRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShRKTtcbiAgICAgICAgdmtbbmFtZV09IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKExQb2ludHMsIFEsIGxvZ2dlciwgXCJtdWx0aWV4cCBcIituYW1lKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVA0KGJ1ZmYpIHtcbiAgICAgICAgY29uc3QgcSA9IGF3YWl0IEZyLmlmZnQoYnVmZik7XG4gICAgICAgIGNvbnN0IHE0ID0gbmV3IEJpZ0J1ZmZlcihkb21haW5TaXplKm44cio0KTtcbiAgICAgICAgcTQuc2V0KHEsIDApO1xuICAgICAgICBjb25zdCBRNCA9IGF3YWl0IEZyLmZmdChxNCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShxKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKFE0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUFkZGl0aW9ucyhzZWN0aW9uTnVtLCBuYW1lKSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZPdXQgPSBuZXcgVWludDhBcnJheSgoMio0KzIqbjhyKSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZPdXRWID0gbmV3IERhdGFWaWV3KGJ1ZmZPdXQuYnVmZmVyKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBsb25rQWRkaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRpdGlvbj1wbG9ua0FkZGl0aW9uc1tpXTtcbiAgICAgICAgICAgIGxldCBvPTA7XG4gICAgICAgICAgICBidWZmT3V0Vi5zZXRVaW50MzIobywgYWRkaXRpb25bMF0sIHRydWUpOyBvKz00O1xuICAgICAgICAgICAgYnVmZk91dFYuc2V0VWludDMyKG8sIGFkZGl0aW9uWzFdLCB0cnVlKTsgbys9NDtcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gTW9udGdvbWVyeS4gc3RvcmVkID0gdipSXG4gICAgICAgICAgICAvLyBzbyB3aGVuIG1vbnRnb21lcnkgbXVsdGlwbGllZCBieSB0aGUgd2l0bmVzcywgaXQncyByZXN1bHQgPSB2KlIqdy9SID0gdip3XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblsyXSwgbyk7IG8rPSBuOHI7XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblszXSwgbyk7IG8rPSBuOHI7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYnVmZk91dCk7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9OiAke2l9LyR7cGxvbmtBZGRpdGlvbnMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlU2lnbWEoc2VjdGlvbk51bSwgbmFtZSkge1xuICAgICAgICBjb25zdCBzaWdtYSA9IG5ldyBCaWdCdWZmZXIobjhyKmRvbWFpblNpemUqMyk7XG4gICAgICAgIGNvbnN0IGxhc3RBcGFyZW5jZSA9ICBuZXcgQmlnQXJyYXkkMShwbG9ua05WYXJzKTtcbiAgICAgICAgY29uc3QgZmlyc3RQb3MgPSBuZXcgQmlnQXJyYXkkMShwbG9ua05WYXJzKTtcbiAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxkb21haW5TaXplO2krKykge1xuICAgICAgICAgICAgaWYgKGk8cGxvbmtDb25zdHJhaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKHBsb25rQ29uc3RyYWludHNbaV1bMF0sIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsxXSwgZG9tYWluU2l6ZSArIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsyXSwgZG9tYWluU2l6ZSoyICsgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBkb21haW5TaXplICsgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBkb21haW5TaXplKjIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1tjaXJQb3dlcl0pO1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfSBwaGFzZTE6ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzPTA7IHM8cGxvbmtOVmFyczsgcysrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpcnN0UG9zW3NdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KGxhc3RBcGFyZW5jZVtzXSwgZmlyc3RQb3Nbc10qbjhyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgbm90IHVzZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWYXJpYWJsZSBub3QgdXNlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKHMlMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGB3cml0aW5nICR7bmFtZX0gcGhhc2UyOiAke3N9LyR7cGxvbmtOVmFyc31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgbGV0IFMxID0gc2lnbWEuc2xpY2UoMCwgZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFMxKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICBsZXQgUzIgPSBzaWdtYS5zbGljZShkb21haW5TaXplKm44ciwgZG9tYWluU2l6ZSpuOHIqMik7XG4gICAgICAgIGF3YWl0IHdyaXRlUDQoUzIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIGxldCBTMyA9IHNpZ21hLnNsaWNlKGRvbWFpblNpemUqbjhyKjIsIGRvbWFpblNpemUqbjhyKjMpO1xuICAgICAgICBhd2FpdCB3cml0ZVA0KFMzKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgICAgICBTMSA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoUzEpO1xuICAgICAgICBTMiA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoUzIpO1xuICAgICAgICBTMyA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoUzMpO1xuXG4gICAgICAgIHZrLlMxPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShMUG9pbnRzLCBTMSwgbG9nZ2VyLCBcIm11bHRpZXhwIFMxXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIHZrLlMyPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShMUG9pbnRzLCBTMiwgbG9nZ2VyLCBcIm11bHRpZXhwIFMyXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIHZrLlMzPSBhd2FpdCBjdXJ2ZS5HMS5tdWx0aUV4cEFmZmluZShMUG9pbnRzLCBTMywgbG9nZ2VyLCBcIm11bHRpZXhwIFMzXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRTaWdtYShzLCBwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RBcGFyZW5jZVtzXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGZpcnN0UG9zW3NdID0gcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KGxhc3RBcGFyZW5jZVtzXSwgcCpuOHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHY7XG4gICAgICAgICAgICBpZiAocDxkb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IHc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHA8Mipkb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IEZyLm11bCh3LCBrMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHYgPSBGci5tdWwodywgazIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEFwYXJlbmNlW3NdPXY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUxzKHNlY3Rpb25OdW0sIG5hbWUpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uTnVtKTtcbiAgICAgICAgY29uc3QgbD1NYXRoLm1heChuUHVibGljLCAxKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJ1ZmYgPSBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUqbjhyKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KEZyLm9uZSwgaSpuOHIpO1xuICAgICAgICAgICAgYXdhaXQgd3JpdGVQNChidWZmKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9ICR7aX0vJHtsfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhZGVycygpIHtcblxuICAgICAgICAvLyBXcml0ZSB0aGUgaGVhZGVyXG4gICAgICAgIC8vLy8vLy8vLy8vXG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKDIpOyAvLyBQbG9ua1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgICAgICAvLyBXcml0ZSB0aGUgUGxvbmsgaGVhZGVyIHNlY3Rpb25cbiAgICAgICAgLy8vLy8vLy8vLy9cblxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDIpO1xuICAgICAgICBjb25zdCBwcmltZVEgPSBjdXJ2ZS5xO1xuICAgICAgICBjb25zdCBuOHEgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgICAgIGNvbnN0IHByaW1lUiA9IGN1cnZlLnI7XG4gICAgICAgIGNvbnN0IG44ciA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZVIpIC0gMSkgLyA2NCkgKzEpKjg7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhxKTtcbiAgICAgICAgYXdhaXQgd3JpdGVCaWdJbnQoZmRaS2V5LCBwcmltZVEsIG44cSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG44cik7XG4gICAgICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkWktleSwgcHJpbWVSLCBuOHIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihwbG9ua05WYXJzKTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIGJhcnNcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoblB1YmxpYyk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcHVibGljIHZhcnMgKG5vdCBpbmNsdWRpbmcgT05FKVxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihkb21haW5TaXplKTsgICAgICAgICAgICAgICAgICAvLyBkb21haW5TaXplXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQWRkaXRpb25zLmxlbmd0aCk7ICAgICAgICAgICAgICAgICAgLy8gZG9tYWluU2l6ZVxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCk7IFxuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShrMSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShrMik7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlFtKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5RbCkpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUXIpKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlFvKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5RYykpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5TMSkpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUzIpKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlMzKSk7XG5cbiAgICAgICAgbGV0IGJYXzI7XG4gICAgICAgIGJYXzIgPSBhd2FpdCBmZFBUYXUucmVhZChzRzIsIHNlY3Rpb25zUFRhdVszXVswXS5wICsgc0cyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJYXzIpO1xuXG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEsxSzIoKSB7XG4gICAgICAgIGxldCBrMSA9IEZyLnR3bztcbiAgICAgICAgd2hpbGUgKGlzSW5jbHVkZWQoazEsIFtdLCBjaXJQb3dlcikpIEZyLmFkZChrMSwgRnIub25lKTtcbiAgICAgICAgbGV0IGsyID0gRnIuYWRkKGsxLCBGci5vbmUpO1xuICAgICAgICB3aGlsZSAoaXNJbmNsdWRlZChrMiwgW2sxXSwgY2lyUG93ZXIpKSBGci5hZGQoazIsIEZyLm9uZSk7XG4gICAgICAgIHJldHVybiBbazEsIGsyXTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIGlzSW5jbHVkZWQoaywga0FyciwgcG93KSB7XG4gICAgICAgICAgICBjb25zdCBkb21haW5TaXplPSAyKipwb3c7XG4gICAgICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxkb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnIuZXEoaywgdykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxrQXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChGci5lcShrLCBGci5tdWwoa0FycltqXSwgdykpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3Bvd10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jbGFzcyBQcm9vZiB7XG4gICAgY29uc3RydWN0b3IoY3VydmUsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmN1cnZlID0gY3VydmU7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuXG4gICAgICAgIHRoaXMucmVzZXRQcm9vZigpO1xuICAgIH1cblxuICAgIHJlc2V0UHJvb2YoKSB7XG4gICAgICAgIHRoaXMucG9seW5vbWlhbHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmFsdWF0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGFkZFBvbHlub21pYWwoa2V5LCBwb2x5bm9taWFsKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5wb2x5bm9taWFscykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcHJvb2Y6IHBvbHlub21pYWwuJHtrZXl9IGFscmVhZHkgZXhpc3QgaW4gcHJvb2ZgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvbHlub21pYWxzW2tleV0gPSBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIGdldFBvbHlub21pYWwoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzLnBvbHlub21pYWxzKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcHJvb2Y6IHBvbHlub21pYWwgJHtrZXl9IGRvZXMgbm90IGV4aXN0IGluIHByb29mYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9seW5vbWlhbHNba2V5XTtcbiAgICB9XG5cbiAgICBhZGRFdmFsdWF0aW9uKGtleSwgZXZhbHVhdGlvbikge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuZXZhbHVhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHByb29mOiBldmFsdWF0aW9ucy4ke2tleX0gYWxyZWFkeSBleGlzdCBpbiBwcm9vZmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZhbHVhdGlvbnNba2V5XSA9IGV2YWx1YXRpb247XG4gICAgfVxuXG4gICAgZ2V0RXZhbHVhdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuZXZhbHVhdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBwcm9vZjogZXZhbHVhdGlvbiAke2tleX0gZG9lcyBub3QgZXhpc3QgaW4gcHJvb2ZgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0aW9uc1trZXldO1xuICAgIH1cblxuICAgIHRvT2JqZWN0UHJvb2Yoc3BsaXRGaWVsZHMgPSB0cnVlKSB7XG4gICAgICAgIGxldCByZXMgPSBzcGxpdEZpZWxkcyA/IHtwb2x5bm9taWFsczoge30sIGV2YWx1YXRpb25zOiB7fX0gOiB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnBvbHlub21pYWxzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY3VydmUuRzEudG9PYmplY3QodGhpcy5wb2x5bm9taWFsc1trZXldKTtcbiAgICAgICAgICAgIGlmKHNwbGl0RmllbGRzKSB7XG4gICAgICAgICAgICAgICAgcmVzLnBvbHlub21pYWxzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ldmFsdWF0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmN1cnZlLkZyLnRvT2JqZWN0KHRoaXMuZXZhbHVhdGlvbnNba2V5XSk7XG4gICAgICAgICAgICBpZihzcGxpdEZpZWxkcykge1xuICAgICAgICAgICAgICAgIHJlcy5ldmFsdWF0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnJvbU9iamVjdFByb29mKG9iamVjdFByb29mKSB7XG4gICAgICAgIHRoaXMucmVzZXRQcm9vZigpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdFByb29mLnBvbHlub21pYWxzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvbHlub21pYWxzW2tleV0gPSB0aGlzLmN1cnZlLkcxLmZyb21PYmplY3Qob2JqZWN0UHJvb2YucG9seW5vbWlhbHNba2V5XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG9iamVjdFByb29mLmV2YWx1YXRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2YWx1YXRpb25zW2tleV0gPSB0aGlzLmN1cnZlLkZyLmZyb21PYmplY3Qob2JqZWN0UHJvb2YuZXZhbHVhdGlvbnNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8gU0hBMyAoa2VjY2FrKSBpcyBiYXNlZCBvbiBhIG5ldyBkZXNpZ246IGJhc2ljYWxseSwgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuLy8gSXQncyBjYWxsZWQgYSBzcG9uZ2UgZnVuY3Rpb24uXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBTSEEzX1BJID0gW107XG5jb25zdCBTSEEzX1JPVEwgPSBbXTtcbmNvbnN0IF9TSEEzX0lPVEEgPSBbXTtcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCAvKiBAX19QVVJFX18gKi8gQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gLyogQF9fUFVSRV9fICovIHNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJIKGgsIGwsIHMpIDogcm90bFNIKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkwoaCwgbCwgcykgOiByb3RsU0woaCwgbCwgcykpO1xuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXG5mdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5jbGFzcyBLZWNjYWsgZXh0ZW5kcyBIYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgIG51bWJlcihvdXRwdXRMZW4pO1xuICAgICAgICAvLyAxNjAwID0gNXg1IG1hdHJpeCBvZiA2NGJpdC4gIDE2MDAgYml0cyA9PT0gMjAwIGJ5dGVzXG4gICAgICAgIGlmICgwID49IHRoaXMuYmxvY2tMZW4gfHwgdGhpcy5ibG9ja0xlbiA+PSAyMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYTMgc3VwcG9ydHMgb25seSBrZWNjYWstZjE2MDAgZnVuY3Rpb24nKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KDIwMCk7XG4gICAgICAgIHRoaXMuc3RhdGUzMiA9IHUzMih0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICBpZiAoIWlzTEUpXG4gICAgICAgICAgICBieXRlU3dhcDMyKHRoaXMuc3RhdGUzMik7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIGlmICghaXNMRSlcbiAgICAgICAgICAgIGJ5dGVTd2FwMzIodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIG51bWJlcihieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbi8qKlxuICoga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuY29uc3QgUE9MWU5PTUlBTCA9IDA7XG5jb25zdCBTQ0FMQVIgPSAxO1xuXG5jbGFzcyBLZWNjYWsyNTZUcmFuc2NyaXB0IHtcbiAgICBjb25zdHJ1Y3RvcihjdXJ2ZSkge1xuICAgICAgICB0aGlzLkcxID0gY3VydmUuRzE7XG4gICAgICAgIHRoaXMuRnIgPSBjdXJ2ZS5GcjtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIH1cblxuICAgIGFkZFBvbENvbW1pdG1lbnQocG9seW5vbWlhbENvbW1pdG1lbnQpIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2goe3R5cGU6IFBPTFlOT01JQUwsIGRhdGE6IHBvbHlub21pYWxDb21taXRtZW50fSk7XG4gICAgfVxuXG4gICAgYWRkU2NhbGFyKHNjYWxhcikge1xuICAgICAgICB0aGlzLmRhdGEucHVzaCh7dHlwZTogU0NBTEFSLCBkYXRhOiBzY2FsYXJ9KTtcbiAgICB9XG5cbiAgICBnZXRDaGFsbGVuZ2UoKSB7XG4gICAgICAgIGlmKDAgPT09IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktlY2NhazI1NlRyYW5zY3JpcHQ6IE5vIGRhdGEgdG8gZ2VuZXJhdGUgYSB0cmFuc2NyaXB0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5Qb2x5bm9taWFscyA9IDA7XG4gICAgICAgIGxldCBuU2NhbGFycyA9IDA7XG5cbiAgICAgICAgdGhpcy5kYXRhLmZvckVhY2goZWxlbWVudCA9PiBQT0xZTk9NSUFMID09PSBlbGVtZW50LnR5cGUgPyBuUG9seW5vbWlhbHMrKyA6IG5TY2FsYXJzKyspO1xuXG4gICAgICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheShuU2NhbGFycyAqIHRoaXMuRnIubjggKyBuUG9seW5vbWlhbHMgKiB0aGlzLkcxLkYubjggKiAyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChQT0xZTk9NSUFMID09PSB0aGlzLmRhdGFbaV0udHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuRzEudG9ScHJVbmNvbXByZXNzZWQoYnVmZmVyLCBvZmZzZXQsIHRoaXMuZGF0YVtpXS5kYXRhKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5HMS5GLm44ICogMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Gci50b1JwckJFKGJ1ZmZlciwgb2Zmc2V0LCB0aGlzLmRhdGFbaV0uZGF0YSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuRnIubjg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZSA9IFNjYWxhci5mcm9tUnByQkUoa2VjY2FrXzI1NihidWZmZXIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuRnIuZSh2YWx1ZSk7XG4gICAgfVxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jbGFzcyBNdWxaIHtcbiAgICBzdGF0aWMgZ2V0WjEoRnIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEZyLnplcm8sXG4gICAgICAgICAgICBGci5hZGQoRnIuZSgtMSksIEZyLndbMl0pLFxuICAgICAgICAgICAgRnIuZSgtMiksXG4gICAgICAgICAgICBGci5zdWIoRnIuZSgtMSksIEZyLndbMl0pLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRaMihGcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgRnIuemVybyxcbiAgICAgICAgICAgIEZyLmFkZChGci56ZXJvLCBGci5tdWwoRnIuZSgtMiksIEZyLndbMl0pKSxcbiAgICAgICAgICAgIEZyLmUoNCksXG4gICAgICAgICAgICBGci5zdWIoRnIuemVybywgRnIubXVsKEZyLmUoLTIpLCBGci53WzJdKSksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFozKEZyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBGci56ZXJvLFxuICAgICAgICAgICAgRnIuYWRkKEZyLmUoMiksIEZyLm11bChGci5lKDIpLCBGci53WzJdKSksXG4gICAgICAgICAgICBGci5lKC04KSxcbiAgICAgICAgICAgIEZyLnN1YihGci5lKDIpLCBGci5tdWwoRnIuZSgyKSwgRnIud1syXSkpLFxuICAgICAgICBdO1xuXG4gICAgfVxuXG4gICAgc3RhdGljIG11bDIoYSwgYiwgYXAsIGJwLCBwLCBGcikge1xuICAgICAgICBjb25zdCBaMSA9IHRoaXMuZ2V0WjEoRnIpO1xuICAgICAgICBsZXQgciwgcno7XG5cbiAgICAgICAgY29uc3QgYV9iID0gRnIubXVsKGEsIGIpO1xuICAgICAgICBjb25zdCBhX2JwID0gRnIubXVsKGEsIGJwKTtcbiAgICAgICAgY29uc3QgYXBfYiA9IEZyLm11bChhcCwgYik7XG4gICAgICAgIGNvbnN0IGFwX2JwID0gRnIubXVsKGFwLCBicCk7XG5cbiAgICAgICAgciA9IGFfYjtcblxuICAgICAgICBsZXQgYTAgPSBGci5hZGQoYV9icCwgYXBfYik7XG5cbiAgICAgICAgbGV0IGExID0gYXBfYnA7XG5cbiAgICAgICAgcnogPSBhMDtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjFbcF0sIGExKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3IsIHJ6XTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbXVsMyhhLCBiLCBjLCBhcCwgYnAsIGNwLCBwLCBGcikge1xuICAgICAgICBjb25zdCBaMSA9IHRoaXMuZ2V0WjEoRnIpO1xuICAgICAgICBjb25zdCBaMiA9IHRoaXMuZ2V0WjIoRnIpO1xuICAgICAgICBsZXQgciwgcno7XG5cbiAgICAgICAgY29uc3QgYV9iID0gRnIubXVsKGEsIGIpO1xuICAgICAgICBjb25zdCBhX2JwID0gRnIubXVsKGEsIGJwKTtcbiAgICAgICAgY29uc3QgYXBfYiA9IEZyLm11bChhcCwgYik7XG4gICAgICAgIGNvbnN0IGFwX2JwID0gRnIubXVsKGFwLCBicCk7XG5cbiAgICAgICAgciA9IEZyLm11bChhX2IsIGMpO1xuXG4gICAgICAgIGxldCBhMCA9IEZyLm11bChhcF9iLCBjKTtcbiAgICAgICAgYTAgPSBGci5hZGQoYTAsIEZyLm11bChhX2JwLCBjKSk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9iLCBjcCkpO1xuXG4gICAgICAgIGxldCBhMSA9IEZyLm11bChhcF9icCwgYyk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYV9icCwgY3ApKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhcF9iLCBjcCkpO1xuXG4gICAgICAgIHJ6ID0gYTA7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBjb25zdCBhMiA9IEZyLm11bChhcF9icCwgY3ApO1xuICAgICAgICAgICAgcnogPSBGci5hZGQocnosIEZyLm11bChaMVtwXSwgYTEpKTtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjJbcF0sIGEyKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3IsIHJ6XTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbXVsNChhLCBiLCBjLCBkLCBhcCwgYnAsIGNwLCBkcCwgcCwgRnIpIHtcbiAgICAgICAgY29uc3QgWjEgPSB0aGlzLmdldFoxKEZyKTtcbiAgICAgICAgY29uc3QgWjIgPSB0aGlzLmdldFoyKEZyKTtcbiAgICAgICAgY29uc3QgWjMgPSB0aGlzLmdldFozKEZyKTtcblxuICAgICAgICBsZXQgciwgcno7XG5cbiAgICAgICAgY29uc3QgYV9iID0gRnIubXVsKGEsIGIpO1xuICAgICAgICBjb25zdCBhX2JwID0gRnIubXVsKGEsIGJwKTtcbiAgICAgICAgY29uc3QgYXBfYiA9IEZyLm11bChhcCwgYik7XG4gICAgICAgIGNvbnN0IGFwX2JwID0gRnIubXVsKGFwLCBicCk7XG5cbiAgICAgICAgY29uc3QgY19kID0gRnIubXVsKGMsIGQpO1xuICAgICAgICBjb25zdCBjX2RwID0gRnIubXVsKGMsIGRwKTtcbiAgICAgICAgY29uc3QgY3BfZCA9IEZyLm11bChjcCwgZCk7XG4gICAgICAgIGNvbnN0IGNwX2RwID0gRnIubXVsKGNwLCBkcCk7XG5cbiAgICAgICAgciA9IEZyLm11bChhX2IsIGNfZCk7XG5cbiAgICAgICAgbGV0IGEwID0gRnIubXVsKGFwX2IsIGNfZCk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9icCwgY19kKSk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9iLCBjcF9kKSk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9iLCBjX2RwKSk7XG5cbiAgICAgICAgbGV0IGExID0gRnIubXVsKGFwX2JwLCBjX2QpO1xuICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFwX2IsIGNwX2QpKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhcF9iLCBjX2RwKSk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYV9icCwgY3BfZCkpO1xuICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFfYnAsIGNfZHApKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhX2IsIGNwX2RwKSk7XG5cbiAgICAgICAgbGV0IGEyID0gRnIubXVsKGFfYnAsIGNwX2RwKTtcbiAgICAgICAgYTIgPSBGci5hZGQoYTIsIEZyLm11bChhcF9iLCBjcF9kcCkpO1xuICAgICAgICBhMiA9IEZyLmFkZChhMiwgRnIubXVsKGFwX2JwLCBjX2RwKSk7XG4gICAgICAgIGEyID0gRnIuYWRkKGEyLCBGci5tdWwoYXBfYnAsIGNwX2QpKTtcblxuICAgICAgICBsZXQgYTMgPSBGci5tdWwoYXBfYnAsIGNwX2RwKTtcblxuICAgICAgICByeiA9IGEwO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgcnogPSBGci5hZGQocnosIEZyLm11bChaMVtwXSwgYTEpKTtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjJbcF0sIGEyKSk7XG4gICAgICAgICAgICByeiA9IEZyLmFkZChyeiwgRnIubXVsKFozW3BdLCBhMykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtyLCByel07XG4gICAgfVxufVxuXG5jb25zdCBaS0VZX1BMX0FERElUSU9OU19TRUNUSU9OID0gMztcbmNvbnN0IFpLRVlfUExfQV9NQVBfU0VDVElPTiA9IDQ7XG5jb25zdCBaS0VZX1BMX0JfTUFQX1NFQ1RJT04gPSA1O1xuY29uc3QgWktFWV9QTF9DX01BUF9TRUNUSU9OID0gNjtcbmNvbnN0IFpLRVlfUExfUU1fU0VDVElPTiA9IDc7XG5jb25zdCBaS0VZX1BMX1FMX1NFQ1RJT04gPSA4O1xuY29uc3QgWktFWV9QTF9RUl9TRUNUSU9OID0gOTtcbmNvbnN0IFpLRVlfUExfUU9fU0VDVElPTiA9IDEwO1xuY29uc3QgWktFWV9QTF9RQ19TRUNUSU9OID0gMTE7XG5jb25zdCBaS0VZX1BMX1NJR01BX1NFQ1RJT04gPSAxMjtcbmNvbnN0IFpLRVlfUExfTEFHUkFOR0VfU0VDVElPTiA9IDEzO1xuY29uc3QgWktFWV9QTF9QVEFVX1NFQ1RJT04gPSAxNDtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuY2xhc3MgUG9seW5vbWlhbCB7XG4gICAgY29uc3RydWN0b3IoY29lZmZpY2llbnRzLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuY29lZiA9IGNvZWZmaWNpZW50cztcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICB0aGlzLkZyID0gY3VydmUuRnI7XG4gICAgICAgIHRoaXMuRzEgPSBjdXJ2ZS5HMTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIGZyb21FdmFsdWF0aW9ucyhidWZmZXIsIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgbGV0IGNvZWZmaWNpZW50cyA9IGF3YWl0IGN1cnZlLkZyLmlmZnQoYnVmZmVyKTtcblxuICAgICAgICByZXR1cm4gbmV3IFBvbHlub21pYWwoY29lZmZpY2llbnRzLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUNvZWZmaWNpZW50c0FycmF5KGFycmF5LCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgIGxldCBidWZmID0gYXJyYXkubGVuZ3RoID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKGFycmF5Lmxlbmd0aCAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KGFycmF5Lmxlbmd0aCAqIEZyLm44KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgYnVmZi5zZXQoYXJyYXlbaV0sIGkgKiBGci5uOCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGJ1ZmYsIGN1cnZlLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tUG9seW5vbWlhbChwb2x5bm9taWFsLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSBwb2x5bm9taWFsLmxlbmd0aCgpO1xuICAgICAgICBsZXQgRnIgPSBjdXJ2ZS5GcjtcblxuICAgICAgICBsZXQgYnVmZiA9IGxlbmd0aCA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcihsZW5ndGggKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShsZW5ndGggKiBGci5uOCk7XG4gICAgICAgIGJ1ZmYuc2V0KHBvbHlub21pYWwuY29lZi5zbGljZSgpLCAwKTtcblxuICAgICAgICByZXR1cm4gbmV3IFBvbHlub21pYWwoYnVmZiwgY3VydmUsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgaXNFcXVhbChwb2x5bm9taWFsKSB7XG4gICAgICAgIGNvbnN0IGRlZ3JlZSA9IHRoaXMuZGVncmVlKCk7XG4gICAgICAgIGlmIChkZWdyZWUgIT09IHBvbHlub21pYWwuZGVncmVlKCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZ3JlZSArIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLkZyLmVxKHRoaXMuZ2V0Q29lZihpKSwgcG9seW5vbWlhbC5nZXRDb2VmKGkpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgYmxpbmRDb2VmZmljaWVudHMoYmxpbmRpbmdGYWN0b3JzKSB7XG4gICAgICAgIGJsaW5kaW5nRmFjdG9ycyA9IGJsaW5kaW5nRmFjdG9ycyB8fCBbXTtcblxuICAgICAgICBjb25zdCBibGluZGVkQ29lZmZpY2llbnRzID0gKHRoaXMubGVuZ3RoKCkgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigodGhpcy5sZW5ndGgoKSArIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGgpICogdGhpcy5Gci5uOCkgOlxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoKHRoaXMubGVuZ3RoKCkgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSAqIHRoaXMuRnIubjgpO1xuXG4gICAgICAgIGJsaW5kZWRDb2VmZmljaWVudHMuc2V0KHRoaXMuY29lZiwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNldChcbiAgICAgICAgICAgICAgICB0aGlzLkZyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRlZENvZWZmaWNpZW50cy5zbGljZSgodGhpcy5sZW5ndGgoKSArIGkpICogdGhpcy5Gci5uOCwgKHRoaXMubGVuZ3RoKCkgKyBpICsgMSkgKiB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRpbmdGYWN0b3JzW2ldXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAodGhpcy5sZW5ndGgoKSArIGkpICogdGhpcy5Gci5uOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJsaW5kZWRDb2VmZmljaWVudHMuc2V0KFxuICAgICAgICAgICAgICAgIHRoaXMuRnIuc3ViKFxuICAgICAgICAgICAgICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNsaWNlKGkgKiB0aGlzLkZyLm44LCAoaSArIDEpICogdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgICAgIGJsaW5kaW5nRmFjdG9yc1tpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaSAqIHRoaXMuRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2VmID0gYmxpbmRlZENvZWZmaWNpZW50cztcbiAgICB9XG5cbiAgICBnZXRDb2VmKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGlfbjggPSBpbmRleCAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgaWYgKGlfbjggKyB0aGlzLkZyLm44ID4gdGhpcy5jb2VmLmJ5dGVMZW5ndGgpIHJldHVybiB0aGlzLkZyLnplcm87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCk7XG4gICAgfVxuXG4gICAgc2V0Q29lZihpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4ID4gKHRoaXMubGVuZ3RoKCkgLSAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29lZiBpbmRleCBpcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2VmLnNldCh2YWx1ZSwgaW5kZXggKiB0aGlzLkZyLm44KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgdG80VChidWZmZXIsIGRvbWFpblNpemUsIGJsaW5kaW5nRmFjdG9ycywgRnIpIHtcbiAgICAgICAgYmxpbmRpbmdGYWN0b3JzID0gYmxpbmRpbmdGYWN0b3JzIHx8IFtdO1xuICAgICAgICBsZXQgYSA9IGF3YWl0IEZyLmlmZnQoYnVmZmVyKTtcblxuICAgICAgICBjb25zdCBhNCA9IChkb21haW5TaXplICogNCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSAqIDQgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShkb21haW5TaXplICogNCAqIEZyLm44KTtcbiAgICAgICAgYTQuc2V0KGEsIDApO1xuXG4gICAgICAgIGNvbnN0IEE0ID0gYXdhaXQgRnIuZmZ0KGE0KTtcblxuICAgICAgICBpZiAoYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFthLCBBNF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhMSA9IGRvbWFpblNpemUgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKChkb21haW5TaXplICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCkgKiBGci5uOCkgOlxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoKGRvbWFpblNpemUgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSAqIEZyLm44KTtcblxuICAgICAgICBhMS5zZXQoYSwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhMS5zZXQoXG4gICAgICAgICAgICAgICAgRnIuYWRkKFxuICAgICAgICAgICAgICAgICAgICBhMS5zbGljZSgoZG9tYWluU2l6ZSArIGkpICogRnIubjgsIChkb21haW5TaXplICsgaSArIDEpICogRnIubjgpLFxuICAgICAgICAgICAgICAgICAgICBibGluZGluZ0ZhY3RvcnNbaV1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChkb21haW5TaXplICsgaSkgKiBGci5uOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGExLnNldChcbiAgICAgICAgICAgICAgICBGci5zdWIoXG4gICAgICAgICAgICAgICAgICAgIGExLnNsaWNlKGkgKiBGci5uOCwgKGkgKyAxKSAqIEZyLm44KSxcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRpbmdGYWN0b3JzW2ldXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpICogRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2ExLCBBNF07XG4gICAgfVxuXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5jb2VmLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44O1xuICAgICAgICBpZiAobGVuZ3RoICE9PSBNYXRoLmZsb29yKHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uOCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHlub21pYWwgY29lZmZpY2llbnRzIGJ1ZmZlciBoYXMgaW5jb3JyZWN0IHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9nZ2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlBvbHlub21pYWwgaGFzIGxlbmd0aCB6ZXJvXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuXG4gICAgZGVncmVlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGgoKSAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIGlmICghdGhpcy5Gci5lcSh0aGlzLkZyLnplcm8sIHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBldmFsdWF0ZShwb2ludCkge1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5Gci56ZXJvO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmRlZ3JlZSgpICsgMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2VmZmljaWVudCA9IHRoaXMuY29lZi5zbGljZShpX244IC0gdGhpcy5Gci5uOCwgaV9uOCk7XG4gICAgICAgICAgICByZXMgPSB0aGlzLkZyLmFkZChjdXJyZW50Q29lZmZpY2llbnQsIHRoaXMuRnIubXVsKHJlcywgcG9pbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZmFzdEV2YWx1YXRlKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcbiAgICAgICAgbGV0IG5UaHJlYWRzID0gMztcblxuICAgICAgICBsZXQgbkNvZWZzID0gdGhpcy5kZWdyZWUoKSArIDE7XG4gICAgICAgIGxldCBjb2Vmc1RocmVhZCA9IHBhcnNlSW50KG5Db2VmcyAvIG5UaHJlYWRzKTtcbiAgICAgICAgbGV0IHJlc2lkdWFsQ29lZnMgPSBuQ29lZnMgLSBjb2Vmc1RocmVhZCAqIG5UaHJlYWRzO1xuXG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgbGV0IHhOID0gW107XG5cbiAgICAgICAgeE5bMF0gPSBGci5vbmU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuVGhyZWFkczsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBGci56ZXJvO1xuXG4gICAgICAgICAgICBsZXQgbkNvZWZzID0gaSA9PT0gKG5UaHJlYWRzIC0gMSkgPyBjb2Vmc1RocmVhZCArIHJlc2lkdWFsQ29lZnMgOiBjb2Vmc1RocmVhZDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBuQ29lZnM7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBGci5hZGQodGhpcy5nZXRDb2VmKChpICogY29lZnNUaHJlYWQpICsgaiAtIDEpLCBGci5tdWwocmVzW2ldLCBwb2ludCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHhOWzBdID0gRnIubXVsKHhOWzBdLCBwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5UaHJlYWRzOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1swXSA9IEZyLmFkZChyZXNbMF0sIEZyLm11bCh4TltpIC0gMV0sIHJlc1tpXSkpO1xuICAgICAgICAgICAgeE5baV0gPSBGci5tdWwoeE5baSAtIDFdLCB4TlswXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzWzBdO1xuICAgIH1cblxuICAgIGFkZChwb2x5bm9taWFsLCBibGluZGluZ1ZhbHVlKSB7XG4gICAgICAgIGxldCBvdGhlciA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwb2x5bm9taWFsLmxlbmd0aCgpID4gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgb3RoZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IHBvbHlMZW5ndGggPSBwb2x5bm9taWFsLmxlbmd0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHRoaXNMZW5ndGgsIHBvbHlMZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgY29uc3QgYSA9IGkgPCB0aGlzTGVuZ3RoID8gdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSA6IHRoaXMuRnIuemVybztcbiAgICAgICAgICAgIGxldCBiID0gaSA8IHBvbHlMZW5ndGggPyBwb2x5bm9taWFsLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpIDogdGhpcy5Gci56ZXJvO1xuXG4gICAgICAgICAgICBpZiAoYmxpbmRpbmdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXMuRnIubXVsKGIsIGJsaW5kaW5nVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgcG9seW5vbWlhbC5jb2VmLnNldCh0aGlzLkZyLmFkZChhLCBiKSwgaV9uOCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5hZGQoYSwgYiksIGlfbjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29lZjtcbiAgICAgICAgICAgIHRoaXMuY29lZiA9IHBvbHlub21pYWwuY29lZjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN1Yihwb2x5bm9taWFsLCBibGluZGluZ1ZhbHVlKSB7XG4gICAgICAgIGxldCBvdGhlciA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwb2x5bm9taWFsLmxlbmd0aCgpID4gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgb3RoZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IHBvbHlMZW5ndGggPSBwb2x5bm9taWFsLmxlbmd0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHRoaXNMZW5ndGgsIHBvbHlMZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgY29uc3QgYSA9IGkgPCB0aGlzTGVuZ3RoID8gdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSA6IHRoaXMuRnIuemVybztcbiAgICAgICAgICAgIGxldCBiID0gaSA8IHBvbHlMZW5ndGggPyBwb2x5bm9taWFsLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpIDogdGhpcy5Gci56ZXJvO1xuXG4gICAgICAgICAgICBpZiAoYmxpbmRpbmdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXMuRnIubXVsKGIsIGJsaW5kaW5nVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgcG9seW5vbWlhbC5jb2VmLnNldCh0aGlzLkZyLnN1YihhLCBiKSwgaV9uOCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5zdWIoYSwgYiksIGlfbjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29lZjtcbiAgICAgICAgICAgIHRoaXMuY29lZiA9IHBvbHlub21pYWwuY29lZjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11bFNjYWxhcih2YWx1ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIubXVsKHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCksIHZhbHVlKSwgaV9uOCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRTY2FsYXIodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gMCA9PT0gdGhpcy5sZW5ndGgoKSA/IHRoaXMuRnIuemVybyA6IHRoaXMuY29lZi5zbGljZSgwLCB0aGlzLkZyLm44KTtcbiAgICAgICAgdGhpcy5jb2VmLnNldCh0aGlzLkZyLmFkZChjdXJyZW50VmFsdWUsIHZhbHVlKSwgMCk7XG4gICAgfVxuXG4gICAgc3ViU2NhbGFyKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IDAgPT09IHRoaXMubGVuZ3RoKCkgPyB0aGlzLkZyLnplcm8gOiB0aGlzLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCk7XG4gICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5zdWIoY3VycmVudFZhbHVlLCB2YWx1ZSksIDApO1xuICAgIH1cblxuICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgcG9seW5vbWlhbCBieSB0aGUgcG9seW5vbWlhbCAoWCAtIHZhbHVlKVxuICAgIGJ5WFN1YlZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcbiAgICAgICAgY29uc3QgcmVzaXplID0gIUZyLmVxKEZyLnplcm8sIHRoaXMuZ2V0Q29lZih0aGlzLmxlbmd0aCgpIC0gMSkpO1xuXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlc2l6ZSA/IHRoaXMubGVuZ3RoKCkgKyAxIDogdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgYnVmZiA9IGxlbmd0aCA+IDIgPDwgMTQgPyBuZXcgQmlnQnVmZmVyKGxlbmd0aCAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KGxlbmd0aCAqIEZyLm44KTtcbiAgICAgICAgbGV0IHBvbCA9IG5ldyBQb2x5bm9taWFsKGJ1ZmYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICAvLyBTdGVwIDA6IFNldCBjdXJyZW50IGNvZWZmaWNpZW50cyB0byB0aGUgbmV3IGJ1ZmZlciBzaGlmdGVkIG9uZSBwb3NpdGlvblxuICAgICAgICBwb2wuY29lZi5zZXQodGhpcy5jb2VmLnNsaWNlKDAsIChsZW5ndGggLSAxKSAqIEZyLm44KSwgMzIpO1xuXG4gICAgICAgIC8vIFN0ZXAgMTogbXVsdGlwbHkgZWFjaCBjb2VmZmljaWVudCBieSAoLXZhbHVlKVxuICAgICAgICB0aGlzLm11bFNjYWxhcihGci5uZWcodmFsdWUpKTtcblxuICAgICAgICAvLyBTdGVwIDI6IEFkZCBjdXJyZW50IHBvbHlub21pYWwgdG8gZGVzdGluYXRpb24gcG9seW5vbWlhbFxuICAgICAgICBwb2wuYWRkKHRoaXMpO1xuXG4gICAgICAgIC8vIFN3YXAgYnVmZmVyc1xuICAgICAgICB0aGlzLmNvZWYgPSBwb2wuY29lZjtcbiAgICB9XG5cbiAgICAvLyBNdWx0aXBseSBjdXJyZW50IHBvbHlub21pYWwgYnkgdGhlIHBvbHlub21pYWwgKFhebiArIHZhbHVlKVxuICAgIGJ5WE5TdWJWYWx1ZShuLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9ICEodGhpcy5sZW5ndGgoKSAtIG4gLSAxID49IHRoaXMuZGVncmVlKCkpO1xuXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlc2l6ZSA/IHRoaXMubGVuZ3RoKCkgKyBuIDogdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgYnVmZiA9IGxlbmd0aCA+IDIgPDwgMTQgPyBuZXcgQmlnQnVmZmVyKGxlbmd0aCAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KGxlbmd0aCAqIEZyLm44KTtcbiAgICAgICAgbGV0IHBvbCA9IG5ldyBQb2x5bm9taWFsKGJ1ZmYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICAvLyBTdGVwIDA6IFNldCBjdXJyZW50IGNvZWZmaWNpZW50cyB0byB0aGUgbmV3IGJ1ZmZlciBzaGlmdGVkIG9uZSBwb3NpdGlvblxuICAgICAgICBwb2wuY29lZi5zZXQodGhpcy5jb2VmLnNsaWNlKDAsICh0aGlzLmRlZ3JlZSgpICsgMSkgKiAzMiwgKSwgbiAqIDMyKTtcblxuICAgICAgICAvLyBTdGVwIDE6IG11bHRpcGx5IGVhY2ggY29lZmZpY2llbnQgYnkgKC0gdmFsdWUpXG4gICAgICAgIHRoaXMubXVsU2NhbGFyKHZhbHVlKTtcblxuICAgICAgICAvLyBTdGVwIDI6IEFkZCBjdXJyZW50IHBvbHlub21pYWwgdG8gZGVzdGluYXRpb24gcG9seW5vbWlhbFxuICAgICAgICBwb2wuYWRkKHRoaXMpO1xuXG4gICAgICAgIC8vIFN3YXAgYnVmZmVyc1xuICAgICAgICB0aGlzLmNvZWYgPSBwb2wuY29lZjtcbiAgICB9XG5cbiAgICAvLyBFdWNsaWRlYW4gZGl2aXNpb25cbiAgICBkaXZCeShwb2x5bm9taWFsKSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcbiAgICAgICAgY29uc3QgZGVncmVlQSA9IHRoaXMuZGVncmVlKCk7XG4gICAgICAgIGNvbnN0IGRlZ3JlZUIgPSBwb2x5bm9taWFsLmRlZ3JlZSgpO1xuXG4gICAgICAgIGxldCBwb2xSID0gbmV3IFBvbHlub21pYWwodGhpcy5jb2VmLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgdGhpcy5jb2VmID0gdGhpcy5sZW5ndGgoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gZGVncmVlQSAtIGRlZ3JlZUI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvZWYoaSwgRnIuZGl2KHBvbFIuZ2V0Q29lZihpICsgZGVncmVlQiksIHBvbHlub21pYWwuZ2V0Q29lZihkZWdyZWVCKSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gZGVncmVlQjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcG9sUi5zZXRDb2VmKGkgKyBqLCBGci5zdWIocG9sUi5nZXRDb2VmKGkgKyBqKSwgRnIubXVsKHRoaXMuZ2V0Q29lZihpKSwgcG9seW5vbWlhbC5nZXRDb2VmKGopKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbFI7XG4gICAgfVxuXG4gICAgLy8gRGl2aXNpb24gYnkgYSBQb2x5bm9taWFsIG9mIHRoZSBmb3JtICh4Xm0gLSBiZXRhKVxuICAgIGRpdkJ5TW9uaWMobSwgYmV0YSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG5cbiAgICAgICAgbGV0IGQgPSB0aGlzLmRlZ3JlZSgpO1xuXG4gICAgICAgIGxldCBidWZmZXIgPSB0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogRnIubjgpO1xuICAgICAgICBsZXQgcXVvdGllbnQgPSBuZXcgUG9seW5vbWlhbChidWZmZXIsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICBsZXQgYkFyciA9IFtdO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgbSBsZWFkaW5nIGNvZWZmaWNpZW50cyBvZiB0aGlzIHRvIHF1b3RpZW50XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICBxdW90aWVudC5zZXRDb2VmKChkIC0gaSkgLSBtLCB0aGlzLmdldENvZWYoZCAtIGkpKTtcbiAgICAgICAgICAgIGJBcnJbaV0gPSB0aGlzLmdldENvZWYoZCAtIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5UaHJlYWRzID0gbTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuVGhyZWFkczsgaysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZCAtIDIgKiBtIC0gazsgaSA+PSAwOyBpID0gaSAtIG5UaHJlYWRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwKSBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgaWR4ID0gaztcbiAgICAgICAgICAgICAgICBiQXJyW2lkeF0gPSBGci5hZGQodGhpcy5nZXRDb2VmKGkgKyBtKSwgRnIubXVsKGJBcnJbaWR4XSwgYmV0YSkpO1xuXG4gICAgICAgICAgICAgICAgcXVvdGllbnQuc2V0Q29lZihpLCBiQXJyW2lkeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2VmID0gcXVvdGllbnQuY29lZjtcbiAgICB9XG5cbiAgICBkaXZCeVZhbmlzaGluZyhuLCBiZXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZ3JlZSgpIDwgbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGl2QnlWYW5pc2hpbmcgcG9seW5vbWlhbCBkaXZpc29yIG11c3QgYmUgb2YgZGVncmVlIGxvd2VyIHRoYW4gdGhlIGRpdmlkZW5kIHBvbHlub21pYWxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG5cbiAgICAgICAgbGV0IHBvbFIgPSBuZXcgUG9seW5vbWlhbCh0aGlzLmNvZWYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICB0aGlzLmNvZWYgPSB0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogRnIubjgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxlbmd0aCgpIC0gMTsgaSA+PSBuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBsZWFkaW5nQ29lZiA9IHBvbFIuZ2V0Q29lZihpKTtcbiAgICAgICAgICAgIGlmIChGci5lcShGci56ZXJvLCBsZWFkaW5nQ29lZikpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBwb2xSLnNldENvZWYoaSwgRnIuemVybyk7XG4gICAgICAgICAgICBwb2xSLnNldENvZWYoaSAtIG4sIEZyLmFkZChwb2xSLmdldENvZWYoaSAtIG4pLCBGci5tdWwoYmV0YSwgbGVhZGluZ0NvZWYpKSk7XG4gICAgICAgICAgICB0aGlzLnNldENvZWYoaSAtIG4sIEZyLmFkZCh0aGlzLmdldENvZWYoaSAtIG4pLCBsZWFkaW5nQ29lZikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbFI7XG4gICAgfVxuXG4gICAgZGl2QnlWYW5pc2hpbmcyKG0sIGJldGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVncmVlKCkgPCBtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXZCeVZhbmlzaGluZyBwb2x5bm9taWFsIGRpdmlzb3IgbXVzdCBiZSBvZiBkZWdyZWUgbG93ZXIgdGhhbiB0aGUgZGl2aWRlbmQgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcblxuICAgICAgICBsZXQgcG9sUiA9IG5ldyBQb2x5bm9taWFsKHRoaXMuY29lZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIodGhpcy5sZW5ndGgoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKiBGci5uOCk7XG5cbiAgICAgICAgbGV0IG5UaHJlYWRzID0gMztcbiAgICAgICAgbGV0IG5Ub3RhbCA9IHRoaXMubGVuZ3RoKCkgLSBtO1xuICAgICAgICBsZXQgbkVsZW1lbnRzQ2h1bmsgPSBNYXRoLmZsb29yKG5Ub3RhbCAvIG5UaHJlYWRzKTtcbiAgICAgICAgbGV0IG5FbGVtZW50c0xhc3QgPSBuVG90YWwgLSAoblRocmVhZHMgLSAxKSAqIG5FbGVtZW50c0NodW5rO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKG5Ub3RhbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKG5FbGVtZW50c0NodW5rICsgXCIgIFwiICsgbkVsZW1lbnRzTGFzdCk7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgblRocmVhZHM7IGsrKykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCI+IFRocmVhZCBcIiArIGspO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IChrID09PSAwID8gbkVsZW1lbnRzTGFzdCA6IG5FbGVtZW50c0NodW5rKTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBpZHhEc3QgPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAoayAhPT0gMCkgaWR4RHN0ICs9IChrIC0gMSkgKiBuRWxlbWVudHNDaHVuayArIG5FbGVtZW50c0xhc3Q7XG4gICAgICAgICAgICAgICAgbGV0IGlkeFNyYyA9IGlkeERzdCArIG07XG5cbiAgICAgICAgICAgICAgICBsZXQgbGVhZGluZ0NvZWYgPSBwb2xSLmdldENvZWYoaWR4U3JjKTtcbiAgICAgICAgICAgICAgICBpZiAoRnIuZXEoRnIuemVybywgbGVhZGluZ0NvZWYpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpZHhTcmMsIEZyLnplcm8pO1xuICAgICAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpZHhEc3QsIEZyLmFkZChwb2xSLmdldENvZWYoaWR4RHN0KSwgRnIubXVsKGJldGEsIGxlYWRpbmdDb2VmKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29lZihpZHhEc3QsIEZyLmFkZCh0aGlzLmdldENvZWYoaWR4RHN0KSwgbGVhZGluZ0NvZWYpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpZHhEc3QgKyBcIiA8LS0gXCIgKyBpZHhTcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmludCgpO1xuICAgICAgICByZXR1cm4gcG9sUjtcbiAgICB9XG5cbiAgICBmYXN0RGl2QnlWYW5pc2hpbmcoZGF0YSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGxldCBtID0gZGF0YVtpXVswXTtcbiAgICAgICAgICAgIGxldCBiZXRhID0gZGF0YVtpXVsxXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZGVncmVlKCkgPCBtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGl2QnlWYW5pc2hpbmcgcG9seW5vbWlhbCBkaXZpc29yIG11c3QgYmUgb2YgZGVncmVlIGxvd2VyIHRoYW4gdGhlIGRpdmlkZW5kIHBvbHlub21pYWxcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBuVGhyZWFkcyA9IDU7XG4gICAgICAgICAgICBsZXQgbkVsZW1lbnRzID0gdGhpcy5sZW5ndGgoKSAtIG07XG4gICAgICAgICAgICBsZXQgbkVsZW1lbnRzQnVja2V0ID0gTWF0aC5mbG9vcihuRWxlbWVudHMgLyBuVGhyZWFkcyAvIG0pO1xuICAgICAgICAgICAgbGV0IG5FbGVtZW50c0NodW5rID0gbkVsZW1lbnRzQnVja2V0ICogbTtcbiAgICAgICAgICAgIGxldCBuRWxlbWVudHNMYXN0ID0gbkVsZW1lbnRzIC0gblRocmVhZHMgKiBuRWxlbWVudHNDaHVuaztcblxuICAgICAgICAgICAgLy9JbiBDKysgaW1wbGVtZW50YXRpb24gdGhpcyBidWZmZXIgd2lsbCBiZSBhbGxvY2F0ZWQgb25seSBvbmNlIG91dHNpZGUgdGhlIGxvb3BcbiAgICAgICAgICAgIGxldCBwb2xUbXAgPSBuZXcgUG9seW5vbWlhbCh0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KSwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgICAgICBsZXQgcHRyID0gdGhpcy5jb2VmO1xuICAgICAgICAgICAgdGhpcy5jb2VmID0gcG9sVG1wLmNvZWY7XG4gICAgICAgICAgICBwb2xUbXAuY29lZiA9IHB0cjtcblxuICAgICAgICAgICAgLy8gU1RFUCAxOiBTZXRlamFyIGVscyBtIHZhbG9ycyBkZWwgc2Vnw7xlbnQgYnVja2V0IGFsIGNodW5rIGFjdHVhbCwgUEFSQUxFTMK3TElUWkFSXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5UaHJlYWRzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaWR4MCA9IChrICsgMSkgKiBuRWxlbWVudHNDaHVuayArIG5FbGVtZW50c0xhc3Q7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKGlkeDAgKyBpIC0gbSwgcG9sVG1wLmdldENvZWYoaWR4MCArIGkpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5FbGVtZW50c0NodW5rIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpZHgwIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBGci5hZGQocG9sVG1wLmdldENvZWYob2Zmc2V0KSwgRnIubXVsKGJldGEsIHRoaXMuZ2V0Q29lZihvZmZzZXQpKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29lZihvZmZzZXQgLSBtLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TVEVQIDI6IFNldGVqYXIgZWxzIHZhbG9ycyBkZWwgZWxlbWVudHMgbGFzdCBOTyBQQVJBTMK3TEVMSVRaQVJcbiAgICAgICAgICAgIGxldCBpZHgwID0gbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbSAmJiBwZW5kaW5nOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYoaWR4MCAtIGkgLSAxLCBwb2xUbXAuZ2V0Q29lZihpZHgwICsgbSAtIGkgLSAxKSk7XG4gICAgICAgICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmc7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpZHgwIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IEZyLmFkZChwb2xUbXAuZ2V0Q29lZihvZmZzZXQpLCBGci5tdWwoYmV0YSwgdGhpcy5nZXRDb2VmKG9mZnNldCkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYob2Zmc2V0IC0gbSwgdmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TdGVwIDM6IGNhbGN1bGFyIGFjdW11bGF0cyBOTyAgUEFSQUxFTMK3TElUWkFSXG5cbiAgICAgICAgICAgIGxldCBhY2MgPSBbXTtcbiAgICAgICAgICAgIGxldCBiZXRhUG93ID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuRWxlbWVudHNCdWNrZXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGJldGFQb3cgPSBGci5tdWwoYmV0YVBvdywgYmV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudEJldGEgPSBGci5vbmU7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBuVGhyZWFkczsgayA+IDA7IGstLSkge1xuICAgICAgICAgICAgICAgIGxldCBpZFRocmVhZCA9IGsgLSAxO1xuICAgICAgICAgICAgICAgIGxldCBpZHgwID0gaWRUaHJlYWQgKiBuRWxlbWVudHNDaHVuayArIG5FbGVtZW50c0xhc3Q7XG4gICAgICAgICAgICAgICAgYWNjW2lkVGhyZWFkXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2lkVGhyZWFkXVtpXSA9IHRoaXMuZ2V0Q29lZihpZHgwICsgaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgIT09IG5UaHJlYWRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NbaWRUaHJlYWRdW2ldID0gRnIuYWRkKGFjY1tpZFRocmVhZF1baV0sIEZyLm11bChiZXRhUG93LCBhY2NbaWRUaHJlYWQgKyAxXVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRCZXRhID0gRnIubXVsKGN1cnJlbnRCZXRhLCBiZXRhUG93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TVEVQIDQgcmVjYWxjdWxhciAgUEFSQUxFTMK3TElUWkFSXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5UaHJlYWRzOyBrKyspIHtcblxuICAgICAgICAgICAgICAgIGxldCBpZHgwID0gayAqIG5FbGVtZW50c0NodW5rICsgbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEJldGEgPSBiZXRhOyAvL1F1YW4gaG9wYXNzZW0gYSBDKysgaSBobyBwYXJhbGVsaXR6ZW0gYXF1ZXN0YSB2YXJpYWJsZSBoYSBkZSBzZXIgcHJpdmFkYVxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TSA9IG0gLSAxO1xuXG4gICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gayA9PT0gMCA/IG5FbGVtZW50c0xhc3QgOiBuRWxlbWVudHNDaHVuaztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGlkeDAgLSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IEZyLmFkZCh0aGlzLmdldENvZWYob2Zmc2V0KSwgRnIubXVsKGN1cnJlbnRCZXRhLCBhY2Nba11bY3VycmVudE1dKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKG9mZnNldCwgdmFsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBhdm9pZCBtb2R1bGFyIG9wZXJhdGlvbnMgaW4gZWFjaCBsb29wLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE0gPSBtIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCZXRhID0gRnIubXVsKGN1cnJlbnRCZXRhLCBiZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIERpdmlkZSBwb2x5bm9taWFsIGJ5IFggLSB2YWx1ZVxuICAgIGRpdkJ5WFN1YlZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvZWZzID0gdGhpcy5sZW5ndGgoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogdGhpcy5Gci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogdGhpcy5Gci5uOCk7XG5cbiAgICAgICAgY29lZnMuc2V0KHRoaXMuRnIuemVybywgKHRoaXMubGVuZ3RoKCkgLSAxKSAqIHRoaXMuRnIubjgpO1xuICAgICAgICBjb2Vmcy5zZXQodGhpcy5jb2VmLnNsaWNlKCh0aGlzLmxlbmd0aCgpIC0gMSkgKiB0aGlzLkZyLm44LCB0aGlzLmxlbmd0aCgpICogdGhpcy5Gci5uOCksICh0aGlzLmxlbmd0aCgpIC0gMikgKiB0aGlzLkZyLm44KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoKCkgLSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIGNvZWZzLnNldChcbiAgICAgICAgICAgICAgICB0aGlzLkZyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNsaWNlKGlfbjggKyB0aGlzLkZyLm44LCBpX244ICsgMiAqIHRoaXMuRnIubjgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkZyLm11bCh2YWx1ZSwgY29lZnMuc2xpY2UoaV9uOCArIHRoaXMuRnIubjgsIGlfbjggKyAyICogdGhpcy5Gci5uOCkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpICogdGhpcy5Gci5uOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuRnIuZXEoXG4gICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCksXG4gICAgICAgICAgICB0aGlzLkZyLm11bCh0aGlzLkZyLm5lZyh2YWx1ZSksIGNvZWZzLnNsaWNlKDAsIHRoaXMuRnIubjgpKVxuICAgICAgICApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5bm9taWFsIGRvZXMgbm90IGRpdmlkZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29lZiA9IGNvZWZzO1xuICAgIH1cblxuICAgIGRpdlpoKGRvbWFpblNpemUsIGV4dGVuc2lvbnMgPSA0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIubmVnKHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkpLCBpX244KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwcGVyQm91bmQgPSB0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjg7XG4gICAgICAgIGZvciAobGV0IGkgPSBkb21haW5TaXplOyBpIDwgdXBwZXJCb3VuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLkZyLnN1YihcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoKGkgLSBkb21haW5TaXplKSAqIHRoaXMuRnIubjgsIChpIC0gZG9tYWluU2l6ZSkgKiB0aGlzLkZyLm44ICsgdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuY29lZi5zZXQoYSwgaV9uOCk7XG4gICAgICAgICAgICBpZiAoaSA+IChkb21haW5TaXplICogKGV4dGVuc2lvbnMtMSkgLSBleHRlbnNpb25zKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBpcyBub3QgZGl2aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRpdkJ5WmVyb2ZpZXIobiwgYmV0YSkge1xuICAgICAgICBsZXQgRnIgPSB0aGlzLkZyO1xuICAgICAgICBjb25zdCBpbnZCZXRhID0gRnIuaW52KGJldGEpO1xuICAgICAgICBjb25zdCBpbnZCZXRhTmVnID0gRnIubmVnKGludkJldGEpO1xuXG4gICAgICAgIGxldCBpc09uZSA9IEZyLmVxKEZyLm9uZSwgaW52QmV0YU5lZyk7XG4gICAgICAgIGxldCBpc05lZ09uZSA9IEZyLmVxKEZyLm5lZ29uZSwgaW52QmV0YU5lZyk7XG5cbiAgICAgICAgaWYgKCFpc09uZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpbnZCZXRhTmVnID09PSAtMSB3ZSdsbCBzYXZlIGEgbXVsdGlwbGljYXRpb24gY2hhbmdpbmcgaXQgYnkgYSBuZWcgZnVuY3Rpb24gY2FsbFxuICAgICAgICAgICAgICAgIGlmIChpc05lZ09uZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gRnIubmVnKHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBGci5tdWwoaW52QmV0YU5lZywgdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmLnNldChlbGVtZW50LCBpX244KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlzT25lID0gRnIuZXEoRnIub25lLCBpbnZCZXRhKTtcbiAgICAgICAgaXNOZWdPbmUgPSBGci5lcShGci5uZWdvbmUsIGludkJldGEpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBuOyBpIDwgdGhpcy5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ID0gaSAqIHRoaXMuRnIubjg7XG4gICAgICAgICAgICBjb25zdCBpX3ByZXZfbjggPSAoaSAtIG4pICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLkZyLnN1YihcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoaV9wcmV2X244LCBpX3ByZXZfbjggKyB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBJZiBpbnZCZXRhID09PSAxIHdlJ2xsIG5vdCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgaWYoIWlzT25lKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaW52QmV0YSA9PT0gLTEgd2UnbGwgc2F2ZSBhIG11bHRpcGxpY2F0aW9uIGNoYW5naW5nIGl0IGJ5IGEgbmVnIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgICAgICBpZihpc05lZ09uZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gRnIubmVnKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBGci5tdWwoaW52QmV0YSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvZWYuc2V0KGVsZW1lbnQsIGlfbjgpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBwb2x5bm9taWFsIGlzIGRpdmlzaWJsZSBieSBjaGVja2luZyBpZiBuIGhpZ2ggY29lZmZpY2llbnRzIGFyZSB6ZXJvXG4gICAgICAgICAgICBpZiAoaSA+IHRoaXMubGVuZ3RoKCkgLSBuIC0gMSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seW5vbWlhbCBpcyBub3QgZGl2aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuLy8gZnVuY3Rpb24gZGl2aWRlQnlWYW5pc2hpbmcoZiwgbiwgcCkge1xuLy8gICAgIC8vIHBvbHlub21pYWwgZGl2aXNpb24gZihYKSAvIChYXm4gLSAxKSB3aXRoIHJlbWFpbmRlclxuLy8gICAgIC8vIHZlcnkgY2hlYXAsIDAgbXVsdGlwbGljYXRpb25zXG4vLyAgICAgLy8gc3RyYXRlZ3k6XG4vLyAgICAgLy8gc3RhcnQgd2l0aCBxKFgpID0gMCwgcihYKSA9IGYoWClcbi8vICAgICAvLyB0aGVuIHN0YXJ0IGNoYW5naW5nIHEsIHIgd2hpbGUgcHJlc2VydmluZyB0aGUgaWRlbnRpdHk6XG4vLyAgICAgLy8gZihYKSA9IHEoWCkgKiAoWF5uIC0gMSkgKyByKFgpXG4vLyAgICAgLy8gaW4gZXZlcnkgc3RlcCwgbW92ZSBoaWdoZXN0LWRlZ3JlZSB0ZXJtIG9mIHIgaW50byB0aGUgcHJvZHVjdFxuLy8gICAgIC8vID0+IHIgZXZlbnR1YWxseSBoYXMgZGVncmVlIDwgbiBhbmQgd2UncmUgZG9uZVxuLy8gICAgIGxldCBxID0gQXJyYXkoZi5sZW5ndGgpLmZpbGwoMG4pO1xuLy8gICAgIGxldCByID0gWy4uLmZdO1xuLy8gICAgIGZvciAobGV0IGkgPSBmLmxlbmd0aCAtIDE7IGkgPj0gbjsgaS0tKSB7XG4vLyAgICAgICAgIGxldCBsZWFkaW5nQ29lZmYgPSByW2ldO1xuLy8gICAgICAgICBpZiAobGVhZGluZ0NvZWZmID09PSAwbikgY29udGludWU7XG4vLyAgICAgICAgIHJbaV0gPSAwbjtcbi8vICAgICAgICAgcltpIC0gbl0gPSBtb2QocltpIC0gbl0gKyBsZWFkaW5nQ29lZmYsIHApO1xuLy8gICAgICAgICBxW2kgLSBuXSA9IG1vZChxW2kgLSBuXSArIGxlYWRpbmdDb2VmZiwgcCk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBbcSwgcl07XG4vLyB9XG5cbiAgICBieVgoKSB7XG4gICAgICAgIGNvbnN0IGNvZWZzID0gKHRoaXMubGVuZ3RoKCkgKyAxKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmNvZWYuYnl0ZUxlbmd0aCArIHRoaXMuRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5jb2VmLmJ5dGVMZW5ndGggKyB0aGlzLkZyLm44KTtcbiAgICAgICAgY29lZnMuc2V0KHRoaXMuRnIuemVybywgMCk7XG4gICAgICAgIGNvZWZzLnNldCh0aGlzLmNvZWYsIHRoaXMuRnIubjgpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IGNvZWZzO1xuICAgIH1cblxuLy8gQ29tcHV0ZSBhIG5ldyBwb2x5bm9taWFsIGYoeF5uKSBmcm9tIGYoeClcbi8vIGYoeCkgICA9IGFfMCArIGFfMcK3eCArIGFfMsK3eF4yICsgLi4uICsgYV9qwrd4Xmpcbi8vIGYoeF5uKSA9IGFfMCArIGFfMcK3eF5uICsgYV8ywrd4XjJuICsgLi4uICsgYV9qwrd4XmpuXG4gICAgc3RhdGljXG4gICAgYXN5bmMgZXhwWChwb2x5bm9taWFsLCBuLCB0cnVuY2F0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IEZyID0gcG9seW5vbWlhbC5GcjtcblxuICAgICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgICAgIC8vIG4gPT0gMCBub3QgYWxsb3dlZCBiZWNhdXNlIGl0IGhhcyBubyBzZW5zZSwgYnV0IGlmIGl0J3MgbmVjZXNzYXJ5IHdlIGhhdmUgdG8gcmV0dXJuXG4gICAgICAgICAgICAvLyBhIHplcm8gZGVncmVlIHBvbHlub21pYWwgd2l0aCBhIGNvbnN0YW50IGNvZWZmaWNpZW50IGVxdWFscyB0byB0aGUgc3VtIG9mIGFsbCB0aGUgb3JpZ2luYWwgY29lZmZpY2llbnRzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wdXRlIGEgbmV3IHBvbHlub21pYWwgdG8gYSB6ZXJvIG9yIG5lZ2F0aXZlIG51bWJlciBpcyBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICgxID09PSBuKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMocG9seW5vbWlhbC5jb2VmLCBjdXJ2ZSwgcG9seW5vbWlhbC5sb2dnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIGlzIHRoZSBsZW5ndGggb2Ygbm9uLWNvbnN0YW50IGNvZWZmaWNpZW50c1xuICAgICAgICAvLyBpZiB0cnVuY2F0ZSA9PT0gdHJ1ZSwgdGhlIGhpZ2hlc3QgemVybyBjb2VmZmljaWVudHMgKGlmIGV4aXN0KSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdHJ1bmNhdGUgPyBwb2x5bm9taWFsLmRlZ3JlZSgpIDogKHBvbHlub21pYWwubGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgY29uc3QgYnVmZmVyRHN0ID0gKGxlbmd0aCAqIG4gKyAxKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigobGVuZ3RoICogbiArIDEpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKGxlbmd0aCAqIG4gKyAxKSAqIEZyLm44KTtcblxuICAgICAgICAvLyBDb3B5IGNvbnN0YW50IGNvZWZmaWNpZW50IGFzIGlzIGJlY2F1c2UgaXMgbm90IHJlbGF0ZWQgdG8geFxuICAgICAgICBidWZmZXJEc3Quc2V0KHBvbHlub21pYWwuZ2V0Q29lZigwKSwgMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIEZyLm44O1xuXG4gICAgICAgICAgICBjb25zdCBjb2VmID0gcG9seW5vbWlhbC5nZXRDb2VmKGkpO1xuICAgICAgICAgICAgYnVmZmVyRHN0LnNldChjb2VmLCBpX3NGciAqIG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGJ1ZmZlckRzdCwgcG9seW5vbWlhbC5jdXJ2ZSwgcG9seW5vbWlhbC5sb2dnZXIpO1xuICAgIH1cblxuICAgIHNwbGl0KG51bVBvbHMsIGRlZ1BvbHMsIGJsaW5kaW5nRmFjdG9ycykge1xuICAgICAgICBpZiAobnVtUG9scyA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbHMgY2FuJ3QgYmUgc3BsaXQgaW4gJHtudW1Qb2xzfSBwYXJ0c2ApO1xuICAgICAgICB9IGVsc2UgaWYgKDEgPT09IG51bVBvbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XG4gICAgICAgIH1cblxuICAgICAgICAvL2JsaW5kaW5nIGZhY3RvcnMgY2FuIGJlIHZvaWQgb3IgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIG51bVBvbHMgLSAxXG4gICAgICAgIGlmICgwICE9PSBibGluZGluZ0ZhY3RvcnMubGVuZ3RoICYmIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPCBudW1Qb2xzIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbGluZGluZyBmYWN0b3JzIGxlbmd0aCBtdXN0IGJlICR7bnVtUG9scyAtIDF9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaHVua0J5dGVMZW5ndGggPSAoZGVnUG9scyArIDEpICogdGhpcy5Gci5uODtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuXG4gICAgICAgIC8vIENoZWNrIHBvbHlub21pYWwgY2FuIGJlIHNwbGl0IGluIG51bUNodW5rcyBwYXJ0cyBvZiBjaHVua1NpemUgYnl0ZXMuLi5cbiAgICAgICAgY29uc3QgbnVtUmVhbFBvbHMgPSBNYXRoLmNlaWwoKHRoaXMuZGVncmVlKCkgKyAxKSAqIHRoaXMuRnIubjggLyBjaHVua0J5dGVMZW5ndGgpO1xuICAgICAgICBpZiAobnVtUmVhbFBvbHMgPCBudW1Qb2xzKSB7XG4gICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbCBpcyBzaG9ydCB0byBiZSBzcGxpdCBpbiAke251bVBvbHN9IHBhcnRzIG9mICR7ZGVnUG9sc30gY29lZmZpY2llbnRzIGVhY2guYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbnVtUmVhbFBvbHM7IGkgPCBudW1Qb2xzOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBuZXcgUG9seW5vbWlhbChuZXcgVWludDhBcnJheSh0aGlzLkZyLm44KSwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbnVtUG9scyA9IE1hdGgubWluKG51bVBvbHMsIG51bVJlYWxQb2xzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2xzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdCA9IChudW1Qb2xzIC0gMSkgPT09IGk7XG4gICAgICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gaXNMYXN0ID8gdGhpcy5jb2VmLmJ5dGVMZW5ndGggLSAoKG51bVBvbHMgLSAxKSAqIGNodW5rQnl0ZUxlbmd0aCkgOiBjaHVua0J5dGVMZW5ndGggKyB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICBsZXQgYnVmZiA9IChieXRlTGVuZ3RoIC8gdGhpcy5Gci5uOCkgPiAyIDw8IDE0ID8gbmV3IEJpZ0J1ZmZlcihieXRlTGVuZ3RoKSA6IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgcmVzW2ldID0gbmV3IFBvbHlub21pYWwoYnVmZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgICAgICBjb25zdCBmciA9IGkgKiBjaHVua0J5dGVMZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0byA9IGlzTGFzdCA/IHRoaXMuY29lZi5ieXRlTGVuZ3RoIDogKGkgKyAxKSAqIGNodW5rQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldCh0aGlzLmNvZWYuc2xpY2UoZnIsIHRvKSwgMCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhIGJsaW5kaW5nIGZhY3RvciBhcyBoaWdoZXIgZGVncmVlXG4gICAgICAgICAgICBpZiAoIWlzTGFzdCkge1xuICAgICAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldChibGluZGluZ0ZhY3RvcnNbaV0sIGNodW5rQnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1YiBibGluZGluZyBmYWN0b3IgdG8gdGhlIGxvd2VzdCBkZWdyZWVcbiAgICAgICAgICAgIGlmICgwICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG93ZXN0RGVncmVlID0gdGhpcy5Gci5zdWIocmVzW2ldLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCksIGJsaW5kaW5nRmFjdG9yc1tpIC0gMV0pO1xuICAgICAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldChsb3dlc3REZWdyZWUsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldLnRydW5jYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuXG4gICAgICAgIC8vIC8vIGNvbXB1dGUgdF9sb3coWClcbiAgICAgICAgLy8gbGV0IHBvbFRMb3cgPSBuZXcgQmlnQnVmZmVyKChjaHVua1NpemUgKyAxKSAqIG44cik7XG4gICAgICAgIC8vIHBvbFRMb3cuc2V0KHQuc2xpY2UoMCwgemtleS5kb21haW5TaXplICogbjhyKSwgMCk7XG4gICAgICAgIC8vIC8vIEFkZCBibGluZGluZyBzY2FsYXIgYl8xMCBhcyBhIG5ldyBjb2VmZmljaWVudCBuXG4gICAgICAgIC8vIHBvbFRMb3cuc2V0KGNoLmJbMTBdLCB6a2V5LmRvbWFpblNpemUgKiBuOHIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAvLyBjb21wdXRlIHRfbWlkKFgpXG4gICAgICAgIC8vIGxldCBwb2xUTWlkID0gbmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgMSkgKiBuOHIpO1xuICAgICAgICAvLyBwb2xUTWlkLnNldCh0LnNsaWNlKHprZXkuZG9tYWluU2l6ZSAqIG44ciwgemtleS5kb21haW5TaXplICogMiAqIG44ciksIDApO1xuICAgICAgICAvLyAvLyBTdWJ0cmFjdCBibGluZGluZyBzY2FsYXIgYl8xMCB0byB0aGUgbG93ZXN0IGNvZWZmaWNpZW50IG9mIHRfbWlkXG4gICAgICAgIC8vIGNvbnN0IGxvd2VzdE1pZCA9IEZyLnN1Yihwb2xUTWlkLnNsaWNlKDAsIG44ciksIGNoLmJbMTBdKTtcbiAgICAgICAgLy8gcG9sVE1pZC5zZXQobG93ZXN0TWlkLCAwKTtcbiAgICAgICAgLy8gLy8gQWRkIGJsaW5kaW5nIHNjYWxhciBiXzExIGFzIGEgbmV3IGNvZWZmaWNpZW50IG5cbiAgICAgICAgLy8gcG9sVE1pZC5zZXQoY2guYlsxMV0sIHprZXkuZG9tYWluU2l6ZSAqIG44cik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIC8vIGNvbXB1dGUgdF9oaWdoKFgpXG4gICAgICAgIC8vIGxldCBwb2xUSGlnaCA9IG5ldyBCaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDYpICogbjhyKTtcbiAgICAgICAgLy8gcG9sVEhpZ2guc2V0KHQuc2xpY2UoemtleS5kb21haW5TaXplICogMiAqIG44ciwgKHprZXkuZG9tYWluU2l6ZSAqIDMgKyA2KSAqIG44ciksIDApO1xuICAgICAgICAvLyAvL1N1YnRyYWN0IGJsaW5kaW5nIHNjYWxhciBiXzExIHRvIHRoZSBsb3dlc3QgY29lZmZpY2llbnQgb2YgdF9oaWdoXG4gICAgICAgIC8vIGNvbnN0IGxvd2VzdEhpZ2ggPSBGci5zdWIocG9sVEhpZ2guc2xpY2UoMCwgbjhyKSwgY2guYlsxMV0pO1xuICAgICAgICAvLyBwb2xUSGlnaC5zZXQobG93ZXN0SGlnaCwgMCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHByb29mLlQxID0gYXdhaXQgZXhwVGF1KHBvbFRMb3csIFwibXVsdGlleHAgVDFcIik7XG4gICAgICAgIC8vIHByb29mLlQyID0gYXdhaXQgZXhwVGF1KHBvbFRNaWQsIFwibXVsdGlleHAgVDJcIik7XG4gICAgICAgIC8vIHByb29mLlQzID0gYXdhaXQgZXhwVGF1KHBvbFRIaWdoLCBcIm11bHRpZXhwIFQzXCIpO1xuICAgIH1cblxuLy8gc3BsaXQyKGRlZ1BvbHMsIGJsaW5kaW5nRmFjdG9ycykge1xuLy8gICAgIGxldCBjdXJyZW50RGVncmVlID0gdGhpcy5kZWdyZWUoKTtcbi8vICAgICBjb25zdCBudW1GaWxsZWRQb2xzID0gTWF0aC5jZWlsKChjdXJyZW50RGVncmVlICsgMSkgLyAoZGVnUG9scyArIDEpKTtcbi8vXG4vLyAgICAgLy9ibGluZGluZyBmYWN0b3JzIGNhbiBiZSB2b2lkIG9yIG11c3QgaGF2ZSBhIGxlbmd0aCBvZiBudW1Qb2xzIC0gMVxuLy8gICAgIGlmICgwICE9PSBibGluZGluZ0ZhY3RvcnMubGVuZ3RoICYmIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggPCBudW1GaWxsZWRQb2xzIC0gMSkge1xuLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsaW5kaW5nIGZhY3RvcnMgbGVuZ3RoIG11c3QgYmUgJHtudW1GaWxsZWRQb2xzIC0gMX1gKTtcbi8vICAgICB9XG4vL1xuLy8gICAgIGNvbnN0IGNodW5rQnl0ZUxlbmd0aCA9IChkZWdQb2xzICsgMSkgKiB0aGlzLkZyLm44O1xuLy9cbi8vICAgICAvLyBDaGVjayBwb2x5bm9taWFsIGNhbiBiZSBzcGxpdCBpbiBudW1DaHVua3MgcGFydHMgb2YgY2h1bmtTaXplIGJ5dGVzLi4uXG4vLyAgICAgaWYgKHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gY2h1bmtCeXRlTGVuZ3RoIDw9IG51bUZpbGxlZFBvbHMgLSAxKSB7XG4vLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seW5vbWlhbCBpcyBzaG9ydCB0byBiZSBzcGxpdCBpbiAke251bUZpbGxlZFBvbHN9IHBhcnRzIG9mICR7ZGVnUG9sc30gY29lZmZpY2llbnRzIGVhY2guYCk7XG4vLyAgICAgfVxuLy9cbi8vICAgICBsZXQgcmVzID0gW107XG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1GaWxsZWRQb2xzOyBpKyspIHtcbi8vICAgICAgICAgY29uc3QgaXNMYXN0ID0gKG51bUZpbGxlZFBvbHMgLSAxKSA9PT0gaTtcbi8vICAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGlzTGFzdCA/IChjdXJyZW50RGVncmVlICsgMSkgKiB0aGlzLkZyLm44IC0gKChudW1GaWxsZWRQb2xzIC0gMSkgKiBjaHVua0J5dGVMZW5ndGgpIDogY2h1bmtCeXRlTGVuZ3RoICsgdGhpcy5Gci5uODtcbi8vXG4vLyAgICAgICAgIHJlc1tpXSA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoYnl0ZUxlbmd0aCksIHRoaXMuRnIsIHRoaXMubG9nZ2VyKTtcbi8vICAgICAgICAgY29uc3QgZnIgPSBpICogY2h1bmtCeXRlTGVuZ3RoO1xuLy8gICAgICAgICBjb25zdCB0byA9IGlzTGFzdCA/IChjdXJyZW50RGVncmVlICsgMSkgKiB0aGlzLkZyLm44IDogKGkgKyAxKSAqIGNodW5rQnl0ZUxlbmd0aDtcbi8vICAgICAgICAgcmVzW2ldLmNvZWYuc2V0KHRoaXMuY29lZi5zbGljZShmciwgdG8pLCAwKTtcbi8vXG4vLyAgICAgICAgIC8vIEFkZCBhIGJsaW5kaW5nIGZhY3RvciBhcyBoaWdoZXIgZGVncmVlXG4vLyAgICAgICAgIGlmICghaXNMYXN0KSB7XG4vLyAgICAgICAgICAgICByZXNbaV0uY29lZi5zZXQoYmxpbmRpbmdGYWN0b3JzW2ldLCBjaHVua0J5dGVMZW5ndGgpO1xuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICAvLyBTdWIgYmxpbmRpbmcgZmFjdG9yIHRvIHRoZSBsb3dlc3QgZGVncmVlXG4vLyAgICAgICAgIGlmICgwICE9PSBpKSB7XG4vLyAgICAgICAgICAgICBjb25zdCBsb3dlc3REZWdyZWUgPSB0aGlzLkZyLnN1YihyZXNbaV0uY29lZi5zbGljZSgwLCB0aGlzLkZyLm44KSwgYmxpbmRpbmdGYWN0b3JzW2kgLSAxXSk7XG4vLyAgICAgICAgICAgICByZXNbaV0uY29lZi5zZXQobG93ZXN0RGVncmVlLCAwKTtcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vXG4vLyAgICAgcmV0dXJuIHJlcztcbi8vIH1cblxuLy8gbWVyZ2UocG9scywgb3ZlcmxhcCA9IHRydWUpIHtcbi8vICAgICBsZXQgbGVuZ3RoID0gMDtcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHMubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgbGVuZ3RoICs9IHBvbHNbaV0ubGVuZ3RoKCk7XG4vLyAgICAgfVxuLy9cbi8vICAgICBpZiAob3ZlcmxhcCkge1xuLy8gICAgICAgICBsZW5ndGggLT0gcG9scy5sZW5ndGggLSAxO1xuLy8gICAgIH1cbi8vXG4vLyAgICAgbGV0IHJlcyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIobGVuZ3RoICogdGhpcy5Gci5uOCkpO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9scy5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gcG9sc1tpXS5jb2VmLmJ5dGVMZW5ndGg7XG4vLyAgICAgICAgIGlmICgwID09PSBpKSB7XG4vLyAgICAgICAgICAgICByZXMuY29lZi5zZXQocG9sc1tpXS5jb2VmLCAwKTtcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vL1xuLy8gICAgIHJldHVybiByZXM7XG4vLyB9XG5cbiAgICB0cnVuY2F0ZSgpIHtcbiAgICAgICAgY29uc3QgZGVnID0gdGhpcy5kZWdyZWUoKTtcbiAgICAgICAgaWYgKGRlZyArIDEgPCB0aGlzLmNvZWYuYnl0ZUxlbmd0aCAvIHRoaXMuRnIubjgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvZWZzID0gKGRlZyArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigoZGVnICsgMSkgKiB0aGlzLkZyLm44KSA6IG5ldyBVaW50OEFycmF5KChkZWcgKyAxKSAqIHRoaXMuRnIubjgpO1xuXG4gICAgICAgICAgICBuZXdDb2Vmcy5zZXQodGhpcy5jb2VmLnNsaWNlKDAsIChkZWcgKyAxKSAqIHRoaXMuRnIubjgpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY29lZiA9IG5ld0NvZWZzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oeEFyciwgeUFyciwgY3VydmUpIHtcbiAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgbGV0IHBvbHlub21pYWwgPSBjb21wdXRlTGFncmFuZ2VQb2x5bm9taWFsKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHhBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvbHlub21pYWwuYWRkKGNvbXB1dGVMYWdyYW5nZVBvbHlub21pYWwoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlub21pYWw7XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUxhZ3JhbmdlUG9seW5vbWlhbChpKSB7XG4gICAgICAgICAgICBsZXQgcG9seW5vbWlhbDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB4QXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvbHlub21pYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYnVmZiA9ICh4QXJyLmxlbmd0aCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIoKHhBcnIubGVuZ3RoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KCh4QXJyLmxlbmd0aCkgKiBGci5uOCk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwgPSBuZXcgUG9seW5vbWlhbChidWZmLCBjdXJ2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwuc2V0Q29lZigwLCBGci5uZWcoeEFycltqXSkpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFsLnNldENvZWYoMSwgRnIub25lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFsLmJ5WFN1YlZhbHVlKHhBcnJbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gcG9seW5vbWlhbC5ldmFsdWF0ZSh4QXJyW2ldKTtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gRnIuaW52KGRlbm9taW5hdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG11bEZhY3RvciA9IEZyLm11bCh5QXJyW2ldLCBkZW5vbWluYXRvcik7XG5cbiAgICAgICAgICAgIHBvbHlub21pYWwubXVsU2NhbGFyKG11bEZhY3Rvcik7XG5cbiAgICAgICAgICAgIHJldHVybiBwb2x5bm9taWFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHplcm9maWVyUG9seW5vbWlhbCh4QXJyLCBjdXJ2ZSkge1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBsZXQgYnVmZiA9ICh4QXJyLmxlbmd0aCArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKCh4QXJyLmxlbmd0aCArIDEpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKHhBcnIubGVuZ3RoICsgMSkgKiBGci5uOCk7XG4gICAgICAgIGxldCBwb2x5bm9taWFsID0gbmV3IFBvbHlub21pYWwoYnVmZiwgY3VydmUpO1xuXG4gICAgICAgIC8vIEJ1aWxkIGEgemVyb2ZpZXIgcG9seW5vbWlhbCB3aXRoIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAgICAgICAgLy8gemVyb2ZpZXIoWCkgPSAoWC14QXJyWzBdKShYLXhBcnJbMV0pLi4uKFgteEFycltuXSlcbiAgICAgICAgcG9seW5vbWlhbC5zZXRDb2VmKDAsIEZyLm5lZyh4QXJyWzBdKSk7XG4gICAgICAgIHBvbHlub21pYWwuc2V0Q29lZigxLCBGci5vbmUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgeEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcG9seW5vbWlhbC5ieVhTdWJWYWx1ZSh4QXJyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2x5bm9taWFsO1xuICAgIH1cblxuICAgIHByaW50KCkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGxldCByZXMgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5kZWdyZWUoKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZWYgPSB0aGlzLmdldENvZWYoaSk7XG4gICAgICAgICAgICBpZiAoIUZyLmVxKEZyLnplcm8sIGNvZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZyLmlzTmVnYXRpdmUoY29lZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiIC0gXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpICE9PSB0aGlzLmRlZ3JlZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIiArIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMgKz0gRnIudG9TdHJpbmcoY29lZik7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBpID4gMSA/IFwieF5cIiArIGkgOiBcInhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cocmVzKTtcbiAgICB9XG5cbiAgICBhc3luYyBtdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uODtcbiAgICAgICAgY29uc3QgUFRhdU4gPSBQVGF1LnNsaWNlKDAsIG4gKiB0aGlzLkcxLkYubjggKiAyKTtcbiAgICAgICAgY29uc3QgYm0gPSBhd2FpdCB0aGlzLkZyLmJhdGNoRnJvbU1vbnRnb21lcnkodGhpcy5jb2VmKTtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHRoaXMuRzEubXVsdGlFeHBBZmZpbmUoUFRhdU4sIGJtLCB0aGlzLmxvZ2dlciwgbmFtZSk7XG4gICAgICAgIHJlcyA9IHRoaXMuRzEudG9BZmZpbmUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNsYXNzIEV2YWx1YXRpb25zIHtcbiAgICBjb25zdHJ1Y3RvcihldmFsdWF0aW9ucywgY3VydmUsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmV2YWwgPSBldmFsdWF0aW9ucztcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICB0aGlzLkZyID0gY3VydmUuRnI7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBmcm9tUG9seW5vbWlhbChwb2x5bm9taWFsLCBleHRlbnNpb24sIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgY29lZmZpY2llbnRzTiA9IG5ldyBCaWdCdWZmZXIocG9seW5vbWlhbC5sZW5ndGgoKSAqIGV4dGVuc2lvbiAqIGN1cnZlLkZyLm44KTtcbiAgICAgICAgY29lZmZpY2llbnRzTi5zZXQocG9seW5vbWlhbC5jb2VmLCAwKTtcblxuICAgICAgICBjb25zdCBldmFsdWF0aW9ucyA9IGF3YWl0IGN1cnZlLkZyLmZmdChjb2VmZmljaWVudHNOKTtcblxuICAgICAgICByZXR1cm4gbmV3IEV2YWx1YXRpb25zKGV2YWx1YXRpb25zLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBnZXRFdmFsdWF0aW9uKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGlfbjggPSBpbmRleCAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgaWYgKGlfbjggKyB0aGlzLkZyLm44ID4gdGhpcy5ldmFsLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2YWx1YXRpb25zLmdldEV2YWx1YXRpb24oKSBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbC5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCk7XG4gICAgfVxuXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5ldmFsLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44O1xuICAgICAgICBpZiAobGVuZ3RoICE9PSBNYXRoLmZsb29yKHRoaXMuZXZhbC5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uOCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHlub21pYWwgZXZhbHVhdGlvbnMgYnVmZmVyIGhhcyBpbmNvcnJlY3Qgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiUG9seW5vbWlhbCBoYXMgbGVuZ3RoIHplcm9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCB7c3RyaW5naWZ5QmlnSW50czogc3RyaW5naWZ5QmlnSW50cyQxfSA9IHV0aWxzO1xuICAgIFxuYXN5bmMgZnVuY3Rpb24gcGxvbmsxNlByb3ZlKHprZXlGaWxlTmFtZSwgd2l0bmVzc0ZpbGVOYW1lLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7ZmQ6IGZkV3Rucywgc2VjdGlvbnM6IHNlY3Rpb25zV3Ruc30gPSBhd2FpdCByZWFkQmluRmlsZSh3aXRuZXNzRmlsZU5hbWUsIFwid3Ruc1wiLCAyKTtcblxuICAgIC8vIFJlYWQgd2l0bmVzcyBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBSZWFkaW5nIHdpdG5lc3MgZmlsZVwiKTtcbiAgICBjb25zdCB3dG5zID0gYXdhaXQgcmVhZEhlYWRlcihmZFd0bnMsIHNlY3Rpb25zV3Rucyk7XG5cbiAgICAvLyBSZWFkIHprZXkgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUmVhZGluZyB6a2V5IGZpbGVcIik7XG4gICAgY29uc3Qge2ZkOiBmZFpLZXksIHNlY3Rpb25zOiB6a2V5U2VjdGlvbnN9ID0gYXdhaXQgcmVhZEJpbkZpbGUoemtleUZpbGVOYW1lLCBcInprZXlcIiwgMik7XG5cbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgcmVhZEhlYWRlciQxKGZkWktleSwgemtleVNlY3Rpb25zLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIGlmICh6a2V5LnByb3RvY29sICE9IFwicGxvbmtcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IHBsb25rXCIpO1xuICAgIH1cblxuICAgIGlmICghU2NhbGFyLmVxKHprZXkuciwgIHd0bnMucSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VydmUgb2YgdGhlIHdpdG5lc3MgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnZlIG9mIHRoZSBwcm92aW5nIGtleVwiKTtcbiAgICB9XG5cbiAgICBpZiAod3Rucy5uV2l0bmVzcyAhPSB6a2V5Lm5WYXJzIC16a2V5Lm5BZGRpdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHdpdG5lc3MgbGVuZ3RoLiBDaXJjdWl0OiAke3prZXkublZhcnN9LCB3aXRuZXNzOiAke3d0bnMubldpdG5lc3N9LCAke3prZXkubkFkZGl0aW9uc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJ2ZSA9IHprZXkuY3VydmU7XG5cbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IG44ciA9IGN1cnZlLkZyLm44O1xuICAgIGNvbnN0IHNEb21haW4gPSB6a2V5LmRvbWFpblNpemUgKiBuOHI7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIiAgUExPTksgUFJPVkUgU0VUVElOR1NcIik7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgICBDdXJ2ZTogICAgICAgICAke2N1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgICBDaXJjdWl0IHBvd2VyOiAke3prZXkucG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgICBEb21haW4gc2l6ZTogICAke3prZXkuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIFZhcnM6ICAgICAgICAgICR7emtleS5uVmFyc31gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIFB1YmxpYyB2YXJzOiAgICR7emtleS5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoYCAgQ29uc3RyYWludHM6ICAgJHt6a2V5Lm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIEFkZGl0aW9uczogICAgICR7emtleS5uQWRkaXRpb25zfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgIH1cblxuICAgIC8vUmVhZCB3aXRuZXNzIGRhdGFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJlYWRpbmcgd2l0bmVzcyBmaWxlIGRhdGFcIik7XG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCByZWFkU2VjdGlvbihmZFd0bnMsIHNlY3Rpb25zV3RucywgMik7XG5cbiAgICAvLyBGaXJzdCBlbGVtZW50IGluIHBsb25rIGlzIG5vdCB1c2VkIGFuZCBjYW4gYmUgYW55IHZhbHVlLiAoQnV0IGFsd2F5cyB0aGUgc2FtZSkuXG4gICAgLy8gV2Ugc2V0IGl0IHRvIHplcm8gdG8gZ28gZmFzdGVyIGluIHRoZSBleHBvbmVudGlhdGlvbnMuXG4gICAgYnVmZldpdG5lc3Muc2V0KEZyLnplcm8sIDApO1xuICAgIGNvbnN0IGJ1ZmZJbnRlcm5hbFdpdG5lc3MgPSBuZXcgQmlnQnVmZmVyKG44cip6a2V5Lm5BZGRpdGlvbnMpO1xuXG4gICAgbGV0IGJ1ZmZlcnMgPSB7fTtcbiAgICBsZXQgcG9seW5vbWlhbHMgPSB7fTtcbiAgICBsZXQgZXZhbHVhdGlvbnMgPSB7fTtcblxuICAgIGxldCBjaGFsbGVuZ2VzID0ge307XG4gICAgbGV0IHByb29mID0gbmV3IFByb29mKGN1cnZlLCBsb2dnZXIpO1xuICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYD4gUmVhZGluZyBTZWN0aW9uICR7WktFWV9QTF9BRERJVElPTlNfU0VDVElPTn0uIEFkZGl0aW9uc2ApO1xuICAgIGF3YWl0IGNhbGN1bGF0ZUFkZGl0aW9ucygpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGA+IFJlYWRpbmcgU2VjdGlvbiAke1pLRVlfUExfU0lHTUFfU0VDVElPTn0uIFNpZ21hMSwgU2lnbWEyICYgU2lnbWEgM2ApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBSZWFkaW5nIFNpZ21hIHBvbHlub21pYWxzIFwiKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTEgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTIgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTMgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWExLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWEyLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnAgKyA1ICogc0RvbWFpbik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5TaWdtYTMuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfU0lHTUFfU0VDVElPTl1bMF0ucCArIDEwICogc0RvbWFpbik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgUmVhZGluZyBTaWdtYSBldmFsdWF0aW9uc1wiKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTEgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgIGV2YWx1YXRpb25zLlNpZ21hMiA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgZXZhbHVhdGlvbnMuU2lnbWEzID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWExLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9TSUdNQV9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5TaWdtYTIuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnAgKyA2ICogc0RvbWFpbik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5TaWdtYTMuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnAgKyAxMSAqIHNEb21haW4pO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGA+IFJlYWRpbmcgU2VjdGlvbiAke1pLRVlfUExfUFRBVV9TRUNUSU9OfS4gUG93ZXJzIG9mIFRhdWApO1xuICAgIGNvbnN0IFBUYXUgPSBhd2FpdCByZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9QTF9QVEFVX1NFQ1RJT04pO1xuXG4gICAgbGV0IHB1YmxpY1NpZ25hbHMgPSBbXTtcblxuICAgIGZvciAobGV0IGk9MTsgaTw9IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHB1YiA9IGJ1ZmZXaXRuZXNzLnNsaWNlKGkqRnIubjgsIGkqRnIubjgrRnIubjgpO1xuICAgICAgICBwdWJsaWNTaWduYWxzLnB1c2goU2NhbGFyLmZyb21ScHJMRShwdWIpKTtcbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJcIik7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBST1VORCAxXCIpO1xuICAgIGF3YWl0IHJvdW5kMSgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBST1VORCAyXCIpO1xuICAgIGF3YWl0IHJvdW5kMigpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBST1VORCAzXCIpO1xuICAgIGF3YWl0IHJvdW5kMygpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBST1VORCA0XCIpO1xuICAgIGF3YWl0IHJvdW5kNCgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBST1VORCA1XCIpO1xuICAgIGF3YWl0IHJvdW5kNSgpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBGaW5hbCBhZGp1c3RtZW50cyAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcblxuICAgIC8vIFByZXBhcmUgcHJvb2ZcbiAgICBsZXQgX3Byb29mID0gcHJvb2YudG9PYmplY3RQcm9vZihmYWxzZSk7XG4gICAgX3Byb29mLnByb3RvY29sID0gXCJwbG9ua1wiO1xuICAgIF9wcm9vZi5jdXJ2ZSA9IGN1cnZlLm5hbWU7XG4gICAgXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiUExPTksgUFJPVkVSIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvb2Y6IHN0cmluZ2lmeUJpZ0ludHMkMShfcHJvb2YpLFxuICAgICAgICBwdWJsaWNTaWduYWxzOiBzdHJpbmdpZnlCaWdJbnRzJDEocHVibGljU2lnbmFscylcbiAgICB9O1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlQWRkaXRpb25zKCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIGFkZGl0aW9uc1wiKTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25zQnVmZiA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX1BMX0FERElUSU9OU19TRUNUSU9OKTtcblxuICAgICAgICAvLyBzaXplczogd2lyZUlkX3ggPSA0IGJ5dGVzICgzMiBiaXRzKSwgZmFjdG9yX3ggPSBmaWVsZCBzaXplIGJpdHNcbiAgICAgICAgLy8gQWRkaXRpb24gZm9ybTogd2lyZUlkX2Egd2lyZUlkX2IgZmFjdG9yX2EgZmFjdG9yX2IgKHNpemUgaXMgNCArIDQgKyBzRnIgKyBzRnIpXG4gICAgICAgIGNvbnN0IHNTdW0gPSA4ICsgbjhyICogMjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkubkFkZGl0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyICYmICgwICE9PSBpKSAmJiAoaSAlIDEwMDAwMCA9PT0gMCkpIGxvZ2dlci5kZWJ1ZyhgICAgIGFkZGl0aW9uICR7aX0vJHt6a2V5Lm5BZGRpdGlvbnN9YCk7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgYWRkaXRpb24gdmFsdWVzXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gaSAqIHNTdW07XG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZDEgPSByZWFkVUludDMyKGFkZGl0aW9uc0J1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkMiA9IHJlYWRVSW50MzIoYWRkaXRpb25zQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yMSA9IGFkZGl0aW9uc0J1ZmYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBuOHIpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IG44cjtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcjIgPSBhZGRpdGlvbnNCdWZmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbjhyKTtcblxuICAgICAgICAgICAgLy8gR2V0IHdpdG5lc3MgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHdpdG5lc3MxID0gZ2V0V2l0bmVzcyhzaWduYWxJZDEpO1xuICAgICAgICAgICAgY29uc3Qgd2l0bmVzczIgPSBnZXRXaXRuZXNzKHNpZ25hbElkMik7XG5cbiAgICAgICAgICAgIC8vQ2FsY3VsYXRlIGZpbmFsIHJlc3VsdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gRnIuYWRkKEZyLm11bChmYWN0b3IxLCB3aXRuZXNzMSksIEZyLm11bChmYWN0b3IyLCB3aXRuZXNzMikpO1xuXG4gICAgICAgICAgICBidWZmSW50ZXJuYWxXaXRuZXNzLnNldChyZXN1bHQsIG44ciAqIGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFVJbnQzMihiLCBvKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBiLnNsaWNlKG8sIG8rNCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBidWZmVi5nZXRVaW50MzIoMCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2l0bmVzcyhpZHgpIHtcbiAgICAgICAgaWYgKGlkeCA8IHprZXkublZhcnMtemtleS5uQWRkaXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZldpdG5lc3Muc2xpY2UoaWR4Km44ciwgaWR4Km44cituOHIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlkeCA8IHprZXkublZhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmSW50ZXJuYWxXaXRuZXNzLnNsaWNlKChpZHggLSAoemtleS5uVmFycy16a2V5Lm5BZGRpdGlvbnMpKSpuOHIsIChpZHgtKHprZXkublZhcnMtemtleS5uQWRkaXRpb25zKSkqbjhyICsgbjhyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJ2ZS5Gci56ZXJvO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQxKCkge1xuICAgICAgICAvLyBTVEVQIDEuMSAtIEdlbmVyYXRlIHJhbmRvbSBibGluZGluZyBzY2FsYXJzIChiMSwgLi4uLCBiMTEpIOKIiCBGXG4gICAgICAgIGNoYWxsZW5nZXMuYiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTE7IGk8PTExOyBpKyspIHtcbiAgICAgICAgICAgIGNoYWxsZW5nZXMuYltpXSA9IGN1cnZlLkZyLnJhbmRvbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU1RFUCAxLjIgLSBDb21wdXRlIHdpcmUgcG9seW5vbWlhbHMgYShYKSwgYihYKSBhbmQgYyhYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBBLCBCLCBDIHdpcmUgcG9seW5vbWlhbHNcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVXaXJlUG9seW5vbWlhbHMoKTtcblxuICAgICAgICAvLyBTVEVQIDEuMyAtIENvbXB1dGUgW2FdXzEsIFtiXV8xLCBbY11fMVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBBLCBCLCBDIE1TTVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdEEgPSBhd2FpdCBwb2x5bm9taWFscy5BLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJBXCIpO1xuICAgICAgICBsZXQgY29tbWl0QiA9IGF3YWl0IHBvbHlub21pYWxzLkIubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIkJcIik7XG4gICAgICAgIGxldCBjb21taXRDID0gYXdhaXQgcG9seW5vbWlhbHMuQy5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiQ1wiKTtcblxuICAgICAgICAvLyBGaXJzdCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW0FdXzEsIFtCXV8xLCBbQ11fMSlcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIkFcIiwgY29tbWl0QSk7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJCXCIsIGNvbW1pdEIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiQ1wiLCBjb21taXRDKTtcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlV2lyZVBvbHlub21pYWxzKCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgUmVhZGluZyBkYXRhIGZyb20gemtleSBmaWxlXCIpO1xuXG4gICAgICAgIC8vIEJ1aWxkIEEsIEIgYW5kIEMgZXZhbHVhdGlvbnMgYnVmZmVyIGZyb20gemtleSBhbmQgd2l0bmVzcyBmaWxlc1xuICAgICAgICBidWZmZXJzLkEgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuICAgICAgICBidWZmZXJzLkIgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuICAgICAgICBidWZmZXJzLkMgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuXG4gICAgICAgIC8vIFJlYWQgemtleSBmaWxlIHRvIHRoZSBidWZmZXJzXG4gICAgICAgIGNvbnN0IGFNYXBCdWZmID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfUExfQV9NQVBfU0VDVElPTik7XG4gICAgICAgIGNvbnN0IGJNYXBCdWZmID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfUExfQl9NQVBfU0VDVElPTik7XG4gICAgICAgIGNvbnN0IGNNYXBCdWZmID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfUExfQ19NQVBfU0VDVElPTik7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBhbGwgd2l0bmVzcyBmcm9tIHNpZ25hbCBpZHMgYW5kIHNldCB0aGVtIHRvIEEsQiAmIEMgYnVmZmVyc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkubkNvbnN0cmFpbnRzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIG44cjtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiA0O1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIEEgdmFsdWUgZnJvbSBhIHNpZ25hbCBpZFxuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWRBID0gcmVhZFVJbnQzMihhTWFwQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQS5zZXQoZ2V0V2l0bmVzcyhzaWduYWxJZEEpLCBpX3NGcik7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgQiB2YWx1ZSBmcm9tIGEgc2lnbmFsIGlkXG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZEIgPSByZWFkVUludDMyKGJNYXBCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgYnVmZmVycy5CLnNldChnZXRXaXRuZXNzKHNpZ25hbElkQiksIGlfc0ZyKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBDIHZhbHVlIGZyb20gYSBzaWduYWwgaWRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkQyA9IHJlYWRVSW50MzIoY01hcEJ1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBidWZmZXJzLkMuc2V0KGdldFdpdG5lc3Moc2lnbmFsSWRDKSwgaV9zRnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZmVycy5BID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZmVycy5BKTtcbiAgICAgICAgYnVmZmVycy5CID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZmVycy5CKTtcbiAgICAgICAgYnVmZmVycy5DID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZmVycy5DKTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHdpcmUgcG9seW5vbWlhbHMgYShYKSwgYihYKSBhbmQgYyhYKSBmcm9tIEEsQiAmIEMgYnVmZmVyc1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIEEgaWZmdFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuQSA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuQSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgQiBpZmZ0XCIpO1xuICAgICAgICBwb2x5bm9taWFscy5CID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5CLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBDIGlmZnRcIik7XG4gICAgICAgIHBvbHlub21pYWxzLkMgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLkMsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgZXh0ZW5kZWQgZXZhbHVhdGlvbnMgb2YgYShYKSwgYihYKSBhbmQgYyhYKSBwb2x5bm9taWFsc1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIEEgZmZ0XCIpO1xuICAgICAgICBldmFsdWF0aW9ucy5BID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQSwgNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgQiBmZnRcIik7XG4gICAgICAgIGV2YWx1YXRpb25zLkIgPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5CLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBDIGZmdFwiKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuQyA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMsIDQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIEJsaW5kIGEoWCksIGIoWCkgYW5kIGMoWCkgcG9seW5vbWlhbHMgY29lZmZpY2llbnRzIHdpdGggYmxpbmRpbmcgc2NhbGFycyBiXG4gICAgICAgIHBvbHlub21pYWxzLkEuYmxpbmRDb2VmZmljaWVudHMoW2NoYWxsZW5nZXMuYlsyXSwgY2hhbGxlbmdlcy5iWzFdXSk7XG4gICAgICAgIHBvbHlub21pYWxzLkIuYmxpbmRDb2VmZmljaWVudHMoW2NoYWxsZW5nZXMuYls0XSwgY2hhbGxlbmdlcy5iWzNdXSk7XG4gICAgICAgIHBvbHlub21pYWxzLkMuYmxpbmRDb2VmZmljaWVudHMoW2NoYWxsZW5nZXMuYls2XSwgY2hhbGxlbmdlcy5iWzVdXSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGVncmVlc1xuICAgICAgICBpZiAocG9seW5vbWlhbHMuQS5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUgKyAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9seW5vbWlhbHMuQi5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUgKyAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9seW5vbWlhbHMuQy5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUgKyAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQyKCkge1xuICAgICAgICAvLyBTVEVQIDIuMSAtIENvbXB1dGUgcGVybXV0YXRpb24gY2hhbGxlbmdlIGJldGEgYW5kIGdhbW1hIOKIiCBGXG4gICAgICAgIC8vIENvbXB1dGUgcGVybXV0YXRpb24gY2hhbGxlbmdlIGJldGFcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlcyBiZXRhIGFuZCBnYW1tYVwiKTtcbiAgICAgICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuXG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlFtKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUWwpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5Rcik7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlFvKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUWMpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5TMSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlMyKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUzMpO1xuXG4gICAgICAgIC8vIEFkZCBBIHRvIHRoZSB0cmFuc2NyaXB0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGJ1ZmZlcnMuQS5zbGljZShpICogbjhyLCBpICogbjhyICsgbjhyKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgQSwgQiwgQyB0byB0aGUgdHJhbnNjcmlwdFxuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIkFcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIkJcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIkNcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMuYmV0YSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmJldGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5iZXRhLCAxNikpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgcGVybXV0YXRpb24gY2hhbGxlbmdlIGdhbW1hXG4gICAgICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5iZXRhKTtcbiAgICAgICAgY2hhbGxlbmdlcy5nYW1tYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmdhbW1hOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuZ2FtbWEsIDE2KSk7XG4gICAgXG4gICAgICAgIC8vIFNURVAgMi4yIC0gQ29tcHV0ZSBwZXJtdXRhdGlvbiBwb2x5bm9taWFsIHooWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgWiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlWigpO1xuXG4gICAgICAgIC8vIFNURVAgMi4zIC0gQ29tcHV0ZSBwZXJtdXRhdGlvbiBbel1fMVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBaIE1TTVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFogPSBhd2FpdCBwb2x5bm9taWFscy5aLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJaXCIpO1xuXG4gICAgICAgIC8vIFNlY29uZCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW1pdXzEpXG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJaXCIsIGNvbW1pdFopO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVaKCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIFogZXZhbHVhdGlvbnNcIik7XG5cbiAgICAgICAgbGV0IG51bUFyciA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG4gICAgICAgIGxldCBkZW5BcnIgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuXG4gICAgICAgIC8vIFNldCB0aGUgZmlyc3QgdmFsdWVzIHRvIDFcbiAgICAgICAgbnVtQXJyLnNldChGci5vbmUsIDApO1xuICAgICAgICBkZW5BcnIuc2V0KEZyLm9uZSwgMCk7XG5cbiAgICAgICAgLy8gU2V0IGluaXRpYWwgb21lZ2FcbiAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjhyID0gaSAqIG44cjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYSA9IGJ1ZmZlcnMuQS5zbGljZShpX244ciwgaV9uOHIgKyBuOHIpO1xuICAgICAgICAgICAgY29uc3QgYiA9IGJ1ZmZlcnMuQi5zbGljZShpX244ciwgaV9uOHIgKyBuOHIpO1xuICAgICAgICAgICAgY29uc3QgYyA9IGJ1ZmZlcnMuQy5zbGljZShpX244ciwgaV9uOHIgKyBuOHIpO1xuXG4gICAgICAgICAgICAvLyBaKFgpIDo9IG51bUFyciAvIGRlbkFyclxuICAgICAgICAgICAgLy8gbnVtQXJyIDo9IChhICsgYmV0YcK3z4kgKyBnYW1tYSkoYiArIGJldGHCt8+JwrdrMSArIGdhbW1hKShjICsgYmV0YcK3z4nCt2syICsgZ2FtbWEpXG4gICAgICAgICAgICBjb25zdCBiZXRhdyA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHcpO1xuXG4gICAgICAgICAgICBsZXQgbjEgPSBGci5hZGQoYSwgYmV0YXcpO1xuICAgICAgICAgICAgbjEgPSBGci5hZGQobjEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgbjIgPSBGci5hZGQoYiwgRnIubXVsKHprZXkuazEsIGJldGF3KSk7XG4gICAgICAgICAgICBuMiA9IEZyLmFkZChuMiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBuMyA9IEZyLmFkZChjLCBGci5tdWwoemtleS5rMiwgYmV0YXcpKTtcbiAgICAgICAgICAgIG4zID0gRnIuYWRkKG4zLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IG51bSA9IEZyLm11bChuMSwgRnIubXVsKG4yLCBuMykpO1xuXG4gICAgICAgICAgICAvLyBkZW5BcnIgOj0gKGEgKyBiZXRhwrdzaWdtYTEgKyBnYW1tYSkoYiArIGJldGHCt3NpZ21hMiArIGdhbW1hKShjICsgYmV0YcK3c2lnbWEzICsgZ2FtbWEpXG4gICAgICAgICAgICBsZXQgZDEgPSBGci5hZGQoYSwgRnIubXVsKGV2YWx1YXRpb25zLlNpZ21hMS5nZXRFdmFsdWF0aW9uKGkgKiA0KSwgY2hhbGxlbmdlcy5iZXRhKSk7XG4gICAgICAgICAgICBkMSA9IEZyLmFkZChkMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBkMiA9IEZyLmFkZChiLCBGci5tdWwoZXZhbHVhdGlvbnMuU2lnbWEyLmdldEV2YWx1YXRpb24oaSAqIDQpLCBjaGFsbGVuZ2VzLmJldGEpKTtcbiAgICAgICAgICAgIGQyID0gRnIuYWRkKGQyLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGQzID0gRnIuYWRkKGMsIEZyLm11bChldmFsdWF0aW9ucy5TaWdtYTMuZ2V0RXZhbHVhdGlvbihpICogNCksIGNoYWxsZW5nZXMuYmV0YSkpO1xuICAgICAgICAgICAgZDMgPSBGci5hZGQoZDMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZGVuID0gRnIubXVsKGQxLCBGci5tdWwoZDIsIGQzKSk7XG5cbiAgICAgICAgICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgbnVtIHZhbHVlIHdpdGggdGhlIHByZXZpb3VzIG9uZSBzYXZlZCBpbiBudW1BcnJcbiAgICAgICAgICAgIG51bSA9IEZyLm11bChudW1BcnIuc2xpY2UoaV9uOHIsIGlfbjhyICsgbjhyKSwgbnVtKTtcbiAgICAgICAgICAgIG51bUFyci5zZXQobnVtLCAoKGkgKyAxKSAlIHprZXkuZG9tYWluU2l6ZSkgKiBuOHIpO1xuXG4gICAgICAgICAgICAvLyBNdWx0aXBseSBjdXJyZW50IGRlbiB2YWx1ZSB3aXRoIHRoZSBwcmV2aW91cyBvbmUgc2F2ZWQgaW4gZGVuQXJyXG4gICAgICAgICAgICBkZW4gPSBGci5tdWwoZGVuQXJyLnNsaWNlKGlfbjhyLCBpX244ciArIG44ciksIGRlbik7XG4gICAgICAgICAgICBkZW5BcnIuc2V0KGRlbiwgKChpICsgMSkgJSB6a2V5LmRvbWFpblNpemUpICogbjhyKTtcblxuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGludmVyc2Ugb2YgZGVuQXJyIHRvIGNvbXB1dGUgaW4gdGhlIG5leHQgY29tbWFuZCB0aGVcbiAgICAgICAgLy8gZGl2aXNpb24gbnVtQXJyL2RlbkFyciBieSBtdWx0aXBseWluZyBudW0gwrcgMS9kZW5BcnJcbiAgICAgICAgZGVuQXJyID0gYXdhaXQgRnIuYmF0Y2hJbnZlcnNlKGRlbkFycik7XG5cbiAgICAgICAgLy8gVE9ETzogRG8gaXQgaW4gYXNzZW1ibHkgYW5kIGluIHBhcmFsbGVsXG4gICAgICAgIC8vIE11bHRpcGx5IG51bUFyciDCtyBkZW5BcnIgd2hlcmUgZGVuQXJyIHdhcyBpbnZlcnRlZCBpbiB0aGUgcHJldmlvdXMgY29tbWFuZFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBuOHI7XG5cbiAgICAgICAgICAgIGNvbnN0IHogPSBGci5tdWwobnVtQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIG44ciksIGRlbkFyci5zbGljZShpX3NGciwgaV9zRnIgKyBuOHIpKTtcbiAgICAgICAgICAgIG51bUFyci5zZXQoeiwgaV9zRnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRnJvbSBub3cgb24gdGhlIHZhbHVlcyBzYXZlZCBvbiBudW1BcnIgd2lsbCBiZSBaKFgpIGJ1ZmZlclxuICAgICAgICBidWZmZXJzLlogPSBudW1BcnI7XG5cbiAgICAgICAgaWYgKCFGci5lcShudW1BcnIuc2xpY2UoMCwgbjhyKSwgRnIub25lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29weSBjb25zdHJhaW50cyBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgcG9seW5vbWlhbCBjb2VmZmljaWVudHMgeihYKSBmcm9tIGJ1ZmZlcnMuWlxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIFogaWZmdFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuWiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuWiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBleHRlbmRlZCBldmFsdWF0aW9ucyBvZiB6KFgpIHBvbHlub21pYWxcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBaIGZmdFwiKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuWiA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLlosIDQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIEJsaW5kIHooWCkgcG9seW5vbWlhbCBjb2VmZmljaWVudHMgd2l0aCBibGluZGluZyBzY2FsYXJzIGJcbiAgICAgICAgcG9seW5vbWlhbHMuWi5ibGluZENvZWZmaWNpZW50cyhbY2hhbGxlbmdlcy5iWzldLCBjaGFsbGVuZ2VzLmJbOF0sIGNoYWxsZW5nZXMuYls3XV0pO1xuXG4gICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICBpZiAocG9seW5vbWlhbHMuWi5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUgKyAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJaIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBidWZmZXJzLlo7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQzKCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBjaGFsbGVuZ2UgYWxwaGFcIik7XG5cbiAgICAgICAgLy8gU1RFUCAzLjEgLSBDb21wdXRlIGV2YWx1YXRpb24gY2hhbGxlbmdlIGFscGhhIOKIiCBGXG4gICAgICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5iZXRhKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5nYW1tYSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiWlwiKSk7XG5cbiAgICAgICAgY2hhbGxlbmdlcy5hbHBoYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGNoYWxsZW5nZXMuYWxwaGEyID0gRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgY2hhbGxlbmdlcy5hbHBoYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmFscGhhLCAxNikpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgcXVvdGllbnQgcG9seW5vbWlhbCBUKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIFQgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVQoKTtcblxuICAgICAgICAvLyBDb21wdXRlIFtUMV1fMSwgW1QyXV8xLCBbVDNdXzFcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgVCBNU01cIik7XG4gICAgICAgIGxldCBjb21taXRUMSA9IGF3YWl0IHBvbHlub21pYWxzLlQxLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJUMVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFQyID0gYXdhaXQgcG9seW5vbWlhbHMuVDIubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlQyXCIpO1xuICAgICAgICBsZXQgY29tbWl0VDMgPSBhd2FpdCBwb2x5bm9taWFscy5UMy5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiVDNcIik7XG5cbiAgICAgICAgLy8gVGhpcmQgb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtUMV1fMSwgW1QyXV8xLCBbVDNdXzEpXG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJUMVwiLCBjb21taXRUMSk7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJUMlwiLCBjb21taXRUMik7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJUM1wiLCBjb21taXRUMyk7ICAgICAgICBcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlVCgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcilcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgwrfCt8K3IFJlYWRpbmcgc2VjdGlvbnMgJHtaS0VZX1BMX1FMX1NFQ1RJT059LCAke1pLRVlfUExfUVJfU0VDVElPTn1gICtcbiAgICAgICAgICAgICAgICBgLCAke1pLRVlfUExfUU1fU0VDVElPTn0sICR7WktFWV9QTF9RT19TRUNUSU9OfSwgJHtaS0VZX1BMX1FDX1NFQ1RJT059LiBRIHNlbGVjdG9yc2ApO1xuICAgICAgICAvLyBSZXNlcnZlIG1lbW9yeSBmb3IgUSdzIGV2YWx1YXRpb25zXG4gICAgICAgIGV2YWx1YXRpb25zLlFMID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuUVIgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBldmFsdWF0aW9ucy5RTSA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zLlFPID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuUUMgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIFJlYWQgUSdzIGV2YWx1YXRpb25zIGZyb20gemtleSBmaWxlXG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUUwuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1FMX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RUi5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfUVJfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFNLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RTV9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUU8uZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1FPX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RQy5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfUUNfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuXG4gICAgICAgIC8vIFJlYWQgTGFncmFuZ2UgcG9seW5vbWlhbHMgJiBldmFsdWF0aW9ucyBmcm9tIHprZXkgZmlsZVxuICAgICAgICBldmFsdWF0aW9ucy5MYWdyYW5nZSA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0ICogemtleS5uUHVibGljKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5MYWdyYW5nZS5ldmFsLCBpICogc0RvbWFpbiAqIDQsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9MQUdSQU5HRV9TRUNUSU9OXVswXS5wICsgaSAqIDUgKiBzRG9tYWluICsgc0RvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXJzLlQgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KTtcbiAgICAgICAgYnVmZmVycy5UeiA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgVCBldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemUgKiA0OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSlcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYCAgICAgIFQgZXZhbHVhdGlvbiAke2l9LyR7emtleS5kb21haW5TaXplICogNH1gKTtcblxuICAgICAgICAgICAgY29uc3QgYSA9IGV2YWx1YXRpb25zLkEuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBldmFsdWF0aW9ucy5CLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBjID0gZXZhbHVhdGlvbnMuQy5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgeiA9IGV2YWx1YXRpb25zLlouZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IHp3ID0gZXZhbHVhdGlvbnMuWi5nZXRFdmFsdWF0aW9uKCh6a2V5LmRvbWFpblNpemUgKiA0ICsgNCArIGkpICUgKHprZXkuZG9tYWluU2l6ZSAqIDQpKTtcblxuICAgICAgICAgICAgY29uc3QgcW0gPSBldmFsdWF0aW9ucy5RTS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgcWwgPSBldmFsdWF0aW9ucy5RTC5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgcXIgPSBldmFsdWF0aW9ucy5RUi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgcW8gPSBldmFsdWF0aW9ucy5RTy5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgcWMgPSBldmFsdWF0aW9ucy5RQy5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgczEgPSBldmFsdWF0aW9ucy5TaWdtYTEuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IHMyID0gZXZhbHVhdGlvbnMuU2lnbWEyLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBzMyA9IGV2YWx1YXRpb25zLlNpZ21hMy5nZXRFdmFsdWF0aW9uKGkpO1xuXG4gICAgICAgICAgICBjb25zdCBhcCA9IEZyLmFkZChjaGFsbGVuZ2VzLmJbMl0sIEZyLm11bChjaGFsbGVuZ2VzLmJbMV0sIHcpKTtcbiAgICAgICAgICAgIGNvbnN0IGJwID0gRnIuYWRkKGNoYWxsZW5nZXMuYls0XSwgRnIubXVsKGNoYWxsZW5nZXMuYlszXSwgdykpO1xuICAgICAgICAgICAgY29uc3QgY3AgPSBGci5hZGQoY2hhbGxlbmdlcy5iWzZdLCBGci5tdWwoY2hhbGxlbmdlcy5iWzVdLCB3KSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHcyID0gRnIuc3F1YXJlKHcpO1xuICAgICAgICAgICAgY29uc3QgenAgPSBGci5hZGQoRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJbN10sIHcyKSwgRnIubXVsKGNoYWxsZW5nZXMuYls4XSwgdykpLCBjaGFsbGVuZ2VzLmJbOV0pO1xuICAgICAgICAgICAgY29uc3Qgd1cgPSBGci5tdWwodywgRnIud1t6a2V5LnBvd2VyXSk7XG4gICAgICAgICAgICBjb25zdCB3VzIgPSBGci5zcXVhcmUod1cpO1xuICAgICAgICAgICAgY29uc3QgeldwID0gRnIuYWRkKEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iWzddLCB3VzIpLCBGci5tdWwoY2hhbGxlbmdlcy5iWzhdLCB3VykpLCBjaGFsbGVuZ2VzLmJbOV0pO1xuXG4gICAgICAgICAgICBsZXQgcGkgPSBGci56ZXJvO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB6a2V5Lm5QdWJsaWM7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IChqICogNCAqIHprZXkuZG9tYWluU2l6ZSkgKyBpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbFBvbCA9IGV2YWx1YXRpb25zLkxhZ3JhbmdlLmdldEV2YWx1YXRpb24ob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBhVmFsID0gYnVmZmVycy5BLnNsaWNlKGogKiBuOHIsIChqICsgMSkgKiBuOHIpO1xuXG4gICAgICAgICAgICAgICAgcGkgPSBGci5zdWIocGksIEZyLm11bChsUG9sLCBhVmFsKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGUxIDo9IGEoWCliKFgpcU0oWCkgKyBhKFgpcUwoWCkgKyBiKFgpcVIoWCkgKyBjKFgpcU8oWCkgKyBQSShYKSArIHFDKFgpXG4gICAgICAgICAgICBsZXQgW2UxLCBlMXpdID0gTXVsWi5tdWwyKGEsIGIsIGFwLCBicCwgaSAlIDQsIEZyKTtcbiAgICAgICAgICAgIGUxID0gRnIubXVsKGUxLCBxbSk7XG4gICAgICAgICAgICBlMXogPSBGci5tdWwoZTF6LCBxbSk7XG5cbiAgICAgICAgICAgIGUxID0gRnIuYWRkKGUxLCBGci5tdWwoYSwgcWwpKTtcbiAgICAgICAgICAgIGUxeiA9IEZyLmFkZChlMXosIEZyLm11bChhcCwgcWwpKTtcblxuICAgICAgICAgICAgZTEgPSBGci5hZGQoZTEsIEZyLm11bChiLCBxcikpO1xuICAgICAgICAgICAgZTF6ID0gRnIuYWRkKGUxeiwgRnIubXVsKGJwLCBxcikpO1xuXG4gICAgICAgICAgICBlMSA9IEZyLmFkZChlMSwgRnIubXVsKGMsIHFvKSk7XG4gICAgICAgICAgICBlMXogPSBGci5hZGQoZTF6LCBGci5tdWwoY3AsIHFvKSk7XG5cbiAgICAgICAgICAgIGUxID0gRnIuYWRkKGUxLCBwaSk7XG4gICAgICAgICAgICBlMSA9IEZyLmFkZChlMSwgcWMpO1xuXG4gICAgICAgICAgICAvLyBlMiA6PSDOsVsoYShYKSArIM6yWCArIM6zKShiKFgpICsgzrJrMVggKyDOsykoYyhYKSArIM6yazJYICsgzrMpeihYKV1cbiAgICAgICAgICAgIGNvbnN0IGJldGF3ID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgdyk7XG4gICAgICAgICAgICBsZXQgZTJhID0gYTtcbiAgICAgICAgICAgIGUyYSA9IEZyLmFkZChlMmEsIGJldGF3KTtcbiAgICAgICAgICAgIGUyYSA9IEZyLmFkZChlMmEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTJiID0gYjtcbiAgICAgICAgICAgIGUyYiA9IEZyLmFkZChlMmIsIEZyLm11bChiZXRhdywgemtleS5rMSkpO1xuICAgICAgICAgICAgZTJiID0gRnIuYWRkKGUyYiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlMmMgPSBjO1xuICAgICAgICAgICAgZTJjID0gRnIuYWRkKGUyYywgRnIubXVsKGJldGF3LCB6a2V5LmsyKSk7XG4gICAgICAgICAgICBlMmMgPSBGci5hZGQoZTJjLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUyZCA9IHo7XG5cbiAgICAgICAgICAgIGxldCBbZTIsIGUyel0gPSBNdWxaLm11bDQoZTJhLCBlMmIsIGUyYywgZTJkLCBhcCwgYnAsIGNwLCB6cCwgaSAlIDQsIEZyKTtcbiAgICAgICAgICAgIGUyID0gRnIubXVsKGUyLCBjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICAgICAgICAgIGUyeiA9IEZyLm11bChlMnosIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgICAgICAgICAvLyBlMyA6PSDOsVsoYShYKSArIM6yU8+DMShYKSArIM6zKShiKFgpICsgzrJTz4MyKFgpICsgzrMpKGMoWCkgKyDOslPPgzMoWCkgKyDOsyl6KFjPiSldXG4gICAgICAgICAgICBsZXQgZTNhID0gYTtcbiAgICAgICAgICAgIGUzYSA9IEZyLmFkZChlM2EsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHMxKSk7XG4gICAgICAgICAgICBlM2EgPSBGci5hZGQoZTNhLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUzYiA9IGI7XG4gICAgICAgICAgICBlM2IgPSBGci5hZGQoZTNiLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBzMikpO1xuICAgICAgICAgICAgZTNiID0gRnIuYWRkKGUzYiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlM2MgPSBjO1xuICAgICAgICAgICAgZTNjID0gRnIuYWRkKGUzYywgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgczMpKTtcbiAgICAgICAgICAgIGUzYyA9IEZyLmFkZChlM2MsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTNkID0genc7XG4gICAgICAgICAgICBsZXQgW2UzLCBlM3pdID0gTXVsWi5tdWw0KGUzYSwgZTNiLCBlM2MsIGUzZCwgYXAsIGJwLCBjcCwgeldwLCBpICUgNCwgRnIpO1xuXG4gICAgICAgICAgICBlMyA9IEZyLm11bChlMywgY2hhbGxlbmdlcy5hbHBoYSk7XG4gICAgICAgICAgICBlM3ogPSBGci5tdWwoZTN6LCBjaGFsbGVuZ2VzLmFscGhhKTtcblxuICAgICAgICAgICAgLy8gZTQgOj0gzrFeMih6KFgp4oiSMSlMMShYKVxuICAgICAgICAgICAgbGV0IGU0ID0gRnIuc3ViKHosIEZyLm9uZSk7XG4gICAgICAgICAgICBlNCA9IEZyLm11bChlNCwgZXZhbHVhdGlvbnMuTGFncmFuZ2UuZ2V0RXZhbHVhdGlvbihpKSk7XG4gICAgICAgICAgICBlNCA9IEZyLm11bChlNCwgY2hhbGxlbmdlcy5hbHBoYTIpO1xuXG4gICAgICAgICAgICBsZXQgZTR6ID0gRnIubXVsKHpwLCBldmFsdWF0aW9ucy5MYWdyYW5nZS5nZXRFdmFsdWF0aW9uKGkpKTtcbiAgICAgICAgICAgIGU0eiA9IEZyLm11bChlNHosIGNoYWxsZW5nZXMuYWxwaGEyKTtcblxuXG4gICAgICAgICAgICBsZXQgdCA9IEZyLmFkZChGci5zdWIoRnIuYWRkKGUxLCBlMiksIGUzKSwgZTQpO1xuICAgICAgICAgICAgbGV0IHR6ID0gRnIuYWRkKEZyLnN1YihGci5hZGQoZTF6LCBlMnopLCBlM3opLCBlNHopO1xuXG4gICAgICAgICAgICBidWZmZXJzLlQuc2V0KHQsIGkgKiBuOHIpO1xuICAgICAgICAgICAgYnVmZmVycy5Uei5zZXQodHosIGkgKiBuOHIpO1xuXG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlciArIDJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcG9seW5vbWlhbCBUMChYKSBmcm9tIGJ1ZmZlcnMuVDBcbiAgICAgICAgaWYgKGxvZ2dlcilcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgVCBpZmZ0XCIpO1xuICAgICAgICBwb2x5bm9taWFscy5UID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5ULCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBEaXZpZGUgdGhlIHBvbHlub21pYWwgVDAgYnkgWl9IKFgpXG4gICAgICAgIGlmIChsb2dnZXIpXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIFQgLyBaSFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVC5kaXZaaCh6a2V5LmRvbWFpblNpemUsIDQpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcG9seW5vbWlhbCBUeihYKSBmcm9tIGJ1ZmZlcnMuVHpcbiAgICAgICAgaWYgKGxvZ2dlcilcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgVHogaWZmdFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVHogPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlR6LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBBZGQgdGhlIHBvbHlub21pYWwgVDF6IHRvIFQxIHRvIGdldCB0aGUgZmluYWwgcG9seW5vbWlhbCBUMVxuICAgICAgICBwb2x5bm9taWFscy5ULmFkZChwb2x5bm9taWFscy5Ueik7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgIGlmIChwb2x5bm9taWFscy5ULmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSAqIDMgKyA2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHQoeCkgaGFzIGRlZ3JlZSAzbiArIDUsIHdlIGFyZSBnb2luZyB0byBzcGxpdCB0KHgpIGludG8gdGhyZWUgc21hbGxlciBwb2x5bm9taWFsczpcbiAgICAgICAgLy8gVDEnIGFuZCBUMicgIHdpdGggYSBkZWdyZWUgPCBuIGFuZCBUMycgd2l0aCBhIGRlZ3JlZSBuKzVcbiAgICAgICAgLy8gc3VjaCB0aGF0IHQoeCkgPSBUMScoWCkgKyBYXm4gVDInKFgpICsgWF57Mm59IFQzJyhYKVxuICAgICAgICAvLyBUbyByYW5kb21pemUgdGhlIHBhcnRzIHdlIHVzZSBibGluZGluZyBzY2FsYXJzIGJfMTAgYW5kIGJfMTEgaW4gYSB3YXkgdGhhdCBkb2Vzbid0IGNoYW5nZSB0KFgpOlxuICAgICAgICAvLyBUMShYKSA9IFQxJyhYKSArIGJfMTAgWF5uXG4gICAgICAgIC8vIFQyKFgpID0gVDInKFgpIC0gYl8xMCArIGJfMTEgWF5uXG4gICAgICAgIC8vIFQzKFgpID0gVDMnKFgpIC0gYl8xMVxuICAgICAgICAvLyBzdWNoIHRoYXRcbiAgICAgICAgLy8gdChYKSA9IFQxKFgpICsgWF5uIFQyKFgpICsgWF4ybiBUMyhYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIFQxLCBUMiwgVDMgcG9seW5vbWlhbHNcIik7XG4gICAgICAgIHBvbHlub21pYWxzLlQxID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgMSkgKiBuOHIpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDIgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKCh6a2V5LmRvbWFpblNpemUgKyAxKSAqIG44ciksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBwb2x5bm9taWFscy5UMyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDYpICogbjhyKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuVDEuY29lZi5zZXQocG9seW5vbWlhbHMuVC5jb2VmLnNsaWNlKDAsIHNEb21haW4pLCAwKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDIuY29lZi5zZXQocG9seW5vbWlhbHMuVC5jb2VmLnNsaWNlKHNEb21haW4sIHNEb21haW4gKiAyKSwgMCk7XG4gICAgICAgIHBvbHlub21pYWxzLlQzLmNvZWYuc2V0KHBvbHlub21pYWxzLlQuY29lZi5zbGljZShzRG9tYWluICogMiwgc0RvbWFpbiAqIDMgKyA2ICogbjhyKSwgMCk7XG5cbiAgICAgICAgLy8gQWRkIGJsaW5kaW5nIHNjYWxhciBiXzEwIGFzIGEgbmV3IGNvZWZmaWNpZW50IG5cbiAgICAgICAgcG9seW5vbWlhbHMuVDEuc2V0Q29lZih6a2V5LmRvbWFpblNpemUsIGNoYWxsZW5nZXMuYlsxMF0pO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgdF9taWQoWClcbiAgICAgICAgLy8gU3VidHJhY3QgYmxpbmRpbmcgc2NhbGFyIGJfMTAgdG8gdGhlIGxvd2VzdCBjb2VmZmljaWVudCBvZiB0X21pZFxuICAgICAgICBjb25zdCBsb3dlc3RNaWQgPSBGci5zdWIocG9seW5vbWlhbHMuVDIuZ2V0Q29lZigwKSwgY2hhbGxlbmdlcy5iWzEwXSk7XG4gICAgICAgIHBvbHlub21pYWxzLlQyLnNldENvZWYoMCwgbG93ZXN0TWlkKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDIuc2V0Q29lZih6a2V5LmRvbWFpblNpemUsIGNoYWxsZW5nZXMuYlsxMV0pO1xuXG4gICAgICAgIC8vIGNvbXB1dGUgdF9oaWdoKFgpXG4gICAgICAgIC8vU3VidHJhY3QgYmxpbmRpbmcgc2NhbGFyIGJfMTEgdG8gdGhlIGxvd2VzdCBjb2VmZmljaWVudCBvZiB0X2hpZ2hcbiAgICAgICAgY29uc3QgbG93ZXN0SGlnaCA9IEZyLnN1Yihwb2x5bm9taWFscy5UMy5nZXRDb2VmKDApLCBjaGFsbGVuZ2VzLmJbMTFdKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDMuc2V0Q29lZigwLCBsb3dlc3RIaWdoKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDQoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZSB4aVwiKTtcblxuICAgICAgICAvLyBTVEVQIDQuMSAtIENvbXB1dGUgZXZhbHVhdGlvbiBjaGFsbGVuZ2UgeGkg4oiIIEZcbiAgICAgICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJUMVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiVDJcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIlQzXCIpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLnhpID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgY2hhbGxlbmdlcy54aXcgPSBGci5tdWwoY2hhbGxlbmdlcy54aSwgRnIud1t6a2V5LnBvd2VyXSk7XG4gICAgICAgIFxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgY2hhbGxlbmdlcy54aTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnhpLCAxNikpOyAgXG5cbiAgICAgICAgLy8gRm91cnRoIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzICggYSh4aSksIGIoeGkpLCBjKHhpKSwgczEoeGkpLCBzMih4aSksIHooeGl3KSApXG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJldmFsX2FcIiwgcG9seW5vbWlhbHMuQS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJldmFsX2JcIiwgcG9seW5vbWlhbHMuQi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJldmFsX2NcIiwgcG9seW5vbWlhbHMuQy5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJldmFsX3MxXCIsIHBvbHlub21pYWxzLlNpZ21hMS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJldmFsX3MyXCIsIHBvbHlub21pYWxzLlNpZ21hMi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJldmFsX3p3XCIsIHBvbHlub21pYWxzLlouZXZhbHVhdGUoY2hhbGxlbmdlcy54aXcpKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDUoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZSB2XCIpO1xuICAgICAgICBcbiAgICAgICAgLy8gU1RFUCA1LjEgLSBDb21wdXRlIGV2YWx1YXRpb24gY2hhbGxlbmdlIHYg4oiIIEZcbiAgICAgICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLnhpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImV2YWxfYVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJldmFsX2JcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiZXZhbF9jXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImV2YWxfczFcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiZXZhbF9zMlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJldmFsX3p3XCIpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLnYgPSBbXTtcbiAgICAgICAgY2hhbGxlbmdlcy52WzFdID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IGNoYWxsZW5nZXMudjogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnZbMV0sIDE2KSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIGNoYWxsZW5nZXMudltpXSA9IEZyLm11bChjaGFsbGVuZ2VzLnZbaSAtIDFdLCBjaGFsbGVuZ2VzLnZbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU1RFUCA1LjIgQ29tcHV0ZSBsaW5lYXJpc2F0aW9uIHBvbHlub21pYWwgcihYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBsaW5lYXJpc2F0aW9uIHBvbHlub21pYWwgUihYKVwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVIoKTtcblxuICAgICAgICAvL1NURVAgNS4zIENvbXB1dGUgb3BlbmluZyBwcm9vZiBwb2x5bm9taWFsIFd4aShYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBvcGVuaW5nIHByb29mIHBvbHlub21pYWwgV3hpKFgpIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbXB1dGVXeGkoKTtcblxuICAgICAgICAvL1NURVAgNS40IENvbXB1dGUgb3BlbmluZyBwcm9vZiBwb2x5bm9taWFsIFd4aXcoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgb3BlbmluZyBwcm9vZiBwb2x5bm9taWFsIFd4aXcoWCkgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgY29tcHV0ZVd4aXcoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBXeGksIFd4aXcgTVNNXCIpO1xuICAgICAgICBsZXQgY29tbWl0V3hpID0gYXdhaXQgcG9seW5vbWlhbHMuV3hpLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJXeGlcIik7XG4gICAgICAgIGxldCBjb21taXRXeGl3ID0gYXdhaXQgcG9seW5vbWlhbHMuV3hpdy5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiV3hpd1wiKTtcblxuICAgICAgICAvLyBGaWZ0aCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW1d4aV1fMSwgW1d4aXddXzEpXG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJXeGlcIiwgY29tbWl0V3hpKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIld4aXdcIiwgY29tbWl0V3hpdyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVIoKSB7XG4gICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgXG4gICAgICAgIC8vIFJlc2VydmUgbWVtb3J5IGZvciBRJ3MgcG9seW5vbWlhbHNcbiAgICAgICAgcG9seW5vbWlhbHMuUUwgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUVIgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUU0gPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUU8gPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUUMgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBSZWFkIFEncyBldmFsdWF0aW9ucyBmcm9tIHprZXkgZmlsZVxuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFMLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1FMX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFSLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1FSX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFNLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1FNX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFPLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1FPX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFDLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1FDX1NFQ1RJT05dWzBdLnApOyAgIFxuICAgICAgICBcbiAgICAgICAgY2hhbGxlbmdlcy54aW4gPSBjaGFsbGVuZ2VzLnhpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkucG93ZXI7IGkrKykge1xuICAgICAgICAgICAgY2hhbGxlbmdlcy54aW4gPSBGci5zcXVhcmUoY2hhbGxlbmdlcy54aW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhbGxlbmdlcy56aCA9IEZyLnN1YihjaGFsbGVuZ2VzLnhpbiwgRnIub25lKTtcblxuICAgICAgICBjb25zdCBMID0gW107XG5cbiAgICAgICAgY29uc3QgbiA9IEZyLmUoemtleS5kb21haW5TaXplKTtcbiAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IE1hdGgubWF4KDEsIHprZXkublB1YmxpYyk7IGkrKykge1xuICAgICAgICAgICAgTFtpXSA9IEZyLmRpdihGci5tdWwodywgY2hhbGxlbmdlcy56aCksIEZyLm11bChuLCBGci5zdWIoY2hhbGxlbmdlcy54aSwgdykpKTtcbiAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1t6a2V5LnBvd2VyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBldmFsX2wxID0gRnIuZGl2KFxuICAgICAgICAgICAgRnIuc3ViKGNoYWxsZW5nZXMueGluLCBGci5vbmUpLFxuICAgICAgICAgICAgRnIubXVsKG4sIEZyLnN1YihjaGFsbGVuZ2VzLnhpLCBGci5vbmUpKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkxhZ3JhbmdlIEV2YWx1YXRpb25zOiBcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTE7IGk8TC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTCR7aX0oeGkpPWAgKyBGci50b1N0cmluZyhMW2ldLCAxNikpOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBldmFsX3BpID0gRnIuemVybztcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBGci5lKHB1YmxpY1NpZ25hbHNbaV0pO1xuICAgICAgICAgICAgZXZhbF9waSA9IEZyLnN1YihldmFsX3BpLCBGci5tdWwodywgTFtpKzFdKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJQSTogXCIgKyBGci50b1N0cmluZyhldmFsX3BpLCAxNikpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgY29uc3RhbnQgcGFydHMgb2YgUihYKVxuICAgICAgICBjb25zdCBjb2VmX2FiID0gRnIubXVsKHByb29mLmV2YWx1YXRpb25zLmV2YWxfYSwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9iKTtcblxuICAgICAgICBsZXQgZTJhID0gcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9hO1xuICAgICAgICBjb25zdCBiZXRheGkgPSBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBjaGFsbGVuZ2VzLnhpKTtcbiAgICAgICAgZTJhID0gRnIuYWRkKGUyYSwgYmV0YXhpKTtcbiAgICAgICAgZTJhID0gRnIuYWRkKGUyYSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgbGV0IGUyYiA9IHByb29mLmV2YWx1YXRpb25zLmV2YWxfYjtcbiAgICAgICAgZTJiID0gRnIuYWRkKGUyYiwgRnIubXVsKGJldGF4aSwgemtleS5rMSkpO1xuICAgICAgICBlMmIgPSBGci5hZGQoZTJiLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICBsZXQgZTJjID0gcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9jO1xuICAgICAgICBlMmMgPSBGci5hZGQoZTJjLCBGci5tdWwoYmV0YXhpLCB6a2V5LmsyKSk7XG4gICAgICAgIGUyYyA9IEZyLmFkZChlMmMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgIGNvbnN0IGUyID0gRnIubXVsKEZyLm11bChGci5tdWwoZTJhLCBlMmIpLCBlMmMpLCBjaGFsbGVuZ2VzLmFscGhhKTtcblxuICAgICAgICBsZXQgZTNhID0gcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9hO1xuICAgICAgICBlM2EgPSBGci5hZGQoZTNhLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX3MxKSk7XG4gICAgICAgIGUzYSA9IEZyLmFkZChlM2EsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgIGxldCBlM2IgPSBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2I7XG4gICAgICAgIGUzYiA9IEZyLmFkZChlM2IsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLmV2YWxfczIpKTtcbiAgICAgICAgZTNiID0gRnIuYWRkKGUzYiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgbGV0IGUzID0gRnIubXVsKGUzYSwgZTNiKTtcbiAgICAgICAgZTMgPSBGci5tdWwoZTMsIHByb29mLmV2YWx1YXRpb25zLmV2YWxfencpO1xuICAgICAgICBlMyA9IEZyLm11bChlMywgY2hhbGxlbmdlcy5hbHBoYSk7XG5cbiAgICAgICAgY29uc3QgZTQgPSBGci5tdWwoZXZhbF9sMSwgY2hhbGxlbmdlcy5hbHBoYTIpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLlIgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKCh6a2V5LmRvbWFpblNpemUgKyA2KSAqIG44ciksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkKHBvbHlub21pYWxzLlFNLCBjb2VmX2FiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGQocG9seW5vbWlhbHMuUUwsIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYSk7XG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkKHBvbHlub21pYWxzLlFSLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2IpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5RTywgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9jKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGQocG9seW5vbWlhbHMuUUMpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5aLCBlMik7XG4gICAgICAgIHBvbHlub21pYWxzLlIuc3ViKHBvbHlub21pYWxzLlNpZ21hMywgRnIubXVsKGUzLCBjaGFsbGVuZ2VzLmJldGEpKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGQocG9seW5vbWlhbHMuWiwgZTQpO1xuXG4gICAgICAgIGxldCB0bXAgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLlQzLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgdG1wLm11bFNjYWxhcihGci5zcXVhcmUoY2hhbGxlbmdlcy54aW4pKTtcbiAgICAgICAgdG1wLmFkZChwb2x5bm9taWFscy5UMiwgY2hhbGxlbmdlcy54aW4pO1xuICAgICAgICB0bXAuYWRkKHBvbHlub21pYWxzLlQxKTtcbiAgICAgICAgdG1wLm11bFNjYWxhcihjaGFsbGVuZ2VzLnpoKTtcblxuICAgICAgICBwb2x5bm9taWFscy5SLnN1Yih0bXApO1xuXG4gICAgICAgIGxldCByMCA9IEZyLnN1YihldmFsX3BpLCBGci5tdWwoZTMsIEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2MsIGNoYWxsZW5nZXMuZ2FtbWEpKSk7XG4gICAgICAgIHIwID0gRnIuc3ViKHIwLCBlNCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwicjA6IFwiICsgRnIudG9TdHJpbmcocjAsIDE2KSk7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGRTY2FsYXIocjApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXeGkoKSB7XG4gICAgICAgIHBvbHlub21pYWxzLld4aSA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiArIDYgKiBuOHIpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICBwb2x5bm9taWFscy5XeGkuYWRkKHBvbHlub21pYWxzLlIpO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuYWRkKHBvbHlub21pYWxzLkEsIGNoYWxsZW5nZXMudlsxXSk7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5hZGQocG9seW5vbWlhbHMuQiwgY2hhbGxlbmdlcy52WzJdKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLmFkZChwb2x5bm9taWFscy5DLCBjaGFsbGVuZ2VzLnZbM10pO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuYWRkKHBvbHlub21pYWxzLlNpZ21hMSwgY2hhbGxlbmdlcy52WzRdKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLmFkZChwb2x5bm9taWFscy5TaWdtYTIsIGNoYWxsZW5nZXMudls1XSk7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLnN1YlNjYWxhcihGci5tdWwoY2hhbGxlbmdlcy52WzFdLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2EpKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLnN1YlNjYWxhcihGci5tdWwoY2hhbGxlbmdlcy52WzJdLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2IpKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLnN1YlNjYWxhcihGci5tdWwoY2hhbGxlbmdlcy52WzNdLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2MpKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLnN1YlNjYWxhcihGci5tdWwoY2hhbGxlbmdlcy52WzRdLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX3MxKSk7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5zdWJTY2FsYXIoRnIubXVsKGNoYWxsZW5nZXMudls1XSwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9zMikpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLld4aS5kaXZCeVplcm9maWVyKDEsIGNoYWxsZW5nZXMueGkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVXeGl3KCkge1xuICAgICAgICBwb2x5bm9taWFscy5XeGl3ID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5aLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpdy5zdWJTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuZXZhbF96dyk7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuV3hpdy5kaXZCeVplcm9maWVyKDEsIGNoYWxsZW5nZXMueGl3KTtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzOiB1bnN0cmluZ2lmeUJpZ0ludHMkNX0gPSB1dGlscztcblxuYXN5bmMgZnVuY3Rpb24gcGxvbmtGdWxsUHJvdmUoX2lucHV0LCB3YXNtRmlsZSwgemtleUZpbGVOYW1lLCBsb2dnZXIsIHd0bnNDYWxjT3B0aW9ucywgcHJvdmVyT3B0aW9ucykge1xuICAgIGNvbnN0IGlucHV0ID0gdW5zdHJpbmdpZnlCaWdJbnRzJDUoX2lucHV0KTtcblxuICAgIGNvbnN0IHd0bnM9IHtcbiAgICAgICAgdHlwZTogXCJtZW1cIlxuICAgIH07XG4gICAgYXdhaXQgd3Ruc0NhbGN1bGF0ZShpbnB1dCwgd2FzbUZpbGUsIHd0bnMsIHd0bnNDYWxjT3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHBsb25rMTZQcm92ZSh6a2V5RmlsZU5hbWUsIHd0bnMsIGxvZ2dlciwgcHJvdmVyT3B0aW9ucyk7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNvbnN0IHsgdW5zdHJpbmdpZnlCaWdJbnRzOiB1bnN0cmluZ2lmeUJpZ0ludHMkNCB9ID0gdXRpbHM7XG5cbmFzeW5jIGZ1bmN0aW9uIHBsb25rVmVyaWZ5KF92a192ZXJpZmllciwgX3B1YmxpY1NpZ25hbHMsIF9wcm9vZiwgbG9nZ2VyKSB7XG4gICAgbGV0IHZrX3ZlcmlmaWVyID0gdW5zdHJpbmdpZnlCaWdJbnRzJDQoX3ZrX3ZlcmlmaWVyKTtcbiAgICBfcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMkNChfcHJvb2YpO1xuICAgIGxldCBwdWJsaWNTaWduYWxzID0gdW5zdHJpbmdpZnlCaWdJbnRzJDQoX3B1YmxpY1NpZ25hbHMpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21OYW1lKHZrX3ZlcmlmaWVyLmN1cnZlKTtcblxuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUExPTksgVkVSSUZJRVIgU1RBUlRFRFwiKTtcblxuICAgIGxldCBwcm9vZiA9IGZyb21PYmplY3RQcm9vZihjdXJ2ZSxfcHJvb2YpO1xuICAgIHZrX3ZlcmlmaWVyID0gZnJvbU9iamVjdFZrJDEoY3VydmUsIHZrX3ZlcmlmaWVyKTtcblxuICAgIGlmICghaXNXZWxsQ29uc3RydWN0ZWQoY3VydmUsIHByb29mKSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJQcm9vZiBjb21taXRtZW50cyBhcmUgbm90IHZhbGlkLlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwdWJsaWNTaWduYWxzLmxlbmd0aCAhPSB2a192ZXJpZmllci5uUHVibGljKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHB1YmxpYyBpbnB1dHNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWV2YWx1YXRpb25zQXJlVmFsaWQkMShjdXJ2ZSwgcHJvb2YpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlByb29mIGV2YWx1YXRpb25zIGFyZSBub3QgdmFsaWRcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXB1YmxpY0lucHV0c0FyZVZhbGlkJDEoY3VydmUsIHB1YmxpY1NpZ25hbHMpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlB1YmxpYyBpbnB1dHMgYXJlIG5vdCB2YWxpZC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFsbGVuZ2VzID0gY2FsY3VsYXRlY2hhbGxlbmdlcyhjdXJ2ZSwgcHJvb2YsIHB1YmxpY1NpZ25hbHMsIHZrX3ZlcmlmaWVyKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcImJldGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5iZXRhLCAxNikpOyAgICBcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiZ2FtbWE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5nYW1tYSwgMTYpKTsgICAgXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcImFscGhhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYWxwaGEsIDE2KSk7ICAgIFxuICAgICAgICBsb2dnZXIuZGVidWcoXCJ4aTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnhpLCAxNikpO1xuICAgICAgICBmb3IobGV0IGk9MTtpPDY7aSsrKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJ2OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMudltpXSwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoXCJ1OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMudSwgMTYpKTsgICAgXG4gICAgfVxuICAgIGNvbnN0IEwgPSBjYWxjdWxhdGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2a192ZXJpZmllcik7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBmb3IgKGxldCBpPTE7IGk8TC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBMJHtpfSh4aSk9YCArIEZyLnRvU3RyaW5nKExbaV0sIDE2KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHB1YmxpY1NpZ25hbHMubGVuZ3RoICE9IHZrX3ZlcmlmaWVyLm5QdWJsaWMpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTnVtYmVyIG9mIHB1YmxpYyBzaWduYWxzIGRvZXMgbm90IG1hdGNoIHdpdGggdmtcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwaSA9IGNhbGN1bGF0ZVBJJDEoY3VydmUsIHB1YmxpY1NpZ25hbHMsIEwpO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUEkoeGkpOiBcIiArIEZyLnRvU3RyaW5nKHBpLCAxNikpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCByMCA9IGNhbGN1bGF0ZVIwKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgcGksIExbMV0pO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwicjA6IFwiICsgRnIudG9TdHJpbmcocjAsIDE2KSk7XG4gICAgfVxuXG4gICAgY29uc3QgRCA9IGNhbGN1bGF0ZUQoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2a192ZXJpZmllciwgTFsxXSk7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJEOiBcIiArIEcxLnRvU3RyaW5nKEcxLnRvQWZmaW5lKEQpLCAxNikpO1xuICAgIH1cblxuICAgIGNvbnN0IEYgPSBjYWxjdWxhdGVGKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmtfdmVyaWZpZXIsIEQpO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRjogXCIgKyBHMS50b1N0cmluZyhHMS50b0FmZmluZShGKSwgMTYpKTtcbiAgICB9XG5cbiAgICBjb25zdCBFID0gY2FsY3VsYXRlRShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHIwKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkU6IFwiICsgRzEudG9TdHJpbmcoRzEudG9BZmZpbmUoRSksIDE2KSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgaXNWYWxpZFBhaXJpbmckMShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrX3ZlcmlmaWVyLCBFLCBGKTtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJPSyFcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIkludmFsaWQgUHJvb2ZcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5cbmZ1bmN0aW9uIGZyb21PYmplY3RQcm9vZihjdXJ2ZSwgcHJvb2YpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgcmVzLkEgPSBHMS5mcm9tT2JqZWN0KHByb29mLkEpO1xuICAgIHJlcy5CID0gRzEuZnJvbU9iamVjdChwcm9vZi5CKTtcbiAgICByZXMuQyA9IEcxLmZyb21PYmplY3QocHJvb2YuQyk7XG4gICAgcmVzLlogPSBHMS5mcm9tT2JqZWN0KHByb29mLlopO1xuICAgIHJlcy5UMSA9IEcxLmZyb21PYmplY3QocHJvb2YuVDEpO1xuICAgIHJlcy5UMiA9IEcxLmZyb21PYmplY3QocHJvb2YuVDIpO1xuICAgIHJlcy5UMyA9IEcxLmZyb21PYmplY3QocHJvb2YuVDMpO1xuICAgIHJlcy5ldmFsX2EgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfYSk7XG4gICAgcmVzLmV2YWxfYiA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF9iKTtcbiAgICByZXMuZXZhbF9jID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX2MpO1xuICAgIHJlcy5ldmFsX3p3ID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX3p3KTtcbiAgICByZXMuZXZhbF9zMSA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF9zMSk7XG4gICAgcmVzLmV2YWxfczIgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfczIpO1xuICAgIHJlcy5XeGkgPSBHMS5mcm9tT2JqZWN0KHByb29mLld4aSk7XG4gICAgcmVzLld4aXcgPSBHMS5mcm9tT2JqZWN0KHByb29mLld4aXcpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3RWayQxKGN1cnZlLCB2aykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRzIgPSBjdXJ2ZS5HMjtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHJlcyA9IHZrO1xuICAgIHJlcy5RbSA9IEcxLmZyb21PYmplY3QodmsuUW0pO1xuICAgIHJlcy5RbCA9IEcxLmZyb21PYmplY3QodmsuUWwpO1xuICAgIHJlcy5RciA9IEcxLmZyb21PYmplY3QodmsuUXIpO1xuICAgIHJlcy5RbyA9IEcxLmZyb21PYmplY3QodmsuUW8pO1xuICAgIHJlcy5RYyA9IEcxLmZyb21PYmplY3QodmsuUWMpO1xuICAgIHJlcy5TMSA9IEcxLmZyb21PYmplY3QodmsuUzEpO1xuICAgIHJlcy5TMiA9IEcxLmZyb21PYmplY3QodmsuUzIpO1xuICAgIHJlcy5TMyA9IEcxLmZyb21PYmplY3QodmsuUzMpO1xuICAgIHJlcy5rMSA9IEZyLmZyb21PYmplY3QodmsuazEpO1xuICAgIHJlcy5rMiA9IEZyLmZyb21PYmplY3QodmsuazIpO1xuICAgIHJlcy5YXzIgPSBHMi5mcm9tT2JqZWN0KHZrLlhfMik7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBpc1dlbGxDb25zdHJ1Y3RlZChjdXJ2ZSwgcHJvb2YpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5BKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5CKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5DKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5aKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5UMSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuVDIpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFHMS5pc1ZhbGlkKHByb29mLlQzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5XeGkpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFHMS5pc1ZhbGlkKHByb29mLld4aXcpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsdWVCZWxvbmdUb0ZpZWxkJDEoY3VydmUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFNjYWxhci5nZXEodmFsdWUsIDApICYmIFNjYWxhci5sdCh2YWx1ZSwgY3VydmUucik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQkMShjdXJ2ZSwgZXZhbHVhdGlvbikge1xuICAgIHJldHVybiBjaGVja1ZhbHVlQmVsb25nVG9GaWVsZCQxKGN1cnZlLCBTY2FsYXIuZnJvbVJwckxFKGV2YWx1YXRpb24pKTtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGlvbnNBcmVWYWxpZCQxKGN1cnZlLCBwcm9vZikge1xuICAgIHJldHVybiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkJDEoY3VydmUsIHByb29mLmV2YWxfYSlcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZCQxKGN1cnZlLCBwcm9vZi5ldmFsX2IpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQkMShjdXJ2ZSwgcHJvb2YuZXZhbF9jKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkJDEoY3VydmUsIHByb29mLmV2YWxfczEpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQkMShjdXJ2ZSwgcHJvb2YuZXZhbF9zMilcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZCQxKGN1cnZlLCBwcm9vZi5ldmFsX3p3KTtcbn1cblxuZnVuY3Rpb24gcHVibGljSW5wdXRzQXJlVmFsaWQkMShjdXJ2ZSwgcHVibGljSW5wdXRzKSB7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHB1YmxpY0lucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZighY2hlY2tWYWx1ZUJlbG9uZ1RvRmllbGQkMShjdXJ2ZSwgcHVibGljSW5wdXRzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVjaGFsbGVuZ2VzKGN1cnZlLCBwcm9vZiwgcHVibGljU2lnbmFscywgdmspIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgMjogYmV0YSBhbmQgZ2FtbWFcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUW0pO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5RbCk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLlFyKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUW8pO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5RYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLlMxKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUzIpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5TMyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoRnIuZShwdWJsaWNTaWduYWxzW2ldKSk7XG4gICAgfVxuXG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLkEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5CKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuQyk7XG5cbiAgICByZXMuYmV0YSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmJldGEpO1xuICAgIHJlcy5nYW1tYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgMzogYWxwaGFcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmJldGEpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHJlcy5nYW1tYSk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLlopO1xuICAgIHJlcy5hbHBoYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgNDogeGlcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmFscGhhKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuVDEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5UMik7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLlQzKTtcbiAgICByZXMueGkgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgIFxuICAgIC8vIENoYWxsZW5nZSByb3VuZCA1OiB2XG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHJlcy54aSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9hKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsX2IpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWxfYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9zMSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9zMik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF96dyk7XG4gICAgcmVzLnYgPSBbXTtcbiAgICByZXMudlsxXSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICBmb3IgKGxldCBpPTI7IGk8NjsgaSsrICkgcmVzLnZbaV0gPSBGci5tdWwocmVzLnZbaS0xXSwgcmVzLnZbMV0pO1xuXG4gICAgLy8gQ2hhbGxlbmdlOiB1XG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5XeGkpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5XeGl3KTtcbiAgICByZXMudSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2aykge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgeGluID0gY2hhbGxlbmdlcy54aTtcbiAgICBsZXQgZG9tYWluU2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaT0wOyBpPHZrLnBvd2VyOyBpKyspIHtcbiAgICAgICAgeGluID0gRnIuc3F1YXJlKHhpbik7XG4gICAgICAgIGRvbWFpblNpemUgKj0gMjtcbiAgICB9XG4gICAgY2hhbGxlbmdlcy54aW4gPSB4aW47XG5cbiAgICBjaGFsbGVuZ2VzLnpoID0gRnIuc3ViKHhpbiwgRnIub25lKTtcblxuICAgIGNvbnN0IEwgPSBbXTtcblxuICAgIGNvbnN0IG4gPSBGci5lKGRvbWFpblNpemUpO1xuICAgIGxldCB3ID0gRnIub25lO1xuICAgIGZvciAobGV0IGk9MTsgaTw9TWF0aC5tYXgoMSwgdmsublB1YmxpYyk7IGkrKykge1xuICAgICAgICBMW2ldID0gRnIuZGl2KEZyLm11bCh3LCBjaGFsbGVuZ2VzLnpoKSwgRnIubXVsKG4sIEZyLnN1YihjaGFsbGVuZ2VzLnhpLCB3KSkpO1xuICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbdmsucG93ZXJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUEkkMShjdXJ2ZSwgcHVibGljU2lnbmFscywgTCkge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgcGkgPSBGci56ZXJvO1xuICAgIGZvciAobGV0IGk9MDsgaTxwdWJsaWNTaWduYWxzLmxlbmd0aDsgaSsrKSB7ICAgICAgICBcbiAgICAgICAgY29uc3QgdyA9IEZyLmUocHVibGljU2lnbmFsc1tpXSk7XG4gICAgICAgIHBpID0gRnIuc3ViKHBpLCBGci5tdWwodywgTFtpKzFdKSk7XG4gICAgfVxuICAgIHJldHVybiBwaTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUjAoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCBwaSwgbDEpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3QgZTEgPSBwaTtcblxuICAgIGNvbnN0IGUyID0gRnIubXVsKGwxLCBGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSkpO1xuXG4gICAgbGV0IGUzYSA9IEZyLmFkZChwcm9vZi5ldmFsX2EsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWxfczEpKTtcbiAgICBlM2EgPSBGci5hZGQoZTNhLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgIGxldCBlM2IgPSBGci5hZGQocHJvb2YuZXZhbF9iLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MyKSk7XG4gICAgZTNiID0gRnIuYWRkKGUzYiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICBsZXQgZTNjID0gRnIuYWRkKHByb29mLmV2YWxfYywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICBsZXQgZTMgPSBGci5tdWwoRnIubXVsKGUzYSwgZTNiKSwgZTNjKTtcbiAgICBlMyA9IEZyLm11bChlMywgcHJvb2YuZXZhbF96dyk7XG4gICAgZTMgPSBGci5tdWwoZTMsIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgY29uc3QgcjAgPSBGci5zdWIoRnIuc3ViKGUxLCBlMiksIGUzKTtcblxuICAgIHJldHVybiByMDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRChjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrLCBsMSkge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBcbiAgICBsZXQgZDEgPSBHMS50aW1lc0ZyKHZrLlFtLCBGci5tdWwocHJvb2YuZXZhbF9hLCBwcm9vZi5ldmFsX2IpKTtcbiAgICBkMSA9IEcxLmFkZChkMSwgRzEudGltZXNGcih2ay5RbCwgcHJvb2YuZXZhbF9hKSk7XG4gICAgZDEgPSBHMS5hZGQoZDEsIEcxLnRpbWVzRnIodmsuUXIsIHByb29mLmV2YWxfYikpO1xuICAgIGQxID0gRzEuYWRkKGQxLCBHMS50aW1lc0ZyKHZrLlFvLCBwcm9vZi5ldmFsX2MpKTtcbiAgICBkMSA9IEcxLmFkZChkMSwgdmsuUWMpO1xuXG4gICAgY29uc3QgYmV0YXhpID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgY2hhbGxlbmdlcy54aSk7XG5cbiAgICBjb25zdCBkMmExID0gRnIuYWRkKEZyLmFkZChwcm9vZi5ldmFsX2EsIGJldGF4aSksIGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIGNvbnN0IGQyYTIgPSBGci5hZGQoRnIuYWRkKHByb29mLmV2YWxfYiwgRnIubXVsKGJldGF4aSwgdmsuazEpKSwgY2hhbGxlbmdlcy5nYW1tYSk7XG4gICAgY29uc3QgZDJhMyA9IEZyLmFkZChGci5hZGQocHJvb2YuZXZhbF9jLCBGci5tdWwoYmV0YXhpLCB2ay5rMikpLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgIGNvbnN0IGQyYSA9IEZyLm11bChGci5tdWwoRnIubXVsKGQyYTEsIGQyYTIpLCBkMmEzKSwgY2hhbGxlbmdlcy5hbHBoYSk7XG5cbiAgICBjb25zdCBkMmIgPSBGci5tdWwobDEsIEZyLnNxdWFyZShjaGFsbGVuZ2VzLmFscGhhKSk7XG5cbiAgICBjb25zdCBkMiA9IEcxLnRpbWVzRnIocHJvb2YuWiwgRnIuYWRkKEZyLmFkZChkMmEsIGQyYiksIGNoYWxsZW5nZXMudSkpO1xuXG4gICAgY29uc3QgZDNhID0gRnIuYWRkKEZyLmFkZChwcm9vZi5ldmFsX2EsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWxfczEpKSwgY2hhbGxlbmdlcy5nYW1tYSk7XG4gICAgY29uc3QgZDNiID0gRnIuYWRkKEZyLmFkZChwcm9vZi5ldmFsX2IsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWxfczIpKSwgY2hhbGxlbmdlcy5nYW1tYSk7XG4gICAgY29uc3QgZDNjID0gRnIubXVsKEZyLm11bChjaGFsbGVuZ2VzLmFscGhhLCBjaGFsbGVuZ2VzLmJldGEpLCBwcm9vZi5ldmFsX3p3KTtcblxuICAgIGNvbnN0IGQzID0gRzEudGltZXNGcih2ay5TMywgRnIubXVsKEZyLm11bChkM2EsIGQzYiksIGQzYykpO1xuICAgIFxuICAgIGNvbnN0IGQ0bG93ID0gcHJvb2YuVDE7XG4gICAgY29uc3QgZDRtaWQgPSBHMS50aW1lc0ZyKHByb29mLlQyLCBjaGFsbGVuZ2VzLnhpbik7XG4gICAgY29uc3QgZDRoaWdoID0gRzEudGltZXNGcihwcm9vZi5UMywgRnIuc3F1YXJlKGNoYWxsZW5nZXMueGluKSk7XG4gICAgbGV0IGQ0ID0gRzEuYWRkKGQ0bG93LCBHMS5hZGQoZDRtaWQsIGQ0aGlnaCkpO1xuICAgIGQ0ID0gRzEudGltZXNGcihkNCwgY2hhbGxlbmdlcy56aCk7XG5cbiAgICBjb25zdCBkID0gRzEuc3ViKEcxLnN1YihHMS5hZGQoZDEsIGQyKSwgZDMpLCBkNCk7XG5cbiAgICByZXR1cm4gZDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRihjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrLCBEKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcblxuICAgIGxldCByZXMgPSBHMS5hZGQoRCwgRzEudGltZXNGcihwcm9vZi5BLCBjaGFsbGVuZ2VzLnZbMV0pKTtcbiAgICByZXMgPSBHMS5hZGQocmVzLCBHMS50aW1lc0ZyKHByb29mLkIsIGNoYWxsZW5nZXMudlsyXSkpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIocHJvb2YuQywgY2hhbGxlbmdlcy52WzNdKSk7XG4gICAgcmVzID0gRzEuYWRkKHJlcywgRzEudGltZXNGcih2ay5TMSwgY2hhbGxlbmdlcy52WzRdKSk7XG4gICAgcmVzID0gRzEuYWRkKHJlcywgRzEudGltZXNGcih2ay5TMiwgY2hhbGxlbmdlcy52WzVdKSk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVFKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgcjApIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgZSA9IEZyLmFkZChGci5uZWcocjApLCBGci5tdWwoY2hhbGxlbmdlcy52WzFdLCBwcm9vZi5ldmFsX2EpKTtcbiAgICBlID0gRnIuYWRkKGUsIEZyLm11bChjaGFsbGVuZ2VzLnZbMl0sIHByb29mLmV2YWxfYikpO1xuICAgIGUgPSBGci5hZGQoZSwgRnIubXVsKGNoYWxsZW5nZXMudlszXSwgcHJvb2YuZXZhbF9jKSk7XG4gICAgZSA9IEZyLmFkZChlLCBGci5tdWwoY2hhbGxlbmdlcy52WzRdLCBwcm9vZi5ldmFsX3MxKSk7XG4gICAgZSA9IEZyLmFkZChlLCBGci5tdWwoY2hhbGxlbmdlcy52WzVdLCBwcm9vZi5ldmFsX3MyKSk7XG4gICAgZSA9IEZyLmFkZChlLCBGci5tdWwoY2hhbGxlbmdlcy51LCBwcm9vZi5ldmFsX3p3KSk7XG5cbiAgICBjb25zdCByZXMgPSBHMS50aW1lc0ZyKEcxLm9uZSwgZSk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpc1ZhbGlkUGFpcmluZyQxKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmssIEUsIEYpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgQTEgPSBwcm9vZi5XeGk7XG4gICAgQTEgPSBHMS5hZGQoQTEsIEcxLnRpbWVzRnIocHJvb2YuV3hpdywgY2hhbGxlbmdlcy51KSk7XG5cbiAgICBsZXQgQjEgPSBHMS50aW1lc0ZyKHByb29mLld4aSwgY2hhbGxlbmdlcy54aSk7XG4gICAgY29uc3QgcyA9IEZyLm11bChGci5tdWwoY2hhbGxlbmdlcy51LCBjaGFsbGVuZ2VzLnhpKSwgRnIud1t2ay5wb3dlcl0pO1xuICAgIEIxID0gRzEuYWRkKEIxLCBHMS50aW1lc0ZyKHByb29mLld4aXcsIHMpKTtcbiAgICBCMSA9IEcxLmFkZChCMSwgRik7XG4gICAgQjEgPSBHMS5zdWIoQjEsIEUpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUucGFpcmluZ0VxKFxuICAgICAgICBHMS5uZWcoQTEpICwgdmsuWF8yLFxuICAgICAgICBCMSAsIGN1cnZlLkcyLm9uZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIxIDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuY29uc3QgeyB1bnN0cmluZ2lmeUJpZ0ludHM6IHVuc3RyaW5naWZ5QmlnSW50cyQzfSA9IHV0aWxzO1xuXG5mdW5jdGlvbiBwMjU2JDEobikge1xuICAgIGxldCBuc3RyID0gbi50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKG5zdHIubGVuZ3RoIDwgNjQpIG5zdHIgPSBcIjBcIituc3RyO1xuICAgIG5zdHIgPSBgXCIweCR7bnN0cn1cImA7XG4gICAgcmV0dXJuIG5zdHI7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBsb25rRXhwb3J0U29saWRpdHlDYWxsRGF0YShfcHJvb2YsIF9wdWIpIHtcbiAgICBjb25zdCBwcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyQzKF9wcm9vZik7XG4gICAgY29uc3QgcHViID0gdW5zdHJpbmdpZnlCaWdJbnRzJDMoX3B1Yik7XG5cbiAgICBhd2FpdCBnZXRDdXJ2ZUZyb21OYW1lKHByb29mLmN1cnZlKTtcblxuICAgIGxldCBpbnB1dHMgPSBcIlwiO1xuICAgIGZvciAobGV0IGk9MDsgaTxwdWIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlucHV0cyAhPSBcIlwiKSBpbnB1dHMgPSBpbnB1dHMgKyBcIixcIjtcbiAgICAgICAgaW5wdXRzID0gaW5wdXRzICsgcDI1NiQxKHB1YltpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBbJHtwMjU2JDEocHJvb2YuQVswXSl9LCAke3AyNTYkMShwcm9vZi5BWzFdKX0sYCArXG4gICAgYCR7cDI1NiQxKHByb29mLkJbMF0pfSwke3AyNTYkMShwcm9vZi5CWzFdKX0sYCArXG4gICAgYCR7cDI1NiQxKHByb29mLkNbMF0pfSwke3AyNTYkMShwcm9vZi5DWzFdKX0sYCArXG4gICAgYCR7cDI1NiQxKHByb29mLlpbMF0pfSwke3AyNTYkMShwcm9vZi5aWzFdKX0sYCArXG4gICAgYCR7cDI1NiQxKHByb29mLlQxWzBdKX0sJHtwMjU2JDEocHJvb2YuVDFbMV0pfSxgICtcbiAgICBgJHtwMjU2JDEocHJvb2YuVDJbMF0pfSwke3AyNTYkMShwcm9vZi5UMlsxXSl9LGAgK1xuICAgIGAke3AyNTYkMShwcm9vZi5UM1swXSl9LCR7cDI1NiQxKHByb29mLlQzWzFdKX0sYCArXG4gICAgYCR7cDI1NiQxKHByb29mLld4aVswXSl9LCR7cDI1NiQxKHByb29mLld4aVsxXSl9LGAgK1xuICAgIGAke3AyNTYkMShwcm9vZi5XeGl3WzBdKX0sJHtwMjU2JDEocHJvb2YuV3hpd1sxXSl9LGAgK1xuICAgIGAke3AyNTYkMShwcm9vZi5ldmFsX2EpfSxgICsgXG4gICAgYCR7cDI1NiQxKHByb29mLmV2YWxfYil9LGAgKyBcbiAgICBgJHtwMjU2JDEocHJvb2YuZXZhbF9jKX0sYCArIFxuICAgIGAke3AyNTYkMShwcm9vZi5ldmFsX3MxKX0sYCArIFxuICAgIGAke3AyNTYkMShwcm9vZi5ldmFsX3MyKX0sYCArIFxuICAgIGAke3AyNTYkMShwcm9vZi5ldmFsX3p3KX1dYCArIFxuICAgIGBbJHtpbnB1dHN9XWA7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbnZhciBwbG9uayA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgc2V0dXA6IHBsb25rU2V0dXAsXG4gICAgZnVsbFByb3ZlOiBwbG9ua0Z1bGxQcm92ZSxcbiAgICBwcm92ZTogcGxvbmsxNlByb3ZlLFxuICAgIHZlcmlmeTogcGxvbmtWZXJpZnksXG4gICAgZXhwb3J0U29saWRpdHlDYWxsRGF0YTogcGxvbmtFeHBvcnRTb2xpZGl0eUNhbGxEYXRhXG59KTtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLy8gV2UgZXhwb3J0IHRvIHprZXkgdGhlIHNpZ25hbHMgYW5kIHZhbHVlcyBvZiB0aGUgYSwgYiwgYywgcWwsIHFyLCBxbSwgcW8gYW5kIHFjXG5cbi8vIGEsIGIgYW5kIGMgYXJlIHNpZ25hbHMgaWQgKDMyLWJpdCBpbnRlZ2Vycylcbi8vIHFsLCBxciwgcW0sIHFvIGFuZCBxYyBhcmUgZmllbGQgdmFsdWVzXG5cbmZ1bmN0aW9uIGdldEZGbG9ua0NvbnN0YW50Q29uc3RyYWludChzaWduYWwxLCBGcikge1xuICAgIHJldHVybiBbc2lnbmFsMSwgMCwgMCwgRnIub25lLCBGci56ZXJvLCBGci56ZXJvLCBGci56ZXJvLCBGci56ZXJvXTtcbn1cblxuZnVuY3Rpb24gZ2V0RkZsb25rQWRkaXRpb25Db25zdHJhaW50KHNpZ25hbDEsIHNpZ25hbDIsIHNpZ25hbE91dCwgcWwsIHFyLCBxbSwgcW8sIHFjKSB7XG4gICAgcmV0dXJuIFtzaWduYWwxLCBzaWduYWwyLCBzaWduYWxPdXQsIHFsLCBxciwgcW0sIHFvLCBxY107XG59XG5cbmZ1bmN0aW9uIGdldEZGbG9ua011bHRpcGxpY2F0aW9uQ29uc3RyYWludChzaWduYWwxLCBzaWduYWwyLCBzaWduYWxPdXQsIHFsLCBxciwgcW0sIHFvLCBxYywgRnIpIHtcbiAgICByZXR1cm4gW3NpZ25hbDEsIHNpZ25hbDIsIHNpZ25hbE91dCwgcWwsIHFyLCBxbSwgcW8sIHFjXTtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuY29uc3QgTElORUFSX0NPTUJJTkFUSU9OX05VTExBQkxFID0gMDtcbmNvbnN0IExJTkVBUl9DT01CSU5BVElPTl9DT05TVEFOVCA9IDE7XG5jb25zdCBMSU5FQVJfQ09NQklOQVRJT05fVkFSSUFCTEUgPSAyO1xuXG5jbGFzcyByMWNzQ29uc3RyYWludFByb2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IoRnIsIGZuR2V0Q29uc3RhbnRDb25zdHJhaW50LCBmbkdldEFkZGl0aW9uQ29uc3RyYWludCwgZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLkZyID0gRnI7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLmZuR2V0QWRkaXRpb25Db25zdHJhaW50ID0gZm5HZXRBZGRpdGlvbkNvbnN0cmFpbnQ7XG4gICAgICAgIHRoaXMuZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQgPSBmbkdldE11bHRpcGxpY2F0aW9uQ29uc3RyYWludDtcbiAgICB9XG5cbiAgICBwcm9jZXNzUjFjc0NvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaW5lYXJDb21iaW5hdGlvbihsY0EpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUxpbmVhckNvbWJpbmF0aW9uKGxjQik7XG4gICAgICAgIHRoaXMubm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24obGNDKTtcblxuICAgICAgICBjb25zdCBsY3RBID0gdGhpcy5nZXRMaW5lYXJDb21iaW5hdGlvblR5cGUobGNBKTtcbiAgICAgICAgY29uc3QgbGN0QiA9IHRoaXMuZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxjQik7XG5cbiAgICAgICAgaWYgKChsY3RBID09PSBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUpIHx8IChsY3RCID09PSBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUjFjc0FkZGl0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGNDKTtcbiAgICAgICAgfSBlbHNlIGlmIChsY3RBID09PSBMSU5FQVJfQ09NQklOQVRJT05fQ09OU1RBTlQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxjQ0MgPSB0aGlzLmpvaW5MaW5lYXJDb21iaW5hdGlvbnMobGNCLCBsY0MsIGxjQVswXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUjFjc0FkZGl0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGNDQyk7XG4gICAgICAgIH0gZWxzZSBpZiAobGN0QiA9PT0gTElORUFSX0NPTUJJTkFUSU9OX0NPTlNUQU5UKSB7XG4gICAgICAgICAgICBjb25zdCBsY0NDID0gdGhpcy5qb2luTGluZWFyQ29tYmluYXRpb25zKGxjQSwgbGNDLCBsY0JbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1IxY3NBZGRpdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQ0MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1IxY3NNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxpbkNvbSkge1xuICAgICAgICAvLyBsZXQgayA9IHRoaXMuRnIuemVybztcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3Qgc2lnbmFsSWRzID0gT2JqZWN0LmtleXMobGluQ29tKTtcbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYWxJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gICAgIGlmIChzaWduYWxJZHNbaV0gPT09IFwiMFwiKSB7XG4gICAgICAgIC8vICAgICAgICAgayA9IHRoaXMuRnIuYWRkKGssIGxpbkNvbVtzaWduYWxJZHNbaV1dKTtcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9WQVJJQUJMRTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvL1xuICAgICAgICAvLyBpZiAoIXRoaXMuRnIuZXEoaywgdGhpcy5Gci56ZXJvKSkgcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9DT05TVEFOVDtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gcmV0dXJuIExJTkVBUl9DT01CSU5BVElPTl9OVUxMQUJMRTtcblxuICAgICAgICBsZXQgayA9IHRoaXMuRnIuemVybztcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBjb25zdCBzcyA9IE9iamVjdC5rZXlzKGxpbkNvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5Db21bc3NbaV1dID09IDBuKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxpbkNvbVtzc1tpXV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNzW2ldID09IDApIHtcbiAgICAgICAgICAgICAgICBrID0gdGhpcy5Gci5hZGQoaywgbGluQ29tW3NzW2ldXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+IDApIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fVkFSSUFCTEU7XG4gICAgICAgIGlmICghdGhpcy5Gci5pc1plcm8oaykpIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fQ09OU1RBTlQ7XG4gICAgICAgIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEU7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24obGluQ29tKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hbElkcyA9IE9iamVjdC5rZXlzKGxpbkNvbSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmFsSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5Gci5pc1plcm8obGluQ29tW3NpZ25hbElkc1tpXV0pKSBkZWxldGUgbGluQ29tW3NpZ25hbElkc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluQ29tO1xuICAgIH1cblxuICAgIGpvaW5MaW5lYXJDb21iaW5hdGlvbnMobGluQ29tMSwgbGluQ29tMiwgaykge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcblxuICAgICAgICBmb3IgKGxldCBzIGluIGxpbkNvbTEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzW3NdID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXNbc10gPSB0aGlzLkZyLm11bChrLCBsaW5Db20xW3NdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW3NdID0gdGhpcy5Gci5hZGQocmVzW3NdLCB0aGlzLkZyLm11bChrLCBsaW5Db20xW3NdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBzIGluIGxpbkNvbTIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuRnIubmVnKGxpbkNvbTJbc10pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNbc10gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJlc1tzXSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW3NdID0gdGhpcy5Gci5hZGQocmVzW3NdLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24ocmVzKTtcbiAgICB9XG5cbiAgICByZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGluQ29tLCBtYXhDKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgIGs6IHRoaXMuRnIuemVybyxcbiAgICAgICAgICAgIHNpZ25hbHM6IFtdLFxuICAgICAgICAgICAgY29lZnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgc2lnbmFsSWQgaW4gbGluQ29tKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsSWQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlcy5rID0gdGhpcy5Gci5hZGQocmVzLmssIGxpbkNvbVtzaWduYWxJZF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5Db21bc2lnbmFsSWRdICE9IDBuKSB7XG4gICAgICAgICAgICAgICAgY3MucHVzaChbTnVtYmVyKHNpZ25hbElkKSwgbGluQ29tW3NpZ25hbElkXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGNzLmxlbmd0aCA+IG1heEMpIHtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gY3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gY3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNvID0gc2V0dGluZ3MublZhcnMrKztcblxuICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmZuR2V0QWRkaXRpb25Db25zdHJhaW50KFxuICAgICAgICAgICAgICAgIGMxWzBdLCBjMlswXSwgc28sXG4gICAgICAgICAgICAgICAgdGhpcy5Gci5uZWcoYzFbMV0pLCB0aGlzLkZyLm5lZyhjMlsxXSksIHRoaXMuRnIuemVybywgdGhpcy5Gci5vbmUsIHRoaXMuRnIuemVybyk7XG5cbiAgICAgICAgICAgIGNvbnN0cmFpbnRzQXJyLnB1c2goY29uc3RyYWludHMpO1xuICAgICAgICAgICAgYWRkaXRpb25zQXJyLnB1c2goW2MxWzBdLCBjMlswXSwgYzFbMV0sIGMyWzFdXSk7XG5cbiAgICAgICAgICAgIGNzLnB1c2goW3NvLCB0aGlzLkZyLm9uZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzLnNpZ25hbHNbaV0gPSBjc1tpXVswXTtcbiAgICAgICAgICAgIHJlcy5jb2Vmc1tpXSA9IGNzW2ldWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHJlcy5jb2Vmcy5sZW5ndGggPCBtYXhDKSB7XG4gICAgICAgICAgICByZXMuc2lnbmFscy5wdXNoKDApO1xuICAgICAgICAgICAgcmVzLmNvZWZzLnB1c2godGhpcy5Gci56ZXJvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgcHJvY2Vzc1IxY3NBZGRpdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxpbkNvbSkge1xuICAgICAgICBjb25zdCBjb25zdHJhaW50c0FyciA9IFtdO1xuICAgICAgICBjb25zdCBhZGRpdGlvbnNBcnIgPSBbXTtcblxuICAgICAgICBjb25zdCBDID0gdGhpcy5yZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGluQ29tLCAzKTtcblxuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuZm5HZXRBZGRpdGlvbkNvbnN0cmFpbnQoXG4gICAgICAgICAgICBDLnNpZ25hbHNbMF0sIEMuc2lnbmFsc1sxXSwgQy5zaWduYWxzWzJdLFxuICAgICAgICAgICAgQy5jb2Vmc1swXSwgQy5jb2Vmc1sxXSwgdGhpcy5Gci56ZXJvLCBDLmNvZWZzWzJdLCBDLmspO1xuXG4gICAgICAgIGNvbnN0cmFpbnRzQXJyLnB1c2goY29uc3RyYWludHMpO1xuXG4gICAgICAgIHJldHVybiBbY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0Fycl07XG4gICAgfVxuXG4gICAgcHJvY2Vzc1IxY3NNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHNBcnIgPSBbXTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25zQXJyID0gW107XG5cbiAgICAgICAgY29uc3QgQSA9IHRoaXMucmVkdWNlQ29lZnMoc2V0dGluZ3MsIGNvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnIsIGxjQSwgMSk7XG4gICAgICAgIGNvbnN0IEIgPSB0aGlzLnJlZHVjZUNvZWZzKHNldHRpbmdzLCBjb25zdHJhaW50c0FyciwgYWRkaXRpb25zQXJyLCBsY0IsIDEpO1xuICAgICAgICBjb25zdCBDID0gdGhpcy5yZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGNDLCAxKTtcblxuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQoXG4gICAgICAgICAgICBBLnNpZ25hbHNbMF0sIEIuc2lnbmFsc1swXSwgQy5zaWduYWxzWzBdLFxuICAgICAgICAgICAgdGhpcy5Gci5tdWwoQS5jb2Vmc1swXSwgQi5rKSxcbiAgICAgICAgICAgIHRoaXMuRnIubXVsKEEuaywgQi5jb2Vmc1swXSksXG4gICAgICAgICAgICB0aGlzLkZyLm11bChBLmNvZWZzWzBdLCBCLmNvZWZzWzBdKSxcbiAgICAgICAgICAgIHRoaXMuRnIubmVnKEMuY29lZnNbMF0pLFxuICAgICAgICAgICAgdGhpcy5Gci5zdWIodGhpcy5Gci5tdWwoQS5rLCBCLmspLCBDLmspKTtcblxuICAgICAgICBjb25zdHJhaW50c0Fyci5wdXNoKGNvbnN0cmFpbnRzKTtcblxuICAgICAgICByZXR1cm4gW2NvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnJdO1xuICAgIH1cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuY2xhc3MgQ1BvbHlub21pYWwge1xuICAgIGNvbnN0cnVjdG9yKG4sIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5uID0gbjtcbiAgICAgICAgdGhpcy5wb2x5bm9taWFscyA9IEFycmF5KG4pLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICB0aGlzLkZyID0gY3VydmUuRnI7XG4gICAgICAgIHRoaXMuRzEgPSBjdXJ2ZS5HMTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuXG4gICAgYWRkUG9seW5vbWlhbChwb3NpdGlvbiwgcG9seW5vbWlhbCkge1xuICAgICAgICBpZiAocG9zaXRpb24gPiB0aGlzLm4gLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDUG9seW5vbWlhbDphZGRQb2x5bm9taWFsLCBjYW5ub3QgYWRkIGEgcG9seW5vbWlhbCB0byBhIHBvc2l0aW9uIGdyZWF0ZXIgdGhhbiBuLTFcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvbHlub21pYWxzW3Bvc2l0aW9uXSA9IHBvbHlub21pYWw7XG4gICAgfVxuXG4gICAgZGVncmVlKCkge1xuICAgICAgICBsZXQgZGVncmVlcyA9IHRoaXMucG9seW5vbWlhbHMubWFwKFxuICAgICAgICAgICAgKHBvbHlub21pYWwsIGluZGV4KSA9PiBwb2x5bm9taWFsID09PSB1bmRlZmluZWQgPyAwIDogcG9seW5vbWlhbC5kZWdyZWUoKSAqIHRoaXMubiArIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KC4uLmRlZ3JlZXMpO1xuICAgIH1cblxuICAgIGdldFBvbHlub21pYWwoKSB7XG4gICAgICAgIGxldCBkZWdyZWVzID0gdGhpcy5wb2x5bm9taWFscy5tYXAocG9seW5vbWlhbCA9PiBwb2x5bm9taWFsID09PSB1bmRlZmluZWQgPyAwIDogcG9seW5vbWlhbC5kZWdyZWUoKSk7XG4gICAgICAgIGNvbnN0IG1heERlZ3JlZSA9IHRoaXMuZGVncmVlKCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aEJ1ZmZlciA9IDIgKiogKGxvZzIobWF4RGVncmVlIC0gMSkgKyAxKTtcbiAgICAgICAgY29uc3Qgc0ZyID0gdGhpcy5Gci5uODtcblxuICAgICAgICBsZXQgcG9seW5vbWlhbCA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIobGVuZ3RoQnVmZmVyICogc0ZyKSwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4RGVncmVlOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogc0ZyO1xuICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpX244ICogdGhpcy5uO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9seW5vbWlhbHNbal0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8PSBkZWdyZWVzW2pdKSBwb2x5bm9taWFsLmNvZWYuc2V0KHRoaXMucG9seW5vbWlhbHNbal0uY29lZi5zbGljZShpX244LCBpX244ICsgc0ZyKSwgaV9zRnIgKyBqICogc0ZyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seW5vbWlhbDtcbiAgICB9XG5cbiAgICBhc3luYyBtdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIG5hbWUpIHtcbiAgICAgICAgbGV0IHBvbHlub21pYWwgPSB0aGlzLmdldFBvbHlub21pYWwoKTtcbiAgICAgICAgY29uc3QgbiA9IHBvbHlub21pYWwuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uODtcbiAgICAgICAgY29uc3QgUFRhdU4gPSBQVGF1LnNsaWNlKDAsIG4gKiB0aGlzLkcxLkYubjggKiAyKTtcbiAgICAgICAgY29uc3QgYm0gPSBhd2FpdCB0aGlzLkZyLmJhdGNoRnJvbU1vbnRnb21lcnkocG9seW5vbWlhbC5jb2VmKTtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHRoaXMuRzEubXVsdGlFeHBBZmZpbmUoUFRhdU4sIGJtLCB0aGlzLmxvZ2dlciwgbmFtZSk7XG4gICAgICAgIHJlcyA9IHRoaXMuRzEudG9BZmZpbmUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuYXN5bmMgZnVuY3Rpb24gZmZsb25rU2V0dXAocjFjc0ZpbGVuYW1lLCBwdGF1RmlsZW5hbWUsIHprZXlGaWxlbmFtZSwgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgU0VUVVAgU1RBUlRFRFwiKTtcblxuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBSZWFkIFBUYXUgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIFBUYXUgZmlsZVwiKTtcbiAgICBjb25zdCB7ZmQ6IGZkUFRhdSwgc2VjdGlvbnM6IHBUYXVTZWN0aW9uc30gPSBhd2FpdCByZWFkQmluRmlsZShwdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBpZiAoIXBUYXVTZWN0aW9uc1sxMl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG93ZXJzIG9mIFRhdSBpcyBub3Qgd2VsbCBwcmVwYXJlZC4gU2VjdGlvbiAxMiBtaXNzaW5nLlwiKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgY3VydmUgZGVmaW5lZCBpbiBQVGF1XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IEdldHRpbmcgY3VydmUgZnJvbSBQVGF1IHNldHRpbmdzXCIpO1xuICAgIGNvbnN0IHtjdXJ2ZX0gPSBhd2FpdCByZWFkUFRhdUhlYWRlcihmZFBUYXUsIHBUYXVTZWN0aW9ucyk7XG5cbiAgICAvLyBSZWFkIHIxY3MgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIHIxY3MgZmlsZVwiKTtcbiAgICBjb25zdCB7ZmQ6IGZkUjFjcywgc2VjdGlvbnM6IHNlY3Rpb25zUjFjc30gPSBhd2FpdCByZWFkQmluRmlsZShyMWNzRmlsZW5hbWUsIFwicjFjc1wiLCAxKTtcbiAgICBjb25zdCByMWNzID0gYXdhaXQgcmVhZFIxY3NGZChmZFIxY3MsIHNlY3Rpb25zUjFjcywge2xvYWRDb25zdHJhaW50czogZmFsc2UsIGxvYWRDdXN0b21HYXRlczogdHJ1ZX0pO1xuXG4gICAgLy8gUG90ZW50aWFsIGVycm9yIGNoZWNrc1xuICAgIGlmIChyMWNzLnByaW1lICE9PSBjdXJ2ZS5yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInIxY3MgY3VydmUgZG9lcyBub3QgbWF0Y2ggcG93ZXJzIG9mIHRhdSBjZXJlbW9ueSBjdXJ2ZVwiKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXphdGlvbnNcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3Qgc0ZyID0gY3VydmUuRnIubjg7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCAqIDI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCAqIDI7XG5cbiAgICBsZXQgcG9seW5vbWlhbHMgPSB7fTtcbiAgICBsZXQgZXZhbHVhdGlvbnMgPSB7fTtcbiAgICBsZXQgUFRhdTtcblxuICAgIGxldCBzZXR0aW5ncyA9IHtcbiAgICAgICAgblZhcnM6IHIxY3MublZhcnMsXG4gICAgICAgIG5QdWJsaWM6IHIxY3Mubk91dHB1dHMgKyByMWNzLm5QdWJJbnB1dHNcbiAgICB9O1xuXG4gICAgY29uc3QgcGxvbmtDb25zdHJhaW50cyA9IG5ldyBCaWdBcnJheSQxKCk7XG4gICAgbGV0IHBsb25rQWRkaXRpb25zID0gbmV3IEJpZ0FycmF5JDEoKTtcblxuICAgIC8vIFByb2Nlc3MgY29uc3RyYWludHMgaW5zaWRlIHIxY3NcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUHJvY2Vzc2luZyBGRmxvbmsgY29uc3RyYWludHNcIik7XG4gICAgYXdhaXQgY29tcHV0ZUZGQ29uc3RyYWludHMoY3VydmUuRnIsIHIxY3MsIGxvZ2dlcik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIC8vIEFzIHRoZSB0IHBvbHlub21pYWwgaXMgbis1IHdlIG5lZWQgYXQgbGVhc3QgYSBwb3dlciBvZiA0XG4gICAgLy9UT0RPIGNoZWNrISEhIVxuICAgIC8vIE5PVEUgOiBwbG9ua0NvbnN0cmFpbnRzICsgMiA9ICNjb25zdHJhaW50cyArIGJsaW5kaW5nIGNvZWZmaWNpZW50cyBmb3IgZWFjaCB3aXJlIHBvbHlub21pYWxcbiAgICBzZXR0aW5ncy5jaXJQb3dlciA9IE1hdGgubWF4KEZGX1RfUE9MX0RFR19NSU4sIGxvZzIoKHBsb25rQ29uc3RyYWludHMubGVuZ3RoICsgMikgLSAxKSArIDEpO1xuICAgIHNldHRpbmdzLmRvbWFpblNpemUgPSAyICoqIHNldHRpbmdzLmNpclBvd2VyO1xuXG4gICAgaWYgKHBUYXVTZWN0aW9uc1syXVswXS5zaXplIDwgKHNldHRpbmdzLmRvbWFpblNpemUgKiA5ICsgMTgpICogc0cxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VycyBvZiBUYXUgaXMgbm90IGJpZyBlbm91Z2ggZm9yIHRoaXMgY2lyY3VpdCBzaXplLiBTZWN0aW9uIDIgdG9vIHNtYWxsLlwiKTtcbiAgICB9XG4gICAgaWYgKHBUYXVTZWN0aW9uc1szXVswXS5zaXplIDwgc0cyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VycyBvZiBUYXUgaXMgbm90IHdlbGwgcHJlcGFyZWQuIFNlY3Rpb24gMyB0b28gc21hbGwuXCIpO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIiAgRkZMT05LIFNFVFVQIFNFVFRJTkdTXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXJ2ZTogICAgICAgICAke2N1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENpcmN1aXQgcG93ZXI6ICR7c2V0dGluZ3MuY2lyUG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIERvbWFpbiBzaXplOiAgICR7c2V0dGluZ3MuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgVmFyczogICAgICAgICAgJHtzZXR0aW5ncy5uVmFyc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHVibGljIHZhcnM6ICAgJHtzZXR0aW5ncy5uUHVibGljfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDb25zdHJhaW50czogICAke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBBZGRpdGlvbnM6ICAgICAke3Bsb25rQWRkaXRpb25zLmxlbmd0aH1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgazEgYW5kIGsyIHRvIGJlIHVzZWQgaW4gdGhlIHBlcm11dGF0aW9uIGNoZWNrc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBjb21wdXRpbmcgazEgYW5kIGsyXCIpO1xuICAgIGNvbnN0IFtrMSwgazJdID0gY29tcHV0ZUsxSzIoKTtcblxuICAgIC8vIENvbXB1dGUgb21lZ2EgMyAodzMpIGFuZCBvbWVnYSA0ICh3NCkgdG8gYmUgdXNlZCBpbiB0aGUgcHJvdmVyIGFuZCB0aGUgdmVyaWZpZXJcbiAgICAvLyB3M14zID0gMSBhbmQgIHc0XjQgPSAxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyB3M1wiKTtcbiAgICBjb25zdCB3MyA9IGNvbXB1dGVXMygpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBjb21wdXRpbmcgdzRcIik7XG4gICAgY29uc3QgdzQgPSBjb21wdXRlVzQoKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gY29tcHV0aW5nIHc4XCIpO1xuICAgIGNvbnN0IHc4ID0gY29tcHV0ZVc4KCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyB3clwiKTtcbiAgICBjb25zdCB3ciA9IGdldE9tZWdhQ3ViaWNSb290KHNldHRpbmdzLmNpclBvd2VyLCBjdXJ2ZS5Gcik7XG5cbiAgICAvLyBXcml0ZSBvdXRwdXQgemtleSBmaWxlXG4gICAgYXdhaXQgd3JpdGVaa2V5RmlsZSgpO1xuXG4gICAgYXdhaXQgZmRSMWNzLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRQVGF1LmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBTRVRVUCBGSU5JU0hFRFwiKTtcblxuICAgIHJldHVybiAwO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUZGQ29uc3RyYWludHMoRnIsIHIxY3MsIGxvZ2dlcikge1xuICAgICAgICAvLyBBZGQgcHVibGljIGlucHV0cyBhbmQgb3V0cHV0c1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLm5QdWJsaWM7IGkrKykge1xuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKGdldEZGbG9ua0NvbnN0YW50Q29uc3RyYWludChpICsgMSwgRnIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBhbGwgY29uc3RyYWludHMgZnJvbSByMWNzIGZpbGVcbiAgICAgICAgY29uc3QgcjFjc1Byb2Nlc3NvciA9IG5ldyByMWNzQ29uc3RyYWludFByb2Nlc3NvcihGciwgZ2V0RkZsb25rQ29uc3RhbnRDb25zdHJhaW50LCBnZXRGRmxvbmtBZGRpdGlvbkNvbnN0cmFpbnQsIGdldEZGbG9ua011bHRpcGxpY2F0aW9uQ29uc3RyYWludCwgbG9nZ2VyKTtcblxuICAgICAgICBjb25zdCBiUjFjcyA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkUjFjcywgc2VjdGlvbnNSMWNzLCAyKTtcbiAgICAgICAgbGV0IGJSMWNzUG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByMWNzLm5Db25zdHJhaW50czsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGkgIT09IDApICYmIChpICUgNTAwMDAwID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGAgICAgcHJvY2Vzc2luZyByMWNzIGNvbnN0cmFpbnRzICR7aX0vJHtyMWNzLm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtjb25zdHJhaW50cywgYWRkaXRpb25zXSA9IHIxY3NQcm9jZXNzb3IucHJvY2Vzc1IxY3NDb25zdHJhaW50KHNldHRpbmdzLCAuLi5yZWFkQ29uc3RyYWludCgpKTtcblxuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKC4uLmNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIHBsb25rQWRkaXRpb25zLnB1c2goLi4uYWRkaXRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRDb25zdHJhaW50KCkge1xuICAgICAgICAgICAgY29uc3QgYyA9IFtdO1xuICAgICAgICAgICAgY1swXSA9IHJlYWRMQygpO1xuICAgICAgICAgICAgY1sxXSA9IHJlYWRMQygpO1xuICAgICAgICAgICAgY1syXSA9IHJlYWRMQygpO1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkTEMoKSB7XG4gICAgICAgICAgICBjb25zdCBsYyA9IHt9O1xuXG4gICAgICAgICAgICBjb25zdCBidWZmVUwzMiA9IGJSMWNzLnNsaWNlKGJSMWNzUG9zLCBiUjFjc1BvcyArIDQpO1xuICAgICAgICAgICAgYlIxY3NQb3MgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZVTDMyViA9IG5ldyBEYXRhVmlldyhidWZmVUwzMi5idWZmZXIpO1xuICAgICAgICAgICAgY29uc3QgbklkeCA9IGJ1ZmZVTDMyVi5nZXRVaW50MzIoMCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBiUjFjcy5zbGljZShiUjFjc1BvcywgYlIxY3NQb3MgKyAoNCArIHIxY3MubjgpICogbklkeCk7XG4gICAgICAgICAgICBiUjFjc1BvcyArPSAoNCArIHIxY3MubjgpICogbklkeDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbklkeDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gYnVmZlYuZ2V0VWludDMyKGkgKiAoNCArIHIxY3MubjgpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSByMWNzLkYuZnJvbVJwckxFKGJ1ZmYsIGkgKiAoNCArIHIxY3MubjgpICsgNCk7XG4gICAgICAgICAgICAgICAgbGNbaWR4XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlWmtleUZpbGUoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBXcml0aW5nIHRoZSB6a2V5IGZpbGVcIik7XG4gICAgICAgIGNvbnN0IGZkWktleSA9IGF3YWl0IGNyZWF0ZUJpbkZpbGUoemtleUZpbGVuYW1lLCBcInprZXlcIiwgMSwgWktFWV9GRl9OU0VDVElPTlMsIDEgPDwgMjIsIDEgPDwgMjQpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7SEVBREVSX1pLRVlfU0VDVElPTn0uIFprZXkgSGVhZGVyYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlWmtleUhlYWRlcihmZFpLZXkpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9BRERJVElPTlNfU0VDVElPTn0uIEFkZGl0aW9uc2ApO1xuICAgICAgICBhd2FpdCB3cml0ZUFkZGl0aW9ucyhmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9BX01BUF9TRUNUSU9OfS4gQSBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9BX01BUF9TRUNUSU9OLCAwLCBcIkEgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9CX01BUF9TRUNUSU9OfS4gQiBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9CX01BUF9TRUNUSU9OLCAxLCBcIkIgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9DX01BUF9TRUNUSU9OfS4gQyBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9DX01BUF9TRUNUSU9OLCAyLCBcIkMgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RTF9TRUNUSU9OfS4gUUxgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RTF9TRUNUSU9OLCAzLCBcIlFMXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RUl9TRUNUSU9OfS4gUVJgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RUl9TRUNUSU9OLCA0LCBcIlFSXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RTV9TRUNUSU9OfS4gUU1gKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RTV9TRUNUSU9OLCA1LCBcIlFNXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RT19TRUNUSU9OfS4gUU9gKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RT19TRUNUSU9OLCA2LCBcIlFPXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RQ19TRUNUSU9OfS4gUUNgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RQ19TRUNUSU9OLCA3LCBcIlFDXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9ucyAke1pLRVlfRkZfU0lHTUExX1NFQ1RJT059LCR7WktFWV9GRl9TSUdNQTJfU0VDVElPTn0sJHtaS0VZX0ZGX1NJR01BM19TRUNUSU9OfS4gU2lnbWExLCBTaWdtYTIgJiBTaWdtYSAzYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlU2lnbWEoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfTEFHUkFOR0VfU0VDVElPTn0uIExhZ3JhbmdlIFBvbHlub21pYWxzYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlTGFncmFuZ2VQb2x5bm9taWFscyhmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9QVEFVX1NFQ1RJT059LiBQb3dlcnMgb2YgVGF1YCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUHRhdShmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9DMF9TRUNUSU9OfS4gQzBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVDMChmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9IRUFERVJfU0VDVElPTn0uIEZGbG9uayBIZWFkZXJgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVGRmxvbmtIZWFkZXIoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gV3JpdGluZyB0aGUgemtleSBmaWxlIGZpbmlzaGVkXCIpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlWmtleUhlYWRlcihmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBIRUFERVJfWktFWV9TRUNUSU9OKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoRkZMT05LX1BST1RPQ09MX0lEKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVBZGRpdGlvbnMoZmRaS2V5KSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgWktFWV9GRl9BRERJVElPTlNfU0VDVElPTik7XG5cbiAgICAgICAgLy8gV3JpdHRlbiB2YWx1ZXMgYXJlIDIgKiAzMiBiaXQgaW50ZWdlcnMgKDIgKiA0IGJ5dGVzKSArIDIgZmllbGQgc2l6ZSB2YWx1ZXMgKCAyICogc0ZyIGJ5dGVzKVxuICAgICAgICBjb25zdCBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoOCArIDIgKiBzRnIpO1xuICAgICAgICBjb25zdCBidWZmT3V0ViA9IG5ldyBEYXRhVmlldyhidWZmT3V0LmJ1ZmZlcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbG9ua0FkZGl0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgICB3cml0aW5nIEFkZGl0aW9uczogJHtpfS8ke3Bsb25rQWRkaXRpb25zLmxlbmd0aH1gKTtcblxuICAgICAgICAgICAgY29uc3QgYWRkaXRpb24gPSBwbG9ua0FkZGl0aW9uc1tpXTtcblxuICAgICAgICAgICAgYnVmZk91dFYuc2V0VWludDMyKDAsIGFkZGl0aW9uWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIGJ1ZmZPdXRWLnNldFVpbnQzMig0LCBhZGRpdGlvblsxXSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblsyXSwgOCk7XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblszXSwgOCArIHNGcik7XG5cbiAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZShidWZmT3V0KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVdpdG5lc3NNYXAoZmRaS2V5LCBzZWN0aW9uTnVtLCBwb3NDb25zdHJhaW50LCBuYW1lKSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCAgICAgIHdyaXRpbmcgd2l0bmVzcyAke25hbWV9OiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQ29uc3RyYWludHNbaV1bcG9zQ29uc3RyYWludF0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUU1hcChmZFpLZXksIHNlY3Rpb25OdW0sIHBvc0NvbnN0cmFpbnQsIG5hbWUpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBRIGZyb20gcSBldmFsdWF0aW9uc1xuICAgICAgICBsZXQgUSA9IG5ldyBCaWdCdWZmZXIoc2V0dGluZ3MuZG9tYWluU2l6ZSAqIHNGcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBRLnNldChwbG9ua0NvbnN0cmFpbnRzW2ldW3Bvc0NvbnN0cmFpbnRdLCBpICogc0ZyKTtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCAgICAgIHdyaXRpbmcgJHtuYW1lfTogJHtpfS8ke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9seW5vbWlhbHNbbmFtZV0gPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhRLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgZXZhbHVhdGlvbnNbbmFtZV0gPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFsc1tuYW1lXSwgNCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gV3JpdGUgUSBjb2VmZmljaWVudHMgYW5kIGV2YWx1YXRpb25zXG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShwb2x5bm9taWFsc1tuYW1lXS5jb2VmKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGV2YWx1YXRpb25zW25hbWVdLmV2YWwpO1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVNpZ21hKGZkWktleSkge1xuICAgICAgICAvLyBDb21wdXRlIHNpZ21hXG4gICAgICAgIGNvbnN0IHNpZ21hID0gbmV3IEJpZ0J1ZmZlcihzRnIgKiBzZXR0aW5ncy5kb21haW5TaXplICogMyk7XG4gICAgICAgIGNvbnN0IGxhc3RTZWVuID0gbmV3IEJpZ0FycmF5JDEoc2V0dGluZ3MublZhcnMpO1xuICAgICAgICBjb25zdCBmaXJzdFBvcyA9IG5ldyBCaWdBcnJheSQxKHNldHRpbmdzLm5WYXJzKTtcblxuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgcGxvbmtDb25zdHJhaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKHBsb25rQ29uc3RyYWludHNbaV1bMF0sIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsxXSwgc2V0dGluZ3MuZG9tYWluU2l6ZSArIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVsyXSwgc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDIgKyBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IHNldHRpbmdzLmRvbWFpblNpemUgLSAyKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIHNldHRpbmdzLmRvbWFpblNpemUgKyBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIHNldHRpbmdzLmRvbWFpblNpemUgKiAyICsgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldCh3LCBpICogc0ZyKTtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQoRnIubXVsKHcsIGsxKSwgKHNldHRpbmdzLmRvbWFpblNpemUgKyBpKSAqIHNGcik7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KEZyLm11bCh3LCBrMiksIChzZXR0aW5ncy5kb21haW5TaXplICogMiArIGkpICogc0ZyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3NldHRpbmdzLmNpclBvd2VyXSk7XG5cbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCAgICAgIHdyaXRpbmcgc2lnbWEgcGhhc2UxOiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLm5WYXJzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlyc3RQb3NbaV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQobGFzdFNlZW5baV0sIGZpcnN0UG9zW2ldICogc0ZyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgbm90IHVzZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWYXJpYWJsZSBub3QgdXNlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgICAgd3JpdGluZyBzaWdtYSBwaGFzZTI6ICR7aX0vJHtzZXR0aW5ncy5uVmFyc31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAgICAgLy8gV3JpdGUgc2lnbWEgY29lZmZpY2llbnRzIGFuZCBldmFsdWF0aW9uc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvbklkID0gMCA9PT0gaSA/IFpLRVlfRkZfU0lHTUExX1NFQ1RJT04gOiAxID09PSBpID8gWktFWV9GRl9TSUdNQTJfU0VDVElPTiA6IFpLRVlfRkZfU0lHTUEzX1NFQ1RJT047XG5cbiAgICAgICAgICAgIGxldCBuYW1lID0gXCJTXCIgKyAoaSArIDEpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHNbbmFtZV0gPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhzaWdtYS5zbGljZShzZXR0aW5ncy5kb21haW5TaXplICogc0ZyICogaSwgc2V0dGluZ3MuZG9tYWluU2l6ZSAqIHNGciAqIChpICsgMSkpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zW25hbWVdID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHNbbmFtZV0sIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uSWQpO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHBvbHlub21pYWxzW25hbWVdLmNvZWYpO1xuICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGV2YWx1YXRpb25zW25hbWVdLmV2YWwpO1xuICAgICAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAgICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBmdW5jdGlvbiBidWlsZFNpZ21hKHNpZ25hbElkLCBpZHgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdFNlZW5bc2lnbmFsSWRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RQb3Nbc2lnbmFsSWRdID0gaWR4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQobGFzdFNlZW5bc2lnbmFsSWRdLCBpZHggKiBzRnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHY7XG4gICAgICAgICAgICBpZiAoaWR4IDwgc2V0dGluZ3MuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHYgPSB3O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZHggPCAyICogc2V0dGluZ3MuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHYgPSBGci5tdWwodywgazEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ID0gRnIubXVsKHcsIGsyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdFNlZW5bc2lnbmFsSWRdID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlTGFncmFuZ2VQb2x5bm9taWFscyhmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04pO1xuXG4gICAgICAgIGNvbnN0IGwgPSBNYXRoLm1heChzZXR0aW5ncy5uUHVibGljLCAxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBidWZmID0gbmV3IEJpZ0J1ZmZlcihzZXR0aW5ncy5kb21haW5TaXplICogc0ZyKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KEZyLm9uZSwgaSAqIHNGcik7XG5cbiAgICAgICAgICAgIGF3YWl0IHdyaXRlUDQoZmRaS2V5LCBidWZmKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVB0YXUoZmRaS2V5KSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgWktFWV9GRl9QVEFVX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIGRvbWFpblNpemUgKiA5ICsgMTggPSBtYXhpbXVtIFNSUyBsZW5ndGggbmVlZGVkLCBzcGVjaWZpY2FsbHkgdG8gY29tbWl0IEMyXG4gICAgICAgIFBUYXUgPSBuZXcgQmlnQnVmZmVyKChzZXR0aW5ncy5kb21haW5TaXplICogOSArIDE4KSAqIHNHMSk7XG4gICAgICAgIGF3YWl0IGZkUFRhdS5yZWFkVG9CdWZmZXIoUFRhdSwgMCwgKHNldHRpbmdzLmRvbWFpblNpemUgKiA5ICsgMTgpICogc0cxLCBwVGF1U2VjdGlvbnNbMl1bMF0ucCk7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKFBUYXUpO1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUMwKGZkWktleSkge1xuICAgICAgICAvLyBDMChYKSA6PSBRTChYXjgpICsgWCDCtyBRUihYXjgpICsgWF4yIMK3IFFPKFheOCkgKyBYXjMgwrcgUU0oWF44KSArIFheNCDCtyBRQyhYXjgpXG4gICAgICAgIC8vICAgICAgICAgICAgKyBYXjUgwrcgU0lHTUExKFheOCkgKyBYXjYgwrcgU0lHTUEyKFheOCkgKyBYXjcgwrcgU0lHTUEzKFheOClcbiAgICAgICAgbGV0IEMwID0gbmV3IENQb2x5bm9taWFsKDgsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDAsIHBvbHlub21pYWxzLlFMKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCgxLCBwb2x5bm9taWFscy5RUik7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoMiwgcG9seW5vbWlhbHMuUU8pO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDMsIHBvbHlub21pYWxzLlFNKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCg0LCBwb2x5bm9taWFscy5RQyk7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoNSwgcG9seW5vbWlhbHMuUzEpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDYsIHBvbHlub21pYWxzLlMyKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCg3LCBwb2x5bm9taWFscy5TMyk7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuQzAgPSBDMC5nZXRQb2x5bm9taWFsKCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgIGlmIChwb2x5bm9taWFscy5DMC5kZWdyZWUoKSA+PSA4ICogc2V0dGluZ3MuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQzAgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBaS0VZX0ZGX0MwX1NFQ1RJT04pO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUocG9seW5vbWlhbHMuQzAuY29lZik7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRkZsb25rSGVhZGVyKGZkWktleSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIFpLRVlfRkZfSEVBREVSX1NFQ1RJT04pO1xuXG4gICAgICAgIGNvbnN0IHByaW1lUSA9IGN1cnZlLnE7XG4gICAgICAgIGNvbnN0IG44cSA9IChNYXRoLmZsb29yKChTY2FsYXIuYml0TGVuZ3RoKHByaW1lUSkgLSAxKSAvIDY0KSArIDEpICogODtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhxKTtcbiAgICAgICAgYXdhaXQgd3JpdGVCaWdJbnQoZmRaS2V5LCBwcmltZVEsIG44cSk7XG5cbiAgICAgICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICAgICAgY29uc3QgbjhyID0gKE1hdGguZmxvb3IoKFNjYWxhci5iaXRMZW5ndGgocHJpbWVSKSAtIDEpIC8gNjQpICsgMSkgKiA4O1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHIpO1xuICAgICAgICBhd2FpdCB3cml0ZUJpZ0ludChmZFpLZXksIHByaW1lUiwgbjhyKTtcblxuICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcjFjcyB2YXJzXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHNldHRpbmdzLm5WYXJzKTtcbiAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIHIxY3MgcHVibGljIHZhcnMgPSBvdXRwdXRzICsgcHVibGljIGlucHV0c1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihzZXR0aW5ncy5uUHVibGljKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoc2V0dGluZ3MuZG9tYWluU2l6ZSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQWRkaXRpb25zLmxlbmd0aCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQ29uc3RyYWludHMubGVuZ3RoKTtcblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoazEpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoazIpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3Myk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3NCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3OCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZSh3cik7XG5cbiAgICAgICAgbGV0IGJYXzI7XG4gICAgICAgIGJYXzIgPSBhd2FpdCBmZFBUYXUucmVhZChzRzIsIHBUYXVTZWN0aW9uc1szXVswXS5wICsgc0cyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJYXzIpO1xuXG4gICAgICAgIGxldCBjb21taXRDMCA9IGF3YWl0IHBvbHlub21pYWxzLkMwLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJDMFwiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGNvbW1pdEMwKTtcblxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVA0KGZkWktleSwgYnVmZikge1xuICAgICAgICBjb25zdCBbY29lZmZpY2llbnRzLCBldmFsdWF0aW9uczRdID0gYXdhaXQgUG9seW5vbWlhbC50bzRUKGJ1ZmYsIHNldHRpbmdzLmRvbWFpblNpemUsIFtdLCBGcik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShjb2VmZmljaWVudHMpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoZXZhbHVhdGlvbnM0KTtcblxuICAgICAgICByZXR1cm4gW2NvZWZmaWNpZW50cywgZXZhbHVhdGlvbnM0XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlSzFLMigpIHtcbiAgICAgICAgbGV0IGsxID0gRnIudHdvO1xuICAgICAgICB3aGlsZSAoaXNJbmNsdWRlZChrMSwgW10sIHNldHRpbmdzLmNpclBvd2VyKSkgRnIuYWRkKGsxLCBGci5vbmUpO1xuICAgICAgICBsZXQgazIgPSBGci5hZGQoazEsIEZyLm9uZSk7XG4gICAgICAgIHdoaWxlIChpc0luY2x1ZGVkKGsyLCBbazFdLCBzZXR0aW5ncy5jaXJQb3dlcikpIEZyLmFkZChrMiwgRnIub25lKTtcbiAgICAgICAgcmV0dXJuIFtrMSwgazJdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzSW5jbHVkZWQoaywga0FyciwgcG93KSB7XG4gICAgICAgICAgICBjb25zdCBkb21haW5TaXplID0gMiAqKiBwb3c7XG4gICAgICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZyLmVxKGssIHcpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtBcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEZyLmVxKGssIEZyLm11bChrQXJyW2pdLCB3KSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbcG93XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlVzMoKSB7XG4gICAgICAgIGxldCBnZW5lcmF0b3IgPSBGci5lKDMxNjI0KTtcblxuICAgICAgICAvLyBFeHBvbmVudCBpcyBvcmRlcihyIC0gMSkgLyAzXG4gICAgICAgIGxldCBvcmRlclJzdWIxID0gMzY0ODA0MDQ3ODYzOTg3OTIwMzcwNzczNDI5MDg3NjIxMjUxNDc1ODA2MDczMzQwMjY3MjM5MDYxNjM2NzM2NDQyOTMwMTQxNTkzNm47XG4gICAgICAgIGxldCBleHBvbmVudCA9IFNjYWxhci5kaXYob3JkZXJSc3ViMSwgU2NhbGFyLmUoMykpO1xuXG4gICAgICAgIHJldHVybiBGci5leHAoZ2VuZXJhdG9yLCBleHBvbmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVc0KCkge1xuICAgICAgICByZXR1cm4gRnIud1syXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlVzgoKSB7XG4gICAgICAgIHJldHVybiBGci53WzNdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE9tZWdhQ3ViaWNSb290KHBvd2VyLCBGcikge1xuICAgICAgICAvLyBIYXJkY29yZGVkIDN0aC1yb290IG9mIEZyLndbMjhdXG4gICAgICAgIGNvbnN0IGZpcnN0Um9vdCA9IEZyLmUoNDY3Nzk5MTY1ODg2MDY5NjEwMDM2MDQ2ODY2Nzk5MjY0MDI2NDgxMzQ0Mjk5MDc5MDExNzYyMDI2Nzc0NTMzNzc0MzQ1OTg4MDgwbik7XG5cbiAgICAgICAgcmV0dXJuIEZyLmV4cChmaXJzdFJvb3QsIDIgKiogKDI4IC0gcG93ZXIpKTtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNvbnN0IHsgc3RyaW5naWZ5QmlnSW50cyB9ID0gdXRpbHM7XG5cblxuYXN5bmMgZnVuY3Rpb24gZmZsb25rUHJvdmUoemtleUZpbGVOYW1lLCB3aXRuZXNzRmlsZU5hbWUsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFBST1ZFUiBTVEFSVEVEXCIpO1xuXG4gICAgLy8gUmVhZCB3aXRuZXNzIGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyB3aXRuZXNzIGZpbGVcIik7XG4gICAgY29uc3Qge1xuICAgICAgICBmZDogZmRXdG5zLFxuICAgICAgICBzZWN0aW9uczogd3Ruc1NlY3Rpb25zXG4gICAgfSA9IGF3YWl0IHJlYWRCaW5GaWxlKHdpdG5lc3NGaWxlTmFtZSwgXCJ3dG5zXCIsIDIpO1xuICAgIGNvbnN0IHd0bnMgPSBhd2FpdCByZWFkSGVhZGVyKGZkV3Rucywgd3Ruc1NlY3Rpb25zKTtcblxuICAgIC8vUmVhZCB6a2V5IGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyB6a2V5IGZpbGVcIik7XG4gICAgY29uc3Qge1xuICAgICAgICBmZDogZmRaS2V5LFxuICAgICAgICBzZWN0aW9uczogemtleVNlY3Rpb25zXG4gICAgfSA9IGF3YWl0IHJlYWRCaW5GaWxlKHprZXlGaWxlTmFtZSwgXCJ6a2V5XCIsIDIpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHJlYWRIZWFkZXIkMShmZFpLZXksIHprZXlTZWN0aW9ucywgdW5kZWZpbmVkLCBvcHRpb25zKTtcblxuICAgIGlmICh6a2V5LnByb3RvY29sSWQgIT09IEZGTE9OS19QUk9UT0NPTF9JRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGZmbG9ua1wiKTtcbiAgICB9XG5cbiAgICBpZiAoIVNjYWxhci5lcSh6a2V5LnIsIHd0bnMucSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VydmUgb2YgdGhlIHdpdG5lc3MgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnZlIG9mIHRoZSBwcm92aW5nIGtleVwiKTtcbiAgICB9XG5cbiAgICBpZiAod3Rucy5uV2l0bmVzcyAhPT0gemtleS5uVmFycyAtIHprZXkubkFkZGl0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgd2l0bmVzcyBsZW5ndGguIENpcmN1aXQ6ICR7emtleS5uVmFyc30sIHdpdG5lc3M6ICR7d3Rucy5uV2l0bmVzc30sICR7emtleS5uQWRkaXRpb25zfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gemtleS5jdXJ2ZTtcblxuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBzRnIgPSBjdXJ2ZS5Gci5uODtcbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44ICogMjtcbiAgICBjb25zdCBzRG9tYWluID0gemtleS5kb21haW5TaXplICogc0ZyO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiICBGRkxPTksgUFJPVkUgU0VUVElOR1NcIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEN1cnZlOiAgICAgICAgICR7Y3VydmUubmFtZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ2lyY3VpdCBwb3dlcjogJHt6a2V5LnBvd2VyfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBEb21haW4gc2l6ZTogICAke3prZXkuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgVmFyczogICAgICAgICAgJHt6a2V5Lm5WYXJzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBQdWJsaWMgdmFyczogICAke3prZXkublB1YmxpY31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ29uc3RyYWludHM6ICAgJHt6a2V5Lm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQWRkaXRpb25zOiAgICAgJHt6a2V5Lm5BZGRpdGlvbnN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICB9XG5cbiAgICAvL1JlYWQgd2l0bmVzcyBkYXRhXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgd2l0bmVzcyBmaWxlIGRhdGFcIik7XG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCByZWFkU2VjdGlvbihmZFd0bnMsIHd0bnNTZWN0aW9ucywgMik7XG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG5cbiAgICAvLyBGaXJzdCBlbGVtZW50IGluIHBsb25rIGlzIG5vdCB1c2VkIGFuZCBjYW4gYmUgYW55IHZhbHVlLiAoQnV0IGFsd2F5cyB0aGUgc2FtZSkuXG4gICAgLy8gV2Ugc2V0IGl0IHRvIHplcm8gdG8gZ28gZmFzdGVyIGluIHRoZSBleHBvbmVudGlhdGlvbnMuXG4gICAgYnVmZldpdG5lc3Muc2V0KEZyLnplcm8sIDApO1xuICAgIGNvbnN0IGJ1ZmZJbnRlcm5hbFdpdG5lc3MgPSBuZXcgQmlnQnVmZmVyKHprZXkubkFkZGl0aW9ucyAqIHNGcik7XG5cbiAgICBsZXQgYnVmZmVycyA9IHt9O1xuICAgIGxldCBwb2x5bm9taWFscyA9IHt9O1xuICAgIGxldCBldmFsdWF0aW9ucyA9IHt9O1xuXG4gICAgLy8gVG8gZGl2aWRlIHByaW1lIGZpZWxkcyB0aGUgRXh0ZW5kZWQgRXVjbGlkZWFuIEFsZ29yaXRobSBmb3IgY29tcHV0aW5nIG1vZHVsYXIgaW52ZXJzZXMgaXMgbmVlZGVkLlxuICAgIC8vIE5PVEU6IFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgY29tcHV0ZSAxL2Rlbm9taW5hdG9yIGFuZCB0aGVuIG11bHRpcGx5IGl0IGJ5IHRoZSBudW1lcmF0b3IuXG4gICAgLy8gVGhlIEV4dGVuZGVkIEV1Y2xpZGVhbiBBbGdvcml0aG0gaXMgZXhwZW5zaXZlIGluIHRlcm1zIG9mIGNvbXB1dGF0aW9uLlxuICAgIC8vIEZvciB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gZG8gbWFueSBtb2R1bGFyIGludmVyc2VzLCB0aGVyZSdzIGEgc2ltcGxlIG1hdGhlbWF0aWNhbCB0cmlja1xuICAgIC8vIHRoYXQgYWxsb3dzIHVzIHRvIGNvbXB1dGUgbWFueSBpbnZlcnNlcywgY2FsbGVkIE1vbnRnb21lcnkgYmF0Y2ggaW52ZXJzaW9uLlxuICAgIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly92aXRhbGlrLmNhL2dlbmVyYWwvMjAxOC8wNy8yMS9zdGFya3NfcGFydF8zLmh0bWxcbiAgICAvLyBNb250Z29tZXJ5IGJhdGNoIGludmVyc2lvbiByZWR1Y2VzIHRoZSBuIGludmVyc2UgY29tcHV0YXRpb25zIHRvIGEgc2luZ2xlIG9uZVxuICAgIC8vIFRvIHNhdmUgdGhpcyAoc2luZ2xlKSBpbnZlcnNlIGNvbXB1dGF0aW9uIG9uLWNoYWluLCB3aWxsIGNvbXB1dGUgaXQgaW4gcHJvdmluZyB0aW1lIGFuZCBzZW5kIGl0IHRvIHRoZSB2ZXJpZmllci5cbiAgICAvLyBUaGUgdmVyaWZpZXIgd2lsbCBoYXZlIHRvIGNoZWNrOlxuICAgIC8vIDEpIHRoZSBkZW5vbWluYXRvciBpcyBjb3JyZWN0IG11bHRpcGx5aW5nIGJ5IGhpbXNlbGYgbm9uLWludmVydGVkIC0+IGEgKiAxL2EgPT0gMVxuICAgIC8vIDIpIGNvbXB1dGUgdGhlIHJlc3Qgb2YgdGhlIGRlbm9taW5hdG9ycyB1c2luZyB0aGUgTW9udGdvbWVyeSBiYXRjaCBpbnZlcnNpb25cbiAgICAvLyBUaGUgaW52ZXJzaW9ucyBhcmU6XG4gICAgLy8gICDCtyBkZW5vbWluYXRvciBuZWVkZWQgaW4gc3RlcCA4IGFuZCA5IG9mIHRoZSB2ZXJpZmllciB0byBtdWx0aXBseSBieSAxL1pfSCh4aSlcbiAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiBzdGVwIDEwIGFuZCAxMSBvZiB0aGUgdmVyaWZpZXJcbiAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiB0aGUgdmVyaWZpZXIgd2hlbiBjb21wdXRpbmcgTF9pXntTMX0oWCkgYW5kIExfaV57UzJ9KFgpXG4gICAgLy8gICDCtyBMX2kgaT0xIHRvIG51bSBwdWJsaWMgaW5wdXRzLCBuZWVkZWQgaW4gc3RlcCA2IGFuZCA3IG9mIHRoZSB2ZXJpZmllciB0byBjb21wdXRlIExfMSh4aSkgYW5kIFBJKHhpKVxuICAgIGxldCB0b0ludmVyc2UgPSB7fTtcblxuICAgIGxldCBjaGFsbGVuZ2VzID0ge307XG4gICAgbGV0IHJvb3RzID0ge307XG5cbiAgICBsZXQgcHJvb2YgPSBuZXcgUHJvb2YoY3VydmUsIGxvZ2dlcik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgPiBSZWFkaW5nIFNlY3Rpb24gJHtaS0VZX0ZGX0FERElUSU9OU19TRUNUSU9OfS4gQWRkaXRpb25zYCk7XG4gICAgYXdhaXQgY2FsY3VsYXRlQWRkaXRpb25zKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgPiBSZWFkaW5nIFNlY3Rpb25zICR7WktFWV9GRl9TSUdNQTFfU0VDVElPTn0sJHtaS0VZX0ZGX1NJR01BMl9TRUNUSU9OfSwke1pLRVlfRkZfU0lHTUEzX1NFQ1RJT059LiBTaWdtYTEsIFNpZ21hMiAmIFNpZ21hIDNgKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBSZWFkaW5nIFNpZ21hIHBvbHlub21pYWxzIFwiKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTEgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTIgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTMgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWExLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1NJR01BMV9TRUNUSU9OXVswXS5wKTtcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlNpZ21hMi5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTJfU0VDVElPTl1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5TaWdtYTMuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfU0lHTUEzX1NFQ1RJT05dWzBdLnApO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgUmVhZGluZyBTaWdtYSBldmFsdWF0aW9uc1wiKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTEgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgIGV2YWx1YXRpb25zLlNpZ21hMiA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgZXZhbHVhdGlvbnMuU2lnbWEzID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWExLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTFfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEyLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTJfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWEzLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTNfU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYD4gUmVhZGluZyBTZWN0aW9uICR7WktFWV9GRl9QVEFVX1NFQ1RJT059LiBQb3dlcnMgb2YgVGF1YCk7XG4gICAgY29uc3QgUFRhdSA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogMTYgKiBzRzEpO1xuICAgIC8vIGRvbWFpblNpemUgKiA5ICsgMTggPSBTUlMgbGVuZ3RoIGluIHRoZSB6a2V5IHNhdmVkIGluIHNldHVwIHByb2Nlc3MuXG4gICAgLy8gaXQgY29ycmVzcG9uZHMgdG8gdGhlIG1heGltdW0gU1JTIGxlbmd0aCBuZWVkZWQsIHNwZWNpZmljYWxseSB0byBjb21taXQgQzJcbiAgICAvLyBub3RpY2UgdGhhdCB0aGUgcmVzZXJ2ZWQgYnVmZmVycyBzaXplIGlzIHprZXkuZG9tYWluU2l6ZSAqIDE2ICogc0cxIGJlY2F1c2UgYSBwb3dlciBvZiB0d28gYnVmZmVyIHNpemUgaXMgbmVlZGVkXG4gICAgLy8gdGhlIHJlbWFpbmluZyBidWZmZXIgbm90IGZpbGxlZCBmcm9tIFNSUyBhcmUgc2V0IHRvIDBcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKFBUYXUsIDAsICh6a2V5LmRvbWFpblNpemUgKiA5ICsgMTgpICogc0cxLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9QVEFVX1NFQ1RJT05dWzBdLnApO1xuXG4gICAgLy8gU1RBUlQgRkZMT05LIFBST1ZFUiBQUk9UT0NPTFxuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCAxLiBDb21wdXRlIEMxKFgpIHBvbHlub21pYWxcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlwiKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgMVwiKTtcbiAgICBhd2FpdCByb3VuZDEoKTtcblxuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMDtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuUUw7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlFSO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5RTTtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuUU87XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlFDO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCAyLiBDb21wdXRlIEMyKFgpIHBvbHlub21pYWxcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgMlwiKTtcbiAgICBhd2FpdCByb3VuZDIoKTtcblxuICAgIGRlbGV0ZSBidWZmZXJzLkE7XG4gICAgZGVsZXRlIGJ1ZmZlcnMuQjtcbiAgICBkZWxldGUgYnVmZmVycy5DO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5BO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5CO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5DO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5TaWdtYTE7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlNpZ21hMjtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuU2lnbWEzO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5sYWdyYW5nZTE7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlo7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIC8vIFJPVU5EIDMuIENvbXB1dGUgb3BlbmluZyBldmFsdWF0aW9uc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBST1VORCAzXCIpO1xuICAgIGF3YWl0IHJvdW5kMygpO1xuXG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkE7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkM7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlo7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlQxO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuU2lnbWExO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5TaWdtYTI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlNpZ21hMztcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUUw7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlFSO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5RTTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUUM7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlFPO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCA0LiBDb21wdXRlIFcoWCkgcG9seW5vbWlhbFxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBST1VORCA0XCIpO1xuICAgIGF3YWl0IHJvdW5kNCgpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBST1VORCA1LiBDb21wdXRlIFcnKFgpIHBvbHlub21pYWxcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUk9VTkQgNVwiKTtcbiAgICBhd2FpdCByb3VuZDUoKTtcblxuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5DMDtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuQzE7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkMyO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5SMTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUjI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkY7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkw7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlpUO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5aVFMyO1xuICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiaW52XCIsIGdldE1vbnRnb21lcnlCYXRjaGVkSW52ZXJzZSgpKTtcblxuICAgIC8vIFByZXBhcmUgcHJvb2ZcbiAgICBsZXQgX3Byb29mID0gcHJvb2YudG9PYmplY3RQcm9vZigpO1xuICAgIF9wcm9vZi5wcm90b2NvbCA9IFwiZmZsb25rXCI7XG4gICAgX3Byb29mLmN1cnZlID0gY3VydmUubmFtZTtcblxuICAgIC8vIFByZXBhcmUgcHVibGljIGlucHV0c1xuICAgIGxldCBwdWJsaWNTaWduYWxzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBzRnI7XG5cbiAgICAgICAgY29uc3QgcHViID0gYnVmZldpdG5lc3Muc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgcHVibGljU2lnbmFscy5wdXNoKFNjYWxhci5mcm9tUnByTEUocHViKSk7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgUFJPVkVSIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvb2Y6IHN0cmluZ2lmeUJpZ0ludHMoX3Byb29mKSxcbiAgICAgICAgcHVibGljU2lnbmFsczogc3RyaW5naWZ5QmlnSW50cyhwdWJsaWNTaWduYWxzKVxuICAgIH07XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVBZGRpdGlvbnMoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBhZGRpdGlvbnNcIik7XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uc0J1ZmYgPSBhd2FpdCByZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9GRl9BRERJVElPTlNfU0VDVElPTik7XG5cbiAgICAgICAgLy8gc2l6ZXM6IHdpcmVJZF94ID0gNCBieXRlcyAoMzIgYml0cyksIGZhY3Rvcl94ID0gZmllbGQgc2l6ZSBiaXRzXG4gICAgICAgIC8vIEFkZGl0aW9uIGZvcm06IHdpcmVJZF9hIHdpcmVJZF9iIGZhY3Rvcl9hIGZhY3Rvcl9iIChzaXplIGlzIDQgKyA0ICsgc0ZyICsgc0ZyKVxuICAgICAgICBjb25zdCBzU3VtID0gOCArIHNGciAqIDI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5BZGRpdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgIGFkZGl0aW9uICR7aX0vJHt6a2V5Lm5BZGRpdGlvbnN9YCk7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgYWRkaXRpb24gdmFsdWVzXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gaSAqIHNTdW07XG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZDEgPSByZWFkVUludDMyKGFkZGl0aW9uc0J1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkMiA9IHJlYWRVSW50MzIoYWRkaXRpb25zQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yMSA9IGFkZGl0aW9uc0J1ZmYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzRnIpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHNGcjtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcjIgPSBhZGRpdGlvbnNCdWZmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc0ZyKTtcblxuICAgICAgICAgICAgLy8gR2V0IHdpdG5lc3MgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHdpdG5lc3MxID0gZ2V0V2l0bmVzcyhzaWduYWxJZDEpO1xuICAgICAgICAgICAgY29uc3Qgd2l0bmVzczIgPSBnZXRXaXRuZXNzKHNpZ25hbElkMik7XG5cbiAgICAgICAgICAgIC8vQ2FsY3VsYXRlIGZpbmFsIHJlc3VsdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gRnIuYWRkKEZyLm11bChmYWN0b3IxLCB3aXRuZXNzMSksIEZyLm11bChmYWN0b3IyLCB3aXRuZXNzMikpO1xuXG4gICAgICAgICAgICBidWZmSW50ZXJuYWxXaXRuZXNzLnNldChyZXN1bHQsIHNGciAqIGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFVJbnQzMihiLCBvKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBiLnNsaWNlKG8sIG8gKyA0KTtcbiAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIsIGJ1ZmYuYnl0ZU9mZnNldCwgYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZWLmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaXRuZXNzKGlkeCkge1xuICAgICAgICBsZXQgZGlmZiA9IHprZXkublZhcnMgLSB6a2V5Lm5BZGRpdGlvbnM7XG4gICAgICAgIGlmIChpZHggPCBkaWZmKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZldpdG5lc3Muc2xpY2UoaWR4ICogc0ZyLCBpZHggKiBzRnIgKyBzRnIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlkeCA8IHprZXkublZhcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IChpZHggLSBkaWZmKSAqIHNGcjtcbiAgICAgICAgICAgIHJldHVybiBidWZmSW50ZXJuYWxXaXRuZXNzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc0ZyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBGci56ZXJvO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMSgpIHtcbiAgICAgICAgLy8gU1RFUCAxLjEgLSBHZW5lcmF0ZSByYW5kb20gYmxpbmRpbmcgc2NhbGFycyAoYl8xLCAuLi4sIGI5KSDiiIggRlxuICAgICAgICBjaGFsbGVuZ2VzLmIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gOTsgaSsrKSB7XG4gICAgICAgICAgICBjaGFsbGVuZ2VzLmJbaV0gPSBGci5yYW5kb20oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNURVAgMS4yIC0gQ29tcHV0ZSB3aXJlIHBvbHlub21pYWxzIGEoWCksIGIoWCkgYW5kIGMoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBBLCBCLCBDIHdpcmUgcG9seW5vbWlhbHNcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVXaXJlUG9seW5vbWlhbHMoKTtcblxuICAgICAgICAvLyBTVEVQIDEuMyAtIENvbXB1dGUgdGhlIHF1b3RpZW50IHBvbHlub21pYWwgVDAoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBUMCBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlVDAoKTtcblxuICAgICAgICAvLyBTVEVQIDEuNCAtIENvbXB1dGUgdGhlIEZGVC1zdHlsZSBjb21iaW5hdGlvbiBwb2x5bm9taWFsIEMxKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgQzEgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZUMxKCk7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbQzFdXzEpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgQzEgbXVsdGkgZXhwb25lbnRpYXRpb25cIik7XG4gICAgICAgIGxldCBjb21taXRDMSA9IGF3YWl0IHBvbHlub21pYWxzLkMxLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJDMVwiKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIkMxXCIsIGNvbW1pdEMxKTtcblxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlV2lyZVBvbHlub21pYWxzKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgUmVhZGluZyBkYXRhIGZyb20gemtleSBmaWxlXCIpO1xuICAgICAgICAgICAgLy8gQnVpbGQgQSwgQiBhbmQgQyBldmFsdWF0aW9ucyBidWZmZXIgZnJvbSB6a2V5IGFuZCB3aXRuZXNzIGZpbGVzXG4gICAgICAgICAgICBidWZmZXJzLkEgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuICAgICAgICAgICAgYnVmZmVycy5CID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQyA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgemtleSBzZWN0aW9ucyBhbmQgZmlsbCB0aGUgYnVmZmVyc1xuICAgICAgICAgICAgY29uc3QgYU1hcEJ1ZmYgPSBhd2FpdCByZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9GRl9BX01BUF9TRUNUSU9OKTtcbiAgICAgICAgICAgIGNvbnN0IGJNYXBCdWZmID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfRkZfQl9NQVBfU0VDVElPTik7XG4gICAgICAgICAgICBjb25zdCBjTWFwQnVmZiA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX0ZGX0NfTUFQX1NFQ1RJT04pO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIGFsbCB3aXRuZXNzIGZyb20gc2lnbmFsIGlkcyBhbmQgc2V0IHRoZW0gdG8gQSxCICYgQyBidWZmZXJzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkubkNvbnN0cmFpbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBzRnI7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDQ7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIEEgdmFsdWUgZnJvbSBhIHNpZ25hbCBpZFxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkQSA9IHJlYWRVSW50MzIoYU1hcEJ1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5BLnNldChnZXRXaXRuZXNzKHNpZ25hbElkQSksIGlfc0ZyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgQiB2YWx1ZSBmcm9tIGEgc2lnbmFsIGlkXG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWRCID0gcmVhZFVJbnQzMihiTWFwQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBidWZmZXJzLkIuc2V0KGdldFdpdG5lc3Moc2lnbmFsSWRCKSwgaV9zRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBDIHZhbHVlIGZyb20gYSBzaWduYWwgaWRcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduYWxJZEMgPSByZWFkVUludDMyKGNNYXBCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuQy5zZXQoZ2V0V2l0bmVzcyhzaWduYWxJZEMpLCBpX3NGcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJsaW5kIGEoWCksIGIoWCkgYW5kIGMoWCkgcG9seW5vbWlhbHMgY29lZmZpY2llbnRzIHdpdGggYmxpbmRpbmcgc2NhbGFycyBiXG4gICAgICAgICAgICBidWZmZXJzLkEuc2V0KGNoYWxsZW5nZXMuYlsxXSwgc0RvbWFpbiAtIDY0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQS5zZXQoY2hhbGxlbmdlcy5iWzJdLCBzRG9tYWluIC0gMzIpO1xuICAgICAgICAgICAgYnVmZmVycy5CLnNldChjaGFsbGVuZ2VzLmJbM10sIHNEb21haW4gLSA2NCk7XG4gICAgICAgICAgICBidWZmZXJzLkIuc2V0KGNoYWxsZW5nZXMuYls0XSwgc0RvbWFpbiAtIDMyKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQy5zZXQoY2hhbGxlbmdlcy5iWzVdLCBzRG9tYWluIC0gNjQpO1xuICAgICAgICAgICAgYnVmZmVycy5DLnNldChjaGFsbGVuZ2VzLmJbNl0sIHNEb21haW4gLSAzMik7XG5cbiAgICAgICAgICAgIGJ1ZmZlcnMuQSA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQSk7XG4gICAgICAgICAgICBidWZmZXJzLkIgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkIpO1xuICAgICAgICAgICAgYnVmZmVycy5DID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZmVycy5DKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSB3aXJlIHBvbHlub21pYWxzIGEoWCksIGIoWCkgYW5kIGMoWCkgZnJvbSBBLEIgJiBDIGJ1ZmZlcnNcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBBIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5BID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5BLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBCIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5CID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5CLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBDIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5DID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5DLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBleHRlbmRlZCBldmFsdWF0aW9ucyBvZiBhKFgpLCBiKFgpIGFuZCBjKFgpIHBvbHlub21pYWxzXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQSBmZnRcIik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5BID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQSwgNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQiBmZnRcIik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5CID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQiwgNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQyBmZnRcIik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5DID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQywgNCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZXNcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5BLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkIuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuQy5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVUMCgpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgUmVhZGluZyBzZWN0aW9ucyAke1pLRVlfRkZfUUxfU0VDVElPTn0sICR7WktFWV9GRl9RUl9TRUNUSU9OfWAgK1xuICAgICAgICAgICAgICAgIGAsICR7WktFWV9GRl9RTV9TRUNUSU9OfSwgJHtaS0VZX0ZGX1FPX1NFQ1RJT059LCAke1pLRVlfRkZfUUNfU0VDVElPTn0uIFEgc2VsZWN0b3JzYCk7XG4gICAgICAgICAgICAvLyBSZXNlcnZlIG1lbW9yeSBmb3IgUSdzIGV2YWx1YXRpb25zXG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RTCA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RUiA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RTSA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RTyA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RQyA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgUSdzIGV2YWx1YXRpb25zIGZyb20gemtleSBmaWxlXG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFMLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RTF9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFSLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RUl9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFNLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RTV9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFPLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RT19TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFDLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RQ19TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgTGFncmFuZ2UgcG9seW5vbWlhbHMgJiBldmFsdWF0aW9ucyBmcm9tIHprZXkgZmlsZVxuICAgICAgICAgICAgY29uc3QgbGFncmFuZ2VQb2x5bm9taWFscyA9IGF3YWl0IHJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX0ZGX0xBR1JBTkdFX1NFQ1RJT04pO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMubGFncmFuZ2UxID0gbmV3IEV2YWx1YXRpb25zKGxhZ3JhbmdlUG9seW5vbWlhbHMsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBSZXNlcnZlIG1lbW9yeSBmb3IgYnVmZmVycyBUMFxuICAgICAgICAgICAgYnVmZmVycy5UMCA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDAgZXZhbHVhdGlvbnNcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZSAqIDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICAgIFQwIGV2YWx1YXRpb24gJHtpfS8ke3prZXkuZG9tYWluU2l6ZSAqIDR9YCk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgcmVsYXRlZCBldmFsdWF0aW9ucyB0byBjb21wdXRlIGN1cnJlbnQgVDAgZXZhbHVhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBldmFsdWF0aW9ucy5BLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGV2YWx1YXRpb25zLkIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gZXZhbHVhdGlvbnMuQy5nZXRFdmFsdWF0aW9uKGkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcWwgPSBldmFsdWF0aW9ucy5RTC5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFyID0gZXZhbHVhdGlvbnMuUVIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxbSA9IGV2YWx1YXRpb25zLlFNLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcW8gPSBldmFsdWF0aW9ucy5RTy5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFjID0gZXZhbHVhdGlvbnMuUUMuZ2V0RXZhbHVhdGlvbihpKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgY3VycmVudCBwdWJsaWMgaW5wdXRcbiAgICAgICAgICAgICAgICBsZXQgcGkgPSBGci56ZXJvO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgemtleS5uUHVibGljOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKGogKiA1ICogemtleS5kb21haW5TaXplKSArIHprZXkuZG9tYWluU2l6ZSArIGk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbFBvbCA9IGV2YWx1YXRpb25zLmxhZ3JhbmdlMS5nZXRFdmFsdWF0aW9uKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFWYWwgPSBidWZmZXJzLkEuc2xpY2UoaiAqIHNGciwgKGogKyAxKSAqIHNGcik7XG5cbiAgICAgICAgICAgICAgICAgICAgcGkgPSBGci5zdWIocGksIEZyLm11bChsUG9sLCBhVmFsKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9UMChYKSA9IFtxX0woWCnCt2EoWCkgKyBxX1IoWCnCt2IoWCkgKyBxX00oWCnCt2EoWCnCt2IoWCkgKyBxX08oWCnCt2MoWCkgKyBxX0MoWCkgKyBQSShYKV0gwrcgMS9aX0goWClcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGZpcnN0IFQwKFgpwrdaX0goWCksIHNvIGRpdmlkZSBsYXRlciB0aGUgcmVzdWx0aW5nIHBvbHlub21pYWwgYnkgWl9IKFgpXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiAxIC0+IHFfTChYKcK3YShYKVxuICAgICAgICAgICAgICAgIGNvbnN0IGUxID0gRnIubXVsKGEsIHFsKTtcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gMiAtPiBxX1IoWCnCt2IoWClcbiAgICAgICAgICAgICAgICBjb25zdCBlMiA9IEZyLm11bChiLCBxcik7XG5cbiAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIDMgLT4gcV9NKFgpwrdhKFgpwrdiKFgpXG4gICAgICAgICAgICAgICAgY29uc3QgZTMgPSBGci5tdWwoRnIubXVsKGEsIGIpLCBxbSk7XG5cbiAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIDQgLT4gcV9PKFgpwrdjKFgpXG4gICAgICAgICAgICAgICAgY29uc3QgZTQgPSBGci5tdWwoYywgcW8pO1xuXG4gICAgICAgICAgICAgICAgLy8gdDAgPSBleHByZXNzaW9ucyAxICsgZXhwcmVzc2lvbiAyICsgZXhwcmVzc2lvbiAzICsgZXhwcmVzc2lvbiA0ICsgcWMgKyBwaVxuICAgICAgICAgICAgICAgIGNvbnN0IHQwID0gRnIuYWRkKGUxLCBGci5hZGQoZTIsIEZyLmFkZChlMywgRnIuYWRkKGU0LCBGci5hZGQocWMsIHBpKSkpKSk7XG5cbiAgICAgICAgICAgICAgICBidWZmZXJzLlQwLnNldCh0MCwgaSAqIHNGcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiYnVmZmVyIFQwOiBcIiArIGJ1ZmZlcnMuVDAuYnl0ZUxlbmd0aCAvIHNGcik7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcG9seW5vbWlhbCBUMChYKSBmcm9tIGJ1ZmZlcnMuVDBcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMCBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDAgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlQwLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJUMCBsZW5ndGg6IFwiICsgcG9seW5vbWlhbHMuVDAubGVuZ3RoKCkpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJUMCBkZWdyZWU6IFwiICsgcG9seW5vbWlhbHMuVDAuZGVncmVlKCkpO1xuXG4gICAgICAgICAgICAvLyBEaXZpZGUgdGhlIHBvbHlub21pYWwgVDAgYnkgWl9IKFgpXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDAgLyBaSFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQwLmRpdkJ5WmVyb2ZpZXIoemtleS5kb21haW5TaXplLCBGci5vbmUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5UMC5kZWdyZWUoKSA+PSAyICogemtleS5kb21haW5TaXplIC0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVDAgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkIChkZWdyZWUgaXMgJHtwb2x5bm9taWFscy5UMC5kZWdyZWUoKX0gYW5kIG11c3QgYmUgbGVzcyB0aGFuICR7MiAqIHprZXkuZG9tYWluU2l6ZSArIDJ9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlQwO1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUMxKCkge1xuICAgICAgICAgICAgbGV0IEMxID0gbmV3IENQb2x5bm9taWFsKDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgQzEuYWRkUG9seW5vbWlhbCgwLCBwb2x5bm9taWFscy5BKTtcbiAgICAgICAgICAgIEMxLmFkZFBvbHlub21pYWwoMSwgcG9seW5vbWlhbHMuQik7XG4gICAgICAgICAgICBDMS5hZGRQb2x5bm9taWFsKDIsIHBvbHlub21pYWxzLkMpO1xuICAgICAgICAgICAgQzEuYWRkUG9seW5vbWlhbCgzLCBwb2x5bm9taWFscy5UMCk7XG5cbiAgICAgICAgICAgIHBvbHlub21pYWxzLkMxID0gQzEuZ2V0UG9seW5vbWlhbCgpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5DMS5kZWdyZWUoKSA+PSA4ICogemtleS5kb21haW5TaXplIC0gOCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkMxIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMigpIHtcbiAgICAgICAgLy8gU1RFUCAyLjEgLSBDb21wdXRlIHBlcm11dGF0aW9uIGNoYWxsZW5nZSBiZXRhIGFuZCBnYW1tYSDiiIggRlxuICAgICAgICAvLyBDb21wdXRlIHBlcm11dGF0aW9uIGNoYWxsZW5nZSBiZXRhXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlcyBiZXRhIGFuZCBnYW1tYVwiKTtcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcblxuICAgICAgICAvLyBBZGQgQzAgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuQzApO1xuXG4gICAgICAgIC8vIEFkZCBBIHRvIHRoZSB0cmFuc2NyaXB0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGJ1ZmZlcnMuQS5zbGljZShpICogc0ZyLCBpICogc0ZyICsgc0ZyKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgQzEgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJDMVwiKSk7XG5cbiAgICAgICAgY2hhbGxlbmdlcy5iZXRhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5iZXRhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYmV0YSkpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgcGVybXV0YXRpb24gY2hhbGxlbmdlIGdhbW1hXG4gICAgICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5iZXRhKTtcbiAgICAgICAgY2hhbGxlbmdlcy5nYW1tYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuZ2FtbWE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5nYW1tYSkpO1xuXG4gICAgICAgIC8vIFNURVAgMi4yIC0gQ29tcHV0ZSBwZXJtdXRhdGlvbiBwb2x5bm9taWFsIHooWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBaIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVaKCk7XG5cbiAgICAgICAgLy8gU1RFUCAyLjMgLSBDb21wdXRlIHF1b3RpZW50IHBvbHlub21pYWwgVDEoWCkgYW5kIFQyKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVDEgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVQxKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgVDIgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVQyKCk7XG5cbiAgICAgICAgLy8gU1RFUCAyLjQgLSBDb21wdXRlIHRoZSBGRlQtc3R5bGUgY29tYmluYXRpb24gcG9seW5vbWlhbCBDMihYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEMyIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVDMigpO1xuXG4gICAgICAgIC8vIFRoZSBzZWNvbmQgb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtDMl1fMSlcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBDMiBtdWx0aSBleHBvbmVudGlhdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbW1pdEMyID0gYXdhaXQgcG9seW5vbWlhbHMuQzIubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIkMyXCIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiQzJcIiwgY29tbWl0QzIpO1xuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVaKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFogZXZhbHVhdGlvbnNcIik7XG5cbiAgICAgICAgICAgIGxldCBudW1BcnIgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuICAgICAgICAgICAgbGV0IGRlbkFyciA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgZmlyc3QgdmFsdWVzIHRvIDFcbiAgICAgICAgICAgIG51bUFyci5zZXQoRnIub25lLCAwKTtcbiAgICAgICAgICAgIGRlbkFyci5zZXQoRnIub25lLCAwKTtcblxuICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgb21lZ2FcbiAgICAgICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICBaIGV2YWx1YXRpb24gJHtpfS8ke3prZXkuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBzRnI7XG5cbiAgICAgICAgICAgICAgICAvLyBaKFgpIDo9IG51bUFyciAvIGRlbkFyclxuICAgICAgICAgICAgICAgIC8vIG51bUFyciA6PSAoYSArIGJldGHCt8+JICsgZ2FtbWEpKGIgKyBiZXRhwrfPicK3azEgKyBnYW1tYSkoYyArIGJldGHCt8+JwrdrMiArIGdhbW1hKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJldGF3ID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgdyk7XG5cbiAgICAgICAgICAgICAgICBsZXQgbnVtMSA9IGJ1ZmZlcnMuQS5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIG51bTEgPSBGci5hZGQobnVtMSwgYmV0YXcpO1xuICAgICAgICAgICAgICAgIG51bTEgPSBGci5hZGQobnVtMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgbnVtMiA9IGJ1ZmZlcnMuQi5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIG51bTIgPSBGci5hZGQobnVtMiwgRnIubXVsKHprZXkuazEsIGJldGF3KSk7XG4gICAgICAgICAgICAgICAgbnVtMiA9IEZyLmFkZChudW0yLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBudW0zID0gYnVmZmVycy5DLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgbnVtMyA9IEZyLmFkZChudW0zLCBGci5tdWwoemtleS5rMiwgYmV0YXcpKTtcbiAgICAgICAgICAgICAgICBudW0zID0gRnIuYWRkKG51bTMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG51bSA9IEZyLm11bChudW0xLCBGci5tdWwobnVtMiwgbnVtMykpO1xuXG4gICAgICAgICAgICAgICAgLy8gZGVuQXJyIDo9IChhICsgYmV0YcK3c2lnbWExICsgZ2FtbWEpKGIgKyBiZXRhwrdzaWdtYTIgKyBnYW1tYSkoYyArIGJldGHCt3NpZ21hMyArIGdhbW1hKVxuICAgICAgICAgICAgICAgIGxldCBkZW4xID0gYnVmZmVycy5BLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgZGVuMSA9IEZyLmFkZChkZW4xLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBldmFsdWF0aW9ucy5TaWdtYTEuZ2V0RXZhbHVhdGlvbihpICogNCkpKTtcbiAgICAgICAgICAgICAgICBkZW4xID0gRnIuYWRkKGRlbjEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGRlbjIgPSBidWZmZXJzLkIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBkZW4yID0gRnIuYWRkKGRlbjIsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGV2YWx1YXRpb25zLlNpZ21hMi5nZXRFdmFsdWF0aW9uKGkgKiA0KSkpO1xuICAgICAgICAgICAgICAgIGRlbjIgPSBGci5hZGQoZGVuMiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZGVuMyA9IGJ1ZmZlcnMuQy5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIGRlbjMgPSBGci5hZGQoZGVuMywgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgZXZhbHVhdGlvbnMuU2lnbWEzLmdldEV2YWx1YXRpb24oaSAqIDQpKSk7XG4gICAgICAgICAgICAgICAgZGVuMyA9IEZyLmFkZChkZW4zLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBkZW4gPSBGci5tdWwoZGVuMSwgRnIubXVsKGRlbjIsIGRlbjMpKTtcblxuICAgICAgICAgICAgICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgbnVtIHZhbHVlIHdpdGggdGhlIHByZXZpb3VzIG9uZSBzYXZlZCBpbiBudW1BcnJcbiAgICAgICAgICAgICAgICBudW0gPSBGci5tdWwobnVtQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGciksIG51bSk7XG4gICAgICAgICAgICAgICAgbnVtQXJyLnNldChudW0sICgoaSArIDEpICUgemtleS5kb21haW5TaXplKSAqIHNGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBNdWx0aXBseSBjdXJyZW50IGRlbiB2YWx1ZSB3aXRoIHRoZSBwcmV2aW91cyBvbmUgc2F2ZWQgaW4gZGVuQXJyXG4gICAgICAgICAgICAgICAgZGVuID0gRnIubXVsKGRlbkFyci5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpLCBkZW4pO1xuICAgICAgICAgICAgICAgIGRlbkFyci5zZXQoZGVuLCAoKGkgKyAxKSAlIHprZXkuZG9tYWluU2l6ZSkgKiBzRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gTmV4dCBvbWVnYVxuICAgICAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1t6a2V5LnBvd2VyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBpbnZlcnNlIG9mIGRlbkFyciB0byBjb21wdXRlIGluIHRoZSBuZXh0IGNvbW1hbmQgdGhlXG4gICAgICAgICAgICAvLyBkaXZpc2lvbiBudW1BcnIvZGVuQXJyIGJ5IG11bHRpcGx5aW5nIG51bSDCtyAxL2RlbkFyclxuICAgICAgICAgICAgZGVuQXJyID0gYXdhaXQgRnIuYmF0Y2hJbnZlcnNlKGRlbkFycik7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IERvIGl0IGluIGFzc2VtYmx5IGFuZCBpbiBwYXJhbGxlbFxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgbnVtQXJyIMK3IGRlbkFyciB3aGVyZSBkZW5BcnIgd2FzIGludmVydGVkIGluIHRoZSBwcmV2aW91cyBjb21tYW5kXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpICogc0ZyO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IEZyLm11bChudW1BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKSwgZGVuQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcikpO1xuICAgICAgICAgICAgICAgIG51bUFyci5zZXQoeiwgaV9zRnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRnJvbSBub3cgb24gdGhlIHZhbHVlcyBzYXZlZCBvbiBudW1BcnIgd2lsbCBiZSBaKFgpIGJ1ZmZlclxuICAgICAgICAgICAgYnVmZmVycy5aID0gbnVtQXJyO1xuXG4gICAgICAgICAgICBpZiAoIUZyLmVxKG51bUFyci5zbGljZSgwLCBzRnIpLCBGci5vbmUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29weSBjb25zdHJhaW50cyBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cyB6KFgpIGZyb20gYnVmZmVycy5aXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgWiBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuWiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuWiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgZXh0ZW5kZWQgZXZhbHVhdGlvbnMgb2YgeihYKSBwb2x5bm9taWFsXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgWiBmZnRcIik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5aID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuWiwgNCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIEJsaW5kIHooWCkgcG9seW5vbWlhbCBjb2VmZmljaWVudHMgd2l0aCBibGluZGluZyBzY2FsYXJzIGJcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlouYmxpbmRDb2VmZmljaWVudHMoW2NoYWxsZW5nZXMuYls5XSwgY2hhbGxlbmdlcy5iWzhdLCBjaGFsbGVuZ2VzLmJbN11dKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuWi5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUgKyAzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlo7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlVDEoKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDEgZXZhbHVhdGlvbnNcIik7XG5cbiAgICAgICAgICAgIGJ1ZmZlcnMuVDEgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4gKiAyKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuVDF6ID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogMik7XG5cbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIG9tZWdhXG4gICAgICAgICAgICBsZXQgb21lZ2EgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZSAqIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIgJiYgKDAgIT09IGkpICYmIChpICUgMTAwMDAwID09PSAwKSkgbG9nZ2VyLmluZm8oYCAgICBUMSBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemUgKiA0fWApO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb21lZ2EyID0gRnIuc3F1YXJlKG9tZWdhKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oaSAqIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpwID0gRnIuYWRkKEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iWzddLCBvbWVnYTIpLCBGci5tdWwoY2hhbGxlbmdlcy5iWzhdLCBvbWVnYSkpLCBjaGFsbGVuZ2VzLmJbOV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gVDEoWCkgOj0gKHooWCkgLSAxKSDCtyBMXzEoWClcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGZpcnN0IFQxKFgpwrdaX0goWCksIHNvIGRpdmlkZSBsYXRlciB0aGUgcmVzdWx0aW5nIHBvbHlub21pYWwgYnkgWl9IKFgpXG4gICAgICAgICAgICAgICAgY29uc3QgbGFncmFuZ2UxID0gZXZhbHVhdGlvbnMubGFncmFuZ2UxLmdldEV2YWx1YXRpb24oemtleS5kb21haW5TaXplICsgaSAqIDIpO1xuICAgICAgICAgICAgICAgIGxldCB0MSA9IEZyLm11bChGci5zdWIoeiwgRnIub25lKSwgbGFncmFuZ2UxKTtcbiAgICAgICAgICAgICAgICBsZXQgdDF6ID0gRnIubXVsKHpwLCBsYWdyYW5nZTEpO1xuXG4gICAgICAgICAgICAgICAgYnVmZmVycy5UMS5zZXQodDEsIGkgKiBzRnIpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuVDF6LnNldCh0MXosIGkgKiBzRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IG9tZWdhXG4gICAgICAgICAgICAgICAgb21lZ2EgPSBGci5tdWwob21lZ2EsIEZyLndbemtleS5wb3dlciArIDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQxKFgpIGZyb20gYnVmZmVycy5UMVxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQxIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMSA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDEsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBEaXZpZGUgdGhlIHBvbHlub21pYWwgVDEgYnkgWl9IKFgpXG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMS5kaXZCeVplcm9maWVyKHprZXkuZG9tYWluU2l6ZSwgRnIub25lKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQxeihYKSBmcm9tIGJ1ZmZlcnMuVDF6XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDF6IGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMXogPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlQxeiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcG9seW5vbWlhbCBUMXogdG8gVDEgdG8gZ2V0IHRoZSBmaW5hbCBwb2x5bm9taWFsIFQxXG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMS5hZGQocG9seW5vbWlhbHMuVDF6KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuVDEuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlQxIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuVDE7XG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5UMXo7XG4gICAgICAgICAgICBkZWxldGUgcG9seW5vbWlhbHMuVDF6O1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVQyKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQyIGV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgICAgICBidWZmZXJzLlQyID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG4gICAgICAgICAgICBidWZmZXJzLlQyeiA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpO1xuXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCBvbWVnYVxuICAgICAgICAgICAgbGV0IG9tZWdhID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemUgKiA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyICYmICgwICE9PSBpKSAmJiAoaSAlIDEwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgVDIgZXZhbHVhdGlvbiAke2l9LyR7emtleS5kb21haW5TaXplICogNH1gKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9tZWdhMiA9IEZyLnNxdWFyZShvbWVnYSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb21lZ2FXID0gRnIubXVsKG9tZWdhLCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbWVnYVcyID0gRnIuc3F1YXJlKG9tZWdhVyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhID0gZXZhbHVhdGlvbnMuQS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBldmFsdWF0aW9ucy5CLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGV2YWx1YXRpb25zLkMuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB6ID0gZXZhbHVhdGlvbnMuWi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpXID0gZXZhbHVhdGlvbnMuWi5nZXRFdmFsdWF0aW9uKCh6a2V5LmRvbWFpblNpemUgKiA0ICsgNCArIGkpICUgKHprZXkuZG9tYWluU2l6ZSAqIDQpKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHpwID0gRnIuYWRkKEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iWzddLCBvbWVnYTIpLCBGci5tdWwoY2hhbGxlbmdlcy5iWzhdLCBvbWVnYSkpLCBjaGFsbGVuZ2VzLmJbOV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpXcCA9IEZyLmFkZChGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYls3XSwgb21lZ2FXMiksIEZyLm11bChjaGFsbGVuZ2VzLmJbOF0sIG9tZWdhVykpLCBjaGFsbGVuZ2VzLmJbOV0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gZXZhbHVhdGlvbnMuU2lnbWExLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbWEyID0gZXZhbHVhdGlvbnMuU2lnbWEyLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbWEzID0gZXZhbHVhdGlvbnMuU2lnbWEzLmdldEV2YWx1YXRpb24oaSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUMihYKSA6PSBbIChhKFgpICsgYmV0YcK3WCArIGdhbW1hKShiKFgpICsgYmV0YcK3azHCt1ggKyBnYW1tYSkoYyhYKSArIGJldGHCt2sywrdYICsgZ2FtbWEpeihYKVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAtKGEoWCkgKyBiZXRhwrdzaWdtYTEoWCkgKyBnYW1tYSkoYihYKSArIGJldGHCt3NpZ21hMihYKSArIGdhbW1hKShjKFgpICsgYmV0YcK3c2lnbWEzKFgpICsgZ2FtbWEpeihYz4kpXSDCtyAxL1pfSChYKVxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgZmlyc3QgVDIoWCnCt1pfSChYKSwgc28gZGl2aWRlIGxhdGVyIHRoZSByZXN1bHRpbmcgcG9seW5vbWlhbCBieSBaX0goWClcblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gMSAtPiAoYShYKSArIGJldGHCt1ggKyBnYW1tYSkoYihYKSArIGJldGHCt2sxwrdYICsgZ2FtbWEpKGMoWCkgKyBiZXRhwrdrMsK3WCArIGdhbW1hKXooWClcbiAgICAgICAgICAgICAgICBjb25zdCBiZXRhWCA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIG9tZWdhKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMTEgPSBGci5hZGQoYSwgYmV0YVgpO1xuICAgICAgICAgICAgICAgIGUxMSA9IEZyLmFkZChlMTEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUxMiA9IEZyLmFkZChiLCBGci5tdWwoYmV0YVgsIHprZXkuazEpKTtcbiAgICAgICAgICAgICAgICBlMTIgPSBGci5hZGQoZTEyLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMTMgPSBGci5hZGQoYywgRnIubXVsKGJldGFYLCB6a2V5LmsyKSk7XG4gICAgICAgICAgICAgICAgZTEzID0gRnIuYWRkKGUxMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTEgPSBGci5tdWwoRnIubXVsKEZyLm11bChlMTEsIGUxMiksIGUxMyksIHopO1xuICAgICAgICAgICAgICAgIGxldCBlMXogPSBGci5tdWwoRnIubXVsKEZyLm11bChlMTEsIGUxMiksIGUxMyksIHpwKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBbZTEsIGUxel0gPSBNdWxaLm11bDQoZTExLCBlMTIsIGUxMywgeiwgYXAsIGJwLCBjcCwgenAsIGkgJSA0LCBGcik7XG5cbiAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIDIgLT4gKGEoWCkgKyBiZXRhwrdzaWdtYTEoWCkgKyBnYW1tYSkoYihYKSArIGJldGHCt3NpZ21hMihYKSArIGdhbW1hKShjKFgpICsgYmV0YcK3c2lnbWEzKFgpICsgZ2FtbWEpeihYz4kpXG4gICAgICAgICAgICAgICAgbGV0IGUyMSA9IEZyLmFkZChhLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBzaWdtYTEpKTtcbiAgICAgICAgICAgICAgICBlMjEgPSBGci5hZGQoZTIxLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMjIgPSBGci5hZGQoYiwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgc2lnbWEyKSk7XG4gICAgICAgICAgICAgICAgZTIyID0gRnIuYWRkKGUyMiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTIzID0gRnIuYWRkKGMsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHNpZ21hMykpO1xuICAgICAgICAgICAgICAgIGUyMyA9IEZyLmFkZChlMjMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUyID0gRnIubXVsKEZyLm11bChGci5tdWwoZTIxLCBlMjIpLCBlMjMpLCB6Vyk7XG4gICAgICAgICAgICAgICAgbGV0IGUyeiA9IEZyLm11bChGci5tdWwoRnIubXVsKGUyMSwgZTIyKSwgZTIzKSwgeldwKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBbZTIsIGUyel0gPSBNdWxaLm11bDQoZTIxLCBlMjIsIGUyMywgelcsIGFwLCBicCwgY3AsIHpXcCwgaSAlIDQsIEZyKTtcblxuICAgICAgICAgICAgICAgIGxldCB0MiA9IEZyLnN1YihlMSwgZTIpO1xuICAgICAgICAgICAgICAgIGxldCB0MnogPSBGci5zdWIoZTF6LCBlMnopO1xuXG4gICAgICAgICAgICAgICAgYnVmZmVycy5UMi5zZXQodDIsIGkgKiBzRnIpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuVDJ6LnNldCh0MnosIGkgKiBzRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IG9tZWdhXG4gICAgICAgICAgICAgICAgb21lZ2EgPSBGci5tdWwob21lZ2EsIEZyLndbemtleS5wb3dlciArIDJdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQyKFgpIGZyb20gYnVmZmVycy5UMlxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQyIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDIsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBEaXZpZGUgdGhlIHBvbHlub21pYWwgVDIgYnkgWl9IKFgpXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDIgLyBaSFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQyLmRpdkJ5WmVyb2ZpZXIoemtleS5kb21haW5TaXplLCBGci5vbmUpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVDJ6KFgpIGZyb20gYnVmZmVycy5UMnpcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMnogaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQyeiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVDJ6LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBwb2x5bm9taWFsIFQyeiB0byBUMiB0byBnZXQgdGhlIGZpbmFsIHBvbHlub21pYWwgVDJcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQyLmFkZChwb2x5bm9taWFscy5UMnopO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5UMi5kZWdyZWUoKSA+PSAzICogemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVDIgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5UMjtcbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlQyejtcbiAgICAgICAgICAgIGRlbGV0ZSBwb2x5bm9taWFscy5UMno7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlQzIoKSB7XG4gICAgICAgICAgICBsZXQgQzIgPSBuZXcgQ1BvbHlub21pYWwoMywgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBDMi5hZGRQb2x5bm9taWFsKDAsIHBvbHlub21pYWxzLlopO1xuICAgICAgICAgICAgQzIuYWRkUG9seW5vbWlhbCgxLCBwb2x5bm9taWFscy5UMSk7XG4gICAgICAgICAgICBDMi5hZGRQb2x5bm9taWFsKDIsIHBvbHlub21pYWxzLlQyKTtcblxuICAgICAgICAgICAgcG9seW5vbWlhbHMuQzIgPSBDMi5nZXRQb2x5bm9taWFsKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkMyLmRlZ3JlZSgpID49IDkgKiB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDMiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDMoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIHhpXCIpO1xuICAgICAgICAvLyBTVEVQIDMuMSAtIENvbXB1dGUgZXZhbHVhdGlvbiBjaGFsbGVuZ2UgeGkg4oiIIFNcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5nYW1tYSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiQzJcIikpO1xuXG4gICAgICAgIC8vIE9idGFpbiBhIHhpX3NlZWRlciBmcm9tIHRoZSB0cmFuc2NyaXB0XG4gICAgICAgIC8vIFRvIGZvcmNlIGgxXjQgPSB4aSwgaDJeMyA9IHhpIGFuZCBoXzNeMiA9IHhpz4lcbiAgICAgICAgLy8gd2UgY29tcHV0ZSB4aSA9IHhpX3NlZWRlcl4xMiwgaDEgPSB4aV9zZWVkZXJeMywgaDIgPSB4aV9zZWVkZXJeNCBhbmQgaDMgPSB4aV9zZWVkZXJeNlxuICAgICAgICBjaGFsbGVuZ2VzLnhpU2VlZCA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGNvbnN0IHhpU2VlZDIgPSBGci5zcXVhcmUoY2hhbGxlbmdlcy54aVNlZWQpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgb21lZ2E4LCBvbWVnYTQgYW5kIG9tZWdhM1xuICAgICAgICByb290cy53OCA9IFtdO1xuICAgICAgICByb290cy53OFswXSA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIHJvb3RzLnc4W2ldID0gRnIubXVsKHJvb3RzLnc4W2kgLSAxXSwgemtleS53OCk7XG4gICAgICAgIH1cblxuICAgICAgICByb290cy53NCA9IFtdO1xuICAgICAgICByb290cy53NFswXSA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHJvb3RzLnc0W2ldID0gRnIubXVsKHJvb3RzLnc0W2kgLSAxXSwgemtleS53NCk7XG4gICAgICAgIH1cblxuICAgICAgICByb290cy53MyA9IFtdO1xuICAgICAgICByb290cy53M1swXSA9IEZyLm9uZTtcbiAgICAgICAgcm9vdHMudzNbMV0gPSB6a2V5LnczO1xuICAgICAgICByb290cy53M1syXSA9IEZyLnNxdWFyZSh6a2V5LnczKTtcblxuICAgICAgICAvLyBDb21wdXRlIGgwID0geGlTZWVkZXJeM1xuICAgICAgICByb290cy5TMCA9IHt9O1xuICAgICAgICByb290cy5TMC5oMHc4ID0gW107XG4gICAgICAgIHJvb3RzLlMwLmgwdzhbMF0gPSBGci5tdWwoeGlTZWVkMiwgY2hhbGxlbmdlcy54aVNlZWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgcm9vdHMuUzAuaDB3OFtpXSA9IEZyLm11bChyb290cy5TMC5oMHc4WzBdLCByb290cy53OFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIGgxID0geGlfc2VlZGVyXjZcbiAgICAgICAgcm9vdHMuUzEgPSB7fTtcbiAgICAgICAgcm9vdHMuUzEuaDF3NCA9IFtdO1xuICAgICAgICByb290cy5TMS5oMXc0WzBdID0gRnIuc3F1YXJlKHJvb3RzLlMwLmgwdzhbMF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgcm9vdHMuUzEuaDF3NFtpXSA9IEZyLm11bChyb290cy5TMS5oMXc0WzBdLCByb290cy53NFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIGgyID0geGlfc2VlZGVyXjhcbiAgICAgICAgcm9vdHMuUzIgPSB7fTtcbiAgICAgICAgcm9vdHMuUzIuaDJ3MyA9IFtdO1xuICAgICAgICByb290cy5TMi5oMnczWzBdID0gRnIubXVsKHJvb3RzLlMxLmgxdzRbMF0sIHhpU2VlZDIpO1xuICAgICAgICByb290cy5TMi5oMnczWzFdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHJvb3RzLnczWzFdKTtcbiAgICAgICAgcm9vdHMuUzIuaDJ3M1syXSA9IEZyLm11bChyb290cy5TMi5oMnczWzBdLCByb290cy53M1syXSk7XG5cbiAgICAgICAgcm9vdHMuUzIuaDN3MyA9IFtdO1xuICAgICAgICAvLyBNdWx0aXBseSBoMyBieSB0aGlyZC1yb290LW9tZWdhIHRvIG9idGFpbiBoXzNeMyA9IHhpz4lcbiAgICAgICAgLy8gU28sIGgzID0geGlfc2VlZGVyXjggz4leezEvM31cbiAgICAgICAgcm9vdHMuUzIuaDN3M1swXSA9IEZyLm11bChyb290cy5TMi5oMnczWzBdLCB6a2V5LndyKTtcbiAgICAgICAgcm9vdHMuUzIuaDN3M1sxXSA9IEZyLm11bChyb290cy5TMi5oM3czWzBdLCByb290cy53M1sxXSk7XG4gICAgICAgIHJvb3RzLlMyLmgzdzNbMl0gPSBGci5tdWwocm9vdHMuUzIuaDN3M1swXSwgcm9vdHMudzNbMl0pO1xuXG4gICAgICAgIC8vIENvbXB1dGUgeGkgPSB4aV9zZWVkZXJeMjRcbiAgICAgICAgY2hhbGxlbmdlcy54aSA9IEZyLm11bChGci5zcXVhcmUocm9vdHMuUzIuaDJ3M1swXSksIHJvb3RzLlMyLmgydzNbMF0pO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMueGk6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy54aSkpO1xuXG4gICAgICAgIC8vIFJlc2VydmUgbWVtb3J5IGZvciBRJ3MgcG9seW5vbWlhbHNcbiAgICAgICAgcG9seW5vbWlhbHMuUUwgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUVIgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUU0gPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUU8gPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUUMgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBSZWFkIFEncyBldmFsdWF0aW9ucyBmcm9tIHprZXkgZmlsZVxuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFMLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FMX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFSLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FSX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFNLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FNX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFPLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FPX1NFQ1RJT05dWzBdLnApO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlFDLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1FDX1NFQ1RJT05dWzBdLnApO1xuXG4gICAgICAgIC8vIFNURVAgMy4yIC0gQ29tcHV0ZSBvcGVuaW5nIGV2YWx1YXRpb25zIGFuZCBhZGQgdGhlbSB0byB0aGUgcHJvb2YgKHRoaXJkIG91dHB1dCBvZiB0aGUgcHJvdmVyKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgZXZhbHVhdGlvbnNcIik7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJxbFwiLCBwb2x5bm9taWFscy5RTC5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJxclwiLCBwb2x5bm9taWFscy5RUi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJxbVwiLCBwb2x5bm9taWFscy5RTS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJxb1wiLCBwb2x5bm9taWFscy5RTy5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJxY1wiLCBwb2x5bm9taWFscy5RQy5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJzMVwiLCBwb2x5bm9taWFscy5TaWdtYTEuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiczJcIiwgcG9seW5vbWlhbHMuU2lnbWEyLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInMzXCIsIHBvbHlub21pYWxzLlNpZ21hMy5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJhXCIsIHBvbHlub21pYWxzLkEuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiYlwiLCBwb2x5bm9taWFscy5CLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImNcIiwgcG9seW5vbWlhbHMuQy5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJ6XCIsIHBvbHlub21pYWxzLlouZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMueGl3ID0gRnIubXVsKGNoYWxsZW5nZXMueGksIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiendcIiwgcG9seW5vbWlhbHMuWi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpdykpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwidDF3XCIsIHBvbHlub21pYWxzLlQxLmV2YWx1YXRlKGNoYWxsZW5nZXMueGl3KSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJ0MndcIiwgcG9seW5vbWlhbHMuVDIuZXZhbHVhdGUoY2hhbGxlbmdlcy54aXcpKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDQoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIGFscGhhXCIpO1xuICAgICAgICAvLyBTVEVQIDQuMSAtIENvbXB1dGUgY2hhbGxlbmdlIGFscGhhIOKIiCBGXG4gICAgICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMueGlTZWVkKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInFsXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInFyXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInFtXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInFvXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInFjXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInMxXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInMyXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInMzXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImFcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiYlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJjXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInpcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiendcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwidDF3XCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInQyd1wiKSk7XG4gICAgICAgIGNoYWxsZW5nZXMuYWxwaGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmFscGhhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYWxwaGEpKTtcblxuICAgICAgICAvLyBTVEVQIDQuMiAtIENvbXB1dGUgRihYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gUmVhZGluZyBDMCBwb2x5bm9taWFsXCIpO1xuICAgICAgICBwb2x5bm9taWFscy5DMCA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDgpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5DMC5jb2VmLCAwLCBzRG9tYWluICogOCwgemtleVNlY3Rpb25zW1pLRVlfRkZfQzBfU0VDVElPTl1bMF0ucCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBSMCBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb21wdXRlUjAoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBSMSBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb21wdXRlUjEoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBSMiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb21wdXRlUjIoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEYgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZUYoKTtcblxuICAgICAgICAvLyBUaGUgZm91cnRoIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbVzFdXzEpLCB3aGVyZSBXMTo9KGYvWl90KSh4KVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFcxIG11bHRpIGV4cG9uZW50aWF0aW9uXCIpO1xuICAgICAgICBsZXQgY29tbWl0VzEgPSBhd2FpdCBwb2x5bm9taWFscy5GLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJXMVwiKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlcxXCIsIGNvbW1pdFcxKTtcblxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlUjAoKSB7XG4gICAgICAgICAgICAvLyBDT01QVVRFIFIwXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgUjAoWCkgZnJvbSA4IGV2YWx1YXRpb25zIHVzaW5nIGxhZ3JhbmdlIGludGVycG9sYXRpb24uIFIwKFgpIOKIiCBGX3s8OH1bWF1cbiAgICAgICAgICAgIC8vIFdlIGRlY2lkZSB0byB1c2UgTGFncmFuZ2UgaW50ZXJwb2xhdGlvbnMgYmVjYXVzZSB0aGUgUjAgZGVncmVlIGlzIHZlcnkgc21hbGwgKGRlZyhSMCk9PT03KSxcbiAgICAgICAgICAgIC8vIGFuZCB3ZSB3ZXJlIG5vdCBhYmxlIHRvIGNvbXB1dGUgaXQgdXNpbmcgY3VycmVudCBpZmZ0IGltcGxlbWVudGF0aW9uIGJlY2F1c2UgdGhlIG9tZWdhIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlIwID0gUG9seW5vbWlhbC5sYWdyYW5nZVBvbHlub21pYWxJbnRlcnBvbGF0aW9uKFxuICAgICAgICAgICAgICAgIFtyb290cy5TMC5oMHc4WzBdLCByb290cy5TMC5oMHc4WzFdLCByb290cy5TMC5oMHc4WzJdLCByb290cy5TMC5oMHc4WzNdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMC5oMHc4WzRdLCByb290cy5TMC5oMHc4WzVdLCByb290cy5TMC5oMHc4WzZdLCByb290cy5TMC5oMHc4WzddXSxcbiAgICAgICAgICAgICAgICBbcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFswXSksIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbMV0pLFxuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzJdKSwgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFszXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbNF0pLCBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzVdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFs2XSksIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbN10pXSwgY3VydmUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgZGVncmVlIG9mIHIwKFgpIDwgOFxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlIwLmRlZ3JlZSgpID4gNykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlIwIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSMSgpIHtcbiAgICAgICAgICAgIC8vIENPTVBVVEUgUjFcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiBSMShYKSBmcm9tIDQgZXZhbHVhdGlvbnMgdXNpbmcgbGFncmFuZ2UgaW50ZXJwb2xhdGlvbi4gUjEoWCkg4oiIIEZfezw0fVtYXVxuICAgICAgICAgICAgLy8gV2UgZGVjaWRlIHRvIHVzZSBMYWdyYW5nZSBpbnRlcnBvbGF0aW9ucyBiZWNhdXNlIHRoZSBSMSBkZWdyZWUgaXMgdmVyeSBzbWFsbCAoZGVnKFIxKT09PTMpLFxuICAgICAgICAgICAgLy8gYW5kIHdlIHdlcmUgbm90IGFibGUgdG8gY29tcHV0ZSBpdCB1c2luZyBjdXJyZW50IGlmZnQgaW1wbGVtZW50YXRpb24gYmVjYXVzZSB0aGUgb21lZ2EgYXJlIGRpZmZlcmVudFxuICAgICAgICAgICAgcG9seW5vbWlhbHMuUjEgPSBQb2x5bm9taWFsLmxhZ3JhbmdlUG9seW5vbWlhbEludGVycG9sYXRpb24oXG4gICAgICAgICAgICAgICAgW3Jvb3RzLlMxLmgxdzRbMF0sIHJvb3RzLlMxLmgxdzRbMV0sIHJvb3RzLlMxLmgxdzRbMl0sIHJvb3RzLlMxLmgxdzRbM11dLFxuICAgICAgICAgICAgICAgIFtwb2x5bm9taWFscy5DMS5ldmFsdWF0ZShyb290cy5TMS5oMXc0WzBdKSwgcG9seW5vbWlhbHMuQzEuZXZhbHVhdGUocm9vdHMuUzEuaDF3NFsxXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMxLmV2YWx1YXRlKHJvb3RzLlMxLmgxdzRbMl0pLCBwb2x5bm9taWFscy5DMS5ldmFsdWF0ZShyb290cy5TMS5oMXc0WzNdKV0sIGN1cnZlKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGRlZ3JlZSBvZiByMShYKSA8IDRcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5SMS5kZWdyZWUoKSA+IDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSMSBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlUjIoKSB7XG4gICAgICAgICAgICAvLyBDT01QVVRFIFIyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgcjIoWCkgZnJvbSA2IGV2YWx1YXRpb25zIHVzaW5nIGxhZ3JhbmdlIGludGVycG9sYXRpb24uIHIyKFgpIOKIiCBGX3s8Nn1bWF1cbiAgICAgICAgICAgIC8vIFdlIGRlY2lkZSB0byB1c2UgTGFncmFuZ2UgaW50ZXJwb2xhdGlvbnMgYmVjYXVzZSB0aGUgUjIuZGVncmVlIGlzIHZlcnkgc21hbGwgKGRlZyhSMik9PT01KSxcbiAgICAgICAgICAgIC8vIGFuZCB3ZSB3ZXJlIG5vdCBhYmxlIHRvIGNvbXB1dGUgaXQgdXNpbmcgY3VycmVudCBpZmZ0IGltcGxlbWVudGF0aW9uIGJlY2F1c2UgdGhlIG9tZWdhIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlIyID0gUG9seW5vbWlhbC5sYWdyYW5nZVBvbHlub21pYWxJbnRlcnBvbGF0aW9uKFxuICAgICAgICAgICAgICAgIFtyb290cy5TMi5oMnczWzBdLCByb290cy5TMi5oMnczWzFdLCByb290cy5TMi5oMnczWzJdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oM3czWzBdLCByb290cy5TMi5oM3czWzFdLCByb290cy5TMi5oM3czWzJdXSxcbiAgICAgICAgICAgICAgICBbcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDJ3M1swXSksIHBvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgydzNbMV0pLFxuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oMnczWzJdKSwgcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDN3M1swXSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgzdzNbMV0pLCBwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oM3czWzJdKV0sIGN1cnZlKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGRlZ3JlZSBvZiByMihYKSA8IDZcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5SMi5kZWdyZWUoKSA+IDUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSMiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlRigpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBGIHBvbHlub21pYWxcIik7XG5cbiAgICAgICAgICAgIC8vIENPTVBVVEUgRihYKVxuICAgICAgICAgICAgcG9seW5vbWlhbHMuRiA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzAsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuRi5zdWIocG9seW5vbWlhbHMuUjApO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuRi5kaXZCeVplcm9maWVyKDgsIGNoYWxsZW5nZXMueGkpO1xuXG4gICAgICAgICAgICBsZXQgZjIgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMxLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGYyLnN1Yihwb2x5bm9taWFscy5SMSk7XG4gICAgICAgICAgICBmMi5tdWxTY2FsYXIoY2hhbGxlbmdlcy5hbHBoYSk7XG4gICAgICAgICAgICBmMi5kaXZCeVplcm9maWVyKDQsIGNoYWxsZW5nZXMueGkpO1xuXG4gICAgICAgICAgICBsZXQgZjMgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMyLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGYzLnN1Yihwb2x5bm9taWFscy5SMik7XG4gICAgICAgICAgICBmMy5tdWxTY2FsYXIoRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpKTtcbiAgICAgICAgICAgIGYzLmRpdkJ5WmVyb2ZpZXIoMywgY2hhbGxlbmdlcy54aSk7XG4gICAgICAgICAgICBmMy5kaXZCeVplcm9maWVyKDMsIGNoYWxsZW5nZXMueGl3KTtcblxuICAgICAgICAgICAgcG9seW5vbWlhbHMuRi5hZGQoZjIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuRi5hZGQoZjMpO1xuXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuRi5kZWdyZWUoKSA+PSA5ICogemtleS5kb21haW5TaXplIC0gNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkYgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQ1KCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZSB5XCIpO1xuXG4gICAgICAgIC8vIFNURVAgNS4xIC0gQ29tcHV0ZSByYW5kb20gZXZhbHVhdGlvbiBwb2ludCB5IOKIiCBGXG4gICAgICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIlcxXCIpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLnkgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLnk6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy55KSk7XG5cbiAgICAgICAgLy8gU1RFUCA1LjIgLSBDb21wdXRlIEwoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBMIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVMKCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBaVFMyIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVaVFMyKCk7XG5cbiAgICAgICAgbGV0IFpUUzJZID0gcG9seW5vbWlhbHMuWlRTMi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xuICAgICAgICBaVFMyWSA9IEZyLmludihaVFMyWSk7XG4gICAgICAgIHBvbHlub21pYWxzLkwubXVsU2NhbGFyKFpUUzJZKTtcblxuICAgICAgICBjb25zdCBwb2xEaXZpZGVuZCA9IFBvbHlub21pYWwuZnJvbUNvZWZmaWNpZW50c0FycmF5KFtGci5uZWcoY2hhbGxlbmdlcy55KSwgRnIub25lXSwgY3VydmUpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFcnID0gTCAvIFpUUzIgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgY29uc3QgcG9sUmVtYWluZGVyID0gcG9seW5vbWlhbHMuTC5kaXZCeShwb2xEaXZpZGVuZCk7XG5cbiAgICAgICAgLy9DaGVjayBwb2xSZW1pbmRlciBkZWdyZWUgaXMgZXF1YWwgdG8gemVyb1xuICAgICAgICBpZiAocG9sUmVtYWluZGVyLmRlZ3JlZSgpID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWdyZWUgb2YgTChYKS8oWlRTMih5KShYLXkpKSByZW1haW5kZXIgaXMgJHtwb2xSZW1haW5kZXIuZGVncmVlKCl9IGFuZCBzaG91bGQgYmUgMGApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvbHlub21pYWxzLkwuZGVncmVlKCkgPj0gOSAqIHprZXkuZG9tYWluU2l6ZSAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZ3JlZSBvZiBMKFgpLyhaVFMyKHkpKFgteSkpIGlzIG5vdCBjb3JyZWN0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZpZnRoIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbVzJdXzEpLCB3aGVyZSBXMjo9KGYvWl90KSh4KVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFcnIG11bHRpIGV4cG9uZW50aWF0aW9uXCIpO1xuICAgICAgICBsZXQgY29tbWl0VzIgPSBhd2FpdCBwb2x5bm9taWFscy5MLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJXMlwiKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIlcyXCIsIGNvbW1pdFcyKTtcblxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlTCgpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBMIHBvbHlub21pYWxcIik7XG5cbiAgICAgICAgICAgIGNvbnN0IGV2YWxSMFkgPSBwb2x5bm9taWFscy5SMC5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xuICAgICAgICAgICAgY29uc3QgZXZhbFIxWSA9IHBvbHlub21pYWxzLlIxLmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG4gICAgICAgICAgICBjb25zdCBldmFsUjJZID0gcG9seW5vbWlhbHMuUjIuZXZhbHVhdGUoY2hhbGxlbmdlcy55KTtcblxuICAgICAgICAgICAgbGV0IG11bEwwID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzAuaDB3OFswXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgICAgIG11bEwwID0gRnIubXVsKG11bEwwLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMC5oMHc4W2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtdWxMMSA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMxLmgxdzRbMF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBtdWxMMSA9IEZyLm11bChtdWxMMSwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzEuaDF3NFtpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbXVsTDIgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMi5oMnczWzBdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbXVsTDIgPSBGci5tdWwobXVsTDIsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgydzNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbXVsTDIgPSBGci5tdWwobXVsTDIsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgzdzNbaV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHByZUwwID0gRnIubXVsKG11bEwxLCBtdWxMMik7XG4gICAgICAgICAgICBsZXQgcHJlTDEgPSBGci5tdWwoY2hhbGxlbmdlcy5hbHBoYSwgRnIubXVsKG11bEwwLCBtdWxMMikpO1xuICAgICAgICAgICAgbGV0IHByZUwyID0gRnIubXVsKEZyLnNxdWFyZShjaGFsbGVuZ2VzLmFscGhhKSwgRnIubXVsKG11bEwwLCBtdWxMMSkpO1xuXG4gICAgICAgICAgICB0b0ludmVyc2VbXCJkZW5IMVwiXSA9IG11bEwxO1xuICAgICAgICAgICAgdG9JbnZlcnNlW1wiZGVuSDJcIl0gPSBtdWxMMjtcblxuICAgICAgICAgICAgLy8gQ09NUFVURSBMKFgpXG4gICAgICAgICAgICBwb2x5bm9taWFscy5MID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DMCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5MLnN1YlNjYWxhcihldmFsUjBZKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwubXVsU2NhbGFyKHByZUwwKTtcblxuICAgICAgICAgICAgbGV0IGwyID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DMSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBsMi5zdWJTY2FsYXIoZXZhbFIxWSk7XG4gICAgICAgICAgICBsMi5tdWxTY2FsYXIocHJlTDEpO1xuXG4gICAgICAgICAgICBsZXQgbDMgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMyLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGwzLnN1YlNjYWxhcihldmFsUjJZKTtcbiAgICAgICAgICAgIGwzLm11bFNjYWxhcihwcmVMMik7XG5cbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwuYWRkKGwyKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkwuYWRkKGwzKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBaVCBwb2x5bm9taWFsXCIpO1xuICAgICAgICAgICAgYXdhaXQgY29tcHV0ZVpUKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGV2YWxaVFkgPSBwb2x5bm9taWFscy5aVC5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuRi5tdWxTY2FsYXIoZXZhbFpUWSk7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5MLnN1Yihwb2x5bm9taWFscy5GKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuTC5kZWdyZWUoKSA+PSA5ICogemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTCBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLkw7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlWlQoKSB7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5aVCA9IFBvbHlub21pYWwuemVyb2ZpZXJQb2x5bm9taWFsKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzAuaDB3OFswXSwgcm9vdHMuUzAuaDB3OFsxXSwgcm9vdHMuUzAuaDB3OFsyXSwgcm9vdHMuUzAuaDB3OFszXSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzAuaDB3OFs0XSwgcm9vdHMuUzAuaDB3OFs1XSwgcm9vdHMuUzAuaDB3OFs2XSwgcm9vdHMuUzAuaDB3OFs3XSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzEuaDF3NFswXSwgcm9vdHMuUzEuaDF3NFsxXSwgcm9vdHMuUzEuaDF3NFsyXSwgcm9vdHMuUzEuaDF3NFszXSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzIuaDJ3M1swXSwgcm9vdHMuUzIuaDJ3M1sxXSwgcm9vdHMuUzIuaDJ3M1syXSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzIuaDN3M1swXSwgcm9vdHMuUzIuaDN3M1sxXSwgcm9vdHMuUzIuaDN3M1syXV0sIGN1cnZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVaVFMyKCkge1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuWlRTMiA9IFBvbHlub21pYWwuemVyb2ZpZXJQb2x5bm9taWFsKFxuICAgICAgICAgICAgICAgIFtyb290cy5TMS5oMXc0WzBdLCByb290cy5TMS5oMXc0WzFdLCByb290cy5TMS5oMXc0WzJdLCByb290cy5TMS5oMXc0WzNdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oMnczWzBdLCByb290cy5TMi5oMnczWzFdLCByb290cy5TMi5oMnczWzJdLFxuICAgICAgICAgICAgICAgICAgICByb290cy5TMi5oM3czWzBdLCByb290cy5TMi5oM3czWzFdLCByb290cy5TMi5oM3czWzJdXSwgY3VydmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TW9udGdvbWVyeUJhdGNoZWRJbnZlcnNlKCkge1xuICAgICAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiBzdGVwIDggYW5kIDkgb2YgdGhlIHZlcmlmaWVyIHRvIG11bHRpcGx5IGJ5IDEvWl9IKHhpKVxuICAgICAgICBsZXQgeGlOID0gY2hhbGxlbmdlcy54aTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LnBvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIHhpTiA9IEZyLnNxdWFyZSh4aU4pO1xuICAgICAgICB9XG4gICAgICAgIHRvSW52ZXJzZVtcInpoXCJdID0gRnIuc3ViKHhpTiwgRnIub25lKTtcblxuICAgICAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiBzdGVwIDEwIGFuZCAxMSBvZiB0aGUgdmVyaWZpZXJcbiAgICAgICAgLy8gICAgIHRvSW52ZXJzZS5kZW5IMSAmIHRvSW52ZXJzZS5kZW5IMiAgLT4gQ29tcHV0ZWQgaW4gcm91bmQ1LCBjb21wdXRlTCgpXG5cbiAgICAgICAgLy8gICDCtyBkZW5vbWluYXRvciBuZWVkZWQgaW4gdGhlIHZlcmlmaWVyIHdoZW4gY29tcHV0aW5nIExfaV57UzB9KFgpLCBMX2lee1MxfShYKSBhbmQgTF9pXntTMn0oWClcbiAgICAgICAgY29tcHV0ZUxpUzAodG9JbnZlcnNlLCByb290cy5TMC5oMHc4LCBjaGFsbGVuZ2VzLnksIGN1cnZlKTtcblxuICAgICAgICBjb21wdXRlTGlTMSh0b0ludmVyc2UsIHJvb3RzLlMxLmgxdzQsIGNoYWxsZW5nZXMueSwgY3VydmUpO1xuXG4gICAgICAgIGNvbXB1dGVMaVMyKHRvSW52ZXJzZSwgcm9vdHMuUzIuaDJ3Mywgcm9vdHMuUzIuaDN3MywgY2hhbGxlbmdlcy55LCBjaGFsbGVuZ2VzLnhpLCBjaGFsbGVuZ2VzLnhpdywgY3VydmUpO1xuXG4gICAgICAgIC8vICAgwrcgTF9pIGk9MSB0byBudW0gcHVibGljIGlucHV0cywgbmVlZGVkIGluIHN0ZXAgNiBhbmQgNyBvZiB0aGUgdmVyaWZpZXIgdG8gY29tcHV0ZSBMXzEoeGkpIGFuZCBQSSh4aSlcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KDEsIHprZXkublB1YmxpYyk7XG5cbiAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0b0ludmVyc2VbXCJMaV9cIiArIChpICsgMSldID0gRnIubXVsKEZyLmUoemtleS5kb21haW5TaXplKSwgRnIuc3ViKGNoYWxsZW5nZXMueGksIHcpKTtcbiAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1t6a2V5LnBvd2VyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbXVsQWNjdW11bGF0b3IgPSBGci5vbmU7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBPYmplY3QudmFsdWVzKHRvSW52ZXJzZSkpIHtcbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YkVsZW1lbnQgb2YgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBtdWxBY2N1bXVsYXRvciA9IEZyLm11bChtdWxBY2N1bXVsYXRvciwgc3ViRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtdWxBY2N1bXVsYXRvciA9IEZyLm11bChtdWxBY2N1bXVsYXRvciwgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZyLmludihtdWxBY2N1bXVsYXRvcik7XG5cbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVMaVMwKHRvSW52ZXJzZSwgcm9vdHMsIHgsIGN1cnZlKSB7XG4gICAgICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gcm9vdHMubGVuZ3RoO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGRlbjEgPSBGci5tdWwoRnIuZShsZW4pLCBGci5leHAocm9vdHNbMF0sIGxlbiAtIDIpKTtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBMaSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjIgPSByb290c1soKGxlbiAtIDEpICogaSkgJSBsZW5dO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjMgPSBGci5zdWIoeCwgcm9vdHNbaV0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICB0b0ludmVyc2VbW1wiTGlTMF9cIiArIChpICsgMSldXSA9IEZyLm11bChGci5tdWwoZGVuMSwgZGVuMiksIGRlbjMpO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBMaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVMaVMxKHRvSW52ZXJzZSwgcm9vdHMsIHgsIGN1cnZlKSB7XG4gICAgICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gcm9vdHMubGVuZ3RoO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGRlbjEgPSBGci5tdWwoRnIuZShsZW4pLCBGci5leHAocm9vdHNbMF0sIGxlbiAtIDIpKTtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBMaSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjIgPSByb290c1soKGxlbiAtIDEpICogaSkgJSBsZW5dO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjMgPSBGci5zdWIoeCwgcm9vdHNbaV0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICB0b0ludmVyc2VbW1wiTGlTMV9cIiArIChpICsgMSldXSA9IEZyLm11bChGci5tdWwoZGVuMSwgZGVuMiksIGRlbjMpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIExpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZUxpUzIodG9JbnZlcnNlLCBTMiwgUzJwLCB2YWx1ZSwgeGksIHhpdywgY3VydmUpIHtcbiAgICAgICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgTGkgPSBbXTtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBfM2gyID0gRnIubXVsKEZyLmUoMyksIFMyWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHhpc3VieGl3ID0gRnIuc3ViKHhpLCB4aXcpO1xuICAgICAgICAgICAgbGV0IGRlbjEgPSBGci5tdWwoXzNoMiwgeGlzdWJ4aXcpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW4yID0gUzJbMiAqIGkgJSAzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHZhbHVlLCBTMltpXSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHRvSW52ZXJzZVtbXCJMaVMyX1wiICsgKGkgKyAxKV1dID0gRnIubXVsKGRlbjEsRnIubXVsKGRlbjIsIGRlbjMpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBfM2gzID0gRnIubXVsKEZyLmUoMyksIFMycFswXSk7XG4gICAgICAgICAgICBjb25zdCB4aXdzdWJ4aSA9IEZyLnN1Yih4aXcsIHhpKTtcbiAgICAgICAgICAgIGRlbjEgPSBGci5tdWwoXzNoMywgeGl3c3VieGkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW4yID0gUzJwWzIgKiBpICUgM107XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih2YWx1ZSwgUzJwW2ldKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgdG9JbnZlcnNlW1tcIkxpUzJfXCIgKyAoaSArIDEgKyAzKV1dID0gRnIubXVsKGRlbjEsRnIubXVsKGRlbjIsIGRlbjMpKTsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIExpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbmNvbnN0IHt1bnN0cmluZ2lmeUJpZ0ludHM6IHVuc3RyaW5naWZ5QmlnSW50cyQyfSA9IHV0aWxzO1xuXG5hc3luYyBmdW5jdGlvbiBmZmxvbmtGdWxsUHJvdmUoX2lucHV0LCB3YXNtRmlsZW5hbWUsIHprZXlGaWxlbmFtZSwgbG9nZ2VyLCB3dG5zQ2FsY09wdGlvbnMsIHByb3Zlck9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyQyKF9pbnB1dCk7XG5cbiAgICBjb25zdCB3dG5zPSB7dHlwZTogXCJtZW1cIn07XG5cbiAgICAvLyBDb21wdXRlIHRoZSB3aXRuZXNzXG4gICAgYXdhaXQgd3Ruc0NhbGN1bGF0ZShpbnB1dCwgd2FzbUZpbGVuYW1lLCB3dG5zLCB3dG5zQ2FsY09wdGlvbnMpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgcHJvb2ZcbiAgICByZXR1cm4gYXdhaXQgZmZsb25rUHJvdmUoemtleUZpbGVuYW1lLCB3dG5zLCBsb2dnZXIsIHByb3Zlck9wdGlvbnMpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCB7IHVuc3RyaW5naWZ5QmlnSW50czogdW5zdHJpbmdpZnlCaWdJbnRzJDEgfSA9IHV0aWxzO1xuXG5hc3luYyBmdW5jdGlvbiBmZmxvbmtWZXJpZnkoX3ZrX3ZlcmlmaWVyLCBfcHVibGljU2lnbmFscywgX3Byb29mLCBsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBWRVJJRklFUiBTVEFSVEVEXCIpO1xuXG4gICAgX3ZrX3ZlcmlmaWVyID0gdW5zdHJpbmdpZnlCaWdJbnRzJDEoX3ZrX3ZlcmlmaWVyKTtcbiAgICBfcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMkMShfcHJvb2YpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21OYW1lKF92a192ZXJpZmllci5jdXJ2ZSk7XG5cbiAgICBjb25zdCB2ayA9IGZyb21PYmplY3RWayhjdXJ2ZSwgX3ZrX3ZlcmlmaWVyKTtcblxuICAgIC8vIFRPRE8gPz8/IENvbXB1dGUgd3JeMyBhbmQgY2hlY2sgaWYgaXQgbWF0Y2hlcyB3aXRoIHdcblxuICAgIGNvbnN0IHByb29mID0gbmV3IFByb29mKGN1cnZlLCBsb2dnZXIpO1xuICAgIHByb29mLmZyb21PYmplY3RQcm9vZihfcHJvb2YpO1xuXG4gICAgY29uc3QgcHVibGljU2lnbmFscyA9IHVuc3RyaW5naWZ5QmlnSW50cyQxKF9wdWJsaWNTaWduYWxzKTtcblxuICAgIGlmIChwdWJsaWNTaWduYWxzLmxlbmd0aCAhPT0gdmsublB1YmxpYykge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJOdW1iZXIgb2YgcHVibGljIHNpZ25hbHMgZG9lcyBub3QgbWF0Y2ggd2l0aCB2a1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCIgIEZGTE9OSyBWRVJJRlkgU0VUVElOR1NcIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEN1cnZlOiAgICAgICAgICR7Y3VydmUubmFtZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ2lyY3VpdCBwb3dlcjogJHt2ay5wb3dlcn1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgRG9tYWluIHNpemU6ICAgJHsyICoqIHZrLnBvd2VyfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBQdWJsaWMgdmFyczogICAke3ZrLm5QdWJsaWN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICB9XG5cbiAgICAvLyBTVEVQIDEgLSBWYWxpZGF0ZSB0aGF0IGFsbCBwb2x5bm9taWFsIGNvbW1pdG1lbnRzIOKIiCBHXzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ2hlY2tpbmcgY29tbWl0bWVudHMgYmVsb25nIHRvIEcxXCIpO1xuICAgIGlmICghY29tbWl0bWVudHNCZWxvbmdUb0cxKGN1cnZlLCBwcm9vZiwgdmspKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlByb29mIGNvbW1pdG1lbnRzIGFyZSBub3QgdmFsaWRcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTVEVQIDIgLSBWYWxpZGF0ZSB0aGF0IGFsbCBldmFsdWF0aW9ucyDiiIggRlxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDaGVja2luZyBldmFsdWF0aW9ucyBiZWxvbmcgdG8gRlwiKTtcbiAgICBpZiAoIWV2YWx1YXRpb25zQXJlVmFsaWQoY3VydmUsIHByb29mKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQcm9vZiBldmFsdWF0aW9ucyBhcmUgbm90IHZhbGlkLlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNURVAgMyAtIFZhbGlkYXRlIHRoYXQgd19pIOKIiCBGIGZvciBpIOKIiCBbbF1cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ2hlY2tpbmcgcHVibGljIGlucHV0cyBiZWxvbmcgdG8gRlwiKTtcbiAgICBpZiAoIXB1YmxpY0lucHV0c0FyZVZhbGlkKGN1cnZlLCBwdWJsaWNTaWduYWxzKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQdWJsaWMgaW5wdXRzIGFyZSBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU1RFUCA0IC0gQ29tcHV0ZSB0aGUgY2hhbGxlbmdlczogYmV0YSwgZ2FtbWEsIHhpLCBhbHBoYSBhbmQgeSDiiIggRlxuICAgIC8vIGFzIGluIHByb3ZlciBkZXNjcmlwdGlvbiwgZnJvbSB0aGUgY29tbW9uIHByZXByb2Nlc3NlZCBpbnB1dHMsIHB1YmxpYyBpbnB1dHMgYW5kIGVsZW1lbnRzIG9mIM+AX1NOQVJLXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBjaGFsbGVuZ2VzXCIpO1xuICAgIGNvbnN0IHsgY2hhbGxlbmdlcywgcm9vdHMgfSA9IGNvbXB1dGVDaGFsbGVuZ2VzKGN1cnZlLCBwcm9vZiwgdmssIHB1YmxpY1NpZ25hbHMsIGxvZ2dlcik7XG5cbiAgICAvLyBTVEVQIDUgLSBDb21wdXRlIHRoZSB6ZXJvIHBvbHlub21pYWwgZXZhbHVhdGlvbiBaX0goeGkpID0geGlebiAtIDFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFplcm8gcG9seW5vbWlhbCBldmFsdWF0aW9uIFpfSCh4aSlcIik7XG4gICAgY2hhbGxlbmdlcy56aCA9IEZyLnN1YihjaGFsbGVuZ2VzLnhpTiwgRnIub25lKTtcbiAgICBjaGFsbGVuZ2VzLmludnpoID0gRnIuaW52KGNoYWxsZW5nZXMuemgpO1xuXG4gICAgLy8gU1RFUCA2IC0gQ29tcHV0ZSB0aGUgbGFncmFuZ2UgcG9seW5vbWlhbCBldmFsdWF0aW9uIExfMSh4aSlcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIExhZ3JhbmdlIGV2YWx1YXRpb25zXCIpO1xuICAgIGNvbnN0IGxhZ3JhbmdlRXZhbHMgPSBhd2FpdCBjb21wdXRlTGFncmFuZ2VFdmFsdWF0aW9ucyhjdXJ2ZSwgY2hhbGxlbmdlcywgdmspO1xuXG4gICAgLy8gU1RFUCA3IC0gQ29tcHV0ZSBwdWJsaWMgaW5wdXQgZXZhbHVhdGlvbiBQSSh4aSlcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIHBvbHlub21pYWwgaWRlbnRpdGllcyBQSShYKVwiKTtcbiAgICBjb25zdCBwaSA9IGNhbGN1bGF0ZVBJKGN1cnZlLCBwdWJsaWNTaWduYWxzLCBsYWdyYW5nZUV2YWxzKTtcblxuICAgIC8vIFNURVAgOCAtIENvbXB1dGUgcG9seW5vbWlhbCByMCDiiIggRl97PDR9W1hdXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyByMCh5KVwiKTtcbiAgICBjb25zdCByMCA9IGNvbXB1dGVSMChwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgLy8gU1RFUCA5IC0gQ29tcHV0ZSBwb2x5bm9taWFsIHIxIOKIiCBGX3s8NH1bWF1cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIHIxKHkpXCIpO1xuICAgIGNvbnN0IHIxID0gY29tcHV0ZVIxKHByb29mLCBjaGFsbGVuZ2VzLCByb290cywgcGksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgLy8gU1RFUCA5IC0gQ29tcHV0ZSBwb2x5bm9taWFsIHIyIOKIiCBGX3s8Nn1bWF1cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIHIyKHkpXCIpO1xuICAgIGNvbnN0IHIyID0gY29tcHV0ZVIyKHByb29mLCBjaGFsbGVuZ2VzLCByb290cywgbGFncmFuZ2VFdmFsc1sxXSwgdmssIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBGXCIpO1xuICAgIGNvbnN0IEYgPSBjb21wdXRlRihjdXJ2ZSwgcHJvb2YsIHZrLCBjaGFsbGVuZ2VzLCByb290cyk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEVcIik7XG4gICAgY29uc3QgRSA9IGNvbXB1dGVFKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmssIHIwLCByMSwgcjIpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBKXCIpO1xuICAgIGNvbnN0IEogPSBjb21wdXRlSihjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFZhbGlkYXRlIGFsbCBldmFsdWF0aW9ucyB3aXRoIGEgcGFpcmluZ1wiKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBpc1ZhbGlkUGFpcmluZyhjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrLCBGLCBFLCBKKTtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJQUk9PRiBWRVJJRklFRCBTVUNDRVNTRlVMTFlcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIkludmFsaWQgUHJvb2ZcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBWRVJJRklFUiBGSU5JU0hFRFwiKTtcblxuICAgIHJldHVybiByZXM7XG5cbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdFZrKGN1cnZlLCB2aykge1xuICAgIGNvbnN0IHJlcyA9IHZrO1xuICAgIHJlcy5rMSA9IGN1cnZlLkZyLmZyb21PYmplY3QodmsuazEpO1xuICAgIHJlcy5rMiA9IGN1cnZlLkZyLmZyb21PYmplY3QodmsuazIpO1xuICAgIHJlcy53ID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay53KTtcbiAgICAvLyByZXMud1cgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLndXKTtcbiAgICByZXMudzMgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLnczKTtcbiAgICByZXMudzQgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLnc0KTtcbiAgICByZXMudzggPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLnc4KTtcbiAgICByZXMud3IgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLndyKTtcbiAgICByZXMuWF8yID0gY3VydmUuRzIuZnJvbU9iamVjdCh2ay5YXzIpO1xuICAgIHJlcy5DMCA9IGN1cnZlLkcxLmZyb21PYmplY3QodmsuQzApO1xuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdG1lbnRzQmVsb25nVG9HMShjdXJ2ZSwgcHJvb2YsIHZrKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICByZXR1cm4gRzEuaXNWYWxpZChwcm9vZi5wb2x5bm9taWFscy5DMSlcbiAgICAgICAgJiYgRzEuaXNWYWxpZChwcm9vZi5wb2x5bm9taWFscy5DMilcbiAgICAgICAgJiYgRzEuaXNWYWxpZChwcm9vZi5wb2x5bm9taWFscy5XMSlcbiAgICAgICAgJiYgRzEuaXNWYWxpZChwcm9vZi5wb2x5bm9taWFscy5XMilcbiAgICAgICAgJiYgRzEuaXNWYWxpZCh2ay5DMCk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsdWVCZWxvbmdUb0ZpZWxkKGN1cnZlLCB2YWx1ZSkge1xuICAgIHJldHVybiBTY2FsYXIuZ2VxKHZhbHVlLCAwKSAmJiBTY2FsYXIubHQodmFsdWUsIGN1cnZlLnIpO1xufVxuXG5mdW5jdGlvbiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBldmFsdWF0aW9uKSB7XG4gICAgcmV0dXJuIGNoZWNrVmFsdWVCZWxvbmdUb0ZpZWxkKGN1cnZlLCBTY2FsYXIuZnJvbVJwckxFKGV2YWx1YXRpb24pKTtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGlvbnNBcmVWYWxpZChjdXJ2ZSwgcHJvb2YpIHtcbiAgICByZXR1cm4gY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMucWwpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnFyKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5xbSlcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMucW8pXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnFjKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5zMSlcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuczIpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnMzKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5hKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5iKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5jKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy56KVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy56dylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMudDF3KVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy50MncpO1xufVxuXG5mdW5jdGlvbiBwdWJsaWNJbnB1dHNBcmVWYWxpZChjdXJ2ZSwgcHVibGljSW5wdXRzKSB7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHB1YmxpY0lucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZighY2hlY2tWYWx1ZUJlbG9uZ1RvRmllbGQoY3VydmUsIHB1YmxpY0lucHV0c1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNoYWxsZW5nZXMoY3VydmUsIHByb29mLCB2aywgcHVibGljU2lnbmFscywgbG9nZ2VyKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IGNoYWxsZW5nZXMgPSB7fTtcbiAgICBjb25zdCByb290cyA9IHt9O1xuICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG5cbiAgICAvLyBBZGQgQzAgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuQzApO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWJsaWNTaWduYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKEZyLmUocHVibGljU2lnbmFsc1tpXSkpO1xuICAgIH1cblxuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5wb2x5bm9taWFscy5DMSk7XG4gICAgY2hhbGxlbmdlcy5iZXRhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG5cbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmJldGEpO1xuICAgIGNoYWxsZW5nZXMuZ2FtbWEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuXG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5wb2x5bm9taWFscy5DMik7XG4gICAgY29uc3QgeGlTZWVkID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICBjb25zdCB4aVNlZWQyID0gRnIuc3F1YXJlKHhpU2VlZCk7XG5cbiAgICBsZXQgdzggPSBbXTtcbiAgICB3OFsxXSA9IHZrLnc4O1xuICAgIHc4WzJdID0gRnIuc3F1YXJlKHZrLnc4KTtcbiAgICB3OFszXSA9IEZyLm11bCh3OFsyXSwgdmsudzgpO1xuICAgIHc4WzRdID0gRnIubXVsKHc4WzNdLCB2ay53OCk7XG4gICAgdzhbNV0gPSBGci5tdWwodzhbNF0sIHZrLnc4KTtcbiAgICB3OFs2XSA9IEZyLm11bCh3OFs1XSwgdmsudzgpO1xuICAgIHc4WzddID0gRnIubXVsKHc4WzZdLCB2ay53OCk7XG4gICAgbGV0IHc0ID0gW107XG4gICAgdzRbMV0gPSB2ay53NDtcbiAgICB3NFsyXSA9IEZyLnNxdWFyZSh2ay53NCk7XG4gICAgdzRbM10gPSBGci5tdWwodzRbMl0sIHZrLnc0KTtcbiAgICBsZXQgdzMgPSBbXTtcbiAgICB3M1sxXSA9IHZrLnczO1xuICAgIHczWzJdID0gRnIuc3F1YXJlKHZrLnczKTtcblxuICAgIC8vIGNvbnN0IHc0XzIgPSBGci5zcXVhcmUodmsudzQpO1xuICAgIC8vIGNvbnN0IHc0XzMgPSBGci5tdWwodzRfMiwgdmsudzQpO1xuICAgIC8vIGNvbnN0IHczXzIgPSBGci5zcXVhcmUodmsudzMpO1xuXG4gICAgLy8gQ29tcHV0ZSBoMCA9IHhpU2VlZGVyXjNcbiAgICByb290cy5TMCA9IHt9O1xuICAgIHJvb3RzLlMwLmgwdzggPSBbXTtcbiAgICByb290cy5TMC5oMHc4WzBdID0gRnIubXVsKHhpU2VlZDIsIHhpU2VlZCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgcm9vdHMuUzAuaDB3OFtpXSA9IEZyLm11bChyb290cy5TMC5oMHc4WzBdLCB3OFtpXSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBoMSA9IHhpX3NlZWRlcl42XG4gICAgcm9vdHMuUzEgPSB7fTtcbiAgICByb290cy5TMS5oMXc0ID0gW107XG4gICAgcm9vdHMuUzEuaDF3NFswXSA9IEZyLnNxdWFyZShyb290cy5TMC5oMHc4WzBdKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICByb290cy5TMS5oMXc0W2ldID0gRnIubXVsKHJvb3RzLlMxLmgxdzRbMF0sIHc0W2ldKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGgyID0geGlfc2VlZGVyXjhcbiAgICByb290cy5TMiA9IHt9O1xuICAgIHJvb3RzLlMyLmgydzMgPSBbXTtcbiAgICByb290cy5TMi5oMnczWzBdID0gRnIubXVsKHJvb3RzLlMxLmgxdzRbMF0sIHhpU2VlZDIpO1xuICAgIHJvb3RzLlMyLmgydzNbMV0gPSBGci5tdWwocm9vdHMuUzIuaDJ3M1swXSwgdzNbMV0pO1xuICAgIHJvb3RzLlMyLmgydzNbMl0gPSBGci5tdWwocm9vdHMuUzIuaDJ3M1swXSwgdzNbMl0pO1xuXG4gICAgcm9vdHMuUzIuaDN3MyA9IFtdO1xuICAgIC8vIE11bHRpcGx5IGgzIGJ5IHRoaXJkLXJvb3Qtb21lZ2EgdG8gb2J0YWluIGhfM14zID0geGnPiVxuICAgIC8vIFNvLCBoMyA9IHhpX3NlZWRlcl44IM+JXnsxLzN9XG4gICAgcm9vdHMuUzIuaDN3M1swXSA9IEZyLm11bChyb290cy5TMi5oMnczWzBdLCB2ay53cik7XG4gICAgcm9vdHMuUzIuaDN3M1sxXSA9IEZyLm11bChyb290cy5TMi5oM3czWzBdLCB3M1sxXSk7XG4gICAgcm9vdHMuUzIuaDN3M1syXSA9IEZyLm11bChyb290cy5TMi5oM3czWzBdLCB3M1syXSk7XG5cbiAgICAvLyBDb21wdXRlIHhpID0geGlfc2VlZGVyXjEyXG4gICAgY2hhbGxlbmdlcy54aSA9IEZyLm11bChGci5zcXVhcmUocm9vdHMuUzIuaDJ3M1swXSksIHJvb3RzLlMyLmgydzNbMF0pO1xuICAgIGNoYWxsZW5nZXMueGl3ID0gRnIubXVsKGNoYWxsZW5nZXMueGksIEZyLndbdmsucG93ZXJdKTtcblxuICAgIGNoYWxsZW5nZXMueGlOID0gY2hhbGxlbmdlcy54aTtcbiAgICB2ay5kb21haW5TaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZrLnBvd2VyOyBpKyspIHtcbiAgICAgICAgY2hhbGxlbmdlcy54aU4gPSBGci5zcXVhcmUoY2hhbGxlbmdlcy54aU4pO1xuICAgICAgICB2ay5kb21haW5TaXplICo9IDI7XG4gICAgfVxuXG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHhpU2VlZCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMucWwpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnFyKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5xbSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMucW8pO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnFjKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5zMSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuczIpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnMzKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5hKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5iKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5jKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy56KTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy56dyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMudDF3KTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy50MncpO1xuICAgIGNoYWxsZW5nZXMuYWxwaGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuXG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5wb2x5bm9taWFscy5XMSk7XG4gICAgY2hhbGxlbmdlcy55ID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5iZXRhOiAgXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmJldGEpKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5nYW1tYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMueGk6ICAgIFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmFscGhhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYWxwaGEpKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy55OiAgICAgXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBjaGFsbGVuZ2VzOiBjaGFsbGVuZ2VzLCByb290czogcm9vdHMgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUxhZ3JhbmdlRXZhbHVhdGlvbnMoY3VydmUsIGNoYWxsZW5nZXMsIHZrKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heCgxLCB2ay5uUHVibGljKTtcbiAgICBjb25zdCBudW1BcnIgPSBuZXcgQmlnQnVmZmVyKHNpemUgKiBGci5uOCk7XG4gICAgbGV0IGRlbkFyciA9IG5ldyBCaWdCdWZmZXIoc2l6ZSAqIEZyLm44KTtcblxuICAgIGxldCB3ID0gRnIub25lO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIEZyLm44O1xuICAgICAgICBudW1BcnIuc2V0KEZyLm11bCh3LCBjaGFsbGVuZ2VzLnpoKSwgaV9zRnIpO1xuICAgICAgICBkZW5BcnIuc2V0KEZyLm11bChGci5lKHZrLmRvbWFpblNpemUpLCBGci5zdWIoY2hhbGxlbmdlcy54aSwgdykpLCBpX3NGcik7XG4gICAgICAgIHcgPSBGci5tdWwodywgdmsudyk7XG4gICAgfVxuXG4gICAgZGVuQXJyID0gYXdhaXQgRnIuYmF0Y2hJbnZlcnNlKGRlbkFycik7XG5cbiAgICBsZXQgTCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIEZyLm44O1xuICAgICAgICBMW2kgKyAxXSA9IEZyLm11bChudW1BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgRnIubjgpLCBkZW5BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgRnIubjgpKTtcbiAgICB9XG4gICAgcmV0dXJuIEw7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBJKGN1cnZlLCBwdWJsaWNTaWduYWxzLCBsYWdyYW5nZUV2YWxzKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBwaSA9IEZyLnplcm87XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWJsaWNTaWduYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHcgPSBGci5lKHB1YmxpY1NpZ25hbHNbaV0pO1xuICAgICAgICBwaSA9IEZyLnN1YihwaSwgRnIubXVsKHcsIGxhZ3JhbmdlRXZhbHNbaSArIDFdKSk7XG4gICAgfVxuICAgIHJldHVybiBwaTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVIwKHByb29mLCBjaGFsbGVuZ2VzLCByb290cywgY3VydmUsIGxvZ2dlcikge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBMaSA9IGNvbXB1dGVMYWdyYW5nZUxpU2kocm9vdHMuUzAuaDB3OCwgY2hhbGxlbmdlcy55LCBjaGFsbGVuZ2VzLnhpLCBjdXJ2ZSk7XG5cbiAgICAvLyByMCh5KSA9IOKIkV8xXjggQ18wKGhfMCDPiV84XntpLTF9KSBMX2koeSkuIFRvIHRoaXMgZW5kIHdlIG5lZWQgdG8gY29tcHV0ZVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgOCBDMCB2YWx1ZXNcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgcjAoeSlcIik7XG5cbiAgICBsZXQgcmVzID0gRnIuemVybztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICBsZXQgY29lZlZhbHVlcyA9IFtdO1xuICAgICAgICBjb2VmVmFsdWVzWzFdID0gcm9vdHMuUzAuaDB3OFtpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDI7IGogPCA4OyBqKyspIHtcbiAgICAgICAgICAgIGNvZWZWYWx1ZXNbal0gPSBGci5tdWwoY29lZlZhbHVlc1tqIC0gMV0sIHJvb3RzLlMwLmgwdzhbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGMwID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLnFsLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucXIsIGNvZWZWYWx1ZXNbMV0pKTtcbiAgICAgICAgYzAgPSBGci5hZGQoYzAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xbywgY29lZlZhbHVlc1syXSkpO1xuICAgICAgICBjMCA9IEZyLmFkZChjMCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFtLCBjb2VmVmFsdWVzWzNdKSk7XG4gICAgICAgIGMwID0gRnIuYWRkKGMwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucWMsIGNvZWZWYWx1ZXNbNF0pKTtcbiAgICAgICAgYzAgPSBGci5hZGQoYzAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5zMSwgY29lZlZhbHVlc1s1XSkpO1xuICAgICAgICBjMCA9IEZyLmFkZChjMCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnMyLCBjb2VmVmFsdWVzWzZdKSk7XG4gICAgICAgIGMwID0gRnIuYWRkKGMwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMuczMsIGNvZWZWYWx1ZXNbN10pKTtcblxuICAgICAgICByZXMgPSBGci5hZGQocmVzLCBGci5tdWwoYzAsIExpW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVIxKHByb29mLCBjaGFsbGVuZ2VzLCByb290cywgcGksIGN1cnZlLCBsb2dnZXIpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3QgTGkgPSBjb21wdXRlTGFncmFuZ2VMaVNpKHJvb3RzLlMxLmgxdzQsIGNoYWxsZW5nZXMueSwgY2hhbGxlbmdlcy54aSwgY3VydmUpO1xuXG4gICAgLy8gcjEoeSkgPSDiiJFfMV40IENfMShoXzEgz4lfNF57aS0xfSkgTF9pKHkpLiBUbyB0aGlzIGVuZCB3ZSBuZWVkIHRvIGNvbXB1dGVcbiAgICAvLyBaMSA9IHtDMShoXzF9LCBDMShoXzEgz4lfNCksIEMxKGhfMSDPiV80XjIpLCBDMShoXzEgz4lfNF4zKX1cbiAgICAvLyB3aGVyZSBDXzEoaF8xIM+JXzRee2ktMX0pID0gZXZhbC5hICsgaF8xIM+JXzReaSBldmFsLmIgKyAoaF8xIM+JXzReaSleMiBldmFsLmMgKyAoaF8xIM+JXzReaSleMyBUMCh4aSksXG4gICAgLy8gd2hlcmUgVDAoeGkpID0gWyBxTMK3YSArIHFSwrdiICsgcU3Ct2HCt2IgKyBxT8K3YyArIHFDICsgUEkoeGkpIF0gLyBaX0goeGkpXG5cbiAgICAvLyBDb21wdXRlIFQwKHhpKVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMCh4aSlcIik7XG4gICAgbGV0IHQwID0gRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFsLCBwcm9vZi5ldmFsdWF0aW9ucy5hKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFyLCBwcm9vZi5ldmFsdWF0aW9ucy5iKSk7XG4gICAgdDAgPSBGci5hZGQodDAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xbSwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLmEsIHByb29mLmV2YWx1YXRpb25zLmIpKSk7XG4gICAgdDAgPSBGci5hZGQodDAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xbywgcHJvb2YuZXZhbHVhdGlvbnMuYykpO1xuICAgIHQwID0gRnIuYWRkKHQwLCBwcm9vZi5ldmFsdWF0aW9ucy5xYyk7XG4gICAgdDAgPSBGci5hZGQodDAsIHBpKTtcbiAgICB0MCA9IEZyLm11bCh0MCwgY2hhbGxlbmdlcy5pbnZ6aCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSA0IEMxIHZhbHVlc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBDMShoXzHPiV80XmkpIHZhbHVlc1wiKTtcblxuICAgIGxldCByZXMgPSBGci56ZXJvO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIGxldCBjMSA9IHByb29mLmV2YWx1YXRpb25zLmE7XG4gICAgICAgIGMxID0gRnIuYWRkKGMxLCBGci5tdWwocm9vdHMuUzEuaDF3NFtpXSwgcHJvb2YuZXZhbHVhdGlvbnMuYikpO1xuICAgICAgICBjb25zdCBoMXc0U3F1YXJlZCA9IEZyLnNxdWFyZShyb290cy5TMS5oMXc0W2ldKTtcbiAgICAgICAgYzEgPSBGci5hZGQoYzEsIEZyLm11bChoMXc0U3F1YXJlZCwgcHJvb2YuZXZhbHVhdGlvbnMuYykpO1xuICAgICAgICBjMSA9IEZyLmFkZChjMSwgRnIubXVsKEZyLm11bChoMXc0U3F1YXJlZCwgcm9vdHMuUzEuaDF3NFtpXSksIHQwKSk7XG5cbiAgICAgICAgcmVzID0gRnIuYWRkKHJlcywgRnIubXVsKGMxLCBMaVtpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVSMihwcm9vZiwgY2hhbGxlbmdlcywgcm9vdHMsIGxhZ3JhbmdlMSwgdmssIGN1cnZlLCBsb2dnZXIpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3QgTGlTMiA9IGNvbXB1dGVMYWdyYW5nZUxpUzIoW3Jvb3RzLlMyLmgydzMsIHJvb3RzLlMyLmgzdzNdLCBjaGFsbGVuZ2VzLnksIGNoYWxsZW5nZXMueGksIGNoYWxsZW5nZXMueGl3LCBjdXJ2ZSk7XG5cbiAgICAvLyByMih5KSA9IOKIkV8xXjMgQ18yKGhfMiDPiV8zXntpLTF9KSBMX2koeSkgKyDiiJFfMV4zIENfMihoXzMgz4lfM157aS0xfSkgTF97aSszfSh5KS4gVG8gdGhpcyBlbmQgd2UgbmVlZCB0byBjb21wdXRlXG4gICAgLy8gWjIgPSB7W0MyKGhfMn0sIEMyKGhfMiDPiV8zKSwgQzIoaF8yIM+JXzNeMildLCBbQzIoaF8zfSwgQzIoaF8zIM+JXzMpLCBDMihoXzMgz4lfM14yKV19XG4gICAgLy8gd2hlcmUgQ18yKGhfMiDPiV8zXntpLTF9KSA9IGV2YWwueiArIGhfMiDPiV8yXmkgVDEoeGkpICsgKGhfMiDPiV8zXmkpXjIgVDIoeGkpLFxuICAgIC8vIHdoZXJlIENfMihoXzMgz4lfM157aS0xfSkgPSBldmFsLnogKyBoXzMgz4lfMl5pIFQxKHhpKSArIChoXzMgz4lfM15pKV4yIFQyKHhpKSxcbiAgICAvLyB3aGVyZSBUMSh4aSkgPSBbIExfMSh4aSkoei0xKV0gLyBaX0goeGkpXG4gICAgLy8gYW5kIFQyKHhpKSA9IFsgIChhICsgYmV0YcK3eGkgKyBnYW1tYSkoYiArIGJldGHCt3hpwrdrMSArIGdhbW1hKShjICsgYmV0YcK3eGnCt2syICsgZ2FtbWEpelxuICAgIC8vICAgICAgICAgICAgICAgLSAoYSArIGJldGHCt3NpZ21hMSArIGdhbW1hKShiICsgYmV0YcK3c2lnbWEyICsgZ2FtbWEpKGMgKyBiZXRhwrdzaWdtYTMgKyBnYW1tYSl6z4kgIF0gLyBaX0goeGkpXG5cbiAgICAvLyBDb21wdXRlIFQxKHhpKVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMSh4aSlcIik7XG4gICAgbGV0IHQxID0gRnIuc3ViKHByb29mLmV2YWx1YXRpb25zLnosIEZyLm9uZSk7XG4gICAgdDEgPSBGci5tdWwodDEsIGxhZ3JhbmdlMSk7XG4gICAgdDEgPSBGci5tdWwodDEsIGNoYWxsZW5nZXMuaW52emgpO1xuXG4gICAgLy8gQ29tcHV0ZSBUMih4aSlcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDIoeGkpXCIpO1xuICAgIGNvbnN0IGJldGF4aSA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGNoYWxsZW5nZXMueGkpO1xuICAgIGNvbnN0IHQyMTEgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYSwgRnIuYWRkKGJldGF4aSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMTIgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYiwgRnIuYWRkKEZyLm11bChiZXRheGksIHZrLmsxKSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMTMgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYywgRnIuYWRkKEZyLm11bChiZXRheGksIHZrLmsyKSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMSA9IEZyLm11bCh0MjExLCBGci5tdWwodDIxMiwgRnIubXVsKHQyMTMsIHByb29mLmV2YWx1YXRpb25zLnopKSk7XG5cbiAgICBjb25zdCB0MjIxID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmEsIEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsdWF0aW9ucy5zMSksIGNoYWxsZW5nZXMuZ2FtbWEpKTtcbiAgICBjb25zdCB0MjIyID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmIsIEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsdWF0aW9ucy5zMiksIGNoYWxsZW5nZXMuZ2FtbWEpKTtcbiAgICBjb25zdCB0MjIzID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLmMsIEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsdWF0aW9ucy5zMyksIGNoYWxsZW5nZXMuZ2FtbWEpKTtcbiAgICBjb25zdCB0MjIgPSBGci5tdWwodDIyMSwgRnIubXVsKHQyMjIsIEZyLm11bCh0MjIzLCBwcm9vZi5ldmFsdWF0aW9ucy56dykpKTtcblxuICAgIGxldCB0MiA9IEZyLnN1Yih0MjEsIHQyMik7XG4gICAgdDIgPSBGci5tdWwodDIsIGNoYWxsZW5nZXMuaW52emgpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgNiBDMiB2YWx1ZXNcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQzIoaF8yz4lfM15pKSB2YWx1ZXNcIik7XG4gICAgbGV0IHJlcyA9IEZyLnplcm87XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgbGV0IGMyID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLnosIEZyLm11bChyb290cy5TMi5oMnczW2ldLCB0MSkpO1xuICAgICAgICBjMiA9IEZyLmFkZChjMiwgRnIubXVsKEZyLnNxdWFyZShyb290cy5TMi5oMnczW2ldKSwgdDIpKTtcblxuICAgICAgICByZXMgPSBGci5hZGQocmVzLCBGci5tdWwoYzIsIExpUzJbaV0pKTtcbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQzIoaF8zz4lfM15pKSB2YWx1ZXNcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgbGV0IGMyID0gRnIuYWRkKHByb29mLmV2YWx1YXRpb25zLnp3LCBGci5tdWwocm9vdHMuUzIuaDN3M1tpXSwgcHJvb2YuZXZhbHVhdGlvbnMudDF3KSk7XG4gICAgICAgIGMyID0gRnIuYWRkKGMyLCBGci5tdWwoRnIuc3F1YXJlKHJvb3RzLlMyLmgzdzNbaV0pLCBwcm9vZi5ldmFsdWF0aW9ucy50MncpKTtcblxuICAgICAgICByZXMgPSBGci5hZGQocmVzLCBGci5tdWwoYzIsIExpUzJbaSArIDNdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUYoY3VydmUsIHByb29mLCB2aywgY2hhbGxlbmdlcywgcm9vdHMpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgbXVsSDAgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMC5oMHc4WzBdKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICBtdWxIMCA9IEZyLm11bChtdWxIMCwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzAuaDB3OFtpXSkpO1xuICAgIH1cblxuICAgIGNoYWxsZW5nZXMudGVtcCA9IG11bEgwO1xuXG4gICAgbGV0IG11bEgxID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzEuaDF3NFswXSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgbXVsSDEgPSBGci5tdWwobXVsSDEsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMxLmgxdzRbaV0pKTtcbiAgICB9XG5cbiAgICBsZXQgbXVsSDIgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMi5oMnczWzBdKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDM7IGkrKykge1xuICAgICAgICBtdWxIMiA9IEZyLm11bChtdWxIMiwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDJ3M1tpXSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBtdWxIMiA9IEZyLm11bChtdWxIMiwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDN3M1tpXSkpO1xuICAgIH1cblxuICAgIGNoYWxsZW5nZXMucXVvdGllbnQxID0gRnIubXVsKGNoYWxsZW5nZXMuYWxwaGEsIEZyLmRpdihtdWxIMCwgbXVsSDEpKTtcbiAgICBjaGFsbGVuZ2VzLnF1b3RpZW50MiA9IEZyLm11bChGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSksIEZyLmRpdihtdWxIMCwgbXVsSDIpKTtcblxuICAgIGxldCBGMiA9IEcxLnRpbWVzRnIocHJvb2YucG9seW5vbWlhbHMuQzEsIGNoYWxsZW5nZXMucXVvdGllbnQxKTtcbiAgICBsZXQgRjMgPSBHMS50aW1lc0ZyKHByb29mLnBvbHlub21pYWxzLkMyLCBjaGFsbGVuZ2VzLnF1b3RpZW50Mik7XG5cbiAgICByZXR1cm4gRzEuYWRkKHZrLkMwLCBHMS5hZGQoRjIsIEYzKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmssIHIwLCByMSwgcjIpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgRTIgPSBGci5tdWwocjEsIGNoYWxsZW5nZXMucXVvdGllbnQxKTtcbiAgICBsZXQgRTMgPSBGci5tdWwocjIsIGNoYWxsZW5nZXMucXVvdGllbnQyKTtcblxuICAgIHJldHVybiBHMS50aW1lc0ZyKEcxLm9uZSwgRnIuYWRkKHIwLCBGci5hZGQoRTIsIEUzKSkpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSihjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuXG4gICAgcmV0dXJuIEcxLnRpbWVzRnIocHJvb2YucG9seW5vbWlhbHMuVzEsIGNoYWxsZW5nZXMudGVtcCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGlzVmFsaWRQYWlyaW5nKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmssIEYsIEUsIEopIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuXG4gICAgbGV0IEExID0gRzEudGltZXNGcihwcm9vZi5wb2x5bm9taWFscy5XMiwgY2hhbGxlbmdlcy55KTtcbiAgICBBMSA9IEcxLmFkZChHMS5zdWIoRzEuc3ViKEYsIEUpLCBKKSwgQTEpO1xuICAgIGNvbnN0IEEyID0gY3VydmUuRzIub25lO1xuXG4gICAgY29uc3QgQjEgPSBwcm9vZi5wb2x5bm9taWFscy5XMjtcbiAgICBjb25zdCBCMiA9IHZrLlhfMjtcblxuICAgIHJldHVybiBhd2FpdCBjdXJ2ZS5wYWlyaW5nRXEoRzEubmVnKEExKSwgQTIsIEIxLCBCMik7XG59XG5cblxuZnVuY3Rpb24gY29tcHV0ZUxhZ3JhbmdlTGlTaShyb290cywgeCwgeGksIGN1cnZlKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCBsZW4gPSByb290cy5sZW5ndGg7XG5cbiAgICBjb25zdCBudW0gPSBGci5zdWIoRnIuZXhwKHgsIGxlbiksIHhpKTtcbiAgICBjb25zdCBkZW4xID0gRnIubXVsKEZyLmUobGVuKSwgRnIuZXhwKHJvb3RzWzBdLCBsZW4gLSAyKSk7XG5cbiAgICBjb25zdCBMaSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWygobGVuIC0gMSkgKiBpKSAlIGxlbl07XG4gICAgICAgIGNvbnN0IGRlbjMgPSBGci5zdWIoeCwgcm9vdHNbaV0pO1xuXG4gICAgICAgIExpW2ldID0gRnIuZGl2KG51bSwgRnIubXVsKEZyLm11bChkZW4xLCBkZW4yKSwgZGVuMykpO1xuICAgIH1cblxuICAgIHJldHVybiBMaTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUxhZ3JhbmdlTGlTMihyb290cywgdmFsdWUsIHhpMCwgeGkxLCBjdXJ2ZSkge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBMaSA9IFtdO1xuXG4gICAgY29uc3QgbGVuID0gcm9vdHNbMF0ubGVuZ3RoO1xuICAgIGNvbnN0IG4gPSBsZW4gKiByb290cy5sZW5ndGg7XG5cbiAgICBjb25zdCBudW0xID0gRnIuZXhwKHZhbHVlLCBuKTtcbiAgICBjb25zdCBudW0yID0gRnIubXVsKEZyLmFkZCh4aTAsIHhpMSksIEZyLmV4cCh2YWx1ZSwgbGVuKSk7XG4gICAgY29uc3QgbnVtMyA9IEZyLm11bCh4aTAsIHhpMSk7XG4gICAgY29uc3QgbnVtID0gRnIuYWRkKEZyLnN1YihudW0xLCBudW0yKSwgbnVtMyk7XG5cbiAgICBsZXQgZGVuMSA9IEZyLm11bChGci5tdWwoRnIuZShsZW4pLCByb290c1swXVswXSksIEZyLnN1Yih4aTAsIHhpMSkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWzBdWyhsZW4gLSAxKSAqIGkgJSBsZW5dO1xuICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHZhbHVlLCByb290c1swXVtpXSk7XG5cbiAgICAgICAgY29uc3QgZGVuID0gRnIubXVsKGRlbjEsRnIubXVsKGRlbjIsIGRlbjMpKTtcblxuICAgICAgICBMaVtpXSA9IEZyLmRpdihudW0sIGRlbik7XG4gICAgfVxuXG4gICAgZGVuMSA9IEZyLm11bChGci5tdWwoRnIuZShsZW4pLCByb290c1sxXVswXSksIEZyLnN1Yih4aTEsIHhpMCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWzFdWyhsZW4gLSAxKSAqIGkgJSBsZW5dO1xuICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHZhbHVlLCByb290c1sxXVtpXSk7XG5cbiAgICAgICAgY29uc3QgZGVuID0gRnIubXVsKGRlbjEsRnIubXVsKGRlbjIsIGRlbjMpKTtcblxuICAgICAgICBMaVtpICsgbGVuXSA9IEZyLmRpdihudW0sIGRlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIExpO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDIxIDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5mdW5jdGlvbiBwMjU2KG4pIHtcbiAgICBsZXQgbnN0ciA9IG4udG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChuc3RyLmxlbmd0aCA8IDY0KSBuc3RyID0gXCIwXCIgKyBuc3RyO1xuICAgIG5zdHIgPSBgMHgke25zdHJ9YDtcbiAgICByZXR1cm4gbnN0cjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmZsb25rRXhwb3J0Q2FsbERhdGEoX3B1YiwgX3Byb29mKSB7XG4gICAgY29uc3QgcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3Byb29mKTtcbiAgICBjb25zdCBwdWIgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3B1Yik7XG5cbiAgICBhd2FpdCBnZXRDdXJ2ZUZyb21OYW1lKHByb29mLmN1cnZlKTtcblxuICAgIGxldCBpbnB1dHMgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHViLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbnB1dHMgIT09IFwiXCIpIGlucHV0cyA9IGlucHV0cyArIFwiLFwiO1xuICAgICAgICBpbnB1dHMgPSBpbnB1dHMgKyBwMjU2KHB1YltpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBbJHtwMjU2KHByb29mLnBvbHlub21pYWxzLkMxWzBdKX0sICR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5DMVsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YucG9seW5vbWlhbHMuQzJbMF0pfSwke3AyNTYocHJvb2YucG9seW5vbWlhbHMuQzJbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLnBvbHlub21pYWxzLlcxWzBdKX0sJHtwMjU2KHByb29mLnBvbHlub21pYWxzLlcxWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5XMlswXSl9LCR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5XMlsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMucWwpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMucXIpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMucW0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnFvKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnFjKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnMxKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5zMil9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5zMyl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5hKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5iKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLmMpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMueil9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuencpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMudDF3KX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnQydyl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuaW52KX1dLGAgK1xuICAgIGBbJHtpbnB1dHN9XWA7XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbnZhciBmZmxvbmsgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHNldHVwOiBmZmxvbmtTZXR1cCxcbiAgICBwcm92ZTogZmZsb25rUHJvdmUsXG4gICAgZnVsbFByb3ZlOiBmZmxvbmtGdWxsUHJvdmUsXG4gICAgdmVyaWZ5OiBmZmxvbmtWZXJpZnksXG4gICAgZXhwb3J0U29saWRpdHlWZXJpZmllcjogZmZsb25rRXhwb3J0U29saWRpdHlWZXJpZmllcixcbiAgICBleHBvcnRTb2xpZGl0eUNhbGxEYXRhOiBmZmxvbmtFeHBvcnRDYWxsRGF0YVxufSk7XG5cbmV4cG9ydCB7IGN1cnZlcywgZmZsb25rLCBncm90aDE2LCBwbG9uaywgcG93ZXJzb2Z0YXUgYXMgcG93ZXJzT2ZUYXUsIHIxY3MsIHd0bnMsIHprZXkgYXMgektleSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/snarkjs/build/browser.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/snarkjs/node_modules/ffjavascript/build/browser.esm.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/snarkjs/node_modules/ffjavascript/build/browser.esm.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigBuffer: () => (/* binding */ BigBuffer),\n/* harmony export */   ChaCha: () => (/* binding */ ChaCha),\n/* harmony export */   EC: () => (/* binding */ EC),\n/* harmony export */   F1Field: () => (/* binding */ ZqField),\n/* harmony export */   F2Field: () => (/* binding */ F2Field),\n/* harmony export */   F3Field: () => (/* binding */ F3Field),\n/* harmony export */   PolField: () => (/* binding */ PolField),\n/* harmony export */   Scalar: () => (/* binding */ Scalar),\n/* harmony export */   ZqField: () => (/* binding */ ZqField),\n/* harmony export */   buildBls12381: () => (/* binding */ buildBls12381),\n/* harmony export */   buildBn128: () => (/* binding */ buildBn128),\n/* harmony export */   getCurveFromName: () => (/* binding */ getCurveFromName),\n/* harmony export */   getCurveFromQ: () => (/* binding */ getCurveFromQ),\n/* harmony export */   getCurveFromR: () => (/* binding */ getCurveFromR),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/* global BigInt */\nconst hexLen = [ 0, 1, 2, 2, 3, 3, 3, 3, 4 ,4 ,4 ,4 ,4 ,4 ,4 ,4];\n\nfunction fromString(s, radix) {\n    if ((!radix)||(radix==10)) {\n        return BigInt(s);\n    } else if (radix==16) {\n        if (s.slice(0,2) == \"0x\") {\n            return BigInt(s);\n        } else {\n            return BigInt(\"0x\"+s);\n        }\n    }\n}\n\nconst e = fromString;\n\nfunction fromArray(a, radix) {\n    let acc =BigInt(0);\n    radix = BigInt(radix);\n    for (let i=0; i<a.length; i++) {\n        acc = acc*radix + BigInt(a[i]);\n    }\n    return acc;\n}\n\nfunction bitLength$6(a) {\n    const aS =a.toString(16);\n    return (aS.length-1)*4 +hexLen[parseInt(aS[0], 16)];\n}\n\nfunction isNegative$4(a) {\n    return BigInt(a) < BigInt(0);\n}\n\nfunction isZero$1(a) {\n    return !a;\n}\n\nfunction shiftLeft(a, n) {\n    return BigInt(a) << BigInt(n);\n}\n\nfunction shiftRight(a, n) {\n    return BigInt(a) >> BigInt(n);\n}\n\nconst shl = shiftLeft;\nconst shr = shiftRight;\n\nfunction isOdd$5(a) {\n    return (BigInt(a) & BigInt(1)) == BigInt(1);\n}\n\n\nfunction naf(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            const z = 2 - Number(E % BigInt(4));\n            res.push( z );\n            E = E - BigInt(z);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\n\nfunction bits(n) {\n    let E = BigInt(n);\n    const res = [];\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        } else {\n            res.push( 0 );\n        }\n        E = E >> BigInt(1);\n    }\n    return res;\n}\n\nfunction toNumber$1(s) {\n    if (s>BigInt(Number.MAX_SAFE_INTEGER )) {\n        throw new Error(\"Number too big\");\n    }\n    return Number(s);\n}\n\nfunction toArray(s, radix) {\n    const res = [];\n    let rem = BigInt(s);\n    radix = BigInt(radix);\n    while (rem) {\n        res.unshift( Number(rem % radix));\n        rem = rem / radix;\n    }\n    return res;\n}\n\n\nfunction add(a, b) {\n    return BigInt(a) + BigInt(b);\n}\n\nfunction sub(a, b) {\n    return BigInt(a) - BigInt(b);\n}\n\nfunction neg(a) {\n    return -BigInt(a);\n}\n\nfunction mul(a, b) {\n    return BigInt(a) * BigInt(b);\n}\n\nfunction square$2(a) {\n    return BigInt(a) * BigInt(a);\n}\n\nfunction pow(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nfunction exp$1(a, b) {\n    return BigInt(a) ** BigInt(b);\n}\n\nfunction abs$1(a) {\n    return BigInt(a) >= 0 ? BigInt(a) : -BigInt(a);\n}\n\nfunction div(a, b) {\n    return BigInt(a) / BigInt(b);\n}\n\nfunction mod(a, b) {\n    return BigInt(a) % BigInt(b);\n}\n\nfunction eq(a, b) {\n    return BigInt(a) == BigInt(b);\n}\n\nfunction neq(a, b) {\n    return BigInt(a) != BigInt(b);\n}\n\nfunction lt(a, b) {\n    return BigInt(a) < BigInt(b);\n}\n\nfunction gt(a, b) {\n    return BigInt(a) > BigInt(b);\n}\n\nfunction leq(a, b) {\n    return BigInt(a) <= BigInt(b);\n}\n\nfunction geq(a, b) {\n    return BigInt(a) >= BigInt(b);\n}\n\nfunction band(a, b) {\n    return BigInt(a) & BigInt(b);\n}\n\nfunction bor(a, b) {\n    return BigInt(a) | BigInt(b);\n}\n\nfunction bxor(a, b) {\n    return BigInt(a) ^ BigInt(b);\n}\n\nfunction land(a, b) {\n    return BigInt(a) && BigInt(b);\n}\n\nfunction lor(a, b) {\n    return BigInt(a) || BigInt(b);\n}\n\nfunction lnot(a) {\n    return !BigInt(a);\n}\n\n// Returns a buffer with Little Endian Representation\nfunction toRprLE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v[i] = parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16);\n    for (let i=l; i<v.length; i++) v[i] = 0;\n    for (let i=v.length*4; i<n8; i++) buff[i] = toNumber$1(band(shiftRight(e, i*8), 0xFF));\n}\n\n// Returns a buffer with Big Endian Representation\nfunction toRprBE(buff, o, e, n8) {\n    const s = \"0000000\" + e.toString(16);\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const l = (((s.length-7)*4 - 1) >> 5)+1;    // Number of 32bit words;\n    for (let i=0; i<l; i++) v.setUint32(n8-i*4 -4, parseInt(s.substring(s.length-8*i-8, s.length-8*i), 16), false);\n    for (let i=0; i<n8/4-l; i++) v[i] = 0;\n}\n\n// Pases a buffer with Little Endian Representation\nfunction fromRprLE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8/4);\n    const a = new Array(n8/4);\n    v.forEach( (ch,i) => a[a.length-i-1] = ch.toString(16).padStart(8,\"0\") );\n    return fromString(a.join(\"\"), 16);\n}\n\n// Pases a buffer with Big Endian Representation\nfunction fromRprBE(buff, o, n8) {\n    n8 = n8 || buff.byteLength;\n    o = o || 0;\n    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);\n    const a = new Array(n8/4);\n    for (let i=0; i<n8/4; i++) {\n        a[i] = v.getUint32(i*4, false).toString(16).padStart(8, \"0\");\n    }\n    return fromString(a.join(\"\"), 16);\n}\n\nfunction toString(a, radix) {\n    return a.toString(radix);\n}\n\nfunction toLEBuff(a) {\n    const buff = new Uint8Array(Math.floor((bitLength$6(a) - 1) / 8) +1);\n    toRprLE(buff, 0, a, buff.byteLength);\n    return buff;\n}\n\nconst zero = e(0);\nconst one = e(1);\n\nvar _Scalar = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    abs: abs$1,\n    add: add,\n    band: band,\n    bitLength: bitLength$6,\n    bits: bits,\n    bor: bor,\n    bxor: bxor,\n    div: div,\n    e: e,\n    eq: eq,\n    exp: exp$1,\n    fromArray: fromArray,\n    fromRprBE: fromRprBE,\n    fromRprLE: fromRprLE,\n    fromString: fromString,\n    geq: geq,\n    gt: gt,\n    isNegative: isNegative$4,\n    isOdd: isOdd$5,\n    isZero: isZero$1,\n    land: land,\n    leq: leq,\n    lnot: lnot,\n    lor: lor,\n    lt: lt,\n    mod: mod,\n    mul: mul,\n    naf: naf,\n    neg: neg,\n    neq: neq,\n    one: one,\n    pow: pow,\n    shiftLeft: shiftLeft,\n    shiftRight: shiftRight,\n    shl: shl,\n    shr: shr,\n    square: square$2,\n    sub: sub,\n    toArray: toArray,\n    toLEBuff: toLEBuff,\n    toNumber: toNumber$1,\n    toRprBE: toRprBE,\n    toRprLE: toRprLE,\n    toString: toString,\n    zero: zero\n});\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nclass PolField {\n    constructor (F) {\n        this.F = F;\n\n        let rem = F.sqrt_t;\n        let s = F.sqrt_s;\n\n        const five = this.F.add(this.F.add(this.F.two, this.F.two), this.F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(five, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n/*        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n    */\n        this._setRoots(15);\n    }\n\n    _setRoots(n) {\n        if (n > this.F.sqrt_s) n = this.s;\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n            this.roots[i] = rootsi;\n        }\n    }\n\n    add(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.add(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        const m = Math.max(a.length, b.length);\n        const res = new Array(m);\n        for (let i=0; i<m; i++) {\n            res[i] = this.F.sub(a[i] || this.F.zero, b[i] || this.F.zero);\n        }\n        return this.reduce(res);\n    }\n\n    mulScalar(p, b) {\n        if (this.F.eq(b, this.F.zero)) return [];\n        if (this.F.eq(b, this.F.one)) return p;\n        const res = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.mul(p[i], b);\n        }\n        return res;\n    }\n\n\n\n    mul(a, b) {\n        if (a.length == 0) return [];\n        if (b.length == 0) return [];\n        if (a.length == 1) return this.mulScalar(b, a[0]);\n        if (b.length == 1) return this.mulScalar(a, b[0]);\n\n        if (b.length > a.length) {\n            [b, a] = [a, b];\n        }\n\n        if ((b.length <= 2) || (b.length < log2$2(a.length))) {\n            return this.mulNormal(a,b);\n        } else {\n            return this.mulFFT(a,b);\n        }\n    }\n\n    mulNormal(a, b) {\n        let res = [];\n        for (let i=0; i<b.length; i++) {\n            res = this.add(res, this.scaleX(this.mulScalar(a, b[i]), i) );\n        }\n        return res;\n    }\n\n    mulFFT(a,b) {\n        const longestN = Math.max(a.length, b.length);\n        const bitsResult = log2$2(longestN-1)+2;\n        this._setRoots(bitsResult);\n\n        const m = 1 << bitsResult;\n        const ea = this.extend(a,m);\n        const eb = this.extend(b,m);\n\n        const ta = __fft$1(this, ea, bitsResult, 0, 1);\n        const tb = __fft$1(this, eb, bitsResult, 0, 1);\n\n        const tres = new Array(m);\n\n        for (let i=0; i<m; i++) {\n            tres[i] = this.F.mul(ta[i], tb[i]);\n        }\n\n        const res = __fft$1(this, tres, bitsResult, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return this.reduce(resn);\n    }\n\n\n\n    square(a) {\n        return this.mul(a,a);\n    }\n\n    scaleX(p, n) {\n        if (n==0) {\n            return p;\n        } else if (n>0) {\n            const z = new Array(n).fill(this.F.zero);\n            return z.concat(p);\n        } else {\n            if (-n >= p.length) return [];\n            return p.slice(-n);\n        }\n    }\n\n    eval2(p, x) {\n        let v = this.F.zero;\n        let ix = this.F.one;\n        for (let i=0; i<p.length; i++) {\n            v = this.F.add(v, this.F.mul(p[i], ix));\n            ix = this.F.mul(ix, x);\n        }\n        return v;\n    }\n\n    evaluate(p,x) {\n        const F = this.F;\n        if (p.length == 0) return F.zero;\n        const m = this._next2Power(p.length);\n        const ep = this.extend(p, m);\n\n        return _eval(ep, x, 0, 1, m);\n\n        function _eval(p, x, offset, step, n) {\n            if (n==1) return p[offset];\n            const newX = F.square(x);\n            const res= F.add(\n                _eval(p, newX, offset, step << 1, n >> 1),\n                F.mul(\n                    x,\n                    _eval(p, newX, offset+step , step << 1, n >> 1)));\n            return res;\n        }\n    }\n\n    lagrange(points) {\n        let roots = [this.F.one];\n        for (let i=0; i<points.length; i++) {\n            roots = this.mul(roots, [this.F.neg(points[i][0]), this.F.one]);\n        }\n\n        let sum = [];\n        for (let i=0; i<points.length; i++) {\n            let mpol = this.ruffini(roots, points[i][0]);\n            const factor =\n                this.F.mul(\n                    this.F.inv(this.evaluate(mpol, points[i][0])),\n                    points[i][1]);\n            mpol = this.mulScalar(mpol, factor);\n            sum = this.add(sum, mpol);\n        }\n        return sum;\n    }\n\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2$2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res = __fft$1(this, ep, bits, 0, 1);\n        return res;\n    }\n\n    fft2(p) {\n        if (p.length <= 1) return p;\n        const bits = log2$2(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res = __fft2(this, ep, bits);\n        return res;\n    }\n\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2$2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        const res =  __fft$1(this, ep, bits, 0, 1);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n\n    ifft2(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2$2(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        const ep = this.extend(p, m);\n        __bitReverse(ep, bits);\n        const res =  __fft2(this, ep, bits);\n\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.F.mul(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n\n    }\n\n    _fft(pall, bits, offset, step) {\n\n        const n = 1 << bits;\n        if (n==1) {\n            return [ pall[offset] ];\n        }\n\n        const ndiv2 = n >> 1;\n        const p1 = this._fft(pall, bits-1, offset, step*2);\n        const p2 = this._fft(pall, bits-1, offset+step, step*2);\n\n        const out = new Array(n);\n\n        let m= this.F.one;\n        for (let i=0; i<ndiv2; i++) {\n            out[i] = this.F.add(p1[i], this.F.mul(m, p2[i]));\n            out[i+ndiv2] = this.F.sub(p1[i], this.F.mul(m, p2[i]));\n            m = this.F.mul(m, this.w[bits]);\n        }\n\n        return out;\n    }\n\n    extend(p, e) {\n        if (e == p.length) return p;\n        const z = new Array(e-p.length).fill(this.F.zero);\n\n        return p.concat(z);\n    }\n\n    reduce(p) {\n        if (p.length == 0) return p;\n        if (! this.F.eq(p[p.length-1], this.F.zero) ) return p;\n        let i=p.length-1;\n        while( i>0 && this.F.eq(p[i], this.F.zero) ) i--;\n        return p.slice(0, i+1);\n    }\n\n    eq(a, b) {\n        const pa = this.reduce(a);\n        const pb = this.reduce(b);\n\n        if (pa.length != pb.length) return false;\n        for (let i=0; i<pb.length; i++) {\n            if (!this.F.eq(pa[i], pb[i])) return false;\n        }\n\n        return true;\n    }\n\n    ruffini(p, r) {\n        const res = new Array(p.length-1);\n        res[res.length-1] = p[p.length-1];\n        for (let i = res.length-2; i>=0; i--) {\n            res[i] = this.F.add(this.F.mul(res[i+1], r), p[i+1]);\n        }\n        return res;\n    }\n\n    _next2Power(v) {\n        v--;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v++;\n        return v;\n    }\n\n    toString(p) {\n        const ap = this.normalize(p);\n        let S = \"\";\n        for (let i=ap.length-1; i>=0; i--) {\n            if (!this.F.eq(p[i], this.F.zero)) {\n                if (S!=\"\") S += \" + \";\n                S = S + p[i].toString(10);\n                if (i>0) {\n                    S = S + \"x\";\n                    if (i>1) {\n                        S = S + \"^\" +i;\n                    }\n                }\n            }\n        }\n        return S;\n    }\n\n    normalize(p) {\n        const res  = new Array(p.length);\n        for (let i=0; i<p.length; i++) {\n            res[i] = this.F.normalize(p[i]);\n        }\n        return res;\n    }\n\n\n    _reciprocal(p, bits) {\n        const k = 1 << bits;\n        if (k==1) {\n            return [ this.F.inv(p[0]) ];\n        }\n        const np = this.scaleX(p, -k/2);\n        const q = this._reciprocal(np, bits-1);\n        const a = this.scaleX(this.double(q), 3*k/2-2);\n        const b = this.mul( this.square(q), p);\n\n        return this.scaleX(this.sub(a,b),   -(k-2));\n    }\n\n    // divides x^m / v\n    _div2(m, v) {\n        const kbits = log2$2(v.length-1)+1;\n        const k = 1 << kbits;\n\n        const scaleV = k - v.length;\n\n        // rec = x^(k - 2) / v* x^scaleV =>\n        // rec = x^(k-2-scaleV)/ v\n        //\n        // res = x^m/v = x^(m + (2*k-2 - scaleV) - (2*k-2 - scaleV)) /v =>\n        // res = rec * x^(m - (2*k-2 - scaleV)) =>\n        // res = rec * x^(m - 2*k + 2 + scaleV)\n\n        const rec = this._reciprocal(this.scaleX(v, scaleV), kbits);\n        const res = this.scaleX(rec, m - 2*k + 2 + scaleV);\n\n        return res;\n    }\n\n    div(_u, _v) {\n        if (_u.length < _v.length) return [];\n        const kbits = log2$2(_v.length-1)+1;\n        const k = 1 << kbits;\n\n        const u = this.scaleX(_u, k-_v.length);\n        const v = this.scaleX(_v, k-_v.length);\n\n        const n = v.length-1;\n        let m = u.length-1;\n\n        const s = this._reciprocal(v, kbits);\n        let t;\n        if (m>2*n) {\n            t = this.sub(this.scaleX([this.F.one], 2*n), this.mul(s, v));\n        }\n\n        let q = [];\n        let rem = u;\n        let us, ut;\n        let finish = false;\n\n        while (!finish) {\n            us = this.mul(rem, s);\n            q = this.add(q, this.scaleX(us, -2*n));\n\n            if ( m > 2*n ) {\n                ut = this.mul(rem, t);\n                rem = this.scaleX(ut, -2*n);\n                m = rem.length-1;\n            } else {\n                finish = true;\n            }\n        }\n\n        return q;\n    }\n\n\n    // returns the ith nth-root of one\n    oneRoot(n, i) {\n        let nbits = log2$2(n-1)+1;\n        let res = this.F.one;\n        let r = i;\n\n        if(i>=n) {\n            throw new Error(\"Given 'i' should be lower than 'n'\");\n        }\n        else if (1<<nbits !== n) {\n            throw new Error(`Internal errlr: ${n} should equal ${1<<nbits}`);\n        }\n\n        while (r>0) {\n            if (r & 1 == 1) {\n                res = this.F.mul(res, this.w[nbits]);\n            }\n            r = r >> 1;\n            nbits --;\n        }\n        return res;\n    }\n\n    computeVanishingPolinomial(bits, t) {\n        const m = 1 << bits;\n        return this.F.sub(this.F.pow(t, m), this.F.one);\n    }\n\n    evaluateLagrangePolynomials(bits, t) {\n        const m= 1 << bits;\n        const tm = this.F.pow(t, m);\n        const u= new Array(m).fill(this.F.zero);\n        this._setRoots(bits);\n        const omega = this.w[bits];\n\n        if (this.F.eq(tm, this.F.one)) {\n            for (let i = 0; i < m; i++) {\n                if (this.F.eq(this.roots[bits][0],t)) { // i.e., t equals omega^i\n                    u[i] = this.F.one;\n                    return u;\n                }\n            }\n        }\n\n        const z = this.F.sub(tm, this.F.one);\n        //        let l = this.F.mul(z,  this.F.pow(this.F.twoinv, m));\n        let l = this.F.mul(z,  this.F.inv(this.F.e(m)));\n        for (let i = 0; i < m; i++) {\n            u[i] = this.F.mul(l, this.F.inv(this.F.sub(t,this.roots[bits][i])));\n            l = this.F.mul(l, omega);\n        }\n\n        return u;\n    }\n\n    log2(V) {\n        return log2$2(V);\n    }\n}\n\nfunction log2$2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft$1(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.F.add(pall[offset], pall[offset + step]),\n            PF.F.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft$1(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft$1(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\n\nfunction __fft2(PF, pall, bits) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[0] ];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft2(PF, pall.slice(0, ndiv2), bits-1);\n    const p2 = __fft2(PF, pall.slice(ndiv2), bits-1);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.F.add(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n        out[i+ndiv2] = PF.F.sub(p1[i], PF.F.mul(PF.roots[bits][i], p2[i]));\n    }\n\n    return out;\n}\n\nconst _revTable$1 = [];\nfor (let i=0; i<256; i++) {\n    _revTable$1[i] = _revSlow$1(i, 8);\n}\n\nfunction _revSlow$1(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction rev(idx, bits) {\n    return (\n        _revTable$1[idx >>> 24] |\n        (_revTable$1[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable$1[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable$1[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\nfunction __bitReverse(p, bits) {\n    for (let k=0; k<p.length; k++) {\n        const r = rev(k, bits);\n        if (r>k) {\n            const tmp= p[k];\n            p[k] = p[r];\n            p[r] = tmp;\n        }\n    }\n\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nfunction mulScalar(F, base, e) {\n    let res;\n\n    if (isZero$1(e)) return F.zero;\n\n    const n = naf(e);\n\n    if (n[n.length-1] == 1) {\n        res = base;\n    } else if (n[n.length-1] == -1) {\n        res = F.neg(base);\n    } else {\n        throw new Error(\"invlaud NAF\");\n    }\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.double(res);\n\n        if (n[i] == 1) {\n            res = F.add(res, base);\n        } else if (n[i] == -1) {\n            res = F.sub(res, base);\n        }\n    }\n\n    return res;\n}\n\n\n/*\nexports.mulScalar = (F, base, e) =>{\n    let res = F.zero;\n    let rem = bigInt(e);\n    let exp = base;\n\n    while (! rem.eq(bigInt.zero)) {\n        if (rem.and(bigInt.one).eq(bigInt.one)) {\n            res = F.add(res, exp);\n        }\n        exp = F.double(exp);\n        rem = rem.shiftRight(1);\n    }\n\n    return res;\n};\n*/\n\n\nfunction exp(F, base, e) {\n\n    if (isZero$1(e)) return F.one;\n\n    const n = bits(e);\n\n    if (n.length==0) return F.one;\n\n    let res = base;\n\n    for (let i=n.length-2; i>=0; i--) {\n\n        res = F.square(res);\n\n        if (n[i]) {\n            res = F.mul(res, base);\n        }\n    }\n\n    return res;\n}\n\n// Check here: https://eprint.iacr.org/2012/685.pdf\n\nfunction buildSqrt (F) {\n    if ((F.m % 2) == 1) {\n        if (eq(mod(F.p, 4), 1 )) {\n            if (eq(mod(F.p, 8), 1 )) {\n                if (eq(mod(F.p, 16), 1 )) {\n                    // alg7_muller(F);\n                    alg5_tonelliShanks(F);\n                } else if (eq(mod(F.p, 16), 9 )) {\n                    alg4_kong(F);\n                } else {\n                    throw new Error(\"Field withot sqrt\");\n                }\n            } else if (eq(mod(F.p, 8), 5 )) {\n                alg3_atkin(F);\n            } else {\n                throw new Error(\"Field withot sqrt\");\n            }\n        } else if (eq(mod(F.p, 4), 3 )) {\n            alg2_shanks(F);\n        }\n    } else {\n        const pm2mod4 = mod(pow(F.p, F.m/2), 4);\n        if (pm2mod4 == 1) {\n            alg10_adj(F);\n        } else if (pm2mod4 == 3) {\n            alg9_adj(F);\n        } else {\n            alg8_complex(F);\n        }\n\n    }\n}\n\n\nfunction alg5_tonelliShanks(F) {\n    F.sqrt_q = pow(F.p, F.m);\n\n    F.sqrt_s = 0;\n    F.sqrt_t = sub(F.sqrt_q, 1);\n\n    while (!isOdd$5(F.sqrt_t)) {\n        F.sqrt_s = F.sqrt_s + 1;\n        F.sqrt_t = div(F.sqrt_t, 2);\n    }\n\n    let c0 = F.one;\n\n    while (F.eq(c0, F.one)) {\n        const c = F.random();\n        F.sqrt_z = F.pow(c, F.sqrt_t);\n        c0 = F.pow(F.sqrt_z, 2 ** (F.sqrt_s-1) );\n    }\n\n    F.sqrt_tm1d2 = div(sub(F.sqrt_t, 1),2);\n\n    F.sqrt = function(a) {\n        const F=this;\n        if (F.isZero(a)) return F.zero;\n        let w = F.pow(a, F.sqrt_tm1d2);\n        const a0 = F.pow( F.mul(F.square(w), a), 2 ** (F.sqrt_s-1) );\n        if (F.eq(a0, F.negone)) return null;\n\n        let v = F.sqrt_s;\n        let x = F.mul(a, w);\n        let b = F.mul(x, w);\n        let z = F.sqrt_z;\n        while (!F.eq(b, F.one)) {\n            let b2k = F.square(b);\n            let k=1;\n            while (!F.eq(b2k, F.one)) {\n                b2k = F.square(b2k);\n                k++;\n            }\n\n            w = z;\n            for (let i=0; i<v-k-1; i++) {\n                w = F.square(w);\n            }\n            z = F.square(w);\n            b = F.mul(b, z);\n            x = F.mul(x, w);\n            v = k;\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg4_kong(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 4 not implemented\");\n    };\n}\n\nfunction alg3_atkin(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 3 not implemented\");\n    };\n}\n\nfunction alg2_shanks(F) {\n\n    F.sqrt_q = pow(F.p, F.m);\n    F.sqrt_e1 = div( sub(F.sqrt_q, 3) , 4);\n\n    F.sqrt = function(a) {\n        if (this.isZero(a)) return this.zero;\n\n        // Test that have solution\n        const a1 = this.pow(a, this.sqrt_e1);\n\n        const a0 = this.mul(this.square(a1), a);\n\n        if ( this.eq(a0, this.negone) ) return null;\n\n        const x = this.mul(a1, a);\n\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\nfunction alg10_adj(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 10 not implemented\");\n    };\n}\n\nfunction alg9_adj(F) {\n    F.sqrt_q = pow(F.p, F.m/2);\n    F.sqrt_e34 = div( sub(F.sqrt_q, 3) , 4);\n    F.sqrt_e12 = div( sub(F.sqrt_q, 1) , 2);\n\n    F.frobenius = function(n, x) {\n        if ((n%2) == 1) {\n            return F.conjugate(x);\n        } else {\n            return x;\n        }\n    };\n\n    F.sqrt = function(a) {\n        const F = this;\n        const a1 = F.pow(a, F.sqrt_e34);\n        const alfa = F.mul(F.square(a1), a);\n        const a0 = F.mul(F.frobenius(1, alfa), alfa);\n        if (F.eq(a0, F.negone)) return null;\n        const x0 = F.mul(a1, a);\n        let x;\n        if (F.eq(alfa, F.negone)) {\n            x = F.mul(x0, [F.F.zero, F.F.one]);\n        } else {\n            const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n            x = F.mul(b, x0);\n        }\n        return F.geq(x, F.zero) ? x : F.neg(x);\n    };\n}\n\n\nfunction alg8_complex(F) {\n    F.sqrt = function() {\n        throw new Error(\"Sqrt alg 8 not implemented\");\n    };\n}\n\nfunction quarterRound(st, a, b, c, d) {\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 16) | ((st[d]>>>16) & 0xFFFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 12) | ((st[b]>>>20) & 0xFFF)) >>> 0;\n\n    st[a] = (st[a] + st[b]) >>> 0;\n    st[d] = (st[d] ^ st[a]) >>> 0;\n    st[d] = ((st[d] << 8) | ((st[d]>>>24) & 0xFF)) >>> 0;\n\n    st[c] = (st[c] + st[d]) >>> 0;\n    st[b] = (st[b] ^ st[c]) >>> 0;\n    st[b] = ((st[b] << 7) | ((st[b]>>>25) & 0x7F)) >>> 0;\n}\n\nfunction doubleRound(st) {\n    quarterRound(st, 0, 4, 8,12);\n    quarterRound(st, 1, 5, 9,13);\n    quarterRound(st, 2, 6,10,14);\n    quarterRound(st, 3, 7,11,15);\n\n    quarterRound(st, 0, 5,10,15);\n    quarterRound(st, 1, 6,11,12);\n    quarterRound(st, 2, 7, 8,13);\n    quarterRound(st, 3, 4, 9,14);\n}\n\nclass ChaCha {\n\n    constructor(seed) {\n        seed = seed || [0,0,0,0,0,0,0,0];\n        this.state = [\n            0x61707865,\n            0x3320646E,\n            0x79622D32,\n            0x6B206574,\n            seed[0],\n            seed[1],\n            seed[2],\n            seed[3],\n            seed[4],\n            seed[5],\n            seed[6],\n            seed[7],\n            0,\n            0,\n            0,\n            0\n        ];\n        this.idx = 16;\n        this.buff = new Array(16);\n    }\n\n    nextU32() {\n        if (this.idx == 16) this.update();\n        return this.buff[this.idx++];\n    }\n\n    nextU64() {\n        return add(mul(this.nextU32(), 0x100000000), this.nextU32());\n    }\n\n    nextBool() {\n        return (this.nextU32() & 1) == 1;\n    }\n\n    update() {\n        // Copy the state\n        for (let i=0; i<16; i++) this.buff[i] = this.state[i];\n\n        // Apply the rounds\n        for (let i=0; i<10; i++) doubleRound(this.buff);\n\n        // Add to the initial\n        for (let i=0; i<16; i++) this.buff[i] = (this.buff[i] + this.state[i]) >>> 0;\n\n        this.idx = 0;\n\n        this.state[12] = (this.state[12] + 1) >>> 0;\n        if (this.state[12] != 0) return;\n        this.state[13] = (this.state[13] + 1) >>> 0;\n        if (this.state[13] != 0) return;\n        this.state[14] = (this.state[14] + 1) >>> 0;\n        if (this.state[14] != 0) return;\n        this.state[15] = (this.state[15] + 1) >>> 0;\n    }\n}\n\nfunction getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    { // Browser\n        if (typeof globalThis.crypto !== \"undefined\") { // Supported\n            globalThis.crypto.getRandomValues(array);\n        } else { // fallback\n            for (let i=0; i<n; i++) {\n                array[i] = (Math.random()*4294967296)>>>0;\n            }\n        }\n    }\n    return array;\n}\n\nfunction getRandomSeed() {\n    const arr = getRandomBytes(32);\n    const arrV = new Uint32Array(arr.buffer);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed.push(arrV[i]);\n    }\n    return seed;\n}\n\nlet threadRng = null;\n\nfunction getThreadRng() {\n    if (threadRng) return threadRng;\n    threadRng = new ChaCha(getRandomSeed());\n    return threadRng;\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\n    This library does operations on polynomials with coefficients in a field F.\n\n    A polynomial P(x) = p0 + p1 * x + p2 * x^2 + ... + pn * x^n  is represented\n    by the array [ p0, p1, p2, ... , pn ].\n */\n\nclass FFT {\n    constructor (G, F, opMulGF) {\n        this.F = F;\n        this.G = G;\n        this.opMulGF = opMulGF;\n\n        let rem = F.sqrt_t || F.t;\n        let s = F.sqrt_s || F.s;\n\n        let nqr = F.one;\n        while (F.eq(F.pow(nqr, F.half), F.one)) nqr = F.add(nqr, F.one);\n\n        this.w = new Array(s+1);\n        this.wi = new Array(s+1);\n        this.w[s] = this.F.pow(nqr, rem);\n        this.wi[s] = this.F.inv(this.w[s]);\n\n        let n=s-1;\n        while (n>=0) {\n            this.w[n] = this.F.square(this.w[n+1]);\n            this.wi[n] = this.F.square(this.wi[n+1]);\n            n--;\n        }\n\n\n        this.roots = [];\n        /*\n        for (let i=0; i<16; i++) {\n            let r = this.F.one;\n            n = 1 << i;\n            const rootsi = new Array(n);\n            for (let j=0; j<n; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots.push(rootsi);\n        }\n        */\n        this._setRoots(Math.min(s, 15));\n    }\n\n    _setRoots(n) {\n        for (let i=n; (i>=0) && (!this.roots[i]); i--) {\n            let r = this.F.one;\n            const nroots = 1 << i;\n            const rootsi = new Array(nroots);\n            for (let j=0; j<nroots; j++) {\n                rootsi[j] = r;\n                r = this.F.mul(r, this.w[i]);\n            }\n\n            this.roots[i] = rootsi;\n        }\n    }\n\n    fft(p) {\n        if (p.length <= 1) return p;\n        const bits = log2$1(p.length-1)+1;\n        this._setRoots(bits);\n\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res = __fft(this, p, bits, 0, 1);\n        return res;\n    }\n\n    ifft(p) {\n\n        if (p.length <= 1) return p;\n        const bits = log2$1(p.length-1)+1;\n        this._setRoots(bits);\n        const m = 1 << bits;\n        if (p.length != m) {\n            throw new Error(\"Size must be multiple of 2\");\n        }\n        const res =  __fft(this, p, bits, 0, 1);\n        const twoinvm = this.F.inv( this.F.mulScalar(this.F.one, m) );\n        const resn = new Array(m);\n        for (let i=0; i<m; i++) {\n            resn[i] = this.opMulGF(res[(m-i)%m], twoinvm);\n        }\n\n        return resn;\n    }\n\n\n}\n\nfunction log2$1( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction __fft(PF, pall, bits, offset, step) {\n\n    const n = 1 << bits;\n    if (n==1) {\n        return [ pall[offset] ];\n    } else if (n==2) {\n        return [\n            PF.G.add(pall[offset], pall[offset + step]),\n            PF.G.sub(pall[offset], pall[offset + step])];\n    }\n\n    const ndiv2 = n >> 1;\n    const p1 = __fft(PF, pall, bits-1, offset, step*2);\n    const p2 = __fft(PF, pall, bits-1, offset+step, step*2);\n\n    const out = new Array(n);\n\n    for (let i=0; i<ndiv2; i++) {\n        out[i] = PF.G.add(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n        out[i+ndiv2] = PF.G.sub(p1[i], PF.opMulGF(p2[i], PF.roots[bits][i]));\n    }\n\n    return out;\n}\n\n/* global BigInt */\n\nclass ZqField {\n    constructor(p) {\n        this.type=\"F1\";\n        this.one = BigInt(1);\n        this.zero = BigInt(0);\n        this.p = BigInt(p);\n        this.m = 1;\n        this.negone = this.p-this.one;\n        this.two = BigInt(2);\n        this.half = this.p >> this.one;\n        this.bitLength = bitLength$6(this.p);\n        this.mask = (this.one << BigInt(this.bitLength)) - this.one;\n\n        this.n64 = Math.floor((this.bitLength - 1) / 64)+1;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n        this.R = this.e(this.one << BigInt(this.n64*64));\n        this.Ri = this.inv(this.R);\n\n        const e = this.negone >> this.one;\n        this.nqr = this.two;\n        let r = this.pow(this.nqr, e);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.nqr + this.one;\n            r = this.pow(this.nqr, e);\n        }\n\n\n        this.s = 0;\n        this.t = this.negone;\n\n        while ((this.t & this.one) == this.zero) {\n            this.s = this.s + 1;\n            this.t = this.t >> this.one;\n        }\n\n        this.nqr_to_t = this.pow(this.nqr, this.t);\n\n        buildSqrt(this);\n\n        this.FFT = new FFT(this, this, this.mul.bind(this));\n\n        this.fft = this.FFT.fft.bind(this.FFT);\n        this.ifft = this.FFT.ifft.bind(this.FFT);\n        this.w = this.FFT.w;\n        this.wi = this.FFT.wi; \n    \n        this.shift = this.square(this.nqr);\n        this.k = this.exp(this.nqr, 2**this.s);\n    }\n\n    e(a,b) {\n        let res;\n        if (!b) {\n            res = BigInt(a);\n        } else if (b==16) {\n            res = BigInt(\"0x\"+a);\n        }\n        if (res < 0) {\n            let nres = -res;\n            if (nres >= this.p) nres = nres % this.p;\n            return this.p - nres;\n        } else {\n            return (res>= this.p) ? res%this.p : res;\n        }\n\n    }\n\n    add(a, b) {\n        const res = a + b;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    sub(a, b) {\n        return (a >= b) ? a-b : this.p-b+a;\n    }\n\n    neg(a) {\n        return a ? this.p-a : a;\n    }\n\n    mul(a, b) {\n        return (a*b)%this.p;\n    }\n\n    mulScalar(base, s) {\n        return (base * this.e(s)) % this.p;\n    }\n\n    square(a) {\n        return (a*a) % this.p;\n    }\n\n    eq(a, b) {\n        return a==b;\n    }\n\n    neq(a, b) {\n        return a!=b;\n    }\n\n    lt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa < bb;\n    }\n\n    gt(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa > bb;\n    }\n\n    leq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa <= bb;\n    }\n\n    geq(a, b) {\n        const aa = (a > this.half) ? a - this.p : a;\n        const bb = (b > this.half) ? b - this.p : b;\n        return aa >= bb;\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    idiv(a, b) {\n        if (!b) throw new Error(\"Division by zero\");\n        return a / b;\n    }\n\n    inv(a) {\n        if (!a) throw new Error(\"Division by zero\");\n\n        let t = this.zero;\n        let r = this.p;\n        let newt = this.one;\n        let newr = a % this.p;\n        while (newr) {\n            let q = r/newr;\n            [t, newt] = [newt, t-q*newt];\n            [r, newr] = [newr, r-q*newr];\n        }\n        if (t<this.zero) t += this.p;\n        return t;\n    }\n\n    mod(a, b) {\n        return a % b;\n    }\n\n    pow(b, e) {\n        return exp(this, b, e);\n    }\n\n    exp(b, e) {\n        return exp(this, b, e);\n    }\n\n    band(a, b) {\n        const res =  ((a & b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bor(a, b) {\n        const res =  ((a | b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bxor(a, b) {\n        const res =  ((a ^ b) & this.mask);\n        return res >= this.p ? res-this.p : res;\n    }\n\n    bnot(a) {\n        const res = a ^ this.mask;\n        return res >= this.p ? res-this.p : res;\n    }\n\n    shl(a, b) {\n        if (Number(b) < this.bitLength) {\n            const res = (a << b) & this.mask;\n            return res >= this.p ? res-this.p : res;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                return a >> nb;\n            } else {\n                return this.zero;\n            }\n        }\n    }\n\n    shr(a, b) {\n        if (Number(b) < this.bitLength) {\n            return a >> b;\n        } else {\n            const nb = this.p - b;\n            if (Number(nb) < this.bitLength) {\n                const res = (a << nb) & this.mask;\n                return res >= this.p ? res-this.p : res;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    land(a, b) {\n        return (a && b) ? this.one : this.zero;\n    }\n\n    lor(a, b) {\n        return (a || b) ? this.one : this.zero;\n    }\n\n    lnot(a) {\n        return (a) ? this.zero : this.one;\n    }\n\n    sqrt_old(n) {\n\n        if (n == this.zero) return this.zero;\n\n        // Test that have solution\n        const res = this.pow(n, this.negone >> this.one);\n        if ( res != this.one ) return null;\n\n        let m = this.s;\n        let c = this.nqr_to_t;\n        let t = this.pow(n, this.t);\n        let r = this.pow(n, this.add(this.t, this.one) >> this.one );\n\n        while ( t != this.one ) {\n            let sq = this.square(t);\n            let i = 1;\n            while (sq != this.one ) {\n                i++;\n                sq = this.square(sq);\n            }\n\n            // b = c ^ m-i-1\n            let b = c;\n            for (let j=0; j< m-i-1; j ++) b = this.square(b);\n\n            m = i;\n            c = this.square(b);\n            t = this.mul(t, c);\n            r = this.mul(r, b);\n        }\n\n        if (r > (this.p >> this.one)) {\n            r = this.neg(r);\n        }\n\n        return r;\n    }\n\n    normalize(a, b) {\n        a = BigInt(a,b);\n        if (a < 0) {\n            let na = -a;\n            if (na >= this.p) na = na % this.p;\n            return this.p - na;\n        } else {\n            return (a>= this.p) ? a%this.p : a;\n        }\n    }\n\n    random() {\n        const nBytes = (this.bitLength*2 / 8);\n        let res =this.zero;\n        for (let i=0; i<nBytes; i++) {\n            res = (res << BigInt(8)) + BigInt(getRandomBytes(1)[0]);\n        }\n        return res % this.p;\n    }\n\n    toString(a, base) {\n        base = base || 10;\n        let vs;\n        if ((a > this.half)&&(base == 10)) {\n            const v = this.p-a;\n            vs = \"-\"+v.toString(base);\n        } else {\n            vs = a.toString(base);\n        }\n        return vs;\n    }\n\n    isZero(a) {\n        return a == this.zero;\n    }\n\n    fromRng(rng) {\n        let v;\n        do {\n            v=this.zero;\n            for (let i=0; i<this.n64; i++) {\n                v += rng.nextU64() << BigInt(64 *i);\n            }\n            v &= this.mask;\n        } while (v >= this.p);\n        v = (v * this.Ri) % this.p;   // Convert from montgomery\n        return v;\n    }\n\n    fft(a) {\n        return this.FFT.fft(a);\n    }\n\n    ifft(a) {\n        return this.FFT.ifft(a);\n    }\n\n    // Returns a buffer with Little Endian Representation\n    toRprLE(buff, o, e) {\n        toRprLE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Representation\n    toRprBE(buff, o, e) {\n        toRprBE(buff, o, e, this.n64*8);\n    }\n\n    // Returns a buffer with Big Endian Montgomery Representation\n    toRprBEM(buff, o, e) {\n        return this.toRprBE(buff, o, this.mul(this.R, e));\n    }\n\n    toRprLEM(buff, o, e) {\n        return this.toRprLE(buff, o, this.mul(this.R, e));\n    }\n\n\n    // Pases a buffer with Little Endian Representation\n    fromRprLE(buff, o) {\n        return fromRprLE(buff, o, this.n8);\n    }\n\n    // Pases a buffer with Big Endian Representation\n    fromRprBE(buff, o) {\n        return fromRprBE(buff, o, this.n8);\n    }\n\n    fromRprLEM(buff, o) {\n        return this.mul(this.fromRprLE(buff, o), this.Ri);\n    }\n\n    fromRprBEM(buff, o) {\n        return this.mul(this.fromRprBE(buff, o), this.Ri);\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nclass F2Field {\n    constructor(F, nonResidue) {\n        this.type=\"F2\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*2;\n        this.p = F.p;\n        this.n64 = F.n64*2;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n\n        buildSqrt(this);\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    conjugate(a) {\n        return [\n            a[0],\n            this.F.neg(a[1])\n        ];\n    }\n\n    mul(a, b) {\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n\n        return [\n            this.F.add( aA , this._mulByNonResidue(bB)),\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]),\n                    this.F.add(b[0], b[1])),\n                this.F.add(aA, bB))];\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);\n        const t1 = this.F.square(a[1]);\n        const t2 = this.F.sub(t0, this._mulByNonResidue(t1));\n        const t3 = this.F.inv(t2);\n        return [\n            this.F.mul(a[0], t3),\n            this.F.neg(this.F.mul( a[1], t3)) ];\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const ab = this.F.mul(a[0] , a[1]);\n\n        /*\n        [\n            (a + b) * (a + non_residue * b) - ab - non_residue * ab,\n            ab + ab\n        ];\n        */\n\n        return [\n            this.F.sub(\n                this.F.mul(\n                    this.F.add(a[0], a[1]) ,\n                    this.F.add(\n                        a[0] ,\n                        this._mulByNonResidue(a[1]))),\n                this.F.add(\n                    ab,\n                    this._mulByNonResidue(ab))),\n            this.F.add(ab, ab)\n        ];\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]);\n    }\n\n    mulScalar(base, e) {\n        return mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        return [c0, c1];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        return false;\n    }\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBE(buff, o);\n        const c0 = this.F.fromRprBE(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c1 = this.F.fromRprBEM(buff, o);\n        const c0 = this.F.fromRprBEM(buff, o+this.F.n8);\n        return [c0, c1];\n    }\n\n    toObject(a) {\n        return a;\n    }\n\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nclass F3Field {\n    constructor(F, nonResidue) {\n        this.type=\"F3\";\n        this.F = F;\n        this.zero = [this.F.zero, this.F.zero, this.F.zero];\n        this.one = [this.F.one, this.F.zero, this.F.zero];\n        this.negone = this.neg(this.one);\n        this.nonResidue = nonResidue;\n        this.m = F.m*3;\n        this.p = F.p;\n        this.n64 = F.n64*3;\n        this.n32 = this.n64*2;\n        this.n8 = this.n64*8;\n    }\n\n    _mulByNonResidue(a) {\n        return this.F.mul(this.nonResidue, a);\n    }\n\n    copy(a) {\n        return [this.F.copy(a[0]), this.F.copy(a[1]), this.F.copy(a[2])];\n    }\n\n    add(a, b) {\n        return [\n            this.F.add(a[0], b[0]),\n            this.F.add(a[1], b[1]),\n            this.F.add(a[2], b[2])\n        ];\n    }\n\n    double(a) {\n        return this.add(a,a);\n    }\n\n    sub(a, b) {\n        return [\n            this.F.sub(a[0], b[0]),\n            this.F.sub(a[1], b[1]),\n            this.F.sub(a[2], b[2])\n        ];\n    }\n\n    neg(a) {\n        return this.sub(this.zero, a);\n    }\n\n    mul(a, b) {\n\n        const aA = this.F.mul(a[0] , b[0]);\n        const bB = this.F.mul(a[1] , b[1]);\n        const cC = this.F.mul(a[2] , b[2]);\n\n        return [\n            this.F.add(\n                aA,\n                this._mulByNonResidue(\n                    this.F.sub(\n                        this.F.mul(\n                            this.F.add(a[1], a[2]),\n                            this.F.add(b[1], b[2])),\n                        this.F.add(bB, cC)))),    // aA + non_residue*((b+c)*(B+C)-bB-cC),\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[1]),\n                        this.F.add(b[0], b[1])),\n                    this.F.add(aA, bB)),\n                this._mulByNonResidue( cC)),   // (a+b)*(A+B)-aA-bB+non_residue*cC\n\n            this.F.add(\n                this.F.sub(\n                    this.F.mul(\n                        this.F.add(a[0], a[2]),\n                        this.F.add(b[0], b[2])),\n                    this.F.add(aA, cC)),\n                bB)];                           // (a+c)*(A+C)-aA+bB-cC)\n    }\n\n    inv(a) {\n        const t0 = this.F.square(a[0]);             // t0 = a^2 ;\n        const t1 = this.F.square(a[1]);             // t1 = b^2 ;\n        const t2 = this.F.square(a[2]);             // t2 = c^2;\n        const t3 = this.F.mul(a[0],a[1]);           // t3 = ab\n        const t4 = this.F.mul(a[0],a[2]);           // t4 = ac\n        const t5 = this.F.mul(a[1],a[2]);           // t5 = bc;\n        // c0 = t0 - non_residue * t5;\n        const c0 = this.F.sub(t0, this._mulByNonResidue(t5));\n        // c1 = non_residue * t2 - t3;\n        const c1 = this.F.sub(this._mulByNonResidue(t2), t3);\n        const c2 = this.F.sub(t1, t4);              // c2 = t1-t4\n\n        // t6 = (a * c0 + non_residue * (c * c1 + b * c2)).inv();\n        const t6 =\n            this.F.inv(\n                this.F.add(\n                    this.F.mul(a[0], c0),\n                    this._mulByNonResidue(\n                        this.F.add(\n                            this.F.mul(a[2], c1),\n                            this.F.mul(a[1], c2)))));\n\n        return [\n            this.F.mul(t6, c0),         // t6*c0\n            this.F.mul(t6, c1),         // t6*c1\n            this.F.mul(t6, c2)];        // t6*c2\n    }\n\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n\n    square(a) {\n        const s0 = this.F.square(a[0]);                   // s0 = a^2\n        const ab = this.F.mul(a[0], a[1]);                // ab = a*b\n        const s1 = this.F.add(ab, ab);                    // s1 = 2ab;\n        const s2 = this.F.square(\n            this.F.add(this.F.sub(a[0],a[1]), a[2]));     // s2 = (a - b + c)^2;\n        const bc = this.F.mul(a[1],a[2]);                 // bc = b*c\n        const s3 = this.F.add(bc, bc);                    // s3 = 2*bc\n        const s4 = this.F.square(a[2]);                   // s4 = c^2\n\n\n        return [\n            this.F.add(\n                s0,\n                this._mulByNonResidue(s3)),           // s0 + non_residue * s3,\n            this.F.add(\n                s1,\n                this._mulByNonResidue(s4)),           // s1 + non_residue * s4,\n            this.F.sub(\n                this.F.add( this.F.add(s1, s2) , s3 ),\n                this.F.add(s0, s4))];                      // s1 + s2 + s3 - s0 - s4\n    }\n\n    isZero(a) {\n        return this.F.isZero(a[0]) && this.F.isZero(a[1]) && this.F.isZero(a[2]);\n    }\n\n    eq(a, b) {\n        return this.F.eq(a[0], b[0]) && this.F.eq(a[1], b[1]) && this.F.eq(a[2], b[2]);\n    }\n\n    affine(a) {\n        return [this.F.affine(a[0]), this.F.affine(a[1]), this.F.affine(a[2])];\n    }\n\n    mulScalar(base, e) {\n        return mulScalar(this, base, e);\n    }\n\n    pow(base, e) {\n        return exp(this, base, e);\n    }\n\n    exp(base, e) {\n        return exp(this, base, e);\n    }\n\n    toString(a) {\n        return `[ ${this.F.toString(a[0])} , ${this.F.toString(a[1])}, ${this.F.toString(a[2])} ]`;\n    }\n\n    fromRng(rng) {\n        const c0 = this.F.fromRng(rng);\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        return [c0, c1, c2];\n    }\n\n    gt(a, b) {\n        if (this.F.gt(a[0], b[0])) return true;\n        if (this.F.gt(b[0], a[0])) return false;\n        if (this.F.gt(a[1], b[1])) return true;\n        if (this.F.gt(b[1], a[1])) return false;\n        if (this.F.gt(a[2], b[2])) return true;\n        return false;\n    }\n\n\n    geq(a, b) {\n        return this.gt(a, b) || this.eq(a, b);\n    }\n\n    lt(a, b) {\n        return !this.geq(a,b);\n    }\n\n    leq(a, b) {\n        return !this.gt(a,b);\n    }\n\n    neq(a, b) {\n        return !this.eq(a,b);\n    }\n\n    random() {\n        return [this.F.random(), this.F.random(), this.F.random()];\n    }\n\n\n    toRprLE(buff, o, e) {\n        this.F.toRprLE(buff, o, e[0]);\n        this.F.toRprLE(buff, o+this.F.n8, e[1]);\n        this.F.toRprLE(buff, o+this.F.n8*2, e[2]);\n    }\n\n    toRprBE(buff, o, e) {\n        this.F.toRprBE(buff, o, e[2]);\n        this.F.toRprBE(buff, o+this.F.n8, e[1]);\n        this.F.toRprBE(buff, o+this.F.n8*2, e[0]);\n    }\n\n    toRprLEM(buff, o, e) {\n        this.F.toRprLEM(buff, o, e[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprLEM(buff, o+this.F.n8*2, e[2]);\n    }\n\n\n    toRprBEM(buff, o, e) {\n        this.F.toRprBEM(buff, o, e[2]);\n        this.F.toRprBEM(buff, o+this.F.n8, e[1]);\n        this.F.toRprBEM(buff, o+this.F.n8*2, e[0]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLE(buff, o);\n        const c1 = this.F.fromRprLE(buff, o+this.n8);\n        const c2 = this.F.fromRprLE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBE(buff, o);\n        const c1 = this.F.fromRprBE(buff, o+this.n8);\n        const c0 = this.F.fromRprBE(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const c0 = this.F.fromRprLEM(buff, o);\n        const c1 = this.F.fromRprLEM(buff, o+this.n8);\n        const c2 = this.F.fromRprLEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const c2 = this.F.fromRprBEM(buff, o);\n        const c1 = this.F.fromRprBEM(buff, o+this.n8);\n        const c0 = this.F.fromRprBEM(buff, o+this.n8*2);\n        return [c0, c1, c2];\n    }\n\n    toObject(a) {\n        return a;\n    }\n}\n\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nfunction isGreatest(F, a) {\n    if (Array.isArray(a)) {\n        for (let i=a.length-1; i>=0; i--) {\n            if (!F.F.isZero(a[i])) {\n                return isGreatest(F.F, a[i]);\n            }\n        }\n        return 0;\n    } else {\n        const na = F.neg(a);\n        return gt(a, na);\n    }\n}\n\n\nclass EC {\n\n    constructor(F, g) {\n        this.F = F;\n        this.g = g;\n        if (this.g.length == 2) this.g[2] = this.F.one;\n        this.zero = [this.F.zero, this.F.one, this.F.zero];\n    }\n\n    add(p1, p2) {\n\n        const F = this.F;\n\n        if (this.eq(p1, this.zero)) return p2;\n        if (this.eq(p2, this.zero)) return p1;\n\n        const res = new Array(3);\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );     // U1 = X1  * Z2Z2\n        const U2 = F.mul( p2[0] , Z1Z1 );     // U2 = X2  * Z1Z1\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);  // S1 = Y1 * Z2 * Z2Z2\n        const S2 = F.mul( p2[1] , Z1_cubed);  // S2 = Y2 * Z1 * Z1Z1\n\n        if (F.eq(U1,U2) && F.eq(S1,S2)) {\n            return this.double(p1);\n        }\n\n        const H = F.sub( U2 , U1 );                    // H = U2-U1\n\n        const S2_minus_S1 = F.sub( S2 , S1 );\n\n        const I = F.square( F.add(H,H) );         // I = (2 * H)^2\n        const J = F.mul( H , I );                      // J = H * I\n\n        const r = F.add( S2_minus_S1 , S2_minus_S1 );  // r = 2 * (S2-S1)\n        const V = F.mul( U1 , I );                     // V = U1 * I\n\n        res[0] =\n            F.sub(\n                F.sub( F.square(r) , J ),\n                F.add( V , V ));                       // X3 = r^2 - J - 2 * V\n\n        const S1_J = F.mul( S1 , J );\n\n        res[1] =\n            F.sub(\n                F.mul( r , F.sub(V,res[0])),\n                F.add( S1_J,S1_J ));                   // Y3 = r * (V-X3)-2 S1 J\n\n        res[2] =\n            F.mul(\n                H,\n                F.sub(\n                    F.square( F.add(p1[2],p2[2]) ),\n                    F.add( Z1Z1 , Z2Z2 )));            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2) * H\n\n        return res;\n    }\n\n    neg(p) {\n        return [p[0], this.F.neg(p[1]), p[2]];\n    }\n\n    sub(a, b) {\n        return this.add(a, this.neg(b));\n    }\n\n    double(p) {\n        const F = this.F;\n\n        const res = new Array(3);\n\n        if (this.eq(p, this.zero)) return p;\n\n        const A = F.square( p[0] );                    // A = X1^2\n        const B = F.square( p[1] );                    // B = Y1^2\n        const C = F.square( B );                       // C = B^2\n\n        let D =\n            F.sub(\n                F.square( F.add(p[0] , B )),\n                F.add( A , C));\n        D = F.add(D,D);                    // D = 2 * ((X1 + B)^2 - A - C)\n\n        const E = F.add( F.add(A,A), A);          // E = 3 * A\n        const FF =F.square( E );                       // F = E^2\n\n        res[0] = F.sub( FF , F.add(D,D) );         // X3 = F - 2 D\n\n        let eightC = F.add( C , C );\n        eightC = F.add( eightC , eightC );\n        eightC = F.add( eightC , eightC );\n\n        res[1] =\n            F.sub(\n                F.mul(\n                    E,\n                    F.sub( D, res[0] )),\n                eightC);                                    // Y3 = E * (D - X3) - 8 * C\n\n        const Y1Z1 = F.mul( p[1] , p[2] );\n        res[2] = F.add( Y1Z1 , Y1Z1 );                 // Z3 = 2 * Y1 * Z1\n\n        return res;\n    }\n\n    timesScalar(base, e) {\n        return mulScalar(this, base, e);\n    }\n\n    mulScalar(base, e) {\n        return mulScalar(this, base, e);\n    }\n\n    affine(p) {\n        const F = this.F;\n        if (this.isZero(p)) {\n            return this.zero;\n        } else if (F.eq(p[2], F.one)) {\n            return p;\n        } else {\n            const Z_inv = F.inv(p[2]);\n            const Z2_inv = F.square(Z_inv);\n            const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n            const res = new Array(3);\n            res[0] = F.mul(p[0],Z2_inv);\n            res[1] = F.mul(p[1],Z3_inv);\n            res[2] = F.one;\n\n            return res;\n        }\n    }\n\n    multiAffine(arr) {\n        const keys = Object.keys(arr);\n        const F = this.F;\n        const accMul = new Array(keys.length+1);\n        accMul[0] = F.one;\n        for (let i = 0; i< keys.length; i++) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i+1] = accMul[i];\n            } else {\n                accMul[i+1] = F.mul(accMul[i], arr[keys[i]][2]);\n            }\n        }\n\n        accMul[keys.length] = F.inv(accMul[keys.length]);\n\n        for (let i = keys.length-1; i>=0; i--) {\n            if (F.eq(arr[keys[i]][2], F.zero)) {\n                accMul[i] = accMul[i+1];\n                arr[keys[i]] = this.zero;\n            } else {\n                const Z_inv = F.mul(accMul[i], accMul[i+1]);\n                accMul[i] = F.mul(arr[keys[i]][2], accMul[i+1]);\n\n                const Z2_inv = F.square(Z_inv);\n                const Z3_inv = F.mul(Z2_inv, Z_inv);\n\n                arr[keys[i]][0] = F.mul(arr[keys[i]][0],Z2_inv);\n                arr[keys[i]][1] = F.mul(arr[keys[i]][1],Z3_inv);\n                arr[keys[i]][2] = F.one;\n            }\n        }\n\n    }\n\n    eq(p1, p2) {\n        const F = this.F;\n\n        if (this.F.eq(p1[2], this.F.zero)) return this.F.eq(p2[2], this.F.zero);\n        if (this.F.eq(p2[2], this.F.zero)) return false;\n\n        const Z1Z1 = F.square( p1[2] );\n        const Z2Z2 = F.square( p2[2] );\n\n        const U1 = F.mul( p1[0] , Z2Z2 );\n        const U2 = F.mul( p2[0] , Z1Z1 );\n\n        const Z1_cubed = F.mul( p1[2] , Z1Z1);\n        const Z2_cubed = F.mul( p2[2] , Z2Z2);\n\n        const S1 = F.mul( p1[1] , Z2_cubed);\n        const S2 = F.mul( p2[1] , Z1_cubed);\n\n        return (F.eq(U1,U2) && F.eq(S1,S2));\n    }\n\n    isZero(p) {\n        return this.F.isZero(p[2]);\n    }\n\n    toString(p) {\n        const cp = this.affine(p);\n        return `[ ${this.F.toString(cp[0])} , ${this.F.toString(cp[1])} ]`;\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n            P[1] = F.sqrt(x3b);\n        } while ((P[1] == null)||(F.isZero[P]));\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        if (this.cofactor) {\n            P = this.mulScalar(P, this.cofactor);\n        }\n\n        P = this.affine(P);\n\n        return P;\n\n    }\n\n    toRprLE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLE(buff, o, p[0]);\n        this.F.toRprLE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprBE(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n        this.F.toRprBE(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n    }\n\n    toRprLEJM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprLEM(buff, o, p[0]);\n        this.F.toRprLEM(buff, o+this.F.n8, p[1]);\n        this.F.toRprLEM(buff, o+2*this.F.n8, p[2]);\n    }\n\n\n    toRprBEM(buff, o, p) {\n        p = this.affine(p);\n        if (this.isZero(p)) {\n            const BuffV = new Uint8Array(buff, o, this.F.n8*2);\n            BuffV.fill(0);\n            return;\n        }\n        this.F.toRprBEM(buff, o, p[0]);\n        this.F.toRprBEM(buff, o+this.F.n8, p[1]);\n    }\n\n    fromRprLE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLE(buff, o);\n        const y = this.F.fromRprLE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprBE(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBE(buff, o);\n        const y = this.F.fromRprBE(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprLEJM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprLEM(buff, o);\n        const y = this.F.fromRprLEM(buff, o+this.F.n8);\n        const z = this.F.fromRprLEM(buff, o+this.F.n8*2);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, z];\n    }\n\n    fromRprBEM(buff, o) {\n        o = o || 0;\n        const x = this.F.fromRprBEM(buff, o);\n        const y = this.F.fromRprBEM(buff, o+this.F.n8);\n        if (this.F.isZero(x) && this.F.isZero(y)) {\n            return this.zero;\n        }\n        return [x, y, this.F.one];\n    }\n\n    fromRprCompressed(buff, o) {\n        const F = this.F;\n        const v = new Uint8Array(buff.buffer, o, F.n8);\n        if (v[0] & 0x40) return this.zero;\n        const P = new Array(3);\n\n        const greatest = ((v[0] & 0x80) != 0);\n        v[0] = v[0] & 0x7F;\n        P[0] = F.fromRprBE(buff, o);\n        if (greatest) v[0] = v[0] | 0x80;  // set back again the old value\n\n        const x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        P[1] = F.sqrt(x3b);\n\n        if (P[1] === null) {\n            throw new Error(\"Invalid Point!\");\n        }\n\n        const s = isGreatest(F, P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n        P[2] = F.one;\n\n        return P;\n    }\n\n    toRprCompressed(buff, o, p) {\n        p = this.affine(p);\n        const v = new Uint8Array(buff.buffer, o, this.F.n8);\n        if (this.isZero(p)) {\n            v.fill(0);\n            v[0] = 0x40;\n            return;\n        }\n        this.F.toRprBE(buff, o, p[0]);\n\n        if (isGreatest(this.F, p[1])) {\n            v[0] = v[0] | 0x80;\n        }\n    }\n\n\n    fromRprUncompressed(buff, o) {\n        if (buff[0] & 0x40) return this.zero;\n\n        return this.fromRprBE(buff, o);\n    }\n\n    toRprUncompressed(buff, o, p) {\n        this.toRprBE(buff, o, p);\n\n        if (this.isZero(p)) {\n            buff[o] = buff[o] | 0x40;\n        }\n    }\n\n\n}\n\nvar utils$6 = {};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nutils$6.bigInt2BytesLE = function bigInt2BytesLE(_a, len) {\n    const b = Array(len);\n    let v = BigInt(_a);\n    for (let i=0; i<len; i++) {\n        b[i] = Number(v & 0xFFn);\n        v = v >> 8n;\n    }\n    return b;\n};\n\nutils$6.bigInt2U32LE = function bigInt2BytesLE(_a, len) {\n    const b = Array(len);\n    let v = BigInt(_a);\n    for (let i=0; i<len; i++) {\n        b[i] = Number(v & 0xFFFFFFFFn);\n        v = v >> 32n;\n    }\n    return b;\n};\n\nutils$6.isOcamNum = function(a) {\n    if (!Array.isArray(a)) return false;\n    if (a.length != 3) return false;\n    if (typeof a[0] !== \"number\") return false;\n    if (typeof a[1] !== \"number\") return false;\n    if (!Array.isArray(a[2])) return false;\n    return true;\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar build_int = function buildInt(module, n64, _prefix) {\n\n    const prefix = _prefix || \"int\";\n    if (module.modules[prefix]) return prefix;  // already builded\n    module.modules[prefix] = {};\n\n    const n32 = n64*2;\n    const n8 = n64*8;\n\n    function buildCopy() {\n        const f = module.addFunction(prefix+\"_copy\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pr\"),\n                    i*8,\n                    c.i64_load(\n                        c.getLocal(\"px\"),\n                        i*8\n                    )\n                )\n            );\n        }\n    }\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pr\"),\n                    i*8,\n                    c.i64_const(0)\n                )\n            );\n        }\n    }\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.i64_store(\n                c.getLocal(\"pr\"),\n                0,\n                c.i64_const(1)\n            )\n        );\n        for (let i=1; i<n64; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pr\"),\n                    i*8,\n                    c.i64_const(0)\n                )\n            );\n        }\n    }\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix+\"_isZero\");\n        f.addParam(\"px\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        function getCompCode(n) {\n            if (n==0) {\n                return  c.ret(c.i64_eqz(\n                    c.i64_load(c.getLocal(\"px\"))\n                ));\n            }\n            return c.if(\n                c.i64_eqz(\n                    c.i64_load(c.getLocal(\"px\"), n*8 )\n                ),\n                getCompCode(n-1),\n                c.ret(c.i32_const(0))\n            );\n        }\n\n        f.addCode(getCompCode(n64-1));\n        f.addCode(c.ret(c.i32_const(0)));\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix+\"_eq\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"py\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        function getCompCode(n) {\n            if (n==0) {\n                return  c.ret(c.i64_eq(\n                    c.i64_load(c.getLocal(\"px\")),\n                    c.i64_load(c.getLocal(\"py\"))\n                ));\n            }\n            return c.if(\n                c.i64_eq(\n                    c.i64_load(c.getLocal(\"px\"), n*8 ),\n                    c.i64_load(c.getLocal(\"py\"), n*8 )\n                ),\n                getCompCode(n-1),\n                c.ret(c.i32_const(0))\n            );\n        }\n\n        f.addCode(getCompCode(n64-1));\n        f.addCode(c.ret(c.i32_const(0)));\n    }\n\n\n\n    function buildGte() {\n        const f = module.addFunction(prefix+\"_gte\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"py\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        function getCompCode(n) {\n            if (n==0) {\n                return  c.ret(c.i64_ge_u(\n                    c.i64_load(c.getLocal(\"px\")),\n                    c.i64_load(c.getLocal(\"py\"))\n                ));\n            }\n            return c.if(\n                c.i64_lt_u(\n                    c.i64_load(c.getLocal(\"px\"), n*8 ),\n                    c.i64_load(c.getLocal(\"py\"), n*8 )\n                ),\n                c.ret(c.i32_const(0)),\n                c.if(\n                    c.i64_gt_u(\n                        c.i64_load(c.getLocal(\"px\"), n*8 ),\n                        c.i64_load(c.getLocal(\"py\"), n*8 )\n                    ),\n                    c.ret(c.i32_const(1)),\n                    getCompCode(n-1)\n                )\n            );\n        }\n\n        f.addCode(getCompCode(n64-1));\n        f.addCode(c.ret(c.i32_const(0)));\n    }\n\n\n\n    function buildAdd() {\n\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"c\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_add(\n                c.i64_load32_u(c.getLocal(\"x\")),\n                c.i64_load32_u(c.getLocal(\"y\"))\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"r\"),\n            c.getLocal(\"c\"),\n        ));\n\n        for (let i=1; i<n32; i++) {\n            f.addCode(c.setLocal( \"c\",\n                c.i64_add(\n                    c.i64_add(\n                        c.i64_load32_u(c.getLocal(\"x\"), 4*i),\n                        c.i64_load32_u(c.getLocal(\"y\"), 4*i)\n                    ),\n                    c.i64_shr_u (c.getLocal(\"c\"), c.i64_const(32))\n                )\n            ));\n\n            f.addCode(c.i64_store32(\n                c.getLocal(\"r\"),\n                i*4,\n                c.getLocal(\"c\")\n            ));\n        }\n\n        f.addCode(c.i32_wrap_i64(c.i64_shr_u (c.getLocal(\"c\"), c.i64_const(32))));\n    }\n\n\n    function buildSub() {\n\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"c\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_sub(\n                c.i64_load32_u(c.getLocal(\"x\")),\n                c.i64_load32_u(c.getLocal(\"y\"))\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"r\"),\n            c.i64_and(\n                c.getLocal(\"c\"),\n                c.i64_const(\"0xFFFFFFFF\")\n            )\n        ));\n\n        for (let i=1; i<n32; i++) {\n            f.addCode(c.setLocal( \"c\",\n                c.i64_add(\n                    c.i64_sub(\n                        c.i64_load32_u(c.getLocal(\"x\"), 4*i),\n                        c.i64_load32_u(c.getLocal(\"y\"), 4*i)\n                    ),\n                    c.i64_shr_s (c.getLocal(\"c\"), c.i64_const(32))\n                )\n            ));\n\n            f.addCode(c.i64_store32(\n                c.getLocal(\"r\"),\n                i*4,\n                c.i64_and( c.getLocal(\"c\"), c.i64_const(\"0xFFFFFFFF\"))\n            ));\n        }\n\n        f.addCode(c.i32_wrap_i64 ( c.i64_shr_s (c.getLocal(\"c\"), c.i64_const(32))));\n    }\n\n\n    function buildMul() {\n\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n            f.addLocal(\"y\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const loadX = [];\n        const loadY = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadY[j]) {\n                Y = c.teeLocal(\"y\"+j, c.i64_load32_u( c.getLocal(\"y\"), j*4));\n                loadY[j] = true;\n            } else {\n                Y = c.getLocal(\"y\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            for (let i=Math.max(0, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n\n            }\n\n            f.addCode(\n                c.i64_store32(\n                    c.getLocal(\"r\"),\n                    k*4,\n                    c.getLocal(c0)\n                )\n            );\n            [c0, c1] = [c1, c0];\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_shr_u(\n                        c.getLocal(c0),\n                        c.i64_const(32)\n                    )\n                )\n            );\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4*2-4,\n                c.getLocal(c0)\n            )\n        );\n\n    }\n\n\n\n    function buildSquare() {\n\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n        f.addLocal(\"c0_old\", \"i64\");\n        f.addLocal(\"c1_old\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const loadX = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadX[j]) {\n                Y = c.teeLocal(\"x\"+j, c.i64_load32_u( c.getLocal(\"x\"), j*4));\n                loadX[j] = true;\n            } else {\n                Y = c.getLocal(\"x\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n        let c0_old = \"c0_old\";\n        let c1_old = \"c1_old\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            f.addCode(\n                c.setLocal(c0, c.i64_const(0)),\n                c.setLocal(c1, c.i64_const(0)),\n            );\n\n            for (let i=Math.max(0, k-n32+1); (i<((k+1)>>1) )&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Multiply by 2\n            f.addCode(\n                c.setLocal(c0,\n                    c.i64_shl(\n                        c.i64_and(\n                            c.getLocal(c0),\n                            c.i64_const(0xFFFFFFFF)\n                        ),\n                        c.i64_const(1)\n                    )\n                )\n            );\n\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_add(\n                        c.i64_shl(\n                            c.getLocal(c1),\n                            c.i64_const(1)\n                        ),\n                        c.i64_shr_u(\n                            c.getLocal(c0),\n                            c.i64_const(32)\n                        )\n                    )\n                )\n            );\n\n            if (k%2 == 0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(k>>1, k>>1)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Add the old carry\n\n            if (k>0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            c.i64_and(\n                                c.getLocal(c0_old),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.i64_add(\n                                c.getLocal(c1),\n                                c.i64_shr_u(\n                                    c.getLocal(c0),\n                                    c.i64_const(32)\n                                )\n                            ),\n                            c.getLocal(c1_old)\n                        )\n                    )\n                );\n            }\n\n            f.addCode(\n                c.i64_store32(\n                    c.getLocal(\"r\"),\n                    k*4,\n                    c.getLocal(c0)\n                )\n            );\n\n            f.addCode(\n                c.setLocal(\n                    c0_old,\n                    c.getLocal(c1)\n                ),\n                c.setLocal(\n                    c1_old,\n                    c.i64_shr_u(\n                        c.getLocal(c0_old),\n                        c.i64_const(32)\n                    )\n                )\n            );\n\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4*2-4,\n                c.getLocal(c0_old)\n            )\n        );\n\n    }\n\n\n    function buildSquareOld() {\n        const f = module.addFunction(prefix+\"_squareOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(prefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"x\"), c.getLocal(\"r\")));\n    }\n\n    function _buildMul1() {\n        const f = module.addFunction(prefix+\"__mul1\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"y\", \"i64\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"c\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_mul(\n                c.i64_load32_u(c.getLocal(\"px\"), 0, 0),\n                c.getLocal(\"y\")\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"pr\"),\n            0,\n            0,\n            c.getLocal(\"c\"),\n        ));\n\n        for (let i=1; i<n32; i++) {\n            f.addCode(c.setLocal( \"c\",\n                c.i64_add(\n                    c.i64_mul(\n                        c.i64_load32_u(c.getLocal(\"px\"), 4*i, 0),\n                        c.getLocal(\"y\")\n                    ),\n                    c.i64_shr_u (c.getLocal(\"c\"), c.i64_const(32))\n                )\n            ));\n\n            f.addCode(c.i64_store32(\n                c.getLocal(\"pr\"),\n                i*4,\n                0,\n                c.getLocal(\"c\")\n            ));\n        }\n    }\n\n    function _buildAdd1() {\n        const f = module.addFunction(prefix+\"__add1\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i64\");\n        f.addLocal(\"c\", \"i64\");\n        f.addLocal(\"px\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.setLocal(\"px\", c.getLocal(\"x\")));\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_add(\n                c.i64_load32_u(c.getLocal(\"px\"), 0, 0),\n                c.getLocal(\"y\")\n            )\n        ));\n\n        f.addCode(c.i64_store32(\n            c.getLocal(\"px\"),\n            0,\n            0,\n            c.getLocal(\"c\"),\n        ));\n\n        f.addCode(c.setLocal(\n            \"c\",\n            c.i64_shr_u(\n                c.getLocal(\"c\"),\n                c.i64_const(32)\n            )\n        ));\n\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.i64_eqz(c.getLocal(\"c\"))\n            ),\n            c.setLocal(\n                \"px\",\n                c.i32_add(\n                    c.getLocal(\"px\"),\n                    c.i32_const(4)\n                )\n            ),\n\n            c.setLocal(\n                \"c\",\n                c.i64_add(\n                    c.i64_load32_u(c.getLocal(\"px\"), 0, 0),\n                    c.getLocal(\"c\")\n                )\n            ),\n\n            c.i64_store32(\n                c.getLocal(\"px\"),\n                0,\n                0,\n                c.getLocal(\"c\"),\n            ),\n\n            c.setLocal(\n                \"c\",\n                c.i64_shr_u(\n                    c.getLocal(\"c\"),\n                    c.i64_const(32)\n                )\n            ),\n\n            c.br(0)\n        )));\n    }\n\n\n    function buildDiv() {\n        _buildMul1();\n        _buildAdd1();\n\n        const f = module.addFunction(prefix+\"_div\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"c\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"rr\", \"i32\");\n        f.addLocal(\"cc\", \"i32\");\n        f.addLocal(\"eX\", \"i32\");\n        f.addLocal(\"eY\", \"i32\");\n        f.addLocal(\"sy\", \"i64\");\n        f.addLocal(\"sx\", \"i64\");\n        f.addLocal(\"ec\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Y = c.i32_const(module.alloc(n8));\n        const Caux = c.i32_const(module.alloc(n8));\n        const Raux = c.i32_const(module.alloc(n8));\n        const C = c.getLocal(\"cc\");\n        const R = c.getLocal(\"rr\");\n        const pr1 = module.alloc(n8*2);\n        const R1 = c.i32_const(pr1);\n        const R2 = c.i32_const(pr1+n8);\n\n        // Ic c is 0 then store it in an auxiliary buffer\n        f.addCode(c.if(\n            c.getLocal(\"c\"),\n            c.setLocal(\"cc\", c.getLocal(\"c\")),\n            c.setLocal(\"cc\", Caux)\n        ));\n\n        // Ic r is 0 then store it in an auxiliary buffer\n        f.addCode(c.if(\n            c.getLocal(\"r\"),\n            c.setLocal(\"rr\", c.getLocal(\"r\")),\n            c.setLocal(\"rr\", Raux)\n        ));\n\n        // Copy\n        f.addCode(c.call(prefix + \"_copy\", c.getLocal(\"x\"), R));\n        f.addCode(c.call(prefix + \"_copy\", c.getLocal(\"y\"), Y));\n        f.addCode(c.call(prefix + \"_zero\", C));\n        f.addCode(c.call(prefix + \"_zero\", R1));\n\n\n        f.addCode(c.setLocal(\"eX\", c.i32_const(n8-1)));\n        f.addCode(c.setLocal(\"eY\", c.i32_const(n8-1)));\n\n        // while (eY>3)&&(Y[eY]==0) ey--;\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.i32_or(\n                    c.i32_load8_u(\n                        c.i32_add(Y , c.getLocal(\"eY\")),\n                        0,\n                        0\n                    ),\n                    c.i32_eq(\n                        c.getLocal(\"eY\"),\n                        c.i32_const(3)\n                    )\n                )\n            ),\n            c.setLocal(\"eY\", c.i32_sub(c.getLocal(\"eY\"), c.i32_const(1))),\n            c.br(0)\n        )));\n\n        f.addCode(\n            c.setLocal(\n                \"sy\",\n                c.i64_add(\n                    c.i64_load32_u(\n                        c.i32_sub(\n                            c.i32_add( Y, c.getLocal(\"eY\")),\n                            c.i32_const(3)\n                        ),\n                        0,\n                        0\n                    ),\n                    c.i64_const(1)\n                )\n            )\n        );\n\n        // Force a divide by 0 if quotien is 0\n        f.addCode(\n            c.if(\n                c.i64_eq(\n                    c.getLocal(\"sy\"),\n                    c.i64_const(1)\n                ),\n                c.drop(c.i64_div_u(c.i64_const(0), c.i64_const(0)))\n            )\n        );\n\n        f.addCode(c.block(c.loop(\n\n            // while (eX>7)&&(Y[eX]==0) ex--;\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_or(\n                        c.i32_load8_u(\n                            c.i32_add(R , c.getLocal(\"eX\")),\n                            0,\n                            0\n                        ),\n                        c.i32_eq(\n                            c.getLocal(\"eX\"),\n                            c.i32_const(7)\n                        )\n                    )\n                ),\n                c.setLocal(\"eX\", c.i32_sub(c.getLocal(\"eX\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            c.setLocal(\n                \"sx\",\n                c.i64_load(\n                    c.i32_sub(\n                        c.i32_add( R, c.getLocal(\"eX\")),\n                        c.i32_const(7)\n                    ),\n                    0,\n                    0\n                )\n            ),\n\n            c.setLocal(\n                \"sx\",\n                c.i64_div_u(\n                    c.getLocal(\"sx\"),\n                    c.getLocal(\"sy\")\n                )\n            ),\n            c.setLocal(\n                \"ec\",\n                c.i32_sub(\n                    c.i32_sub(\n                        c.getLocal(\"eX\"),\n                        c.getLocal(\"eY\")\n                    ),\n                    c.i32_const(4)\n                )\n            ),\n\n            // While greater than 32 bits or ec is neg, shr and inc exp\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_and(\n                        c.i64_eqz(\n                            c.i64_and(\n                                c.getLocal(\"sx\"),\n                                c.i64_const(\"0xFFFFFFFF00000000\")\n                            )\n                        ),\n                        c.i32_ge_s(\n                            c.getLocal(\"ec\"),\n                            c.i32_const(0)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"sx\",\n                    c.i64_shr_u(\n                        c.getLocal(\"sx\"),\n                        c.i64_const(8)\n                    )\n                ),\n\n                c.setLocal(\n                    \"ec\",\n                    c.i32_add(\n                        c.getLocal(\"ec\"),\n                        c.i32_const(1)\n                    )\n                ),\n                c.br(0)\n            )),\n\n            c.if(\n                c.i64_eqz(c.getLocal(\"sx\")),\n                [\n                    ...c.br_if(\n                        2,\n                        c.i32_eqz(c.call(prefix + \"_gte\", R, Y))\n                    ),\n                    ...c.setLocal(\"sx\", c.i64_const(1)),\n                    ...c.setLocal(\"ec\", c.i32_const(0))\n                ]\n            ),\n\n            c.call(prefix + \"__mul1\", Y, c.getLocal(\"sx\"), R2),\n            c.drop(c.call(\n                prefix + \"_sub\",\n                R,\n                c.i32_sub(R2, c.getLocal(\"ec\")),\n                R\n            )),\n            c.call(\n                prefix + \"__add1\",\n                c.i32_add(C, c.getLocal(\"ec\")),\n                c.getLocal(\"sx\")\n            ),\n            c.br(0)\n        )));\n    }\n\n    function buildInverseMod() {\n\n        const f = module.addFunction(prefix+\"_inverseMod\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"pm\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"t\", \"i32\");\n        f.addLocal(\"newt\", \"i32\");\n        f.addLocal(\"r\", \"i32\");\n        f.addLocal(\"qq\", \"i32\");\n        f.addLocal(\"qr\", \"i32\");\n        f.addLocal(\"newr\", \"i32\");\n        f.addLocal(\"swp\", \"i32\");\n        f.addLocal(\"x\", \"i32\");\n        f.addLocal(\"signt\", \"i32\");\n        f.addLocal(\"signnewt\", \"i32\");\n        f.addLocal(\"signx\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux1 = c.i32_const(module.alloc(n8));\n        const aux2 = c.i32_const(module.alloc(n8));\n        const aux3 = c.i32_const(module.alloc(n8));\n        const aux4 = c.i32_const(module.alloc(n8));\n        const aux5 = c.i32_const(module.alloc(n8));\n        const aux6 = c.i32_const(module.alloc(n8));\n        const mulBuff = c.i32_const(module.alloc(n8*2));\n        const aux7 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"t\", aux1),\n            c.call(prefix + \"_zero\", aux1),\n            c.setLocal(\"signt\", c.i32_const(0)),\n        );\n\n        f.addCode(\n            c.setLocal(\"r\", aux2),\n            c.call(prefix + \"_copy\", c.getLocal(\"pm\"), aux2)\n        );\n\n        f.addCode(\n            c.setLocal(\"newt\", aux3),\n            c.call(prefix + \"_one\", aux3),\n            c.setLocal(\"signnewt\", c.i32_const(0)),\n        );\n\n        f.addCode(\n            c.setLocal(\"newr\", aux4),\n            c.call(prefix + \"_copy\", c.getLocal(\"px\"), aux4)\n        );\n\n\n\n\n        f.addCode(c.setLocal(\"qq\", aux5));\n        f.addCode(c.setLocal(\"qr\", aux6));\n        f.addCode(c.setLocal(\"x\", aux7));\n\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.call(prefix + \"_isZero\", c.getLocal(\"newr\") )\n            ),\n            c.call(prefix + \"_div\", c.getLocal(\"r\"), c.getLocal(\"newr\"), c.getLocal(\"qq\"), c.getLocal(\"qr\")),\n\n            c.call(prefix + \"_mul\", c.getLocal(\"qq\"), c.getLocal(\"newt\"), mulBuff),\n\n            c.if(\n                c.getLocal(\"signt\"),\n                c.if(\n                    c.getLocal(\"signnewt\"),\n                    c.if (\n                        c.call(prefix + \"_gte\", mulBuff, c.getLocal(\"t\")),\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(0))\n                        ],\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", c.getLocal(\"t\"), mulBuff, c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(1))\n                        ],\n                    ),\n                    [\n                        ...c.drop(c.call(prefix + \"_add\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                        ...c.setLocal(\"signx\", c.i32_const(1))\n                    ]\n                ),\n                c.if(\n                    c.getLocal(\"signnewt\"),\n                    [\n                        ...c.drop(c.call(prefix + \"_add\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                        ...c.setLocal(\"signx\", c.i32_const(0))\n                    ],\n                    c.if (\n                        c.call(prefix + \"_gte\", c.getLocal(\"t\"), mulBuff),\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", c.getLocal(\"t\"), mulBuff, c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(0))\n                        ],\n                        [\n                            ...c.drop(c.call(prefix + \"_sub\", mulBuff, c.getLocal(\"t\"), c.getLocal(\"x\"))),\n                            ...c.setLocal(\"signx\", c.i32_const(1))\n                        ]\n                    )\n                )\n            ),\n\n            c.setLocal(\"swp\", c.getLocal(\"t\")),\n            c.setLocal(\"t\", c.getLocal(\"newt\")),\n            c.setLocal(\"newt\", c.getLocal(\"x\")),\n            c.setLocal(\"x\", c.getLocal(\"swp\")),\n\n            c.setLocal(\"signt\", c.getLocal(\"signnewt\")),\n            c.setLocal(\"signnewt\", c.getLocal(\"signx\")),\n\n            c.setLocal(\"swp\", c.getLocal(\"r\")),\n            c.setLocal(\"r\", c.getLocal(\"newr\")),\n            c.setLocal(\"newr\", c.getLocal(\"qr\")),\n            c.setLocal(\"qr\", c.getLocal(\"swp\")),\n\n            c.br(0)\n        )));\n\n        f.addCode(c.if(\n            c.getLocal(\"signt\"),\n            c.drop(c.call(prefix + \"_sub\", c.getLocal(\"pm\"), c.getLocal(\"t\"), c.getLocal(\"pr\"))),\n            c.call(prefix + \"_copy\", c.getLocal(\"t\"), c.getLocal(\"pr\"))\n        ));\n    }\n\n\n    buildCopy();\n    buildZero();\n    buildIsZero();\n    buildOne();\n    buildEq();\n    buildGte();\n    buildAdd();\n    buildSub();\n    buildMul();\n    buildSquare();\n    buildSquareOld();\n    buildDiv();\n    buildInverseMod();\n    module.exportFunction(prefix+\"_copy\");\n    module.exportFunction(prefix+\"_zero\");\n    module.exportFunction(prefix+\"_one\");\n    module.exportFunction(prefix+\"_isZero\");\n    module.exportFunction(prefix+\"_eq\");\n    module.exportFunction(prefix+\"_gte\");\n    module.exportFunction(prefix+\"_add\");\n    module.exportFunction(prefix+\"_sub\");\n    module.exportFunction(prefix+\"_mul\");\n    module.exportFunction(prefix+\"_square\");\n    module.exportFunction(prefix+\"_squareOld\");\n    module.exportFunction(prefix+\"_div\");\n    module.exportFunction(prefix+\"_inverseMod\");\n\n    return prefix;\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar build_timesscalar = function buildTimesScalar(module, fnName, elementLen, opAB, opAA, opCopy, opInit) {\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"base\", \"i32\");\n    f.addParam(\"scalar\", \"i32\");\n    f.addParam(\"scalarLength\", \"i32\");\n    f.addParam(\"r\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"b\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const aux = c.i32_const(module.alloc(elementLen));\n\n    f.addCode(\n        c.if(\n            c.i32_eqz(c.getLocal(\"scalarLength\")),\n            [\n                ...c.call(opInit, c.getLocal(\"r\")),\n                ...c.ret([])\n            ]\n        )\n    );\n    f.addCode(c.call(opCopy, c.getLocal(\"base\"), aux));\n    f.addCode(c.call(opInit, c.getLocal(\"r\")));\n    f.addCode(c.setLocal(\"i\", c.getLocal(\"scalarLength\")));\n    f.addCode(c.block(c.loop(\n        c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n\n        c.setLocal(\n            \"b\",\n            c.i32_load8_u(\n                c.i32_add(\n                    c.getLocal(\"scalar\"),\n                    c.getLocal(\"i\")\n                )\n            )\n        ),\n        ...innerLoop(),\n        c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n        c.br(0)\n    )));\n\n\n    function innerLoop() {\n        const code = [];\n        for (let i=0; i<8; i++) {\n            code.push(\n                ...c.call(opAA, c.getLocal(\"r\"), c.getLocal(\"r\")),\n                ...c.if(\n                    c.i32_ge_u( c.getLocal(\"b\"), c.i32_const(0x80 >> i)),\n                    [\n                        ...c.setLocal(\n                            \"b\",\n                            c.i32_sub(\n                                c.getLocal(\"b\"),\n                                c.i32_const(0x80 >> i)\n                            )\n                        ),\n                        ...c.call(opAB, c.getLocal(\"r\"),aux, c.getLocal(\"r\"))\n                    ]\n                )\n            );\n        }\n        return code;\n    }\n\n};\n\nvar build_batchinverse = buildBatchInverse$3;\n\nfunction buildBatchInverse$3(module, prefix) {\n\n\n    const n8 = module.modules[prefix].n64*8;\n\n    const f = module.addFunction(prefix+\"_batchInverse\");\n    f.addParam(\"pIn\", \"i32\");\n    f.addParam(\"inStep\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addParam(\"outStep\", \"i32\");\n    f.addLocal(\"itAux\", \"i32\");\n    f.addLocal(\"itIn\", \"i32\");\n    f.addLocal(\"itOut\",\"i32\");\n    f.addLocal(\"i\",\"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const AUX = c.i32_const(module.alloc(n8));\n\n\n    // Alloc Working space for accumulated umltiplications\n    f.addCode(\n        c.setLocal(\"itAux\", c.i32_load( c.i32_const(0) )),\n        c.i32_store(\n            c.i32_const(0),\n            c.i32_add(\n                c.getLocal(\"itAux\"),\n                c.i32_mul(\n                    c.i32_add(\n                        c.getLocal(\"n\"),\n                        c.i32_const(1)\n                    ),\n                    c.i32_const(n8)\n                )\n            )\n        )\n    );\n\n    f.addCode(\n\n        // aux[0] = a;\n        c.call(prefix+\"_one\", c.getLocal(\"itAux\")),\n        // for (i=0;i<n;i++) aux[i] = aux[i-1]*in[i]\n        c.setLocal(\"itIn\", c.getLocal(\"pIn\")),\n        c.setLocal(\"itAux\", c.i32_add(c.getLocal(\"itAux\"), c.i32_const(n8))),\n        c.setLocal(\"i\", c.i32_const(0)),\n\n        c.block(c.loop(\n            c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n            c.if(\n                c.call(prefix+\"_isZero\", c.getLocal(\"itIn\")),\n                c.call(\n                    prefix + \"_copy\",\n                    c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    c.getLocal(\"itAux\")\n                ),\n                c.call(\n                    prefix+\"_mul\",\n                    c.getLocal(\"itIn\"),\n                    c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    c.getLocal(\"itAux\")\n                )\n            ),\n            c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.getLocal(\"inStep\"))),\n            c.setLocal(\"itAux\", c.i32_add(c.getLocal(\"itAux\"), c.i32_const(n8))),\n            c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        )),\n\n        // point to the last\n        c.setLocal(\"itIn\", c.i32_sub(c.getLocal(\"itIn\"), c.getLocal(\"inStep\"))),\n        c.setLocal(\"itAux\", c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8))),\n        // itOut = pOut + (n-1)*stepOut   // Point to the last\n        c.setLocal(\n            \"itOut\",\n            c.i32_add(\n                c.getLocal(\"pOut\"),\n                c.i32_mul(\n                    c.i32_sub(c.getLocal(\"n\"), c.i32_const(1)),\n                    c.getLocal(\"outStep\"),\n                )\n            )\n        ),\n\n        // aux[n-1] = 1/aux[n-1]\n        c.call(prefix+\"_inverse\", c.getLocal(\"itAux\"), c.getLocal(\"itAux\") ),\n\n        c.block(c.loop(\n            c.br_if(1, c.i32_eqz( c.getLocal(\"i\"))),\n            c.if(\n                c.call(prefix+\"_isZero\", c.getLocal(\"itIn\")),\n                [\n                    ...c.call(\n                        prefix + \"_copy\",\n                        c.getLocal(\"itAux\"),\n                        c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    ),\n                    ...c.call(\n                        prefix + \"_zero\",\n                        c.getLocal(\"itOut\")\n                    )\n                ],[\n                    ...c.call(prefix + \"_copy\", c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)), AUX),\n                    ...c.call(\n                        prefix+\"_mul\",\n                        c.getLocal(\"itAux\"),\n                        c.getLocal(\"itIn\"),\n                        c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8)),\n                    ),\n                    ...c.call(\n                        prefix+\"_mul\",\n                        c.getLocal(\"itAux\"),\n                        AUX,\n                        c.getLocal(\"itOut\")\n                    )\n                ]\n            ),\n            c.setLocal(\"itIn\", c.i32_sub(c.getLocal(\"itIn\"), c.getLocal(\"inStep\"))),\n            c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.getLocal(\"outStep\"))),\n            c.setLocal(\"itAux\", c.i32_sub(c.getLocal(\"itAux\"), c.i32_const(n8))),\n            c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        ))\n\n    );\n\n\n    // Recover Old memory\n    f.addCode(\n        c.i32_store(\n            c.i32_const(0),\n            c.getLocal(\"itAux\")\n        )\n    );\n\n}\n\nvar build_batchconvertion = buildBatchConvertion$3;\n\nfunction buildBatchConvertion$3(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {\n    if (typeof reverse === \"undefined\") {\n        // Set the reverse in a way that allows to use the same buffer as in/out.\n        if (sizeIn < sizeOut) {\n            reverse = true;\n        } else {\n            reverse = false;\n        }\n    }\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"pIn\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"itIn\", \"i32\");\n    f.addLocal(\"itOut\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    if (reverse) {\n        f.addCode(\n            c.setLocal(\"itIn\",\n                c.i32_add(\n                    c.getLocal(\"pIn\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeIn)\n                    )\n                )\n            ),\n            c.setLocal(\"itOut\",\n                c.i32_add(\n                    c.getLocal(\"pOut\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeOut)\n                    )\n                )\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn\", c.i32_sub(c.getLocal(\"itIn\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    } else {\n        f.addCode(\n            c.setLocal(\"itIn\", c.getLocal(\"pIn\")),\n            c.setLocal(\"itOut\", c.getLocal(\"pOut\")),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    }\n}\n\nvar build_batchop = buildBatchConvertion$2;\n\nfunction buildBatchConvertion$2(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {\n    if (typeof reverse === \"undefined\") {\n        // Set the reverse in a way that allows to use the same buffer as in/out.\n        if (sizeIn < sizeOut) {\n            reverse = true;\n        } else {\n            reverse = false;\n        }\n    }\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"pIn1\", \"i32\");\n    f.addParam(\"pIn2\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"itIn1\", \"i32\");\n    f.addLocal(\"itIn2\", \"i32\");\n    f.addLocal(\"itOut\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    if (reverse) {\n        f.addCode(\n            c.setLocal(\"itIn1\",\n                c.i32_add(\n                    c.getLocal(\"pIn1\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeIn)\n                    )\n                )\n            ),\n            c.setLocal(\"itIn2\",\n                c.i32_add(\n                    c.getLocal(\"pIn2\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeIn)\n                    )\n                )\n            ),\n            c.setLocal(\"itOut\",\n                c.i32_add(\n                    c.getLocal(\"pOut\"),\n                    c.i32_mul(\n                        c.i32_sub(\n                            c.getLocal(\"n\"),\n                            c.i32_const(1)\n                        ),\n                        c.i32_const(sizeOut)\n                    )\n                )\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn1\"), c.getLocal(\"itIn2\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn1\", c.i32_sub(c.getLocal(\"itIn1\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itIn2\", c.i32_sub(c.getLocal(\"itIn2\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    } else {\n        f.addCode(\n            c.setLocal(\"itIn1\", c.getLocal(\"pIn1\")),\n            c.setLocal(\"itIn2\", c.getLocal(\"pIn2\")),\n            c.setLocal(\"itOut\", c.getLocal(\"pOut\")),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.call(internalFnName, c.getLocal(\"itIn1\"), c.getLocal(\"itIn2\"), c.getLocal(\"itOut\")),\n\n                c.setLocal(\"itIn1\", c.i32_add(c.getLocal(\"itIn1\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itIn2\", c.i32_add(c.getLocal(\"itIn2\"), c.i32_const(sizeIn))),\n                c.setLocal(\"itOut\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(sizeOut))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n    }\n}\n\nvar bigint = {};\n\n// Many of these utilities are from the `big-integer` library,\n// but adjusted to only work with native BigInt type\n// Ref https://github.com/peterolson/BigInteger.js/blob/e5d2154d3c417069c51e7116bafc3b91d0b9fe41/BigInteger.js\n// Originally licensed The Unlicense\n\nfunction compare(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction square$1(n) {\n    return n * n;\n}\n\nfunction isOdd$4(n) {\n    return n % 2n !== 0n;\n}\n\nfunction isEven(n) {\n    return n % 2n === 0n;\n}\n\nfunction isNegative$3(n) {\n    return n < 0n;\n}\n\nfunction isPositive(n) {\n    return n > 0n;\n}\n\nfunction bitLength$5(n) {\n    if (isNegative$3(n)) {\n        return n.toString(2).length - 1; // discard the - sign\n    } else {\n        return n.toString(2).length;\n    }\n}\n\nfunction abs(n) {\n    return n < 0n ? -n : n;\n}\n\nfunction isUnit(n) {\n    return abs(n) === 1n;\n}\n\nfunction modInv$3(a, n) {\n    var t = 0n, newT = 1n, r = n, newR = abs(a), q, lastT, lastR;\n    while (newR !== 0n) {\n        q = r / newR;\n        lastT = t;\n        lastR = r;\n        t = newT;\n        r = newR;\n        newT = lastT - (q * newT);\n        newR = lastR - (q * newR);\n    }\n    if (!isUnit(r)) throw new Error(a.toString() + \" and \" + n.toString() + \" are not co-prime\");\n    if (compare(t, 0n) === -1) {\n        t = t + n;\n    }\n    if (isNegative$3(a)) {\n        return -t;\n    }\n    return t;\n}\n\nfunction modPow$2(n, exp, mod) {\n    if (mod === 0n) throw new Error(\"Cannot take modPow with modulus 0\");\n    var r = 1n,\n        base = n % mod;\n    if (isNegative$3(exp)) {\n        exp = exp * -1n;\n        base = modInv$3(base, mod);\n    }\n    while (isPositive(exp)) {\n        if (base === 0n) return 0n;\n        if (isOdd$4(exp)) r = r * base % mod;\n        exp = exp / 2n;\n        base = square$1(base) % mod;\n    }\n    return r;\n}\n\nfunction compareAbs(a, b) {\n    a = a >= 0n ? a : -a;\n    b = b >= 0n ? b : -b;\n    return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction isDivisibleBy(a, n) {\n    if (n === 0n) return false;\n    if (isUnit(n)) return true;\n    if (compareAbs(n, 2n) === 0) return isEven(a);\n    return a % n === 0n;\n}\n\nfunction isBasicPrime(v) {\n    var n = abs(v);\n    if (isUnit(n)) return false;\n    if (n === 2n || n === 3n || n === 5n) return true;\n    if (isEven(n) || isDivisibleBy(n, 3n) || isDivisibleBy(n, 5n)) return false;\n    if (n < 49n) return true;\n    // we don't know if it's prime: let the other functions figure it out\n}\n\nfunction prev(n) {\n    return n - 1n;\n}\n\nfunction millerRabinTest(n, a) {\n    var nPrev = prev(n),\n        b = nPrev,\n        r = 0,\n        d, i, x;\n    while (isEven(b)) b = b / 2n, r++;\n    next: for (i = 0; i < a.length; i++) {\n        if (n < a[i]) continue;\n        x = modPow$2(BigInt(a[i]), b, n);\n        if (isUnit(x) || x === nPrev) continue;\n        for (d = r - 1; d != 0; d--) {\n            x = square$1(x) % n;\n            if (isUnit(x)) return false;\n            if (x === nPrev) continue next;\n        }\n        return false;\n    }\n    return true;\n}\n\nfunction isPrime$1(p) {\n    var isPrime = isBasicPrime(p);\n    if (isPrime !== undefined) return isPrime;\n    var n = abs(p);\n    var bits = bitLength$5(n);\n    if (bits <= 64)\n        return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\n    var logN = Math.log(2) * Number(bits);\n    var t = Math.ceil(logN);\n    for (var a = [], i = 0; i < t; i++) {\n        a.push(BigInt(i + 2));\n    }\n    return millerRabinTest(n, a);\n}\n\nbigint.bitLength = bitLength$5;\nbigint.isOdd = isOdd$4;\nbigint.isNegative = isNegative$3;\nbigint.abs = abs;\nbigint.isUnit = isUnit;\nbigint.compare = compare;\nbigint.modInv = modInv$3;\nbigint.modPow = modPow$2;\nbigint.isPrime = isPrime$1;\nbigint.square = square$1;\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst buildInt = build_int;\nconst utils$5 = utils$6;\nconst buildExp$2 = build_timesscalar;\nconst buildBatchInverse$2 = build_batchinverse;\nconst buildBatchConvertion$1 = build_batchconvertion;\nconst buildBatchOp = build_batchop;\nconst { bitLength: bitLength$4, modInv: modInv$2, modPow: modPow$1, isPrime, isOdd: isOdd$3, square } = bigint;\n\nvar build_f1m = function buildF1m(module, _q, _prefix, _intPrefix) {\n    const q = BigInt(_q);\n    const n64 = Math.floor((bitLength$4(q - 1n) - 1)/64) +1;\n    const n32 = n64*2;\n    const n8 = n64*8;\n\n    const prefix = _prefix || \"f1m\";\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const intPrefix = buildInt(module, n64, _intPrefix);\n    const pq = module.alloc(n8, utils$5.bigInt2BytesLE(q, n8));\n\n    const pR2 = module.alloc(utils$5.bigInt2BytesLE(square(1n << BigInt(n64*64)) % q, n8));\n    const pOne = module.alloc(utils$5.bigInt2BytesLE((1n << BigInt(n64*64)) % q, n8));\n    const pZero = module.alloc(utils$5.bigInt2BytesLE(0n, n8));\n    const _minusOne = q - 1n;\n    const _e = _minusOne >> 1n; // e = (p-1)/2\n    const pe = module.alloc(n8, utils$5.bigInt2BytesLE(_e, n8));\n\n    const _ePlusOne = _e + 1n; // e = (p-1)/2\n    const pePlusOne = module.alloc(n8, utils$5.bigInt2BytesLE(_ePlusOne, n8));\n\n    module.modules[prefix] = {\n        pq: pq,\n        pR2: pR2,\n        n64: n64,\n        q: q,\n        pOne: pOne,\n        pZero: pZero,\n        pePlusOne: pePlusOne\n    };\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(intPrefix + \"_copy\", c.i32_const(pOne), c.getLocal(\"pr\")));\n    }\n\n    function buildAdd() {\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.call(intPrefix+\"_add\", c.getLocal(\"x\"),  c.getLocal(\"y\"), c.getLocal(\"r\")),\n                c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                c.if(\n                    c.call(intPrefix+\"_gte\", c.getLocal(\"r\"), c.i32_const(pq)  ),\n                    c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                )\n            )\n        );\n    }\n\n    function buildSub() {\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.call(intPrefix+\"_sub\", c.getLocal(\"x\"),  c.getLocal(\"y\"), c.getLocal(\"r\")),\n                c.drop(c.call(intPrefix+\"_add\", c.getLocal(\"r\"),  c.i32_const(pq), c.getLocal(\"r\")))\n            )\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix+\"_neg\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(prefix + \"_sub\", c.i32_const(pZero), c.getLocal(\"x\"), c.getLocal(\"r\"))\n        );\n    }\n\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(prefix + \"_fromMontgomery\", c.getLocal(\"x\"), AUX),\n            c.call(intPrefix + \"_gte\", AUX, c.i32_const(pePlusOne) )\n        );\n    }\n\n    function buildSign() {\n        const f = module.addFunction(prefix+\"_sign\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if (\n                c.call(intPrefix + \"_isZero\", c.getLocal(\"x\")),\n                c.ret(c.i32_const(0))\n            ),\n            c.call(prefix + \"_fromMontgomery\", c.getLocal(\"x\"), AUX),\n            c.if(\n                c.call(intPrefix + \"_gte\", AUX, c.i32_const(pePlusOne)),\n                c.ret(c.i32_const(-1))\n            ),\n            c.ret(c.i32_const(1))\n        );\n    }\n\n\n    function buildMReduct() {\n        const carries = module.alloc(n32*n32*8);\n\n        const f = module.addFunction(prefix+\"_mReduct\");\n        f.addParam(\"t\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"np32\", \"i64\");\n        f.addLocal(\"c\", \"i64\");\n        f.addLocal(\"m\", \"i64\");\n\n        const c = f.getCodeBuilder();\n\n        const np32 = Number(0x100000000n - modInv$2(q, 0x100000000n));\n\n        f.addCode(c.setLocal(\"np32\", c.i64_const(np32)));\n\n        for (let i=0; i<n32; i++) {\n            f.addCode(c.setLocal(\"c\", c.i64_const(0)));\n\n            f.addCode(\n                c.setLocal(\n                    \"m\",\n                    c.i64_and(\n                        c.i64_mul(\n                            c.i64_load32_u(c.getLocal(\"t\"), i*4),\n                            c.getLocal(\"np32\")\n                        ),\n                        c.i64_const(\"0xFFFFFFFF\")\n                    )\n                )\n            );\n\n            for (let j=0; j<n32; j++) {\n\n                f.addCode(\n                    c.setLocal(\"c\",\n                        c.i64_add(\n                            c.i64_add(\n                                c.i64_load32_u(c.getLocal(\"t\"), (i+j)*4),\n                                c.i64_shr_u(c.getLocal(\"c\"), c.i64_const(32))\n                            ),\n                            c.i64_mul(\n                                c.i64_load32_u(c.i32_const(pq), j*4),\n                                c.getLocal(\"m\")\n                            )\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.i64_store32(\n                        c.getLocal(\"t\"),\n                        (i+j)*4,\n                        c.getLocal(\"c\")\n                    )\n                );\n            }\n\n            f.addCode(\n                c.i64_store32(\n                    c.i32_const(carries),\n                    i*4,\n                    c.i64_shr_u(c.getLocal(\"c\"), c.i64_const(32))\n                )\n            );\n        }\n\n        f.addCode(\n            c.call(\n                prefix+\"_add\",\n                c.i32_const(carries),\n                c.i32_add(\n                    c.getLocal(\"t\"),\n                    c.i32_const(n32*4)\n                ),\n                c.getLocal(\"r\")\n            )\n        );\n    }\n\n\n\n    function buildMul() {\n\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n        f.addLocal(\"np32\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n            f.addLocal(\"y\"+i, \"i64\");\n            f.addLocal(\"m\"+i, \"i64\");\n            f.addLocal(\"q\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const np32 = Number(0x100000000n - modInv$2(q, 0x100000000n));\n\n        f.addCode(c.setLocal(\"np32\", c.i64_const(np32)));\n\n\n        const loadX = [];\n        const loadY = [];\n        const loadQ = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadY[j]) {\n                Y = c.teeLocal(\"y\"+j, c.i64_load32_u( c.getLocal(\"y\"), j*4));\n                loadY[j] = true;\n            } else {\n                Y = c.getLocal(\"y\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        function mulqm(i, j) {\n            let Q,M;\n            if (!loadQ[i]) {\n                Q = c.teeLocal(\"q\"+i, c.i64_load32_u(c.i32_const(0), pq+i*4 ));\n                loadQ[i] = true;\n            } else {\n                Q = c.getLocal(\"q\"+i);\n            }\n            M = c.getLocal(\"m\"+j);\n\n            return c.i64_mul( Q, M );\n        }\n\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            for (let i=Math.max(0, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n\n            for (let i=Math.max(1, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n            if (k<n32) {\n                f.addCode(\n                    c.setLocal(\n                        \"m\"+k,\n                        c.i64_and(\n                            c.i64_mul(\n                                c.i64_and(\n                                    c.getLocal(c0),\n                                    c.i64_const(0xFFFFFFFF)\n                                ),\n                                c.getLocal(\"np32\")\n                            ),\n                            c.i64_const(\"0xFFFFFFFF\")\n                        )\n                    )\n                );\n\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(0,k)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n\n            if (k>=n32) {\n                f.addCode(\n                    c.i64_store32(\n                        c.getLocal(\"r\"),\n                        (k-n32)*4,\n                        c.getLocal(c0)\n                    )\n                );\n            }\n            [c0, c1] = [c1, c0];\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_shr_u(\n                        c.getLocal(c0),\n                        c.i64_const(32)\n                    )\n                )\n            );\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4-4,\n                c.getLocal(c0)\n            )\n        );\n\n        f.addCode(\n            c.if(\n                c.i32_wrap_i64(c.getLocal(c1)),\n                c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                c.if(\n                    c.call(intPrefix+\"_gte\", c.getLocal(\"r\"), c.i32_const(pq)  ),\n                    c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                )\n            )\n        );\n    }\n\n\n    function buildSquare() {\n\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"c0\", \"i64\");\n        f.addLocal(\"c1\", \"i64\");\n        f.addLocal(\"c0_old\", \"i64\");\n        f.addLocal(\"c1_old\", \"i64\");\n        f.addLocal(\"np32\", \"i64\");\n\n\n        for (let i=0;i<n32; i++) {\n            f.addLocal(\"x\"+i, \"i64\");\n            f.addLocal(\"m\"+i, \"i64\");\n            f.addLocal(\"q\"+i, \"i64\");\n        }\n\n        const c = f.getCodeBuilder();\n\n        const np32 = Number(0x100000000n - modInv$2(q, 0x100000000n));\n\n        f.addCode(c.setLocal(\"np32\", c.i64_const(np32)));\n\n\n        const loadX = [];\n        const loadQ = [];\n        function mulij(i, j) {\n            let X,Y;\n            if (!loadX[i]) {\n                X = c.teeLocal(\"x\"+i, c.i64_load32_u( c.getLocal(\"x\"), i*4));\n                loadX[i] = true;\n            } else {\n                X = c.getLocal(\"x\"+i);\n            }\n            if (!loadX[j]) {\n                Y = c.teeLocal(\"x\"+j, c.i64_load32_u( c.getLocal(\"x\"), j*4));\n                loadX[j] = true;\n            } else {\n                Y = c.getLocal(\"x\"+j);\n            }\n\n            return c.i64_mul( X, Y );\n        }\n\n        function mulqm(i, j) {\n            let Q,M;\n            if (!loadQ[i]) {\n                Q = c.teeLocal(\"q\"+i, c.i64_load32_u(c.i32_const(0), pq+i*4 ));\n                loadQ[i] = true;\n            } else {\n                Q = c.getLocal(\"q\"+i);\n            }\n            M = c.getLocal(\"m\"+j);\n\n            return c.i64_mul( Q, M );\n        }\n\n\n        let c0 = \"c0\";\n        let c1 = \"c1\";\n        let c0_old = \"c0_old\";\n        let c1_old = \"c1_old\";\n\n        for (let k=0; k<n32*2-1; k++) {\n            f.addCode(\n                c.setLocal(c0, c.i64_const(0)),\n                c.setLocal(c1, c.i64_const(0)),\n            );\n            for (let i=Math.max(0, k-n32+1); (i<((k+1)>>1) )&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Multiply by 2\n            f.addCode(\n                c.setLocal(c0,\n                    c.i64_shl(\n                        c.i64_and(\n                            c.getLocal(c0),\n                            c.i64_const(0xFFFFFFFF)\n                        ),\n                        c.i64_const(1)\n                    )\n                )\n            );\n\n            f.addCode(\n                c.setLocal(c1,\n                    c.i64_add(\n                        c.i64_shl(\n                            c.getLocal(c1),\n                            c.i64_const(1)\n                        ),\n                        c.i64_shr_u(\n                            c.getLocal(c0),\n                            c.i64_const(32)\n                        )\n                    )\n                )\n            );\n\n            if (k%2 == 0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulij(k>>1, k>>1)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            // Add the old carry\n\n            if (k>0) {\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            c.i64_and(\n                                c.getLocal(c0_old),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.i64_add(\n                                c.getLocal(c1),\n                                c.i64_shr_u(\n                                    c.getLocal(c0),\n                                    c.i64_const(32)\n                                )\n                            ),\n                            c.getLocal(c1_old)\n                        )\n                    )\n                );\n            }\n\n\n            for (let i=Math.max(1, k-n32+1); (i<=k)&&(i<n32); i++) {\n                const j= k-i;\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(i,j)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n            if (k<n32) {\n                f.addCode(\n                    c.setLocal(\n                        \"m\"+k,\n                        c.i64_and(\n                            c.i64_mul(\n                                c.i64_and(\n                                    c.getLocal(c0),\n                                    c.i64_const(0xFFFFFFFF)\n                                ),\n                                c.getLocal(\"np32\")\n                            ),\n                            c.i64_const(\"0xFFFFFFFF\")\n                        )\n                    )\n                );\n\n\n                f.addCode(\n                    c.setLocal(c0,\n                        c.i64_add(\n                            c.i64_and(\n                                c.getLocal(c0),\n                                c.i64_const(0xFFFFFFFF)\n                            ),\n                            mulqm(0,k)\n                        )\n                    )\n                );\n\n                f.addCode(\n                    c.setLocal(c1,\n                        c.i64_add(\n                            c.getLocal(c1),\n                            c.i64_shr_u(\n                                c.getLocal(c0),\n                                c.i64_const(32)\n                            )\n                        )\n                    )\n                );\n            }\n\n            if (k>=n32) {\n                f.addCode(\n                    c.i64_store32(\n                        c.getLocal(\"r\"),\n                        (k-n32)*4,\n                        c.getLocal(c0)\n                    )\n                );\n            }\n            f.addCode(\n                c.setLocal(\n                    c0_old,\n                    c.getLocal(c1)\n                ),\n                c.setLocal(\n                    c1_old,\n                    c.i64_shr_u(\n                        c.getLocal(c0_old),\n                        c.i64_const(32)\n                    )\n                )\n            );\n        }\n        f.addCode(\n            c.i64_store32(\n                c.getLocal(\"r\"),\n                n32*4-4,\n                c.getLocal(c0_old)\n            )\n        );\n\n        f.addCode(\n            c.if(\n                c.i32_wrap_i64(c.getLocal(c1_old)),\n                c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                c.if(\n                    c.call(intPrefix+\"_gte\", c.getLocal(\"r\"), c.i32_const(pq)  ),\n                    c.drop(c.call(intPrefix+\"_sub\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\"))),\n                )\n            )\n        );\n    }\n\n\n    function buildSquareOld() {\n        const f = module.addFunction(prefix+\"_squareOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(prefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"x\"), c.getLocal(\"r\")));\n    }\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix+\"_toMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(prefix+\"_mul\", c.getLocal(\"x\"), c.i32_const(pR2), c.getLocal(\"r\")));\n    }\n\n    function buildFromMontgomery() {\n\n        const pAux2 = module.alloc(n8*2);\n\n        const f = module.addFunction(prefix+\"_fromMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(intPrefix + \"_copy\", c.getLocal(\"x\"), c.i32_const(pAux2) ));\n        f.addCode(c.call(intPrefix + \"_zero\", c.i32_const(pAux2 + n8) ));\n        f.addCode(c.call(prefix+\"_mReduct\", c.i32_const(pAux2), c.getLocal(\"r\")));\n    }\n\n    function buildInverse() {\n\n        const f = module.addFunction(prefix+ \"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(prefix + \"_fromMontgomery\", c.getLocal(\"x\"), c.getLocal(\"r\")));\n        f.addCode(c.call(intPrefix + \"_inverseMod\", c.getLocal(\"r\"), c.i32_const(pq), c.getLocal(\"r\")));\n        f.addCode(c.call(prefix + \"_toMontgomery\", c.getLocal(\"r\"), c.getLocal(\"r\")));\n    }\n\n    // Calculate various valuse needed for sqrt\n\n\n    let _nqr = 2n;\n    if (isPrime(q)) {\n        while (modPow$1(_nqr, _e, q) !== _minusOne) _nqr = _nqr + 1n;\n    }\n\n    let s2 = 0;\n    let _t = _minusOne;\n\n    while ((!isOdd$3(_t))&&(_t !== 0n)) {\n        s2++;\n        _t = _t >> 1n;\n    }\n    const pt = module.alloc(n8, utils$5.bigInt2BytesLE(_t, n8));\n\n    const _nqrToT = modPow$1(_nqr, _t, q);\n    const pNqrToT = module.alloc(utils$5.bigInt2BytesLE((_nqrToT << BigInt(n64*64)) % q, n8));\n\n    const _tPlusOneOver2 = (_t + 1n) >> 1n;\n    const ptPlusOneOver2 = module.alloc(n8, utils$5.bigInt2BytesLE(_tPlusOneOver2, n8));\n\n    function buildSqrt() {\n\n        const f = module.addFunction(prefix+ \"_sqrt\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"m\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const ONE = c.i32_const(pOne);\n        const C = c.i32_const(module.alloc(n8));\n        const T = c.i32_const(module.alloc(n8));\n        const R = c.i32_const(module.alloc(n8));\n        const SQ = c.i32_const(module.alloc(n8));\n        const B = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n\n            // If (n==0) return 0\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"n\")),\n                c.ret(\n                    c.call(prefix + \"_zero\", c.getLocal(\"r\"))\n                )\n            ),\n\n            c.setLocal(\"m\", c.i32_const(s2)),\n            c.call(prefix + \"_copy\", c.i32_const(pNqrToT), C),\n            c.call(prefix + \"_exp\", c.getLocal(\"n\"), c.i32_const(pt), c.i32_const(n8), T),\n            c.call(prefix + \"_exp\", c.getLocal(\"n\"), c.i32_const(ptPlusOneOver2), c.i32_const(n8), R),\n\n            c.block(c.loop(\n                c.br_if(1, c.call(prefix + \"_eq\", T, ONE)),\n\n                c.call(prefix + \"_square\", T, SQ),\n                c.setLocal(\"i\", c.i32_const(1)),\n                c.block(c.loop(\n                    c.br_if(1, c.call(prefix + \"_eq\", SQ, ONE)),\n                    c.call(prefix + \"_square\", SQ, SQ),\n                    c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n\n                c.call(prefix + \"_copy\", C, B),\n                c.setLocal(\"j\", c.i32_sub(c.i32_sub( c.getLocal(\"m\"), c.getLocal(\"i\")), c.i32_const(1)) ),\n                c.block(c.loop(\n                    c.br_if(1, c.i32_eqz(c.getLocal(\"j\"))),\n                    c.call(prefix + \"_square\", B, B),\n                    c.setLocal(\"j\", c.i32_sub(c.getLocal(\"j\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n\n                c.setLocal(\"m\", c.getLocal(\"i\")),\n                c.call(prefix + \"_square\", B, C),\n                c.call(prefix + \"_mul\", T, C, T),\n                c.call(prefix + \"_mul\", R, B, R),\n\n                c.br(0)\n            )),\n\n            c.if(\n                c.call(prefix + \"_isNegative\", R),\n                c.call(prefix + \"_neg\", R, c.getLocal(\"r\")),\n                c.call(prefix + \"_copy\", R, c.getLocal(\"r\")),\n            )\n        );\n    }\n\n    function buildIsSquare() {\n        const f = module.addFunction(prefix+\"_isSquare\");\n        f.addParam(\"n\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const ONE = c.i32_const(pOne);\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"n\")),\n                c.ret(c.i32_const(1))\n            ),\n            c.call(prefix + \"_exp\", c.getLocal(\"n\"), c.i32_const(pe), c.i32_const(n8), AUX),\n            c.call(prefix + \"_eq\", AUX, ONE)\n        );\n    }\n\n\n    function buildLoad() {\n        const f = module.addFunction(prefix+\"_load\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"p\", \"i32\");\n        f.addLocal(\"l\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        const c = f.getCodeBuilder();\n\n        const R = c.i32_const(module.alloc(n8));\n        const pAux = module.alloc(n8);\n        const AUX = c.i32_const(pAux);\n\n        f.addCode(\n            c.call(intPrefix + \"_zero\", c.getLocal(\"r\")),\n            c.setLocal(\"i\", c.i32_const(n8)),\n            c.setLocal(\"p\", c.getLocal(\"scalar\")),\n            c.block(c.loop(\n                c.br_if(1, c.i32_gt_u(c.getLocal(\"i\"), c.getLocal(\"scalarLen\"))),\n\n                c.if(\n                    c.i32_eq(c.getLocal(\"i\"), c.i32_const(n8)),\n                    c.call(prefix + \"_one\", R),\n                    c.call(prefix + \"_mul\", R, c.i32_const(pR2), R)\n                ),\n                c.call(prefix + \"_mul\", c.getLocal(\"p\"), R, AUX),\n                c.call(prefix + \"_add\", c.getLocal(\"r\"), AUX, c.getLocal(\"r\")),\n\n                c.setLocal(\"p\", c.i32_add(c.getLocal(\"p\"), c.i32_const(n8))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(n8))),\n                c.br(0)\n            )),\n\n            c.setLocal(\"l\", c.i32_rem_u( c.getLocal(\"scalarLen\"), c.i32_const(n8))),\n            c.if(c.i32_eqz(c.getLocal(\"l\")), c.ret([])),\n            c.call(intPrefix + \"_zero\", AUX),\n            c.setLocal(\"j\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq(c.getLocal(\"j\"), c.getLocal(\"l\"))),\n\n                c.i32_store8(\n                    c.getLocal(\"j\"),\n                    pAux,\n                    c.i32_load8_u(c.getLocal(\"p\")),\n                ),\n                c.setLocal(\"p\", c.i32_add(c.getLocal(\"p\"), c.i32_const(1))),\n                c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            c.if(\n                c.i32_eq(c.getLocal(\"i\"), c.i32_const(n8)),\n                c.call(prefix + \"_one\", R),\n                c.call(prefix + \"_mul\", R, c.i32_const(pR2), R)\n            ),\n            c.call(prefix + \"_mul\", AUX, R, AUX),\n            c.call(prefix + \"_add\", c.getLocal(\"r\"), AUX, c.getLocal(\"r\")),\n        );\n    }\n\n    function buildTimesScalar() {\n        const f = module.addFunction(prefix+\"_timesScalar\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(prefix + \"_load\", c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), AUX),\n            c.call(prefix + \"_toMontgomery\", AUX, AUX),\n            c.call(prefix + \"_mul\", c.getLocal(\"x\"), AUX, c.getLocal(\"r\")),\n        );\n    }\n\n    function buildIsOne() {\n        const f = module.addFunction(prefix+\"_isOne\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(\n            c.ret(c.call(intPrefix + \"_eq\", c.getLocal(\"x\"), c.i32_const(pOne)))\n        );\n    }\n\n\n    module.exportFunction(intPrefix + \"_copy\", prefix+\"_copy\");\n    module.exportFunction(intPrefix + \"_zero\", prefix+\"_zero\");\n    module.exportFunction(intPrefix + \"_isZero\", prefix+\"_isZero\");\n    module.exportFunction(intPrefix + \"_eq\", prefix+\"_eq\");\n\n    buildIsOne();\n    buildAdd();\n    buildSub();\n    buildNeg();\n    buildMReduct();\n    buildMul();\n    buildSquare();\n    buildSquareOld();\n    buildToMontgomery();\n    buildFromMontgomery();\n    buildIsNegative();\n    buildSign();\n    buildInverse();\n    buildOne();\n    buildLoad();\n    buildTimesScalar();\n    buildBatchInverse$2(module, prefix);\n    buildBatchConvertion$1(module, prefix + \"_batchToMontgomery\", prefix + \"_toMontgomery\", n8, n8);\n    buildBatchConvertion$1(module, prefix + \"_batchFromMontgomery\", prefix + \"_fromMontgomery\", n8, n8);\n    buildBatchConvertion$1(module, prefix + \"_batchNeg\", prefix + \"_neg\", n8, n8);\n    buildBatchOp(module, prefix + \"_batchAdd\", prefix + \"_add\", n8, n8);\n    buildBatchOp(module, prefix + \"_batchSub\", prefix + \"_sub\", n8, n8);\n    buildBatchOp(module, prefix + \"_batchMul\", prefix + \"_mul\", n8, n8);\n\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_isNegative\");\n    module.exportFunction(prefix + \"_isOne\");\n    module.exportFunction(prefix + \"_sign\");\n    module.exportFunction(prefix + \"_mReduct\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_squareOld\");\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_inverse\");\n    module.exportFunction(prefix + \"_one\");\n    module.exportFunction(prefix + \"_load\");\n    module.exportFunction(prefix + \"_timesScalar\");\n    buildExp$2(\n        module,\n        prefix + \"_exp\",\n        n8,\n        prefix + \"_mul\",\n        prefix + \"_square\",\n        intPrefix + \"_copy\",\n        prefix + \"_one\",\n    );\n    module.exportFunction(prefix + \"_exp\");\n    module.exportFunction(prefix + \"_batchInverse\");\n    if (isPrime(q)) {\n        buildSqrt();\n        buildIsSquare();\n        module.exportFunction(prefix + \"_sqrt\");\n        module.exportFunction(prefix + \"_isSquare\");\n    }\n    module.exportFunction(prefix + \"_batchToMontgomery\");\n    module.exportFunction(prefix + \"_batchFromMontgomery\");\n    // console.log(module.functionIdxByName);\n\n    return prefix;\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst buildF1m$2 =build_f1m;\nconst { bitLength: bitLength$3 } = bigint;\n\nvar build_f1 = function buildF1(module, _q, _prefix, _f1mPrefix, _intPrefix) {\n\n    const q = BigInt(_q);\n    const n64 = Math.floor((bitLength$3(q - 1n) - 1)/64) +1;\n    const n8 = n64*8;\n\n    const prefix = _prefix || \"f1\";\n    if (module.modules[prefix]) return prefix;  // already builded\n    module.modules[prefix] = {\n        n64: n64\n    };\n\n    const intPrefix = _intPrefix || \"int\";\n    const f1mPrefix = buildF1m$2(module, q, _f1mPrefix, intPrefix);\n\n\n    const pR2 =     module.modules[f1mPrefix].pR2;\n    const pq =     module.modules[f1mPrefix].pq;\n    const pePlusOne = module.modules[f1mPrefix].pePlusOne;\n\n    function buildMul() {\n        const pAux1 = module.alloc(n8);\n\n        const f = module.addFunction(prefix+ \"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(f1mPrefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"y\"), c.i32_const(pAux1)));\n        f.addCode(c.call(f1mPrefix + \"_mul\", c.i32_const(pAux1), c.i32_const(pR2), c.getLocal(\"r\")));\n    }\n\n    function buildSquare() {\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(prefix + \"_mul\", c.getLocal(\"x\"), c.getLocal(\"x\"), c.getLocal(\"r\")));\n    }\n\n\n    function buildInverse() {\n\n        const f = module.addFunction(prefix+ \"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n        f.addCode(c.call(intPrefix + \"_inverseMod\", c.getLocal(\"x\"), c.i32_const(pq), c.getLocal(\"r\")));\n    }\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(intPrefix + \"_gte\", c.getLocal(\"x\"), c.i32_const(pePlusOne) )\n        );\n    }\n\n\n    buildMul();\n    buildSquare();\n    buildInverse();\n    buildIsNegative();\n    module.exportFunction(f1mPrefix + \"_add\", prefix + \"_add\");\n    module.exportFunction(f1mPrefix + \"_sub\", prefix + \"_sub\");\n    module.exportFunction(f1mPrefix + \"_neg\", prefix + \"_neg\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_inverse\");\n    module.exportFunction(prefix + \"_isNegative\");\n    module.exportFunction(f1mPrefix + \"_copy\", prefix+\"_copy\");\n    module.exportFunction(f1mPrefix + \"_zero\", prefix+\"_zero\");\n    module.exportFunction(f1mPrefix + \"_one\", prefix+\"_one\");\n    module.exportFunction(f1mPrefix + \"_isZero\", prefix+\"_isZero\");\n    module.exportFunction(f1mPrefix + \"_eq\", prefix+\"_eq\");\n\n    return prefix;\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst buildExp$1 = build_timesscalar;\nconst buildBatchInverse$1 = build_batchinverse;\nconst utils$4 = utils$6;\n\nvar build_f2m = function buildF2m(module, mulNonResidueFn, prefix, f1mPrefix) {\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const f1n8 = module.modules[f1mPrefix].n64*8;\n    const q = module.modules[f1mPrefix].q;\n\n    module.modules[prefix] = {\n        n64: module.modules[f1mPrefix].n64*2\n    };\n\n    function buildAdd() {\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_add\", x0, y0, r0),\n            c.call(f1mPrefix+\"_add\", x1, y1, r1),\n        );\n    }\n\n    function buildTimesScalar() {\n        const f = module.addFunction(prefix+\"_timesScalar\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_timesScalar\", x0, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r0),\n            c.call(f1mPrefix+\"_timesScalar\", x1, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r1),\n        );\n    }\n\n    function buildSub() {\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_sub\", x0, y0, r0),\n            c.call(f1mPrefix+\"_sub\", x1, y1, r1),\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix+\"_neg\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_neg\", x0, r0),\n            c.call(f1mPrefix+\"_neg\", x1, r1),\n        );\n    }\n\n    function buildConjugate() {\n        const f = module.addFunction(prefix+\"_conjugate\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, r0),\n            c.call(f1mPrefix+\"_neg\", x1, r1),\n        );\n    }\n\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.if(\n                c.call(f1mPrefix+\"_isZero\", x1),\n                c.ret(c.call(f1mPrefix+\"_isNegative\", x0))\n            ),\n            c.ret(c.call(f1mPrefix+\"_isNegative\", x1))\n        );\n    }\n\n    function buildMul() {\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        const A = c.i32_const(module.alloc(f1n8));\n        const B = c.i32_const(module.alloc(f1n8));\n        const C = c.i32_const(module.alloc(f1n8));\n        const D = c.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n            c.call(f1mPrefix + \"_mul\", x0, y0, A),             // A = x0*y0\n            c.call(f1mPrefix + \"_mul\", x1, y1, B),             // B = x1*y1\n\n            c.call(f1mPrefix + \"_add\", x0, x1, C),             // C = x0 + x1\n            c.call(f1mPrefix + \"_add\", y0, y1, D),             // D = y0 + y1\n            c.call(f1mPrefix + \"_mul\", C, D, C),               // C = (x0 + x1)*(y0 + y1) = x0*y0+x0*y1+x1*y0+x1*y1\n\n            //  c.call(f1mPrefix + \"_mul\", B, c.i32_const(pNonResidue), r0),  // r0 = nr*(x1*y1)\n            c.call(mulNonResidueFn, B, r0),  // r0 = nr*(x1*y1)\n            c.call(f1mPrefix + \"_add\", A, r0, r0),             // r0 = x0*y0 + nr*(x1*y1)\n            c.call(f1mPrefix + \"_add\", A, B, r1),             // r1 = x0*y0+x1*y1\n            c.call(f1mPrefix + \"_sub\", C, r1, r1)              // r1 = x0*y0+x0*y1+x1*y0+x1*y1 - x0*y0+x1*y1 = x0*y1+x1*y0\n        );\n\n    }\n\n    function buildMul1() {\n        const f = module.addFunction(prefix+\"_mul1\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y = c.getLocal(\"y\");\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n\n        f.addCode(\n            c.call(f1mPrefix + \"_mul\", x0, y, r0),             // A = x0*y\n            c.call(f1mPrefix + \"_mul\", x1, y, r1),             // B = x1*y\n        );\n    }\n\n    function buildSquare() {\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        const AB = c.i32_const(module.alloc(f1n8));\n        const APB = c.i32_const(module.alloc(f1n8));\n        const APNB = c.i32_const(module.alloc(f1n8));\n        const ABPNAB = c.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n            // AB = x0*y1\n            c.call(f1mPrefix + \"_mul\", x0, x1, AB),\n\n            // APB = x0+y1\n            c.call(f1mPrefix + \"_add\", x0, x1, APB),\n\n            // APBN0 = x0 + nr*x1\n            c.call(mulNonResidueFn, x1, APNB),\n            c.call(f1mPrefix + \"_add\", x0, APNB, APNB),\n\n            // ABPNAB = ab + nr*ab\n            c.call(mulNonResidueFn, AB, ABPNAB),\n            c.call(f1mPrefix + \"_add\", ABPNAB, AB, ABPNAB),\n\n            // r0 = APB * APNB - ABPNAB\n            c.call(f1mPrefix + \"_mul\", APB, APNB, r0),\n            c.call(f1mPrefix + \"_sub\", r0, ABPNAB, r0),\n\n            // r1 = AB + AB\n            c.call(f1mPrefix + \"_add\", AB, AB, r1),\n        );\n\n    }\n\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix+\"_toMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_toMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_toMontgomery\", x1, r1)\n        );\n    }\n\n    function buildFromMontgomery() {\n        const f = module.addFunction(prefix+\"_fromMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_fromMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_fromMontgomery\", x1, r1)\n        );\n    }\n\n    function buildCopy() {\n        const f = module.addFunction(prefix+\"_copy\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, r0),\n            c.call(f1mPrefix+\"_copy\", x1, r1)\n        );\n    }\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_zero\", x0),\n            c.call(f1mPrefix+\"_zero\", x1)\n        );\n    }\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_one\", x0),\n            c.call(f1mPrefix+\"_zero\", x1)\n        );\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix+\"_eq\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.call(f1mPrefix+\"_eq\", x0, y0),\n                c.call(f1mPrefix+\"_eq\", x1, y1)\n            )\n        );\n    }\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix+\"_isZero\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.call(f1mPrefix+\"_isZero\", x0),\n                c.call(f1mPrefix+\"_isZero\", x1)\n            )\n        );\n    }\n\n    function buildInverse() {\n        const f = module.addFunction(prefix+\"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n\n        const t0 = c.i32_const(module.alloc(f1n8));\n        const t1 = c.i32_const(module.alloc(f1n8));\n        const t2 = c.i32_const(module.alloc(f1n8));\n        const t3 = c.i32_const(module.alloc(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_square\", x0, t0),\n            c.call(f1mPrefix+\"_square\", x1, t1),\n            // c.call(f1mPrefix+\"_mul\", t1, c.i32_const(pNonResidue), t2),\n            c.call(mulNonResidueFn, t1, t2),\n\n            c.call(f1mPrefix+\"_sub\", t0, t2, t2),\n            c.call(f1mPrefix+\"_inverse\", t2, t3),\n\n            c.call(f1mPrefix+\"_mul\", x0, t3, r0),\n            c.call(f1mPrefix+\"_mul\", x1, t3, r1),\n            c.call(f1mPrefix+\"_neg\", r1, r1),\n        );\n    }\n\n\n    function buildSign() {\n        const f = module.addFunction(prefix+\"_sign\");\n        f.addParam(\"x\", \"i32\");\n        f.addLocal(\"s\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.setLocal(\"s\" , c.call( f1mPrefix + \"_sign\", x1)),\n            c.if(\n                c.getLocal(\"s\"),\n                c.ret(c.getLocal(\"s\"))\n            ),\n            c.ret(c.call( f1mPrefix + \"_sign\", x0))\n        );\n    }\n\n    function buildIsOne() {\n        const f = module.addFunction(prefix+\"_isOne\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n\n        f.addCode(\n            c.ret(c.i32_and(\n                c.call(f1mPrefix + \"_isOne\", x0),\n                c.call(f1mPrefix + \"_isZero\", x1),\n            ))\n        );\n    }\n\n\n    // Check here: https://eprint.iacr.org/2012/685.pdf\n    // Alg 9adj\n    function buildSqrt() {\n\n        const f = module.addFunction(prefix+\"_sqrt\");\n        f.addParam(\"a\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        // BigInt can't take `undefined` so we use `|| 0`\n        const e34 = c.i32_const(module.alloc(utils$4.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8 )));\n        // BigInt can't take `undefined` so we use `|| 0`\n        const e12 = c.i32_const(module.alloc(utils$4.bigInt2BytesLE((BigInt(q || 0) - 1n) / 2n, f1n8 )));\n\n        const a = c.getLocal(\"a\");\n        const a1 = c.i32_const(module.alloc(f1n8*2));\n        const alpha = c.i32_const(module.alloc(f1n8*2));\n        const a0 = c.i32_const(module.alloc(f1n8*2));\n        const pn1 = module.alloc(f1n8*2);\n        const n1 = c.i32_const(pn1);\n        const n1a = c.i32_const(pn1);\n        const n1b = c.i32_const(pn1+f1n8);\n        const x0 = c.i32_const(module.alloc(f1n8*2));\n        const b = c.i32_const(module.alloc(f1n8*2));\n\n        f.addCode(\n\n            c.call(prefix + \"_one\", n1),\n            c.call(prefix + \"_neg\", n1, n1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_exp\", a, e34, c.i32_const(f1n8), a1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_square\", a1, alpha),\n            c.call(prefix + \"_mul\", a, alpha, alpha),\n\n            // const a0 = F.mul(F.frobenius(1, alfa), alfa);\n            c.call(prefix + \"_conjugate\", alpha, a0),\n            c.call(prefix + \"_mul\", a0, alpha, a0),\n\n            // if (F.eq(a0, F.negone)) return null;\n            c.if(c.call(prefix + \"_eq\",a0,n1), c.unreachable() ),\n\n            // const x0 = F.mul(a1, a);\n            c.call(prefix + \"_mul\", a1, a, x0),\n\n            // if (F.eq(alfa, F.negone)) {\n            c.if(\n                c.call(prefix + \"_eq\", alpha, n1),\n                [\n                    // x = F.mul(x0, [F.F.zero, F.F.one]);\n                    ...c.call(f1mPrefix + \"_zero\", n1a),\n                    ...c.call(f1mPrefix + \"_one\", n1b),\n                    ...c.call(prefix + \"_mul\", n1, x0, c.getLocal(\"pr\")),\n                ],\n                [\n                    // const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);\n                    ...c.call(prefix + \"_one\", b),\n                    ...c.call(prefix + \"_add\", b, alpha, b),\n                    ...c.call(prefix + \"_exp\", b, e12, c.i32_const(f1n8), b),\n\n                    // x = F.mul(b, x0);\n                    ...c.call(prefix + \"_mul\", b, x0, c.getLocal(\"pr\")),\n                ]\n            )\n        );\n\n    }\n\n\n    function buildIsSquare() {\n\n        const f = module.addFunction(prefix+\"_isSquare\");\n        f.addParam(\"a\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        // BigInt can't take `undefined` so we use `|| 0`\n        const e34 = c.i32_const(module.alloc(utils$4.bigInt2BytesLE((BigInt(q || 0) - 3n) / 4n, f1n8 )));\n\n        const a = c.getLocal(\"a\");\n        const a1 = c.i32_const(module.alloc(f1n8*2));\n        const alpha = c.i32_const(module.alloc(f1n8*2));\n        const a0 = c.i32_const(module.alloc(f1n8*2));\n        const pn1 = module.alloc(f1n8*2);\n        const n1 = c.i32_const(pn1);\n\n        f.addCode(\n\n            c.call(prefix + \"_one\", n1),\n            c.call(prefix + \"_neg\", n1, n1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_exp\", a, e34, c.i32_const(f1n8), a1),\n\n            // const a1 = F.pow(a, F.sqrt_e34);\n            c.call(prefix + \"_square\", a1, alpha),\n            c.call(prefix + \"_mul\", a, alpha, alpha),\n\n            // const a0 = F.mul(F.frobenius(1, alfa), alfa);\n            c.call(prefix + \"_conjugate\", alpha, a0),\n            c.call(prefix + \"_mul\", a0, alpha, a0),\n\n            // if (F.eq(a0, F.negone)) return null;\n            c.if(\n                c.call(\n                    prefix + \"_eq\",\n                    a0,\n                    n1\n                ),\n                c.ret(c.i32_const(0))\n            ),\n            c.ret(c.i32_const(1))\n        );\n\n    }\n\n\n    buildIsZero();\n    buildIsOne();\n    buildZero();\n    buildOne();\n    buildCopy();\n    buildMul();\n    buildMul1();\n    buildSquare();\n    buildAdd();\n    buildSub();\n    buildNeg();\n    buildConjugate();\n    buildToMontgomery();\n    buildFromMontgomery();\n    buildEq();\n    buildInverse();\n    buildTimesScalar();\n    buildSign();\n    buildIsNegative();\n\n    module.exportFunction(prefix + \"_isZero\");\n    module.exportFunction(prefix + \"_isOne\");\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_one\");\n    module.exportFunction(prefix + \"_copy\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_mul1\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_sign\");\n    module.exportFunction(prefix + \"_conjugate\");\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_eq\");\n    module.exportFunction(prefix + \"_inverse\");\n    buildBatchInverse$1(module, prefix);\n    buildExp$1(\n        module,\n        prefix + \"_exp\",\n        f1n8*2,\n        prefix + \"_mul\",\n        prefix + \"_square\",\n        prefix + \"_copy\",\n        prefix + \"_one\",\n    );\n    buildSqrt();\n    buildIsSquare();\n\n    module.exportFunction(prefix + \"_exp\");\n    module.exportFunction(prefix + \"_timesScalar\");\n    module.exportFunction(prefix + \"_batchInverse\");\n    module.exportFunction(prefix + \"_sqrt\");\n    module.exportFunction(prefix + \"_isSquare\");\n    module.exportFunction(prefix + \"_isNegative\");\n\n\n    return prefix;\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst buildExp = build_timesscalar;\nconst buildBatchInverse = build_batchinverse;\n\nvar build_f3m = function buildF3m(module, mulNonResidueFn, prefix, f1mPrefix) {\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const f1n8 = module.modules[f1mPrefix].n64*8;\n    module.modules[prefix] = {\n        n64: module.modules[f1mPrefix].n64*3\n    };\n\n    function buildAdd() {\n        const f = module.addFunction(prefix+\"_add\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const y2 = c.i32_add(c.getLocal(\"y\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_add\", x0, y0, r0),\n            c.call(f1mPrefix+\"_add\", x1, y1, r1),\n            c.call(f1mPrefix+\"_add\", x2, y2, r2),\n        );\n    }\n\n    function buildTimesScalar() {\n        const f = module.addFunction(prefix+\"_timesScalar\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"scalar\", \"i32\");\n        f.addParam(\"scalarLen\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_timesScalar\", x0, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r0),\n            c.call(f1mPrefix+\"_timesScalar\", x1, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r1),\n            c.call(f1mPrefix+\"_timesScalar\", x2, c.getLocal(\"scalar\"), c.getLocal(\"scalarLen\"), r2),\n        );\n    }\n\n\n    function buildSub() {\n        const f = module.addFunction(prefix+\"_sub\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const y2 = c.i32_add(c.getLocal(\"y\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_sub\", x0, y0, r0),\n            c.call(f1mPrefix+\"_sub\", x1, y1, r1),\n            c.call(f1mPrefix+\"_sub\", x2, y2, r2),\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix+\"_neg\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_neg\", x0, r0),\n            c.call(f1mPrefix+\"_neg\", x1, r1),\n            c.call(f1mPrefix+\"_neg\", x2, r2),\n        );\n    }\n\n    function buildIsNegative() {\n        const f = module.addFunction(prefix+\"_isNegative\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.if(\n                c.call(f1mPrefix+\"_isZero\", x2),\n                c.if(\n                    c.call(f1mPrefix+\"_isZero\", x1),\n                    c.ret(c.call(f1mPrefix+\"_isNegative\", x0)),\n                    c.ret(c.call(f1mPrefix+\"_isNegative\", x1))\n                )\n            ),\n            c.ret(c.call(f1mPrefix+\"_isNegative\", x2))\n        );\n    }\n\n\n    function buildMul() {\n        const f = module.addFunction(prefix+\"_mul\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const cd = f.getCodeBuilder();\n\n        const a = cd.getLocal(\"x\");\n        const b = cd.i32_add(cd.getLocal(\"x\"), cd.i32_const(f1n8));\n        const c = cd.i32_add(cd.getLocal(\"x\"), cd.i32_const(2*f1n8));\n        const A = cd.getLocal(\"y\");\n        const B = cd.i32_add(cd.getLocal(\"y\"), cd.i32_const(f1n8));\n        const C = cd.i32_add(cd.getLocal(\"y\"), cd.i32_const(2*f1n8));\n        const r0 = cd.getLocal(\"r\");\n        const r1 = cd.i32_add(cd.getLocal(\"r\"), cd.i32_const(f1n8));\n        const r2 = cd.i32_add(cd.getLocal(\"r\"), cd.i32_const(2*f1n8));\n\n        const aA = cd.i32_const(module.alloc(f1n8));\n        const bB = cd.i32_const(module.alloc(f1n8));\n        const cC = cd.i32_const(module.alloc(f1n8));\n        const a_b = cd.i32_const(module.alloc(f1n8));\n        const A_B = cd.i32_const(module.alloc(f1n8));\n        const a_c = cd.i32_const(module.alloc(f1n8));\n        const A_C = cd.i32_const(module.alloc(f1n8));\n        const b_c = cd.i32_const(module.alloc(f1n8));\n        const B_C = cd.i32_const(module.alloc(f1n8));\n        const aA_bB = cd.i32_const(module.alloc(f1n8));\n        const aA_cC = cd.i32_const(module.alloc(f1n8));\n        const bB_cC = cd.i32_const(module.alloc(f1n8));\n        const AUX = cd.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n            cd.call(f1mPrefix + \"_mul\", a, A, aA),\n            cd.call(f1mPrefix + \"_mul\", b, B, bB),\n            cd.call(f1mPrefix + \"_mul\", c, C, cC),\n\n            cd.call(f1mPrefix + \"_add\", a, b, a_b),\n            cd.call(f1mPrefix + \"_add\", A, B, A_B),\n            cd.call(f1mPrefix + \"_add\", a, c, a_c),\n            cd.call(f1mPrefix + \"_add\", A, C, A_C),\n            cd.call(f1mPrefix + \"_add\", b, c, b_c),\n            cd.call(f1mPrefix + \"_add\", B, C, B_C),\n\n            cd.call(f1mPrefix + \"_add\", aA, bB, aA_bB),\n            cd.call(f1mPrefix + \"_add\", aA, cC, aA_cC),\n            cd.call(f1mPrefix + \"_add\", bB, cC, bB_cC),\n\n            cd.call(f1mPrefix + \"_mul\", b_c, B_C, r0),\n            cd.call(f1mPrefix + \"_sub\", r0, bB_cC, r0),\n            cd.call(mulNonResidueFn, r0, r0),\n            cd.call(f1mPrefix + \"_add\", aA, r0, r0),\n\n            cd.call(f1mPrefix + \"_mul\", a_b, A_B, r1),\n            cd.call(f1mPrefix + \"_sub\", r1, aA_bB, r1),\n            cd.call(mulNonResidueFn, cC, AUX),\n            cd.call(f1mPrefix + \"_add\", r1, AUX, r1),\n\n            cd.call(f1mPrefix + \"_mul\", a_c, A_C, r2),\n            cd.call(f1mPrefix + \"_sub\", r2, aA_cC, r2),\n            cd.call(f1mPrefix + \"_add\", r2, bB, r2),\n        );\n\n    }\n\n    function buildSquare() {\n        const f = module.addFunction(prefix+\"_square\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const A = c.getLocal(\"x\");\n        const B = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const C = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        const s0 = c.i32_const(module.alloc(f1n8));\n        const ab = c.i32_const(module.alloc(f1n8));\n        const s1 = c.i32_const(module.alloc(f1n8));\n        const s2 = c.i32_const(module.alloc(f1n8));\n        const bc = c.i32_const(module.alloc(f1n8));\n        const s3 = c.i32_const(module.alloc(f1n8));\n        const s4 = c.i32_const(module.alloc(f1n8));\n\n\n        f.addCode(\n\n            c.call(f1mPrefix + \"_square\", A, s0),\n            c.call(f1mPrefix + \"_mul\", A, B, ab),\n            c.call(f1mPrefix + \"_add\", ab, ab, s1),\n\n            c.call(f1mPrefix + \"_sub\", A, B, s2),\n            c.call(f1mPrefix + \"_add\", s2, C, s2),\n            c.call(f1mPrefix + \"_square\", s2, s2),\n\n            c.call(f1mPrefix + \"_mul\", B, C, bc),\n            c.call(f1mPrefix + \"_add\", bc, bc, s3),\n\n            c.call(f1mPrefix + \"_square\", C, s4),\n\n            c.call(mulNonResidueFn, s3, r0),\n            c.call(f1mPrefix + \"_add\", s0, r0, r0),\n\n            c.call(mulNonResidueFn, s4, r1),\n            c.call(f1mPrefix + \"_add\", s1, r1, r1),\n\n            c.call(f1mPrefix + \"_add\", s0, s4, r2),\n            c.call(f1mPrefix + \"_sub\", s3, r2, r2),\n            c.call(f1mPrefix + \"_add\", s2, r2, r2),\n            c.call(f1mPrefix + \"_add\", s1, r2, r2),\n        );\n\n    }\n\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix+\"_toMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_toMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_toMontgomery\", x1, r1),\n            c.call(f1mPrefix+\"_toMontgomery\", x2, r2)\n        );\n    }\n\n    function buildFromMontgomery() {\n        const f = module.addFunction(prefix+\"_fromMontgomery\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_fromMontgomery\", x0, r0),\n            c.call(f1mPrefix+\"_fromMontgomery\", x1, r1),\n            c.call(f1mPrefix+\"_fromMontgomery\", x2, r2)\n        );\n    }\n\n    function buildCopy() {\n        const f = module.addFunction(prefix+\"_copy\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, r0),\n            c.call(f1mPrefix+\"_copy\", x1, r1),\n            c.call(f1mPrefix+\"_copy\", x2, r2),\n        );\n    }\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_zero\", x0),\n            c.call(f1mPrefix+\"_zero\", x1),\n            c.call(f1mPrefix+\"_zero\", x2),\n        );\n    }\n\n    function buildOne() {\n        const f = module.addFunction(prefix+\"_one\");\n        f.addParam(\"x\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_one\", x0),\n            c.call(f1mPrefix+\"_zero\", x1),\n            c.call(f1mPrefix+\"_zero\", x2),\n        );\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix+\"_eq\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"y\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const y0 = c.getLocal(\"y\");\n        const y1 = c.i32_add(c.getLocal(\"y\"), c.i32_const(f1n8));\n        const y2 = c.i32_add(c.getLocal(\"y\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.i32_and(\n                    c.call(f1mPrefix+\"_eq\", x0, y0),\n                    c.call(f1mPrefix+\"_eq\", x1, y1),\n                ),\n                c.call(f1mPrefix+\"_eq\", x2, y2)\n            )\n        );\n    }\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix+\"_isZero\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.i32_and(\n                c.i32_and(\n                    c.call(f1mPrefix+\"_isZero\", x0),\n                    c.call(f1mPrefix+\"_isZero\", x1)\n                ),\n                c.call(f1mPrefix+\"_isZero\", x2)\n            )\n        );\n    }\n\n    function buildInverse() {\n        const f = module.addFunction(prefix+\"_inverse\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n        const r0 = c.getLocal(\"r\");\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f1n8));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f1n8));\n\n        const t0 = c.i32_const(module.alloc(f1n8));\n        const t1 = c.i32_const(module.alloc(f1n8));\n        const t2 = c.i32_const(module.alloc(f1n8));\n        const t3 = c.i32_const(module.alloc(f1n8));\n        const t4 = c.i32_const(module.alloc(f1n8));\n        const t5 = c.i32_const(module.alloc(f1n8));\n        const c0 = c.i32_const(module.alloc(f1n8));\n        const c1 = c.i32_const(module.alloc(f1n8));\n        const c2 = c.i32_const(module.alloc(f1n8));\n        const t6 = c.i32_const(module.alloc(f1n8));\n        const AUX = c.i32_const(module.alloc(f1n8));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_square\", x0, t0),\n            c.call(f1mPrefix+\"_square\", x1, t1),\n            c.call(f1mPrefix+\"_square\", x2, t2),\n            c.call(f1mPrefix+\"_mul\", x0, x1, t3),\n            c.call(f1mPrefix+\"_mul\", x0, x2, t4),\n            c.call(f1mPrefix+\"_mul\", x1, x2, t5),\n\n            c.call(mulNonResidueFn, t5, c0),\n            c.call(f1mPrefix+\"_sub\", t0, c0, c0),\n\n            c.call(mulNonResidueFn, t2, c1),\n            c.call(f1mPrefix+\"_sub\", c1, t3, c1),\n\n            c.call(f1mPrefix+\"_sub\", t1, t4, c2),\n\n            c.call(f1mPrefix+\"_mul\", x2, c1, t6),\n            c.call(f1mPrefix+\"_mul\", x1, c2, AUX),\n            c.call(f1mPrefix+\"_add\", t6, AUX, t6),\n            c.call(mulNonResidueFn, t6, t6),\n            c.call(f1mPrefix+\"_mul\", x0, c0, AUX),\n            c.call(f1mPrefix+\"_add\", AUX, t6, t6),\n\n            c.call(f1mPrefix+\"_inverse\", t6, t6),\n\n            c.call(f1mPrefix+\"_mul\", t6, c0, r0),\n            c.call(f1mPrefix+\"_mul\", t6, c1, r1),\n            c.call(f1mPrefix+\"_mul\", t6, c2, r2)\n        );\n    }\n\n\n    function buildSign() {\n        const f = module.addFunction(prefix+\"_sign\");\n        f.addParam(\"x\", \"i32\");\n        f.addLocal(\"s\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f1n8));\n\n        f.addCode(\n            c.setLocal(\"s\" , c.call( f1mPrefix + \"_sign\", x2)),\n            c.if(\n                c.getLocal(\"s\"),\n                c.ret(c.getLocal(\"s\"))\n            ),\n            c.setLocal(\"s\" , c.call( f1mPrefix + \"_sign\", x1)),\n            c.if(\n                c.getLocal(\"s\"),\n                c.ret(c.getLocal(\"s\"))\n            ),\n            c.ret(c.call( f1mPrefix + \"_sign\", x0))\n        );\n    }\n\n    function buildIsOne() {\n        const f = module.addFunction(prefix+\"_isOne\");\n        f.addParam(\"x\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1n8*2));\n\n        f.addCode(\n            c.ret(\n                c.i32_and(\n                    c.i32_and(\n                        c.call(f1mPrefix + \"_isOne\", x0),\n                        c.call(f1mPrefix + \"_isZero\", x1)\n                    ),\n                    c.call(f1mPrefix + \"_isZero\", x2)\n                )\n            )\n        );\n    }\n\n    buildIsZero();\n    buildIsOne();\n    buildZero();\n    buildOne();\n    buildCopy();\n    buildMul();\n    buildSquare();\n    buildAdd();\n    buildSub();\n    buildNeg();\n    buildSign();\n    buildToMontgomery();\n    buildFromMontgomery();\n    buildEq();\n    buildInverse();\n    buildTimesScalar();\n    buildIsNegative();\n\n    module.exportFunction(prefix + \"_isZero\");\n    module.exportFunction(prefix + \"_isOne\");\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_one\");\n    module.exportFunction(prefix + \"_copy\");\n    module.exportFunction(prefix + \"_mul\");\n    module.exportFunction(prefix + \"_square\");\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_sign\");\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_eq\");\n    module.exportFunction(prefix + \"_inverse\");\n    buildBatchInverse(module, prefix);\n    buildExp(\n        module,\n        prefix + \"_exp\",\n        f1n8*3,\n        prefix + \"_mul\",\n        prefix + \"_square\",\n        prefix + \"_copy\",\n        prefix + \"_one\"\n    );\n    module.exportFunction(prefix + \"_exp\");\n    module.exportFunction(prefix + \"_timesScalar\");\n    module.exportFunction(prefix + \"_batchInverse\");\n    module.exportFunction(prefix + \"_isNegative\");\n\n    return prefix;\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar build_timesscalarnaf = function buildTimesScalarNAF(module, fnName, elementLen, opAB, opAA, opAmB, opCopy, opInit) {\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"base\", \"i32\");\n    f.addParam(\"scalar\", \"i32\");\n    f.addParam(\"scalarLength\", \"i32\");\n    f.addParam(\"r\", \"i32\");\n    f.addLocal(\"old0\", \"i32\");\n    f.addLocal(\"nbits\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"last\", \"i32\");\n    f.addLocal(\"cur\", \"i32\");\n    f.addLocal(\"carry\", \"i32\");\n    f.addLocal(\"p\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const aux = c.i32_const(module.alloc(elementLen));\n\n    function getBit(IDX) {\n        return c.i32_and(\n            c.i32_shr_u(\n                c.i32_load(\n                    c.i32_add(\n                        c.getLocal(\"scalar\"),\n                        c.i32_and(\n                            c.i32_shr_u(\n                                IDX,\n                                c.i32_const(3)\n                            ),\n                            c.i32_const(0xFFFFFFFC)\n                        )\n                    )\n                ),\n                c.i32_and(\n                    IDX,\n                    c.i32_const(0x1F)\n                )\n            ),\n            c.i32_const(1)\n        );\n    }\n\n    function pushBit(b) {\n        return [\n            ...c.i32_store8(\n                c.getLocal(\"p\"),\n                c.i32_const(b)\n            ),\n            ...c.setLocal(\n                \"p\",\n                c.i32_add(\n                    c.getLocal(\"p\"),\n                    c.i32_const(1)\n                )\n            )\n        ];\n    }\n\n    f.addCode(\n        c.if(\n            c.i32_eqz(c.getLocal(\"scalarLength\")),\n            [\n                ...c.call(opInit, c.getLocal(\"r\")),\n                ...c.ret([])\n            ]\n        ),\n        c.setLocal(\"nbits\", c.i32_shl(c.getLocal(\"scalarLength\"), c.i32_const(3))),\n        c.setLocal(\"old0\", c.i32_load(c.i32_const(0))),\n        c.setLocal(\"p\", c.getLocal(\"old0\")),\n        c.i32_store(\n            c.i32_const(0),\n            c.i32_and(\n                c.i32_add(\n                    c.i32_add(\n                        c.getLocal(\"old0\"),\n                        c.i32_const(32)\n                    ),\n                    c.getLocal(\"nbits\")\n                ),\n                c.i32_const(0xFFFFFFF8)\n            )\n        ),\n        c.setLocal(\"i\", c.i32_const(1)),\n\n        c.setLocal(\"last\",getBit(c.i32_const(0))),\n        c.setLocal(\"carry\",c.i32_const(0)),\n\n        c.block(c.loop(\n            c.br_if(1, c.i32_eq( c.getLocal(\"i\"), c.getLocal(\"nbits\"))),\n\n            c.setLocal(\"cur\", getBit(c.getLocal(\"i\"))),\n            c.if( c.getLocal(\"last\"),\n                c.if( c.getLocal(\"cur\"),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(1)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(255)\n                        ],\n                    ),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(255)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(1)\n                        ],\n                    ),\n                ),\n                c.if( c.getLocal(\"cur\"),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(1)),\n                            ...pushBit(0)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(1)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(0)\n                        ],\n                    ),\n                    c.if(c.getLocal(\"carry\"),\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(1)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(0)\n                        ]\n                        ,\n                        [\n                            ...c.setLocal(\"last\", c.i32_const(0)),\n                            ...c.setLocal(\"carry\", c.i32_const(0)),\n                            ...pushBit(0)\n                        ],\n                    ),\n                )\n            ),\n            c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        )),\n\n        c.if( c.getLocal(\"last\"),\n            c.if(c.getLocal(\"carry\"),\n                [\n                    ...pushBit(255),\n                    ...pushBit(0),\n                    ...pushBit(1)\n                ]\n                ,\n                [\n                    ...pushBit(1)\n                ],\n            ),\n            c.if(c.getLocal(\"carry\"),\n                [\n                    ...pushBit(0),\n                    ...pushBit(1)\n                ]\n            ),\n        ),\n\n        c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n\n        // p already points to the last bit\n\n        c.call(opCopy, c.getLocal(\"base\"), aux),\n\n        c.call(opInit, c.getLocal(\"r\")),\n\n        c.block(c.loop(\n\n\n            c.call(opAA, c.getLocal(\"r\"), c.getLocal(\"r\")),\n\n\n            c.setLocal(\"cur\",\n                c.i32_load8_u(\n                    c.getLocal(\"p\")\n                )\n            ),\n\n            c.if(\n                c.getLocal(\"cur\"),\n                c.if(\n                    c.i32_eq(c.getLocal(\"cur\"), c.i32_const(1)),\n                    c.call(opAB,  c.getLocal(\"r\"), aux, c.getLocal(\"r\")),\n                    c.call(opAmB, c.getLocal(\"r\"), aux, c.getLocal(\"r\")),\n                )\n            ),\n\n            c.br_if(1, c.i32_eq( c.getLocal(\"old0\"), c.getLocal(\"p\"))),\n            c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n            c.br(0)\n\n        )),\n\n        c.i32_store( c.i32_const(0), c.getLocal(\"old0\"))\n\n    );\n\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar build_multiexp = function buildMultiexp(module, prefix, fnName, opAdd, n8b) {\n\n    const n64g = module.modules[prefix].n64;\n    const n8g = n64g*8;\n\n    function buildGetChunk() {\n        const f = module.addFunction(fnName + \"_getChunk\");\n        f.addParam(\"pScalar\", \"i32\");\n        f.addParam(\"scalarSize\", \"i32\");  // Number of bytes of the scalar\n        f.addParam(\"startBit\", \"i32\");  // Bit to start extract\n        f.addParam(\"chunkSize\", \"i32\");  // Chunk size in bits\n        f.addLocal(\"bitsToEnd\", \"i32\");\n        f.addLocal(\"mask\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\"bitsToEnd\",\n                c.i32_sub(\n                    c.i32_mul(\n                        c.getLocal(\"scalarSize\"),\n                        c.i32_const(8)\n                    ),\n                    c.getLocal(\"startBit\")\n                )\n            ),\n            c.if(\n                c.i32_gt_s(\n                    c.getLocal(\"chunkSize\"),\n                    c.getLocal(\"bitsToEnd\")\n                ),\n                c.setLocal(\n                    \"mask\",\n                    c.i32_sub(\n                        c.i32_shl(\n                            c.i32_const(1),\n                            c.getLocal(\"bitsToEnd\")\n                        ),\n                        c.i32_const(1)\n                    )\n                ),\n                c.setLocal(\n                    \"mask\",\n                    c.i32_sub(\n                        c.i32_shl(\n                            c.i32_const(1),\n                            c.getLocal(\"chunkSize\")\n                        ),\n                        c.i32_const(1)\n                    )\n                )\n            ),\n            c.i32_and(\n                c.i32_shr_u(\n                    c.i32_load(\n                        c.i32_add(\n                            c.getLocal(\"pScalar\"),\n                            c.i32_shr_u(\n                                c.getLocal(\"startBit\"),\n                                c.i32_const(3)\n                            )\n                        ),\n                        0,  // offset\n                        0   // align to byte.\n                    ),\n                    c.i32_and(\n                        c.getLocal(\"startBit\"),\n                        c.i32_const(0x7)\n                    )\n                ),\n                c.getLocal(\"mask\")\n            )\n        );\n    }\n\n    function buildMutiexpChunk() {\n        const f = module.addFunction(fnName + \"_chunk\");\n        f.addParam(\"pBases\", \"i32\");\n        f.addParam(\"pScalars\", \"i32\");\n        f.addParam(\"scalarSize\", \"i32\");  // Number of points\n        f.addParam(\"n\", \"i32\");  // Number of points\n        f.addParam(\"startBit\", \"i32\");  // bit where it starts the chunk\n        f.addParam(\"chunkSize\", \"i32\");  // bit where it starts the chunk\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"nChunks\", \"i32\");\n        f.addLocal(\"itScalar\", \"i32\");\n        f.addLocal(\"endScalar\", \"i32\");\n        f.addLocal(\"itBase\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"nTable\", \"i32\");\n        f.addLocal(\"pTable\", \"i32\");\n        f.addLocal(\"idx\", \"i32\");\n        f.addLocal(\"pIdxTable\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.i32_eqz(c.getLocal(\"n\")),\n                [\n                    ...c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n\n            // Allocate memory\n\n            c.setLocal(\n                \"nTable\",\n                c.i32_shl(\n                    c.i32_const(1),\n                    c.getLocal(\"chunkSize\")\n                )\n            ),\n            c.setLocal(\"pTable\", c.i32_load( c.i32_const(0) )),\n            c.i32_store(\n                c.i32_const(0),\n                c.i32_add(\n                    c.getLocal(\"pTable\"),\n                    c.i32_mul(\n                        c.getLocal(\"nTable\"),\n                        c.i32_const(n8g)\n                    )\n                )\n            ),\n\n            // Reset Table\n            c.setLocal(\"j\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"j\"),\n                        c.getLocal(\"nTable\")\n                    )\n                ),\n\n                c.call(\n                    prefix + \"_zero\",\n                    c.i32_add(\n                        c.getLocal(\"pTable\"),\n                        c.i32_mul(\n                            c.getLocal(\"j\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            // Distribute elements\n            c.setLocal(\"itBase\", c.getLocal(\"pBases\")),\n            c.setLocal(\"itScalar\", c.getLocal(\"pScalars\")),\n            c.setLocal(\"endScalar\",\n                c.i32_add(\n                    c.getLocal(\"pScalars\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.getLocal(\"scalarSize\")\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"itScalar\"),\n                        c.getLocal(\"endScalar\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx\",\n                    c.call(fnName + \"_getChunk\",\n                        c.getLocal(\"itScalar\"),\n                        c.getLocal(\"scalarSize\"),\n                        c.getLocal(\"startBit\"),\n                        c.getLocal(\"chunkSize\")\n                    )\n                ),\n\n                c.if(\n                    c.getLocal(\"idx\"),\n                    [\n                        ...c.setLocal(\n                            \"pIdxTable\",\n                            c.i32_add(\n                                c.getLocal(\"pTable\"),\n                                c.i32_mul(\n                                    c.i32_sub(\n                                        c.getLocal(\"idx\"),\n                                        c.i32_const(1)\n                                    ),\n                                    c.i32_const(n8g)\n                                )\n                            )\n                        ),\n                        ...c.call(\n                            opAdd,\n                            c.getLocal(\"pIdxTable\"),\n                            c.getLocal(\"itBase\"),\n                            c.getLocal(\"pIdxTable\"),\n                        )\n                    ]\n                ),\n\n                c.setLocal(\"itScalar\", c.i32_add(c.getLocal(\"itScalar\"), c.getLocal(\"scalarSize\"))),\n                c.setLocal(\"itBase\", c.i32_add(c.getLocal(\"itBase\"), c.i32_const(n8b))),\n                c.br(0)\n            )),\n\n            c.call(fnName + \"_reduceTable\", c.getLocal(\"pTable\"), c.getLocal(\"chunkSize\")),\n            c.call(\n                prefix + \"_copy\",\n                c.getLocal(\"pTable\"),\n                c.getLocal(\"pr\")\n            ),\n\n\n            c.i32_store(\n                c.i32_const(0),\n                c.getLocal(\"pTable\")\n            )\n\n        );\n    }\n\n    function buildMultiexp() {\n        const f = module.addFunction(fnName);\n        f.addParam(\"pBases\", \"i32\");\n        f.addParam(\"pScalars\", \"i32\");\n        f.addParam(\"scalarSize\", \"i32\");  // Number of points\n        f.addParam(\"n\", \"i32\");  // Number of points\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"chunkSize\", \"i32\");\n        f.addLocal(\"nChunks\", \"i32\");\n        f.addLocal(\"itScalar\", \"i32\");\n        f.addLocal(\"endScalar\", \"i32\");\n        f.addLocal(\"itBase\", \"i32\");\n        f.addLocal(\"itBit\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"nTable\", \"i32\");\n        f.addLocal(\"pTable\", \"i32\");\n        f.addLocal(\"idx\", \"i32\");\n        f.addLocal(\"pIdxTable\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8g));\n\n        const pTSizes = module.alloc([\n            17, 17, 17, 17,   17, 17, 17, 17,\n            17, 17, 16, 16,   15, 14, 13, 13,\n            12, 11, 10,  9,    8,  7,  7,  6,\n            5 ,  4,  3,  2,    1,  1,  1,  1\n        ]);\n\n        f.addCode(\n            c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n            c.if(\n                c.i32_eqz(c.getLocal(\"n\")),\n                c.ret([])\n            ),\n            c.setLocal(\"chunkSize\", c.i32_load8_u( c.i32_clz(c.getLocal(\"n\")),  pTSizes )),\n            c.setLocal(\n                \"nChunks\",\n                c.i32_add(\n                    c.i32_div_u(\n                        c.i32_sub(\n                            c.i32_shl(\n                                c.getLocal(\"scalarSize\"),\n                                c.i32_const(3)\n                            ),\n                            c.i32_const(1)\n                        ),\n                        c.getLocal(\"chunkSize\")\n                    ),\n                    c.i32_const(1)\n                )\n            ),\n\n\n            // Allocate memory\n\n            c.setLocal(\n                \"itBit\",\n                c.i32_mul(\n                    c.i32_sub(\n                        c.getLocal(\"nChunks\"),\n                        c.i32_const(1)\n                    ),\n                    c.getLocal(\"chunkSize\")\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_lt_s(\n                        c.getLocal(\"itBit\"),\n                        c.i32_const(0)\n                    )\n                ),\n\n                // Double nChunk times\n                c.if(\n                    c.i32_eqz(c.call(prefix + \"_isZero\", c.getLocal(\"pr\"))),\n                    [\n                        ...c.setLocal(\"j\", c.i32_const(0)),\n                        ...c.block(c.loop(\n                            c.br_if(\n                                1,\n                                c.i32_eq(\n                                    c.getLocal(\"j\"),\n                                    c.getLocal(\"chunkSize\")\n                                )\n                            ),\n\n                            c.call(prefix + \"_double\", c.getLocal(\"pr\"), c.getLocal(\"pr\")),\n\n                            c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                            c.br(0)\n                        ))\n                    ]\n                ),\n\n                c.call(\n                    fnName + \"_chunk\",\n                    c.getLocal(\"pBases\"),\n                    c.getLocal(\"pScalars\"),\n                    c.getLocal(\"scalarSize\"),\n                    c.getLocal(\"n\"),\n                    c.getLocal(\"itBit\"),\n                    c.getLocal(\"chunkSize\"),\n                    aux\n                ),\n\n                c.call(\n                    prefix + \"_add\",\n                    c.getLocal(\"pr\"),\n                    aux,\n                    c.getLocal(\"pr\")\n                ),\n                c.setLocal(\"itBit\", c.i32_sub(c.getLocal(\"itBit\"), c.getLocal(\"chunkSize\"))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildReduceTable() {\n        const f = module.addFunction(fnName + \"_reduceTable\");\n        f.addParam(\"pTable\", \"i32\");\n        f.addParam(\"p\", \"i32\");  // Number of bits of the table\n        f.addLocal(\"half\", \"i32\");\n        f.addLocal(\"it1\", \"i32\");\n        f.addLocal(\"it2\", \"i32\");\n        f.addLocal(\"pAcc\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.if(\n                c.i32_eq(c.getLocal(\"p\"), c.i32_const(1)),\n                c.ret([])\n            ),\n            c.setLocal(\n                \"half\",\n                c.i32_shl(\n                    c.i32_const(1),\n                    c.i32_sub(\n                        c.getLocal(\"p\"),\n                        c.i32_const(1)\n                    )\n                )\n            ),\n\n            c.setLocal(\"it1\", c.getLocal(\"pTable\")),\n            c.setLocal(\n                \"it2\",\n                c.i32_add(\n                    c.getLocal(\"pTable\"),\n                    c.i32_mul(\n                        c.getLocal(\"half\"),\n                        c.i32_const(n8g)\n                    )\n                )\n            ),\n            c.setLocal(\"pAcc\",\n                c.i32_sub(\n                    c.getLocal(\"it2\"),\n                    c.i32_const(n8g)\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"it1\"),\n                        c.getLocal(\"pAcc\")\n                    )\n                ),\n                c.call(\n                    prefix + \"_add\",\n                    c.getLocal(\"it1\"),\n                    c.getLocal(\"it2\"),\n                    c.getLocal(\"it1\")\n                ),\n                c.call(\n                    prefix + \"_add\",\n                    c.getLocal(\"pAcc\"),\n                    c.getLocal(\"it2\"),\n                    c.getLocal(\"pAcc\")\n                ),\n                c.setLocal(\"it1\", c.i32_add(c.getLocal(\"it1\"), c.i32_const(n8g))),\n                c.setLocal(\"it2\", c.i32_add(c.getLocal(\"it2\"), c.i32_const(n8g))),\n                c.br(0)\n            )),\n\n            c.call(\n                fnName + \"_reduceTable\",\n                c.getLocal(\"pTable\"),\n                c.i32_sub(\n                    c.getLocal(\"p\"),\n                    c.i32_const(1)\n                )\n            ),\n\n            c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eqz(c.getLocal(\"p\"))),\n                c.call(prefix + \"_double\", c.getLocal(\"pAcc\"), c.getLocal(\"pAcc\")),\n                c.setLocal(\"p\", c.i32_sub(c.getLocal(\"p\"), c.i32_const(1))),\n                c.br(0)\n            )),\n\n            c.call(prefix + \"_add\", c.getLocal(\"pTable\"), c.getLocal(\"pAcc\"), c.getLocal(\"pTable\"))\n        );\n    }\n\n    buildGetChunk();\n    buildReduceTable();\n    buildMutiexpChunk();\n    buildMultiexp();\n\n    module.exportFunction(fnName);\n    module.exportFunction(fnName +\"_chunk\");\n\n\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst buildTimesScalarNAF = build_timesscalarnaf;\n//const buildTimesScalar = require(\"./build_timesscalar\");\nconst buildBatchConvertion = build_batchconvertion;\nconst buildMultiexp$1 = build_multiexp;\n\nvar build_curve_jacobian_a0 = function buildCurve(module, prefix, prefixField, pB) {\n\n\n    const n64 = module.modules[prefixField].n64;\n    const n8 = n64*8;\n\n    if (module.modules[prefix]) return prefix;  // already builded\n    module.modules[prefix] = {\n        n64: n64*3\n    };\n\n    function buildIsZero() {\n        const f = module.addFunction(prefix + \"_isZero\");\n        f.addParam(\"p1\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_isZero\",\n            c.i32_add(\n                c.getLocal(\"p1\"),\n                c.i32_const(n8*2)\n            )\n        ));\n    }\n    function buildIsZeroAffine() {\n        const f = module.addFunction(prefix + \"_isZeroAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.i32_and(\n                c.call(\n                    prefixField + \"_isZero\",\n                    c.getLocal(\"p1\")\n                ),\n                c.call(\n                    prefixField + \"_isZero\",\n                    c.i32_add(\n                        c.getLocal(\"p1\"),\n                        c.i32_const(n8)\n                    )\n                )\n            )\n        );\n    }\n\n    function buildCopy() {\n        const f = module.addFunction(prefix + \"_copy\");\n        f.addParam(\"ps\", \"i32\");\n        f.addParam(\"pd\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64*3; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pd\"),\n                    i*8,\n                    c.i64_load(\n                        c.getLocal(\"ps\"),\n                        i*8\n                    )\n                )\n            );\n        }\n    }\n\n\n    function buildCopyAffine() {\n        const f = module.addFunction(prefix + \"_copyAffine\");\n        f.addParam(\"ps\", \"i32\");\n        f.addParam(\"pd\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<n64*2; i++) {\n            f.addCode(\n                c.i64_store(\n                    c.getLocal(\"pd\"),\n                    i*8,\n                    c.i64_load(\n                        c.getLocal(\"ps\"),\n                        i*8\n                    )\n                )\n            );\n        }\n\n    }\n\n\n    function buildZero() {\n        const f = module.addFunction(prefix + \"_zero\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.getLocal(\"pr\")\n        ));\n\n        f.addCode(c.call(\n            prefixField + \"_one\",\n            c.i32_add(\n                c.getLocal(\"pr\"),\n                c.i32_const(n8)\n            )\n        ));\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.i32_add(\n                c.getLocal(\"pr\"),\n                c.i32_const(n8*2)\n            )\n        ));\n    }\n\n\n    function buildZeroAffine() {\n        const f = module.addFunction(prefix + \"_zeroAffine\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.getLocal(\"pr\")\n        ));\n\n        f.addCode(c.call(\n            prefixField + \"_zero\",\n            c.i32_add(\n                c.getLocal(\"pr\"),\n                c.i32_const(n8)\n            )\n        ));\n    }\n\n    function buildEq() {\n        const f = module.addFunction(prefix + \"_eq\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"z1\", \"i32\");\n        f.addLocal(\"z2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z2\", c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8*2))));\n        const z2 = c.getLocal(\"z2\");\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const Z2Z2 = c.i32_const(module.alloc(n8));\n        const U1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const Z2_cubed = c.i32_const(module.alloc(n8));\n        const S1 = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                c.ret( c.call(prefix + \"_isZero\", c.getLocal(\"p2\"))),\n            ),\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p2\")),\n                c.ret(c.i32_const(0))\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                c.ret(c.call(prefix + \"_eqMixed\", c.getLocal(\"p2\"), c.getLocal(\"p1\")))\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z2),\n                c.ret(c.call(prefix + \"_eqMixed\", c.getLocal(\"p1\"), c.getLocal(\"p2\")))\n            ),\n\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_square\", z2, Z2Z2),\n            c.call(prefixField + \"_mul\", x1, Z2Z2, U1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", z2, Z2Z2, Z2_cubed),\n            c.call(prefixField + \"_mul\", y1, Z2_cubed, S1),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", U1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", S1, S2),\n                    c.ret(c.i32_const(1))\n                )\n            ),\n            c.ret(c.i32_const(0))\n        );\n    }\n\n\n    function buildEqMixed() {\n        const f = module.addFunction(prefix + \"_eqMixed\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                c.ret( c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\"))),\n            ),\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\")),\n                c.ret(c.i32_const(0))\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                c.ret(c.call(prefix + \"_eqAffine\", c.getLocal(\"p1\"), c.getLocal(\"p2\")))\n            ),\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", x1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", y1, S2),\n                    c.ret(c.i32_const(1))\n                )\n            ),\n            c.ret(c.i32_const(0))\n        );\n    }\n\n    function buildDouble() {\n        const f = module.addFunction(prefix + \"_double\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const A = c.i32_const(module.alloc(n8));\n        const B = c.i32_const(module.alloc(n8));\n        const C = c.i32_const(module.alloc(n8));\n        const D = c.i32_const(module.alloc(n8));\n        const E = c.i32_const(module.alloc(n8));\n        const F = c.i32_const(module.alloc(n8));\n        const G = c.i32_const(module.alloc(n8));\n        const eightC = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z),\n                [\n                    ...c.ret(c.call(prefix + \"_doubleAffine\", c.getLocal(\"p1\"), c.getLocal(\"pr\"))),\n                    ...c.ret([])\n                ]\n            ),\n\n            c.call(prefixField + \"_square\", x, A),\n            c.call(prefixField + \"_square\", y, B),\n            c.call(prefixField + \"_square\", B, C),\n\n            c.call(prefixField + \"_add\", x, B, D),\n            c.call(prefixField + \"_square\", D, D),\n            c.call(prefixField + \"_sub\", D, A, D),\n            c.call(prefixField + \"_sub\", D, C, D),\n            c.call(prefixField + \"_add\", D, D, D),\n\n            c.call(prefixField + \"_add\", A, A, E),\n            c.call(prefixField + \"_add\", E, A, E),\n            c.call(prefixField + \"_square\", E, F),\n\n            c.call(prefixField + \"_mul\", y, z, G),\n\n            c.call(prefixField + \"_add\", D, D, x3),\n            c.call(prefixField + \"_sub\", F, x3, x3),\n\n            c.call(prefixField + \"_add\", C, C, eightC),\n            c.call(prefixField + \"_add\", eightC, eightC, eightC),\n            c.call(prefixField + \"_add\", eightC, eightC, eightC),\n\n            c.call(prefixField + \"_sub\", D, x3, y3),\n            c.call(prefixField + \"_mul\", y3, E, y3),\n            c.call(prefixField + \"_sub\", y3, eightC, y3),\n\n            c.call(prefixField + \"_add\", G, G, z3),\n        );\n    }\n\n\n    function buildDoubleAffine() {\n        const f = module.addFunction(prefix + \"_doubleAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const XX = c.i32_const(module.alloc(n8));\n        const YY = c.i32_const(module.alloc(n8));\n        const YYYY = c.i32_const(module.alloc(n8));\n        const S = c.i32_const(module.alloc(n8));\n        const M = c.i32_const(module.alloc(n8));\n        const eightYYYY = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_toJacobian\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n\n            // XX = X1^2\n            c.call(prefixField + \"_square\", x, XX),\n\n            // YY = Y1^2\n            c.call(prefixField + \"_square\", y, YY),\n\n            // YYYY = YY^2\n            c.call(prefixField + \"_square\", YY, YYYY),\n\n            // S = 2*((X1+YY)^2-XX-YYYY)\n            c.call(prefixField + \"_add\", x, YY, S),\n            c.call(prefixField + \"_square\", S, S),\n            c.call(prefixField + \"_sub\", S, XX, S),\n            c.call(prefixField + \"_sub\", S, YYYY, S),\n            c.call(prefixField + \"_add\", S, S, S),\n\n            // M = 3*XX+a  (Hera a=0)\n            c.call(prefixField + \"_add\", XX, XX, M),\n            c.call(prefixField + \"_add\", M, XX, M),\n\n            // Z3 = 2*Y1\n            c.call(prefixField + \"_add\", y, y, z3),\n\n            // T = M^2-2*S\n            // X3 = T\n            c.call(prefixField + \"_square\", M, x3),\n            c.call(prefixField + \"_sub\", x3, S, x3),\n            c.call(prefixField + \"_sub\", x3, S, x3),\n\n            // Y3 = M*(S-T)-8*YYYY\n            c.call(prefixField + \"_add\", YYYY, YYYY, eightYYYY),\n            c.call(prefixField + \"_add\", eightYYYY, eightYYYY, eightYYYY),\n            c.call(prefixField + \"_add\", eightYYYY, eightYYYY, eightYYYY),\n            c.call(prefixField + \"_sub\", S, x3, y3),\n            c.call(prefixField + \"_mul\", y3, M, y3),\n            c.call(prefixField + \"_sub\", y3, eightYYYY, y3),\n        );\n    }\n\n\n    function buildEqAffine() {\n        const f = module.addFunction(prefix + \"_eqAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.ret(c.i32_and(\n                c.call(\n                    prefixField + \"_eq\",\n                    c.getLocal(\"p1\"),\n                    c.getLocal(\"p2\")\n                ),\n                c.call(\n                    prefixField + \"_eq\",\n                    c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8)),\n                    c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8))\n                )\n            ))\n        );\n    }\n\n    function buildToMontgomery() {\n        const f = module.addFunction(prefix + \"_toMontgomery\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_toMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<3; i++) {\n            f.addCode(c.call(\n                prefixField + \"_toMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n    function buildToMontgomeryAffine() {\n        const f = module.addFunction(prefix + \"_toMontgomeryAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_toMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<2; i++) {\n            f.addCode(c.call(\n                prefixField + \"_toMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n    function buildFromMontgomery() {\n        const f = module.addFunction(prefix + \"_fromMontgomery\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_fromMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<3; i++) {\n            f.addCode(c.call(\n                prefixField + \"_fromMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n\n    function buildFromMontgomeryAffine() {\n        const f = module.addFunction(prefix + \"_fromMontgomeryAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(c.call(\n            prefixField + \"_fromMontgomery\",\n            c.getLocal(\"p1\"),\n            c.getLocal(\"pr\")\n        ));\n        for (let i=1; i<2; i++) {\n            f.addCode(c.call(\n                prefixField + \"_fromMontgomery\",\n                c.i32_add(c.getLocal(\"p1\"), c.i32_const(i*n8)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(i*n8))\n            ));\n        }\n    }\n\n    function buildAdd() {\n\n        const f = module.addFunction(prefix + \"_add\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"z1\", \"i32\");\n        f.addLocal(\"z2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z2\", c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8*2))));\n        const z2 = c.getLocal(\"z2\");\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const Z2Z2 = c.i32_const(module.alloc(n8));\n        const U1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const Z2_cubed = c.i32_const(module.alloc(n8));\n        const S1 = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n        const H = c.i32_const(module.alloc(n8));\n        const S2_minus_S1 = c.i32_const(module.alloc(n8));\n        const I = c.i32_const(module.alloc(n8));\n        const J = c.i32_const(module.alloc(n8));\n        const r = c.i32_const(module.alloc(n8));\n        const r2 = c.i32_const(module.alloc(n8));\n        const V = c.i32_const(module.alloc(n8));\n        const V2 = c.i32_const(module.alloc(n8));\n        const S1_J2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p2\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                [\n                    ...c.call(prefix + \"_addMixed\", x2, x1, x3),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z2),\n                [\n                    ...c.call(prefix + \"_addMixed\", x1, x2, x3),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_square\", z2, Z2Z2),\n            c.call(prefixField + \"_mul\", x1, Z2Z2, U1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", z2, Z2Z2, Z2_cubed),\n            c.call(prefixField + \"_mul\", y1, Z2_cubed, S1),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", U1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", S1, S2),\n                    [\n                        ...c.call(prefix + \"_double\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                        ...c.ret([])\n                    ]\n                )\n            ),\n\n            c.call(prefixField + \"_sub\", U2, U1, H),\n            c.call(prefixField + \"_sub\", S2, S1, S2_minus_S1),\n            c.call(prefixField + \"_add\", H, H, I),\n            c.call(prefixField + \"_square\", I, I),\n            c.call(prefixField + \"_mul\", H, I, J),\n            c.call(prefixField + \"_add\", S2_minus_S1, S2_minus_S1, r),\n            c.call(prefixField + \"_mul\", U1, I, V),\n            c.call(prefixField + \"_square\", r, r2),\n            c.call(prefixField + \"_add\", V, V, V2),\n\n            c.call(prefixField + \"_sub\", r2, J, x3),\n            c.call(prefixField + \"_sub\", x3, V2, x3),\n\n            c.call(prefixField + \"_mul\", S1, J, S1_J2),\n            c.call(prefixField + \"_add\", S1_J2, S1_J2, S1_J2),\n\n            c.call(prefixField + \"_sub\", V, x3, y3),\n            c.call(prefixField + \"_mul\", y3, r, y3),\n            c.call(prefixField + \"_sub\", y3, S1_J2, y3),\n\n            c.call(prefixField + \"_add\", z1, z2, z3),\n            c.call(prefixField + \"_square\", z3, z3),\n            c.call(prefixField + \"_sub\", z3, Z1Z1, z3),\n            c.call(prefixField + \"_sub\", z3, Z2Z2, z3),\n            c.call(prefixField + \"_mul\", z3, H, z3),\n        );\n\n    }\n\n\n    function buildAddMixed() {\n\n        const f = module.addFunction(prefix + \"_addMixed\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const z1 = c.getLocal(\"z1\");\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const Z1Z1 = c.i32_const(module.alloc(n8));\n        const U2 = c.i32_const(module.alloc(n8));\n        const Z1_cubed = c.i32_const(module.alloc(n8));\n        const S2 = c.i32_const(module.alloc(n8));\n        const H = c.i32_const(module.alloc(n8));\n        const HH = c.i32_const(module.alloc(n8));\n        const S2_minus_y1 = c.i32_const(module.alloc(n8));\n        const I = c.i32_const(module.alloc(n8));\n        const J = c.i32_const(module.alloc(n8));\n        const r = c.i32_const(module.alloc(n8));\n        const r2 = c.i32_const(module.alloc(n8));\n        const V = c.i32_const(module.alloc(n8));\n        const V2 = c.i32_const(module.alloc(n8));\n        const y1_J2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copyAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                    ...c.call(prefixField + \"_one\", c.i32_add(c.getLocal(\"pr\") , c.i32_const(n8*2))),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\")),\n                [\n                    ...c.call(prefix + \"_copy\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefixField + \"_isOne\", z1),\n                [\n                    ...c.call(prefix + \"_addAffine\", x1, x2, x3),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefixField + \"_square\", z1, Z1Z1),\n            c.call(prefixField + \"_mul\", x2, Z1Z1, U2),\n            c.call(prefixField + \"_mul\", z1, Z1Z1, Z1_cubed),\n            c.call(prefixField + \"_mul\", y2, Z1_cubed, S2),\n\n            c.if(\n                c.call(prefixField + \"_eq\", x1, U2),\n                c.if(\n                    c.call(prefixField + \"_eq\", y1, S2),\n                    [\n                        ...c.call(prefix + \"_doubleAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                        ...c.ret([])\n                    ]\n                )\n            ),\n\n            c.call(prefixField + \"_sub\", U2, x1, H),\n            c.call(prefixField + \"_sub\", S2, y1, S2_minus_y1),\n            c.call(prefixField + \"_square\", H, HH),\n            c.call(prefixField + \"_add\", HH , HH, I),\n            c.call(prefixField + \"_add\", I , I, I),\n            c.call(prefixField + \"_mul\", H, I, J),\n            c.call(prefixField + \"_add\", S2_minus_y1, S2_minus_y1, r),\n            c.call(prefixField + \"_mul\", x1, I, V),\n            c.call(prefixField + \"_square\", r, r2),\n            c.call(prefixField + \"_add\", V, V, V2),\n\n            c.call(prefixField + \"_sub\", r2, J, x3),\n            c.call(prefixField + \"_sub\", x3, V2, x3),\n\n            c.call(prefixField + \"_mul\", y1, J, y1_J2),\n            c.call(prefixField + \"_add\", y1_J2, y1_J2, y1_J2),\n\n            c.call(prefixField + \"_sub\", V, x3, y3),\n            c.call(prefixField + \"_mul\", y3, r, y3),\n            c.call(prefixField + \"_sub\", y3, y1_J2, y3),\n\n            c.call(prefixField + \"_add\", z1, H, z3),\n            c.call(prefixField + \"_square\", z3, z3),\n            c.call(prefixField + \"_sub\", z3, Z1Z1, z3),\n            c.call(prefixField + \"_sub\", z3, HH, z3),\n        );\n    }\n\n\n    function buildAddAffine() {\n\n        const f = module.addFunction(prefix + \"_addAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"z1\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x1 = c.getLocal(\"p1\");\n        const y1 = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        f.addCode(c.setLocal(\"z1\", c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2))));\n        const x2 = c.getLocal(\"p2\");\n        const y2 = c.i32_add(c.getLocal(\"p2\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        const H = c.i32_const(module.alloc(n8));\n        const HH = c.i32_const(module.alloc(n8));\n        const y2_minus_y1 = c.i32_const(module.alloc(n8));\n        const I = c.i32_const(module.alloc(n8));\n        const J = c.i32_const(module.alloc(n8));\n        const r = c.i32_const(module.alloc(n8));\n        const r2 = c.i32_const(module.alloc(n8));\n        const V = c.i32_const(module.alloc(n8));\n        const V2 = c.i32_const(module.alloc(n8));\n        const y1_J2 = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefix + \"_copyAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                    ...c.call(prefixField + \"_one\", c.i32_add(c.getLocal(\"pr\") , c.i32_const(n8*2))),\n                    ...c.ret([])\n                ]\n            ),\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p2\")),\n                [\n                    ...c.call(prefix + \"_copyAffine\", c.getLocal(\"p1\"), c.getLocal(\"pr\")),\n                    ...c.call(prefixField + \"_one\", c.i32_add(c.getLocal(\"pr\") , c.i32_const(n8*2))),\n                    ...c.ret([])\n                ]\n            ),\n\n\n            c.if(\n                c.call(prefixField + \"_eq\", x1, x2),\n                c.if(\n                    c.call(prefixField + \"_eq\", y1, y2),\n                    [\n                        ...c.call(prefix + \"_doubleAffine\", c.getLocal(\"p2\"), c.getLocal(\"pr\")),\n                        ...c.ret([])\n                    ]\n                )\n            ),\n\n            c.call(prefixField + \"_sub\", x2, x1, H),\n            c.call(prefixField + \"_sub\", y2, y1, y2_minus_y1),\n            c.call(prefixField + \"_square\", H, HH),\n            c.call(prefixField + \"_add\", HH , HH, I),\n            c.call(prefixField + \"_add\", I , I, I),\n            c.call(prefixField + \"_mul\", H, I, J),\n            c.call(prefixField + \"_add\", y2_minus_y1, y2_minus_y1, r),\n            c.call(prefixField + \"_mul\", x1, I, V),\n            c.call(prefixField + \"_square\", r, r2),\n            c.call(prefixField + \"_add\", V, V, V2),\n\n            c.call(prefixField + \"_sub\", r2, J, x3),\n            c.call(prefixField + \"_sub\", x3, V2, x3),\n\n            c.call(prefixField + \"_mul\", y1, J, y1_J2),\n            c.call(prefixField + \"_add\", y1_J2, y1_J2, y1_J2),\n\n            c.call(prefixField + \"_sub\", V, x3, y3),\n            c.call(prefixField + \"_mul\", y3, r, y3),\n            c.call(prefixField + \"_sub\", y3, y1_J2, y3),\n\n            c.call(prefixField + \"_add\", H, H, z3),\n        );\n    }\n\n    function buildNeg() {\n        const f = module.addFunction(prefix + \"_neg\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        f.addCode(\n            c.call(prefixField + \"_copy\", x, x3),\n            c.call(prefixField + \"_neg\", y, y3),\n            c.call(prefixField + \"_copy\", z, z3)\n        );\n    }\n\n\n    function buildNegAffine() {\n        const f = module.addFunction(prefix + \"_negAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n\n        f.addCode(\n            c.call(prefixField + \"_copy\", x, x3),\n            c.call(prefixField + \"_neg\", y, y3),\n        );\n    }\n\n\n    function buildSub() {\n        const f = module.addFunction(prefix + \"_sub\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8*3));\n\n        f.addCode(\n            c.call(prefix + \"_neg\", c.getLocal(\"p2\"), AUX),\n            c.call(prefix + \"_add\", c.getLocal(\"p1\"), AUX, c.getLocal(\"pr\")),\n        );\n    }\n\n    function buildSubMixed() {\n        const f = module.addFunction(prefix + \"_subMixed\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8*3));\n\n        f.addCode(\n            c.call(prefix + \"_negAffine\", c.getLocal(\"p2\"), AUX),\n            c.call(prefix + \"_addMixed\", c.getLocal(\"p1\"), AUX, c.getLocal(\"pr\")),\n        );\n    }\n\n\n    function buildSubAffine() {\n        const f = module.addFunction(prefix + \"_subAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"p2\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8*3));\n\n        f.addCode(\n            c.call(prefix + \"_negAffine\", c.getLocal(\"p2\"), AUX),\n            c.call(prefix + \"_addAffine\", c.getLocal(\"p1\"), AUX, c.getLocal(\"pr\")),\n        );\n    }\n\n    // This sets Z to One\n    function buildNormalize() {\n        const f = module.addFunction(prefix + \"_normalize\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n\n        const Z_inv = c.i32_const(module.alloc(n8));\n        const Z2_inv = c.i32_const(module.alloc(n8));\n        const Z3_inv = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n                [\n                    ...c.call(prefixField + \"_inverse\", z, Z_inv),\n                    ...c.call(prefixField + \"_square\", Z_inv, Z2_inv),\n                    ...c.call(prefixField + \"_mul\", Z_inv, Z2_inv, Z3_inv),\n                    ...c.call(prefixField + \"_mul\", x, Z2_inv, x3),\n                    ...c.call(prefixField + \"_mul\", y, Z3_inv, y3),\n                    ...c.call(prefixField + \"_one\", z3),\n                ]\n            )\n        );\n    }\n\n\n    // Does not set Z.\n    function buildToAffine() {\n        const f = module.addFunction(prefix + \"_toAffine\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n\n\n        const Z_inv = c.i32_const(module.alloc(n8));\n        const Z2_inv = c.i32_const(module.alloc(n8));\n        const Z3_inv = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZero\", c.getLocal(\"p1\")),\n                [\n                    ...c.call(prefixField + \"_zero\", x3),\n                    ...c.call(prefixField + \"_zero\", y3),\n                ],\n                [\n                    ...c.call(prefixField + \"_inverse\", z, Z_inv),\n                    ...c.call(prefixField + \"_square\", Z_inv, Z2_inv),\n                    ...c.call(prefixField + \"_mul\", Z_inv, Z2_inv, Z3_inv),\n                    ...c.call(prefixField + \"_mul\", x, Z2_inv, x3),\n                    ...c.call(prefixField + \"_mul\", y, Z3_inv, y3),\n                ]\n            )\n        );\n    }\n\n\n    function buildToJacobian() {\n        const f = module.addFunction(prefix + \"_toJacobian\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(n8));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"p1\")),\n                c.call(prefix + \"_zero\", c.getLocal(\"pr\")),\n                [\n                    ...c.call(prefixField + \"_one\", z3),\n                    ...c.call(prefixField + \"_copy\", y, y3),\n                    ...c.call(prefixField + \"_copy\", x, x3)\n                ]\n            )\n        );\n    }\n\n    function buildBatchToAffine() {\n        const f = module.addFunction(prefix + \"_batchToAffine\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n        f.addLocal(\"pAux\", \"i32\");\n        f.addLocal(\"itIn\", \"i32\");\n        f.addLocal(\"itAux\", \"i32\");\n        f.addLocal(\"itOut\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const tmp = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"pAux\", c.i32_load( c.i32_const(0) )),\n            c.i32_store(\n                c.i32_const(0),\n                c.i32_add(\n                    c.getLocal(\"pAux\"),\n                    c.i32_mul(c.getLocal(\"n\"), c.i32_const(n8))\n                )\n            ),\n\n            c.call(\n                prefixField + \"_batchInverse\",\n                c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8*2)),\n                c.i32_const(n8*3),\n                c.getLocal(\"n\"),\n                c.getLocal(\"pAux\"),\n                c.i32_const(n8)\n            ),\n\n            c.setLocal(\"itIn\", c.getLocal(\"pIn\")),\n            c.setLocal(\"itAux\", c.getLocal(\"pAux\")),\n            c.setLocal(\"itOut\", c.getLocal(\"pOut\")),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n                c.if(\n                    c.call(prefixField + \"_isZero\", c.getLocal(\"itAux\")),\n                    [\n                        ...c.call(prefixField + \"_zero\", c.getLocal(\"itOut\")),\n                        ...c.call(prefixField + \"_zero\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(n8)))\n                    ],\n                    [\n                        ...c.call(\n                            prefixField+\"_mul\",\n                            c.getLocal(\"itAux\"),\n                            c.i32_add(c.getLocal(\"itIn\"), c.i32_const(n8)),\n                            tmp,\n                        ),\n                        ...c.call(\n                            prefixField+\"_square\",\n                            c.getLocal(\"itAux\"),\n                            c.getLocal(\"itAux\")\n                        ),\n                        ...c.call(\n                            prefixField+\"_mul\",\n                            c.getLocal(\"itAux\"),\n                            c.getLocal(\"itIn\"),\n                            c.getLocal(\"itOut\"),\n                        ),\n                        ...c.call(\n                            prefixField+\"_mul\",\n                            c.getLocal(\"itAux\"),\n                            tmp,\n                            c.i32_add(c.getLocal(\"itOut\"), c.i32_const(n8)),\n                        ),\n                    ]\n                ),\n\n                c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.i32_const(n8*3))),\n                c.setLocal(\"itOut\", c.i32_add(c.getLocal(\"itOut\"), c.i32_const(n8*2))),\n                c.setLocal(\"itAux\", c.i32_add(c.getLocal(\"itAux\"), c.i32_const(n8))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n            c.i32_store(\n                c.i32_const(0),\n                c.getLocal(\"pAux\")\n            )\n        );\n    }\n\n\n    // This function is private and does not allow to OVERLAP buffers.\n    function buildReverseBytes() {\n        const f = module.addFunction(prefix + \"__reverseBytes\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n        f.addLocal(\"itOut\", \"i32\");\n        f.addLocal(\"itIn\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\n                \"itOut\",\n                c.i32_sub(\n                    c.i32_add(\n                        c.getLocal(\"pOut\"),\n                        c.getLocal(\"n\")\n                    ),\n                    c.i32_const(1)\n                )\n            ),\n            c.setLocal(\n                \"itIn\",\n                c.getLocal(\"pIn\")\n            ),\n            c.block(c.loop(\n                c.br_if(1, c.i32_lt_s( c.getLocal(\"itOut\"), c.getLocal(\"pOut\") )),\n                c.i32_store8(\n                    c.getLocal(\"itOut\"),\n                    c.i32_load8_u(c.getLocal(\"itIn\")),\n                ),\n                c.setLocal(\"itOut\", c.i32_sub(c.getLocal(\"itOut\"), c.i32_const(1))),\n                c.setLocal(\"itIn\", c.i32_add(c.getLocal(\"itIn\"), c.i32_const(1))),\n                c.br(0)\n            )),\n        );\n\n    }\n\n    function buildLEMtoC() {\n        const f = module.addFunction(prefix + \"_LEMtoC\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const tmp = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"pIn\")),\n                [\n                    ...c.call(prefixField + \"_zero\", c.getLocal(\"pOut\")),\n                    ...c.i32_store8(\n                        c.getLocal(\"pOut\"),\n                        c.i32_const(0x40)\n                    ),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefixField + \"_fromMontgomery\", c.getLocal(\"pIn\"), tmp),\n            c.call(prefix + \"__reverseBytes\", tmp, c.i32_const(n8), c.getLocal(\"pOut\")),\n            c.if(\n                c.i32_eq(\n                    c.call(prefixField + \"_sign\", c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8))),\n                    c.i32_const(-1)\n                ),\n                c.i32_store8(\n                    c.getLocal(\"pOut\"),\n                    c.i32_or(\n                        c.i32_load8_u(c.getLocal(\"pOut\")),\n                        c.i32_const(0x80)\n                    )\n                )\n            ),\n        );\n    }\n\n    function buildLEMtoU() {\n        const f = module.addFunction(prefix + \"_LEMtoU\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const pTmp = module.alloc(n8*2);\n        const tmp = c.i32_const(pTmp);\n        const tmpX = c.i32_const(pTmp);\n        const tmpY = c.i32_const(pTmp + n8);\n\n        f.addCode(\n            c.if(\n                c.call(prefix + \"_isZeroAffine\", c.getLocal(\"pIn\")),\n                [\n                    ...c.call(prefix + \"_zeroAffine\", c.getLocal(\"pOut\")),\n                    ...c.ret([])\n                ]\n            ),\n\n            c.call(prefix + \"_fromMontgomeryAffine\", c.getLocal(\"pIn\"), tmp),\n\n            c.call(prefix + \"__reverseBytes\", tmpX, c.i32_const(n8), c.getLocal(\"pOut\")),\n            c.call(prefix + \"__reverseBytes\", tmpY, c.i32_const(n8), c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8))),\n        );\n    }\n\n    function buildUtoLEM() {\n        const f = module.addFunction(prefix + \"_UtoLEM\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const pTmp = module.alloc(n8*2);\n        const tmp = c.i32_const(pTmp);\n        const tmpX = c.i32_const(pTmp);\n        const tmpY = c.i32_const(pTmp + n8);\n\n        f.addCode(\n            c.if(\n                c.i32_and(c.i32_load8_u(c.getLocal(\"pIn\")), c.i32_const(0x40)),\n                [\n                    ...c.call(prefix + \"_zeroAffine\", c.getLocal(\"pOut\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.call(prefix + \"__reverseBytes\", c.getLocal(\"pIn\"), c.i32_const(n8), tmpX),\n            c.call(prefix + \"__reverseBytes\", c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8)), c.i32_const(n8), tmpY),\n            c.call(prefix + \"_toMontgomeryAffine\", tmp,  c.getLocal(\"pOut\"))\n        );\n    }\n\n    function buildCtoLEM() {\n        const f = module.addFunction(prefix + \"_CtoLEM\");\n        f.addParam(\"pIn\", \"i32\");\n        f.addParam(\"pOut\", \"i32\");\n        f.addLocal(\"firstByte\", \"i32\");\n        f.addLocal(\"greatest\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const pTmp = module.alloc(n8*2);\n        const tmpX = c.i32_const(pTmp);\n        const tmpY = c.i32_const(pTmp + n8);\n\n        f.addCode(\n            c.setLocal(\"firstByte\", c.i32_load8_u(c.getLocal(\"pIn\"))),\n            c.if(\n                c.i32_and(\n                    c.getLocal(\"firstByte\"),\n                    c.i32_const(0x40)\n                ),\n                [\n                    ...c.call(prefix + \"_zeroAffine\", c.getLocal(\"pOut\")),\n                    ...c.ret([])\n                ]\n            ),\n            c.setLocal(\n                \"greatest\",\n                c.i32_and(\n                    c.getLocal(\"firstByte\"),\n                    c.i32_const(0x80)\n                )\n            ),\n\n            c.call(prefixField + \"_copy\", c.getLocal(\"pIn\"), tmpY),\n            c.i32_store8(tmpY, c.i32_and(c.getLocal(\"firstByte\"), c.i32_const(0x3F))),\n            c.call(prefix + \"__reverseBytes\", tmpY, c.i32_const(n8), tmpX),\n            c.call(prefixField + \"_toMontgomery\", tmpX, c.getLocal(\"pOut\")),\n\n            c.call(prefixField + \"_square\", c.getLocal(\"pOut\"), tmpY),\n            c.call(prefixField + \"_mul\", c.getLocal(\"pOut\"), tmpY,  tmpY),\n            c.call(prefixField + \"_add\", tmpY, c.i32_const(pB),  tmpY),\n\n            c.call(prefixField + \"_sqrt\", tmpY, tmpY),\n            c.call(prefixField + \"_neg\", tmpY, tmpX),\n\n            c.if(\n                c.i32_eq(\n                    c.call(prefixField + \"_sign\", tmpY),\n                    c.i32_const(-1)\n                ),\n                c.if(\n                    c.getLocal(\"greatest\"),\n                    c.call(prefixField + \"_copy\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8))),\n                    c.call(prefixField + \"_neg\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8)))\n                ),\n                c.if(\n                    c.getLocal(\"greatest\"),\n                    c.call(prefixField + \"_neg\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8))),\n                    c.call(prefixField + \"_copy\", tmpY, c.i32_add(c.getLocal(\"pOut\"), c.i32_const(n8)))\n                ),\n            )\n\n        );\n    }\n\n    function buildInCurveAffine() {\n        const f = module.addFunction(prefix + \"_inCurveAffine\");\n        f.addParam(\"pIn\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"pIn\");\n        const y = c.i32_add(c.getLocal(\"pIn\"), c.i32_const(n8));\n\n        const y2 = c.i32_const(module.alloc(n8));\n        const x3b = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(prefixField + \"_square\", y, y2),\n            c.call(prefixField + \"_square\", x, x3b),\n            c.call(prefixField + \"_mul\", x, x3b, x3b),\n            c.call(prefixField + \"_add\", x3b, c.i32_const(pB), x3b),\n\n            c.ret(\n                c.call(prefixField + \"_eq\", y2, x3b)\n            )\n        );\n    }\n\n    function buildInCurve() {\n        const f = module.addFunction(prefix + \"_inCurve\");\n        f.addParam(\"pIn\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8*2));\n\n        f.addCode(\n            c.call(prefix + \"_toAffine\", c.getLocal(\"pIn\"), aux),\n\n            c.ret(\n                c.call(prefix + \"_inCurveAffine\", aux),\n            )\n        );\n    }\n\n    buildIsZeroAffine();\n    buildIsZero();\n    buildZeroAffine();\n    buildZero();\n    buildCopyAffine();\n    buildCopy();\n    buildToJacobian();\n    buildEqAffine();\n    buildEqMixed();\n    buildEq();\n    buildDoubleAffine();\n    buildDouble();\n    buildAddAffine();\n    buildAddMixed();\n    buildAdd();\n    buildNegAffine();\n    buildNeg();\n    buildSubAffine();\n    buildSubMixed();\n    buildSub();\n    buildFromMontgomeryAffine();\n    buildFromMontgomery();\n    buildToMontgomeryAffine();\n    buildToMontgomery();\n    buildToAffine();\n    buildInCurveAffine();\n    buildInCurve();\n\n    buildBatchToAffine();\n\n    buildNormalize();\n\n\n    buildReverseBytes();\n\n    buildLEMtoU();\n    buildLEMtoC();\n    buildUtoLEM();\n    buildCtoLEM();\n\n    buildBatchConvertion(module, prefix + \"_batchLEMtoU\", prefix + \"_LEMtoU\", n8*2, n8*2);\n    buildBatchConvertion(module, prefix + \"_batchLEMtoC\", prefix + \"_LEMtoC\", n8*2, n8);\n    buildBatchConvertion(module, prefix + \"_batchUtoLEM\", prefix + \"_UtoLEM\", n8*2, n8*2);\n    buildBatchConvertion(module, prefix + \"_batchCtoLEM\", prefix + \"_CtoLEM\", n8, n8*2, true);\n\n    buildBatchConvertion(module, prefix + \"_batchToJacobian\", prefix + \"_toJacobian\", n8*2, n8*3, true);\n\n    buildMultiexp$1(module, prefix, prefix + \"_multiexp\", prefix + \"_add\", n8*3);\n    buildMultiexp$1(module, prefix, prefix + \"_multiexpAffine\", prefix + \"_addMixed\", n8*2);\n\n    /*\n    buildTimesScalar(\n        module,\n        prefix + \"_timesScalarOld\",\n        n8*3,\n        prefix + \"_add\",\n        prefix + \"_double\",\n        prefix + \"_copy\",\n        prefix + \"_zero\",\n    );\n    */\n    buildTimesScalarNAF(\n        module,\n        prefix + \"_timesScalar\",\n        n8*3,\n        prefix + \"_add\",\n        prefix + \"_double\",\n        prefix + \"_sub\",\n        prefix + \"_copy\",\n        prefix + \"_zero\"\n    );\n\n    buildTimesScalarNAF(\n        module,\n        prefix + \"_timesScalarAffine\",\n        n8*2,\n        prefix + \"_addMixed\",\n        prefix + \"_double\",\n        prefix + \"_subMixed\",\n        prefix + \"_copyAffine\",\n        prefix + \"_zero\"\n    );\n\n    module.exportFunction(prefix + \"_isZero\");\n    module.exportFunction(prefix + \"_isZeroAffine\");\n\n    module.exportFunction(prefix + \"_eq\");\n    module.exportFunction(prefix + \"_eqMixed\");\n    module.exportFunction(prefix + \"_eqAffine\");\n\n    module.exportFunction(prefix + \"_copy\");\n    module.exportFunction(prefix + \"_copyAffine\");\n\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_zeroAffine\");\n\n    module.exportFunction(prefix + \"_double\");\n    module.exportFunction(prefix + \"_doubleAffine\");\n\n    module.exportFunction(prefix + \"_add\");\n    module.exportFunction(prefix + \"_addMixed\");\n    module.exportFunction(prefix + \"_addAffine\");\n\n    module.exportFunction(prefix + \"_neg\");\n    module.exportFunction(prefix + \"_negAffine\");\n\n    module.exportFunction(prefix + \"_sub\");\n    module.exportFunction(prefix + \"_subMixed\");\n    module.exportFunction(prefix + \"_subAffine\");\n\n    module.exportFunction(prefix + \"_fromMontgomery\");\n    module.exportFunction(prefix + \"_fromMontgomeryAffine\");\n\n    module.exportFunction(prefix + \"_toMontgomery\");\n    module.exportFunction(prefix + \"_toMontgomeryAffine\");\n\n    module.exportFunction(prefix + \"_timesScalar\");\n    module.exportFunction(prefix + \"_timesScalarAffine\");\n\n    module.exportFunction(prefix + \"_normalize\");\n\n    // Convertion functions\n    module.exportFunction(prefix + \"_LEMtoU\");\n    module.exportFunction(prefix + \"_LEMtoC\");\n    module.exportFunction(prefix + \"_UtoLEM\");\n    module.exportFunction(prefix + \"_CtoLEM\");\n\n    module.exportFunction(prefix + \"_batchLEMtoU\");\n    module.exportFunction(prefix + \"_batchLEMtoC\");\n    module.exportFunction(prefix + \"_batchUtoLEM\");\n    module.exportFunction(prefix + \"_batchCtoLEM\");\n\n    module.exportFunction(prefix + \"_toAffine\");\n    module.exportFunction(prefix + \"_toJacobian\");\n\n    module.exportFunction(prefix + \"_batchToAffine\");\n    module.exportFunction(prefix + \"_batchToJacobian\");\n\n    module.exportFunction(prefix + \"_inCurve\");\n    module.exportFunction(prefix + \"_inCurveAffine\");\n\n    /*\n    buildG1MulScalar(module, zq);\n    module.exportFunction(\"g1MulScalar\");\n    */\n\n    return prefix;\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { isOdd: isOdd$2, modInv: modInv$1, modPow } = bigint;\nconst utils$3 = utils$6;\n\nvar build_fft = function buildFFT(module, prefix, gPrefix, fPrefix, opGtimesF) {\n\n    const n64f = module.modules[fPrefix].n64;\n    const n8f = n64f*8;\n\n    const n64g = module.modules[gPrefix].n64;\n    const n8g = n64g*8;\n\n    const q = module.modules[fPrefix].q;\n\n    let rem = q - 1n;\n    let maxBits = 0;\n    while (!isOdd$2(rem)) {\n        maxBits ++;\n        rem = rem >> 1n;\n    }\n\n    let nr = 2n;\n\n    while ( modPow(nr, q >> 1n, q) === 1n ) nr = nr + 1n;\n\n    // console.log(nr);\n\n    const w = new Array(maxBits+1);\n    w[maxBits] = modPow(nr, rem, q);\n\n    let n=maxBits-1;\n    while (n>=0) {\n        w[n] = modPow(w[n+1], 2n, q);\n        n--;\n    }\n\n    const bytes = [];\n    const R = (1n << BigInt(n8f*8)) % q;\n\n    for (let i=0; i<w.length; i++) {\n        const m = w[i] * R % q;\n        bytes.push(...utils$3.bigInt2BytesLE(m, n8f));\n    }\n\n    const ROOTs = module.alloc(bytes);\n\n    const i2 = new Array(maxBits+1);\n    i2[0] = 1n;\n\n    for (let i=1; i<=maxBits; i++) {\n        i2[i] = i2[i-1] * 2n;\n    }\n\n    const bytesi2 =[];\n    for (let i=0; i<=maxBits; i++) {\n        const m = modInv$1(i2[i], q) * R % q;\n        bytesi2.push(...utils$3.bigInt2BytesLE(m, n8f));\n    }\n\n    const INV2 = module.alloc(bytesi2);\n\n    const shift = modPow(nr, 2n, q);\n    const bytesShiftToSmallM =[];\n    const bytesSConst =[];\n    for (let i=0; i<=maxBits; i++) {\n        const shiftToSmallM = modPow(shift, 2n ** BigInt(i), q);\n        const sConst = modInv$1(q + 1n - shiftToSmallM, q);\n        bytesShiftToSmallM.push(...utils$3.bigInt2BytesLE(shiftToSmallM * R % q, n8f));\n        bytesSConst.push(...utils$3.bigInt2BytesLE(sConst * R % q, n8f));\n    }\n\n    const SHIFT_TO_M = module.alloc( bytesShiftToSmallM  );\n    const SCONST = module.alloc( bytesSConst  );\n\n    function rev(x) {\n        let r=0;\n        for (let i=0; i<8; i++) {\n            if (x & (1 << i)) {\n                r = r | (0x80 >> i);\n            }\n        }\n        return r;\n    }\n\n    const rtable = Array(256);\n    for (let i=0; i<256; i++) {\n        rtable[i] = rev(i);\n    }\n\n    const REVTABLE = module.alloc(rtable);\n\n\n    function buildLog2() {\n        const f = module.addFunction(prefix+\"__log2\");\n        f.addParam(\"n\", \"i32\");\n        f.setReturnType(\"i32\");\n        f.addLocal(\"bits\", \"i32\");\n        f.addLocal(\"aux\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\n                \"aux\",\n                c.i32_shr_u(\n                    c.getLocal(\"n\"),\n                    c.i32_const(1)\n                )\n            )\n        );\n        f.addCode(c.setLocal(\"bits\", c.i32_const(0)));\n\n        f.addCode(c.block(c.loop(\n            c.br_if(\n                1,\n                c.i32_eqz(c.getLocal(\"aux\"))\n            ),\n\n            c.setLocal(\n                \"aux\",\n                c.i32_shr_u(\n                    c.getLocal(\"aux\"),\n                    c.i32_const(1)\n                )\n            ),\n\n            c.setLocal(\n                \"bits\",\n                c.i32_add(\n                    c.getLocal(\"bits\"),\n                    c.i32_const(1)\n                )\n            ),\n\n            c.br(0)\n        )));\n\n        f.addCode(c.if(\n            c.i32_ne(\n                c.getLocal(\"n\"),\n                c.i32_shl(\n                    c.i32_const(1),\n                    c.getLocal(\"bits\")\n                )\n            ),\n            c.unreachable()\n        ));\n\n        f.addCode(c.if(\n            c.i32_gt_u(\n                c.getLocal(\"bits\"),\n                c.i32_const(maxBits)\n            ),\n            c.unreachable()\n        ));\n\n        f.addCode(c.getLocal(\"bits\"));\n    }\n\n    function buildFFT() {\n        const f = module.addFunction(prefix+\"_fft\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n\n        f.addLocal(\"bits\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const One = c.i32_const(module.alloc(n8f));\n\n        f.addCode(\n            c.setLocal(\n                \"bits\",\n                c.call(\n                    prefix + \"__log2\",\n                    c.getLocal(\"n\")\n                )\n            ),\n            c.call(fPrefix + \"_one\", One),\n            c.call(\n                prefix+\"_rawfft\",\n                c.getLocal(\"px\"),\n                c.getLocal(\"bits\"),\n                c.i32_const(0),\n                One\n            )\n        );\n\n    }\n\n    function buildIFFT() {\n        const f = module.addFunction(prefix+\"_ifft\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addLocal(\"bits\", \"i32\");\n        f.addLocal(\"pInv2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\n                \"bits\",\n                c.call(\n                    prefix + \"__log2\",\n                    c.getLocal(\"n\")\n                )\n            ),\n            c.setLocal(\n                \"pInv2\",\n                c.i32_add(\n                    c.i32_const(INV2),\n                    c.i32_mul(\n                        c.getLocal(\"bits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n            c.call(\n                prefix+\"_rawfft\",\n                c.getLocal(\"px\"),\n                c.getLocal(\"bits\"),\n                c.i32_const(1),\n                c.getLocal(\"pInv2\")\n            ),\n        );\n    }\n\n    function buildRawFFT() {\n        const f = module.addFunction(prefix+\"_rawfft\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"bits\", \"i32\"); // 2 power\n        f.addParam(\"reverse\", \"i32\");\n        f.addParam(\"mulFactor\", \"i32\");\n\n        f.addLocal(\"s\", \"i32\");\n        f.addLocal(\"k\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"m\", \"i32\");\n        f.addLocal(\"mdiv2\", \"i32\");\n        f.addLocal(\"n\", \"i32\");\n        f.addLocal(\"pwm\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const T = c.i32_const(module.alloc(n8g));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.call(prefix + \"__reversePermutation\", c.getLocal(\"px\"), c.getLocal(\"bits\")),\n            c.setLocal(\"n\", c.i32_shl(c.i32_const(1), c.getLocal(\"bits\"))),\n            c.setLocal(\"s\", c.i32_const(1)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_gt_u(\n                        c.getLocal(\"s\"),\n                        c.getLocal(\"bits\")\n                    )\n                ),\n                c.setLocal(\"m\", c.i32_shl(c.i32_const(1), c.getLocal(\"s\"))),\n                c.setLocal(\"pwm\",\n                    c.i32_add(\n                        c.i32_const(ROOTs),\n                        c.i32_mul(\n                            c.getLocal(\"s\"),\n                            c.i32_const(n8f)\n                        )\n                    )\n                ),\n                c.setLocal(\"k\", c.i32_const(0)),\n                c.block(c.loop(\n                    c.br_if(\n                        1,\n                        c.i32_ge_u(\n                            c.getLocal(\"k\"),\n                            c.getLocal(\"n\")\n                        )\n                    ),\n\n                    c.call(fPrefix + \"_one\", W),\n\n                    c.setLocal(\"mdiv2\", c.i32_shr_u(c.getLocal(\"m\"), c.i32_const(1)) ),\n                    c.setLocal(\"j\", c.i32_const(0)),\n                    c.block(c.loop(\n                        c.br_if(\n                            1,\n                            c.i32_ge_u(\n                                c.getLocal(\"j\"),\n                                c.getLocal(\"mdiv2\")\n                            )\n                        ),\n\n                        c.setLocal(\n                            \"idx1\",\n                            c.i32_add(\n                                c.getLocal(\"px\"),\n                                c.i32_mul(\n                                    c.i32_add(\n                                        c.getLocal(\"k\"),\n                                        c.getLocal(\"j\")\n                                    ),\n                                    c.i32_const(n8g)\n                                )\n                            )\n                        ),\n\n                        c.setLocal(\n                            \"idx2\",\n                            c.i32_add(\n                                c.getLocal(\"idx1\"),\n                                c.i32_mul(\n                                    c.getLocal(\"mdiv2\"),\n                                    c.i32_const(n8g)\n                                )\n                            )\n                        ),\n\n                        c.call(\n                            opGtimesF,\n                            c.getLocal(\"idx2\"),\n                            W,\n                            T\n                        ),\n\n                        c.call(\n                            gPrefix + \"_copy\",\n                            c.getLocal(\"idx1\"),\n                            U\n                        ),\n\n                        c.call(\n                            gPrefix + \"_add\",\n                            U,\n                            T,\n                            c.getLocal(\"idx1\"),\n                        ),\n\n                        c.call(\n                            gPrefix + \"_sub\",\n                            U,\n                            T,\n                            c.getLocal(\"idx2\"),\n                        ),\n\n                        c.call(\n                            fPrefix + \"_mul\",\n                            W,\n                            c.getLocal(\"pwm\"),\n                            W,\n                        ),\n\n                        c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                        c.br(0)\n                    )),\n\n                    c.setLocal(\"k\", c.i32_add(c.getLocal(\"k\"), c.getLocal(\"m\"))),\n                    c.br(0)\n                )),\n\n                c.setLocal(\"s\", c.i32_add(c.getLocal(\"s\"), c.i32_const(1))),\n                c.br(0)\n            )),\n            c.call(\n                prefix + \"__fftFinal\",\n                c.getLocal(\"px\"),\n                c.getLocal(\"bits\"),\n                c.getLocal(\"reverse\"),\n                c.getLocal(\"mulFactor\")\n            )\n        );\n    }\n\n\n    function buildFinalInverse() {\n        const f = module.addFunction(prefix+\"__fftFinal\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"bits\", \"i32\");\n        f.addParam(\"reverse\", \"i32\");\n        f.addParam(\"mulFactor\", \"i32\");\n        f.addLocal(\"n\", \"i32\");\n        f.addLocal(\"ndiv2\", \"i32\");\n        f.addLocal(\"pInv2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"mask\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const T = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.if(\n                c.i32_and(\n                    c.i32_eqz(c.getLocal(\"reverse\")),\n                    c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\"))\n                ),\n                c.ret([])\n            ),\n            c.setLocal(\"n\", c.i32_shl( c.i32_const(1), c.getLocal(\"bits\"))),\n\n            c.setLocal(\"mask\", c.i32_sub( c.getLocal(\"n\") , c.i32_const(1))),\n            c.setLocal(\"i\", c.i32_const(1)),\n            c.setLocal(\n                \"ndiv2\",\n                c.i32_shr_u(\n                    c.getLocal(\"n\"),\n                    c.i32_const(1)\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_ge_u(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"ndiv2\")\n                    )\n                ),\n\n                c.setLocal(\"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.i32_sub(\n                                c.getLocal(\"n\"),\n                                c.getLocal(\"i\")\n                            ),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.if(\n                    c.getLocal(\"reverse\"),\n                    c.if(\n                        c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\")),\n                        [\n                            ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx1\"), T),\n                            ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx2\") , c.getLocal(\"idx1\") ),\n                            ...c.call(gPrefix + \"_copy\", T , c.getLocal(\"idx2\")),\n                        ],\n                        [\n                            ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx1\"), T),\n                            ...c.call(opGtimesF , c.getLocal(\"idx2\") , c.getLocal(\"mulFactor\"), c.getLocal(\"idx1\") ),\n                            ...c.call(opGtimesF , T , c.getLocal(\"mulFactor\"), c.getLocal(\"idx2\")),\n                        ]\n                    ),\n                    c.if(\n                        c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\")),\n                        [\n                            // Do nothing (It should not be here)\n                        ],\n                        [\n                            ...c.call(opGtimesF , c.getLocal(\"idx1\") , c.getLocal(\"mulFactor\"), c.getLocal(\"idx1\") ),\n                            ...c.call(opGtimesF , c.getLocal(\"idx2\") , c.getLocal(\"mulFactor\"), c.getLocal(\"idx2\")),\n                        ]\n                    )\n                ),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n\n                c.br(0)\n            )),\n\n            c.if(\n                c.call(fPrefix + \"_isOne\", c.getLocal(\"mulFactor\")),\n                [\n                    // Do nothing (It should not be here)\n                ],\n                [\n                    ...c.call(opGtimesF, c.getLocal(\"px\") , c.getLocal(\"mulFactor\"), c.getLocal(\"px\")),\n                    ...c.setLocal(\"idx2\",\n                        c.i32_add(\n                            c.getLocal(\"px\"),\n                            c.i32_mul(\n                                c.getLocal(\"ndiv2\"),\n                                c.i32_const(n8g)\n                            )\n                        )\n                    ),\n                    ...c.call(opGtimesF, c.getLocal(\"idx2\"),c.getLocal(\"mulFactor\"), c.getLocal(\"idx2\"))\n                ]\n            )\n        );\n    }\n\n    function buildReversePermutation() {\n        const f = module.addFunction(prefix+\"__reversePermutation\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"bits\", \"i32\");\n        f.addLocal(\"n\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"ri\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const T = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.setLocal(\"n\", c.i32_shl( c.i32_const(1), c.getLocal(\"bits\"))),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\"ri\", c.call(prefix + \"__rev\", c.getLocal(\"i\"), c.getLocal(\"bits\"))),\n\n                c.setLocal(\"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"px\"),\n                        c.i32_mul(\n                            c.getLocal(\"ri\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.if(\n                    c.i32_lt_u(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"ri\")\n                    ),\n                    [\n                        ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx1\"), T),\n                        ...c.call(gPrefix + \"_copy\", c.getLocal(\"idx2\") , c.getLocal(\"idx1\")),\n                        ...c.call(gPrefix + \"_copy\", T , c.getLocal(\"idx2\"))\n                    ]\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildRev() {\n        const f = module.addFunction(prefix+\"__rev\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"bits\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.i32_rotl(\n                c.i32_add(\n                    c.i32_add(\n                        c.i32_shl(\n                            c.i32_load8_u(\n                                c.i32_and(\n                                    c.getLocal(\"x\"),\n                                    c.i32_const(0xFF)\n                                ),\n                                REVTABLE,\n                                0\n                            ),\n                            c.i32_const(24)\n                        ),\n                        c.i32_shl(\n                            c.i32_load8_u(\n                                c.i32_and(\n                                    c.i32_shr_u(\n                                        c.getLocal(\"x\"),\n                                        c.i32_const(8)\n                                    ),\n                                    c.i32_const(0xFF)\n                                ),\n                                REVTABLE,\n                                0\n                            ),\n                            c.i32_const(16)\n                        ),\n                    ),\n                    c.i32_add(\n                        c.i32_shl(\n                            c.i32_load8_u(\n                                c.i32_and(\n                                    c.i32_shr_u(\n                                        c.getLocal(\"x\"),\n                                        c.i32_const(16)\n                                    ),\n                                    c.i32_const(0xFF)\n                                ),\n                                REVTABLE,\n                                0\n                            ),\n                            c.i32_const(8)\n                        ),\n                        c.i32_load8_u(\n                            c.i32_and(\n                                c.i32_shr_u(\n                                    c.getLocal(\"x\"),\n                                    c.i32_const(24)\n                                ),\n                                c.i32_const(0xFF)\n                            ),\n                            REVTABLE,\n                            0\n                        ),\n                    )\n                ),\n                c.getLocal(\"bits\")\n            )\n        );\n    }\n\n\n    function buildFFTJoin() {\n        const f = module.addFunction(prefix+\"_fftJoin\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const T = c.i32_const(module.alloc(n8g));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    T\n                ),\n\n                c.call(\n                    gPrefix + \"_copy\",\n                    c.getLocal(\"idx1\"),\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_add\",\n                    U,\n                    T,\n                    c.getLocal(\"idx1\"),\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    U,\n                    T,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W,\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n    function buildFFTJoinExt() {\n        const f = module.addFunction(prefix+\"_fftJoinExt\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addParam(\"totalBits\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"pShiftToM\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n\n            c.setLocal(\"pShiftToM\",\n                c.i32_add(\n                    c.i32_const(SHIFT_TO_M),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    gPrefix + \"_add\",\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx2\"),\n                    U\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"pShiftToM\"),\n                    c.getLocal(\"idx2\")\n                ),\n\n                c.call(\n                    gPrefix + \"_add\",\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"idx2\")\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    gPrefix + \"_copy\",\n                    U,\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildFFTJoinExtInv() {\n        const f = module.addFunction(prefix+\"_fftJoinExtInv\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addParam(\"totalBits\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"pShiftToM\", \"i32\");\n        f.addLocal(\"pSConst\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n\n            c.setLocal(\"pShiftToM\",\n                c.i32_add(\n                    c.i32_const(SHIFT_TO_M),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n            c.setLocal(\"pSConst\",\n                c.i32_add(\n                    c.i32_const(SCONST),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    c.getLocal(\"idx1\"),\n                    U,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"pSConst\"),\n                    c.getLocal(\"idx2\")\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"pShiftToM\"),\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    U,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"pSConst\"),\n                    c.getLocal(\"idx1\")\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n\n    function buildPrepareLagrangeEvaluation() {\n        const f = module.addFunction(prefix+\"_prepareLagrangeEvaluation\");\n        f.addParam(\"pBuff1\", \"i32\");\n        f.addParam(\"pBuff2\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"first\", \"i32\");\n        f.addParam(\"inc\", \"i32\");\n        f.addParam(\"totalBits\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"pShiftToM\", \"i32\");\n        f.addLocal(\"pSConst\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n\n            c.setLocal(\"pShiftToM\",\n                c.i32_add(\n                    c.i32_const(SHIFT_TO_M),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n            c.setLocal(\"pSConst\",\n                c.i32_add(\n                    c.i32_const(SCONST),\n                    c.i32_mul(\n                        c.getLocal(\"totalBits\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n\n\n            c.call( fPrefix + \"_copy\", c.getLocal(\"first\"), W),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"n\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff1\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff2\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"pShiftToM\"),\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    c.getLocal(\"idx2\"),\n                    U,\n                    U\n                ),\n\n                c.call(\n                    gPrefix + \"_sub\",\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    opGtimesF,\n                    U,\n                    c.getLocal(\"pSConst\"),\n                    c.getLocal(\"idx1\"),\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    W,\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    fPrefix + \"_mul\",\n                    W,\n                    c.getLocal(\"inc\"),\n                    W\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildFFTMix() {\n        const f = module.addFunction(prefix+\"_fftMix\");\n        f.addParam(\"pBuff\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"exp\", \"i32\");\n        f.addLocal(\"nGroups\", \"i32\");\n        f.addLocal(\"nPerGroup\", \"i32\");\n        f.addLocal(\"nPerGroupDiv2\", \"i32\");\n        f.addLocal(\"pairOffset\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"pwm\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const W = c.i32_const(module.alloc(n8f));\n        const T = c.i32_const(module.alloc(n8g));\n        const U = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.setLocal(\"nPerGroup\", c.i32_shl(c.i32_const(1), c.getLocal(\"exp\"))),\n            c.setLocal(\"nPerGroupDiv2\", c.i32_shr_u(c.getLocal(\"nPerGroup\"), c.i32_const(1))),\n            c.setLocal(\"nGroups\", c.i32_shr_u(c.getLocal(\"n\"), c.getLocal(\"exp\"))),\n            c.setLocal(\"pairOffset\", c.i32_mul(c.getLocal(\"nPerGroupDiv2\"), c.i32_const(n8g))),\n            c.setLocal(\"pwm\",\n                c.i32_add(\n                    c.i32_const(ROOTs),\n                    c.i32_mul(\n                        c.getLocal(\"exp\"),\n                        c.i32_const(n8f)\n                    )\n                )\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"nGroups\")\n                    )\n                ),\n                c.call( fPrefix + \"_one\", W),\n                c.setLocal(\"j\", c.i32_const(0)),\n                c.block(c.loop(\n                    c.br_if(\n                        1,\n                        c.i32_eq(\n                            c.getLocal(\"j\"),\n                            c.getLocal(\"nPerGroupDiv2\")\n                        )\n                    ),\n\n                    c.setLocal(\n                        \"idx1\",\n                        c.i32_add(\n                            c.getLocal(\"pBuff\"),\n                            c.i32_mul(\n                                c.i32_add(\n                                    c.i32_mul(\n                                        c.getLocal(\"i\"),\n                                        c.getLocal(\"nPerGroup\")\n                                    ),\n                                    c.getLocal(\"j\")\n                                ),\n                                c.i32_const(n8g)\n                            )\n                        )\n                    ),\n\n                    c.setLocal(\n                        \"idx2\",\n                        c.i32_add(\n                            c.getLocal(\"idx1\"),\n                            c.getLocal(\"pairOffset\")\n                        )\n                    ),\n\n                    c.call(\n                        opGtimesF,\n                        c.getLocal(\"idx2\"),\n                        W,\n                        T\n                    ),\n\n                    c.call(\n                        gPrefix + \"_copy\",\n                        c.getLocal(\"idx1\"),\n                        U\n                    ),\n\n                    c.call(\n                        gPrefix + \"_add\",\n                        U,\n                        T,\n                        c.getLocal(\"idx1\"),\n                    ),\n\n                    c.call(\n                        gPrefix + \"_sub\",\n                        U,\n                        T,\n                        c.getLocal(\"idx2\"),\n                    ),\n\n                    c.call(\n                        fPrefix + \"_mul\",\n                        W,\n                        c.getLocal(\"pwm\"),\n                        W,\n                    ),\n                    c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n    // Reverse all and multiply by factor\n    function buildFFTFinal() {\n        const f = module.addFunction(prefix+\"_fftFinal\");\n        f.addParam(\"pBuff\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"factor\", \"i32\");\n        f.addLocal(\"idx1\", \"i32\");\n        f.addLocal(\"idx2\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"ndiv2\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const T = c.i32_const(module.alloc(n8g));\n\n        f.addCode(\n            c.setLocal(\"ndiv2\", c.i32_shr_u(c.getLocal(\"n\"), c.i32_const(1))),\n            c.if(\n                c.i32_and(\n                    c.getLocal(\"n\"),\n                    c.i32_const(1)\n                ),\n                c.call(\n                    opGtimesF,\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.getLocal(\"ndiv2\"),\n                            c.i32_const(n8g)\n                        )\n                    ),\n                    c.getLocal(\"factor\"),\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.getLocal(\"ndiv2\"),\n                            c.i32_const(n8g)\n                        )\n                    ),\n                ),\n            ),\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_ge_u(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"ndiv2\")\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx1\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.getLocal(\"i\"),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.setLocal(\n                    \"idx2\",\n                    c.i32_add(\n                        c.getLocal(\"pBuff\"),\n                        c.i32_mul(\n                            c.i32_sub(\n                                c.i32_sub(\n                                    c.getLocal(\"n\"),\n                                    c.i32_const(1)\n                                ),\n                                c.getLocal(\"i\")\n                            ),\n                            c.i32_const(n8g)\n                        )\n                    )\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx2\"),\n                    c.getLocal(\"factor\"),\n                    T\n                ),\n\n                c.call(\n                    opGtimesF,\n                    c.getLocal(\"idx1\"),\n                    c.getLocal(\"factor\"),\n                    c.getLocal(\"idx2\"),\n                ),\n\n                c.call(\n                    gPrefix + \"_copy\",\n                    T,\n                    c.getLocal(\"idx1\"),\n                ),\n\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n    buildRev();\n    buildReversePermutation();\n    buildFinalInverse();\n    buildRawFFT();\n    buildLog2();\n    buildFFT();\n    buildIFFT();\n    buildFFTJoin();\n    buildFFTJoinExt();\n    buildFFTJoinExtInv();\n    buildFFTMix();\n    buildFFTFinal();\n    buildPrepareLagrangeEvaluation();\n\n    module.exportFunction(prefix+\"_fft\");\n    module.exportFunction(prefix+\"_ifft\");\n    module.exportFunction(prefix+\"_rawfft\");\n    module.exportFunction(prefix+\"_fftJoin\");\n    module.exportFunction(prefix+\"_fftJoinExt\");\n    module.exportFunction(prefix+\"_fftJoinExtInv\");\n    module.exportFunction(prefix+\"_fftMix\");\n    module.exportFunction(prefix+\"_fftFinal\");\n    module.exportFunction(prefix+\"_prepareLagrangeEvaluation\");\n\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar build_pol = function buildPol(module, prefix, prefixField) {\n\n    const n64 = module.modules[prefixField].n64;\n    const n8 = n64*8;\n\n\n    function buildZero() {\n        const f = module.addFunction(prefix+\"_zero\");\n        f.addParam(\"px\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addLocal(\"lastp\", \"i32\");\n        f.addLocal(\"p\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\"p\", c.getLocal(\"px\")),\n            c.setLocal(\n                \"lastp\",\n                c.i32_add(\n                    c.getLocal(\"px\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"p\"),\n                        c.getLocal(\"lastp\")\n                    )\n                ),\n                c.call(prefixField + \"_zero\", c.getLocal(\"p\")),\n                c.setLocal(\"p\", c.i32_add(c.getLocal(\"p\"), c.i32_const(n8))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildConstructLC() {\n        const f = module.addFunction(prefix+\"_constructLC\");\n        f.addParam(\"ppolynomials\", \"i32\");\n        f.addParam(\"psignals\", \"i32\");\n        f.addParam(\"nSignals\", \"i32\");\n        f.addParam(\"pres\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n        f.addLocal(\"j\", \"i32\");\n        f.addLocal(\"pp\", \"i32\");\n        f.addLocal(\"ps\", \"i32\");\n        f.addLocal(\"pd\", \"i32\");\n        f.addLocal(\"ncoefs\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"i\", c.i32_const(0)),\n            c.setLocal(\"pp\", c.getLocal(\"ppolynomials\")),\n            c.setLocal(\"ps\", c.getLocal(\"psignals\")),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"i\"),\n                        c.getLocal(\"nSignals\")\n                    )\n                ),\n\n                c.setLocal(\"ncoefs\", c.i32_load(c.getLocal(\"pp\"))),\n                c.setLocal(\"pp\", c.i32_add(c.getLocal(\"pp\"), c.i32_const(4))),\n\n                c.setLocal(\"j\", c.i32_const(0)),\n                c.block(c.loop(\n                    c.br_if(\n                        1,\n                        c.i32_eq(\n                            c.getLocal(\"j\"),\n                            c.getLocal(\"ncoefs\")\n                        )\n                    ),\n\n                    c.setLocal(\n                        \"pd\",\n                        c.i32_add(\n                            c.getLocal(\"pres\"),\n                            c.i32_mul(\n                                c.i32_load(c.getLocal(\"pp\")),\n                                c.i32_const(n8)\n                            )\n                        )\n                    ),\n\n                    c.setLocal(\"pp\", c.i32_add(c.getLocal(\"pp\"), c.i32_const(4))),\n\n\n                    c.call(\n                        prefixField + \"_mul\",\n                        c.getLocal(\"ps\"),\n                        c.getLocal(\"pp\"),\n                        aux\n                    ),\n\n                    c.call(\n                        prefixField + \"_add\",\n                        aux,\n                        c.getLocal(\"pd\"),\n                        c.getLocal(\"pd\")\n                    ),\n\n                    c.setLocal(\"pp\", c.i32_add(c.getLocal(\"pp\"), c.i32_const(n8))),\n                    c.setLocal(\"j\", c.i32_add(c.getLocal(\"j\"), c.i32_const(1))),\n                    c.br(0)\n                )),\n\n                c.setLocal(\"ps\", c.i32_add(c.getLocal(\"ps\"), c.i32_const(n8))),\n                c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n\n    }\n\n    buildZero();\n    buildConstructLC();\n\n\n    module.exportFunction(prefix + \"_zero\");\n    module.exportFunction(prefix + \"_constructLC\");\n\n    return prefix;\n\n\n\n\n};\n\nvar build_qap = function buildQAP(module, prefix, prefixField) {\n\n    const n64 = module.modules[prefixField].n64;\n    const n8 = n64*8;\n\n\n    function buildBuildABC() {\n        const f = module.addFunction(prefix+\"_buildABC\");\n        f.addParam(\"pCoefs\", \"i32\");\n        f.addParam(\"nCoefs\", \"i32\");\n        f.addParam(\"pWitness\", \"i32\");\n        f.addParam(\"pA\", \"i32\");\n        f.addParam(\"pB\", \"i32\");\n        f.addParam(\"pC\", \"i32\");\n        f.addParam(\"offsetOut\", \"i32\");\n        f.addParam(\"nOut\", \"i32\");\n        f.addParam(\"offsetWitness\", \"i32\");\n        f.addParam(\"nWitness\", \"i32\");\n        f.addLocal(\"it\", \"i32\");\n        f.addLocal(\"ita\", \"i32\");\n        f.addLocal(\"itb\", \"i32\");\n        f.addLocal(\"last\", \"i32\");\n        f.addLocal(\"m\", \"i32\");\n        f.addLocal(\"c\", \"i32\");\n        f.addLocal(\"s\", \"i32\");\n        f.addLocal(\"pOut\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n\n            // Set output a and b to 0\n            c.setLocal(\"ita\", c.getLocal(\"pA\")),\n            c.setLocal(\"itb\", c.getLocal(\"pB\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pA\"),\n                    c.i32_mul(\n                        c.getLocal(\"nOut\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(prefixField + \"_zero\", c.getLocal(\"ita\")),\n                c.call(prefixField + \"_zero\", c.getLocal(\"itb\")),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.br(0)\n            )),\n\n\n            c.setLocal(\"it\", c.getLocal(\"pCoefs\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pCoefs\"),\n                    c.i32_mul(\n                        c.getLocal(\"nCoefs\"),\n                        c.i32_const(n8+12)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"it\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.setLocal(\n                    \"s\",\n                    c.i32_load(c.getLocal(\"it\"), 8)\n                ),\n                c.if(\n                    c.i32_or(\n                        c.i32_lt_u(\n                            c.getLocal(\"s\"),\n                            c.getLocal(\"offsetWitness\"),\n                        ),\n                        c.i32_ge_u(\n                            c.getLocal(\"s\"),\n                            c.i32_add(\n                                c.getLocal(\"offsetWitness\"),\n                                c.getLocal(\"nWitness\"),\n                            )\n                        )\n                    ),\n                    [\n                        ...c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                        ...c.br(1)\n                    ]\n                ),\n\n                c.setLocal(\n                    \"m\",\n                    c.i32_load(c.getLocal(\"it\"))\n                ),\n                c.if(\n                    c.i32_eq(c.getLocal(\"m\"), c.i32_const(0)),\n                    c.setLocal(\"pOut\", c.getLocal(\"pA\")),\n                    c.if(\n                        c.i32_eq(c.getLocal(\"m\"), c.i32_const(1)),\n                        c.setLocal(\"pOut\", c.getLocal(\"pB\")),\n                        [\n                            ...c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                            ...c.br(1)\n                        ]\n                    )\n                ),\n                c.setLocal(\n                    \"c\",\n                    c.i32_load(c.getLocal(\"it\"), 4)\n                ),\n                c.if(\n                    c.i32_or(\n                        c.i32_lt_u(\n                            c.getLocal(\"c\"),\n                            c.getLocal(\"offsetOut\"),\n                        ),\n                        c.i32_ge_u(\n                            c.getLocal(\"c\"),\n                            c.i32_add(\n                                c.getLocal(\"offsetOut\"),\n                                c.getLocal(\"nOut\"),\n                            )\n                        )\n                    ),\n                    [\n                        ...c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                        ...c.br(1)\n                    ]\n                ),\n                c.setLocal(\n                    \"pOut\",\n                    c.i32_add(\n                        c.getLocal(\"pOut\"),\n                        c.i32_mul(\n                            c.i32_sub(\n                                c.getLocal(\"c\"),\n                                c.getLocal(\"offsetOut\")\n                            ),\n                            c.i32_const(n8)\n                        )\n                    )\n                ),\n                c.call(\n                    prefixField + \"_mul\",\n                    c.i32_add(\n                        c.getLocal(\"pWitness\"),\n                        c.i32_mul(\n                            c.i32_sub(c.getLocal(\"s\"), c.getLocal(\"offsetWitness\")),\n                            c.i32_const(n8)\n                        )\n                    ),\n                    c.i32_add( c.getLocal(\"it\"), c.i32_const(12)),\n                    aux\n                ),\n                c.call(\n                    prefixField + \"_add\",\n                    c.getLocal(\"pOut\"),\n                    aux,\n                    c.getLocal(\"pOut\"),\n                ),\n                c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8+12))),\n                c.br(0)\n            )),\n\n            c.setLocal(\"ita\", c.getLocal(\"pA\")),\n            c.setLocal(\"itb\", c.getLocal(\"pB\")),\n            c.setLocal(\"it\", c.getLocal(\"pC\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pA\"),\n                    c.i32_mul(\n                        c.getLocal(\"nOut\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(\n                    prefixField + \"_mul\",\n                    c.getLocal(\"ita\"),\n                    c.getLocal(\"itb\"),\n                    c.getLocal(\"it\")\n                ),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.setLocal(\"it\", c.i32_add(c.getLocal(\"it\"), c.i32_const(n8))),\n                c.br(0)\n            )),\n\n        );\n    }\n\n    function buildJoinABC() {\n        const f = module.addFunction(prefix+\"_joinABC\");\n        f.addParam(\"pA\", \"i32\");\n        f.addParam(\"pB\", \"i32\");\n        f.addParam(\"pC\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pP\", \"i32\");\n        f.addLocal(\"ita\", \"i32\");\n        f.addLocal(\"itb\", \"i32\");\n        f.addLocal(\"itc\", \"i32\");\n        f.addLocal(\"itp\", \"i32\");\n        f.addLocal(\"last\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const aux = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.setLocal(\"ita\", c.getLocal(\"pA\")),\n            c.setLocal(\"itb\", c.getLocal(\"pB\")),\n            c.setLocal(\"itc\", c.getLocal(\"pC\")),\n            c.setLocal(\"itp\", c.getLocal(\"pP\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pA\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(\n                    prefixField + \"_mul\",\n                    c.getLocal(\"ita\"),\n                    c.getLocal(\"itb\"),\n                    aux\n                ),\n                c.call(\n                    prefixField + \"_sub\",\n                    aux,\n                    c.getLocal(\"itc\"),\n                    c.getLocal(\"itp\"),\n                ),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.setLocal(\"itc\", c.i32_add(c.getLocal(\"itc\"), c.i32_const(n8))),\n                c.setLocal(\"itp\", c.i32_add(c.getLocal(\"itp\"), c.i32_const(n8))),\n                c.br(0)\n            ))\n        );\n    }\n\n    function buildBatchAdd() {\n        const f = module.addFunction(prefix+\"_batchAdd\");\n        f.addParam(\"pa\", \"i32\");\n        f.addParam(\"pb\", \"i32\");\n        f.addParam(\"n\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n        f.addLocal(\"ita\", \"i32\");\n        f.addLocal(\"itb\", \"i32\");\n        f.addLocal(\"itr\", \"i32\");\n        f.addLocal(\"last\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.setLocal(\"ita\", c.getLocal(\"pa\")),\n            c.setLocal(\"itb\", c.getLocal(\"pb\")),\n            c.setLocal(\"itr\", c.getLocal(\"pr\")),\n            c.setLocal(\n                \"last\",\n                c.i32_add(\n                    c.getLocal(\"pa\"),\n                    c.i32_mul(\n                        c.getLocal(\"n\"),\n                        c.i32_const(n8)\n                    )\n                )\n            ),\n            c.block(c.loop(\n                c.br_if(\n                    1,\n                    c.i32_eq(\n                        c.getLocal(\"ita\"),\n                        c.getLocal(\"last\")\n                    )\n                ),\n                c.call(\n                    prefixField + \"_add\",\n                    c.getLocal(\"ita\"),\n                    c.getLocal(\"itb\"),\n                    c.getLocal(\"itr\"),\n                ),\n                c.setLocal(\"ita\", c.i32_add(c.getLocal(\"ita\"), c.i32_const(n8))),\n                c.setLocal(\"itb\", c.i32_add(c.getLocal(\"itb\"), c.i32_const(n8))),\n                c.setLocal(\"itr\", c.i32_add(c.getLocal(\"itr\"), c.i32_const(n8))),\n                c.br(0)\n            ))\n        );\n    }\n\n    buildBuildABC();\n    buildJoinABC();\n    buildBatchAdd();\n\n    module.exportFunction(prefix + \"_buildABC\");\n    module.exportFunction(prefix + \"_joinABC\");\n    module.exportFunction(prefix + \"_batchAdd\");\n\n    return prefix;\n\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nvar build_applykey = function buildApplyKey(module, fnName, gPrefix, frPrefix, sizeGIn, sizeGOut, sizeF, opGtimesF) {\n\n    const f = module.addFunction(fnName);\n    f.addParam(\"pIn\", \"i32\");\n    f.addParam(\"n\", \"i32\");\n    f.addParam(\"pFirst\", \"i32\");\n    f.addParam(\"pInc\", \"i32\");\n    f.addParam(\"pOut\", \"i32\");\n    f.addLocal(\"pOldFree\", \"i32\");\n    f.addLocal(\"i\", \"i32\");\n    f.addLocal(\"pFrom\", \"i32\");\n    f.addLocal(\"pTo\", \"i32\");\n\n    const c = f.getCodeBuilder();\n\n    const t = c.i32_const(module.alloc(sizeF));\n\n    f.addCode(\n        c.setLocal(\"pFrom\", c.getLocal(\"pIn\")),\n        c.setLocal(\"pTo\", c.getLocal(\"pOut\")),\n    );\n\n    // t = first\n    f.addCode(\n        c.call(\n            frPrefix + \"_copy\",\n            c.getLocal(\"pFirst\"),\n            t\n        )\n    );\n    f.addCode(\n        c.setLocal(\"i\", c.i32_const(0)),\n        c.block(c.loop(\n            c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.getLocal(\"n\") )),\n\n            c.call(\n                opGtimesF,\n                c.getLocal(\"pFrom\"),\n                t,\n                c.getLocal(\"pTo\")\n            ),\n            c.setLocal(\"pFrom\", c.i32_add(c.getLocal(\"pFrom\"), c.i32_const(sizeGIn))),\n            c.setLocal(\"pTo\", c.i32_add(c.getLocal(\"pTo\"), c.i32_const(sizeGOut))),\n\n            // t = t* inc\n            c.call(\n                frPrefix + \"_mul\",\n                t,\n                c.getLocal(\"pInc\"),\n                t\n            ),\n            c.setLocal(\"i\", c.i32_add(c.getLocal(\"i\"), c.i32_const(1))),\n            c.br(0)\n        ))\n    );\n\n    module.exportFunction(fnName);\n\n};\n\nconst utils$2 = utils$6;\n\nconst buildF1m$1 =build_f1m;\nconst buildF1$1 =build_f1;\nconst buildF2m$1 =build_f2m;\nconst buildF3m$1 =build_f3m;\nconst buildCurve$1 =build_curve_jacobian_a0;\nconst buildFFT$2 = build_fft;\nconst buildPol$1 = build_pol;\nconst buildQAP$1 = build_qap;\nconst buildApplyKey$1 = build_applykey;\nconst { bitLength: bitLength$2, modInv, isOdd: isOdd$1, isNegative: isNegative$2 } = bigint;\n\nvar build_bn128 = function buildBN128(module, _prefix) {\n\n    const prefix = _prefix || \"bn128\";\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const q = 21888242871839275222246405745257275088696311157297823662689037894645226208583n;\n    const r = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;\n\n\n    const n64 = Math.floor((bitLength$2(q - 1n) - 1)/64) +1;\n    const n8 = n64*8;\n    const frsize = n8;\n    const f1size = n8;\n    const f2size = f1size * 2;\n    const ftsize = f1size * 12;\n\n    const pr = module.alloc(utils$2.bigInt2BytesLE( r, frsize ));\n\n    const f1mPrefix = buildF1m$1(module, q, \"f1m\");\n    buildF1$1(module, r, \"fr\", \"frm\");\n\n    const pG1b = module.alloc(utils$2.bigInt2BytesLE( toMontgomery(3n), f1size ));\n    const g1mPrefix = buildCurve$1(module, \"g1m\", \"f1m\", pG1b);\n\n    buildFFT$2(module, \"frm\", \"frm\", \"frm\", \"frm_mul\");\n\n    buildPol$1(module, \"pol\", \"frm\");\n    buildQAP$1(module, \"qap\", \"frm\");\n\n    const f2mPrefix = buildF2m$1(module, \"f1m_neg\", \"f2m\", \"f1m\");\n    const pG2b = module.alloc([\n        ...utils$2.bigInt2BytesLE( toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size )\n    ]);\n    const g2mPrefix = buildCurve$1(module, \"g2m\", \"f2m\", pG2b);\n\n\n    function buildGTimesFr(fnName, opMul) {\n        const f = module.addFunction(fnName);\n        f.addParam(\"pG\", \"i32\");\n        f.addParam(\"pFr\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8));\n\n        f.addCode(\n            c.call(\"frm_fromMontgomery\", c.getLocal(\"pFr\"), AUX),\n            c.call(\n                opMul,\n                c.getLocal(\"pG\"),\n                AUX,\n                c.i32_const(n8),\n                c.getLocal(\"pr\")\n            )\n        );\n\n        module.exportFunction(fnName);\n    }\n    buildGTimesFr(\"g1m_timesFr\", \"g1m_timesScalar\");\n    buildFFT$2(module, \"g1m\", \"g1m\", \"frm\", \"g1m_timesFr\");\n\n    buildGTimesFr(\"g2m_timesFr\", \"g2m_timesScalar\");\n    buildFFT$2(module, \"g2m\", \"g2m\", \"frm\", \"g2m_timesFr\");\n\n    buildGTimesFr(\"g1m_timesFrAffine\", \"g1m_timesScalarAffine\");\n    buildGTimesFr(\"g2m_timesFrAffine\", \"g2m_timesScalarAffine\");\n\n    buildApplyKey$1(module, \"frm_batchApplyKey\", \"fmr\", \"frm\", n8, n8, n8, \"frm_mul\");\n    buildApplyKey$1(module, \"g1m_batchApplyKey\", \"g1m\", \"frm\", n8*3, n8*3, n8, \"g1m_timesFr\");\n    buildApplyKey$1(module, \"g1m_batchApplyKeyMixed\", \"g1m\", \"frm\", n8*2, n8*3, n8, \"g1m_timesFrAffine\");\n    buildApplyKey$1(module, \"g2m_batchApplyKey\", \"g2m\", \"frm\", n8*2*3, n8*3*2, n8, \"g2m_timesFr\");\n    buildApplyKey$1(module, \"g2m_batchApplyKeyMixed\", \"g2m\", \"frm\", n8*2*2, n8*3*2, n8, \"g2m_timesFrAffine\");\n\n    function toMontgomery(a) {\n        return BigInt(a) * ( 1n << BigInt(f1size*8)) % q;\n    }\n\n    const G1gen = [\n        1n,\n        2n,\n        1n\n    ];\n\n    const pG1gen = module.alloc(\n        [\n            ...utils$2.bigInt2BytesLE( toMontgomery(G1gen[0]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G1gen[1]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G1gen[2]), f1size ),\n        ]\n    );\n\n    const G1zero = [\n        0n,\n        1n,\n        0n\n    ];\n\n    const pG1zero = module.alloc(\n        [\n            ...utils$2.bigInt2BytesLE( toMontgomery(G1zero[0]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G1zero[1]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G1zero[2]), f1size )\n        ]\n    );\n\n    const G2gen = [\n        [\n            10857046999023057135944570762232829481370756359578518086990519993285655852781n,\n            11559732032986387107991004021392285783925812861821192530917403151452391805634n,\n        ],[\n            8495653923123431417604973247489272438418190587263600148770280649306958101930n,\n            4082367875863433681332203403145435568316851327593401208105741076214120093531n,\n        ],[\n            1n,\n            0n,\n        ]\n    ];\n\n    const pG2gen = module.alloc(\n        [\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2gen[0][0]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2gen[0][1]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2gen[1][0]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2gen[1][1]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2gen[2][0]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2gen[2][1]), f1size ),\n        ]\n    );\n\n    const G2zero = [\n        [\n            0n,\n            0n,\n        ],[\n            1n,\n            0n,\n        ],[\n            0n,\n            0n,\n        ]\n    ];\n\n    const pG2zero = module.alloc(\n        [\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2zero[0][0]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2zero[0][1]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2zero[1][0]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2zero[1][1]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2zero[2][0]), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(G2zero[2][1]), f1size ),\n        ]\n    );\n\n    const pOneT = module.alloc([\n        ...utils$2.bigInt2BytesLE( toMontgomery(1), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(0), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(0), f1size ),\n    ]);\n\n    const pNonResidueF6 = module.alloc([\n        ...utils$2.bigInt2BytesLE( toMontgomery(9), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(1), f1size ),\n    ]);\n\n    const pTwoInv = module.alloc([\n        ...utils$2.bigInt2BytesLE( toMontgomery(  modInv(2n, q)), f1size ),\n        ...utils$2.bigInt2BytesLE( 0n, f1size )\n    ]);\n\n    const pAltBn128Twist = pNonResidueF6;\n\n    const pTwistCoefB = module.alloc([\n        ...utils$2.bigInt2BytesLE( toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size ),\n        ...utils$2.bigInt2BytesLE( toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size ),\n    ]);\n\n    function build_mulNR6() {\n        const f = module.addFunction(prefix + \"_mulNR6\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(\n                f2mPrefix + \"_mul\",\n                c.i32_const(pNonResidueF6),\n                c.getLocal(\"x\"),\n                c.getLocal(\"pr\")\n            )\n        );\n    }\n    build_mulNR6();\n\n    const f6mPrefix = buildF3m$1(module, prefix+\"_mulNR6\", \"f6m\", \"f2m\");\n\n    function build_mulNR12() {\n        const f = module.addFunction(prefix + \"_mulNR12\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(\n                f2mPrefix + \"_mul\",\n                c.i32_const(pNonResidueF6),\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8*4)),\n                c.getLocal(\"pr\")\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.getLocal(\"x\"),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*2)),\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8*2)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8*4)),\n            )\n        );\n    }\n    build_mulNR12();\n\n    const ftmPrefix = buildF2m$1(module, prefix+\"_mulNR12\", \"ftm\", f6mPrefix);\n\n\n    const ateLoopCount = 29793968203157093288n;\n    const ateLoopBitBytes = bits(ateLoopCount);\n    const pAteLoopBitBytes = module.alloc(ateLoopBitBytes);\n\n    const ateCoefSize = 3 * f2size;\n    const ateNDblCoefs = ateLoopBitBytes.length-1;\n    const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) =>  acc + ( b!=0 ? 1 : 0)   ,0);\n    const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;\n    const prePSize = 3*2*n8;\n    const preQSize = 3*n8*2 + ateNCoefs*ateCoefSize;\n\n\n    module.modules[prefix] = {\n        n64: n64,\n        pG1gen: pG1gen,\n        pG1zero: pG1zero,\n        pG1b: pG1b,\n        pG2gen: pG2gen,\n        pG2zero: pG2zero,\n        pG2b: pG2b,\n        pq: module.modules[\"f1m\"].pq,\n        pr: pr,\n        pOneT: pOneT,\n        prePSize: prePSize,\n        preQSize: preQSize,\n        r: r.toString(),\n        q: q.toString()\n    };\n\n    // console.log(\"PrePSize: \" +prePSize);\n    // console.log(\"PreQSize: \" +preQSize);\n\n    const finalExpZ = 4965661367192848881n;\n\n    function naf(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd$1(E)) {\n                const z = 2 - Number(E % 4n);\n                res.push( z );\n                E = E - BigInt(z);\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function bits(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd$1(E)) {\n                res.push( 1 );\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function buildPrepareG1() {\n        const f = module.addFunction(prefix+ \"_prepareG1\");\n        f.addParam(\"pP\", \"i32\");\n        f.addParam(\"ppreP\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(g1mPrefix + \"_normalize\", c.getLocal(\"pP\"), c.getLocal(\"ppreP\")),  // TODO Remove if already in affine\n        );\n    }\n\n    function buildPrepAddStep() {\n        const f = module.addFunction(prefix+ \"_prepAddStep\");\n        f.addParam(\"pQ\", \"i32\");\n        f.addParam(\"pR\", \"i32\");\n        f.addParam(\"pCoef\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const X2  = c.getLocal(\"pQ\");\n        const Y2  = c.i32_add(c.getLocal(\"pQ\"), c.i32_const(f2size));\n\n        const X1  = c.getLocal(\"pR\");\n        const Y1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f2size));\n        const Z1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(2*f2size));\n\n        const ELL_0  = c.getLocal(\"pCoef\");\n        const ELL_VW = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(f2size));\n        const ELL_VV  = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(2*f2size));\n\n        const D = ELL_VW;\n        const E = c.i32_const(module.alloc(f2size));\n        const F = c.i32_const(module.alloc(f2size));\n        const G = c.i32_const(module.alloc(f2size));\n        const H = c.i32_const(module.alloc(f2size));\n        const I = c.i32_const(module.alloc(f2size));\n        const J = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n            // D = X1 - X2*Z1\n            c.call(f2mPrefix + \"_mul\", X2, Z1, D),\n            c.call(f2mPrefix + \"_sub\", X1, D, D),\n\n            // E = Y1 - Y2*Z1\n            c.call(f2mPrefix + \"_mul\", Y2, Z1, E),\n            c.call(f2mPrefix + \"_sub\", Y1, E, E),\n\n            // F = D^2\n            c.call(f2mPrefix + \"_square\", D, F),\n\n            // G = E^2\n            c.call(f2mPrefix + \"_square\", E, G),\n\n            // H = D*F\n            c.call(f2mPrefix + \"_mul\", D, F, H),\n\n            // I = X1 * F\n            c.call(f2mPrefix + \"_mul\", X1, F, I),\n\n            // J = H + Z1*G - (I+I)\n            c.call(f2mPrefix + \"_add\", I, I, AUX),\n            c.call(f2mPrefix + \"_mul\", Z1, G, J),\n            c.call(f2mPrefix + \"_add\", H, J, J),\n            c.call(f2mPrefix + \"_sub\", J, AUX, J),\n\n\n            // X3 (X1) = D*J\n            c.call(f2mPrefix + \"_mul\", D, J, X1),\n\n            // Y3 (Y1) = E*(I-J)-(H*Y1)\n            c.call(f2mPrefix + \"_mul\", H, Y1, Y1),\n            c.call(f2mPrefix + \"_sub\", I, J, AUX),\n            c.call(f2mPrefix + \"_mul\", E, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", AUX, Y1, Y1),\n\n            // Z3 (Z1) = Z1*H\n            c.call(f2mPrefix + \"_mul\", Z1, H, Z1),\n\n            // ell_0 = xi * (E * X2 - D * Y2)\n            c.call(f2mPrefix + \"_mul\", D, Y2, AUX),\n            c.call(f2mPrefix + \"_mul\", E, X2, ELL_0),\n            c.call(f2mPrefix + \"_sub\", ELL_0, AUX, ELL_0),\n            c.call(f2mPrefix + \"_mul\", ELL_0, c.i32_const(pAltBn128Twist), ELL_0),\n\n\n            // ell_VV = - E (later: * xP)\n            c.call(f2mPrefix + \"_neg\", E, ELL_VV),\n\n            // ell_VW = D (later: * yP    )\n            // Already assigned\n\n        );\n    }\n\n\n\n    function buildPrepDoubleStep() {\n        const f = module.addFunction(prefix+ \"_prepDblStep\");\n        f.addParam(\"pR\", \"i32\");\n        f.addParam(\"pCoef\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const X1  = c.getLocal(\"pR\");\n        const Y1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f2size));\n        const Z1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(2*f2size));\n\n        const ELL_0  = c.getLocal(\"pCoef\");\n        const ELL_VW = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(f2size));\n        const ELL_VV  = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(2*f2size));\n\n        const A = c.i32_const(module.alloc(f2size));\n        const B = c.i32_const(module.alloc(f2size));\n        const C = c.i32_const(module.alloc(f2size));\n        const D = c.i32_const(module.alloc(f2size));\n        const E = c.i32_const(module.alloc(f2size));\n        const F = c.i32_const(module.alloc(f2size));\n        const G = c.i32_const(module.alloc(f2size));\n        const H = c.i32_const(module.alloc(f2size));\n        const I = c.i32_const(module.alloc(f2size));\n        const J = c.i32_const(module.alloc(f2size));\n        const E2 = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // A = X1 * Y1 / 2\n            c.call(f2mPrefix + \"_mul\", Y1, c.i32_const(pTwoInv), A),\n            c.call(f2mPrefix + \"_mul\", X1, A, A),\n\n            // B = Y1^2\n            c.call(f2mPrefix + \"_square\", Y1, B),\n\n            // C = Z1^2\n            c.call(f2mPrefix + \"_square\", Z1, C),\n\n            // D = 3 * C\n            c.call(f2mPrefix + \"_add\", C, C, D),\n            c.call(f2mPrefix + \"_add\", D, C, D),\n\n            // E = twist_b * D\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pTwistCoefB), D, E),\n\n            // F = 3 * E\n            c.call(f2mPrefix + \"_add\", E, E, F),\n            c.call(f2mPrefix + \"_add\", E, F, F),\n\n            // G = (B+F)/2\n            c.call(f2mPrefix + \"_add\", B, F, G),\n            c.call(f2mPrefix + \"_mul\", G, c.i32_const(pTwoInv), G),\n\n            // H = (Y1+Z1)^2-(B+C)\n            c.call(f2mPrefix + \"_add\", B, C, AUX),\n            c.call(f2mPrefix + \"_add\", Y1, Z1, H),\n            c.call(f2mPrefix + \"_square\", H, H),\n            c.call(f2mPrefix + \"_sub\", H, AUX, H),\n\n            // I = E-B\n            c.call(f2mPrefix + \"_sub\", E, B, I),\n\n            // J = X1^2\n            c.call(f2mPrefix + \"_square\", X1, J),\n\n            // E_squared = E^2\n            c.call(f2mPrefix + \"_square\", E, E2),\n\n            // X3 (X1) = A * (B-F)\n            c.call(f2mPrefix + \"_sub\", B, F, AUX),\n            c.call(f2mPrefix + \"_mul\", A, AUX, X1),\n\n            // Y3 (Y1) = G^2 - 3*E^2\n            c.call(f2mPrefix + \"_add\", E2, E2, AUX),\n            c.call(f2mPrefix + \"_add\", E2, AUX, AUX),\n            c.call(f2mPrefix + \"_square\", G, Y1),\n            c.call(f2mPrefix + \"_sub\", Y1, AUX, Y1),\n\n            // Z3 (Z1) = B * H\n            c.call(f2mPrefix + \"_mul\", B, H, Z1),\n\n            // ell_0 = xi * I\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pAltBn128Twist), I, ELL_0),\n\n            // ell_VW = - H (later: * yP)\n            c.call(f2mPrefix + \"_neg\", H, ELL_VW),\n\n            // ell_VV = 3*J (later: * xP)\n            c.call(f2mPrefix + \"_add\", J, J, ELL_VV),\n            c.call(f2mPrefix + \"_add\", J, ELL_VV, ELL_VV),\n\n        );\n    }\n\n    function buildMulByQ() {\n        const f = module.addFunction(prefix + \"_mulByQ\");\n        f.addParam(\"p1\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"p1\");\n        const y = c.i32_add(c.getLocal(\"p1\"), c.i32_const(f2size));\n        const z = c.i32_add(c.getLocal(\"p1\"), c.i32_const(f2size*2));\n        const x3 = c.getLocal(\"pr\");\n        const y3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(f2size));\n        const z3 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(f2size*2));\n\n        const MulByQX = c.i32_const(module.alloc([\n            ...utils$2.bigInt2BytesLE( toMontgomery(\"21575463638280843010398324269430826099269044274347216827212613867836435027261\"), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(\"10307601595873709700152284273816112264069230130616436755625194854815875713954\"), f1size ),\n        ]));\n\n        const MulByQY = c.i32_const(module.alloc([\n            ...utils$2.bigInt2BytesLE( toMontgomery(\"2821565182194536844548159561693502659359617185244120367078079554186484126554\"), f1size ),\n            ...utils$2.bigInt2BytesLE( toMontgomery(\"3505843767911556378687030309984248845540243509899259641013678093033130930403\"), f1size ),\n        ]));\n\n        f.addCode(\n            // The frobeniusMap(1) in this field, is the conjugate\n            c.call(f2mPrefix + \"_conjugate\", x, x3),\n            c.call(f2mPrefix + \"_mul\", MulByQX, x3, x3),\n            c.call(f2mPrefix + \"_conjugate\", y, y3),\n            c.call(f2mPrefix + \"_mul\", MulByQY, y3, y3),\n            c.call(f2mPrefix + \"_conjugate\", z, z3),\n        );\n    }\n\n\n    function buildPrepareG2() {\n        buildMulByQ();\n        const f = module.addFunction(prefix+ \"_prepareG2\");\n        f.addParam(\"pQ\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const QX = c.getLocal(\"pQ\");\n\n        const pR = module.alloc(f2size*3);\n        const R = c.i32_const(pR);\n        const RX = c.i32_const(pR);\n        const RY = c.i32_const(pR+f2size);\n        const RZ = c.i32_const(pR+2*f2size);\n\n        const cQX = c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(0));\n        const cQY = c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size));\n\n        const pQ1 = module.alloc(f2size*3);\n        const Q1 = c.i32_const(pQ1);\n\n        const pQ2 = module.alloc(f2size*3);\n        const Q2 = c.i32_const(pQ2);\n        const Q2Y = c.i32_const(pQ2 + f2size);\n\n        f.addCode(\n            c.call(g2mPrefix + \"_normalize\", QX, cQX),  // TODO Remove if already in affine\n            c.call(f2mPrefix + \"_copy\", cQX, RX),\n            c.call(f2mPrefix + \"_copy\", cQY, RY),\n            c.call(f2mPrefix + \"_one\", RZ),\n        );\n\n        f.addCode(\n            c.setLocal(\"pCoef\", c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n                c.call(prefix + \"_prepDblStep\", R, c.getLocal(\"pCoef\")),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(prefix + \"_prepAddStep\", cQX, R, c.getLocal(\"pCoef\")),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n                    ]\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n\n        f.addCode(\n            c.call(prefix + \"_mulByQ\", cQX, Q1),\n            c.call(prefix + \"_mulByQ\", Q1, Q2)\n        );\n\n        f.addCode(\n            c.call(f2mPrefix + \"_neg\", Q2Y, Q2Y),\n\n            c.call(prefix + \"_prepAddStep\", Q1, R, c.getLocal(\"pCoef\")),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n            c.call(prefix + \"_prepAddStep\", Q2, R, c.getLocal(\"pCoef\")),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n        );\n    }\n\n    function buildMulBy024Old() {\n        const f = module.addFunction(prefix+ \"__mulBy024Old\");\n        f.addParam(\"pEll0\", \"i32\");\n        f.addParam(\"pEllVW\", \"i32\");\n        f.addParam(\"pEllVV\", \"i32\");\n        f.addParam(\"pR\", \"i32\");            // Result in F12\n\n        const c = f.getCodeBuilder();\n\n        const x0  = c.getLocal(\"pEll0\");\n        const x2  = c.getLocal(\"pEllVV\");\n        const x4  = c.getLocal(\"pEllVW\");\n\n        const z0  = c.getLocal(\"pR\");\n\n        const pAUX12 = module.alloc(ftsize);\n        const AUX12 = c.i32_const(pAUX12);\n        const AUX12_0 = c.i32_const(pAUX12);\n        const AUX12_2 = c.i32_const(pAUX12+f2size);\n        const AUX12_4 = c.i32_const(pAUX12+f2size*2);\n        const AUX12_6 = c.i32_const(pAUX12+f2size*3);\n        const AUX12_8 = c.i32_const(pAUX12+f2size*4);\n        const AUX12_10 = c.i32_const(pAUX12+f2size*5);\n\n        f.addCode(\n\n            c.call(f2mPrefix + \"_copy\", x0, AUX12_0),\n            c.call(f2mPrefix + \"_zero\", AUX12_2),\n            c.call(f2mPrefix + \"_copy\", x2, AUX12_4),\n            c.call(f2mPrefix + \"_zero\", AUX12_6),\n            c.call(f2mPrefix + \"_copy\", x4, AUX12_8),\n            c.call(f2mPrefix + \"_zero\", AUX12_10),\n            c.call(ftmPrefix + \"_mul\", AUX12, z0, z0),\n        );\n    }\n\n    function buildMulBy024() {\n        const f = module.addFunction(prefix+ \"__mulBy024\");\n        f.addParam(\"pEll0\", \"i32\");\n        f.addParam(\"pEllVW\", \"i32\");\n        f.addParam(\"pEllVV\", \"i32\");\n        f.addParam(\"pR\", \"i32\");            // Result in F12\n\n        const c = f.getCodeBuilder();\n\n        const x0  = c.getLocal(\"pEll0\");\n        const x2  = c.getLocal(\"pEllVV\");\n        const x4  = c.getLocal(\"pEllVW\");\n\n        const z0  = c.getLocal(\"pR\");\n        const z1  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(2*n8));\n        const z2  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(4*n8));\n        const z3  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(6*n8));\n        const z4  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(8*n8));\n        const z5  = c.i32_add(c.getLocal(\"pR\"), c.i32_const(10*n8));\n\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const s0 = c.i32_const(module.alloc(f2size));\n        const T3 = c.i32_const(module.alloc(f2size));\n        const T4 = c.i32_const(module.alloc(f2size));\n        const D0 = c.i32_const(module.alloc(f2size));\n        const D2 = c.i32_const(module.alloc(f2size));\n        const D4 = c.i32_const(module.alloc(f2size));\n        const S1 = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // D0 = z0 * x0;\n            c.call(f2mPrefix + \"_mul\", z0, x0, D0),\n            // D2 = z2 * x2;\n            c.call(f2mPrefix + \"_mul\", z2, x2, D2),\n            // D4 = z4 * x4;\n            c.call(f2mPrefix + \"_mul\", z4, x4, D4),\n            // t2 = z0 + z4;\n            c.call(f2mPrefix + \"_add\", z0, z4, t2),\n            // t1 = z0 + z2;\n            c.call(f2mPrefix + \"_add\", z0, z2, t1),\n            // s0 = z1 + z3 + z5;\n            c.call(f2mPrefix + \"_add\", z1, z3, s0),\n            c.call(f2mPrefix + \"_add\", s0, z5, s0),\n\n\n            // For z.a_.a_ = z0.\n            // S1 = z1 * x2;\n            c.call(f2mPrefix + \"_mul\", z1, x2, S1),\n            // T3 = S1 + D4;\n            c.call(f2mPrefix + \"_add\", S1, D4, T3),\n            // T4 = my_Fp6::non_residue * T3 + D0;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            c.call(f2mPrefix + \"_add\", T4, D0, z0),\n            // z0 = T4;\n\n            // For z.a_.b_ = z1\n            // T3 = z5 * x4;\n            c.call(f2mPrefix + \"_mul\", z5, x4, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T3 = T3 + D2;\n            c.call(f2mPrefix + \"_add\", T3, D2, T3),\n            // T4 = my_Fp6::non_residue * T3;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            // T3 = z1 * x0;\n            c.call(f2mPrefix + \"_mul\", z1, x0, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T4 = T4 + T3;\n            c.call(f2mPrefix + \"_add\", T4, T3, z1),\n            // z1 = T4;\n\n\n\n            // For z.a_.c_ = z2\n            // t0 = x0 + x2;\n            c.call(f2mPrefix + \"_add\", x0, x2, t0),\n            // T3 = t1 * t0 - D0 - D2;\n            c.call(f2mPrefix + \"_mul\", t1, t0, T3),\n            c.call(f2mPrefix + \"_add\", D0, D2, AUX),\n            c.call(f2mPrefix + \"_sub\", T3, AUX, T3),\n            // T4 = z3 * x4;\n            c.call(f2mPrefix + \"_mul\", z3, x4, T4),\n            // S1 = S1 + T4;\n            c.call(f2mPrefix + \"_add\", S1, T4, S1),\n\n\n            // For z.b_.a_ = z3 (z3 needs z2)\n            // t0 = z2 + z4;\n            c.call(f2mPrefix + \"_add\", z2, z4, t0),\n            // T3 = T3 + T4;\n            // z2 = T3;\n            c.call(f2mPrefix + \"_add\", T3, T4, z2),\n            // t1 = x2 + x4;\n            c.call(f2mPrefix + \"_add\", x2, x4, t1),\n            // T3 = t0 * t1 - D2 - D4;\n            c.call(f2mPrefix + \"_mul\", t1, t0, T3),\n            c.call(f2mPrefix + \"_add\", D2, D4, AUX),\n            c.call(f2mPrefix + \"_sub\", T3, AUX, T3),\n            // T4 = my_Fp6::non_residue * T3;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            // T3 = z3 * x0;\n            c.call(f2mPrefix + \"_mul\", z3, x0, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T4 = T4 + T3;\n            c.call(f2mPrefix + \"_add\", T4, T3, z3),\n            // z3 = T4;\n\n            // For z.b_.b_ = z4\n            // T3 = z5 * x2;\n            c.call(f2mPrefix + \"_mul\", z5, x2, T3),\n            // S1 = S1 + T3;\n            c.call(f2mPrefix + \"_add\", S1, T3, S1),\n            // T4 = my_Fp6::non_residue * T3;\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), T3, T4),\n            // t0 = x0 + x4;\n            c.call(f2mPrefix + \"_add\", x0, x4, t0),\n            // T3 = t2 * t0 - D0 - D4;\n            c.call(f2mPrefix + \"_mul\", t2, t0, T3),\n            c.call(f2mPrefix + \"_add\", D0, D4, AUX),\n            c.call(f2mPrefix + \"_sub\", T3, AUX, T3),\n            // T4 = T4 + T3;\n            c.call(f2mPrefix + \"_add\", T4, T3, z4),\n            // z4 = T4;\n\n            // For z.b_.c_ = z5.\n            // t0 = x0 + x2 + x4;\n            c.call(f2mPrefix + \"_add\", x0, x2, t0),\n            c.call(f2mPrefix + \"_add\", t0, x4, t0),\n            // T3 = s0 * t0 - S1;\n            c.call(f2mPrefix + \"_mul\", s0, t0, T3),\n            c.call(f2mPrefix + \"_sub\", T3, S1, z5),\n            // z5 = T3;\n\n        );\n    }\n\n\n    function buildMillerLoop() {\n        const f = module.addFunction(prefix+ \"_millerLoop\");\n        f.addParam(\"ppreP\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const preP_PX = c.getLocal(\"ppreP\");\n        const preP_PY = c.i32_add(c.getLocal(\"ppreP\"), c.i32_const(f1size));\n\n        const ELL_0  = c.getLocal(\"pCoef\");\n        const ELL_VW = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(f2size));\n        const ELL_VV  = c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(2*f2size));\n\n\n        const pVW = module.alloc(f2size);\n        const VW = c.i32_const(pVW);\n        const pVV = module.alloc(f2size);\n        const VV = c.i32_const(pVV);\n\n        const F = c.getLocal(\"r\");\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_one\", F),\n\n            c.setLocal(\"pCoef\", c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n\n                c.call(ftmPrefix + \"_square\", F, F),\n\n                c.call(f2mPrefix + \"_mul1\", ELL_VW,preP_PY, VW),\n                c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n                c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(f2mPrefix + \"_mul1\", ELL_VW, preP_PY, VW),\n                        ...c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n\n                        ...c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                    ]\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n\n        );\n\n        f.addCode(\n            c.call(f2mPrefix + \"_mul1\", ELL_VW, preP_PY, VW),\n            c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n            c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n            c.call(f2mPrefix + \"_mul1\", ELL_VW, preP_PY, VW),\n            c.call(f2mPrefix + \"_mul1\", ELL_VV, preP_PX, VV),\n            c.call(prefix + \"__mulBy024\", ELL_0, VW, VV, F),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n        );\n\n    }\n\n\n    function buildFrobeniusMap(n) {\n        const F12 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [8376118865763821496583973867626364092589906065868298776909617916018768340080n, 16469823323077808223889137241176536799009286646108169935659301613961712198316n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556617n, 0n],\n                [11697423496358154304825782922584725312912383441159505038794027105778954184319n, 303847389135065887422783454877609941456349188919719272345083954437860409601n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],\n                [3321304630594332808241809054958361220322477375291206261884409189760185844239n, 5722266937896532885780051958958348231143373700109372999374820235121374419868n],\n                [21888242871839275222246405745257275088696311157297823662689037894645226208582n, 0n],\n                [13512124006075453725662431877630910996106405091429524885779419978626457868503n, 5418419548761466998357268504080738289687024511189653727029736280683514010267n],\n                [2203960485148121921418603742825762020974279258880205651966n, 0n],\n                [10190819375481120917420622822672549775783927716138318623895010788866272024264n, 21584395482704209334823622290379665147239961968378104390343953940207365798982n],\n                [2203960485148121921418603742825762020974279258880205651967n, 0n],\n                [18566938241244942414004596690298913868373833782006617400804628704885040364344n, 16165975933942742336466353786298926857552937457188450663314217659523851788715n],\n            ]\n        ];\n\n        const F6 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [21575463638280843010398324269430826099269044274347216827212613867836435027261n, 10307601595873709700152284273816112264069230130616436755625194854815875713954n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],\n                [3772000881919853776433695186713858239009073593817195771773381919316419345261n, 2236595495967245188281701248203181795121068902605861227855261137820944008926n],\n                [2203960485148121921418603742825762020974279258880205651966n, 0n],\n                [18429021223477853657660792034369865839114504446431234726392080002137598044644n, 9344045779998320333812420223237981029506012124075525679208581902008406485703n],\n            ],\n            [\n                [1n, 0n],\n                [2581911344467009335267311115468803099551665605076196740867805258568234346338n, 19937756971775647987995932169929341994314640652964949448313374472400716661030n],\n                [2203960485148121921418603742825762020974279258880205651966n, 0n],\n                [5324479202449903542726783395506214481928257762400643279780343368557297135718n, 16208900380737693084919495127334387981393726419856888799917914180988844123039n],\n                [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],\n                [13981852324922362344252311234282257507216387789820983642040889267519694726527n, 7629828391165209371577384193250820201684255241773809077146787135900891633097n],\n            ]\n        ];\n\n        const f = module.addFunction(prefix+ \"__frobeniusMap\"+n);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<6; i++) {\n            const X = (i==0) ? c.getLocal(\"x\") : c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size));\n            const Xc0 = X;\n            const Xc1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size + f1size));\n            const R = (i==0) ? c.getLocal(\"r\") : c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size));\n            const Rc0 = R;\n            const Rc1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size + f1size));\n            const coef = mul2(F12[Math.floor(i/3)][n%12] , F6[i%3][n%6]);\n            const pCoef = module.alloc([\n                ...utils$2.bigInt2BytesLE(toMontgomery(coef[0]), 32),\n                ...utils$2.bigInt2BytesLE(toMontgomery(coef[1]), 32),\n            ]);\n            if (n%2 == 1) {\n                f.addCode(\n                    c.call(f1mPrefix + \"_copy\", Xc0, Rc0),\n                    c.call(f1mPrefix + \"_neg\", Xc1, Rc1),\n                    c.call(f2mPrefix + \"_mul\", R, c.i32_const(pCoef), R),\n                );\n            } else {\n                f.addCode(c.call(f2mPrefix + \"_mul\", X, c.i32_const(pCoef), R));\n            }\n        }\n\n        function mul2(a, b) {\n            const ac0 = BigInt(a[0]);\n            const ac1 = BigInt(a[1]);\n            const bc0 = BigInt(b[0]);\n            const bc1 = BigInt(b[1]);\n            const res = [\n                (ac0 * bc0 - (  ac1 * bc1)  ) % q,\n                (ac0 * bc1 + (  ac1 * bc0)  ) % q,\n            ];\n            if (isNegative$2(res[0])) res[0] = res[0] + q;\n            return res;\n        }\n\n    }\n\n\n\n    function buildFinalExponentiationFirstChunk() {\n\n        const f = module.addFunction(prefix+ \"__finalExponentiationFirstChunk\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const eltC0 = elt;\n        const eltC1 = c.i32_add(elt, c.i32_const(n8*6));\n        const r = c.getLocal(\"r\");\n        const pA = module.alloc(ftsize);\n        const A = c.i32_const(pA);\n        const Ac0 = A;\n        const Ac1 = c.i32_const(pA + n8*6);\n        const B = c.i32_const(module.alloc(ftsize));\n        const C = c.i32_const(module.alloc(ftsize));\n        const D = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n            // const alt_bn128_Fq12 A = alt_bn128_Fq12(elt.c0,-elt.c1);\n            c.call(f6mPrefix + \"_copy\", eltC0, Ac0),\n            c.call(f6mPrefix + \"_neg\", eltC1, Ac1),\n\n            // const alt_bn128_Fq12 B = elt.inverse();\n            c.call(ftmPrefix + \"_inverse\", elt, B),\n\n            // const alt_bn128_Fq12 C = A * B;\n            c.call(ftmPrefix + \"_mul\", A, B, C),\n            // const alt_bn128_Fq12 D = C.Frobenius_map(2);\n            c.call(prefix + \"__frobeniusMap2\", C, D),\n            // const alt_bn128_Fq12 result = D * C;\n            c.call(ftmPrefix + \"_mul\", C, D, r),\n        );\n    }\n\n    function buildCyclotomicSquare() {\n        const f = module.addFunction(prefix+ \"__cyclotomicSquare\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x4 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f2size));\n        const x3 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f2size));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(3*f2size));\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(4*f2size));\n        const x5 = c.i32_add(c.getLocal(\"x\"), c.i32_const(5*f2size));\n\n        const r0 = c.getLocal(\"r\");\n        const r4 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f2size));\n        const r3 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f2size));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(3*f2size));\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*f2size));\n        const r5 = c.i32_add(c.getLocal(\"r\"), c.i32_const(5*f2size));\n\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t3 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n        const tmp = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n\n        f.addCode(\n            //    // t0 + t1*y = (z0 + z1*y)^2 = a^2\n            //    tmp = z0 * z1;\n            //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;\n            //    t1 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x0, x1, tmp),\n            c.call(f2mPrefix + \"_mul\", x1, c.i32_const(pNonResidueF6), t0),\n            c.call(f2mPrefix + \"_add\", x0, t0, t0),\n            c.call(f2mPrefix + \"_add\", x0, x1, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t0, t0),\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t0, AUX, t0),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t1),\n\n            //  // t2 + t3*y = (z2 + z3*y)^2 = b^2\n            //  tmp = z2 * z3;\n            //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;\n            //  t3 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x2, x3, tmp),\n            c.call(f2mPrefix + \"_mul\", x3, c.i32_const(pNonResidueF6), t2),\n            c.call(f2mPrefix + \"_add\", x2, t2, t2),\n            c.call(f2mPrefix + \"_add\", x2, x3, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t2, t2),\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t2, AUX, t2),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t3),\n\n            //  // t4 + t5*y = (z4 + z5*y)^2 = c^2\n            //  tmp = z4 * z5;\n            //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;\n            //  t5 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x4, x5, tmp),\n            c.call(f2mPrefix + \"_mul\", x5, c.i32_const(pNonResidueF6), t4),\n            c.call(f2mPrefix + \"_add\", x4, t4, t4),\n            c.call(f2mPrefix + \"_add\", x4, x5, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t4, t4),\n            c.call(f2mPrefix + \"_mul\", c.i32_const(pNonResidueF6), tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t4, AUX, t4),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t5),\n\n            // For A\n            // z0 = 3 * t0 - 2 * z0\n            c.call(f2mPrefix + \"_sub\", t0, x0, r0),\n            c.call(f2mPrefix + \"_add\", r0, r0, r0),\n            c.call(f2mPrefix + \"_add\", t0, r0, r0),\n            // z1 = 3 * t1 + 2 * z1\n            c.call(f2mPrefix + \"_add\", t1, x1, r1),\n            c.call(f2mPrefix + \"_add\", r1, r1, r1),\n            c.call(f2mPrefix + \"_add\", t1, r1, r1),\n\n            // For B\n            // z2 = 3 * (xi * t5) + 2 * z2\n            c.call(f2mPrefix + \"_mul\", t5, c.i32_const(pAltBn128Twist), AUX),\n            c.call(f2mPrefix + \"_add\", AUX, x2, r2),\n            c.call(f2mPrefix + \"_add\", r2, r2, r2),\n            c.call(f2mPrefix + \"_add\", AUX, r2, r2),\n            // z3 = 3 * t4 - 2 * z3\n            c.call(f2mPrefix + \"_sub\", t4, x3, r3),\n            c.call(f2mPrefix + \"_add\", r3, r3, r3),\n            c.call(f2mPrefix + \"_add\", t4, r3, r3),\n\n            // For C\n            // z4 = 3 * t2 - 2 * z4\n            c.call(f2mPrefix + \"_sub\", t2, x4, r4),\n            c.call(f2mPrefix + \"_add\", r4, r4, r4),\n            c.call(f2mPrefix + \"_add\", t2, r4, r4),\n            // z5 = 3 * t3 + 2 * z5\n            c.call(f2mPrefix + \"_add\", t3, x5, r5),\n            c.call(f2mPrefix + \"_add\", r5, r5, r5),\n            c.call(f2mPrefix + \"_add\", t3, r5, r5),\n\n        );\n    }\n\n\n    function buildCyclotomicExp(exponent, fnName) {\n        const exponentNafBytes = naf(exponent).map( (b) => (b==-1 ? 0xFF: b) );\n        const pExponentNafBytes = module.alloc(exponentNafBytes);\n\n        const f = module.addFunction(prefix+ \"__cyclotomicExp_\"+fnName);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"bit\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"x\");\n\n        const res = c.getLocal(\"r\");\n\n        const inverse = c.i32_const(module.alloc(ftsize));\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_conjugate\", x, inverse),\n            c.call(ftmPrefix + \"_one\", res),\n\n            c.if(\n                c.teeLocal(\"bit\", c.i32_load8_s(c.i32_const(exponentNafBytes.length-1), pExponentNafBytes)),\n                c.if(\n                    c.i32_eq(\n                        c.getLocal(\"bit\"),\n                        c.i32_const(1)\n                    ),\n                    c.call(ftmPrefix + \"_mul\", res, x, res),\n                    c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                )\n            ),\n\n            c.setLocal(\"i\", c.i32_const(exponentNafBytes.length-2)),\n            c.block(c.loop(\n                c.call(prefix + \"__cyclotomicSquare\", res, res),\n                c.if(\n                    c.teeLocal(\"bit\", c.i32_load8_s(c.getLocal(\"i\"), pExponentNafBytes)),\n                    c.if(\n                        c.i32_eq(\n                            c.getLocal(\"bit\"),\n                            c.i32_const(1)\n                        ),\n                        c.call(ftmPrefix + \"_mul\", res, x, res),\n                        c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                    )\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n\n    function buildFinalExponentiationLastChunk() {\n        buildCyclotomicSquare();\n        buildCyclotomicExp(finalExpZ, \"w0\");\n\n        const f = module.addFunction(prefix+ \"__finalExponentiationLastChunk\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const result = c.getLocal(\"r\");\n        const A = c.i32_const(module.alloc(ftsize));\n        const B = c.i32_const(module.alloc(ftsize));\n        const C = c.i32_const(module.alloc(ftsize));\n        const D = c.i32_const(module.alloc(ftsize));\n        const E = c.i32_const(module.alloc(ftsize));\n        const F = c.i32_const(module.alloc(ftsize));\n        const G = c.i32_const(module.alloc(ftsize));\n        const H = c.i32_const(module.alloc(ftsize));\n        const I = c.i32_const(module.alloc(ftsize));\n        const J = c.i32_const(module.alloc(ftsize));\n        const K = c.i32_const(module.alloc(ftsize));\n        const L = c.i32_const(module.alloc(ftsize));\n        const M = c.i32_const(module.alloc(ftsize));\n        const N = c.i32_const(module.alloc(ftsize));\n        const O = c.i32_const(module.alloc(ftsize));\n        const P = c.i32_const(module.alloc(ftsize));\n        const Q = c.i32_const(module.alloc(ftsize));\n        const R = c.i32_const(module.alloc(ftsize));\n        const S = c.i32_const(module.alloc(ftsize));\n        const T = c.i32_const(module.alloc(ftsize));\n        const U = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n\n\n            // A = exp_by_neg_z(elt)  // = elt^(-z)\n            c.call(prefix + \"__cyclotomicExp_w0\", elt, A),\n            c.call(ftmPrefix + \"_conjugate\", A, A),\n            // B = A^2                // = elt^(-2*z)\n            c.call(prefix + \"__cyclotomicSquare\", A, B),\n            // C = B^2                // = elt^(-4*z)\n            c.call(prefix + \"__cyclotomicSquare\", B, C),\n            // D = C * B              // = elt^(-6*z)\n            c.call(ftmPrefix + \"_mul\", C, B, D),\n            // E = exp_by_neg_z(D)    // = elt^(6*z^2)\n            c.call(prefix + \"__cyclotomicExp_w0\", D, E),\n            c.call(ftmPrefix + \"_conjugate\", E, E),\n            // F = E^2                // = elt^(12*z^2)\n            c.call(prefix + \"__cyclotomicSquare\", E, F),\n            // G = epx_by_neg_z(F)    // = elt^(-12*z^3)\n            c.call(prefix + \"__cyclotomicExp_w0\", F, G),\n            c.call(ftmPrefix + \"_conjugate\", G, G),\n            // H = conj(D)            // = elt^(6*z)\n            c.call(ftmPrefix + \"_conjugate\", D, H),\n            // I = conj(G)            // = elt^(12*z^3)\n            c.call(ftmPrefix + \"_conjugate\", G, I),\n            // J = I * E              // = elt^(12*z^3 + 6*z^2)\n            c.call(ftmPrefix + \"_mul\", I, E, J),\n            // K = J * H              // = elt^(12*z^3 + 6*z^2 + 6*z)\n            c.call(ftmPrefix + \"_mul\", J, H, K),\n            // L = K * B              // = elt^(12*z^3 + 6*z^2 + 4*z)\n            c.call(ftmPrefix + \"_mul\", K, B, L),\n            // M = K * E              // = elt^(12*z^3 + 12*z^2 + 6*z)\n            c.call(ftmPrefix + \"_mul\", K, E, M),\n\n            // N = M * elt            // = elt^(12*z^3 + 12*z^2 + 6*z + 1)\n            c.call(ftmPrefix + \"_mul\", M, elt, N),\n\n            // O = L.Frobenius_map(1) // = elt^(q*(12*z^3 + 6*z^2 + 4*z))\n            c.call(prefix + \"__frobeniusMap1\", L, O),\n            // P = O * N              // = elt^(q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))\n            c.call(ftmPrefix + \"_mul\", O, N, P),\n            // Q = K.Frobenius_map(2) // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z))\n            c.call(prefix + \"__frobeniusMap2\", K, Q),\n            // R = Q * P              // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))\n            c.call(ftmPrefix + \"_mul\", Q, P, R),\n            // S = conj(elt)          // = elt^(-1)\n            c.call(ftmPrefix + \"_conjugate\", elt, S),\n            // T = S * L              // = elt^(12*z^3 + 6*z^2 + 4*z - 1)\n            c.call(ftmPrefix + \"_mul\", S, L, T),\n            // U = T.Frobenius_map(3) // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1))\n            c.call(prefix + \"__frobeniusMap3\", T, U),\n            // V = U * R              // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1) + q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))\n            c.call(ftmPrefix + \"_mul\", U, R, result),\n            // result = V\n        );\n    }\n\n\n    function buildFinalExponentiation() {\n        buildFinalExponentiationFirstChunk();\n        buildFinalExponentiationLastChunk();\n        const f = module.addFunction(prefix+ \"_finalExponentiation\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const result = c.getLocal(\"r\");\n        const eltToFirstChunk = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n            c.call(prefix + \"__finalExponentiationFirstChunk\", elt, eltToFirstChunk ),\n            c.call(prefix + \"__finalExponentiationLastChunk\", eltToFirstChunk, result )\n        );\n    }\n\n\n    function buildFinalExponentiationOld() {\n        const f = module.addFunction(prefix+ \"_finalExponentiationOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const exponent = 552484233613224096312617126783173147097382103762957654188882734314196910839907541213974502761540629817009608548654680343627701153829446747810907373256841551006201639677726139946029199968412598804882391702273019083653272047566316584365559776493027495458238373902875937659943504873220554161550525926302303331747463515644711876653177129578303191095900909191624817826566688241804408081892785725967931714097716709526092261278071952560171111444072049229123565057483750161460024353346284167282452756217662335528813519139808291170539072125381230815729071544861602750936964829313608137325426383735122175229541155376346436093930287402089517426973178917569713384748081827255472576937471496195752727188261435633271238710131736096299798168852925540549342330775279877006784354801422249722573783561685179618816480037695005515426162362431072245638324744480n;\n\n        const pExponent = module.alloc(utils$2.bigInt2BytesLE( exponent, 352 ));\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(ftmPrefix + \"_exp\", c.getLocal(\"x\"), c.i32_const(pExponent), c.i32_const(352), c.getLocal(\"r\")),\n        );\n    }\n\n\n\n\n    const pPreP = module.alloc(prePSize);\n    const pPreQ = module.alloc(preQSize);\n\n    function buildPairingEquation(nPairings) {\n\n        const f = module.addFunction(prefix+ \"_pairingEq\"+nPairings);\n        for (let i=0; i<nPairings; i++) {\n            f.addParam(\"p_\"+i, \"i32\");\n            f.addParam(\"q_\"+i, \"i32\");\n        }\n        f.addParam(\"c\", \"i32\");\n        f.setReturnType(\"i32\");\n\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n        const auxT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(ftmPrefix + \"_one\", resT ));\n\n        for (let i=0; i<nPairings; i++) {\n\n            f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p_\"+i), c.i32_const(pPreP) ));\n            f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q_\"+i), c.i32_const(pPreQ) ));\n            f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), auxT ));\n\n            f.addCode(c.call(ftmPrefix + \"_mul\", resT, auxT, resT ));\n        }\n\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, resT ));\n\n        f.addCode(c.call(ftmPrefix + \"_eq\", resT, c.getLocal(\"c\")));\n    }\n\n\n    function buildPairing() {\n\n        const f = module.addFunction(prefix+ \"_pairing\");\n        f.addParam(\"p\", \"i32\");\n        f.addParam(\"q\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p\"), c.i32_const(pPreP) ));\n        f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q\"), c.i32_const(pPreQ) ));\n        f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), resT ));\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, c.getLocal(\"r\") ));\n    }\n\n\n    buildPrepAddStep();\n    buildPrepDoubleStep();\n\n    buildPrepareG1();\n    buildPrepareG2();\n\n    buildMulBy024();\n    buildMulBy024Old();\n    buildMillerLoop();\n\n\n    for (let i=0; i<10; i++) {\n        buildFrobeniusMap(i);\n        module.exportFunction(prefix + \"__frobeniusMap\"+i);\n    }\n\n    buildFinalExponentiationOld();\n    buildFinalExponentiation();\n\n    for (let i=1; i<=5; i++) {\n        buildPairingEquation(i);\n        module.exportFunction(prefix + \"_pairingEq\"+i);\n    }\n\n    buildPairing();\n\n    module.exportFunction(prefix + \"_pairing\");\n\n    module.exportFunction(prefix + \"_prepareG1\");\n    module.exportFunction(prefix + \"_prepareG2\");\n    module.exportFunction(prefix + \"_millerLoop\");\n    module.exportFunction(prefix + \"_finalExponentiation\");\n    module.exportFunction(prefix + \"_finalExponentiationOld\");\n    module.exportFunction(prefix + \"__mulBy024\");\n    module.exportFunction(prefix + \"__mulBy024Old\");\n    module.exportFunction(prefix + \"__cyclotomicSquare\");\n    module.exportFunction(prefix + \"__cyclotomicExp_w0\");\n\n    // console.log(module.functionIdxByName);\n\n};\n\nconst utils$1 = utils$6;\n\nconst buildF1m =build_f1m;\nconst buildF1 =build_f1;\nconst buildF2m =build_f2m;\nconst buildF3m =build_f3m;\nconst buildCurve =build_curve_jacobian_a0;\nconst buildFFT$1 = build_fft;\nconst buildPol = build_pol;\nconst buildQAP = build_qap;\nconst buildApplyKey = build_applykey;\nconst { bitLength: bitLength$1, isOdd, isNegative: isNegative$1 } = bigint;\n\n// Definition here: https://electriccoin.co/blog/new-snark-curve/\n\nvar build_bls12381 = function buildBLS12381(module, _prefix) {\n\n    const prefix = _prefix || \"bls12381\";\n\n    if (module.modules[prefix]) return prefix;  // already builded\n\n    const q = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    const r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;\n\n    const n64q = Math.floor((bitLength$1(q - 1n) - 1)/64) +1;\n    const n8q = n64q*8;\n    const f1size = n8q;\n    const f2size = f1size * 2;\n    const ftsize = f1size * 12;\n\n    const n64r = Math.floor((bitLength$1(r - 1n) - 1)/64) +1;\n    const n8r = n64r*8;\n    const frsize = n8r;\n\n\n    const pr = module.alloc(utils$1.bigInt2BytesLE( r, frsize ));\n\n    const f1mPrefix = buildF1m(module, q, \"f1m\", \"intq\");\n    buildF1(module, r, \"fr\", \"frm\", \"intr\");\n    const pG1b = module.alloc(utils$1.bigInt2BytesLE( toMontgomery(4n), f1size ));\n    const g1mPrefix = buildCurve(module, \"g1m\", \"f1m\", pG1b);\n\n    buildFFT$1(module, \"frm\", \"frm\", \"frm\", \"frm_mul\");\n\n    buildPol(module, \"pol\", \"frm\");\n    buildQAP(module, \"qap\", \"frm\");\n\n    const f2mPrefix = buildF2m(module, \"f1m_neg\", \"f2m\", \"f1m\");\n    const pG2b = module.alloc([\n        ...utils$1.bigInt2BytesLE( toMontgomery(4n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(4n), f1size )\n    ]);\n    const g2mPrefix = buildCurve(module, \"g2m\", \"f2m\", pG2b);\n\n\n    function buildGTimesFr(fnName, opMul) {\n        const f = module.addFunction(fnName);\n        f.addParam(\"pG\", \"i32\");\n        f.addParam(\"pFr\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const AUX = c.i32_const(module.alloc(n8r));\n\n        f.addCode(\n            c.call(\"frm_fromMontgomery\", c.getLocal(\"pFr\"), AUX),\n            c.call(\n                opMul,\n                c.getLocal(\"pG\"),\n                AUX,\n                c.i32_const(n8r),\n                c.getLocal(\"pr\")\n            )\n        );\n\n        module.exportFunction(fnName);\n    }\n    buildGTimesFr(\"g1m_timesFr\", \"g1m_timesScalar\");\n    buildFFT$1(module, \"g1m\", \"g1m\", \"frm\", \"g1m_timesFr\");\n\n    buildGTimesFr(\"g2m_timesFr\", \"g2m_timesScalar\");\n    buildFFT$1(module, \"g2m\", \"g2m\", \"frm\", \"g2m_timesFr\");\n\n    buildGTimesFr(\"g1m_timesFrAffine\", \"g1m_timesScalarAffine\");\n    buildGTimesFr(\"g2m_timesFrAffine\", \"g2m_timesScalarAffine\");\n\n    buildApplyKey(module, \"frm_batchApplyKey\", \"fmr\", \"frm\", n8r, n8r, n8r, \"frm_mul\");\n    buildApplyKey(module, \"g1m_batchApplyKey\", \"g1m\", \"frm\", n8q*3, n8q*3, n8r, \"g1m_timesFr\");\n    buildApplyKey(module, \"g1m_batchApplyKeyMixed\", \"g1m\", \"frm\", n8q*2, n8q*3, n8r, \"g1m_timesFrAffine\");\n    buildApplyKey(module, \"g2m_batchApplyKey\", \"g2m\", \"frm\", n8q*2*3, n8q*3*2, n8r, \"g2m_timesFr\");\n    buildApplyKey(module, \"g2m_batchApplyKeyMixed\", \"g2m\", \"frm\", n8q*2*2, n8q*3*2, n8r, \"g2m_timesFrAffine\");\n\n\n    function toMontgomery(a) {\n        return BigInt(a) * (1n << BigInt(f1size*8)) % q;\n    }\n\n    const G1gen = [\n        3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507n,\n        1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569n,\n        1n\n    ];\n\n    const pG1gen = module.alloc(\n        [\n            ...utils$1.bigInt2BytesLE( toMontgomery(G1gen[0]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G1gen[1]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G1gen[2]), f1size ),\n        ]\n    );\n\n    const G1zero = [\n        0n,\n        1n,\n        0n\n    ];\n\n    const pG1zero = module.alloc(\n        [\n            ...utils$1.bigInt2BytesLE( toMontgomery(G1zero[0]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G1zero[1]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G1zero[2]), f1size )\n        ]\n    );\n\n    const G2gen = [\n        [\n            352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160n,\n            3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758n,\n        ],[\n            1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905n,\n            927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582n,\n        ],[\n            1n,\n            0n,\n        ]\n    ];\n\n    const pG2gen = module.alloc(\n        [\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2gen[0][0]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2gen[0][1]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2gen[1][0]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2gen[1][1]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2gen[2][0]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2gen[2][1]), f1size ),\n        ]\n    );\n\n    const G2zero = [\n        [\n            0n,\n            0n,\n        ],[\n            1n,\n            0n,\n        ],[\n            0n,\n            0n,\n        ]\n    ];\n\n    const pG2zero = module.alloc(\n        [\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2zero[0][0]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2zero[0][1]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2zero[1][0]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2zero[1][1]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2zero[2][0]), f1size ),\n            ...utils$1.bigInt2BytesLE( toMontgomery(G2zero[2][1]), f1size ),\n        ]\n    );\n\n    const pOneT = module.alloc([\n        ...utils$1.bigInt2BytesLE( toMontgomery(1n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(0n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(0n), f1size ),\n    ]);\n\n    const pBls12381Twist =  module.alloc([\n        ...utils$1.bigInt2BytesLE( toMontgomery(1n), f1size ),\n        ...utils$1.bigInt2BytesLE( toMontgomery(1n), f1size ),\n    ]);\n\n    function build_mulNR2() {\n        const f = module.addFunction(f2mPrefix + \"_mulNR\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0c = c.i32_const(module.alloc(f1size));\n        const x0 = c.getLocal(\"x\");\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f1size));\n        const r0 = c.getLocal(\"pr\");\n        const r1 = c.i32_add(c.getLocal(\"pr\"), c.i32_const(f1size));\n\n        f.addCode(\n            c.call(f1mPrefix+\"_copy\", x0, x0c),\n            c.call(f1mPrefix+\"_sub\", x0, x1, r0),\n            c.call(f1mPrefix+\"_add\", x0c, x1, r1),\n        );\n    }\n    build_mulNR2();\n\n    const f6mPrefix = buildF3m(module, f2mPrefix+\"_mulNR\", \"f6m\", \"f2m\");\n\n    function build_mulNR6() {\n        const f = module.addFunction(f6mPrefix + \"_mulNR\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"pr\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const c0copy = c.i32_const(module.alloc(f1size*2));\n\n        f.addCode(\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.getLocal(\"x\"),\n                c0copy\n            ),\n            c.call(\n                f2mPrefix + \"_mulNR\",\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8q*4)),\n                c.getLocal(\"pr\")\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c.i32_add(c.getLocal(\"x\"), c.i32_const(n8q*2)),\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8q*4)),\n            ),\n            c.call(\n                f2mPrefix + \"_copy\",\n                c0copy,\n                c.i32_add(c.getLocal(\"pr\"), c.i32_const(n8q*2)),\n            ),\n        );\n    }\n    build_mulNR6();\n\n    const ftmPrefix = buildF2m(module, f6mPrefix+\"_mulNR\", \"ftm\", f6mPrefix);\n\n    const ateLoopCount = 0xd201000000010000n;\n    const ateLoopBitBytes = bits(ateLoopCount);\n    const pAteLoopBitBytes = module.alloc(ateLoopBitBytes);\n\n    const ateCoefSize = 3 * f2size;\n    const ateNDblCoefs = ateLoopBitBytes.length-1;\n    const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b) =>  acc + ( b!=0 ? 1 : 0)   ,0);\n    const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;\n    const prePSize = 3*2*n8q;\n    const preQSize = 3*n8q*2 + ateNCoefs*ateCoefSize;\n    const finalExpIsNegative = true;\n\n    const finalExpZ = 15132376222941642752n;\n\n\n    module.modules[prefix] = {\n        n64q: n64q,\n        n64r: n64r,\n        n8q: n8q,\n        n8r: n8r,\n        pG1gen: pG1gen,\n        pG1zero: pG1zero,\n        pG1b: pG1b,\n        pG2gen: pG2gen,\n        pG2zero: pG2zero,\n        pG2b: pG2b,\n        pq: module.modules[\"f1m\"].pq,\n        pr: pr,\n        pOneT: pOneT,\n        r: r,\n        q: q,\n        prePSize: prePSize,\n        preQSize: preQSize\n    };\n\n\n    function naf(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd(E)) {\n                const z = 2 - Number(E % 4n);\n                res.push( z );\n                E = E - BigInt(z);\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function bits(n) {\n        let E = n;\n        const res = [];\n        while (E > 0n) {\n            if (isOdd(E)) {\n                res.push( 1 );\n            } else {\n                res.push( 0 );\n            }\n            E = E >> 1n;\n        }\n        return res;\n    }\n\n    function buildPrepareG1() {\n        const f = module.addFunction(prefix+ \"_prepareG1\");\n        f.addParam(\"pP\", \"i32\");\n        f.addParam(\"ppreP\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(g1mPrefix + \"_normalize\", c.getLocal(\"pP\"), c.getLocal(\"ppreP\")),  // TODO Remove if already in affine\n        );\n    }\n\n\n\n    function buildPrepDoubleStep() {\n        const f = module.addFunction(prefix+ \"_prepDblStep\");\n        f.addParam(\"R\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Rx  = c.getLocal(\"R\");\n        const Ry  = c.i32_add(c.getLocal(\"R\"), c.i32_const(2*n8q));\n        const Rz  = c.i32_add(c.getLocal(\"R\"), c.i32_const(4*n8q));\n\n        const t0  = c.getLocal(\"r\");\n        const t3  = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*n8q));\n        const t6  = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*n8q));\n\n\n        const zsquared = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // tmp0 = r.x.square();\n            c.call(f2mPrefix + \"_square\", Rx, t0),\n\n            // tmp1 = r.y.square();\n            c.call(f2mPrefix + \"_square\", Ry, t1),\n\n            // tmp2 = tmp1.square();\n            c.call(f2mPrefix + \"_square\", t1, t2),\n\n            // tmp3 = (tmp1 + r.x).square() - tmp0 - tmp2;\n            c.call(f2mPrefix + \"_add\", t1, Rx, t3),\n            c.call(f2mPrefix + \"_square\", t3, t3),\n            c.call(f2mPrefix + \"_sub\", t3, t0, t3),\n            c.call(f2mPrefix + \"_sub\", t3, t2, t3),\n\n            // tmp3 = tmp3 + tmp3;\n            c.call(f2mPrefix + \"_add\", t3, t3, t3),\n\n            // tmp4 = tmp0 + tmp0 + tmp0;\n            c.call(f2mPrefix + \"_add\", t0, t0, t4),\n            c.call(f2mPrefix + \"_add\", t4, t0, t4),\n\n            // tmp6 = r.x + tmp4;\n            c.call(f2mPrefix + \"_add\", Rx, t4, t6),\n\n            // tmp5 = tmp4.square();\n            c.call(f2mPrefix + \"_square\", t4, t5),\n\n            // zsquared = r.z.square();\n            c.call(f2mPrefix + \"_square\", Rz, zsquared),\n\n            // r.x = tmp5 - tmp3 - tmp3;\n            c.call(f2mPrefix + \"_sub\", t5, t3, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t3, Rx),\n\n            // r.z = (r.z + r.y).square() - tmp1 - zsquared;\n            c.call(f2mPrefix + \"_add\", Rz, Ry, Rz),\n            c.call(f2mPrefix + \"_square\", Rz, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, t1, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, zsquared, Rz),\n\n            // r.y = (tmp3 - r.x) * tmp4;\n            c.call(f2mPrefix + \"_sub\", t3, Rx, Ry),\n            c.call(f2mPrefix + \"_mul\", Ry, t4, Ry),\n\n            // tmp2 = tmp2 + tmp2;\n            c.call(f2mPrefix + \"_add\", t2, t2, t2),\n\n            // tmp2 = tmp2 + tmp2;\n            c.call(f2mPrefix + \"_add\", t2, t2, t2),\n\n            // tmp2 = tmp2 + tmp2;\n            c.call(f2mPrefix + \"_add\", t2, t2, t2),\n\n            // r.y -= tmp2;\n            c.call(f2mPrefix + \"_sub\", Ry, t2, Ry),\n\n            // tmp3 = tmp4 * zsquared;\n            c.call(f2mPrefix + \"_mul\", t4, zsquared, t3),\n\n            // tmp3 = tmp3 + tmp3;\n            c.call(f2mPrefix + \"_add\", t3, t3, t3),\n\n            // tmp3 = -tmp3;\n            c.call(f2mPrefix + \"_neg\", t3, t3),\n\n            // tmp6 = tmp6.square() - tmp0 - tmp5;\n            c.call(f2mPrefix + \"_square\", t6, t6),\n            c.call(f2mPrefix + \"_sub\", t6, t0, t6),\n            c.call(f2mPrefix + \"_sub\", t6, t5, t6),\n\n            // tmp1 = tmp1 + tmp1;\n            c.call(f2mPrefix + \"_add\", t1, t1, t1),\n\n            // tmp1 = tmp1 + tmp1;\n            c.call(f2mPrefix + \"_add\", t1, t1, t1),\n\n            // tmp6 = tmp6 - tmp1;\n            c.call(f2mPrefix + \"_sub\", t6, t1, t6),\n\n            // tmp0 = r.z * zsquared;\n            c.call(f2mPrefix + \"_mul\", Rz, zsquared, t0),\n\n            // tmp0 = tmp0 + tmp0;\n            c.call(f2mPrefix + \"_add\", t0, t0, t0),\n\n        );\n    }\n\n    function buildPrepAddStep() {\n        const f = module.addFunction(prefix+ \"_prepAddStep\");\n        f.addParam(\"R\", \"i32\");\n        f.addParam(\"Q\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Rx  = c.getLocal(\"R\");\n        const Ry  = c.i32_add(c.getLocal(\"R\"), c.i32_const(2*n8q));\n        const Rz  = c.i32_add(c.getLocal(\"R\"), c.i32_const(4*n8q));\n\n        const Qx  = c.getLocal(\"Q\");\n        const Qy  = c.i32_add(c.getLocal(\"Q\"), c.i32_const(2*n8q));\n\n        const t10  = c.getLocal(\"r\");\n        const t1  = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*n8q));\n        const t9  = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*n8q));\n\n        const zsquared = c.i32_const(module.alloc(f2size));\n        const ysquared = c.i32_const(module.alloc(f2size));\n        const ztsquared = c.i32_const(module.alloc(f2size));\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t3 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n        const t6 = c.i32_const(module.alloc(f2size));\n        const t7 = c.i32_const(module.alloc(f2size));\n        const t8 = c.i32_const(module.alloc(f2size));\n\n        f.addCode(\n\n            // zsquared = r.z.square();\n            c.call(f2mPrefix + \"_square\", Rz, zsquared),\n\n            // ysquared = q.y.square();\n            c.call(f2mPrefix + \"_square\", Qy, ysquared),\n\n            // t0 = zsquared * q.x;\n            c.call(f2mPrefix + \"_mul\", zsquared, Qx, t0),\n\n            // t1 = ((q.y + r.z).square() - ysquared - zsquared) * zsquared;\n            c.call(f2mPrefix + \"_add\", Qy, Rz, t1),\n            c.call(f2mPrefix + \"_square\", t1, t1),\n            c.call(f2mPrefix + \"_sub\", t1, ysquared, t1),\n            c.call(f2mPrefix + \"_sub\", t1, zsquared, t1),\n            c.call(f2mPrefix + \"_mul\", t1, zsquared, t1),\n\n            // t2 = t0 - r.x;\n            c.call(f2mPrefix + \"_sub\", t0, Rx, t2),\n\n            // t3 = t2.square();\n            c.call(f2mPrefix + \"_square\", t2, t3),\n\n            // t4 = t3 + t3;\n            c.call(f2mPrefix + \"_add\", t3, t3, t4),\n\n            // t4 = t4 + t4;\n            c.call(f2mPrefix + \"_add\", t4, t4, t4),\n\n            // t5 = t4 * t2;\n            c.call(f2mPrefix + \"_mul\", t4, t2, t5),\n\n            // t6 = t1 - r.y - r.y;\n            c.call(f2mPrefix + \"_sub\", t1, Ry, t6),\n            c.call(f2mPrefix + \"_sub\", t6, Ry, t6),\n\n            // t9 = t6 * q.x;\n            c.call(f2mPrefix + \"_mul\", t6, Qx, t9),\n\n            // t7 = t4 * r.x;\n            c.call(f2mPrefix + \"_mul\", t4, Rx, t7),\n\n            // r.x = t6.square() - t5 - t7 - t7;\n            c.call(f2mPrefix + \"_square\", t6, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t5, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t7, Rx),\n            c.call(f2mPrefix + \"_sub\", Rx, t7, Rx),\n\n            // r.z = (r.z + t2).square() - zsquared - t3;\n            c.call(f2mPrefix + \"_add\", Rz, t2, Rz),\n            c.call(f2mPrefix + \"_square\", Rz, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, zsquared, Rz),\n            c.call(f2mPrefix + \"_sub\", Rz, t3, Rz),\n\n            // t10 = q.y + r.z;\n            c.call(f2mPrefix + \"_add\", Qy, Rz, t10),\n\n            // t8 = (t7 - r.x) * t6;\n            c.call(f2mPrefix + \"_sub\", t7, Rx, t8),\n            c.call(f2mPrefix + \"_mul\", t8, t6, t8),\n\n            // t0 = r.y * t5;\n            c.call(f2mPrefix + \"_mul\", Ry, t5, t0),\n\n            // t0 = t0 + t0;\n            c.call(f2mPrefix + \"_add\", t0, t0, t0),\n\n            // r.y = t8 - t0;\n            c.call(f2mPrefix + \"_sub\", t8, t0, Ry),\n\n            // t10 = t10.square() - ysquared;\n            c.call(f2mPrefix + \"_square\", t10, t10),\n            c.call(f2mPrefix + \"_sub\", t10, ysquared, t10),\n\n            // ztsquared = r.z.square();\n            c.call(f2mPrefix + \"_square\", Rz, ztsquared),\n\n            // t10 = t10 - ztsquared;\n            c.call(f2mPrefix + \"_sub\", t10, ztsquared, t10),\n\n            // t9 = t9 + t9 - t10;\n            c.call(f2mPrefix + \"_add\", t9, t9, t9),\n            c.call(f2mPrefix + \"_sub\", t9, t10, t9),\n\n            // t10 = r.z + r.z;\n            c.call(f2mPrefix + \"_add\", Rz, Rz, t10),\n\n            // t6 = -t6;\n            c.call(f2mPrefix + \"_neg\", t6, t6),\n\n            // t1 = t6 + t6;\n            c.call(f2mPrefix + \"_add\", t6, t6, t1),\n        );\n    }\n\n\n    function buildPrepareG2() {\n        const f = module.addFunction(prefix+ \"_prepareG2\");\n        f.addParam(\"pQ\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n\n        const Q = c.getLocal(\"pQ\");\n\n        const pR = module.alloc(f2size*3);\n        const R = c.i32_const(pR);\n\n        const base = c.getLocal(\"ppreQ\");\n\n        f.addCode(\n            c.call(g2mPrefix + \"_normalize\", Q, base),\n            c.if(\n                c.call(g2mPrefix + \"_isZero\", base),\n                c.ret([])\n            ),\n            c.call(g2mPrefix + \"_copy\", base, R),\n            c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n        );\n\n        f.addCode(\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n                c.call(prefix + \"_prepDblStep\", R, c.getLocal(\"pCoef\")),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(prefix + \"_prepAddStep\", R, base, c.getLocal(\"pCoef\")),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n                    ]\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n    }\n\n\n    function buildF6Mul1() {\n        const f = module.addFunction(f6mPrefix+ \"_mul1\");\n        f.addParam(\"pA\", \"i32\");    // F6\n        f.addParam(\"pC1\", \"i32\");   // F2\n        f.addParam(\"pR\", \"i32\");    // F6\n\n        const c = f.getCodeBuilder();\n\n        const A_c0 = c.getLocal(\"pA\");\n        const A_c1 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*2));\n        const A_c2 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*4));\n\n        const c1  = c.getLocal(\"pC1\");\n\n        const t1 = c.getLocal(\"pR\");\n        const t2 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*2));\n        const b_b = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*4));\n\n        const Ac0_Ac1 = c.i32_const(module.alloc(f1size*2));\n        const Ac1_Ac2 = c.i32_const(module.alloc(f1size*2));\n\n        f.addCode(\n\n            c.call(f2mPrefix + \"_add\", A_c0, A_c1, Ac0_Ac1),\n            c.call(f2mPrefix + \"_add\", A_c1, A_c2, Ac1_Ac2),\n\n            // let b_b = self.c1 * c1;\n            c.call(f2mPrefix + \"_mul\", A_c1, c1, b_b),\n\n            // let t1 = (self.c1 + self.c2) * c1 - b_b;\n            c.call(f2mPrefix + \"_mul\", Ac1_Ac2, c1, t1),\n            c.call(f2mPrefix + \"_sub\", t1, b_b, t1),\n\n            // let t1 = t1.mul_by_nonresidue();\n            c.call(f2mPrefix + \"_mulNR\", t1, t1),\n\n            // let t2 = (self.c0 + self.c1) * c1 - b_b;\n            c.call(f2mPrefix + \"_mul\", Ac0_Ac1, c1, t2),\n            c.call(f2mPrefix + \"_sub\", t2, b_b, t2),\n        );\n    }\n    buildF6Mul1();\n\n    function buildF6Mul01() {\n        const f = module.addFunction(f6mPrefix+ \"_mul01\");\n        f.addParam(\"pA\", \"i32\");    // F6\n        f.addParam(\"pC0\", \"i32\");   // F2\n        f.addParam(\"pC1\", \"i32\");   // F2\n        f.addParam(\"pR\", \"i32\");    // F6\n\n        const c = f.getCodeBuilder();\n\n        const A_c0 = c.getLocal(\"pA\");\n        const A_c1 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*2));\n        const A_c2 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*4));\n\n        const c0  = c.getLocal(\"pC0\");\n        const c1  = c.getLocal(\"pC1\");\n\n        const t1 = c.getLocal(\"pR\");\n        const t2 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*2));\n        const t3 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*4));\n\n        const a_a = c.i32_const(module.alloc(f1size*2));\n        const b_b = c.i32_const(module.alloc(f1size*2));\n        const Ac0_Ac1 = c.i32_const(module.alloc(f1size*2));\n        const Ac0_Ac2 = c.i32_const(module.alloc(f1size*2));\n\n        f.addCode(\n            // let a_a = self.c0 * c0;\n            c.call(f2mPrefix + \"_mul\", A_c0, c0, a_a),\n\n            // let b_b = self.c1 * c1;\n            c.call(f2mPrefix + \"_mul\", A_c1, c1, b_b),\n\n\n            c.call(f2mPrefix + \"_add\", A_c0, A_c1, Ac0_Ac1),\n            c.call(f2mPrefix + \"_add\", A_c0, A_c2, Ac0_Ac2),\n\n            // let t1 = (self.c1 + self.c2) * c1 - b_b;\n            c.call(f2mPrefix + \"_add\", A_c1, A_c2, t1),\n            c.call(f2mPrefix + \"_mul\", t1, c1, t1),\n            c.call(f2mPrefix + \"_sub\", t1, b_b, t1),\n\n            // let t1 = t1.mul_by_nonresidue() + a_a;\n            c.call(f2mPrefix + \"_mulNR\", t1, t1),\n            c.call(f2mPrefix + \"_add\", t1, a_a, t1),\n\n            // let t2 = (c0 + c1) * (self.c0 + self.c1) - a_a - b_b;\n            c.call(f2mPrefix + \"_add\", c0, c1, t2),\n            c.call(f2mPrefix + \"_mul\", t2, Ac0_Ac1, t2),\n            c.call(f2mPrefix + \"_sub\", t2, a_a, t2),\n            c.call(f2mPrefix + \"_sub\", t2, b_b, t2),\n\n            // let t3 = (self.c0 + self.c2) * c0 - a_a + b_b;\n            c.call(f2mPrefix + \"_mul\", Ac0_Ac2, c0, t3),\n            c.call(f2mPrefix + \"_sub\", t3, a_a, t3),\n            c.call(f2mPrefix + \"_add\", t3, b_b, t3),\n\n\n        );\n    }\n    buildF6Mul01();\n\n\n    function buildF12Mul014() {\n\n        const f = module.addFunction(ftmPrefix+ \"_mul014\");\n        f.addParam(\"pA\", \"i32\");    // F12\n        f.addParam(\"pC0\", \"i32\");   // F2\n        f.addParam(\"pC1\", \"i32\");   // F2\n        f.addParam(\"pC4\", \"i32\");   // F2\n        f.addParam(\"pR\", \"i32\");    // F12\n\n        const c = f.getCodeBuilder();\n\n\n        const A_c0 = c.getLocal(\"pA\");\n        const A_c1 = c.i32_add(c.getLocal(\"pA\"), c.i32_const(f1size*6));\n\n        const c0  = c.getLocal(\"pC0\");\n        const c1  = c.getLocal(\"pC1\");\n        const c4  = c.getLocal(\"pC4\");\n\n        const aa = c.i32_const(module.alloc(f1size*6));\n        const bb = c.i32_const(module.alloc(f1size*6));\n        const o = c.i32_const(module.alloc(f1size*2));\n\n        const R_c0 = c.getLocal(\"pR\");\n        const R_c1 = c.i32_add(c.getLocal(\"pR\"), c.i32_const(f1size*6));\n\n        f.addCode(\n            // let aa = self.c0.mul_by_01(c0, c1);\n            c.call(f6mPrefix + \"_mul01\", A_c0, c0, c1, aa),\n\n            // let bb = self.c1.mul_by_1(c4);\n            c.call(f6mPrefix + \"_mul1\", A_c1, c4, bb),\n\n            // let o = c1 + c4;\n            c.call(f2mPrefix + \"_add\", c1, c4, o),\n\n            // let c1 = self.c1 + self.c0;\n            c.call(f6mPrefix + \"_add\", A_c1, A_c0, R_c1),\n\n            // let c1 = c1.mul_by_01(c0, &o);\n            c.call(f6mPrefix + \"_mul01\", R_c1, c0, o, R_c1),\n\n            // let c1 = c1 - aa - bb;\n            c.call(f6mPrefix + \"_sub\", R_c1, aa, R_c1),\n            c.call(f6mPrefix + \"_sub\", R_c1, bb, R_c1),\n\n            // let c0 = bb;\n            c.call(f6mPrefix + \"_copy\", bb, R_c0),\n\n            // let c0 = c0.mul_by_nonresidue();\n            c.call(f6mPrefix + \"_mulNR\", R_c0, R_c0),\n\n            // let c0 = c0 + aa;\n            c.call(f6mPrefix + \"_add\", R_c0, aa, R_c0),\n        );\n    }\n    buildF12Mul014();\n\n\n    function buildELL() {\n        const f = module.addFunction(prefix+ \"_ell\");\n        f.addParam(\"pP\", \"i32\");\n        f.addParam(\"pCoefs\", \"i32\");\n        f.addParam(\"pF\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const Px  = c.getLocal(\"pP\");\n        const Py  = c.i32_add(c.getLocal(\"pP\"), c.i32_const(n8q));\n\n        const F  = c.getLocal(\"pF\");\n\n        const coef0_0  = c.getLocal(\"pCoefs\");\n        const coef0_1  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size));\n        const coef1_0  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size*2));\n        const coef1_1  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size*3));\n        const coef2  = c.i32_add(c.getLocal(\"pCoefs\"), c.i32_const(f1size*4));\n\n        const pc0 = module.alloc(f1size*2);\n        const c0  = c.i32_const(pc0);\n        const c0_c0 = c.i32_const(pc0);\n        const c0_c1 = c.i32_const(pc0+f1size);\n\n        const pc1 = module.alloc(f1size*2);\n        const c1  = c.i32_const(pc1);\n        const c1_c0 = c.i32_const(pc1);\n        const c1_c1 = c.i32_const(pc1+f1size);\n        f.addCode(\n            //     let mut c0 = coeffs.0;\n            //     let mut c1 = coeffs.1;\n            //\n            //    c0.c0 *= p.y;\n            //    c0.c1 *= p.y;\n            //\n            //    c1.c0 *= p.x;\n            //    c1.c1 *= p.x;\n            //\n            //     f.mul_by_014(&coeffs.2, &c1, &c0)\n\n            c.call(f1mPrefix + \"_mul\", coef0_0, Py, c0_c0),\n            c.call(f1mPrefix + \"_mul\", coef0_1, Py, c0_c1),\n            c.call(f1mPrefix + \"_mul\", coef1_0, Px, c1_c0),\n            c.call(f1mPrefix + \"_mul\", coef1_1, Px, c1_c1),\n\n            c.call(ftmPrefix + \"_mul014\", F, coef2, c1, c0, F),\n\n        );\n\n    }\n    buildELL();\n\n    function buildMillerLoop() {\n        const f = module.addFunction(prefix+ \"_millerLoop\");\n        f.addParam(\"ppreP\", \"i32\");\n        f.addParam(\"ppreQ\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"pCoef\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const preP = c.getLocal(\"ppreP\");\n\n        const coefs  = c.getLocal(\"pCoef\");\n\n        const F = c.getLocal(\"r\");\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_one\", F),\n\n            c.if(\n                c.call(g1mPrefix + \"_isZero\", preP),\n                c.ret([])\n            ),\n            c.if(\n                c.call(g1mPrefix + \"_isZero\", c.getLocal(\"ppreQ\")),\n                c.ret([])\n            ),\n            c.setLocal(\"pCoef\", c.i32_add( c.getLocal(\"ppreQ\"), c.i32_const(f2size*3))),\n\n            c.setLocal(\"i\", c.i32_const(ateLoopBitBytes.length-2)),\n            c.block(c.loop(\n\n\n                c.call(prefix + \"_ell\", preP, coefs,  F),\n                c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n\n                c.if(\n                    c.i32_load8_s(c.getLocal(\"i\"), pAteLoopBitBytes),\n                    [\n                        ...c.call(prefix + \"_ell\", preP, coefs,  F),\n                        ...c.setLocal(\"pCoef\", c.i32_add(c.getLocal(\"pCoef\"), c.i32_const(ateCoefSize))),\n                    ]\n                ),\n                c.call(ftmPrefix + \"_square\", F, F),\n\n                c.br_if(1, c.i32_eq ( c.getLocal(\"i\"), c.i32_const(1) )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            )),\n            c.call(prefix + \"_ell\", preP, coefs,  F),\n\n        );\n\n\n        {\n            f.addCode(\n                c.call(ftmPrefix + \"_conjugate\", F, F),\n            );\n        }\n    }\n\n\n    function buildFrobeniusMap(n) {\n        const F12 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n, 151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],\n                [2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n, 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],\n                [3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n, 877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n],\n                [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],\n                [151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n, 3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],\n                [1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n, 2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],\n                [877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n, 3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n],\n            ]\n        ];\n\n        const F6 = [\n            [\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n                [1n, 0n],\n            ],\n            [\n                [1n, 0n],\n                [0n, 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],\n                [0n, 1n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],\n                [0n, 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n],\n            ],\n            [\n                [1n, 0n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],\n                [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],\n                [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],\n                [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],\n            ]\n        ];\n\n        const f = module.addFunction(ftmPrefix + \"_frobeniusMap\"+n);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        for (let i=0; i<6; i++) {\n            const X = (i==0) ? c.getLocal(\"x\") : c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size));\n            const Xc0 = X;\n            const Xc1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(i*f2size + f1size));\n            const R = (i==0) ? c.getLocal(\"r\") : c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size));\n            const Rc0 = R;\n            const Rc1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(i*f2size + f1size));\n            const coef = mul2(F12[Math.floor(i/3)][n%12] , F6[i%3][n%6]);\n            const pCoef = module.alloc([\n                ...utils$1.bigInt2BytesLE(toMontgomery(coef[0]), n8q),\n                ...utils$1.bigInt2BytesLE(toMontgomery(coef[1]), n8q),\n            ]);\n            if (n%2 == 1) {\n                f.addCode(\n                    c.call(f1mPrefix + \"_copy\", Xc0, Rc0),\n                    c.call(f1mPrefix + \"_neg\", Xc1, Rc1),\n                    c.call(f2mPrefix + \"_mul\", R, c.i32_const(pCoef), R),\n                );\n            } else {\n                f.addCode(c.call(f2mPrefix + \"_mul\", X, c.i32_const(pCoef), R));\n            }\n        }\n\n        function mul2(a, b) {\n            const ac0 = a[0];\n            const ac1 = a[1];\n            const bc0 = b[0];\n            const bc1 = b[1];\n            const res = [\n                (ac0 * bc0 - (ac1 * bc1)) % q,\n                (ac0 * bc1 + (ac1 * bc0)) % q,\n            ];\n            if (isNegative$1(res[0])) res[0] = res[0] + q;\n            return res;\n        }\n\n    }\n\n\n    function buildCyclotomicSquare() {\n        const f = module.addFunction(prefix+ \"__cyclotomicSquare\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x0 = c.getLocal(\"x\");\n        const x4 = c.i32_add(c.getLocal(\"x\"), c.i32_const(f2size));\n        const x3 = c.i32_add(c.getLocal(\"x\"), c.i32_const(2*f2size));\n        const x2 = c.i32_add(c.getLocal(\"x\"), c.i32_const(3*f2size));\n        const x1 = c.i32_add(c.getLocal(\"x\"), c.i32_const(4*f2size));\n        const x5 = c.i32_add(c.getLocal(\"x\"), c.i32_const(5*f2size));\n\n        const r0 = c.getLocal(\"r\");\n        const r4 = c.i32_add(c.getLocal(\"r\"), c.i32_const(f2size));\n        const r3 = c.i32_add(c.getLocal(\"r\"), c.i32_const(2*f2size));\n        const r2 = c.i32_add(c.getLocal(\"r\"), c.i32_const(3*f2size));\n        const r1 = c.i32_add(c.getLocal(\"r\"), c.i32_const(4*f2size));\n        const r5 = c.i32_add(c.getLocal(\"r\"), c.i32_const(5*f2size));\n\n        const t0 = c.i32_const(module.alloc(f2size));\n        const t1 = c.i32_const(module.alloc(f2size));\n        const t2 = c.i32_const(module.alloc(f2size));\n        const t3 = c.i32_const(module.alloc(f2size));\n        const t4 = c.i32_const(module.alloc(f2size));\n        const t5 = c.i32_const(module.alloc(f2size));\n        const tmp = c.i32_const(module.alloc(f2size));\n        const AUX = c.i32_const(module.alloc(f2size));\n\n\n        f.addCode(\n            //    // t0 + t1*y = (z0 + z1*y)^2 = a^2\n            //    tmp = z0 * z1;\n            //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;\n            //    t1 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x0, x1, tmp),\n            c.call(f2mPrefix + \"_mulNR\", x1, t0),\n            c.call(f2mPrefix + \"_add\", x0, t0, t0),\n            c.call(f2mPrefix + \"_add\", x0, x1, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t0, t0),\n            c.call(f2mPrefix + \"_mulNR\", tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t0, AUX, t0),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t1),\n\n            //  // t2 + t3*y = (z2 + z3*y)^2 = b^2\n            //  tmp = z2 * z3;\n            //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;\n            //  t3 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x2, x3, tmp),\n            c.call(f2mPrefix + \"_mulNR\", x3, t2),\n            c.call(f2mPrefix + \"_add\", x2, t2, t2),\n            c.call(f2mPrefix + \"_add\", x2, x3, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t2, t2),\n            c.call(f2mPrefix + \"_mulNR\", tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t2, AUX, t2),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t3),\n\n            //  // t4 + t5*y = (z4 + z5*y)^2 = c^2\n            //  tmp = z4 * z5;\n            //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;\n            //  t5 = tmp + tmp;\n            c.call(f2mPrefix + \"_mul\", x4, x5, tmp),\n            c.call(f2mPrefix + \"_mulNR\", x5, t4),\n            c.call(f2mPrefix + \"_add\", x4, t4, t4),\n            c.call(f2mPrefix + \"_add\", x4, x5, AUX),\n            c.call(f2mPrefix + \"_mul\", AUX, t4, t4),\n            c.call(f2mPrefix + \"_mulNR\", tmp, AUX),\n            c.call(f2mPrefix + \"_add\", tmp, AUX, AUX),\n            c.call(f2mPrefix + \"_sub\", t4, AUX, t4),\n            c.call(f2mPrefix + \"_add\", tmp, tmp, t5),\n\n            // For A\n            // z0 = 3 * t0 - 2 * z0\n            c.call(f2mPrefix + \"_sub\", t0, x0, r0),\n            c.call(f2mPrefix + \"_add\", r0, r0, r0),\n            c.call(f2mPrefix + \"_add\", t0, r0, r0),\n            // z1 = 3 * t1 + 2 * z1\n            c.call(f2mPrefix + \"_add\", t1, x1, r1),\n            c.call(f2mPrefix + \"_add\", r1, r1, r1),\n            c.call(f2mPrefix + \"_add\", t1, r1, r1),\n\n            // For B\n            // z2 = 3 * (xi * t5) + 2 * z2\n            c.call(f2mPrefix + \"_mul\", t5, c.i32_const(pBls12381Twist), AUX),\n            c.call(f2mPrefix + \"_add\", AUX, x2, r2),\n            c.call(f2mPrefix + \"_add\", r2, r2, r2),\n            c.call(f2mPrefix + \"_add\", AUX, r2, r2),\n            // z3 = 3 * t4 - 2 * z3\n            c.call(f2mPrefix + \"_sub\", t4, x3, r3),\n            c.call(f2mPrefix + \"_add\", r3, r3, r3),\n            c.call(f2mPrefix + \"_add\", t4, r3, r3),\n\n            // For C\n            // z4 = 3 * t2 - 2 * z4\n            c.call(f2mPrefix + \"_sub\", t2, x4, r4),\n            c.call(f2mPrefix + \"_add\", r4, r4, r4),\n            c.call(f2mPrefix + \"_add\", t2, r4, r4),\n            // z5 = 3 * t3 + 2 * z5\n            c.call(f2mPrefix + \"_add\", t3, x5, r5),\n            c.call(f2mPrefix + \"_add\", r5, r5, r5),\n            c.call(f2mPrefix + \"_add\", t3, r5, r5),\n\n        );\n    }\n\n\n    function buildCyclotomicExp(exponent, isExpNegative, fnName) {\n        const exponentNafBytes = naf(exponent).map( (b) => (b==-1 ? 0xFF: b) );\n        const pExponentNafBytes = module.alloc(exponentNafBytes);\n        // const pExponent = module.alloc(utils.bigInt2BytesLE(exponent, n8));\n\n        const f = module.addFunction(prefix+ \"__cyclotomicExp_\"+fnName);\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n        f.addLocal(\"bit\", \"i32\");\n        f.addLocal(\"i\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const x = c.getLocal(\"x\");\n\n        const res = c.getLocal(\"r\");\n\n        const inverse = c.i32_const(module.alloc(ftsize));\n\n\n        f.addCode(\n            c.call(ftmPrefix + \"_conjugate\", x, inverse),\n            c.call(ftmPrefix + \"_one\", res),\n\n            c.if(\n                c.teeLocal(\"bit\", c.i32_load8_s(c.i32_const(exponentNafBytes.length-1), pExponentNafBytes)),\n                c.if(\n                    c.i32_eq(\n                        c.getLocal(\"bit\"),\n                        c.i32_const(1)\n                    ),\n                    c.call(ftmPrefix + \"_mul\", res, x, res),\n                    c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                )\n            ),\n\n            c.setLocal(\"i\", c.i32_const(exponentNafBytes.length-2)),\n            c.block(c.loop(\n                c.call(prefix + \"__cyclotomicSquare\", res, res),\n                c.if(\n                    c.teeLocal(\"bit\", c.i32_load8_s(c.getLocal(\"i\"), pExponentNafBytes)),\n                    c.if(\n                        c.i32_eq(\n                            c.getLocal(\"bit\"),\n                            c.i32_const(1)\n                        ),\n                        c.call(ftmPrefix + \"_mul\", res, x, res),\n                        c.call(ftmPrefix + \"_mul\", res, inverse, res),\n                    )\n                ),\n                c.br_if(1, c.i32_eqz ( c.getLocal(\"i\") )),\n                c.setLocal(\"i\", c.i32_sub(c.getLocal(\"i\"), c.i32_const(1))),\n                c.br(0)\n            ))\n        );\n\n        if (isExpNegative) {\n            f.addCode(\n                c.call(ftmPrefix + \"_conjugate\", res, res),\n            );\n        }\n\n    }\n\n    function buildFinalExponentiation() {\n        buildCyclotomicSquare();\n        buildCyclotomicExp(finalExpZ, finalExpIsNegative, \"w0\");\n\n        const f = module.addFunction(prefix+ \"_finalExponentiation\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const elt = c.getLocal(\"x\");\n        const res = c.getLocal(\"r\");\n        const t0 = c.i32_const(module.alloc(ftsize));\n        const t1 = c.i32_const(module.alloc(ftsize));\n        const t2 = c.i32_const(module.alloc(ftsize));\n        const t3 = c.i32_const(module.alloc(ftsize));\n        const t4 = c.i32_const(module.alloc(ftsize));\n        const t5 = c.i32_const(module.alloc(ftsize));\n        const t6 = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(\n\n            // let mut t0 = f.frobenius_map(6)\n            c.call(ftmPrefix + \"_frobeniusMap6\", elt, t0),\n\n            // let t1 = f.invert()\n            c.call(ftmPrefix + \"_inverse\", elt, t1),\n\n            // let mut t2 = t0 * t1;\n            c.call(ftmPrefix + \"_mul\", t0, t1, t2),\n\n            // t1 = t2.clone();\n            c.call(ftmPrefix + \"_copy\", t2, t1),\n\n            // t2 = t2.frobenius_map().frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap2\", t2, t2),\n\n            // t2 *= t1;\n            c.call(ftmPrefix + \"_mul\", t2, t1, t2),\n\n\n            // t1 = cyclotomic_square(t2).conjugate();\n            c.call(prefix + \"__cyclotomicSquare\", t2, t1),\n            c.call(ftmPrefix + \"_conjugate\", t1, t1),\n\n            // let mut t3 = cycolotomic_exp(t2);\n            c.call(prefix + \"__cyclotomicExp_w0\", t2, t3),\n\n            // let mut t4 = cyclotomic_square(t3);\n            c.call(prefix + \"__cyclotomicSquare\", t3, t4),\n\n            // let mut t5 = t1 * t3;\n            c.call(ftmPrefix + \"_mul\", t1, t3, t5),\n\n            // t1 = cycolotomic_exp(t5);\n            c.call(prefix + \"__cyclotomicExp_w0\", t5, t1),\n\n            // t0 = cycolotomic_exp(t1);\n            c.call(prefix + \"__cyclotomicExp_w0\", t1, t0),\n\n            // let mut t6 = cycolotomic_exp(t0);\n            c.call(prefix + \"__cyclotomicExp_w0\", t0, t6),\n\n            // t6 *= t4;\n            c.call(ftmPrefix + \"_mul\", t6, t4, t6),\n\n            // t4 = cycolotomic_exp(t6);\n            c.call(prefix + \"__cyclotomicExp_w0\", t6, t4),\n\n            // t5 = t5.conjugate();\n            c.call(ftmPrefix + \"_conjugate\", t5, t5),\n\n            // t4 *= t5 * t2;\n            c.call(ftmPrefix + \"_mul\", t4, t5, t4),\n            c.call(ftmPrefix + \"_mul\", t4, t2, t4),\n\n            // t5 = t2.conjugate();\n            c.call(ftmPrefix + \"_conjugate\", t2, t5),\n\n            // t1 *= t2;\n            c.call(ftmPrefix + \"_mul\", t1, t2, t1),\n\n            // t1 = t1.frobenius_map().frobenius_map().frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap3\", t1, t1),\n\n            // t6 *= t5;\n            c.call(ftmPrefix + \"_mul\", t6, t5, t6),\n\n            // t6 = t6.frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap1\", t6, t6),\n\n            // t3 *= t0;\n            c.call(ftmPrefix + \"_mul\", t3, t0, t3),\n\n            // t3 = t3.frobenius_map().frobenius_map();\n            c.call(ftmPrefix + \"_frobeniusMap2\", t3, t3),\n\n            // t3 *= t1;\n            c.call(ftmPrefix + \"_mul\", t3, t1, t3),\n\n            // t3 *= t6;\n            c.call(ftmPrefix + \"_mul\", t3, t6, t3),\n\n            // f = t3 * t4;\n            c.call(ftmPrefix + \"_mul\", t3, t4, res),\n\n        );\n    }\n\n\n    function buildFinalExponentiationOld() {\n        const f = module.addFunction(prefix+ \"_finalExponentiationOld\");\n        f.addParam(\"x\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const exponent = 322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n;\n\n        const pExponent = module.alloc(utils$1.bigInt2BytesLE( exponent, 544 ));\n\n        const c = f.getCodeBuilder();\n\n        f.addCode(\n            c.call(ftmPrefix + \"_exp\", c.getLocal(\"x\"), c.i32_const(pExponent), c.i32_const(544), c.getLocal(\"r\")),\n        );\n    }\n\n\n    const pPreP = module.alloc(prePSize);\n    const pPreQ = module.alloc(preQSize);\n\n    function buildPairingEquation(nPairings) {\n\n        const f = module.addFunction(prefix+ \"_pairingEq\"+nPairings);\n        for (let i=0; i<nPairings; i++) {\n            f.addParam(\"p_\"+i, \"i32\");\n            f.addParam(\"q_\"+i, \"i32\");\n        }\n        f.addParam(\"c\", \"i32\");\n        f.setReturnType(\"i32\");\n\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n        const auxT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(ftmPrefix + \"_one\", resT ));\n\n        for (let i=0; i<nPairings; i++) {\n\n            f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p_\"+i), c.i32_const(pPreP) ));\n            f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q_\"+i), c.i32_const(pPreQ) ));\n\n            // Checks\n            f.addCode(\n                c.if(\n                    c.i32_eqz(c.call(g1mPrefix + \"_inGroupAffine\", c.i32_const(pPreP))),\n                    c.ret(c.i32_const(0))\n                ),\n                c.if(\n                    c.i32_eqz(c.call(g2mPrefix + \"_inGroupAffine\", c.i32_const(pPreQ))),\n                    c.ret(c.i32_const(0))\n                )\n            );\n\n            f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), auxT ));\n\n            f.addCode(c.call(ftmPrefix + \"_mul\", resT, auxT, resT ));\n        }\n\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, resT ));\n\n        f.addCode(c.call(ftmPrefix + \"_eq\", resT, c.getLocal(\"c\")));\n    }\n\n\n    function buildPairing() {\n\n        const f = module.addFunction(prefix+ \"_pairing\");\n        f.addParam(\"p\", \"i32\");\n        f.addParam(\"q\", \"i32\");\n        f.addParam(\"r\", \"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const resT = c.i32_const(module.alloc(ftsize));\n\n        f.addCode(c.call(prefix + \"_prepareG1\", c.getLocal(\"p\"), c.i32_const(pPreP) ));\n        f.addCode(c.call(prefix + \"_prepareG2\", c.getLocal(\"q\"), c.i32_const(pPreQ) ));\n        f.addCode(c.call(prefix + \"_millerLoop\", c.i32_const(pPreP), c.i32_const(pPreQ), resT ));\n        f.addCode(c.call(prefix + \"_finalExponentiation\", resT, c.getLocal(\"r\") ));\n    }\n\n\n    function buildInGroupG2() {\n        const f = module.addFunction(g2mPrefix+ \"_inGroupAffine\");\n        f.addParam(\"p\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const WINV = [\n            2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279894n,\n            2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893n\n        ];\n\n        const FROB2X = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;\n        const FROB3Y = [\n            2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,\n            2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n\n        ];\n\n        const wInv = c.i32_const(module.alloc([\n            ...utils$1.bigInt2BytesLE(toMontgomery(WINV[0]), n8q),\n            ...utils$1.bigInt2BytesLE(toMontgomery(WINV[1]), n8q),\n        ]));\n\n        const frob2X = c.i32_const(module.alloc(utils$1.bigInt2BytesLE(toMontgomery(FROB2X), n8q)));\n        const frob3Y = c.i32_const(module.alloc([\n            ...utils$1.bigInt2BytesLE(toMontgomery(FROB3Y[0]), n8q),\n            ...utils$1.bigInt2BytesLE(toMontgomery(FROB3Y[1]), n8q),\n        ]));\n\n        const z = c.i32_const(module.alloc(utils$1.bigInt2BytesLE(finalExpZ, 8)));\n\n        const px = c.getLocal(\"p\");\n        const py = c.i32_add(c.getLocal(\"p\"), c.i32_const(f2size));\n\n        const aux = c.i32_const(module.alloc(f1size));\n\n        const x_winv = c.i32_const(module.alloc(f2size));\n        const y_winv = c.i32_const(module.alloc(f2size));\n        const pf2 = module.alloc(f2size*2);\n        const f2 = c.i32_const(pf2);\n        const f2x = c.i32_const(pf2);\n        const f2x_c1 = c.i32_const(pf2);\n        const f2x_c2 = c.i32_const(pf2+f1size);\n        const f2y = c.i32_const(pf2+f2size);\n        const f2y_c1 = c.i32_const(pf2+f2size);\n        const f2y_c2 = c.i32_const(pf2+f2size+f1size);\n        const pf3 = module.alloc(f2size*3);\n        const f3 = c.i32_const(pf3);\n        const f3x = c.i32_const(pf3);\n        const f3x_c1 = c.i32_const(pf3);\n        const f3x_c2 = c.i32_const(pf3+f1size);\n        const f3y = c.i32_const(pf3+f2size);\n        const f3y_c1 = c.i32_const(pf3+f2size);\n        const f3y_c2 = c.i32_const(pf3+f2size+f1size);\n        const f3z = c.i32_const(pf3+f2size*2);\n\n\n        f.addCode(\n            c.if(\n                c.call(g2mPrefix + \"_isZeroAffine\", c.getLocal(\"p\")),\n                c.ret( c.i32_const(1)),\n            ),\n            c.if(\n                c.i32_eqz(c.call(g2mPrefix + \"_inCurveAffine\", c.getLocal(\"p\"))),\n                c.ret( c.i32_const(0)),\n            ),\n            c.call(f2mPrefix + \"_mul\", px, wInv, x_winv),\n            c.call(f2mPrefix + \"_mul\", py, wInv, y_winv),\n\n            c.call(f2mPrefix + \"_mul1\", x_winv, frob2X, f2x),\n            c.call(f2mPrefix + \"_neg\", y_winv, f2y),\n\n            c.call(f2mPrefix + \"_neg\", x_winv, f3x),\n            c.call(f2mPrefix + \"_mul\", y_winv, frob3Y, f3y),\n\n            c.call(f1mPrefix + \"_sub\", f2x_c1, f2x_c2, aux),\n            c.call(f1mPrefix + \"_add\", f2x_c1, f2x_c2, f2x_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f2x_c1),\n\n            c.call(f1mPrefix + \"_sub\", f2y_c1, f2y_c2, aux),\n            c.call(f1mPrefix + \"_add\", f2y_c1, f2y_c2, f2y_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f2y_c1),\n\n            c.call(f1mPrefix + \"_add\", f3x_c1, f3x_c2, aux),\n            c.call(f1mPrefix + \"_sub\", f3x_c1, f3x_c2, f3x_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f3x_c1),\n\n            c.call(f1mPrefix + \"_sub\", f3y_c2, f3y_c1, aux),\n            c.call(f1mPrefix + \"_add\", f3y_c1, f3y_c2, f3y_c2),\n            c.call(f1mPrefix + \"_copy\", aux, f3y_c1),\n\n            c.call(f2mPrefix + \"_one\", f3z),\n\n            c.call(g2mPrefix + \"_timesScalar\", f3, z, c.i32_const(8), f3),\n            c.call(g2mPrefix + \"_addMixed\", f3, f2, f3),\n\n            c.ret(\n                c.call(g2mPrefix + \"_eqMixed\", f3, c.getLocal(\"p\"))\n            )\n        );\n\n        const fInGroup = module.addFunction(g2mPrefix + \"_inGroup\");\n        fInGroup.addParam(\"pIn\", \"i32\");\n        fInGroup.setReturnType(\"i32\");\n\n        const c2 = fInGroup.getCodeBuilder();\n\n        const aux2 = c2.i32_const(module.alloc(f2size*2));\n\n        fInGroup.addCode(\n            c2.call(g2mPrefix + \"_toAffine\", c2.getLocal(\"pIn\"), aux2),\n\n            c2.ret(\n                c2.call(g2mPrefix + \"_inGroupAffine\", aux2),\n            )\n        );\n\n    }\n\n    function buildInGroupG1() {\n        const f = module.addFunction(g1mPrefix+ \"_inGroupAffine\");\n        f.addParam(\"p\", \"i32\");\n        f.setReturnType(\"i32\");\n\n        const c = f.getCodeBuilder();\n\n        const BETA = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;\n        const BETA2 = 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n;\n        const Z2M1D3 = (finalExpZ * finalExpZ - 1n) / 3n;\n\n        const beta = c.i32_const(module.alloc(utils$1.bigInt2BytesLE(toMontgomery(BETA), n8q)));\n        const beta2 = c.i32_const(module.alloc(utils$1.bigInt2BytesLE(toMontgomery(BETA2), n8q)));\n\n        const z2m1d3 = c.i32_const(module.alloc(utils$1.bigInt2BytesLE(Z2M1D3, 16)));\n\n\n        const px = c.getLocal(\"p\");\n        const py = c.i32_add(c.getLocal(\"p\"), c.i32_const(f1size));\n\n        const psp = module.alloc(f1size*3);\n        const sp = c.i32_const(psp);\n        const spx = c.i32_const(psp);\n        const spy = c.i32_const(psp+f1size);\n\n        const ps2p = module.alloc(f1size*2);\n        const s2p = c.i32_const(ps2p);\n        const s2px = c.i32_const(ps2p);\n        const s2py = c.i32_const(ps2p+f1size);\n\n        f.addCode(\n            c.if(\n                c.call(g1mPrefix + \"_isZeroAffine\", c.getLocal(\"p\")),\n                c.ret( c.i32_const(1)),\n            ),\n            c.if(\n                c.i32_eqz(c.call(g1mPrefix + \"_inCurveAffine\", c.getLocal(\"p\"))),\n                c.ret( c.i32_const(0)),\n            ),\n\n            c.call(f1mPrefix + \"_mul\", px, beta, spx),\n            c.call(f1mPrefix + \"_copy\", py, spy),\n\n            c.call(f1mPrefix + \"_mul\", px, beta2, s2px),\n            c.call(f1mPrefix + \"_copy\", py, s2py),\n\n\n            c.call(g1mPrefix + \"_doubleAffine\", sp, sp),\n            c.call(g1mPrefix + \"_subMixed\", sp, c.getLocal(\"p\"), sp),\n            c.call(g1mPrefix + \"_subMixed\", sp, s2p, sp),\n\n            c.call(g1mPrefix + \"_timesScalar\", sp, z2m1d3, c.i32_const(16), sp),\n\n            c.ret(\n                c.call(g1mPrefix + \"_eqMixed\", sp, s2p)\n            )\n\n        );\n\n        const fInGroup = module.addFunction(g1mPrefix + \"_inGroup\");\n        fInGroup.addParam(\"pIn\", \"i32\");\n        fInGroup.setReturnType(\"i32\");\n\n        const c2 = fInGroup.getCodeBuilder();\n\n        const aux2 = c2.i32_const(module.alloc(f1size*2));\n\n        fInGroup.addCode(\n            c2.call(g1mPrefix + \"_toAffine\", c2.getLocal(\"pIn\"), aux2),\n\n            c2.ret(\n                c2.call(g1mPrefix + \"_inGroupAffine\", aux2),\n            )\n        );\n    }\n\n    for (let i=0; i<10; i++) {\n        buildFrobeniusMap(i);\n        module.exportFunction(ftmPrefix + \"_frobeniusMap\"+i);\n    }\n\n\n    buildInGroupG1();\n    buildInGroupG2();\n\n    buildPrepAddStep();\n    buildPrepDoubleStep();\n\n    buildPrepareG1();\n    buildPrepareG2();\n\n    buildMillerLoop();\n\n    buildFinalExponentiationOld();\n    buildFinalExponentiation();\n\n    for (let i=1; i<=5; i++) {\n        buildPairingEquation(i);\n        module.exportFunction(prefix + \"_pairingEq\"+i);\n    }\n\n    buildPairing();\n\n    module.exportFunction(prefix + \"_pairing\");\n\n\n    module.exportFunction(prefix + \"_prepareG1\");\n    module.exportFunction(prefix + \"_prepareG2\");\n    module.exportFunction(prefix + \"_millerLoop\");\n    module.exportFunction(prefix + \"_finalExponentiation\");\n    module.exportFunction(prefix + \"_finalExponentiationOld\");\n    module.exportFunction(prefix + \"__cyclotomicSquare\");\n    module.exportFunction(prefix + \"__cyclotomicExp_w0\");\n\n    module.exportFunction(f6mPrefix + \"_mul1\");\n    module.exportFunction(f6mPrefix + \"_mul01\");\n    module.exportFunction(ftmPrefix + \"_mul014\");\n\n    module.exportFunction(g1mPrefix + \"_inGroupAffine\");\n    module.exportFunction(g1mPrefix + \"_inGroup\");\n    module.exportFunction(g2mPrefix + \"_inGroupAffine\");\n    module.exportFunction(g2mPrefix + \"_inGroup\");\n\n    // console.log(module.functionIdxByName);\n};\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// module.exports.bn128_wasm = require(\"./build/bn128_wasm.js\");\n// module.exports.bls12381_wasm = require(\"./build/bls12381_wasm.js\");\n// module.exports.mnt6753_wasm = require(\"./build/mnt6753_wasm.js\");\n\nvar buildBn128$1 = build_bn128;\nvar buildBls12381$1 = build_bls12381;\n\n/* global BigInt */\n\nfunction stringifyBigInts(o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return fromRprLE(o, 0);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigInts);\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction unstringifyBigInts(o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return BigInt(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return BigInt(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyBigInts);\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyBigInts(o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction beBuff2int(buff) {\n    let res = BigInt(0);\n    let i = buff.length;\n    let offset = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i > 0) {\n        if (i >= 4) {\n            i -= 4;\n            res += BigInt(buffV.getUint32(i)) << BigInt(offset * 8);\n            offset += 4;\n        } else if (i >= 2) {\n            i -= 2;\n            res += BigInt(buffV.getUint16(i)) << BigInt(offset * 8);\n            offset += 2;\n        } else {\n            i -= 1;\n            res += BigInt(buffV.getUint8(i)) << BigInt(offset * 8);\n            offset += 1;\n        }\n    }\n    return res;\n}\n\nfunction beInt2Buff(n, len) {\n    let r = n;\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = len;\n    while (o > 0) {\n        if (o - 4 >= 0) {\n            o -= 4;\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)));\n            r = r >> BigInt(32);\n        } else if (o - 2 >= 0) {\n            o -= 2;\n            buffV.setUint16(o, Number(r & BigInt(0xffff)));\n            r = r >> BigInt(16);\n        } else {\n            o -= 1;\n            buffV.setUint8(o, Number(r & BigInt(0xff)));\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nfunction leBuff2int(buff) {\n    let res = BigInt(0);\n    let i = 0;\n    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n    while (i < buff.length) {\n        if (i + 4 <= buff.length) {\n            res += BigInt(buffV.getUint32(i, true)) << BigInt(i * 8);\n            i += 4;\n        } else if (i + 2 <= buff.length) {\n            res += BigInt(buffV.getUint16(i, true)) << BigInt(i * 8);\n            i += 2;\n        } else {\n            res += BigInt(buffV.getUint8(i, true)) << BigInt(i * 8);\n            i += 1;\n        }\n    }\n    return res;\n}\n\nfunction leInt2Buff(n, len) {\n    let r = n;\n    if (typeof len === \"undefined\") {\n        len = Math.floor((bitLength$6(n) - 1) / 8) + 1;\n        if (len == 0) len = 1;\n    }\n    const buff = new Uint8Array(len);\n    const buffV = new DataView(buff.buffer);\n    let o = 0;\n    while (o < len) {\n        if (o + 4 <= len) {\n            buffV.setUint32(o, Number(r & BigInt(0xffffffff)), true);\n            o += 4;\n            r = r >> BigInt(32);\n        } else if (o + 2 <= len) {\n            buffV.setUint16(o, Number(r & BigInt(0xffff)), true);\n            o += 2;\n            r = r >> BigInt(16);\n        } else {\n            buffV.setUint8(o, Number(r & BigInt(0xff)), true);\n            o += 1;\n            r = r >> BigInt(8);\n        }\n    }\n    if (r) {\n        throw new Error(\"Number does not fit in this length\");\n    }\n    return buff;\n}\n\nfunction stringifyFElements(F, o) {\n    if (typeof o == \"bigint\" || o.eq !== undefined) {\n        return o.toString(10);\n    } else if (o instanceof Uint8Array) {\n        return F.toString(F.e(o));\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = stringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nfunction unstringifyFElements(F, o) {\n    if (typeof o == \"string\" && /^[0-9]+$/.test(o)) {\n        return F.e(o);\n    } else if (typeof o == \"string\" && /^0x[0-9a-fA-F]+$/.test(o)) {\n        return F.e(o);\n    } else if (Array.isArray(o)) {\n        return o.map(unstringifyFElements.bind(this, F));\n    } else if (typeof o == \"object\") {\n        if (o === null) return null;\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach((k) => {\n            res[k] = unstringifyFElements(F, o[k]);\n        });\n        return res;\n    } else {\n        return o;\n    }\n}\n\nconst _revTable = [];\nfor (let i = 0; i < 256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res = 0;\n    let a = idx;\n    for (let i = 0; i < bits; i++) {\n        res <<= 1;\n        res = res | (a & 1);\n        a >>= 1;\n    }\n    return res;\n}\n\nfunction bitReverse(idx, bits) {\n    return (\n        (_revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xff] << 8) |\n        (_revTable[(idx >>> 8) & 0xff] << 16) |\n        (_revTable[idx & 0xff] << 24)) >>>\n        (32 - bits)\n    );\n}\n\nfunction log2(V) {\n    return (\n        ((V & 0xffff0000) !== 0 ? ((V &= 0xffff0000), 16) : 0) |\n        ((V & 0xff00ff00) !== 0 ? ((V &= 0xff00ff00), 8) : 0) |\n        ((V & 0xf0f0f0f0) !== 0 ? ((V &= 0xf0f0f0f0), 4) : 0) |\n        ((V & 0xcccccccc) !== 0 ? ((V &= 0xcccccccc), 2) : 0) |\n        ((V & 0xaaaaaaaa) !== 0)\n    );\n}\n\nfunction buffReverseBits(buff, eSize) {\n    const n = buff.byteLength / eSize;\n    const bits = log2(n);\n    if (n != 1 << bits) {\n        throw new Error(\"Invalid number of pointers\");\n    }\n    for (let i = 0; i < n; i++) {\n        const r = bitReverse(i, bits);\n        if (i > r) {\n            const tmp = buff.slice(i * eSize, (i + 1) * eSize);\n            buff.set(buff.slice(r * eSize, (r + 1) * eSize), i * eSize);\n            buff.set(tmp, r * eSize);\n        }\n    }\n}\n\nfunction array2buffer(arr, sG) {\n    const buff = new Uint8Array(sG * arr.length);\n\n    for (let i = 0; i < arr.length; i++) {\n        buff.set(arr[i], i * sG);\n    }\n\n    return buff;\n}\n\nfunction buffer2array(buff, sG) {\n    const n = buff.byteLength / sG;\n    const arr = new Array(n);\n    for (let i = 0; i < n; i++) {\n        arr[i] = buff.slice(i * sG, i * sG + sG);\n    }\n    return arr;\n}\n\nvar _utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    array2buffer: array2buffer,\n    beBuff2int: beBuff2int,\n    beInt2Buff: beInt2Buff,\n    bitReverse: bitReverse,\n    buffReverseBits: buffReverseBits,\n    buffer2array: buffer2array,\n    leBuff2int: leBuff2int,\n    leInt2Buff: leInt2Buff,\n    log2: log2,\n    stringifyBigInts: stringifyBigInts,\n    stringifyFElements: stringifyFElements,\n    unstringifyBigInts: unstringifyBigInts,\n    unstringifyFElements: unstringifyFElements\n});\n\nconst PAGE_SIZE = 1<<30;\n\nclass BigBuffer {\n\n    constructor(size) {\n        this.buffers = [];\n        this.byteLength = size;\n        for (let i=0; i<size; i+= PAGE_SIZE) {\n            const n = Math.min(size-i, PAGE_SIZE);\n            this.buffers.push(new Uint8Array(n));\n        }\n\n    }\n\n    slice(fr, to) {\n        if ( to === undefined ) to = this.byteLength;\n        if ( fr === undefined ) fr = 0;\n        const len = to-fr;\n\n        const firstPage = Math.floor(fr / PAGE_SIZE);\n        const lastPage = Math.floor((fr+len-1) / PAGE_SIZE);\n\n        if ((firstPage == lastPage)||(len==0))\n            return this.buffers[firstPage].slice(fr%PAGE_SIZE, fr%PAGE_SIZE + len);\n\n        let buff;\n\n        let p = firstPage;\n        let o = fr % PAGE_SIZE;\n        // Remaining bytes to read\n        let r = len;\n        while (r>0) {\n            // bytes to copy from this page\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset+o, l);\n            if (l == len) return srcView.slice();\n            if (!buff) {\n                if (len <= PAGE_SIZE) {\n                    buff = new Uint8Array(len);\n                } else {\n                    buff = new BigBuffer(len);\n                }\n            }\n            buff.set(srcView, len-r);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n        return buff;\n    }\n\n    set(buff, offset) {\n        if (offset === undefined) offset = 0;\n\n        const len = buff.byteLength;\n\n        if (len==0) return;\n\n        const firstPage = Math.floor(offset / PAGE_SIZE);\n        const lastPage = Math.floor((offset+len-1) / PAGE_SIZE);\n\n        if (firstPage == lastPage) {\n            if ((buff instanceof BigBuffer)&&(buff.buffers.length==1)) {\n                return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);\n            } else {\n                return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);\n            }\n\n        }\n\n\n        let p = firstPage;\n        let o = offset % PAGE_SIZE;\n        let r = len;\n        while (r>0) {\n            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;\n            const srcView = buff.slice( len -r, len -r+l);\n            const dstView = new Uint8Array(this.buffers[p].buffer, this.buffers[p].byteOffset + o, l);\n            dstView.set(srcView);\n            r = r-l;\n            p ++;\n            o = 0;\n        }\n\n    }\n}\n\nfunction buildBatchConvert(tm, fnName, sIn, sOut) {\n    return async function batchConvert(buffIn) {\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1}\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n\nclass WasmField1 {\n\n    constructor(tm, prefix, n8, p) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.p = p;\n        this.n8 = n8;\n        this.type = \"F1\";\n        this.m = 1;\n\n        this.half = shiftRight(p, one);\n        this.bitLength = bitLength$6(p);\n        this.mask = sub(shiftLeft(one, this.bitLength), one);\n\n        this.pOp1 = tm.alloc(n8);\n        this.pOp2 = tm.alloc(n8);\n        this.pOp3 = tm.alloc(n8);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = this.tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.n64 = Math.floor(n8/8);\n        this.n32 = Math.floor(n8/4);\n\n        if(this.n64*8 != this.n8) {\n            throw new Error(\"n8 must be a multiple of 8\");\n        }\n\n        this.half = shiftRight(this.p, one);\n        this.nqr = this.two;\n        let r = this.exp(this.nqr, this.half);\n        while (!this.eq(r, this.negone)) {\n            this.nqr = this.add(this.nqr, this.one);\n            r = this.exp(this.nqr, this.half);\n        }\n\n        this.shift = this.mul(this.nqr, this.nqr);\n        this.shiftInv = this.inv(this.shift);\n\n        this.s = 0;\n        let t = sub(this.p, one);\n\n        while ( !isOdd$5(t) ) {\n            this.s = this.s + 1;\n            t = shiftRight(t, one);\n        }\n\n        this.w = [];\n        this.w[this.s] = this.exp(this.nqr, t);\n\n        for (let i= this.s-1; i>=0; i--) {\n            this.w[i] = this.square(this.w[i+1]);\n        }\n\n        if (!this.eq(this.w[0], this.one)) {\n            throw new Error(\"Error calculating roots of unity\");\n        }\n\n        this.batchToMontgomery = buildBatchConvert(tm, prefix + \"_batchToMontgomery\", this.n8, this.n8);\n        this.batchFromMontgomery = buildBatchConvert(tm, prefix + \"_batchFromMontgomery\", this.n8, this.n8);\n    }\n\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = toLEBuff(e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        let ra = e(a, b);\n        if (isNegative$4(ra)) {\n            ra = neg(ra);\n            if (gt(ra, this.p)) {\n                ra = mod(ra, this.p);\n            }\n            ra = sub(this.p, ra);\n        } else {\n            if (gt(ra, this.p)) {\n                ra = mod(ra, this.p);\n            }\n        }\n        const buff = leInt2Buff(ra, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toString(a, radix) {\n        const an = this.fromMontgomery(a);\n        const s = fromRprLE(an, 0);\n        return toString(s, radix);\n    }\n\n    fromRng(rng) {\n        let v;\n        const buff = new Uint8Array(this.n8);\n        do {\n            v = zero;\n            for (let i=0; i<this.n64; i++) {\n                v = add(v,  shiftLeft(rng.nextU64(), 64*i));\n            }\n            v = band(v, this.mask);\n        } while (geq(v, this.p));\n        toRprLE(buff, 0, v, this.n8);\n        return buff;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const an = this.fromMontgomery(a);\n        return fromRprLE(an, 0);\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.n8);\n        toRprLE(buff, 0, a, this.n8);\n        return this.toMontgomery(buff);\n    }\n\n    toRprLE(buff, offset, a) {\n        buff.set(this.fromMontgomery(a), offset);\n    }\n\n    toRprBE(buff, offset, a) {\n        const buff2 = this.fromMontgomery(a);\n        for (let i=0; i<this.n8/2; i++) {\n            const aux = buff2[i];\n            buff2[i] = buff2[this.n8-1-i];\n            buff2[this.n8-1-i] = aux;\n        }\n        buff.set(buff2, offset);\n    }\n\n    fromRprLE(buff, offset) {\n        offset = offset || 0;\n        const res = buff.slice(offset, offset + this.n8);\n        return this.toMontgomery(res);\n    }\n\n    async batchInverse(buffIn) {\n        let returnArray = false;\n        const sIn = this.n8;\n        const sOut = this.n8;\n\n        if (Array.isArray(buffIn)) {\n            buffIn = array2buffer(buffIn, sIn );\n            returnArray = true;\n        } else {\n            buffIn = buffIn.slice(0, buffIn.byteLength);\n        }\n\n        const nPoints = Math.floor(buffIn.byteLength / sIn);\n        if ( nPoints * sIn !== buffIn.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const pointsPerChunk = Math.floor(nPoints/this.tm.concurrency);\n        const opPromises = [];\n        for (let i=0; i<this.tm.concurrency; i++) {\n            let n;\n            if (i< this.tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const buffChunk = buffIn.slice(i*pointsPerChunk*sIn, i*pointsPerChunk*sIn + n*sIn);\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff:buffChunk},\n                {cmd: \"ALLOC\", var: 1, len:sOut * n},\n                {cmd: \"CALL\", fnName: this.prefix + \"_batchInverse\", params: [\n                    {var: 0},\n                    {val: sIn},\n                    {val: n},\n                    {var: 1},\n                    {val: sOut},\n                ]},\n                {cmd: \"GET\", out: 0, var: 1, len:sOut * n},\n            ];\n            opPromises.push(\n                this.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buffIn instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        if (returnArray) {\n            return buffer2array(fullBuffOut, sOut);\n        } else {\n            return fullBuffOut;\n        }\n\n    }\n\n}\n\nclass WasmField2 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F2\";\n        this.m = F.m * 2;\n        this.n8 = this.F.n8*2;\n        this.n32 = this.F.n32*2;\n        this.n64 = this.F.n64*2;\n\n        this.pOp1 = tm.alloc(F.n8*2);\n        this.pOp2 = tm.alloc(F.n8*2);\n        this.pOp3 = tm.alloc(F.n8*2);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    mul1(a,b) {\n        return this.op2(\"_mul1\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = toLEBuff(e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 2)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const res = new Uint8Array(this.F.n8*2);\n            res.set(c1);\n            res.set(c2, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F2\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8), radix);\n        return `[${s1}, ${s2}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*2);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        return [c1, c2];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8);\n    }\n\n}\n\nclass WasmField3 {\n\n    constructor(tm, prefix, F) {\n        this.tm = tm;\n        this.prefix = prefix;\n\n        this.F = F;\n        this.type = \"F3\";\n        this.m = F.m * 3;\n        this.n8 = this.F.n8*3;\n        this.n32 = this.F.n32*3;\n        this.n64 = this.F.n64*3;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = tm.getBuff(this.pOp1, this.n8);\n        this.tm.instance.exports[prefix + \"_one\"](this.pOp1);\n        this.one = tm.getBuff(this.pOp1, this.n8);\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op2Bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n\n    eq(a,b) {\n        return this.op2Bool(\"_eq\", a, b);\n    }\n\n    isZero(a) {\n        return this.op1Bool(\"_isZero\", a);\n    }\n\n    add(a,b) {\n        return this.op2(\"_add\", a, b);\n    }\n\n    sub(a,b) {\n        return this.op2(\"_sub\", a, b);\n    }\n\n    neg(a) {\n        return this.op1(\"_neg\", a);\n    }\n\n    inv(a) {\n        return this.op1(\"_inverse\", a);\n    }\n\n    isNegative(a) {\n        return this.op1Bool(\"_isNegative\", a);\n    }\n\n    toMontgomery(a) {\n        return this.op1(\"_toMontgomery\", a);\n    }\n\n    fromMontgomery(a) {\n        return this.op1(\"_fromMontgomery\", a);\n    }\n\n    mul(a,b) {\n        return this.op2(\"_mul\", a, b);\n    }\n\n    div(a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_inverse\"](this.pOp2, this.pOp2);\n        this.tm.instance.exports[this.prefix + \"_mul\"](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.n8);\n    }\n\n    square(a) {\n        return this.op1(\"_square\", a);\n    }\n\n    isSquare(a) {\n        return this.op1Bool(\"_isSquare\", a);\n    }\n\n    sqrt(a) {\n        return this.op1(\"_sqrt\", a);\n    }\n\n    exp(a, b) {\n        if (!(b instanceof Uint8Array)) {\n            b = toLEBuff(e(b));\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + \"_exp\"](this.pOp1, this.pOp2, b.byteLength, this.pOp3);\n        return this.getBuff(this.pOp3, this.n8);\n    }\n\n    e(a, b) {\n        if (a instanceof Uint8Array) return a;\n        if ((Array.isArray(a)) && (a.length == 3)) {\n            const c1 = this.F.e(a[0], b);\n            const c2 = this.F.e(a[1], b);\n            const c3 = this.F.e(a[2], b);\n            const res = new Uint8Array(this.F.n8*3);\n            res.set(c1);\n            res.set(c2, this.F.n8);\n            res.set(c3, this.F.n8*2);\n            return res;\n        } else {\n            throw new Error(\"invalid F3\");\n        }\n    }\n\n    toString(a, radix) {\n        const s1 = this.F.toString(a.slice(0, this.F.n8), radix);\n        const s2 = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n        const s3 = this.F.toString(a.slice(this.F.n8*2), radix);\n        return `[${s1}, ${s2}, ${s3}]`;\n    }\n\n    fromRng(rng) {\n        const c1 = this.F.fromRng(rng);\n        const c2 = this.F.fromRng(rng);\n        const c3 = this.F.fromRng(rng);\n        const res = new Uint8Array(this.F.n8*3);\n        res.set(c1);\n        res.set(c2, this.F.n8);\n        res.set(c3, this.F.n8*2);\n        return res;\n    }\n\n    random() {\n        return this.fromRng(getThreadRng());\n    }\n\n    toObject(a) {\n        const c1 = this.F.toObject(a.slice(0, this.F.n8));\n        const c2 = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        const c3 = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        return [c1, c2, c3];\n    }\n\n    fromObject(a) {\n        const buff = new Uint8Array(this.F.n8*3);\n        const b1 = this.F.fromObject(a[0]);\n        const b2 = this.F.fromObject(a[1]);\n        const b3 = this.F.fromObject(a[2]);\n        buff.set(b1);\n        buff.set(b2, this.F.n8);\n        buff.set(b3, this.F.n8*2);\n        return buff;\n    }\n\n    c1(a) {\n        return a.slice(0, this.F.n8);\n    }\n\n    c2(a) {\n        return a.slice(this.F.n8, this.F.n8*2);\n    }\n\n    c3(a) {\n        return a.slice(this.F.n8*2);\n    }\n\n}\n\nclass WasmCurve {\n\n    constructor(tm, prefix, F, pGen, pGb, cofactor) {\n        this.tm = tm;\n        this.prefix = prefix;\n        this.F = F;\n\n        this.pOp1 = tm.alloc(F.n8*3);\n        this.pOp2 = tm.alloc(F.n8*3);\n        this.pOp3 = tm.alloc(F.n8*3);\n        this.tm.instance.exports[prefix + \"_zero\"](this.pOp1);\n        this.zero = this.tm.getBuff(this.pOp1, F.n8*3);\n        this.tm.instance.exports[prefix + \"_zeroAffine\"](this.pOp1);\n        this.zeroAffine = this.tm.getBuff(this.pOp1, F.n8*2);\n        this.one = this.tm.getBuff(pGen, F.n8*3);\n        this.g = this.one;\n        this.oneAffine = this.tm.getBuff(pGen, F.n8*2);\n        this.gAffine = this.oneAffine;\n        this.b = this.tm.getBuff(pGb, F.n8);\n\n        if (cofactor) {\n            this.cofactor = toLEBuff(cofactor);\n        }\n\n        this.negone = this.neg(this.one);\n        this.two = this.add(this.one, this.one);\n\n        this.batchLEMtoC = buildBatchConvert(tm, prefix + \"_batchLEMtoC\", F.n8*2, F.n8);\n        this.batchLEMtoU = buildBatchConvert(tm, prefix + \"_batchLEMtoU\", F.n8*2, F.n8*2);\n        this.batchCtoLEM = buildBatchConvert(tm, prefix + \"_batchCtoLEM\", F.n8, F.n8*2);\n        this.batchUtoLEM = buildBatchConvert(tm, prefix + \"_batchUtoLEM\", F.n8*2, F.n8*2);\n        this.batchToJacobian = buildBatchConvert(tm, prefix + \"_batchToJacobian\", F.n8*2, F.n8*3);\n        this.batchToAffine = buildBatchConvert(tm, prefix + \"_batchToAffine\", F.n8*3, F.n8*2);\n    }\n\n    op2(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op2bool(opName, a, b) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, b);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);\n    }\n\n    op1(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    op1Affine(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*2);\n    }\n\n    op1Bool(opName, a) {\n        this.tm.setBuff(this.pOp1, a);\n        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);\n    }\n\n    add(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_add\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_addMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_addAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    sub(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_sub\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2(\"_subMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2(\"_subAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    neg(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_neg\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Affine(\"_negAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    double(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1(\"_double\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_doubleAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isZero(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Bool(\"_isZero\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1Bool(\"_isZeroAffine\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    timesScalar(a, s) {\n        if (!(s instanceof Uint8Array)) {\n            s = toLEBuff(e(s));\n        }\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesScalar\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesScalarAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s.byteLength, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    timesFr(a, s) {\n        let fnName;\n        if (a.byteLength == this.F.n8*3) {\n            fnName = this.prefix + \"_timesFr\";\n        } else if (a.byteLength == this.F.n8*2) {\n            fnName = this.prefix + \"_timesFrAffine\";\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.setBuff(this.pOp1, a);\n        this.tm.setBuff(this.pOp2, s);\n        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);\n        return this.tm.getBuff(this.pOp3, this.F.n8*3);\n    }\n\n    eq(a,b) {\n        if (a.byteLength == this.F.n8*3) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eq\", a, b);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqMixed\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else if (a.byteLength == this.F.n8*2) {\n            if (b.byteLength == this.F.n8*3) {\n                return this.op2bool(\"_eqMixed\", b, a);\n            } else if (b.byteLength == this.F.n8*2) {\n                return this.op2bool(\"_eqAffine\", a, b);\n            } else {\n                throw new Error(\"invalid point size\");\n            }\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toAffine(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return this.op1Affine(\"_toAffine\", a);\n        } else if (a.byteLength == this.F.n8*2) {\n            return a;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toJacobian(a) {\n        if (a.byteLength == this.F.n8*3) {\n            return a;\n        } else if (a.byteLength == this.F.n8*2) {\n            return this.op1(\"_toJacobian\", a);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    toRprUncompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoU\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n        arr.set(res, offset);\n    }\n\n    fromRprUncompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8*2);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_UtoLEM\"](this.pOp1, this.pOp1);\n        return this.tm.getBuff(this.pOp1, this.F.n8*2);\n    }\n\n    toRprCompressed(arr, offset, a) {\n        this.tm.setBuff(this.pOp1, a);\n        if (a.byteLength == this.F.n8*3) {\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n        } else if (a.byteLength != this.F.n8*2) {\n            throw new Error(\"invalid point size\");\n        }\n        this.tm.instance.exports[this.prefix + \"_LEMtoC\"](this.pOp1, this.pOp1);\n        const res = this.tm.getBuff(this.pOp1, this.F.n8);\n        arr.set(res, offset);\n    }\n\n    fromRprCompressed(arr, offset) {\n        const buff = arr.slice(offset, offset + this.F.n8);\n        this.tm.setBuff(this.pOp1, buff);\n        this.tm.instance.exports[this.prefix + \"_CtoLEM\"](this.pOp1, this.pOp2);\n        return this.tm.getBuff(this.pOp2, this.F.n8*2);\n    }\n\n    toUncompressed(a) {\n        const buff = new Uint8Array(this.F.n8*2);\n        this.toRprUncompressed(buff, 0, a);\n        return buff;\n    }\n\n    toRprLEM(arr, offset, a) {\n        if (a.byteLength == this.F.n8*2) {\n            arr.set(a, offset);\n            return;\n        } else if (a.byteLength == this.F.n8*3) {\n            this.tm.setBuff(this.pOp1, a);\n            this.tm.instance.exports[this.prefix + \"_toAffine\"](this.pOp1, this.pOp1);\n            const res = this.tm.getBuff(this.pOp1, this.F.n8*2);\n            arr.set(res, offset);\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    fromRprLEM(arr, offset) {\n        offset = offset || 0;\n        return arr.slice(offset, offset+this.F.n8*2);\n    }\n\n    toString(a, radix) {\n        if (a.byteLength == this.F.n8*3) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8, this.F.n8*2), radix);\n            const z = this.F.toString(a.slice(this.F.n8*2), radix);\n            return `[ ${x}, ${y}, ${z} ]`;\n        } else if (a.byteLength == this.F.n8*2) {\n            const x = this.F.toString(a.slice(0, this.F.n8), radix);\n            const y = this.F.toString(a.slice(this.F.n8), radix);\n            return `[ ${x}, ${y} ]`;\n        } else {\n            throw new Error(\"invalid point size\");\n        }\n    }\n\n    isValid(a) {\n        if (this.isZero(a)) return true;\n        const F = this.F;\n        const aa = this.toAffine(a);\n        const x = aa.slice(0, this.F.n8);\n        const y = aa.slice(this.F.n8, this.F.n8*2);\n        const x3b = F.add(F.mul(F.square(x),x), this.b);\n        const y2 = F.square(y);\n        return F.eq(x3b, y2);\n    }\n\n    fromRng(rng) {\n        const F = this.F;\n        let P = [];\n        let greatest;\n        let x3b;\n        do {\n            P[0] = F.fromRng(rng);\n            greatest = rng.nextBool();\n            x3b = F.add(F.mul(F.square(P[0]), P[0]), this.b);\n        } while (!F.isSquare(x3b));\n\n        P[1] = F.sqrt(x3b);\n\n        const s = F.isNegative(P[1]);\n        if (greatest ^ s) P[1] = F.neg(P[1]);\n\n        let Pbuff = new Uint8Array(this.F.n8*2);\n        Pbuff.set(P[0]);\n        Pbuff.set(P[1], this.F.n8);\n\n        if (this.cofactor) {\n            Pbuff = this.timesScalar(Pbuff, this.cofactor);\n        }\n\n        return Pbuff;\n    }\n\n\n\n    toObject(a) {\n        if (this.isZero(a)) {\n            return [\n                this.F.toObject(this.F.zero),\n                this.F.toObject(this.F.one),\n                this.F.toObject(this.F.zero),\n            ];\n        }\n        const x = this.F.toObject(a.slice(0, this.F.n8));\n        const y = this.F.toObject(a.slice(this.F.n8, this.F.n8*2));\n        let z;\n        if (a.byteLength == this.F.n8*3) {\n            z = this.F.toObject(a.slice(this.F.n8*2, this.F.n8*3));\n        } else {\n            z = this.F.toObject(this.F.one);\n        }\n        return [x, y, z];\n    }\n\n    fromObject(a) {\n        const x = this.F.fromObject(a[0]);\n        const y = this.F.fromObject(a[1]);\n        let z;\n        if (a.length==3) {\n            z = this.F.fromObject(a[2]);\n        } else {\n            z = this.F.one;\n        }\n        if (this.F.isZero(z, this.F.one)) {\n            return this.zeroAffine;\n        } else if (this.F.eq(z, this.F.one)) {\n            const buff = new Uint8Array(this.F.n8*2);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            return buff;\n        } else {\n            const buff = new Uint8Array(this.F.n8*3);\n            buff.set(x);\n            buff.set(y, this.F.n8);\n            buff.set(z, this.F.n8*2);\n            return buff;\n        }\n    }\n\n    e(a) {\n        if (a instanceof Uint8Array) return a;\n        return this.fromObject(a);\n    }\n\n    x(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(0, this.F.n8);\n    }\n\n    y(a) {\n        const tmp = this.toAffine(a);\n        return tmp.slice(this.F.n8);\n    }\n\n}\n\n/* global WebAssembly */\n\nfunction thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == \"INIT\") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == \"TERMINATE\") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == \"INIT\") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case \"ALLOCSET\":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case \"ALLOC\":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case \"SET\":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case \"CALL\": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== \"undefined\") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != \"undefined\") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case \"GET\":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error(\"Invalid cmd\");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmsnark (Web Assembly zkSnark Prover).\n\n    wasmsnark is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmsnark is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmsnark. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// const MEM_SIZE = 1000;  // Memory size in 64K Pakes (512Mb)\nconst MEM_SIZE = 25;  // Memory size in 64K Pakes (1600Kb)\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject)=> {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nlet workerSource;\n\nconst threadStr = `(${\"function thread(self) {\\n    const MAXMEM = 32767;\\n    let instance;\\n    let memory;\\n\\n    if (self) {\\n        self.onmessage = function(e) {\\n            let data;\\n            if (e.data) {\\n                data = e.data;\\n            } else {\\n                data = e;\\n            }\\n\\n            if (data[0].cmd == \\\"INIT\\\") {\\n                init(data[0]).then(function() {\\n                    self.postMessage(data.result);\\n                });\\n            } else if (data[0].cmd == \\\"TERMINATE\\\") {\\n                self.close();\\n            } else {\\n                const res = runTask(data);\\n                self.postMessage(res);\\n            }\\n        };\\n    }\\n\\n    async function init(data) {\\n        const code = new Uint8Array(data.code);\\n        const wasmModule = await WebAssembly.compile(code);\\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\\n\\n        instance = await WebAssembly.instantiate(wasmModule, {\\n            env: {\\n                \\\"memory\\\": memory\\n            }\\n        });\\n    }\\n\\n\\n\\n    function alloc(length) {\\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\\n        const res = u32[0];\\n        u32[0] += length;\\n        if (u32[0] + length > memory.buffer.byteLength) {\\n            const currentPages = memory.buffer.byteLength / 0x10000;\\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\\n            memory.grow(requiredPages-currentPages);\\n        }\\n        return res;\\n    }\\n\\n    function allocBuffer(buffer) {\\n        const p = alloc(buffer.byteLength);\\n        setBuffer(p, buffer);\\n        return p;\\n    }\\n\\n    function getBuffer(pointer, length) {\\n        const u8 = new Uint8Array(memory.buffer);\\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\\n    }\\n\\n    function setBuffer(pointer, buffer) {\\n        const u8 = new Uint8Array(memory.buffer);\\n        u8.set(new Uint8Array(buffer), pointer);\\n    }\\n\\n    function runTask(task) {\\n        if (task[0].cmd == \\\"INIT\\\") {\\n            return init(task[0]);\\n        }\\n        const ctx = {\\n            vars: [],\\n            out: []\\n        };\\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\\n        const oldAlloc = u32a[0];\\n        for (let i=0; i<task.length; i++) {\\n            switch (task[i].cmd) {\\n            case \\\"ALLOCSET\\\":\\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\\n                break;\\n            case \\\"ALLOC\\\":\\n                ctx.vars[task[i].var] = alloc(task[i].len);\\n                break;\\n            case \\\"SET\\\":\\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\\n                break;\\n            case \\\"CALL\\\": {\\n                const params = [];\\n                for (let j=0; j<task[i].params.length; j++) {\\n                    const p = task[i].params[j];\\n                    if (typeof p.var !== \\\"undefined\\\") {\\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\\n                    } else if (typeof p.val != \\\"undefined\\\") {\\n                        params.push(p.val);\\n                    }\\n                }\\n                instance.exports[task[i].fnName](...params);\\n                break;\\n            }\\n            case \\\"GET\\\":\\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\\n                break;\\n            default:\\n                throw new Error(\\\"Invalid cmd\\\");\\n            }\\n        }\\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\\n        u32b[0] = oldAlloc;\\n        return ctx.out;\\n    }\\n\\n\\n    return runTask;\\n}\"})(self)`;\n{\n    if(globalThis?.Blob) {\n        const threadBytes= new TextEncoder().encode(threadStr);\n        const workerBlob = new Blob([threadBytes], { type: \"application/javascript\" }) ;\n        workerSource = URL.createObjectURL(workerBlob);\n    } else {\n        workerSource = \"data:application/javascript;base64,\" + globalThis.btoa(threadStr);\n    }\n}\n\n\n\nasync function buildThreadManager(wasm, singleThread) {\n    const tm = new ThreadManager();\n\n    tm.memory = new WebAssembly.Memory({initial:MEM_SIZE});\n    tm.u8 = new Uint8Array(tm.memory.buffer);\n    tm.u32 = new Uint32Array(tm.memory.buffer);\n\n    const wasmModule = await WebAssembly.compile(wasm.code);\n\n    tm.instance = await WebAssembly.instantiate(wasmModule, {\n        env: {\n            \"memory\": tm.memory\n        }\n    });\n    \n    if(!globalThis?.Worker) {\n        singleThread = true;\n    }\n    \n    tm.singleThread = singleThread;\n    tm.initalPFree = tm.u32[0];   // Save the Pointer to free space.\n    tm.pq = wasm.pq;\n    tm.pr = wasm.pr;\n    tm.pG1gen = wasm.pG1gen;\n    tm.pG1zero = wasm.pG1zero;\n    tm.pG2gen = wasm.pG2gen;\n    tm.pG2zero = wasm.pG2zero;\n    tm.pOneT = wasm.pOneT;\n\n    //    tm.pTmp0 = tm.alloc(curve.G2.F.n8*3);\n    //    tm.pTmp1 = tm.alloc(curve.G2.F.n8*3);\n\n    if (singleThread) {\n        tm.code = wasm.code;\n        tm.taskManager = thread();\n        await tm.taskManager([{\n            cmd: \"INIT\",\n            init: MEM_SIZE,\n            code: tm.code.slice()\n        }]);\n        tm.concurrency  = 1;\n    } else {\n        tm.workers = [];\n        tm.pendingDeferreds = [];\n        tm.working = [];\n\n        let concurrency = 2;\n        {\n            if (typeof navigator === \"object\" && navigator.hardwareConcurrency) {\n                concurrency = navigator.hardwareConcurrency;\n            }\n        }\n\n        if(concurrency == 0){\n            concurrency = 2;\n        }\n\n        // Limit to 64 threads for memory reasons.\n        if (concurrency>64) concurrency=64;\n        tm.concurrency = concurrency;\n\n        for (let i = 0; i<concurrency; i++) {\n\n            tm.workers[i] = new Worker(workerSource);\n\n            tm.workers[i].addEventListener(\"message\", getOnMsg(i));\n\n            tm.working[i]=false;\n        }\n\n        const initPromises = [];\n        for (let i=0; i<tm.workers.length;i++) {\n            const copyCode = wasm.code.slice();\n            initPromises.push(tm.postAction(i, [{\n                cmd: \"INIT\",\n                init: MEM_SIZE,\n                code: copyCode\n            }], [copyCode.buffer]));\n        }\n\n        await Promise.all(initPromises);\n\n    }\n    return tm;\n\n    function getOnMsg(i) {\n        return function(e) {\n            let data;\n            if ((e)&&(e.data)) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            tm.working[i]=false;\n            tm.pendingDeferreds[i].resolve(data);\n            tm.processWorks();\n        };\n    }\n\n}\n\nclass ThreadManager {\n    constructor() {\n        this.actionQueue = [];\n        this.oldPFree = 0;\n    }\n\n    startSyncOp() {\n        if (this.oldPFree != 0) throw new Error(\"Sync operation in progress\");\n        this.oldPFree = this.u32[0];\n    }\n\n    endSyncOp() {\n        if (this.oldPFree == 0) throw new Error(\"No sync operation in progress\");\n        this.u32[0] = this.oldPFree;\n        this.oldPFree = 0;\n    }\n\n    postAction(workerId, e, transfers, _deferred) {\n        if (this.working[workerId]) {\n            throw new Error(\"Posting a job t a working worker\");\n        }\n        this.working[workerId] = true;\n\n        this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();\n        this.workers[workerId].postMessage(e, transfers);\n\n        return this.pendingDeferreds[workerId].promise;\n    }\n\n    processWorks() {\n        for (let i=0; (i<this.workers.length)&&(this.actionQueue.length > 0); i++) {\n            if (this.working[i] == false) {\n                const work = this.actionQueue.shift();\n                this.postAction(i, work.data, work.transfers, work.deferred);\n            }\n        }\n    }\n\n    queueAction(actionData, transfers) {\n        const d = new Deferred();\n\n        if (this.singleThread) {\n            const res = this.taskManager(actionData);\n            d.resolve(res);\n        } else {\n            this.actionQueue.push({\n                data: actionData,\n                transfers: transfers,\n                deferred: d\n            });\n            this.processWorks();\n        }\n        return d.promise;\n    }\n\n    resetMemory() {\n        this.u32[0] = this.initalPFree;\n    }\n\n    allocBuff(buff) {\n        const pointer = this.alloc(buff.byteLength);\n        this.setBuff(pointer, buff);\n        return pointer;\n    }\n\n    getBuff(pointer, length) {\n        return this.u8.slice(pointer, pointer+ length);\n    }\n\n    setBuff(pointer, buffer) {\n        this.u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    alloc(length) {\n        while (this.u32[0] & 3) this.u32[0]++;  // Return always aligned pointers\n        const res = this.u32[0];\n        this.u32[0] += length;\n        return res;\n    }\n\n    async terminate() {\n        for (let i=0; i<this.workers.length; i++) {\n            this.workers[i].postMessage([{cmd: \"TERMINATE\"}]);\n        }\n        await sleep(200);\n    }\n\n}\n\nfunction buildBatchApplyKey(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = curve.tm;\n\n    curve[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        let fnName, fnAffine;\n        let sGin, sGmid, sGout;\n        if (groupName == \"G1\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g1m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g1m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g1m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"jacobian\") {\n                sGin = G.F.n8*3;\n                fnName = \"g2m_batchApplyKey\";\n            } else {\n                sGin = G.F.n8*2;\n                fnName = \"g2m_batchApplyKeyMixed\";\n            }\n            sGmid = G.F.n8*3;\n            if (outType == \"jacobian\") {\n                sGout = G.F.n8*3;\n            } else {\n                fnAffine = \"g2m_batchToAffine\";\n                sGout = G.F.n8*2;\n            }\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_batchApplyKey\";\n            sGin = G.n8;\n            sGmid = G.n8;\n            sGout = G.n8;\n        } else {\n            throw new Error(\"Invalid group: \" + groupName);\n        }\n        const nPoints = Math.floor(buff.byteLength / sGin);\n        const pointsPerChunk = Math.floor(nPoints/tm.concurrency);\n        const opPromises = [];\n        inc = Fr.e(inc);\n        let t = Fr.e(first);\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({\n                cmd: \"ALLOCSET\",\n                var: 0,\n                buff: buff.slice(i*pointsPerChunk*sGin, i*pointsPerChunk*sGin + n*sGin)\n            });\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: t});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: inc});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*Math.max(sGmid, sGout)});\n            task.push({\n                cmd: \"CALL\",\n                fnName: fnName,\n                params: [\n                    {var: 0},\n                    {val: n},\n                    {var: 1},\n                    {var: 2},\n                    {var:3}\n                ]\n            });\n            if (fnAffine) {\n                task.push({\n                    cmd: \"CALL\",\n                    fnName: fnAffine,\n                    params: [\n                        {var: 3},\n                        {val: n},\n                        {var: 3},\n                    ]\n                });\n            }\n            task.push({cmd: \"GET\", out: 0, var: 3, len: n*sGout});\n\n            opPromises.push(tm.queueAction(task));\n            t = Fr.mul(t, Fr.exp(inc, n));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let outBuff;\n        if (buff instanceof BigBuffer) {\n            outBuff = new BigBuffer(nPoints*sGout);\n        } else {\n            outBuff = new Uint8Array(nPoints*sGout);\n        }\n\n        let p=0;\n        for (let i=0; i<result.length; i++) {\n            outBuff.set(result[i][0], p);\n            p += result[i][0].byteLength;\n        }\n\n        return outBuff;\n    };\n}\n\nfunction buildPairing(curve) {\n    const tm = curve.tm;\n    curve.pairing = function pairing(a, b) {\n\n        tm.startSyncOp();\n        const pA = tm.allocBuff(curve.G1.toJacobian(a));\n        const pB = tm.allocBuff(curve.G2.toJacobian(b));\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports[curve.name + \"_pairing\"](pA, pB, pRes);\n\n        const res = tm.getBuff(pRes, curve.Gt.n8);\n\n        tm.endSyncOp();\n        return res;\n    };\n\n    curve.pairingEq = async function pairingEq() {\n        let  buffCt;\n        let nEqs;\n        if ((arguments.length % 2) == 1) {\n            buffCt = arguments[arguments.length-1];\n            nEqs = (arguments.length -1) /2;\n        } else {\n            buffCt = curve.Gt.one;\n            nEqs = arguments.length /2;\n        }\n\n        const opPromises = [];\n        for (let i=0; i<nEqs; i++) {\n\n            const task = [];\n\n            const g1Buff = curve.G1.toJacobian(arguments[i*2]);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: g1Buff});\n            task.push({cmd: \"ALLOC\", var: 1, len: curve.prePSize});\n\n            const g2Buff = curve.G2.toJacobian(arguments[i*2 +1]);\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: g2Buff});\n            task.push({cmd: \"ALLOC\", var: 3, len: curve.preQSize});\n\n            task.push({cmd: \"ALLOC\", var: 4, len: curve.Gt.n8});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG1\", params: [\n                {var: 0},\n                {var: 1}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_prepareG2\", params: [\n                {var: 2},\n                {var: 3}\n            ]});\n\n            task.push({cmd: \"CALL\", fnName: curve.name + \"_millerLoop\", params: [\n                {var: 1},\n                {var: 3},\n                {var: 4}\n            ]});\n\n            task.push({cmd: \"GET\", out: 0, var: 4, len: curve.Gt.n8});\n\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        tm.startSyncOp();\n        const pRes = tm.alloc(curve.Gt.n8);\n        tm.instance.exports.ftm_one(pRes);\n\n        for (let i=0; i<result.length; i++) {\n            const pMR = tm.allocBuff(result[i][0]);\n            tm.instance.exports.ftm_mul(pRes, pMR, pRes);\n        }\n        tm.instance.exports[curve.name + \"_finalExponentiation\"](pRes, pRes);\n\n        const pCt = tm.allocBuff(buffCt);\n\n        const r = !!tm.instance.exports.ftm_eq(pRes, pCt);\n\n        tm.endSyncOp();\n\n        return r;\n    };\n\n    curve.prepareG1 = function(p) {\n        this.tm.startSyncOp();\n        const pP = this.tm.allocBuff(p);\n        const pPrepP = this.tm.alloc(this.prePSize);\n        this.tm.instance.exports[this.name + \"_prepareG1\"](pP, pPrepP);\n        const res = this.tm.getBuff(pPrepP, this.prePSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.prepareG2 = function(q) {\n        this.tm.startSyncOp();\n        const pQ = this.tm.allocBuff(q);\n        const pPrepQ = this.tm.alloc(this.preQSize);\n        this.tm.instance.exports[this.name + \"_prepareG2\"](pQ, pPrepQ);\n        const res = this.tm.getBuff(pPrepQ, this.preQSize);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.millerLoop = function(preP, preQ) {\n        this.tm.startSyncOp();\n        const pPreP = this.tm.allocBuff(preP);\n        const pPreQ = this.tm.allocBuff(preQ);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_millerLoop\"](pPreP, pPreQ, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n    curve.finalExponentiation = function(a) {\n        this.tm.startSyncOp();\n        const pA = this.tm.allocBuff(a);\n        const pRes = this.tm.alloc(this.Gt.n8);\n        this.tm.instance.exports[this.name + \"_finalExponentiation\"](pA, pRes);\n        const res = this.tm.getBuff(pRes, this.Gt.n8);\n        this.tm.endSyncOp();\n        return res;\n    };\n\n}\n\nconst pTSizes = [\n    1 ,  1,  1,  1,    2,  3,  4,  5,\n    6 ,  7,  7,  8,    9, 10, 11, 12,\n    13, 13, 14, 15,   16, 16, 17, 17,\n    17, 17, 17, 17,   17, 17, 17, 17\n];\n\nfunction buildMultiexp(curve, groupName) {\n    const G = curve[groupName];\n    const tm = G.tm;\n    async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {\n        if ( ! (buffBases instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);\n        }\n        if ( ! (buffScalars instanceof Uint8Array) ) {\n            if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n            throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);\n        }\n        inType = inType || \"affine\";\n\n        let sGIn;\n        let fnName;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                fnName = \"g1m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g1m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                fnName = \"g2m_multiexpAffine_chunk\";\n                sGIn = G.F.n8*2;\n            } else {\n                fnName = \"g2m_multiexp_chunk\";\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [\n                {cmd: \"ALLOCSET\", var: 0, buff: buffBases},\n                {cmd: \"ALLOCSET\", var: 1, buff: buffScalars},\n                {cmd: \"ALLOC\", var: 2, len: G.F.n8*3},\n                {cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {var: 1},\n                    {val: sScalar},\n                    {val: nPoints},\n                    {val: i*bitChunkSize},\n                    {val: Math.min(sScalar*8 - i*bitChunkSize, bitChunkSize)},\n                    {var: 2}\n                ]},\n                {cmd: \"GET\", out: 0, var: 2, len: G.F.n8*3}\n            ];\n            opPromises.push(\n                G.tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            if (!G.isZero(res)) {\n                for (let j=0; j<bitChunkSize; j++) res = G.double(res);\n            }\n            res = G.add(res, result[i][0]);\n        }\n\n        return res;\n    }\n\n    async function _multiExp(buffBases, buffScalars, inType, logger, logText) {\n        const MAX_CHUNK_SIZE = 1 << 22;\n        const MIN_CHUNK_SIZE = 1 << 10;\n        let sGIn;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sGIn = G.F.n8*2;\n            } else {\n                sGIn = G.F.n8*3;\n            }\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buffBases.byteLength / sGIn);\n        if (nPoints == 0) return G.zero;\n        const sScalar = Math.floor(buffScalars.byteLength / nPoints);\n        if( sScalar * nPoints != buffScalars.byteLength) {\n            throw new Error(\"Scalar size does not match\");\n        }\n\n        const bitChunkSize = pTSizes[log2(nPoints)];\n        const nChunks = Math.floor((sScalar*8 - 1) / bitChunkSize) +1;\n\n        let chunkSize;\n        chunkSize = Math.floor(nPoints / (tm.concurrency /nChunks));\n        if (chunkSize>MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n        if (chunkSize<MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n\n        const opPromises = [];\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`Multiexp start: ${logText}: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n            const buffBasesChunk = buffBases.slice(i*sGIn, (i+n)*sGIn);\n            const buffScalarsChunk = buffScalars.slice(i*sScalar, (i+n)*sScalar);\n            opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then( (r) => {\n                if (logger) logger.debug(`Multiexp end: ${logText}: ${i}/${nPoints}`);\n                return r;\n            }));\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let res = G.zero;\n        for (let i=result.length-1; i>=0; i--) {\n            res = G.add(res, result[i]);\n        }\n\n        return res;\n    }\n\n    G.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"jacobian\", logger, logText);\n    };\n    G.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {\n        return await _multiExp(buffBases, buffScalars, \"affine\", logger, logText);\n    };\n}\n\nfunction buildFFT(curve, groupName) {\n    const G = curve[groupName];\n    const Fr = curve.Fr;\n    const tm = G.tm;\n    async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {\n\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n        const MAX_BITS_THREAD = 14;\n\n        let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g1m_fftFinal\";\n            }\n            fnFFTJoin = \"g1m_fftJoin\";\n            fnFFTMix = \"g1m_fftMix\";\n\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g1m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            if (inverse) {\n                fnFFTFinal = \"g2m_fftFinal\";\n            }\n            fnFFTJoin = \"g2m_fftJoin\";\n            fnFFTMix = \"g2m_fftMix\";\n            if (outType == \"affine\") {\n                sOut = G.F.n8*2;\n                fnMid2Out = \"g2m_batchToAffine\";\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = G.n8;\n            sMid = G.n8;\n            sOut = G.n8;\n            if (inverse) {\n                fnFFTFinal = \"frm_fftFinal\";\n            }\n            fnFFTMix = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        }\n\n\n        let returnArray = false;\n        if (Array.isArray(buff)) {\n            buff = array2buffer(buff, sIn);\n            returnArray = true;\n        } else {\n            buff = buff.slice(0, buff.byteLength);\n        }\n\n        const nPoints = buff.byteLength / sIn;\n        const bits = log2(nPoints);\n\n        if  ((1 << bits) != nPoints) {\n            throw new Error(\"fft must be multiple of 2\" );\n        }\n\n        if (bits == Fr.s +1) {\n            let buffOut;\n\n            if (inverse) {\n                buffOut =  await _fftExtInv(buff, inType, outType, logger, loggerTxt);\n            } else {\n                buffOut =  await _fftExt(buff, inType, outType, logger, loggerTxt);\n            }\n\n            if (returnArray) {\n                return buffer2array(buffOut, sOut);\n            } else {\n                return buffOut;\n            }\n        }\n\n        let inv;\n        if (inverse) {\n            inv = Fr.inv(Fr.e(nPoints));\n        }\n\n        let buffOut;\n\n        buffReverseBits(buff, sIn);\n\n        let chunks;\n        let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);\n        let nChunks = nPoints / pointsInChunk;\n\n        while ((nChunks < tm.concurrency)&&(pointsInChunk>=16)) {\n            nChunks *= 2;\n            pointsInChunk /= 2;\n        }\n\n        const l2Chunk = log2(pointsInChunk);\n\n        const promises = [];\n        for (let i = 0; i< nChunks; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix start: ${i}/${nChunks}`);\n            const task = [];\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*pointsInChunk});\n            const buffChunk = buff.slice( (pointsInChunk * i)*sIn, (pointsInChunk * (i+1))*sIn);\n            task.push({cmd: \"SET\", var: 0, buff: buffChunk});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n            }\n            for (let j=1; j<=l2Chunk;j++) {\n                task.push({cmd: \"CALL\", fnName:fnFFTMix, params: [{var:0}, {val: pointsInChunk}, {val: j}]});\n            }\n\n            if (l2Chunk==bits) {\n                if (fnFFTFinal) {\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: inv});\n                    task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                        {var: 0},\n                        {val: pointsInChunk},\n                        {var: 1},\n                    ]});\n                }\n                if (fnMid2Out) {\n                    task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                }\n                task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n            } else {\n                task.push({cmd: \"GET\", out:0, var: 0, len: sMid*pointsInChunk});\n            }\n            promises.push(tm.queueAction(task).then( (r) => {\n                if (logger) logger.debug(`${loggerTxt}: fft ${bits} mix end: ${i}/${nChunks}`);\n                return r;\n            }));\n        }\n\n        chunks = await Promise.all(promises);\n        for (let i = 0; i< nChunks; i++) chunks[i] = chunks[i][0];\n\n        for (let i = l2Chunk+1;   i<=bits; i++) {\n            if (logger) logger.debug(`${loggerTxt}: fft  ${bits}  join: ${i}/${bits}`);\n            const nGroups = 1 << (bits - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsInChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsInChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    if (i==bits) {\n                        if (fnFFTFinal) {\n                            task.push({cmd: \"ALLOCSET\", var: 4, buff: inv});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 0},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                            task.push({cmd: \"CALL\", fnName: fnFFTFinal,  params:[\n                                {var: 1},\n                                {val: pointsInChunk},\n                                {var: 4},\n                            ]});\n                        }\n                        if (fnMid2Out) {\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: pointsInChunk}, {var: 0}]});\n                            task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: pointsInChunk}, {var: 1}]});\n                        }\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sOut});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sOut});\n                    } else {\n                        task.push({cmd: \"GET\", out: 0, var: 0, len: pointsInChunk*sMid});\n                        task.push({cmd: \"GET\", out: 1, var: 1, len: pointsInChunk*sMid});\n                    }\n                    opPromises.push(tm.queueAction(task).then( (r) => {\n                        if (logger) logger.debug(`${loggerTxt}: fft ${bits} join  ${i}/${bits}  ${j+1}/${nGroups} ${k}/${nChunksPerGroup/2}`);\n                        return r;\n                    }));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        if (buff instanceof BigBuffer) {\n            buffOut = new BigBuffer(nPoints*sOut);\n        } else {\n            buffOut = new Uint8Array(nPoints*sOut);\n        }\n        if (inverse) {\n            buffOut.set(chunks[0].slice((pointsInChunk-1)*sOut));\n            let p= sOut;\n            for (let i=nChunks-1; i>0; i--) {\n                buffOut.set(chunks[i], p);\n                p += pointsInChunk*sOut;\n                delete chunks[i];  // Liberate mem\n            }\n            buffOut.set(chunks[0].slice(0, (pointsInChunk-1)*sOut), p);\n            delete chunks[0];\n        } else {\n            for (let i=0; i<nChunks; i++) {\n                buffOut.set(chunks[i], pointsInChunk*sOut*i);\n                delete chunks[i];\n            }\n        }\n\n        if (returnArray) {\n            return buffer2array(buffOut, sOut);\n        } else {\n            return buffOut;\n        }\n    }\n\n    async function _fftExt(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        [b1, b2] = await _fftJoinExt(b1, b2, \"fftJoinExt\", Fr.one, Fr.shift, inType, \"jacobian\", logger, loggerTxt);\n\n        promises.push( _fft(b1, false, \"jacobian\", outType, logger, loggerTxt));\n        promises.push( _fft(b2, false, \"jacobian\", outType, logger, loggerTxt));\n\n        const res1 = await Promise.all(promises);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n    async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {\n        let b1, b2;\n        b1 = buff.slice( 0 , buff.byteLength/2);\n        b2 = buff.slice( buff.byteLength/2, buff.byteLength);\n\n        const promises = [];\n\n        promises.push( _fft(b1, true, inType, \"jacobian\", logger, loggerTxt));\n        promises.push( _fft(b2, true, inType, \"jacobian\", logger, loggerTxt));\n\n        [b1, b2] = await Promise.all(promises);\n\n        const res1 = await _fftJoinExt(b1, b2, \"fftJoinExtInv\", Fr.one, Fr.shiftInv, \"jacobian\", outType, logger, loggerTxt);\n\n        let buffOut;\n        if (res1[0].byteLength > (1<<28)) {\n            buffOut = new BigBuffer(res1[0].byteLength*2);\n        } else {\n            buffOut = new Uint8Array(res1[0].byteLength*2);\n        }\n\n        buffOut.set(res1[0]);\n        buffOut.set(res1[1], res1[0].byteLength);\n\n        return buffOut;\n    }\n\n\n    async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const MIN_CHUNK_SIZE = 1<<4;\n\n        let fnName;\n        let fnIn2Mid, fnMid2Out;\n        let sOut, sIn, sMid;\n\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g1m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            sMid = G.F.n8*3;\n            fnName = \"g1m_\"+fn;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g1m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n                fnIn2Mid = \"g2m_batchToJacobian\";\n            } else {\n                sIn = G.F.n8*3;\n            }\n            fnName = \"g2m_\"+fn;\n            sMid = G.F.n8*3;\n            if (outType == \"affine\") {\n                fnMid2Out = \"g2m_batchToAffine\";\n                sOut = G.F.n8*2;\n            } else {\n                sOut = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n            sOut = Fr.n8;\n            sMid = Fr.n8;\n            fnName = \"frm_\" + fn;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sIn);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let chunkSize = Math.floor(nPoints /tm.concurrency);\n        if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;\n        if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;\n\n        const opPromises = [];\n\n        for (let i=0; i<nPoints; i += chunkSize) {\n            if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i}/${nPoints}`);\n            const n= Math.min(nPoints - i, chunkSize);\n\n            const firstChunk = Fr.mul(first, Fr.exp( inc, i));\n            const task = [];\n\n            const b1 = buff1.slice(i*sIn, (i+n)*sIn);\n            const b2 = buff2.slice(i*sIn, (i+n)*sIn);\n\n            task.push({cmd: \"ALLOC\", var: 0, len: sMid*n});\n            task.push({cmd: \"SET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOC\", var: 1, len: sMid*n});\n            task.push({cmd: \"SET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            if (fnIn2Mid) {\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnIn2Mid, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: n},\n                {var: 2},\n                {var: 3},\n                {val: Fr.s},\n            ]});\n            if (fnMid2Out) {\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:0}, {val: n}, {var: 0}]});\n                task.push({cmd: \"CALL\", fnName:fnMid2Out, params: [{var:1}, {val: n}, {var: 1}]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sOut});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: n*sOut});\n            opPromises.push(\n                tm.queueAction(task).then( (r) => {\n                    if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i}/${nPoints}`);\n                    return r;\n                })\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (nPoints * sOut > 1<<28) {\n            fullBuffOut1 = new BigBuffer(nPoints*sOut);\n            fullBuffOut2 = new BigBuffer(nPoints*sOut);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sOut);\n            fullBuffOut2 = new Uint8Array(nPoints*sOut);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    }\n\n\n    G.fft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, false, inType, outType, logger, loggerTxt);\n    };\n\n    G.ifft = async function(buff, inType, outType, logger, loggerTxt) {\n        return await _fft(buff, true, inType, outType, logger, loggerTxt);\n    };\n\n    G.lagrangeEvaluations = async function (buff, inType, outType, logger, loggerTxt) {\n        inType = inType || \"affine\";\n        outType = outType || \"affine\";\n\n        let sIn;\n        if (groupName == \"G1\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"G2\") {\n            if (inType == \"affine\") {\n                sIn = G.F.n8*2;\n            } else {\n                sIn = G.F.n8*3;\n            }\n        } else if (groupName == \"Fr\") {\n            sIn = Fr.n8;\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = buff.byteLength /sIn;\n        const bits = log2(nPoints);\n\n        if ((2 ** bits)*sIn != buff.byteLength) {\n            if (logger) logger.error(\"lagrangeEvaluations iinvalid input size\");\n            throw new Error(\"lagrangeEvaluations invalid Input size\");\n        }\n\n        if (bits <= Fr.s) {\n            return await G.ifft(buff, inType, outType, logger, loggerTxt);\n        }\n\n        if (bits > Fr.s+1) {\n            if (logger) logger.error(\"lagrangeEvaluations input too big\");\n            throw new Error(\"lagrangeEvaluations input too big\");\n        }\n\n        let t0 = buff.slice(0, buff.byteLength/2);\n        let t1 = buff.slice(buff.byteLength/2, buff.byteLength);\n\n\n        const shiftToSmallM = Fr.exp(Fr.shift, nPoints/2);\n        const sConst = Fr.inv( Fr.sub(Fr.one, shiftToSmallM));\n\n        [t0, t1] = await _fftJoinExt(t0, t1, \"prepareLagrangeEvaluation\", sConst, Fr.shiftInv, inType, \"jacobian\", logger, loggerTxt + \" prep\");\n\n        const promises = [];\n\n        promises.push( _fft(t0, true, \"jacobian\", outType, logger, loggerTxt + \" t0\"));\n        promises.push( _fft(t1, true, \"jacobian\", outType, logger, loggerTxt + \" t1\"));\n\n        [t0, t1] = await Promise.all(promises);\n\n        let buffOut;\n        if (t0.byteLength > (1<<28)) {\n            buffOut = new BigBuffer(t0.byteLength*2);\n        } else {\n            buffOut = new Uint8Array(t0.byteLength*2);\n        }\n\n        buffOut.set(t0);\n        buffOut.set(t1, t0.byteLength);\n\n        return buffOut;\n    };\n\n    G.fftMix = async function fftMix(buff) {\n        const sG = G.F.n8*3;\n        let fnName, fnFFTJoin;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftMix\";\n            fnFFTJoin = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftMix\";\n            fnFFTJoin = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftMix\";\n            fnFFTJoin = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        const power = log2(nPoints);\n\n        let nChunks = 1 << log2(tm.concurrency);\n\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n        const powerChunk = log2(pointsPerChunk);\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            for (let j=1; j<=powerChunk; j++) {\n                task.push({cmd: \"CALL\", fnName: fnName, params: [\n                    {var: 0},\n                    {val: pointsPerChunk},\n                    {val: j}\n                ]});\n            }\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n        }\n\n        const result = await Promise.all(opPromises);\n\n        const chunks = [];\n        for (let i=0; i<result.length; i++) chunks[i] = result[i][0];\n\n\n        for (let i = powerChunk+1; i<=power; i++) {\n            const nGroups = 1 << (power - i);\n            const nChunksPerGroup = nChunks / nGroups;\n            const opPromises = [];\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const first = Fr.exp( Fr.w[i], k*pointsPerChunk);\n                    const inc = Fr.w[i];\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n\n                    const task = [];\n                    task.push({cmd: \"ALLOCSET\", var: 0, buff: chunks[o1]});\n                    task.push({cmd: \"ALLOCSET\", var: 1, buff: chunks[o2]});\n                    task.push({cmd: \"ALLOCSET\", var: 2, buff: first});\n                    task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n                    task.push({cmd: \"CALL\", fnName: fnFFTJoin,  params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: pointsPerChunk},\n                        {var: 2},\n                        {var: 3}\n                    ]});\n                    task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n                    task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n                    opPromises.push(tm.queueAction(task));\n                }\n            }\n\n            const res = await Promise.all(opPromises);\n            for (let j=0; j<nGroups; j++) {\n                for (let k=0; k <nChunksPerGroup/2; k++) {\n                    const o1 = j*nChunksPerGroup + k;\n                    const o2 = j*nChunksPerGroup + k + nChunksPerGroup/2;\n                    const resChunk = res.shift();\n                    chunks[o1] = resChunk[0];\n                    chunks[o2] = resChunk[1];\n                }\n            }\n        }\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sG);\n        }\n        let p =0;\n        for (let i=0; i<nChunks; i++) {\n            fullBuffOut.set(chunks[i], p);\n            p+=chunks[i].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n\n    G.fftJoin = async function fftJoin(buff1, buff2, first, inc) {\n        const sG = G.F.n8*3;\n        let fnName;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftJoin\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftJoin\";\n        } else if (groupName == \"Fr\") {\n            fnName = \"frm_fftJoin\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        if (buff1.byteLength != buff2.byteLength) {\n            throw new Error(\"Invalid buffer size\");\n        }\n        const nPoints = Math.floor(buff1.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        let nChunks = 1 << log2(tm.concurrency);\n        if (nPoints <= nChunks*2) nChunks = 1;\n\n        const pointsPerChunk = nPoints / nChunks;\n\n\n        const opPromises = [];\n        for (let i=0; i<nChunks; i++) {\n            const task = [];\n\n            const firstChunk = Fr.mul(first, Fr.exp(inc, i*pointsPerChunk));\n            const b1 = buff1.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            const b2 = buff2.slice((i* pointsPerChunk)*sG, ((i+1)* pointsPerChunk)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b1});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: b2});\n            task.push({cmd: \"ALLOCSET\", var: 2, buff: firstChunk});\n            task.push({cmd: \"ALLOCSET\", var: 3, buff: inc});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {var: 1},\n                {val: pointsPerChunk},\n                {var: 2},\n                {var: 3}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: pointsPerChunk*sG});\n            task.push({cmd: \"GET\", out: 1, var: 1, len: pointsPerChunk*sG});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut1;\n        let fullBuffOut2;\n        if (buff1 instanceof BigBuffer) {\n            fullBuffOut1 = new BigBuffer(nPoints*sG);\n            fullBuffOut2 = new BigBuffer(nPoints*sG);\n        } else {\n            fullBuffOut1 = new Uint8Array(nPoints*sG);\n            fullBuffOut2 = new Uint8Array(nPoints*sG);\n        }\n\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut1.set(result[i][0], p);\n            fullBuffOut2.set(result[i][1], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return [fullBuffOut1, fullBuffOut2];\n    };\n\n\n\n    G.fftFinal =  async function fftFinal(buff, factor) {\n        const sG = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnName, fnToAffine;\n        if (groupName == \"G1\") {\n            fnName = \"g1m_fftFinal\";\n            fnToAffine = \"g1m_batchToAffine\";\n        } else if (groupName == \"G2\") {\n            fnName = \"g2m_fftFinal\";\n            fnToAffine = \"g2m_batchToAffine\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n\n        const nPoints = Math.floor(buff.byteLength / sG);\n        if (nPoints != 1 << log2(nPoints)) {\n            throw new Error(\"Invalid number of points\");\n        }\n\n        const pointsPerChunk = Math.floor(nPoints / tm.concurrency);\n\n        const opPromises = [];\n        for (let i=0; i<tm.concurrency; i++) {\n            let n;\n            if (i< tm.concurrency-1) {\n                n = pointsPerChunk;\n            } else {\n                n = nPoints - i*pointsPerChunk;\n            }\n            if (n==0) continue;\n            const task = [];\n            const b = buff.slice((i* pointsPerChunk)*sG, (i*pointsPerChunk+n)*sG);\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: b});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: factor});\n            task.push({cmd: \"CALL\", fnName: fnName, params: [\n                {var: 0},\n                {val: n},\n                {var: 1},\n            ]});\n            task.push({cmd: \"CALL\", fnName: fnToAffine, params: [\n                {var: 0},\n                {val: n},\n                {var: 0},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 0, len: n*sGout});\n            opPromises.push(\n                tm.queueAction(task)\n            );\n\n        }\n\n        const result = await Promise.all(opPromises);\n\n        let fullBuffOut;\n        if (buff instanceof BigBuffer) {\n            fullBuffOut = new BigBuffer(nPoints*sGout);\n        } else {\n            fullBuffOut = new Uint8Array(nPoints*sGout);\n        }\n\n        let p =0;\n        for (let i=result.length-1; i>=0; i--) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    };\n}\n\nasync function buildEngine(params) {\n\n    const tm = await buildThreadManager(params.wasm, params.singleThread);\n\n\n    const curve = {};\n\n    curve.q = e(params.wasm.q.toString());\n    curve.r = e(params.wasm.r.toString());\n    curve.name = params.name;\n    curve.tm = tm;\n    curve.prePSize = params.wasm.prePSize;\n    curve.preQSize = params.wasm.preQSize;\n    curve.Fr = new WasmField1(tm, \"frm\", params.n8r, params.r);\n    curve.F1 = new WasmField1(tm, \"f1m\", params.n8q, params.q);\n    curve.F2 = new WasmField2(tm, \"f2m\", curve.F1);\n    curve.G1 = new WasmCurve(tm, \"g1m\", curve.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);\n    curve.G2 = new WasmCurve(tm, \"g2m\", curve.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);\n    curve.F6 = new WasmField3(tm, \"f6m\", curve.F2);\n    curve.F12 = new WasmField2(tm, \"ftm\", curve.F6);\n\n    curve.Gt = curve.F12;\n\n    buildBatchApplyKey(curve, \"G1\");\n    buildBatchApplyKey(curve, \"G2\");\n    buildBatchApplyKey(curve, \"Fr\");\n\n    buildMultiexp(curve, \"G1\");\n    buildMultiexp(curve, \"G2\");\n\n    buildFFT(curve, \"G1\");\n    buildFFT(curve, \"G2\");\n    buildFFT(curve, \"Fr\");\n\n    buildPairing(curve);\n\n    curve.array2buffer = function(arr, sG) {\n        const buff = new Uint8Array(sG*arr.length);\n\n        for (let i=0; i<arr.length; i++) {\n            buff.set(arr[i], i*sG);\n        }\n\n        return buff;\n    };\n\n    curve.buffer2array = function(buff , sG) {\n        const n= buff.byteLength / sG;\n        const arr = new Array(n);\n        for (let i=0; i<n; i++) {\n            arr[i] = buff.slice(i*sG, i*sG+sG);\n        }\n        return arr;\n    };\n\n    return curve;\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nfunction toNumber(n) {\n    return BigInt(n);\n}\n\nfunction isNegative(n) {\n    return n < 0n;\n}\n\nfunction isZero(n) {\n    return n === 0n;\n}\n\nfunction bitLength(n) {\n    if (isNegative(n)) {\n        return n.toString(2).length - 1; // discard the - sign\n    } else {\n        return n.toString(2).length;\n    }\n}\n\nfunction u32(n) {\n    const b = [];\n    const v = toNumber(n);\n    b.push(Number(v & 0xFFn));\n    b.push(Number(v >> 8n & 0xFFn));\n    b.push(Number(v >> 16n & 0xFFn));\n    b.push(Number(v >> 24n & 0xFFn));\n    return b;\n}\n\nfunction toUTF8Array(str) {\n    var utf8 = [];\n    for (var i=0; i < str.length; i++) {\n        var charcode = str.charCodeAt(i);\n        if (charcode < 0x80) utf8.push(charcode);\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6),\n                0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12),\n                0x80 | ((charcode>>6) & 0x3f),\n                0x80 | (charcode & 0x3f));\n        }\n        // surrogate pair\n        else {\n            i++;\n            // UTF-16 encodes 0x10000-0x10FFFF by\n            // subtracting 0x10000 and splitting the\n            // 20 bits of 0x0-0xFFFFF into two halves\n            charcode = 0x10000 + (((charcode & 0x3ff)<<10)\n                      | (str.charCodeAt(i) & 0x3ff));\n            utf8.push(0xf0 | (charcode >>18),\n                0x80 | ((charcode>>12) & 0x3f),\n                0x80 | ((charcode>>6) & 0x3f),\n                0x80 | (charcode & 0x3f));\n        }\n    }\n    return utf8;\n}\n\nfunction string(str) {\n    const bytes = toUTF8Array(str);\n    return [ ...varuint32(bytes.length), ...bytes ];\n}\n\nfunction varuint(n) {\n    const code = [];\n    let v = toNumber(n);\n    if (isNegative(v)) throw new Error(\"Number cannot be negative\");\n    while (!isZero(v)) {\n        code.push(Number(v & 0x7Fn));\n        v = v >> 7n;\n    }\n    if (code.length==0) code.push(0);\n    for (let i=0; i<code.length-1; i++) {\n        code[i] = code[i] | 0x80;\n    }\n    return code;\n}\n\nfunction varint(_n) {\n    let n, sign;\n    const bits = bitLength(_n);\n    if (_n<0) {\n        sign = true;\n        n = (1n << BigInt(bits)) + _n;\n    } else {\n        sign = false;\n        n = toNumber(_n);\n    }\n    const paddingBits = 7 - (bits % 7);\n\n    const padding = ((1n << BigInt(paddingBits)) - 1n) << BigInt(bits);\n    const paddingMask = ((1 << (7 - paddingBits))-1) | 0x80;\n\n    const code = varuint(n + padding);\n\n    if (!sign) {\n        code[code.length-1] = code[code.length-1] & paddingMask;\n    }\n\n    return code;\n}\n\nfunction varint32(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFn) throw new Error(\"Number too big\");\n    if (v > 0x7FFFFFFFn) v = v - 0x100000000n;\n    // bigInt(\"-80000000\", 16) as base10\n    if (v < -2147483648n) throw new Error(\"Number too small\");\n    return varint(v);\n}\n\nfunction varint64(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFFFFFFFFFn) throw new Error(\"Number too big\");\n    if (v > 0x7FFFFFFFFFFFFFFFn) v = v - 0x10000000000000000n;\n    // bigInt(\"-8000000000000000\", 16) as base10\n    if (v < -9223372036854775808n) throw new Error(\"Number too small\");\n    return varint(v);\n}\n\nfunction varuint32(n) {\n    let v = toNumber(n);\n    if (v > 0xFFFFFFFFn) throw new Error(\"Number too big\");\n    return varuint(v);\n}\n\nfunction toHexString(byteArray) {\n    return Array.from(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nclass CodeBuilder {\n    constructor(func) {\n        this.func = func;\n        this.functionName = func.functionName;\n        this.module = func.module;\n    }\n\n    setLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [...valCode, 0x21, ...varuint32( idx )];\n    }\n\n    teeLocal(localName, valCode) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [...valCode, 0x22, ...varuint32( idx )];\n    }\n\n    getLocal(localName) {\n        const idx = this.func.localIdxByName[localName];\n        if (idx === undefined)\n            throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);\n        return [0x20, ...varuint32( idx )];\n    }\n\n    i64_load8_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 8 bits alignment by default\n        return [...idxCode, 0x30, align, ...varuint32(offset)];\n    }\n\n    i64_load8_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 8 bits alignment by default\n        return [...idxCode, 0x31, align, ...varuint32(offset)];\n    }\n\n    i64_load16_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 16 bits alignment by default\n        return [...idxCode, 0x32, align, ...varuint32(offset)];\n    }\n\n    i64_load16_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 16 bits alignment by default\n        return [...idxCode, 0x33, align, ...varuint32(offset)];\n    }\n\n    i64_load32_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x34, align, ...varuint32(offset)];\n    }\n\n    i64_load32_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x35, align, ...varuint32(offset)];\n    }\n\n    i64_load(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 3 : _align;  // 64 bits alignment by default\n        return [...idxCode, 0x29, align, ...varuint32(offset)];\n    }\n\n\n    i64_store(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 3;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 3;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x37, align, ...varuint32(offset)];\n    }\n\n    i64_store32(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 2;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 2;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3e, align, ...varuint32(offset)];\n    }\n\n\n    i64_store16(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 1;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 1;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3d, align, ...varuint32(offset)];\n    }\n\n\n    i64_store8(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 0;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 0;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3c, align, ...varuint32(offset)];\n    }\n\n    i32_load8_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2c, align, ...varuint32(offset)];\n    }\n\n    i32_load8_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 0 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2d, align, ...varuint32(offset)];\n    }\n\n    i32_load16_s(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2e, align, ...varuint32(offset)];\n    }\n\n    i32_load16_u(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 1 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x2f, align, ...varuint32(offset)];\n    }\n\n    i32_load(idxCode, _offset, _align) {\n        const offset = _offset || 0;\n        const align = (_align === undefined) ? 2 : _align;  // 32 bits alignment by default\n        return [...idxCode, 0x28, align, ...varuint32(offset)];\n    }\n\n    i32_store(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 2;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 2;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x36, align, ...varuint32(offset)];\n    }\n\n\n    i32_store16(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 1;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 1;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3b, align, ...varuint32(offset)];\n    }\n\n    i32_store8(idxCode, _offset, _align, _codeVal) {\n        let offset, align, codeVal;\n        if (Array.isArray(_offset)) {\n            offset = 0;\n            align = 0;\n            codeVal = _offset;\n        } else if (Array.isArray(_align)) {\n            offset = _offset;\n            align = 0;\n            codeVal = _align;\n        } else if (Array.isArray(_codeVal)) {\n            offset = _offset;\n            align = _align;\n            codeVal = _codeVal;\n        }\n        return [...idxCode, ...codeVal, 0x3a, align, ...varuint32(offset)];\n    }\n\n    call(fnName, ...args) {\n        const idx = this.module.functionIdxByName[fnName];\n        if (idx === undefined)\n            throw new Error(`Function not defined: Function: ${fnName}`);\n        return [...[].concat(...args), 0x10, ...varuint32(idx)];\n    }\n\n    call_indirect(fnIdx, ...args) {\n        return [...[].concat(...args), ...fnIdx, 0x11, 0, 0];\n    }\n\n    if(condCode, thenCode, elseCode) {\n        if (elseCode) {\n            return [...condCode, 0x04, 0x40, ...thenCode, 0x05, ...elseCode, 0x0b];\n        } else {\n            return [...condCode, 0x04, 0x40, ...thenCode, 0x0b];\n        }\n    }\n\n    block(bCode) { return [0x02, 0x40, ...bCode, 0x0b]; }\n    loop(...args) {\n        return [0x03, 0x40, ...[].concat(...[...args]), 0x0b];\n    }\n    br_if(relPath, condCode) { return [...condCode, 0x0d, ...varuint32(relPath)]; }\n    br(relPath) { return [0x0c, ...varuint32(relPath)]; }\n    ret(rCode) { return [...rCode, 0x0f]; }\n    drop(dCode) { return [...dCode,  0x1a]; }\n\n    i64_const(num) { return [0x42, ...varint64(num)]; }\n    i32_const(num) { return [0x41, ...varint32(num)]; }\n\n\n    i64_eqz(opcode) { return [...opcode, 0x50]; }\n    i64_eq(op1code, op2code) { return [...op1code, ...op2code, 0x51]; }\n    i64_ne(op1code, op2code) { return [...op1code, ...op2code, 0x52]; }\n    i64_lt_s(op1code, op2code) { return [...op1code, ...op2code, 0x53]; }\n    i64_lt_u(op1code, op2code) { return [...op1code, ...op2code, 0x54]; }\n    i64_gt_s(op1code, op2code) { return [...op1code, ...op2code, 0x55]; }\n    i64_gt_u(op1code, op2code) { return [...op1code, ...op2code, 0x56]; }\n    i64_le_s(op1code, op2code) { return [...op1code, ...op2code, 0x57]; }\n    i64_le_u(op1code, op2code) { return [...op1code, ...op2code, 0x58]; }\n    i64_ge_s(op1code, op2code) { return [...op1code, ...op2code, 0x59]; }\n    i64_ge_u(op1code, op2code) { return [...op1code, ...op2code, 0x5a]; }\n    i64_add(op1code, op2code) { return [...op1code, ...op2code, 0x7c]; }\n    i64_sub(op1code, op2code) { return [...op1code, ...op2code, 0x7d]; }\n    i64_mul(op1code, op2code) { return [...op1code, ...op2code, 0x7e]; }\n    i64_div_s(op1code, op2code) { return [...op1code, ...op2code, 0x7f]; }\n    i64_div_u(op1code, op2code) { return [...op1code, ...op2code, 0x80]; }\n    i64_rem_s(op1code, op2code) { return [...op1code, ...op2code, 0x81]; }\n    i64_rem_u(op1code, op2code) { return [...op1code, ...op2code, 0x82]; }\n    i64_and(op1code, op2code) { return [...op1code, ...op2code, 0x83]; }\n    i64_or(op1code, op2code) { return [...op1code, ...op2code, 0x84]; }\n    i64_xor(op1code, op2code) { return [...op1code, ...op2code, 0x85]; }\n    i64_shl(op1code, op2code) { return [...op1code, ...op2code, 0x86]; }\n    i64_shr_s(op1code, op2code) { return [...op1code, ...op2code, 0x87]; }\n    i64_shr_u(op1code, op2code) { return [...op1code, ...op2code, 0x88]; }\n    i64_extend_i32_s(op1code) { return [...op1code, 0xac]; }\n    i64_extend_i32_u(op1code) { return [...op1code, 0xad]; }\n    i64_clz(op1code) { return [...op1code, 0x79]; }\n    i64_ctz(op1code) { return [...op1code, 0x7a]; }\n\n    i32_eqz(op1code) { return [...op1code, 0x45]; }\n    i32_eq(op1code, op2code) { return [...op1code, ...op2code, 0x46]; }\n    i32_ne(op1code, op2code) { return [...op1code, ...op2code, 0x47]; }\n    i32_lt_s(op1code, op2code) { return [...op1code, ...op2code, 0x48]; }\n    i32_lt_u(op1code, op2code) { return [...op1code, ...op2code, 0x49]; }\n    i32_gt_s(op1code, op2code) { return [...op1code, ...op2code, 0x4a]; }\n    i32_gt_u(op1code, op2code) { return [...op1code, ...op2code, 0x4b]; }\n    i32_le_s(op1code, op2code) { return [...op1code, ...op2code, 0x4c]; }\n    i32_le_u(op1code, op2code) { return [...op1code, ...op2code, 0x4d]; }\n    i32_ge_s(op1code, op2code) { return [...op1code, ...op2code, 0x4e]; }\n    i32_ge_u(op1code, op2code) { return [...op1code, ...op2code, 0x4f]; }\n    i32_add(op1code, op2code) { return [...op1code, ...op2code, 0x6a]; }\n    i32_sub(op1code, op2code) { return [...op1code, ...op2code, 0x6b]; }\n    i32_mul(op1code, op2code) { return [...op1code, ...op2code, 0x6c]; }\n    i32_div_s(op1code, op2code) { return [...op1code, ...op2code, 0x6d]; }\n    i32_div_u(op1code, op2code) { return [...op1code, ...op2code, 0x6e]; }\n    i32_rem_s(op1code, op2code) { return [...op1code, ...op2code, 0x6f]; }\n    i32_rem_u(op1code, op2code) { return [...op1code, ...op2code, 0x70]; }\n    i32_and(op1code, op2code) { return [...op1code, ...op2code, 0x71]; }\n    i32_or(op1code, op2code) { return [...op1code, ...op2code, 0x72]; }\n    i32_xor(op1code, op2code) { return [...op1code, ...op2code, 0x73]; }\n    i32_shl(op1code, op2code) { return [...op1code, ...op2code, 0x74]; }\n    i32_shr_s(op1code, op2code) { return [...op1code, ...op2code, 0x75]; }\n    i32_shr_u(op1code, op2code) { return [...op1code, ...op2code, 0x76]; }\n    i32_rotl(op1code, op2code) { return [...op1code, ...op2code, 0x77]; }\n    i32_rotr(op1code, op2code) { return [...op1code, ...op2code, 0x78]; }\n    i32_wrap_i64(op1code) { return [...op1code, 0xa7]; }\n    i32_clz(op1code) { return [...op1code, 0x67]; }\n    i32_ctz(op1code) { return [...op1code, 0x68]; }\n\n    unreachable() { return [ 0x0 ]; }\n\n    current_memory() { return [ 0x3f, 0]; }\n\n    comment() { return []; }\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nconst typeCodes = {\n    \"i32\": 0x7f,\n    \"i64\": 0x7e,\n    \"f32\": 0x7d,\n    \"f64\": 0x7c,\n    \"anyfunc\": 0x70,\n    \"func\": 0x60,\n    \"emptyblock\": 0x40\n};\n\n\nclass FunctionBuilder {\n\n    constructor (module, fnName, fnType, moduleName, fieldName) {\n        if (fnType == \"import\") {\n            this.fnType = \"import\";\n            this.moduleName = moduleName;\n            this.fieldName = fieldName;\n        } else if (fnType == \"internal\") {\n            this.fnType = \"internal\";\n        } else {\n            throw new Error(\"Invalid function fnType: \" + fnType);\n        }\n        this.module = module;\n        this.fnName = fnName;\n        this.params = [];\n        this.locals = [];\n        this.localIdxByName = {};\n        this.code = [];\n        this.returnType = null;\n        this.nextLocal =0;\n    }\n\n    addParam(paramName, paramType) {\n        if (this.localIdxByName[paramName])\n            throw new Error(`param already exists. Function: ${this.fnName}, Param: ${paramName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[paramName] = idx;\n        this.params.push({\n            type: paramType\n        });\n    }\n\n    addLocal(localName, localType, _length) {\n        const length = _length || 1;\n        if (this.localIdxByName[localName])\n            throw new Error(`local already exists. Function: ${this.fnName}, Param: ${localName} `);\n        const idx = this.nextLocal++;\n        this.localIdxByName[localName] = idx;\n        this.locals.push({\n            type: localType,\n            length: length\n        });\n    }\n\n    setReturnType(returnType) {\n        if (this.returnType)\n            throw new Error(`returnType already defined. Function: ${this.fnName}`);\n        this.returnType = returnType;\n    }\n\n    getSignature() {\n        const params = [...varuint32(this.params.length), ...this.params.map((p) => typeCodes[p.type])];\n        const returns = this.returnType ? [0x01, typeCodes[this.returnType]] : [0];\n        return [0x60, ...params, ...returns];\n    }\n\n    getBody() {\n        const locals = this.locals.map((l) => [\n            ...varuint32(l.length),\n            typeCodes[l.type]\n        ]);\n\n        const body = [\n            ...varuint32(this.locals.length),\n            ...[].concat(...locals),\n            ...this.code,\n            0x0b\n        ];\n        return [\n            ...varuint32(body.length),\n            ...body\n        ];\n    }\n\n    addCode(...code) {\n        this.code.push(...[].concat(...[...code]));\n    }\n\n    getCodeBuilder() {\n        return new CodeBuilder(this);\n    }\n}\n\n/*\n    Copyright 2019 0KIMS association.\n\n    This file is part of wasmbuilder\n\n    wasmbuilder is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    wasmbuilder is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with wasmbuilder. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\nclass ModuleBuilder {\n\n    constructor() {\n        this.functions = [];\n        this.functionIdxByName = {};\n        this.nImportFunctions = 0;\n        this.nInternalFunctions =0;\n        this.memory = {\n            pagesSize: 1,\n            moduleName: \"env\",\n            fieldName: \"memory\"\n        };\n        this.free = 8;\n        this.datas = [];\n        this.modules = {};\n        this.exports = [];\n        this.functionsTable = [];\n    }\n\n    build() {\n        this._setSignatures();\n        return new Uint8Array([\n            ...u32(0x6d736100),\n            ...u32(1),\n            ...this._buildType(),\n            ...this._buildImport(),\n            ...this._buildFunctionDeclarations(),\n            ...this._buildFunctionsTable(),\n            ...this._buildExports(),\n            ...this._buildElements(),\n            ...this._buildCode(),\n            ...this._buildData()\n        ]);\n    }\n\n    addFunction(fnName) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilder(this, fnName, \"internal\"));\n\n        this.nInternalFunctions++;\n        return this.functions[idx];\n    }\n\n    addIimportFunction(fnName, moduleName, _fieldName) {\n        if (typeof(this.functionIdxByName[fnName]) !== \"undefined\")\n            throw new Error(`Function already defined: ${fnName}`);\n\n        if (  (this.functions.length>0)\n            &&(this.functions[this.functions.length-1].type == \"internal\"))\n            throw new Error(`Import functions must be declared before internal: ${fnName}`);\n\n        let fieldName = _fieldName || fnName;\n\n        const idx = this.functions.length;\n        this.functionIdxByName[fnName] = idx;\n\n        this.functions.push(new FunctionBuilder(this, fnName, \"import\", moduleName, fieldName));\n\n        this.nImportFunctions ++;\n        return this.functions[idx];\n    }\n\n    setMemory(pagesSize, moduleName, fieldName) {\n        this.memory = {\n            pagesSize: pagesSize,\n            moduleName: moduleName || \"env\",\n            fieldName: fieldName || \"memory\"\n        };\n    }\n\n    exportFunction(fnName, _exportName) {\n        const exportName = _exportName || fnName;\n        if (typeof(this.functionIdxByName[fnName]) === \"undefined\")\n            throw new Error(`Function not defined: ${fnName}`);\n        const idx = this.functionIdxByName[fnName];\n        if (exportName != fnName) {\n            this.functionIdxByName[exportName] = idx;\n        }\n        this.exports.push({\n            exportName: exportName,\n            idx: idx\n        });\n    }\n\n    addFunctionToTable(fnName) {\n        const idx = this.functionIdxByName[fnName];\n        this.functionsTable.push(idx);\n    }\n\n    addData(offset, bytes) {\n        this.datas.push({\n            offset: offset,\n            bytes: bytes\n        });\n    }\n\n    alloc(a, b) {\n        let size;\n        let bytes;\n        if ((Array.isArray(a) || ArrayBuffer.isView(a)) && (typeof(b) === \"undefined\")) {\n            size = a.length;\n            bytes = a;\n        } else {\n            size = a;\n            bytes = b;\n        }\n        size = (((size-1)>>3) +1)<<3;       // Align to 64 bits.\n        const p = this.free;\n        this.free += size;\n        if (bytes) {\n            this.addData(p, bytes);\n        }\n        return p;\n    }\n\n    allocString(s) {\n        const encoder = new globalThis.TextEncoder();\n        const uint8array = encoder.encode(s);\n        return this.alloc([...uint8array, 0]);\n    }\n\n    _setSignatures() {\n        this.signatures = [];\n        const signatureIdxByName = {};\n        if (this.functionsTable.length>0) {\n            const signature = this.functions[this.functionsTable[0]].getSignature();\n            const signatureName = \"s_\"+toHexString(signature);\n            signatureIdxByName[signatureName] = 0;\n            this.signatures.push(signature);\n        }\n        for (let i=0; i<this.functions.length; i++) {\n            const signature = this.functions[i].getSignature();\n            const signatureName = \"s_\"+toHexString(signature);\n            if (typeof(signatureIdxByName[signatureName]) === \"undefined\") {\n                signatureIdxByName[signatureName] = this.signatures.length;\n                this.signatures.push(signature);\n            }\n\n            this.functions[i].signatureIdx = signatureIdxByName[signatureName];\n        }\n\n    }\n\n    _buildSection(sectionType, section) {\n        return [sectionType, ...varuint32(section.length), ...section];\n    }\n\n    _buildType() {\n        return this._buildSection(\n            0x01,\n            [\n                ...varuint32(this.signatures.length),\n                ...[].concat(...this.signatures)\n            ]\n        );\n    }\n\n    _buildImport() {\n        const entries = [];\n        entries.push([\n            ...string(this.memory.moduleName),\n            ...string(this.memory.fieldName),\n            0x02,\n            0x00,   //Flags no init valua\n            ...varuint32(this.memory.pagesSize)\n        ]);\n        for (let i=0; i< this.nImportFunctions; i++) {\n            entries.push([\n                ...string(this.functions[i].moduleName),\n                ...string(this.functions[i].fieldName),\n                0x00,\n                ...varuint32(this.functions[i].signatureIdx)\n            ]);\n        }\n        return this._buildSection(\n            0x02,\n            varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildFunctionDeclarations() {\n        const entries = [];\n        for (let i=this.nImportFunctions; i< this.nImportFunctions + this.nInternalFunctions; i++) {\n            entries.push(...varuint32(this.functions[i].signatureIdx));\n        }\n        return this._buildSection(\n            0x03,\n            [\n                ...varuint32(entries.length),\n                ...[...entries]\n            ]\n        );\n    }\n\n    _buildFunctionsTable() {\n        if (this.functionsTable.length == 0) return [];\n        return this._buildSection(\n            0x04,\n            [\n                ...varuint32(1),\n                0x70, 0, ...varuint32(this.functionsTable.length)\n            ]\n        );\n    }\n\n    _buildElements() {\n        if (this.functionsTable.length == 0) return [];\n        const entries = [];\n        for (let i=0; i<this.functionsTable.length; i++) {\n            entries.push(...varuint32(this.functionsTable[i]));\n        }\n        return this._buildSection(\n            0x09,\n            [\n                ...varuint32(1),      // 1 entry\n                ...varuint32(0),      // Table (0 in MVP)\n                0x41,                       // offset 0\n                ...varint32(0),\n                0x0b,\n                ...varuint32(this.functionsTable.length), // Number of elements\n                ...[...entries]\n            ]\n        );\n    }\n\n    _buildExports() {\n        const entries = [];\n        for (let i=0; i< this.exports.length; i++) {\n            entries.push([\n                ...string(this.exports[i].exportName),\n                0x00,\n                ...varuint32(this.exports[i].idx)\n            ]);\n        }\n        return this._buildSection(\n            0x07,\n            varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildCode() {\n        const entries = [];\n        for (let i=this.nImportFunctions; i< this.nImportFunctions + this.nInternalFunctions; i++) {\n            entries.push(this.functions[i].getBody());\n        }\n        return this._buildSection(\n            0x0a,\n            varuint32(entries.length).concat(...entries)\n        );\n    }\n\n    _buildData() {\n        const entries = [];\n        entries.push([\n            0x00,\n            0x41,\n            0x00,\n            0x0b,\n            0x04,\n            ...u32(this.free)\n        ]);\n        for (let i=0; i< this.datas.length; i++) {\n            entries.push([\n                0x00,\n                0x41,\n                ...varint32(this.datas[i].offset),\n                0x0b,\n                ...varuint32(this.datas[i].bytes.length),\n                ...this.datas[i].bytes,\n            ]);\n        }\n        return this._buildSection(\n            0x0b,\n            varuint32(entries.length).concat(...entries)\n        );\n    }\n\n}\n\nglobalThis.curve_bn128 = null;\n\nasync function buildBn128(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bn128)) return globalThis.curve_bn128;\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBn128$1(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bn128wasm = {};\n\n    bn128wasm.code = moduleBuilder.build();\n    bn128wasm.pq = moduleBuilder.modules.f1m.pq;\n    bn128wasm.pr = moduleBuilder.modules.frm.pq;\n    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;\n    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;\n    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;\n    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;\n    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;\n    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;\n    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;\n    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;\n    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;\n    bn128wasm.n8q = 32;\n    bn128wasm.n8r = 32;\n    bn128wasm.q = moduleBuilder.modules.bn128.q;\n    bn128wasm.r = moduleBuilder.modules.bn128.r;\n\n    const params = {\n        name: \"bn128\",\n        wasm: bn128wasm,\n        q: e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\"),\n        r: e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\"),\n        n8q: 32,\n        n8r: 32,\n        cofactorG2: e(\"30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bn128 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bn128 = curve;\n    }\n\n    return curve;\n}\n\nglobalThis.curve_bls12381 = null;\n\nasync function buildBls12381(singleThread, plugins) {\n    if ((!singleThread) && (globalThis.curve_bls12381)) return globalThis.curve_bls12381;\n\n    const moduleBuilder = new ModuleBuilder();\n    moduleBuilder.setMemory(25);\n    buildBls12381$1(moduleBuilder);\n\n    if (plugins) plugins(moduleBuilder);\n\n    const bls12381wasm = {};\n\n    bls12381wasm.code = moduleBuilder.build();\n    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;\n    bls12381wasm.pr = moduleBuilder.modules.frm.pq;\n    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;\n    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;\n    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;\n    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;\n    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;\n    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;\n    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;\n    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;\n    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;\n    bls12381wasm.n8q = 48;\n    bls12381wasm.n8r = 32;\n    bls12381wasm.q = moduleBuilder.modules.bls12381.q;\n    bls12381wasm.r = moduleBuilder.modules.bls12381.r;\n\n\n    const params = {\n        name: \"bls12381\",\n        wasm: bls12381wasm,\n        q: e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16),\n        r: e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16),\n        n8q: 48,\n        n8r: 32,\n        cofactorG1: e(\"0x396c8c005555e1568c00aaab0000aaab\", 16),\n        cofactorG2: e(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\", 16),\n        singleThread: singleThread ? true : false\n    };\n\n    const curve = await buildEngine(params);\n    curve.terminate = async function () {\n        if (!params.singleThread) {\n            globalThis.curve_bls12381 = null;\n            await this.tm.terminate();\n        }\n    };\n\n    if (!singleThread) {\n        globalThis.curve_bls12381 = curve;\n    }\n\n    return curve;\n}\n\nconst bls12381r = e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nasync function getCurveFromR(r, singleThread, plugins) {\n    let curve;\n    if (eq(r, bn128r)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (eq(r, bls12381r)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${toString(r)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromQ(q, singleThread, plugins) {\n    let curve;\n    if (eq(q, bn128q)) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if (eq(q, bls12381q)) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${toString(q, 16)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromName(name, singleThread, plugins) {\n    let curve;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await buildBn128(singleThread, plugins);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await buildBls12381(singleThread, plugins);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n\nconst Scalar=_Scalar;\nconst utils = _utils;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zbmFya2pzL25vZGVfbW9kdWxlcy9mZmphdmFzY3JpcHQvYnVpbGQvYnJvd3Nlci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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dkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsR0FBRyxlQUFlLFNBQVM7QUFDMUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSwyQkFBMkIsTUFBTTs7QUFFakM7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQixNQUFNOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixNQUFNOztBQUU1QjtBQUNBLHNCQUFzQixNQUFNOztBQUU1QjtBQUNBLHNCQUFzQixNQUFNOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTix3REFBd0Q7QUFDeEQ7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix1QkFBdUIsSUFBSSx1QkFBdUI7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFdBQVc7QUFDakMsNkNBQTZDLGlCQUFpQjtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QywwQkFBMEI7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBCQUEwQjtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEseUJBQXlCOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyx3Q0FBd0M7QUFDeEMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxpQ0FBaUM7QUFDakMsd0NBQXdDO0FBQ3hDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSwyQ0FBMkM7QUFDbkQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJFQUEyRTs7QUFFbkY7O0FBRUE7O0FBRUEsZ0RBQWdEOztBQUVoRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLGFBQWE7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBMEQ7O0FBRWxFOztBQUVBOztBQUVBOztBQUVBLGdEQUFnRDs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DOztBQUVwQzs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixhQUFhOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pELGlCQUFpQixtQ0FBbUM7QUFDcEQsaUJBQWlCO0FBQ2pCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsaUJBQWlCLHlDQUF5QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQix3Q0FBd0M7QUFDekQsaUJBQWlCLG1DQUFtQztBQUNwRCxpQkFBaUI7QUFDakIscUJBQXFCLE9BQU87QUFDNUIscUJBQXFCLFNBQVM7QUFDOUIscUJBQXFCLE9BQU87QUFDNUIscUJBQXFCLE9BQU87QUFDNUIscUJBQXFCLFVBQVU7QUFDL0Isa0JBQWtCO0FBQ2xCLGlCQUFpQix5Q0FBeUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHLElBQUksR0FBRztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHLElBQUksR0FBRyxJQUFJLEdBQUc7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFLElBQUksRUFBRSxJQUFJLEdBQUc7QUFDdkMsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxJQUFJLEdBQUc7QUFDakMsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1DQUFtQzs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7Ozs7QUFJQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxtQkFBbUIsU0FBUyxXQUFXO0FBQzVHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLG1CQUFtQixTQUFTLFdBQVc7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsbUJBQW1CLFNBQVMsV0FBVztBQUM1RztBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsT0FBTztBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQixrQkFBa0I7O0FBRWxCLHFCQUFxQjtBQUNyQixxQkFBcUI7OztBQUdyQixzQkFBc0I7QUFDdEIsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCLHVCQUF1QjtBQUN2QiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsNEJBQTRCO0FBQzVCLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCLG9CQUFvQjs7QUFFcEIsdUJBQXVCOztBQUV2QixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRCxZQUFZLFdBQVcsV0FBVztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsWUFBWSxXQUFXLFdBQVc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EscUVBQXFFLFlBQVk7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTzs7QUFFaEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RCxPQUFPOztBQUVoRTtBQUNBO0FBQ0Esa0ZBQWtGLE9BQU87O0FBRXpGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxvREFBb0Q7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLG9EQUFvRDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFb0wiLCJzb3VyY2VzIjpbIi9ob21lL25lby9naXQvem5lcDE3L3dlYi9ub2RlX21vZHVsZXMvc25hcmtqcy9ub2RlX21vZHVsZXMvZmZqYXZhc2NyaXB0L2J1aWxkL2Jyb3dzZXIuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBCaWdJbnQgKi9cbmNvbnN0IGhleExlbiA9IFsgMCwgMSwgMiwgMiwgMywgMywgMywgMywgNCAsNCAsNCAsNCAsNCAsNCAsNCAsNF07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcocywgcmFkaXgpIHtcbiAgICBpZiAoKCFyYWRpeCl8fChyYWRpeD09MTApKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQocyk7XG4gICAgfSBlbHNlIGlmIChyYWRpeD09MTYpIHtcbiAgICAgICAgaWYgKHMuc2xpY2UoMCwyKSA9PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQocyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KFwiMHhcIitzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgZSA9IGZyb21TdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21BcnJheShhLCByYWRpeCkge1xuICAgIGxldCBhY2MgPUJpZ0ludCgwKTtcbiAgICByYWRpeCA9IEJpZ0ludChyYWRpeCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjID0gYWNjKnJhZGl4ICsgQmlnSW50KGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xufVxuXG5mdW5jdGlvbiBiaXRMZW5ndGgkNihhKSB7XG4gICAgY29uc3QgYVMgPWEudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiAoYVMubGVuZ3RoLTEpKjQgK2hleExlbltwYXJzZUludChhU1swXSwgMTYpXTtcbn1cblxuZnVuY3Rpb24gaXNOZWdhdGl2ZSQ0KGEpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpIDwgQmlnSW50KDApO1xufVxuXG5mdW5jdGlvbiBpc1plcm8kMShhKSB7XG4gICAgcmV0dXJuICFhO1xufVxuXG5mdW5jdGlvbiBzaGlmdExlZnQoYSwgbikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPDwgQmlnSW50KG4pO1xufVxuXG5mdW5jdGlvbiBzaGlmdFJpZ2h0KGEsIG4pIHtcbiAgICByZXR1cm4gQmlnSW50KGEpID4+IEJpZ0ludChuKTtcbn1cblxuY29uc3Qgc2hsID0gc2hpZnRMZWZ0O1xuY29uc3Qgc2hyID0gc2hpZnRSaWdodDtcblxuZnVuY3Rpb24gaXNPZGQkNShhKSB7XG4gICAgcmV0dXJuIChCaWdJbnQoYSkgJiBCaWdJbnQoMSkpID09IEJpZ0ludCgxKTtcbn1cblxuXG5mdW5jdGlvbiBuYWYobikge1xuICAgIGxldCBFID0gQmlnSW50KG4pO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIHdoaWxlIChFKSB7XG4gICAgICAgIGlmIChFICYgQmlnSW50KDEpKSB7XG4gICAgICAgICAgICBjb25zdCB6ID0gMiAtIE51bWJlcihFICUgQmlnSW50KDQpKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKCB6ICk7XG4gICAgICAgICAgICBFID0gRSAtIEJpZ0ludCh6KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKCAwICk7XG4gICAgICAgIH1cbiAgICAgICAgRSA9IEUgPj4gQmlnSW50KDEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5cbmZ1bmN0aW9uIGJpdHMobikge1xuICAgIGxldCBFID0gQmlnSW50KG4pO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIHdoaWxlIChFKSB7XG4gICAgICAgIGlmIChFICYgQmlnSW50KDEpKSB7XG4gICAgICAgICAgICByZXMucHVzaCgxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKCAwICk7XG4gICAgICAgIH1cbiAgICAgICAgRSA9IEUgPj4gQmlnSW50KDEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiB0b051bWJlciQxKHMpIHtcbiAgICBpZiAocz5CaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlcihzKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheShzLCByYWRpeCkge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGxldCByZW0gPSBCaWdJbnQocyk7XG4gICAgcmFkaXggPSBCaWdJbnQocmFkaXgpO1xuICAgIHdoaWxlIChyZW0pIHtcbiAgICAgICAgcmVzLnVuc2hpZnQoIE51bWJlcihyZW0gJSByYWRpeCkpO1xuICAgICAgICByZW0gPSByZW0gLyByYWRpeDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuXG5mdW5jdGlvbiBhZGQoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgKyBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSAtIEJpZ0ludChiKTtcbn1cblxuZnVuY3Rpb24gbmVnKGEpIHtcbiAgICByZXR1cm4gLUJpZ0ludChhKTtcbn1cblxuZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICogQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBzcXVhcmUkMihhKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSAqIEJpZ0ludChhKTtcbn1cblxuZnVuY3Rpb24gcG93KGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICoqIEJpZ0ludChiKTtcbn1cblxuZnVuY3Rpb24gZXhwJDEoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgKiogQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBhYnMkMShhKSB7XG4gICAgcmV0dXJuIEJpZ0ludChhKSA+PSAwID8gQmlnSW50KGEpIDogLUJpZ0ludChhKTtcbn1cblxuZnVuY3Rpb24gZGl2KGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpIC8gQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgJSBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIGVxKGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpID09IEJpZ0ludChiKTtcbn1cblxuZnVuY3Rpb24gbmVxKGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICE9IEJpZ0ludChiKTtcbn1cblxuZnVuY3Rpb24gbHQoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPCBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIGd0KGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpID4gQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBsZXEoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPD0gQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBnZXEoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgPj0gQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBiYW5kKGEsIGIpIHtcbiAgICByZXR1cm4gQmlnSW50KGEpICYgQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBib3IoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgfCBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIGJ4b3IoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgXiBCaWdJbnQoYik7XG59XG5cbmZ1bmN0aW9uIGxhbmQoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgJiYgQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBsb3IoYSwgYikge1xuICAgIHJldHVybiBCaWdJbnQoYSkgfHwgQmlnSW50KGIpO1xufVxuXG5mdW5jdGlvbiBsbm90KGEpIHtcbiAgICByZXR1cm4gIUJpZ0ludChhKTtcbn1cblxuLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIExpdHRsZSBFbmRpYW4gUmVwcmVzZW50YXRpb25cbmZ1bmN0aW9uIHRvUnByTEUoYnVmZiwgbywgZSwgbjgpIHtcbiAgICBjb25zdCBzID0gXCIwMDAwMDAwXCIgKyBlLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCB2ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQgKyBvLCBuOC80KTtcbiAgICBjb25zdCBsID0gKCgocy5sZW5ndGgtNykqNCAtIDEpID4+IDUpKzE7ICAgIC8vIE51bWJlciBvZiAzMmJpdCB3b3JkcztcbiAgICBmb3IgKGxldCBpPTA7IGk8bDsgaSsrKSB2W2ldID0gcGFyc2VJbnQocy5zdWJzdHJpbmcocy5sZW5ndGgtOCppLTgsIHMubGVuZ3RoLTgqaSksIDE2KTtcbiAgICBmb3IgKGxldCBpPWw7IGk8di5sZW5ndGg7IGkrKykgdltpXSA9IDA7XG4gICAgZm9yIChsZXQgaT12Lmxlbmd0aCo0OyBpPG44OyBpKyspIGJ1ZmZbaV0gPSB0b051bWJlciQxKGJhbmQoc2hpZnRSaWdodChlLCBpKjgpLCAweEZGKSk7XG59XG5cbi8vIFJldHVybnMgYSBidWZmZXIgd2l0aCBCaWcgRW5kaWFuIFJlcHJlc2VudGF0aW9uXG5mdW5jdGlvbiB0b1JwckJFKGJ1ZmYsIG8sIGUsIG44KSB7XG4gICAgY29uc3QgcyA9IFwiMDAwMDAwMFwiICsgZS50b1N0cmluZygxNik7XG4gICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0ICsgbywgbjgpO1xuICAgIGNvbnN0IGwgPSAoKChzLmxlbmd0aC03KSo0IC0gMSkgPj4gNSkrMTsgICAgLy8gTnVtYmVyIG9mIDMyYml0IHdvcmRzO1xuICAgIGZvciAobGV0IGk9MDsgaTxsOyBpKyspIHYuc2V0VWludDMyKG44LWkqNCAtNCwgcGFyc2VJbnQocy5zdWJzdHJpbmcocy5sZW5ndGgtOCppLTgsIHMubGVuZ3RoLTgqaSksIDE2KSwgZmFsc2UpO1xuICAgIGZvciAobGV0IGk9MDsgaTxuOC80LWw7IGkrKykgdltpXSA9IDA7XG59XG5cbi8vIFBhc2VzIGEgYnVmZmVyIHdpdGggTGl0dGxlIEVuZGlhbiBSZXByZXNlbnRhdGlvblxuZnVuY3Rpb24gZnJvbVJwckxFKGJ1ZmYsIG8sIG44KSB7XG4gICAgbjggPSBuOCB8fCBidWZmLmJ5dGVMZW5ndGg7XG4gICAgbyA9IG8gfHwgMDtcbiAgICBjb25zdCB2ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQgKyBvLCBuOC80KTtcbiAgICBjb25zdCBhID0gbmV3IEFycmF5KG44LzQpO1xuICAgIHYuZm9yRWFjaCggKGNoLGkpID0+IGFbYS5sZW5ndGgtaS0xXSA9IGNoLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LFwiMFwiKSApO1xuICAgIHJldHVybiBmcm9tU3RyaW5nKGEuam9pbihcIlwiKSwgMTYpO1xufVxuXG4vLyBQYXNlcyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gUmVwcmVzZW50YXRpb25cbmZ1bmN0aW9uIGZyb21ScHJCRShidWZmLCBvLCBuOCkge1xuICAgIG44ID0gbjggfHwgYnVmZi5ieXRlTGVuZ3RoO1xuICAgIG8gPSBvIHx8IDA7XG4gICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0ICsgbywgbjgpO1xuICAgIGNvbnN0IGEgPSBuZXcgQXJyYXkobjgvNCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPG44LzQ7IGkrKykge1xuICAgICAgICBhW2ldID0gdi5nZXRVaW50MzIoaSo0LCBmYWxzZSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoYS5qb2luKFwiXCIpLCAxNik7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKGEsIHJhZGl4KSB7XG4gICAgcmV0dXJuIGEudG9TdHJpbmcocmFkaXgpO1xufVxuXG5mdW5jdGlvbiB0b0xFQnVmZihhKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KE1hdGguZmxvb3IoKGJpdExlbmd0aCQ2KGEpIC0gMSkgLyA4KSArMSk7XG4gICAgdG9ScHJMRShidWZmLCAwLCBhLCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiBidWZmO1xufVxuXG5jb25zdCB6ZXJvID0gZSgwKTtcbmNvbnN0IG9uZSA9IGUoMSk7XG5cbnZhciBfU2NhbGFyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBhYnM6IGFicyQxLFxuICAgIGFkZDogYWRkLFxuICAgIGJhbmQ6IGJhbmQsXG4gICAgYml0TGVuZ3RoOiBiaXRMZW5ndGgkNixcbiAgICBiaXRzOiBiaXRzLFxuICAgIGJvcjogYm9yLFxuICAgIGJ4b3I6IGJ4b3IsXG4gICAgZGl2OiBkaXYsXG4gICAgZTogZSxcbiAgICBlcTogZXEsXG4gICAgZXhwOiBleHAkMSxcbiAgICBmcm9tQXJyYXk6IGZyb21BcnJheSxcbiAgICBmcm9tUnByQkU6IGZyb21ScHJCRSxcbiAgICBmcm9tUnByTEU6IGZyb21ScHJMRSxcbiAgICBmcm9tU3RyaW5nOiBmcm9tU3RyaW5nLFxuICAgIGdlcTogZ2VxLFxuICAgIGd0OiBndCxcbiAgICBpc05lZ2F0aXZlOiBpc05lZ2F0aXZlJDQsXG4gICAgaXNPZGQ6IGlzT2RkJDUsXG4gICAgaXNaZXJvOiBpc1plcm8kMSxcbiAgICBsYW5kOiBsYW5kLFxuICAgIGxlcTogbGVxLFxuICAgIGxub3Q6IGxub3QsXG4gICAgbG9yOiBsb3IsXG4gICAgbHQ6IGx0LFxuICAgIG1vZDogbW9kLFxuICAgIG11bDogbXVsLFxuICAgIG5hZjogbmFmLFxuICAgIG5lZzogbmVnLFxuICAgIG5lcTogbmVxLFxuICAgIG9uZTogb25lLFxuICAgIHBvdzogcG93LFxuICAgIHNoaWZ0TGVmdDogc2hpZnRMZWZ0LFxuICAgIHNoaWZ0UmlnaHQ6IHNoaWZ0UmlnaHQsXG4gICAgc2hsOiBzaGwsXG4gICAgc2hyOiBzaHIsXG4gICAgc3F1YXJlOiBzcXVhcmUkMixcbiAgICBzdWI6IHN1YixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIHRvTEVCdWZmOiB0b0xFQnVmZixcbiAgICB0b051bWJlcjogdG9OdW1iZXIkMSxcbiAgICB0b1JwckJFOiB0b1JwckJFLFxuICAgIHRvUnByTEU6IHRvUnByTEUsXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgIHplcm86IHplcm9cbn0pO1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKlxuICAgIFRoaXMgbGlicmFyeSBkb2VzIG9wZXJhdGlvbnMgb24gcG9seW5vbWlhbHMgd2l0aCBjb2VmZmljaWVudHMgaW4gYSBmaWVsZCBGLlxuXG4gICAgQSBwb2x5bm9taWFsIFAoeCkgPSBwMCArIHAxICogeCArIHAyICogeF4yICsgLi4uICsgcG4gKiB4Xm4gIGlzIHJlcHJlc2VudGVkXG4gICAgYnkgdGhlIGFycmF5IFsgcDAsIHAxLCBwMiwgLi4uICwgcG4gXS5cbiAqL1xuXG5jbGFzcyBQb2xGaWVsZCB7XG4gICAgY29uc3RydWN0b3IgKEYpIHtcbiAgICAgICAgdGhpcy5GID0gRjtcblxuICAgICAgICBsZXQgcmVtID0gRi5zcXJ0X3Q7XG4gICAgICAgIGxldCBzID0gRi5zcXJ0X3M7XG5cbiAgICAgICAgY29uc3QgZml2ZSA9IHRoaXMuRi5hZGQodGhpcy5GLmFkZCh0aGlzLkYudHdvLCB0aGlzLkYudHdvKSwgdGhpcy5GLm9uZSk7XG5cbiAgICAgICAgdGhpcy53ID0gbmV3IEFycmF5KHMrMSk7XG4gICAgICAgIHRoaXMud2kgPSBuZXcgQXJyYXkocysxKTtcbiAgICAgICAgdGhpcy53W3NdID0gdGhpcy5GLnBvdyhmaXZlLCByZW0pO1xuICAgICAgICB0aGlzLndpW3NdID0gdGhpcy5GLmludih0aGlzLndbc10pO1xuXG4gICAgICAgIGxldCBuPXMtMTtcbiAgICAgICAgd2hpbGUgKG4+PTApIHtcbiAgICAgICAgICAgIHRoaXMud1tuXSA9IHRoaXMuRi5zcXVhcmUodGhpcy53W24rMV0pO1xuICAgICAgICAgICAgdGhpcy53aVtuXSA9IHRoaXMuRi5zcXVhcmUodGhpcy53aVtuKzFdKTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5yb290cyA9IFtdO1xuLyogICAgICAgIGZvciAobGV0IGk9MDsgaTwxNjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgciA9IHRoaXMuRi5vbmU7XG4gICAgICAgICAgICBuID0gMSA8PCBpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdHNpID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG47IGorKykge1xuICAgICAgICAgICAgICAgIHJvb3RzaVtqXSA9IHI7XG4gICAgICAgICAgICAgICAgciA9IHRoaXMuRi5tdWwociwgdGhpcy53W2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yb290cy5wdXNoKHJvb3RzaSk7XG4gICAgICAgIH1cbiAgICAqL1xuICAgICAgICB0aGlzLl9zZXRSb290cygxNSk7XG4gICAgfVxuXG4gICAgX3NldFJvb3RzKG4pIHtcbiAgICAgICAgaWYgKG4gPiB0aGlzLkYuc3FydF9zKSBuID0gdGhpcy5zO1xuICAgICAgICBmb3IgKGxldCBpPW47IChpPj0wKSAmJiAoIXRoaXMucm9vdHNbaV0pOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCByID0gdGhpcy5GLm9uZTtcbiAgICAgICAgICAgIGNvbnN0IG5yb290cyA9IDEgPDwgaTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RzaSA9IG5ldyBBcnJheShucm9vdHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5yb290czsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNpW2pdID0gcjtcbiAgICAgICAgICAgICAgICByID0gdGhpcy5GLm11bChyLCB0aGlzLndbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb290c1tpXSA9IHJvb3RzaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZChhLCBiKSB7XG4gICAgICAgIGNvbnN0IG0gPSBNYXRoLm1heChhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IHRoaXMuRi5hZGQoYVtpXSB8fCB0aGlzLkYuemVybywgYltpXSB8fCB0aGlzLkYuemVybyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKHJlcyk7XG4gICAgfVxuXG4gICAgZG91YmxlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGEsYSk7XG4gICAgfVxuXG4gICAgc3ViKGEsIGIpIHtcbiAgICAgICAgY29uc3QgbSA9IE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG07IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5GLnN1YihhW2ldIHx8IHRoaXMuRi56ZXJvLCBiW2ldIHx8IHRoaXMuRi56ZXJvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UocmVzKTtcbiAgICB9XG5cbiAgICBtdWxTY2FsYXIocCwgYikge1xuICAgICAgICBpZiAodGhpcy5GLmVxKGIsIHRoaXMuRi56ZXJvKSkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAodGhpcy5GLmVxKGIsIHRoaXMuRi5vbmUpKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IHRoaXMuRi5tdWwocFtpXSwgYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxuXG4gICAgbXVsKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoID09IDApIHJldHVybiBbXTtcbiAgICAgICAgaWYgKGIubGVuZ3RoID09IDApIHJldHVybiBbXTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLm11bFNjYWxhcihiLCBhWzBdKTtcbiAgICAgICAgaWYgKGIubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLm11bFNjYWxhcihhLCBiWzBdKTtcblxuICAgICAgICBpZiAoYi5sZW5ndGggPiBhLmxlbmd0aCkge1xuICAgICAgICAgICAgW2IsIGFdID0gW2EsIGJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChiLmxlbmd0aCA8PSAyKSB8fCAoYi5sZW5ndGggPCBsb2cyJDIoYS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsTm9ybWFsKGEsYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWxGRlQoYSxiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11bE5vcm1hbChhLCBiKSB7XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcyA9IHRoaXMuYWRkKHJlcywgdGhpcy5zY2FsZVgodGhpcy5tdWxTY2FsYXIoYSwgYltpXSksIGkpICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBtdWxGRlQoYSxiKSB7XG4gICAgICAgIGNvbnN0IGxvbmdlc3ROID0gTWF0aC5tYXgoYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYml0c1Jlc3VsdCA9IGxvZzIkMihsb25nZXN0Ti0xKSsyO1xuICAgICAgICB0aGlzLl9zZXRSb290cyhiaXRzUmVzdWx0KTtcblxuICAgICAgICBjb25zdCBtID0gMSA8PCBiaXRzUmVzdWx0O1xuICAgICAgICBjb25zdCBlYSA9IHRoaXMuZXh0ZW5kKGEsbSk7XG4gICAgICAgIGNvbnN0IGViID0gdGhpcy5leHRlbmQoYixtKTtcblxuICAgICAgICBjb25zdCB0YSA9IF9fZmZ0JDEodGhpcywgZWEsIGJpdHNSZXN1bHQsIDAsIDEpO1xuICAgICAgICBjb25zdCB0YiA9IF9fZmZ0JDEodGhpcywgZWIsIGJpdHNSZXN1bHQsIDAsIDEpO1xuXG4gICAgICAgIGNvbnN0IHRyZXMgPSBuZXcgQXJyYXkobSk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG07IGkrKykge1xuICAgICAgICAgICAgdHJlc1tpXSA9IHRoaXMuRi5tdWwodGFbaV0sIHRiW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlcyA9IF9fZmZ0JDEodGhpcywgdHJlcywgYml0c1Jlc3VsdCwgMCwgMSk7XG5cbiAgICAgICAgY29uc3QgdHdvaW52bSA9IHRoaXMuRi5pbnYoIHRoaXMuRi5tdWxTY2FsYXIodGhpcy5GLm9uZSwgbSkgKTtcbiAgICAgICAgY29uc3QgcmVzbiA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG07IGkrKykge1xuICAgICAgICAgICAgcmVzbltpXSA9IHRoaXMuRi5tdWwocmVzWyhtLWkpJW1dLCB0d29pbnZtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShyZXNuKTtcbiAgICB9XG5cblxuXG4gICAgc3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKGEsYSk7XG4gICAgfVxuXG4gICAgc2NhbGVYKHAsIG4pIHtcbiAgICAgICAgaWYgKG49PTApIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9IGVsc2UgaWYgKG4+MCkge1xuICAgICAgICAgICAgY29uc3QgeiA9IG5ldyBBcnJheShuKS5maWxsKHRoaXMuRi56ZXJvKTtcbiAgICAgICAgICAgIHJldHVybiB6LmNvbmNhdChwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgtbiA+PSBwLmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgcmV0dXJuIHAuc2xpY2UoLW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXZhbDIocCwgeCkge1xuICAgICAgICBsZXQgdiA9IHRoaXMuRi56ZXJvO1xuICAgICAgICBsZXQgaXggPSB0aGlzLkYub25lO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdiA9IHRoaXMuRi5hZGQodiwgdGhpcy5GLm11bChwW2ldLCBpeCkpO1xuICAgICAgICAgICAgaXggPSB0aGlzLkYubXVsKGl4LCB4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICBldmFsdWF0ZShwLHgpIHtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcbiAgICAgICAgaWYgKHAubGVuZ3RoID09IDApIHJldHVybiBGLnplcm87XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9uZXh0MlBvd2VyKHAubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZXAgPSB0aGlzLmV4dGVuZChwLCBtKTtcblxuICAgICAgICByZXR1cm4gX2V2YWwoZXAsIHgsIDAsIDEsIG0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9ldmFsKHAsIHgsIG9mZnNldCwgc3RlcCwgbikge1xuICAgICAgICAgICAgaWYgKG49PTEpIHJldHVybiBwW29mZnNldF07XG4gICAgICAgICAgICBjb25zdCBuZXdYID0gRi5zcXVhcmUoeCk7XG4gICAgICAgICAgICBjb25zdCByZXM9IEYuYWRkKFxuICAgICAgICAgICAgICAgIF9ldmFsKHAsIG5ld1gsIG9mZnNldCwgc3RlcCA8PCAxLCBuID4+IDEpLFxuICAgICAgICAgICAgICAgIEYubXVsKFxuICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICBfZXZhbChwLCBuZXdYLCBvZmZzZXQrc3RlcCAsIHN0ZXAgPDwgMSwgbiA+PiAxKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxhZ3JhbmdlKHBvaW50cykge1xuICAgICAgICBsZXQgcm9vdHMgPSBbdGhpcy5GLm9uZV07XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJvb3RzID0gdGhpcy5tdWwocm9vdHMsIFt0aGlzLkYubmVnKHBvaW50c1tpXVswXSksIHRoaXMuRi5vbmVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdW0gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1wb2wgPSB0aGlzLnJ1ZmZpbmkocm9vdHMsIHBvaW50c1tpXVswXSk7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IgPVxuICAgICAgICAgICAgICAgIHRoaXMuRi5tdWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRi5pbnYodGhpcy5ldmFsdWF0ZShtcG9sLCBwb2ludHNbaV1bMF0pKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2ldWzFdKTtcbiAgICAgICAgICAgIG1wb2wgPSB0aGlzLm11bFNjYWxhcihtcG9sLCBmYWN0b3IpO1xuICAgICAgICAgICAgc3VtID0gdGhpcy5hZGQoc3VtLCBtcG9sKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cblxuXG4gICAgZmZ0KHApIHtcbiAgICAgICAgaWYgKHAubGVuZ3RoIDw9IDEpIHJldHVybiBwO1xuICAgICAgICBjb25zdCBiaXRzID0gbG9nMiQyKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuXG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHM7XG4gICAgICAgIGNvbnN0IGVwID0gdGhpcy5leHRlbmQocCwgbSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IF9fZmZ0JDEodGhpcywgZXAsIGJpdHMsIDAsIDEpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZmdDIocCkge1xuICAgICAgICBpZiAocC5sZW5ndGggPD0gMSkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyJDIocC5sZW5ndGgtMSkrMTtcbiAgICAgICAgdGhpcy5fc2V0Um9vdHMoYml0cyk7XG5cbiAgICAgICAgY29uc3QgbSA9IDEgPDwgYml0cztcbiAgICAgICAgY29uc3QgZXAgPSB0aGlzLmV4dGVuZChwLCBtKTtcbiAgICAgICAgX19iaXRSZXZlcnNlKGVwLCBiaXRzKTtcbiAgICAgICAgY29uc3QgcmVzID0gX19mZnQyKHRoaXMsIGVwLCBiaXRzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxuICAgIGlmZnQocCkge1xuXG4gICAgICAgIGlmIChwLmxlbmd0aCA8PSAxKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgYml0cyA9IGxvZzIkMihwLmxlbmd0aC0xKSsxO1xuICAgICAgICB0aGlzLl9zZXRSb290cyhiaXRzKTtcbiAgICAgICAgY29uc3QgbSA9IDEgPDwgYml0cztcbiAgICAgICAgY29uc3QgZXAgPSB0aGlzLmV4dGVuZChwLCBtKTtcbiAgICAgICAgY29uc3QgcmVzID0gIF9fZmZ0JDEodGhpcywgZXAsIGJpdHMsIDAsIDEpO1xuXG4gICAgICAgIGNvbnN0IHR3b2ludm0gPSB0aGlzLkYuaW52KCB0aGlzLkYubXVsU2NhbGFyKHRoaXMuRi5vbmUsIG0pICk7XG4gICAgICAgIGNvbnN0IHJlc24gPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgIHJlc25baV0gPSB0aGlzLkYubXVsKHJlc1sobS1pKSVtXSwgdHdvaW52bSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzbjtcblxuICAgIH1cblxuXG4gICAgaWZmdDIocCkge1xuXG4gICAgICAgIGlmIChwLmxlbmd0aCA8PSAxKSByZXR1cm4gcDtcbiAgICAgICAgY29uc3QgYml0cyA9IGxvZzIkMihwLmxlbmd0aC0xKSsxO1xuICAgICAgICB0aGlzLl9zZXRSb290cyhiaXRzKTtcbiAgICAgICAgY29uc3QgbSA9IDEgPDwgYml0cztcbiAgICAgICAgY29uc3QgZXAgPSB0aGlzLmV4dGVuZChwLCBtKTtcbiAgICAgICAgX19iaXRSZXZlcnNlKGVwLCBiaXRzKTtcbiAgICAgICAgY29uc3QgcmVzID0gIF9fZmZ0Mih0aGlzLCBlcCwgYml0cyk7XG5cbiAgICAgICAgY29uc3QgdHdvaW52bSA9IHRoaXMuRi5pbnYoIHRoaXMuRi5tdWxTY2FsYXIodGhpcy5GLm9uZSwgbSkgKTtcbiAgICAgICAgY29uc3QgcmVzbiA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG07IGkrKykge1xuICAgICAgICAgICAgcmVzbltpXSA9IHRoaXMuRi5tdWwocmVzWyhtLWkpJW1dLCB0d29pbnZtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNuO1xuXG4gICAgfVxuXG4gICAgX2ZmdChwYWxsLCBiaXRzLCBvZmZzZXQsIHN0ZXApIHtcblxuICAgICAgICBjb25zdCBuID0gMSA8PCBiaXRzO1xuICAgICAgICBpZiAobj09MSkge1xuICAgICAgICAgICAgcmV0dXJuIFsgcGFsbFtvZmZzZXRdIF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZGl2MiA9IG4gPj4gMTtcbiAgICAgICAgY29uc3QgcDEgPSB0aGlzLl9mZnQocGFsbCwgYml0cy0xLCBvZmZzZXQsIHN0ZXAqMik7XG4gICAgICAgIGNvbnN0IHAyID0gdGhpcy5fZmZ0KHBhbGwsIGJpdHMtMSwgb2Zmc2V0K3N0ZXAsIHN0ZXAqMik7XG5cbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgICAgIGxldCBtPSB0aGlzLkYub25lO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bmRpdjI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gdGhpcy5GLmFkZChwMVtpXSwgdGhpcy5GLm11bChtLCBwMltpXSkpO1xuICAgICAgICAgICAgb3V0W2krbmRpdjJdID0gdGhpcy5GLnN1YihwMVtpXSwgdGhpcy5GLm11bChtLCBwMltpXSkpO1xuICAgICAgICAgICAgbSA9IHRoaXMuRi5tdWwobSwgdGhpcy53W2JpdHNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZXh0ZW5kKHAsIGUpIHtcbiAgICAgICAgaWYgKGUgPT0gcC5sZW5ndGgpIHJldHVybiBwO1xuICAgICAgICBjb25zdCB6ID0gbmV3IEFycmF5KGUtcC5sZW5ndGgpLmZpbGwodGhpcy5GLnplcm8pO1xuXG4gICAgICAgIHJldHVybiBwLmNvbmNhdCh6KTtcbiAgICB9XG5cbiAgICByZWR1Y2UocCkge1xuICAgICAgICBpZiAocC5sZW5ndGggPT0gMCkgcmV0dXJuIHA7XG4gICAgICAgIGlmICghIHRoaXMuRi5lcShwW3AubGVuZ3RoLTFdLCB0aGlzLkYuemVybykgKSByZXR1cm4gcDtcbiAgICAgICAgbGV0IGk9cC5sZW5ndGgtMTtcbiAgICAgICAgd2hpbGUoIGk+MCAmJiB0aGlzLkYuZXEocFtpXSwgdGhpcy5GLnplcm8pICkgaS0tO1xuICAgICAgICByZXR1cm4gcC5zbGljZSgwLCBpKzEpO1xuICAgIH1cblxuICAgIGVxKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcGEgPSB0aGlzLnJlZHVjZShhKTtcbiAgICAgICAgY29uc3QgcGIgPSB0aGlzLnJlZHVjZShiKTtcblxuICAgICAgICBpZiAocGEubGVuZ3RoICE9IHBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5GLmVxKHBhW2ldLCBwYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJ1ZmZpbmkocCwgcikge1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkocC5sZW5ndGgtMSk7XG4gICAgICAgIHJlc1tyZXMubGVuZ3RoLTFdID0gcFtwLmxlbmd0aC0xXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJlcy5sZW5ndGgtMjsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICByZXNbaV0gPSB0aGlzLkYuYWRkKHRoaXMuRi5tdWwocmVzW2krMV0sIHIpLCBwW2krMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgX25leHQyUG93ZXIodikge1xuICAgICAgICB2LS07XG4gICAgICAgIHYgfD0gdiA+PiAxO1xuICAgICAgICB2IHw9IHYgPj4gMjtcbiAgICAgICAgdiB8PSB2ID4+IDQ7XG4gICAgICAgIHYgfD0gdiA+PiA4O1xuICAgICAgICB2IHw9IHYgPj4gMTY7XG4gICAgICAgIHYrKztcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcocCkge1xuICAgICAgICBjb25zdCBhcCA9IHRoaXMubm9ybWFsaXplKHApO1xuICAgICAgICBsZXQgUyA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGk9YXAubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLkYuZXEocFtpXSwgdGhpcy5GLnplcm8pKSB7XG4gICAgICAgICAgICAgICAgaWYgKFMhPVwiXCIpIFMgKz0gXCIgKyBcIjtcbiAgICAgICAgICAgICAgICBTID0gUyArIHBbaV0udG9TdHJpbmcoMTApO1xuICAgICAgICAgICAgICAgIGlmIChpPjApIHtcbiAgICAgICAgICAgICAgICAgICAgUyA9IFMgKyBcInhcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGk+MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUyA9IFMgKyBcIl5cIiAraTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUztcbiAgICB9XG5cbiAgICBub3JtYWxpemUocCkge1xuICAgICAgICBjb25zdCByZXMgID0gbmV3IEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IHRoaXMuRi5ub3JtYWxpemUocFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxuICAgIF9yZWNpcHJvY2FsKHAsIGJpdHMpIHtcbiAgICAgICAgY29uc3QgayA9IDEgPDwgYml0cztcbiAgICAgICAgaWYgKGs9PTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbIHRoaXMuRi5pbnYocFswXSkgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBucCA9IHRoaXMuc2NhbGVYKHAsIC1rLzIpO1xuICAgICAgICBjb25zdCBxID0gdGhpcy5fcmVjaXByb2NhbChucCwgYml0cy0xKTtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuc2NhbGVYKHRoaXMuZG91YmxlKHEpLCAzKmsvMi0yKTtcbiAgICAgICAgY29uc3QgYiA9IHRoaXMubXVsKCB0aGlzLnNxdWFyZShxKSwgcCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYKHRoaXMuc3ViKGEsYiksICAgLShrLTIpKTtcbiAgICB9XG5cbiAgICAvLyBkaXZpZGVzIHhebSAvIHZcbiAgICBfZGl2MihtLCB2KSB7XG4gICAgICAgIGNvbnN0IGtiaXRzID0gbG9nMiQyKHYubGVuZ3RoLTEpKzE7XG4gICAgICAgIGNvbnN0IGsgPSAxIDw8IGtiaXRzO1xuXG4gICAgICAgIGNvbnN0IHNjYWxlViA9IGsgLSB2Lmxlbmd0aDtcblxuICAgICAgICAvLyByZWMgPSB4XihrIC0gMikgLyB2KiB4XnNjYWxlViA9PlxuICAgICAgICAvLyByZWMgPSB4XihrLTItc2NhbGVWKS8gdlxuICAgICAgICAvL1xuICAgICAgICAvLyByZXMgPSB4Xm0vdiA9IHheKG0gKyAoMiprLTIgLSBzY2FsZVYpIC0gKDIqay0yIC0gc2NhbGVWKSkgL3YgPT5cbiAgICAgICAgLy8gcmVzID0gcmVjICogeF4obSAtICgyKmstMiAtIHNjYWxlVikpID0+XG4gICAgICAgIC8vIHJlcyA9IHJlYyAqIHheKG0gLSAyKmsgKyAyICsgc2NhbGVWKVxuXG4gICAgICAgIGNvbnN0IHJlYyA9IHRoaXMuX3JlY2lwcm9jYWwodGhpcy5zY2FsZVgodiwgc2NhbGVWKSwga2JpdHMpO1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnNjYWxlWChyZWMsIG0gLSAyKmsgKyAyICsgc2NhbGVWKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGRpdihfdSwgX3YpIHtcbiAgICAgICAgaWYgKF91Lmxlbmd0aCA8IF92Lmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgICAgICBjb25zdCBrYml0cyA9IGxvZzIkMihfdi5sZW5ndGgtMSkrMTtcbiAgICAgICAgY29uc3QgayA9IDEgPDwga2JpdHM7XG5cbiAgICAgICAgY29uc3QgdSA9IHRoaXMuc2NhbGVYKF91LCBrLV92Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLnNjYWxlWChfdiwgay1fdi5sZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IG4gPSB2Lmxlbmd0aC0xO1xuICAgICAgICBsZXQgbSA9IHUubGVuZ3RoLTE7XG5cbiAgICAgICAgY29uc3QgcyA9IHRoaXMuX3JlY2lwcm9jYWwodiwga2JpdHMpO1xuICAgICAgICBsZXQgdDtcbiAgICAgICAgaWYgKG0+MipuKSB7XG4gICAgICAgICAgICB0ID0gdGhpcy5zdWIodGhpcy5zY2FsZVgoW3RoaXMuRi5vbmVdLCAyKm4pLCB0aGlzLm11bChzLCB2KSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcSA9IFtdO1xuICAgICAgICBsZXQgcmVtID0gdTtcbiAgICAgICAgbGV0IHVzLCB1dDtcbiAgICAgICAgbGV0IGZpbmlzaCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlICghZmluaXNoKSB7XG4gICAgICAgICAgICB1cyA9IHRoaXMubXVsKHJlbSwgcyk7XG4gICAgICAgICAgICBxID0gdGhpcy5hZGQocSwgdGhpcy5zY2FsZVgodXMsIC0yKm4pKTtcblxuICAgICAgICAgICAgaWYgKCBtID4gMipuICkge1xuICAgICAgICAgICAgICAgIHV0ID0gdGhpcy5tdWwocmVtLCB0KTtcbiAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnNjYWxlWCh1dCwgLTIqbik7XG4gICAgICAgICAgICAgICAgbSA9IHJlbS5sZW5ndGgtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluaXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxO1xuICAgIH1cblxuXG4gICAgLy8gcmV0dXJucyB0aGUgaXRoIG50aC1yb290IG9mIG9uZVxuICAgIG9uZVJvb3QobiwgaSkge1xuICAgICAgICBsZXQgbmJpdHMgPSBsb2cyJDIobi0xKSsxO1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5GLm9uZTtcbiAgICAgICAgbGV0IHIgPSBpO1xuXG4gICAgICAgIGlmKGk+PW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdpdmVuICdpJyBzaG91bGQgYmUgbG93ZXIgdGhhbiAnbidcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoMTw8bmJpdHMgIT09IG4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgZXJybHI6ICR7bn0gc2hvdWxkIGVxdWFsICR7MTw8bmJpdHN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocj4wKSB7XG4gICAgICAgICAgICBpZiAociAmIDEgPT0gMSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMuRi5tdWwocmVzLCB0aGlzLndbbmJpdHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSByID4+IDE7XG4gICAgICAgICAgICBuYml0cyAtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGNvbXB1dGVWYW5pc2hpbmdQb2xpbm9taWFsKGJpdHMsIHQpIHtcbiAgICAgICAgY29uc3QgbSA9IDEgPDwgYml0cztcbiAgICAgICAgcmV0dXJuIHRoaXMuRi5zdWIodGhpcy5GLnBvdyh0LCBtKSwgdGhpcy5GLm9uZSk7XG4gICAgfVxuXG4gICAgZXZhbHVhdGVMYWdyYW5nZVBvbHlub21pYWxzKGJpdHMsIHQpIHtcbiAgICAgICAgY29uc3QgbT0gMSA8PCBiaXRzO1xuICAgICAgICBjb25zdCB0bSA9IHRoaXMuRi5wb3codCwgbSk7XG4gICAgICAgIGNvbnN0IHU9IG5ldyBBcnJheShtKS5maWxsKHRoaXMuRi56ZXJvKTtcbiAgICAgICAgdGhpcy5fc2V0Um9vdHMoYml0cyk7XG4gICAgICAgIGNvbnN0IG9tZWdhID0gdGhpcy53W2JpdHNdO1xuXG4gICAgICAgIGlmICh0aGlzLkYuZXEodG0sIHRoaXMuRi5vbmUpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLkYuZXEodGhpcy5yb290c1tiaXRzXVswXSx0KSkgeyAvLyBpLmUuLCB0IGVxdWFscyBvbWVnYV5pXG4gICAgICAgICAgICAgICAgICAgIHVbaV0gPSB0aGlzLkYub25lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB6ID0gdGhpcy5GLnN1Yih0bSwgdGhpcy5GLm9uZSk7XG4gICAgICAgIC8vICAgICAgICBsZXQgbCA9IHRoaXMuRi5tdWwoeiwgIHRoaXMuRi5wb3codGhpcy5GLnR3b2ludiwgbSkpO1xuICAgICAgICBsZXQgbCA9IHRoaXMuRi5tdWwoeiwgIHRoaXMuRi5pbnYodGhpcy5GLmUobSkpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgIHVbaV0gPSB0aGlzLkYubXVsKGwsIHRoaXMuRi5pbnYodGhpcy5GLnN1Yih0LHRoaXMucm9vdHNbYml0c11baV0pKSk7XG4gICAgICAgICAgICBsID0gdGhpcy5GLm11bChsLCBvbWVnYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdTtcbiAgICB9XG5cbiAgICBsb2cyKFYpIHtcbiAgICAgICAgcmV0dXJuIGxvZzIkMihWKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvZzIkMiggViApXG57XG4gICAgcmV0dXJuKCAoICggViAmIDB4RkZGRjAwMDAgKSAhPT0gMCA/ICggViAmPSAweEZGRkYwMDAwLCAxNiApIDogMCApIHwgKCAoIFYgJiAweEZGMDBGRjAwICkgIT09IDAgPyAoIFYgJj0gMHhGRjAwRkYwMCwgOCApIDogMCApIHwgKCAoIFYgJiAweEYwRjBGMEYwICkgIT09IDAgPyAoIFYgJj0gMHhGMEYwRjBGMCwgNCApIDogMCApIHwgKCAoIFYgJiAweENDQ0NDQ0NDICkgIT09IDAgPyAoIFYgJj0gMHhDQ0NDQ0NDQywgMiApIDogMCApIHwgKCAoIFYgJiAweEFBQUFBQUFBICkgIT09IDAgKSApO1xufVxuXG5cbmZ1bmN0aW9uIF9fZmZ0JDEoUEYsIHBhbGwsIGJpdHMsIG9mZnNldCwgc3RlcCkge1xuXG4gICAgY29uc3QgbiA9IDEgPDwgYml0cztcbiAgICBpZiAobj09MSkge1xuICAgICAgICByZXR1cm4gWyBwYWxsW29mZnNldF0gXTtcbiAgICB9IGVsc2UgaWYgKG49PTIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFBGLkYuYWRkKHBhbGxbb2Zmc2V0XSwgcGFsbFtvZmZzZXQgKyBzdGVwXSksXG4gICAgICAgICAgICBQRi5GLnN1YihwYWxsW29mZnNldF0sIHBhbGxbb2Zmc2V0ICsgc3RlcF0pXTtcbiAgICB9XG5cbiAgICBjb25zdCBuZGl2MiA9IG4gPj4gMTtcbiAgICBjb25zdCBwMSA9IF9fZmZ0JDEoUEYsIHBhbGwsIGJpdHMtMSwgb2Zmc2V0LCBzdGVwKjIpO1xuICAgIGNvbnN0IHAyID0gX19mZnQkMShQRiwgcGFsbCwgYml0cy0xLCBvZmZzZXQrc3RlcCwgc3RlcCoyKTtcblxuICAgIGNvbnN0IG91dCA9IG5ldyBBcnJheShuKTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxuZGl2MjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IFBGLkYuYWRkKHAxW2ldLCBQRi5GLm11bChQRi5yb290c1tiaXRzXVtpXSwgcDJbaV0pKTtcbiAgICAgICAgb3V0W2krbmRpdjJdID0gUEYuRi5zdWIocDFbaV0sIFBGLkYubXVsKFBGLnJvb3RzW2JpdHNdW2ldLCBwMltpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59XG5cblxuZnVuY3Rpb24gX19mZnQyKFBGLCBwYWxsLCBiaXRzKSB7XG5cbiAgICBjb25zdCBuID0gMSA8PCBiaXRzO1xuICAgIGlmIChuPT0xKSB7XG4gICAgICAgIHJldHVybiBbIHBhbGxbMF0gXTtcbiAgICB9XG5cbiAgICBjb25zdCBuZGl2MiA9IG4gPj4gMTtcbiAgICBjb25zdCBwMSA9IF9fZmZ0MihQRiwgcGFsbC5zbGljZSgwLCBuZGl2MiksIGJpdHMtMSk7XG4gICAgY29uc3QgcDIgPSBfX2ZmdDIoUEYsIHBhbGwuc2xpY2UobmRpdjIpLCBiaXRzLTEpO1xuXG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgZm9yIChsZXQgaT0wOyBpPG5kaXYyOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gUEYuRi5hZGQocDFbaV0sIFBGLkYubXVsKFBGLnJvb3RzW2JpdHNdW2ldLCBwMltpXSkpO1xuICAgICAgICBvdXRbaStuZGl2Ml0gPSBQRi5GLnN1YihwMVtpXSwgUEYuRi5tdWwoUEYucm9vdHNbYml0c11baV0sIHAyW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuY29uc3QgX3JldlRhYmxlJDEgPSBbXTtcbmZvciAobGV0IGk9MDsgaTwyNTY7IGkrKykge1xuICAgIF9yZXZUYWJsZSQxW2ldID0gX3JldlNsb3ckMShpLCA4KTtcbn1cblxuZnVuY3Rpb24gX3JldlNsb3ckMShpZHgsIGJpdHMpIHtcbiAgICBsZXQgcmVzID0wO1xuICAgIGxldCBhID0gaWR4O1xuICAgIGZvciAobGV0IGk9MDsgaTxiaXRzOyBpKyspIHtcbiAgICAgICAgcmVzIDw8PSAxO1xuICAgICAgICByZXMgPSByZXMgfCAoYSAmMSk7XG4gICAgICAgIGEgPj49MTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcmV2KGlkeCwgYml0cykge1xuICAgIHJldHVybiAoXG4gICAgICAgIF9yZXZUYWJsZSQxW2lkeCA+Pj4gMjRdIHxcbiAgICAgICAgKF9yZXZUYWJsZSQxWyhpZHggPj4+IDE2KSAmIDB4RkZdIDw8IDgpIHxcbiAgICAgICAgKF9yZXZUYWJsZSQxWyhpZHggPj4+IDgpICYgMHhGRl0gPDwgMTYpIHxcbiAgICAgICAgKF9yZXZUYWJsZSQxW2lkeCAmIDB4RkZdIDw8IDI0KVxuICAgICkgPj4+ICgzMi1iaXRzKTtcbn1cblxuZnVuY3Rpb24gX19iaXRSZXZlcnNlKHAsIGJpdHMpIHtcbiAgICBmb3IgKGxldCBrPTA7IGs8cC5sZW5ndGg7IGsrKykge1xuICAgICAgICBjb25zdCByID0gcmV2KGssIGJpdHMpO1xuICAgICAgICBpZiAocj5rKSB7XG4gICAgICAgICAgICBjb25zdCB0bXA9IHBba107XG4gICAgICAgICAgICBwW2tdID0gcFtyXTtcbiAgICAgICAgICAgIHBbcl0gPSB0bXA7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwa2ltcyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuXG5cbmZ1bmN0aW9uIG11bFNjYWxhcihGLCBiYXNlLCBlKSB7XG4gICAgbGV0IHJlcztcblxuICAgIGlmIChpc1plcm8kMShlKSkgcmV0dXJuIEYuemVybztcblxuICAgIGNvbnN0IG4gPSBuYWYoZSk7XG5cbiAgICBpZiAobltuLmxlbmd0aC0xXSA9PSAxKSB7XG4gICAgICAgIHJlcyA9IGJhc2U7XG4gICAgfSBlbHNlIGlmIChuW24ubGVuZ3RoLTFdID09IC0xKSB7XG4gICAgICAgIHJlcyA9IEYubmVnKGJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmxhdWQgTkFGXCIpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGk9bi5sZW5ndGgtMjsgaT49MDsgaS0tKSB7XG5cbiAgICAgICAgcmVzID0gRi5kb3VibGUocmVzKTtcblxuICAgICAgICBpZiAobltpXSA9PSAxKSB7XG4gICAgICAgICAgICByZXMgPSBGLmFkZChyZXMsIGJhc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKG5baV0gPT0gLTEpIHtcbiAgICAgICAgICAgIHJlcyA9IEYuc3ViKHJlcywgYmFzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5cbi8qXG5leHBvcnRzLm11bFNjYWxhciA9IChGLCBiYXNlLCBlKSA9PntcbiAgICBsZXQgcmVzID0gRi56ZXJvO1xuICAgIGxldCByZW0gPSBiaWdJbnQoZSk7XG4gICAgbGV0IGV4cCA9IGJhc2U7XG5cbiAgICB3aGlsZSAoISByZW0uZXEoYmlnSW50Lnplcm8pKSB7XG4gICAgICAgIGlmIChyZW0uYW5kKGJpZ0ludC5vbmUpLmVxKGJpZ0ludC5vbmUpKSB7XG4gICAgICAgICAgICByZXMgPSBGLmFkZChyZXMsIGV4cCk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwID0gRi5kb3VibGUoZXhwKTtcbiAgICAgICAgcmVtID0gcmVtLnNoaWZ0UmlnaHQoMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn07XG4qL1xuXG5cbmZ1bmN0aW9uIGV4cChGLCBiYXNlLCBlKSB7XG5cbiAgICBpZiAoaXNaZXJvJDEoZSkpIHJldHVybiBGLm9uZTtcblxuICAgIGNvbnN0IG4gPSBiaXRzKGUpO1xuXG4gICAgaWYgKG4ubGVuZ3RoPT0wKSByZXR1cm4gRi5vbmU7XG5cbiAgICBsZXQgcmVzID0gYmFzZTtcblxuICAgIGZvciAobGV0IGk9bi5sZW5ndGgtMjsgaT49MDsgaS0tKSB7XG5cbiAgICAgICAgcmVzID0gRi5zcXVhcmUocmVzKTtcblxuICAgICAgICBpZiAobltpXSkge1xuICAgICAgICAgICAgcmVzID0gRi5tdWwocmVzLCBiYXNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIENoZWNrIGhlcmU6IGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZlxuXG5mdW5jdGlvbiBidWlsZFNxcnQgKEYpIHtcbiAgICBpZiAoKEYubSAlIDIpID09IDEpIHtcbiAgICAgICAgaWYgKGVxKG1vZChGLnAsIDQpLCAxICkpIHtcbiAgICAgICAgICAgIGlmIChlcShtb2QoRi5wLCA4KSwgMSApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVxKG1vZChGLnAsIDE2KSwgMSApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsZzdfbXVsbGVyKEYpO1xuICAgICAgICAgICAgICAgICAgICBhbGc1X3RvbmVsbGlTaGFua3MoRik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcShtb2QoRi5wLCAxNiksIDkgKSkge1xuICAgICAgICAgICAgICAgICAgICBhbGc0X2tvbmcoRik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgd2l0aG90IHNxcnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlcShtb2QoRi5wLCA4KSwgNSApKSB7XG4gICAgICAgICAgICAgICAgYWxnM19hdGtpbihGKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgd2l0aG90IHNxcnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXEobW9kKEYucCwgNCksIDMgKSkge1xuICAgICAgICAgICAgYWxnMl9zaGFua3MoRik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwbTJtb2Q0ID0gbW9kKHBvdyhGLnAsIEYubS8yKSwgNCk7XG4gICAgICAgIGlmIChwbTJtb2Q0ID09IDEpIHtcbiAgICAgICAgICAgIGFsZzEwX2FkaihGKTtcbiAgICAgICAgfSBlbHNlIGlmIChwbTJtb2Q0ID09IDMpIHtcbiAgICAgICAgICAgIGFsZzlfYWRqKEYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxnOF9jb21wbGV4KEYpO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gYWxnNV90b25lbGxpU2hhbmtzKEYpIHtcbiAgICBGLnNxcnRfcSA9IHBvdyhGLnAsIEYubSk7XG5cbiAgICBGLnNxcnRfcyA9IDA7XG4gICAgRi5zcXJ0X3QgPSBzdWIoRi5zcXJ0X3EsIDEpO1xuXG4gICAgd2hpbGUgKCFpc09kZCQ1KEYuc3FydF90KSkge1xuICAgICAgICBGLnNxcnRfcyA9IEYuc3FydF9zICsgMTtcbiAgICAgICAgRi5zcXJ0X3QgPSBkaXYoRi5zcXJ0X3QsIDIpO1xuICAgIH1cblxuICAgIGxldCBjMCA9IEYub25lO1xuXG4gICAgd2hpbGUgKEYuZXEoYzAsIEYub25lKSkge1xuICAgICAgICBjb25zdCBjID0gRi5yYW5kb20oKTtcbiAgICAgICAgRi5zcXJ0X3ogPSBGLnBvdyhjLCBGLnNxcnRfdCk7XG4gICAgICAgIGMwID0gRi5wb3coRi5zcXJ0X3osIDIgKiogKEYuc3FydF9zLTEpICk7XG4gICAgfVxuXG4gICAgRi5zcXJ0X3RtMWQyID0gZGl2KHN1YihGLnNxcnRfdCwgMSksMik7XG5cbiAgICBGLnNxcnQgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIGNvbnN0IEY9dGhpcztcbiAgICAgICAgaWYgKEYuaXNaZXJvKGEpKSByZXR1cm4gRi56ZXJvO1xuICAgICAgICBsZXQgdyA9IEYucG93KGEsIEYuc3FydF90bTFkMik7XG4gICAgICAgIGNvbnN0IGEwID0gRi5wb3coIEYubXVsKEYuc3F1YXJlKHcpLCBhKSwgMiAqKiAoRi5zcXJ0X3MtMSkgKTtcbiAgICAgICAgaWYgKEYuZXEoYTAsIEYubmVnb25lKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgbGV0IHYgPSBGLnNxcnRfcztcbiAgICAgICAgbGV0IHggPSBGLm11bChhLCB3KTtcbiAgICAgICAgbGV0IGIgPSBGLm11bCh4LCB3KTtcbiAgICAgICAgbGV0IHogPSBGLnNxcnRfejtcbiAgICAgICAgd2hpbGUgKCFGLmVxKGIsIEYub25lKSkge1xuICAgICAgICAgICAgbGV0IGIyayA9IEYuc3F1YXJlKGIpO1xuICAgICAgICAgICAgbGV0IGs9MTtcbiAgICAgICAgICAgIHdoaWxlICghRi5lcShiMmssIEYub25lKSkge1xuICAgICAgICAgICAgICAgIGIyayA9IEYuc3F1YXJlKGIyayk7XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ID0gejtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTx2LWstMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdyA9IEYuc3F1YXJlKHcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeiA9IEYuc3F1YXJlKHcpO1xuICAgICAgICAgICAgYiA9IEYubXVsKGIsIHopO1xuICAgICAgICAgICAgeCA9IEYubXVsKHgsIHcpO1xuICAgICAgICAgICAgdiA9IGs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEYuZ2VxKHgsIEYuemVybykgPyB4IDogRi5uZWcoeCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWxnNF9rb25nKEYpIHtcbiAgICBGLnNxcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3FydCBhbGcgNCBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWxnM19hdGtpbihGKSB7XG4gICAgRi5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNxcnQgYWxnIDMgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFsZzJfc2hhbmtzKEYpIHtcblxuICAgIEYuc3FydF9xID0gcG93KEYucCwgRi5tKTtcbiAgICBGLnNxcnRfZTEgPSBkaXYoIHN1YihGLnNxcnRfcSwgMykgLCA0KTtcblxuICAgIEYuc3FydCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKGEpKSByZXR1cm4gdGhpcy56ZXJvO1xuXG4gICAgICAgIC8vIFRlc3QgdGhhdCBoYXZlIHNvbHV0aW9uXG4gICAgICAgIGNvbnN0IGExID0gdGhpcy5wb3coYSwgdGhpcy5zcXJ0X2UxKTtcblxuICAgICAgICBjb25zdCBhMCA9IHRoaXMubXVsKHRoaXMuc3F1YXJlKGExKSwgYSk7XG5cbiAgICAgICAgaWYgKCB0aGlzLmVxKGEwLCB0aGlzLm5lZ29uZSkgKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCB4ID0gdGhpcy5tdWwoYTEsIGEpO1xuXG4gICAgICAgIHJldHVybiBGLmdlcSh4LCBGLnplcm8pID8geCA6IEYubmVnKHgpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFsZzEwX2FkaihGKSB7XG4gICAgRi5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNxcnQgYWxnIDEwIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhbGc5X2FkaihGKSB7XG4gICAgRi5zcXJ0X3EgPSBwb3coRi5wLCBGLm0vMik7XG4gICAgRi5zcXJ0X2UzNCA9IGRpdiggc3ViKEYuc3FydF9xLCAzKSAsIDQpO1xuICAgIEYuc3FydF9lMTIgPSBkaXYoIHN1YihGLnNxcnRfcSwgMSkgLCAyKTtcblxuICAgIEYuZnJvYmVuaXVzID0gZnVuY3Rpb24obiwgeCkge1xuICAgICAgICBpZiAoKG4lMikgPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIEYuY29uanVnYXRlKHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRi5zcXJ0ID0gZnVuY3Rpb24oYSkge1xuICAgICAgICBjb25zdCBGID0gdGhpcztcbiAgICAgICAgY29uc3QgYTEgPSBGLnBvdyhhLCBGLnNxcnRfZTM0KTtcbiAgICAgICAgY29uc3QgYWxmYSA9IEYubXVsKEYuc3F1YXJlKGExKSwgYSk7XG4gICAgICAgIGNvbnN0IGEwID0gRi5tdWwoRi5mcm9iZW5pdXMoMSwgYWxmYSksIGFsZmEpO1xuICAgICAgICBpZiAoRi5lcShhMCwgRi5uZWdvbmUpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgeDAgPSBGLm11bChhMSwgYSk7XG4gICAgICAgIGxldCB4O1xuICAgICAgICBpZiAoRi5lcShhbGZhLCBGLm5lZ29uZSkpIHtcbiAgICAgICAgICAgIHggPSBGLm11bCh4MCwgW0YuRi56ZXJvLCBGLkYub25lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBiID0gRi5wb3coRi5hZGQoRi5vbmUsIGFsZmEpLCBGLnNxcnRfZTEyKTtcbiAgICAgICAgICAgIHggPSBGLm11bChiLCB4MCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEYuZ2VxKHgsIEYuemVybykgPyB4IDogRi5uZWcoeCk7XG4gICAgfTtcbn1cblxuXG5mdW5jdGlvbiBhbGc4X2NvbXBsZXgoRikge1xuICAgIEYuc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcXJ0IGFsZyA4IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBxdWFydGVyUm91bmQoc3QsIGEsIGIsIGMsIGQpIHtcblxuICAgIHN0W2FdID0gKHN0W2FdICsgc3RbYl0pID4+PiAwO1xuICAgIHN0W2RdID0gKHN0W2RdIF4gc3RbYV0pID4+PiAwO1xuICAgIHN0W2RdID0gKChzdFtkXSA8PCAxNikgfCAoKHN0W2RdPj4+MTYpICYgMHhGRkZGKSkgPj4+IDA7XG5cbiAgICBzdFtjXSA9IChzdFtjXSArIHN0W2RdKSA+Pj4gMDtcbiAgICBzdFtiXSA9IChzdFtiXSBeIHN0W2NdKSA+Pj4gMDtcbiAgICBzdFtiXSA9ICgoc3RbYl0gPDwgMTIpIHwgKChzdFtiXT4+PjIwKSAmIDB4RkZGKSkgPj4+IDA7XG5cbiAgICBzdFthXSA9IChzdFthXSArIHN0W2JdKSA+Pj4gMDtcbiAgICBzdFtkXSA9IChzdFtkXSBeIHN0W2FdKSA+Pj4gMDtcbiAgICBzdFtkXSA9ICgoc3RbZF0gPDwgOCkgfCAoKHN0W2RdPj4+MjQpICYgMHhGRikpID4+PiAwO1xuXG4gICAgc3RbY10gPSAoc3RbY10gKyBzdFtkXSkgPj4+IDA7XG4gICAgc3RbYl0gPSAoc3RbYl0gXiBzdFtjXSkgPj4+IDA7XG4gICAgc3RbYl0gPSAoKHN0W2JdIDw8IDcpIHwgKChzdFtiXT4+PjI1KSAmIDB4N0YpKSA+Pj4gMDtcbn1cblxuZnVuY3Rpb24gZG91YmxlUm91bmQoc3QpIHtcbiAgICBxdWFydGVyUm91bmQoc3QsIDAsIDQsIDgsMTIpO1xuICAgIHF1YXJ0ZXJSb3VuZChzdCwgMSwgNSwgOSwxMyk7XG4gICAgcXVhcnRlclJvdW5kKHN0LCAyLCA2LDEwLDE0KTtcbiAgICBxdWFydGVyUm91bmQoc3QsIDMsIDcsMTEsMTUpO1xuXG4gICAgcXVhcnRlclJvdW5kKHN0LCAwLCA1LDEwLDE1KTtcbiAgICBxdWFydGVyUm91bmQoc3QsIDEsIDYsMTEsMTIpO1xuICAgIHF1YXJ0ZXJSb3VuZChzdCwgMiwgNywgOCwxMyk7XG4gICAgcXVhcnRlclJvdW5kKHN0LCAzLCA0LCA5LDE0KTtcbn1cblxuY2xhc3MgQ2hhQ2hhIHtcblxuICAgIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICAgICAgc2VlZCA9IHNlZWQgfHwgWzAsMCwwLDAsMCwwLDAsMF07XG4gICAgICAgIHRoaXMuc3RhdGUgPSBbXG4gICAgICAgICAgICAweDYxNzA3ODY1LFxuICAgICAgICAgICAgMHgzMzIwNjQ2RSxcbiAgICAgICAgICAgIDB4Nzk2MjJEMzIsXG4gICAgICAgICAgICAweDZCMjA2NTc0LFxuICAgICAgICAgICAgc2VlZFswXSxcbiAgICAgICAgICAgIHNlZWRbMV0sXG4gICAgICAgICAgICBzZWVkWzJdLFxuICAgICAgICAgICAgc2VlZFszXSxcbiAgICAgICAgICAgIHNlZWRbNF0sXG4gICAgICAgICAgICBzZWVkWzVdLFxuICAgICAgICAgICAgc2VlZFs2XSxcbiAgICAgICAgICAgIHNlZWRbN10sXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuaWR4ID0gMTY7XG4gICAgICAgIHRoaXMuYnVmZiA9IG5ldyBBcnJheSgxNik7XG4gICAgfVxuXG4gICAgbmV4dFUzMigpIHtcbiAgICAgICAgaWYgKHRoaXMuaWR4ID09IDE2KSB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmW3RoaXMuaWR4KytdO1xuICAgIH1cblxuICAgIG5leHRVNjQoKSB7XG4gICAgICAgIHJldHVybiBhZGQobXVsKHRoaXMubmV4dFUzMigpLCAweDEwMDAwMDAwMCksIHRoaXMubmV4dFUzMigpKTtcbiAgICB9XG5cbiAgICBuZXh0Qm9vbCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm5leHRVMzIoKSAmIDEpID09IDE7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvLyBDb3B5IHRoZSBzdGF0ZVxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8MTY7IGkrKykgdGhpcy5idWZmW2ldID0gdGhpcy5zdGF0ZVtpXTtcblxuICAgICAgICAvLyBBcHBseSB0aGUgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwxMDsgaSsrKSBkb3VibGVSb3VuZCh0aGlzLmJ1ZmYpO1xuXG4gICAgICAgIC8vIEFkZCB0byB0aGUgaW5pdGlhbFxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8MTY7IGkrKykgdGhpcy5idWZmW2ldID0gKHRoaXMuYnVmZltpXSArIHRoaXMuc3RhdGVbaV0pID4+PiAwO1xuXG4gICAgICAgIHRoaXMuaWR4ID0gMDtcblxuICAgICAgICB0aGlzLnN0YXRlWzEyXSA9ICh0aGlzLnN0YXRlWzEyXSArIDEpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZVsxMl0gIT0gMCkgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlWzEzXSA9ICh0aGlzLnN0YXRlWzEzXSArIDEpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZVsxM10gIT0gMCkgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlWzE0XSA9ICh0aGlzLnN0YXRlWzE0XSArIDEpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZVsxNF0gIT0gMCkgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlWzE1XSA9ICh0aGlzLnN0YXRlWzE1XSArIDEpID4+PiAwO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tQnl0ZXMobikge1xuICAgIGxldCBhcnJheSA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgIHsgLy8gQnJvd3NlclxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMuY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiKSB7IC8vIFN1cHBvcnRlZFxuICAgICAgICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZmFsbGJhY2tcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IChNYXRoLnJhbmRvbSgpKjQyOTQ5NjcyOTYpPj4+MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGdldFJhbmRvbVNlZWQoKSB7XG4gICAgY29uc3QgYXJyID0gZ2V0UmFuZG9tQnl0ZXMoMzIpO1xuICAgIGNvbnN0IGFyclYgPSBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlcik7XG4gICAgY29uc3Qgc2VlZCA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTw4OyBpKyspIHtcbiAgICAgICAgc2VlZC5wdXNoKGFyclZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VlZDtcbn1cblxubGV0IHRocmVhZFJuZyA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldFRocmVhZFJuZygpIHtcbiAgICBpZiAodGhyZWFkUm5nKSByZXR1cm4gdGhyZWFkUm5nO1xuICAgIHRocmVhZFJuZyA9IG5ldyBDaGFDaGEoZ2V0UmFuZG9tU2VlZCgpKTtcbiAgICByZXR1cm4gdGhyZWFkUm5nO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKlxuICAgIFRoaXMgbGlicmFyeSBkb2VzIG9wZXJhdGlvbnMgb24gcG9seW5vbWlhbHMgd2l0aCBjb2VmZmljaWVudHMgaW4gYSBmaWVsZCBGLlxuXG4gICAgQSBwb2x5bm9taWFsIFAoeCkgPSBwMCArIHAxICogeCArIHAyICogeF4yICsgLi4uICsgcG4gKiB4Xm4gIGlzIHJlcHJlc2VudGVkXG4gICAgYnkgdGhlIGFycmF5IFsgcDAsIHAxLCBwMiwgLi4uICwgcG4gXS5cbiAqL1xuXG5jbGFzcyBGRlQge1xuICAgIGNvbnN0cnVjdG9yIChHLCBGLCBvcE11bEdGKSB7XG4gICAgICAgIHRoaXMuRiA9IEY7XG4gICAgICAgIHRoaXMuRyA9IEc7XG4gICAgICAgIHRoaXMub3BNdWxHRiA9IG9wTXVsR0Y7XG5cbiAgICAgICAgbGV0IHJlbSA9IEYuc3FydF90IHx8IEYudDtcbiAgICAgICAgbGV0IHMgPSBGLnNxcnRfcyB8fCBGLnM7XG5cbiAgICAgICAgbGV0IG5xciA9IEYub25lO1xuICAgICAgICB3aGlsZSAoRi5lcShGLnBvdyhucXIsIEYuaGFsZiksIEYub25lKSkgbnFyID0gRi5hZGQobnFyLCBGLm9uZSk7XG5cbiAgICAgICAgdGhpcy53ID0gbmV3IEFycmF5KHMrMSk7XG4gICAgICAgIHRoaXMud2kgPSBuZXcgQXJyYXkocysxKTtcbiAgICAgICAgdGhpcy53W3NdID0gdGhpcy5GLnBvdyhucXIsIHJlbSk7XG4gICAgICAgIHRoaXMud2lbc10gPSB0aGlzLkYuaW52KHRoaXMud1tzXSk7XG5cbiAgICAgICAgbGV0IG49cy0xO1xuICAgICAgICB3aGlsZSAobj49MCkge1xuICAgICAgICAgICAgdGhpcy53W25dID0gdGhpcy5GLnNxdWFyZSh0aGlzLndbbisxXSk7XG4gICAgICAgICAgICB0aGlzLndpW25dID0gdGhpcy5GLnNxdWFyZSh0aGlzLndpW24rMV0pO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLnJvb3RzID0gW107XG4gICAgICAgIC8qXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwxNjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgciA9IHRoaXMuRi5vbmU7XG4gICAgICAgICAgICBuID0gMSA8PCBpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdHNpID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG47IGorKykge1xuICAgICAgICAgICAgICAgIHJvb3RzaVtqXSA9IHI7XG4gICAgICAgICAgICAgICAgciA9IHRoaXMuRi5tdWwociwgdGhpcy53W2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yb290cy5wdXNoKHJvb3RzaSk7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2V0Um9vdHMoTWF0aC5taW4ocywgMTUpKTtcbiAgICB9XG5cbiAgICBfc2V0Um9vdHMobikge1xuICAgICAgICBmb3IgKGxldCBpPW47IChpPj0wKSAmJiAoIXRoaXMucm9vdHNbaV0pOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCByID0gdGhpcy5GLm9uZTtcbiAgICAgICAgICAgIGNvbnN0IG5yb290cyA9IDEgPDwgaTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RzaSA9IG5ldyBBcnJheShucm9vdHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5yb290czsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNpW2pdID0gcjtcbiAgICAgICAgICAgICAgICByID0gdGhpcy5GLm11bChyLCB0aGlzLndbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJvb3RzW2ldID0gcm9vdHNpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmZ0KHApIHtcbiAgICAgICAgaWYgKHAubGVuZ3RoIDw9IDEpIHJldHVybiBwO1xuICAgICAgICBjb25zdCBiaXRzID0gbG9nMiQxKHAubGVuZ3RoLTEpKzE7XG4gICAgICAgIHRoaXMuX3NldFJvb3RzKGJpdHMpO1xuXG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHM7XG4gICAgICAgIGlmIChwLmxlbmd0aCAhPSBtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplIG11c3QgYmUgbXVsdGlwbGUgb2YgMlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBfX2ZmdCh0aGlzLCBwLCBiaXRzLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZmZ0KHApIHtcblxuICAgICAgICBpZiAocC5sZW5ndGggPD0gMSkgcmV0dXJuIHA7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyJDEocC5sZW5ndGgtMSkrMTtcbiAgICAgICAgdGhpcy5fc2V0Um9vdHMoYml0cyk7XG4gICAgICAgIGNvbnN0IG0gPSAxIDw8IGJpdHM7XG4gICAgICAgIGlmIChwLmxlbmd0aCAhPSBtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplIG11c3QgYmUgbXVsdGlwbGUgb2YgMlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSAgX19mZnQodGhpcywgcCwgYml0cywgMCwgMSk7XG4gICAgICAgIGNvbnN0IHR3b2ludm0gPSB0aGlzLkYuaW52KCB0aGlzLkYubXVsU2NhbGFyKHRoaXMuRi5vbmUsIG0pICk7XG4gICAgICAgIGNvbnN0IHJlc24gPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgIHJlc25baV0gPSB0aGlzLm9wTXVsR0YocmVzWyhtLWkpJW1dLCB0d29pbnZtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNuO1xuICAgIH1cblxuXG59XG5cbmZ1bmN0aW9uIGxvZzIkMSggViApXG57XG4gICAgcmV0dXJuKCAoICggViAmIDB4RkZGRjAwMDAgKSAhPT0gMCA/ICggViAmPSAweEZGRkYwMDAwLCAxNiApIDogMCApIHwgKCAoIFYgJiAweEZGMDBGRjAwICkgIT09IDAgPyAoIFYgJj0gMHhGRjAwRkYwMCwgOCApIDogMCApIHwgKCAoIFYgJiAweEYwRjBGMEYwICkgIT09IDAgPyAoIFYgJj0gMHhGMEYwRjBGMCwgNCApIDogMCApIHwgKCAoIFYgJiAweENDQ0NDQ0NDICkgIT09IDAgPyAoIFYgJj0gMHhDQ0NDQ0NDQywgMiApIDogMCApIHwgKCAoIFYgJiAweEFBQUFBQUFBICkgIT09IDAgKSApO1xufVxuXG5cbmZ1bmN0aW9uIF9fZmZ0KFBGLCBwYWxsLCBiaXRzLCBvZmZzZXQsIHN0ZXApIHtcblxuICAgIGNvbnN0IG4gPSAxIDw8IGJpdHM7XG4gICAgaWYgKG49PTEpIHtcbiAgICAgICAgcmV0dXJuIFsgcGFsbFtvZmZzZXRdIF07XG4gICAgfSBlbHNlIGlmIChuPT0yKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBQRi5HLmFkZChwYWxsW29mZnNldF0sIHBhbGxbb2Zmc2V0ICsgc3RlcF0pLFxuICAgICAgICAgICAgUEYuRy5zdWIocGFsbFtvZmZzZXRdLCBwYWxsW29mZnNldCArIHN0ZXBdKV07XG4gICAgfVxuXG4gICAgY29uc3QgbmRpdjIgPSBuID4+IDE7XG4gICAgY29uc3QgcDEgPSBfX2ZmdChQRiwgcGFsbCwgYml0cy0xLCBvZmZzZXQsIHN0ZXAqMik7XG4gICAgY29uc3QgcDIgPSBfX2ZmdChQRiwgcGFsbCwgYml0cy0xLCBvZmZzZXQrc3RlcCwgc3RlcCoyKTtcblxuICAgIGNvbnN0IG91dCA9IG5ldyBBcnJheShuKTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxuZGl2MjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IFBGLkcuYWRkKHAxW2ldLCBQRi5vcE11bEdGKHAyW2ldLCBQRi5yb290c1tiaXRzXVtpXSkpO1xuICAgICAgICBvdXRbaStuZGl2Ml0gPSBQRi5HLnN1YihwMVtpXSwgUEYub3BNdWxHRihwMltpXSwgUEYucm9vdHNbYml0c11baV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKiBnbG9iYWwgQmlnSW50ICovXG5cbmNsYXNzIFpxRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKHApIHtcbiAgICAgICAgdGhpcy50eXBlPVwiRjFcIjtcbiAgICAgICAgdGhpcy5vbmUgPSBCaWdJbnQoMSk7XG4gICAgICAgIHRoaXMuemVybyA9IEJpZ0ludCgwKTtcbiAgICAgICAgdGhpcy5wID0gQmlnSW50KHApO1xuICAgICAgICB0aGlzLm0gPSAxO1xuICAgICAgICB0aGlzLm5lZ29uZSA9IHRoaXMucC10aGlzLm9uZTtcbiAgICAgICAgdGhpcy50d28gPSBCaWdJbnQoMik7XG4gICAgICAgIHRoaXMuaGFsZiA9IHRoaXMucCA+PiB0aGlzLm9uZTtcbiAgICAgICAgdGhpcy5iaXRMZW5ndGggPSBiaXRMZW5ndGgkNih0aGlzLnApO1xuICAgICAgICB0aGlzLm1hc2sgPSAodGhpcy5vbmUgPDwgQmlnSW50KHRoaXMuYml0TGVuZ3RoKSkgLSB0aGlzLm9uZTtcblxuICAgICAgICB0aGlzLm42NCA9IE1hdGguZmxvb3IoKHRoaXMuYml0TGVuZ3RoIC0gMSkgLyA2NCkrMTtcbiAgICAgICAgdGhpcy5uMzIgPSB0aGlzLm42NCoyO1xuICAgICAgICB0aGlzLm44ID0gdGhpcy5uNjQqODtcbiAgICAgICAgdGhpcy5SID0gdGhpcy5lKHRoaXMub25lIDw8IEJpZ0ludCh0aGlzLm42NCo2NCkpO1xuICAgICAgICB0aGlzLlJpID0gdGhpcy5pbnYodGhpcy5SKTtcblxuICAgICAgICBjb25zdCBlID0gdGhpcy5uZWdvbmUgPj4gdGhpcy5vbmU7XG4gICAgICAgIHRoaXMubnFyID0gdGhpcy50d287XG4gICAgICAgIGxldCByID0gdGhpcy5wb3codGhpcy5ucXIsIGUpO1xuICAgICAgICB3aGlsZSAoIXRoaXMuZXEociwgdGhpcy5uZWdvbmUpKSB7XG4gICAgICAgICAgICB0aGlzLm5xciA9IHRoaXMubnFyICsgdGhpcy5vbmU7XG4gICAgICAgICAgICByID0gdGhpcy5wb3codGhpcy5ucXIsIGUpO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLnMgPSAwO1xuICAgICAgICB0aGlzLnQgPSB0aGlzLm5lZ29uZTtcblxuICAgICAgICB3aGlsZSAoKHRoaXMudCAmIHRoaXMub25lKSA9PSB0aGlzLnplcm8pIHtcbiAgICAgICAgICAgIHRoaXMucyA9IHRoaXMucyArIDE7XG4gICAgICAgICAgICB0aGlzLnQgPSB0aGlzLnQgPj4gdGhpcy5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5xcl90b190ID0gdGhpcy5wb3codGhpcy5ucXIsIHRoaXMudCk7XG5cbiAgICAgICAgYnVpbGRTcXJ0KHRoaXMpO1xuXG4gICAgICAgIHRoaXMuRkZUID0gbmV3IEZGVCh0aGlzLCB0aGlzLCB0aGlzLm11bC5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLmZmdCA9IHRoaXMuRkZULmZmdC5iaW5kKHRoaXMuRkZUKTtcbiAgICAgICAgdGhpcy5pZmZ0ID0gdGhpcy5GRlQuaWZmdC5iaW5kKHRoaXMuRkZUKTtcbiAgICAgICAgdGhpcy53ID0gdGhpcy5GRlQudztcbiAgICAgICAgdGhpcy53aSA9IHRoaXMuRkZULndpOyBcbiAgICBcbiAgICAgICAgdGhpcy5zaGlmdCA9IHRoaXMuc3F1YXJlKHRoaXMubnFyKTtcbiAgICAgICAgdGhpcy5rID0gdGhpcy5leHAodGhpcy5ucXIsIDIqKnRoaXMucyk7XG4gICAgfVxuXG4gICAgZShhLGIpIHtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICByZXMgPSBCaWdJbnQoYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYj09MTYpIHtcbiAgICAgICAgICAgIHJlcyA9IEJpZ0ludChcIjB4XCIrYSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcyA8IDApIHtcbiAgICAgICAgICAgIGxldCBucmVzID0gLXJlcztcbiAgICAgICAgICAgIGlmIChucmVzID49IHRoaXMucCkgbnJlcyA9IG5yZXMgJSB0aGlzLnA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wIC0gbnJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAocmVzPj0gdGhpcy5wKSA/IHJlcyV0aGlzLnAgOiByZXM7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGFkZChhLCBiKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGEgKyBiO1xuICAgICAgICByZXR1cm4gcmVzID49IHRoaXMucCA/IHJlcy10aGlzLnAgOiByZXM7XG4gICAgfVxuXG4gICAgc3ViKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhID49IGIpID8gYS1iIDogdGhpcy5wLWIrYTtcbiAgICB9XG5cbiAgICBuZWcoYSkge1xuICAgICAgICByZXR1cm4gYSA/IHRoaXMucC1hIDogYTtcbiAgICB9XG5cbiAgICBtdWwoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEqYikldGhpcy5wO1xuICAgIH1cblxuICAgIG11bFNjYWxhcihiYXNlLCBzKSB7XG4gICAgICAgIHJldHVybiAoYmFzZSAqIHRoaXMuZShzKSkgJSB0aGlzLnA7XG4gICAgfVxuXG4gICAgc3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIChhKmEpICUgdGhpcy5wO1xuICAgIH1cblxuICAgIGVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGE9PWI7XG4gICAgfVxuXG4gICAgbmVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEhPWI7XG4gICAgfVxuXG4gICAgbHQoYSwgYikge1xuICAgICAgICBjb25zdCBhYSA9IChhID4gdGhpcy5oYWxmKSA/IGEgLSB0aGlzLnAgOiBhO1xuICAgICAgICBjb25zdCBiYiA9IChiID4gdGhpcy5oYWxmKSA/IGIgLSB0aGlzLnAgOiBiO1xuICAgICAgICByZXR1cm4gYWEgPCBiYjtcbiAgICB9XG5cbiAgICBndChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFhID0gKGEgPiB0aGlzLmhhbGYpID8gYSAtIHRoaXMucCA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gKGIgPiB0aGlzLmhhbGYpID8gYiAtIHRoaXMucCA6IGI7XG4gICAgICAgIHJldHVybiBhYSA+IGJiO1xuICAgIH1cblxuICAgIGxlcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFhID0gKGEgPiB0aGlzLmhhbGYpID8gYSAtIHRoaXMucCA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gKGIgPiB0aGlzLmhhbGYpID8gYiAtIHRoaXMucCA6IGI7XG4gICAgICAgIHJldHVybiBhYSA8PSBiYjtcbiAgICB9XG5cbiAgICBnZXEoYSwgYikge1xuICAgICAgICBjb25zdCBhYSA9IChhID4gdGhpcy5oYWxmKSA/IGEgLSB0aGlzLnAgOiBhO1xuICAgICAgICBjb25zdCBiYiA9IChiID4gdGhpcy5oYWxmKSA/IGIgLSB0aGlzLnAgOiBiO1xuICAgICAgICByZXR1cm4gYWEgPj0gYmI7XG4gICAgfVxuXG4gICAgZGl2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKGEsIHRoaXMuaW52KGIpKTtcbiAgICB9XG5cbiAgICBpZGl2KGEsIGIpIHtcbiAgICAgICAgaWYgKCFiKSB0aHJvdyBuZXcgRXJyb3IoXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xuICAgICAgICByZXR1cm4gYSAvIGI7XG4gICAgfVxuXG4gICAgaW52KGEpIHtcbiAgICAgICAgaWYgKCFhKSB0aHJvdyBuZXcgRXJyb3IoXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xuXG4gICAgICAgIGxldCB0ID0gdGhpcy56ZXJvO1xuICAgICAgICBsZXQgciA9IHRoaXMucDtcbiAgICAgICAgbGV0IG5ld3QgPSB0aGlzLm9uZTtcbiAgICAgICAgbGV0IG5ld3IgPSBhICUgdGhpcy5wO1xuICAgICAgICB3aGlsZSAobmV3cikge1xuICAgICAgICAgICAgbGV0IHEgPSByL25ld3I7XG4gICAgICAgICAgICBbdCwgbmV3dF0gPSBbbmV3dCwgdC1xKm5ld3RdO1xuICAgICAgICAgICAgW3IsIG5ld3JdID0gW25ld3IsIHItcSpuZXdyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodDx0aGlzLnplcm8pIHQgKz0gdGhpcy5wO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICBtb2QoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAlIGI7XG4gICAgfVxuXG4gICAgcG93KGIsIGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cCh0aGlzLCBiLCBlKTtcbiAgICB9XG5cbiAgICBleHAoYiwgZSkge1xuICAgICAgICByZXR1cm4gZXhwKHRoaXMsIGIsIGUpO1xuICAgIH1cblxuICAgIGJhbmQoYSwgYikge1xuICAgICAgICBjb25zdCByZXMgPSAgKChhICYgYikgJiB0aGlzLm1hc2spO1xuICAgICAgICByZXR1cm4gcmVzID49IHRoaXMucCA/IHJlcy10aGlzLnAgOiByZXM7XG4gICAgfVxuXG4gICAgYm9yKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gICgoYSB8IGIpICYgdGhpcy5tYXNrKTtcbiAgICAgICAgcmV0dXJuIHJlcyA+PSB0aGlzLnAgPyByZXMtdGhpcy5wIDogcmVzO1xuICAgIH1cblxuICAgIGJ4b3IoYSwgYikge1xuICAgICAgICBjb25zdCByZXMgPSAgKChhIF4gYikgJiB0aGlzLm1hc2spO1xuICAgICAgICByZXR1cm4gcmVzID49IHRoaXMucCA/IHJlcy10aGlzLnAgOiByZXM7XG4gICAgfVxuXG4gICAgYm5vdChhKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGEgXiB0aGlzLm1hc2s7XG4gICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5wID8gcmVzLXRoaXMucCA6IHJlcztcbiAgICB9XG5cbiAgICBzaGwoYSwgYikge1xuICAgICAgICBpZiAoTnVtYmVyKGIpIDwgdGhpcy5iaXRMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IChhIDw8IGIpICYgdGhpcy5tYXNrO1xuICAgICAgICAgICAgcmV0dXJuIHJlcyA+PSB0aGlzLnAgPyByZXMtdGhpcy5wIDogcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmIgPSB0aGlzLnAgLSBiO1xuICAgICAgICAgICAgaWYgKE51bWJlcihuYikgPCB0aGlzLmJpdExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID4+IG5iO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2hyKGEsIGIpIHtcbiAgICAgICAgaWYgKE51bWJlcihiKSA8IHRoaXMuYml0TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYSA+PiBiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmIgPSB0aGlzLnAgLSBiO1xuICAgICAgICAgICAgaWYgKE51bWJlcihuYikgPCB0aGlzLmJpdExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IChhIDw8IG5iKSAmIHRoaXMubWFzaztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzID49IHRoaXMucCA/IHJlcy10aGlzLnAgOiByZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGFuZChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYSAmJiBiKSA/IHRoaXMub25lIDogdGhpcy56ZXJvO1xuICAgIH1cblxuICAgIGxvcihhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYSB8fCBiKSA/IHRoaXMub25lIDogdGhpcy56ZXJvO1xuICAgIH1cblxuICAgIGxub3QoYSkge1xuICAgICAgICByZXR1cm4gKGEpID8gdGhpcy56ZXJvIDogdGhpcy5vbmU7XG4gICAgfVxuXG4gICAgc3FydF9vbGQobikge1xuXG4gICAgICAgIGlmIChuID09IHRoaXMuemVybykgcmV0dXJuIHRoaXMuemVybztcblxuICAgICAgICAvLyBUZXN0IHRoYXQgaGF2ZSBzb2x1dGlvblxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnBvdyhuLCB0aGlzLm5lZ29uZSA+PiB0aGlzLm9uZSk7XG4gICAgICAgIGlmICggcmVzICE9IHRoaXMub25lICkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgbGV0IG0gPSB0aGlzLnM7XG4gICAgICAgIGxldCBjID0gdGhpcy5ucXJfdG9fdDtcbiAgICAgICAgbGV0IHQgPSB0aGlzLnBvdyhuLCB0aGlzLnQpO1xuICAgICAgICBsZXQgciA9IHRoaXMucG93KG4sIHRoaXMuYWRkKHRoaXMudCwgdGhpcy5vbmUpID4+IHRoaXMub25lICk7XG5cbiAgICAgICAgd2hpbGUgKCB0ICE9IHRoaXMub25lICkge1xuICAgICAgICAgICAgbGV0IHNxID0gdGhpcy5zcXVhcmUodCk7XG4gICAgICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgICAgICB3aGlsZSAoc3EgIT0gdGhpcy5vbmUgKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHNxID0gdGhpcy5zcXVhcmUoc3EpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiID0gYyBeIG0taS0xXG4gICAgICAgICAgICBsZXQgYiA9IGM7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8IG0taS0xOyBqICsrKSBiID0gdGhpcy5zcXVhcmUoYik7XG5cbiAgICAgICAgICAgIG0gPSBpO1xuICAgICAgICAgICAgYyA9IHRoaXMuc3F1YXJlKGIpO1xuICAgICAgICAgICAgdCA9IHRoaXMubXVsKHQsIGMpO1xuICAgICAgICAgICAgciA9IHRoaXMubXVsKHIsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIgPiAodGhpcy5wID4+IHRoaXMub25lKSkge1xuICAgICAgICAgICAgciA9IHRoaXMubmVnKHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplKGEsIGIpIHtcbiAgICAgICAgYSA9IEJpZ0ludChhLGIpO1xuICAgICAgICBpZiAoYSA8IDApIHtcbiAgICAgICAgICAgIGxldCBuYSA9IC1hO1xuICAgICAgICAgICAgaWYgKG5hID49IHRoaXMucCkgbmEgPSBuYSAlIHRoaXMucDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnAgLSBuYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoYT49IHRoaXMucCkgPyBhJXRoaXMucCA6IGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByYW5kb20oKSB7XG4gICAgICAgIGNvbnN0IG5CeXRlcyA9ICh0aGlzLmJpdExlbmd0aCoyIC8gOCk7XG4gICAgICAgIGxldCByZXMgPXRoaXMuemVybztcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5CeXRlczsgaSsrKSB7XG4gICAgICAgICAgICByZXMgPSAocmVzIDw8IEJpZ0ludCg4KSkgKyBCaWdJbnQoZ2V0UmFuZG9tQnl0ZXMoMSlbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMgJSB0aGlzLnA7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoYSwgYmFzZSkge1xuICAgICAgICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgICAgICAgbGV0IHZzO1xuICAgICAgICBpZiAoKGEgPiB0aGlzLmhhbGYpJiYoYmFzZSA9PSAxMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLnAtYTtcbiAgICAgICAgICAgIHZzID0gXCItXCIrdi50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZzID0gYS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdnM7XG4gICAgfVxuXG4gICAgaXNaZXJvKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgPT0gdGhpcy56ZXJvO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGxldCB2O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2PXRoaXMuemVybztcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLm42NDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdiArPSBybmcubmV4dFU2NCgpIDw8IEJpZ0ludCg2NCAqaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ICY9IHRoaXMubWFzaztcbiAgICAgICAgfSB3aGlsZSAodiA+PSB0aGlzLnApO1xuICAgICAgICB2ID0gKHYgKiB0aGlzLlJpKSAlIHRoaXMucDsgICAvLyBDb252ZXJ0IGZyb20gbW9udGdvbWVyeVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICBmZnQoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5GRlQuZmZ0KGEpO1xuICAgIH1cblxuICAgIGlmZnQoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5GRlQuaWZmdChhKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGEgYnVmZmVyIHdpdGggTGl0dGxlIEVuZGlhbiBSZXByZXNlbnRhdGlvblxuICAgIHRvUnByTEUoYnVmZiwgbywgZSkge1xuICAgICAgICB0b1JwckxFKGJ1ZmYsIG8sIGUsIHRoaXMubjY0KjgpO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBidWZmZXIgd2l0aCBCaWcgRW5kaWFuIFJlcHJlc2VudGF0aW9uXG4gICAgdG9ScHJCRShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRvUnByQkUoYnVmZiwgbywgZSwgdGhpcy5uNjQqOCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIGJ1ZmZlciB3aXRoIEJpZyBFbmRpYW4gTW9udGdvbWVyeSBSZXByZXNlbnRhdGlvblxuICAgIHRvUnByQkVNKGJ1ZmYsIG8sIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9ScHJCRShidWZmLCBvLCB0aGlzLm11bCh0aGlzLlIsIGUpKTtcbiAgICB9XG5cbiAgICB0b1JwckxFTShidWZmLCBvLCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUnByTEUoYnVmZiwgbywgdGhpcy5tdWwodGhpcy5SLCBlKSk7XG4gICAgfVxuXG5cbiAgICAvLyBQYXNlcyBhIGJ1ZmZlciB3aXRoIExpdHRsZSBFbmRpYW4gUmVwcmVzZW50YXRpb25cbiAgICBmcm9tUnByTEUoYnVmZiwgbykge1xuICAgICAgICByZXR1cm4gZnJvbVJwckxFKGJ1ZmYsIG8sIHRoaXMubjgpO1xuICAgIH1cblxuICAgIC8vIFBhc2VzIGEgYnVmZmVyIHdpdGggQmlnIEVuZGlhbiBSZXByZXNlbnRhdGlvblxuICAgIGZyb21ScHJCRShidWZmLCBvKSB7XG4gICAgICAgIHJldHVybiBmcm9tUnByQkUoYnVmZiwgbywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgZnJvbVJwckxFTShidWZmLCBvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bCh0aGlzLmZyb21ScHJMRShidWZmLCBvKSwgdGhpcy5SaSk7XG4gICAgfVxuXG4gICAgZnJvbVJwckJFTShidWZmLCBvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bCh0aGlzLmZyb21ScHJCRShidWZmLCBvKSwgdGhpcy5SaSk7XG4gICAgfVxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuY2xhc3MgRjJGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoRiwgbm9uUmVzaWR1ZSkge1xuICAgICAgICB0aGlzLnR5cGU9XCJGMlwiO1xuICAgICAgICB0aGlzLkYgPSBGO1xuICAgICAgICB0aGlzLnplcm8gPSBbdGhpcy5GLnplcm8sIHRoaXMuRi56ZXJvXTtcbiAgICAgICAgdGhpcy5vbmUgPSBbdGhpcy5GLm9uZSwgdGhpcy5GLnplcm9dO1xuICAgICAgICB0aGlzLm5lZ29uZSA9IHRoaXMubmVnKHRoaXMub25lKTtcbiAgICAgICAgdGhpcy5ub25SZXNpZHVlID0gbm9uUmVzaWR1ZTtcbiAgICAgICAgdGhpcy5tID0gRi5tKjI7XG4gICAgICAgIHRoaXMucCA9IEYucDtcbiAgICAgICAgdGhpcy5uNjQgPSBGLm42NCoyO1xuICAgICAgICB0aGlzLm4zMiA9IHRoaXMubjY0KjI7XG4gICAgICAgIHRoaXMubjggPSB0aGlzLm42NCo4O1xuXG4gICAgICAgIGJ1aWxkU3FydCh0aGlzKTtcbiAgICB9XG5cbiAgICBfbXVsQnlOb25SZXNpZHVlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRi5tdWwodGhpcy5ub25SZXNpZHVlLCBhKTtcbiAgICB9XG5cbiAgICBjb3B5KGEpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLkYuY29weShhWzBdKSwgdGhpcy5GLmNvcHkoYVsxXSldO1xuICAgIH1cblxuICAgIGFkZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuYWRkKGFbMF0sIGJbMF0pLFxuICAgICAgICAgICAgdGhpcy5GLmFkZChhWzFdLCBiWzFdKVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGRvdWJsZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhLGEpO1xuICAgIH1cblxuICAgIHN1YihhLCBiKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuc3ViKGFbMF0sIGJbMF0pLFxuICAgICAgICAgICAgdGhpcy5GLnN1YihhWzFdLCBiWzFdKVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIG5lZyhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLnplcm8sIGEpO1xuICAgIH1cblxuICAgIGNvbmp1Z2F0ZShhKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBhWzBdLFxuICAgICAgICAgICAgdGhpcy5GLm5lZyhhWzFdKVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIG11bChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFBID0gdGhpcy5GLm11bChhWzBdICwgYlswXSk7XG4gICAgICAgIGNvbnN0IGJCID0gdGhpcy5GLm11bChhWzFdICwgYlsxXSk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoIGFBICwgdGhpcy5fbXVsQnlOb25SZXNpZHVlKGJCKSksXG4gICAgICAgICAgICB0aGlzLkYuc3ViKFxuICAgICAgICAgICAgICAgIHRoaXMuRi5tdWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYVswXSwgYVsxXSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYlswXSwgYlsxXSkpLFxuICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYUEsIGJCKSldO1xuICAgIH1cblxuICAgIGludihhKSB7XG4gICAgICAgIGNvbnN0IHQwID0gdGhpcy5GLnNxdWFyZShhWzBdKTtcbiAgICAgICAgY29uc3QgdDEgPSB0aGlzLkYuc3F1YXJlKGFbMV0pO1xuICAgICAgICBjb25zdCB0MiA9IHRoaXMuRi5zdWIodDAsIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZSh0MSkpO1xuICAgICAgICBjb25zdCB0MyA9IHRoaXMuRi5pbnYodDIpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5GLm11bChhWzBdLCB0MyksXG4gICAgICAgICAgICB0aGlzLkYubmVnKHRoaXMuRi5tdWwoIGFbMV0sIHQzKSkgXTtcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgdGhpcy5pbnYoYikpO1xuICAgIH1cblxuICAgIHNxdWFyZShhKSB7XG4gICAgICAgIGNvbnN0IGFiID0gdGhpcy5GLm11bChhWzBdICwgYVsxXSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgW1xuICAgICAgICAgICAgKGEgKyBiKSAqIChhICsgbm9uX3Jlc2lkdWUgKiBiKSAtIGFiIC0gbm9uX3Jlc2lkdWUgKiBhYixcbiAgICAgICAgICAgIGFiICsgYWJcbiAgICAgICAgXTtcbiAgICAgICAgKi9cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5GLnN1YihcbiAgICAgICAgICAgICAgICB0aGlzLkYubXVsKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFbMF0sIGFbMV0pICxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFbMF0gLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXVsQnlOb25SZXNpZHVlKGFbMV0pKSksXG4gICAgICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICAgICAgYWIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZShhYikpKSxcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoYWIsIGFiKVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGlzWmVybyhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkYuaXNaZXJvKGFbMF0pICYmIHRoaXMuRi5pc1plcm8oYVsxXSk7XG4gICAgfVxuXG4gICAgZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5GLmVxKGFbMF0sIGJbMF0pICYmIHRoaXMuRi5lcShhWzFdLCBiWzFdKTtcbiAgICB9XG5cbiAgICBtdWxTY2FsYXIoYmFzZSwgZSkge1xuICAgICAgICByZXR1cm4gbXVsU2NhbGFyKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIHBvdyhiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBleHAodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgZXhwKGJhc2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cCh0aGlzLCBiYXNlLCBlKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZyhhKSB7XG4gICAgICAgIHJldHVybiBgWyAke3RoaXMuRi50b1N0cmluZyhhWzBdKX0gLCAke3RoaXMuRi50b1N0cmluZyhhWzFdKX0gXWA7XG4gICAgfVxuXG4gICAgZnJvbVJuZyhybmcpIHtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgIHJldHVybiBbYzAsIGMxXTtcbiAgICB9XG5cbiAgICBndChhLCBiKSB7XG4gICAgICAgIGlmICh0aGlzLkYuZ3QoYVswXSwgYlswXSkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5GLmd0KGJbMF0sIGFbMF0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLkYuZ3QoYVsxXSwgYlsxXSkpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2VxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3QoYSwgYikgfHwgdGhpcy5lcShhLCBiKTtcbiAgICB9XG5cbiAgICBsdChhLCBiKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5nZXEoYSxiKTtcbiAgICB9XG5cbiAgICBsZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZ3QoYSxiKTtcbiAgICB9XG5cbiAgICBuZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXEoYSxiKTtcbiAgICB9XG5cbiAgICByYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5GLnJhbmRvbSgpLCB0aGlzLkYucmFuZG9tKCldO1xuICAgIH1cblxuXG4gICAgdG9ScHJMRShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckxFKGJ1ZmYsIG8sIGVbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRShidWZmLCBvK3RoaXMuRi5uOCwgZVsxXSk7XG4gICAgfVxuXG4gICAgdG9ScHJCRShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8sIGVbMV0pO1xuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvK3RoaXMuRi5uOCwgZVswXSk7XG4gICAgfVxuXG4gICAgdG9ScHJMRU0oYnVmZiwgbywgZSkge1xuICAgICAgICB0aGlzLkYudG9ScHJMRU0oYnVmZiwgbywgZVswXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFTShidWZmLCBvK3RoaXMuRi5uOCwgZVsxXSk7XG4gICAgfVxuXG5cbiAgICB0b1JwckJFTShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckJFTShidWZmLCBvLCBlWzFdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkVNKGJ1ZmYsIG8rdGhpcy5GLm44LCBlWzBdKTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEUoYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5mcm9tUnByTEUoYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21ScHJMRShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIHJldHVybiBbYzAsIGMxXTtcbiAgICB9XG5cbiAgICBmcm9tUnByQkUoYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi5mcm9tUnByQkUoYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21ScHJCRShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIHJldHVybiBbYzAsIGMxXTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIHJldHVybiBbYzAsIGMxXTtcbiAgICB9XG5cbiAgICBmcm9tUnByQkVNKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIHJldHVybiBbYzAsIGMxXTtcbiAgICB9XG5cbiAgICB0b09iamVjdChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5cbmNsYXNzIEYzRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKEYsIG5vblJlc2lkdWUpIHtcbiAgICAgICAgdGhpcy50eXBlPVwiRjNcIjtcbiAgICAgICAgdGhpcy5GID0gRjtcbiAgICAgICAgdGhpcy56ZXJvID0gW3RoaXMuRi56ZXJvLCB0aGlzLkYuemVybywgdGhpcy5GLnplcm9dO1xuICAgICAgICB0aGlzLm9uZSA9IFt0aGlzLkYub25lLCB0aGlzLkYuemVybywgdGhpcy5GLnplcm9dO1xuICAgICAgICB0aGlzLm5lZ29uZSA9IHRoaXMubmVnKHRoaXMub25lKTtcbiAgICAgICAgdGhpcy5ub25SZXNpZHVlID0gbm9uUmVzaWR1ZTtcbiAgICAgICAgdGhpcy5tID0gRi5tKjM7XG4gICAgICAgIHRoaXMucCA9IEYucDtcbiAgICAgICAgdGhpcy5uNjQgPSBGLm42NCozO1xuICAgICAgICB0aGlzLm4zMiA9IHRoaXMubjY0KjI7XG4gICAgICAgIHRoaXMubjggPSB0aGlzLm42NCo4O1xuICAgIH1cblxuICAgIF9tdWxCeU5vblJlc2lkdWUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5GLm11bCh0aGlzLm5vblJlc2lkdWUsIGEpO1xuICAgIH1cblxuICAgIGNvcHkoYSkge1xuICAgICAgICByZXR1cm4gW3RoaXMuRi5jb3B5KGFbMF0pLCB0aGlzLkYuY29weShhWzFdKSwgdGhpcy5GLmNvcHkoYVsyXSldO1xuICAgIH1cblxuICAgIGFkZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuYWRkKGFbMF0sIGJbMF0pLFxuICAgICAgICAgICAgdGhpcy5GLmFkZChhWzFdLCBiWzFdKSxcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoYVsyXSwgYlsyXSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBkb3VibGUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYSxhKTtcbiAgICB9XG5cbiAgICBzdWIoYSwgYikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5GLnN1YihhWzBdLCBiWzBdKSxcbiAgICAgICAgICAgIHRoaXMuRi5zdWIoYVsxXSwgYlsxXSksXG4gICAgICAgICAgICB0aGlzLkYuc3ViKGFbMl0sIGJbMl0pXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuemVybywgYSk7XG4gICAgfVxuXG4gICAgbXVsKGEsIGIpIHtcblxuICAgICAgICBjb25zdCBhQSA9IHRoaXMuRi5tdWwoYVswXSAsIGJbMF0pO1xuICAgICAgICBjb25zdCBiQiA9IHRoaXMuRi5tdWwoYVsxXSAsIGJbMV0pO1xuICAgICAgICBjb25zdCBjQyA9IHRoaXMuRi5tdWwoYVsyXSAsIGJbMl0pO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYuYWRkKFxuICAgICAgICAgICAgICAgIGFBLFxuICAgICAgICAgICAgICAgIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLnN1YihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhWzFdLCBhWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGJbMV0sIGJbMl0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYkIsIGNDKSkpKSwgICAgLy8gYUEgKyBub25fcmVzaWR1ZSooKGIrYykqKEIrQyktYkItY0MpLFxuXG4gICAgICAgICAgICB0aGlzLkYuYWRkKFxuICAgICAgICAgICAgICAgIHRoaXMuRi5zdWIoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRi5tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGFbMF0sIGFbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChiWzBdLCBiWzFdKSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYUEsIGJCKSksXG4gICAgICAgICAgICAgICAgdGhpcy5fbXVsQnlOb25SZXNpZHVlKCBjQykpLCAgIC8vIChhK2IpKihBK0IpLWFBLWJCK25vbl9yZXNpZHVlKmNDXG5cbiAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgdGhpcy5GLnN1YihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLm11bChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoYVswXSwgYVsyXSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkYuYWRkKGJbMF0sIGJbMl0pKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLmFkZChhQSwgY0MpKSxcbiAgICAgICAgICAgICAgICBiQildOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChhK2MpKihBK0MpLWFBK2JCLWNDKVxuICAgIH1cblxuICAgIGludihhKSB7XG4gICAgICAgIGNvbnN0IHQwID0gdGhpcy5GLnNxdWFyZShhWzBdKTsgICAgICAgICAgICAgLy8gdDAgPSBhXjIgO1xuICAgICAgICBjb25zdCB0MSA9IHRoaXMuRi5zcXVhcmUoYVsxXSk7ICAgICAgICAgICAgIC8vIHQxID0gYl4yIDtcbiAgICAgICAgY29uc3QgdDIgPSB0aGlzLkYuc3F1YXJlKGFbMl0pOyAgICAgICAgICAgICAvLyB0MiA9IGNeMjtcbiAgICAgICAgY29uc3QgdDMgPSB0aGlzLkYubXVsKGFbMF0sYVsxXSk7ICAgICAgICAgICAvLyB0MyA9IGFiXG4gICAgICAgIGNvbnN0IHQ0ID0gdGhpcy5GLm11bChhWzBdLGFbMl0pOyAgICAgICAgICAgLy8gdDQgPSBhY1xuICAgICAgICBjb25zdCB0NSA9IHRoaXMuRi5tdWwoYVsxXSxhWzJdKTsgICAgICAgICAgIC8vIHQ1ID0gYmM7XG4gICAgICAgIC8vIGMwID0gdDAgLSBub25fcmVzaWR1ZSAqIHQ1O1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5zdWIodDAsIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZSh0NSkpO1xuICAgICAgICAvLyBjMSA9IG5vbl9yZXNpZHVlICogdDIgLSB0MztcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuc3ViKHRoaXMuX211bEJ5Tm9uUmVzaWR1ZSh0MiksIHQzKTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuc3ViKHQxLCB0NCk7ICAgICAgICAgICAgICAvLyBjMiA9IHQxLXQ0XG5cbiAgICAgICAgLy8gdDYgPSAoYSAqIGMwICsgbm9uX3Jlc2lkdWUgKiAoYyAqIGMxICsgYiAqIGMyKSkuaW52KCk7XG4gICAgICAgIGNvbnN0IHQ2ID1cbiAgICAgICAgICAgIHRoaXMuRi5pbnYoXG4gICAgICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5GLm11bChhWzBdLCBjMCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX211bEJ5Tm9uUmVzaWR1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLm11bChhWzJdLCBjMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GLm11bChhWzFdLCBjMikpKSkpO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLkYubXVsKHQ2LCBjMCksICAgICAgICAgLy8gdDYqYzBcbiAgICAgICAgICAgIHRoaXMuRi5tdWwodDYsIGMxKSwgICAgICAgICAvLyB0NipjMVxuICAgICAgICAgICAgdGhpcy5GLm11bCh0NiwgYzIpXTsgICAgICAgIC8vIHQ2KmMyXG4gICAgfVxuXG4gICAgZGl2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKGEsIHRoaXMuaW52KGIpKTtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICBjb25zdCBzMCA9IHRoaXMuRi5zcXVhcmUoYVswXSk7ICAgICAgICAgICAgICAgICAgIC8vIHMwID0gYV4yXG4gICAgICAgIGNvbnN0IGFiID0gdGhpcy5GLm11bChhWzBdLCBhWzFdKTsgICAgICAgICAgICAgICAgLy8gYWIgPSBhKmJcbiAgICAgICAgY29uc3QgczEgPSB0aGlzLkYuYWRkKGFiLCBhYik7ICAgICAgICAgICAgICAgICAgICAvLyBzMSA9IDJhYjtcbiAgICAgICAgY29uc3QgczIgPSB0aGlzLkYuc3F1YXJlKFxuICAgICAgICAgICAgdGhpcy5GLmFkZCh0aGlzLkYuc3ViKGFbMF0sYVsxXSksIGFbMl0pKTsgICAgIC8vIHMyID0gKGEgLSBiICsgYyleMjtcbiAgICAgICAgY29uc3QgYmMgPSB0aGlzLkYubXVsKGFbMV0sYVsyXSk7ICAgICAgICAgICAgICAgICAvLyBiYyA9IGIqY1xuICAgICAgICBjb25zdCBzMyA9IHRoaXMuRi5hZGQoYmMsIGJjKTsgICAgICAgICAgICAgICAgICAgIC8vIHMzID0gMipiY1xuICAgICAgICBjb25zdCBzNCA9IHRoaXMuRi5zcXVhcmUoYVsyXSk7ICAgICAgICAgICAgICAgICAgIC8vIHM0ID0gY14yXG5cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5GLmFkZChcbiAgICAgICAgICAgICAgICBzMCxcbiAgICAgICAgICAgICAgICB0aGlzLl9tdWxCeU5vblJlc2lkdWUoczMpKSwgICAgICAgICAgIC8vIHMwICsgbm9uX3Jlc2lkdWUgKiBzMyxcbiAgICAgICAgICAgIHRoaXMuRi5hZGQoXG4gICAgICAgICAgICAgICAgczEsXG4gICAgICAgICAgICAgICAgdGhpcy5fbXVsQnlOb25SZXNpZHVlKHM0KSksICAgICAgICAgICAvLyBzMSArIG5vbl9yZXNpZHVlICogczQsXG4gICAgICAgICAgICB0aGlzLkYuc3ViKFxuICAgICAgICAgICAgICAgIHRoaXMuRi5hZGQoIHRoaXMuRi5hZGQoczEsIHMyKSAsIHMzICksXG4gICAgICAgICAgICAgICAgdGhpcy5GLmFkZChzMCwgczQpKV07ICAgICAgICAgICAgICAgICAgICAgIC8vIHMxICsgczIgKyBzMyAtIHMwIC0gczRcbiAgICB9XG5cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5GLmlzWmVybyhhWzBdKSAmJiB0aGlzLkYuaXNaZXJvKGFbMV0pICYmIHRoaXMuRi5pc1plcm8oYVsyXSk7XG4gICAgfVxuXG4gICAgZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5GLmVxKGFbMF0sIGJbMF0pICYmIHRoaXMuRi5lcShhWzFdLCBiWzFdKSAmJiB0aGlzLkYuZXEoYVsyXSwgYlsyXSk7XG4gICAgfVxuXG4gICAgYWZmaW5lKGEpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLkYuYWZmaW5lKGFbMF0pLCB0aGlzLkYuYWZmaW5lKGFbMV0pLCB0aGlzLkYuYWZmaW5lKGFbMl0pXTtcbiAgICB9XG5cbiAgICBtdWxTY2FsYXIoYmFzZSwgZSkge1xuICAgICAgICByZXR1cm4gbXVsU2NhbGFyKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIHBvdyhiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBleHAodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgZXhwKGJhc2UsIGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cCh0aGlzLCBiYXNlLCBlKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZyhhKSB7XG4gICAgICAgIHJldHVybiBgWyAke3RoaXMuRi50b1N0cmluZyhhWzBdKX0gLCAke3RoaXMuRi50b1N0cmluZyhhWzFdKX0sICR7dGhpcy5GLnRvU3RyaW5nKGFbMl0pfSBdYDtcbiAgICB9XG5cbiAgICBmcm9tUm5nKHJuZykge1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMSwgYzJdO1xuICAgIH1cblxuICAgIGd0KGEsIGIpIHtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChhWzBdLCBiWzBdKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLkYuZ3QoYlswXSwgYVswXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChhWzFdLCBiWzFdKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLkYuZ3QoYlsxXSwgYVsxXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuRi5ndChhWzJdLCBiWzJdKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIGdlcShhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmd0KGEsIGIpIHx8IHRoaXMuZXEoYSwgYik7XG4gICAgfVxuXG4gICAgbHQoYSwgYikge1xuICAgICAgICByZXR1cm4gIXRoaXMuZ2VxKGEsYik7XG4gICAgfVxuXG4gICAgbGVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmd0KGEsYik7XG4gICAgfVxuXG4gICAgbmVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVxKGEsYik7XG4gICAgfVxuXG4gICAgcmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuRi5yYW5kb20oKSwgdGhpcy5GLnJhbmRvbSgpLCB0aGlzLkYucmFuZG9tKCldO1xuICAgIH1cblxuXG4gICAgdG9ScHJMRShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckxFKGJ1ZmYsIG8sIGVbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJMRShidWZmLCBvK3RoaXMuRi5uOCwgZVsxXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckxFKGJ1ZmYsIG8rdGhpcy5GLm44KjIsIGVbMl0pO1xuICAgIH1cblxuICAgIHRvUnByQkUoYnVmZiwgbywgZSkge1xuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvLCBlWzJdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkUoYnVmZiwgbyt0aGlzLkYubjgsIGVbMV0pO1xuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvK3RoaXMuRi5uOCoyLCBlWzBdKTtcbiAgICB9XG5cbiAgICB0b1JwckxFTShidWZmLCBvLCBlKSB7XG4gICAgICAgIHRoaXMuRi50b1JwckxFTShidWZmLCBvLCBlWzBdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8rdGhpcy5GLm44LCBlWzFdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8rdGhpcy5GLm44KjIsIGVbMl0pO1xuICAgIH1cblxuXG4gICAgdG9ScHJCRU0oYnVmZiwgbywgZSkge1xuICAgICAgICB0aGlzLkYudG9ScHJCRU0oYnVmZiwgbywgZVsyXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckJFTShidWZmLCBvK3RoaXMuRi5uOCwgZVsxXSk7XG4gICAgICAgIHRoaXMuRi50b1JwckJFTShidWZmLCBvK3RoaXMuRi5uOCoyLCBlWzBdKTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEUoYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCBjMCA9IHRoaXMuRi5mcm9tUnByTEUoYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21ScHJMRShidWZmLCBvK3RoaXMubjgpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5mcm9tUnByTEUoYnVmZiwgbyt0aGlzLm44KjIpO1xuICAgICAgICByZXR1cm4gW2MwLCBjMSwgYzJdO1xuICAgIH1cblxuICAgIGZyb21ScHJCRShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5GLmZyb21ScHJCRShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8rdGhpcy5uOCk7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21ScHJCRShidWZmLCBvK3RoaXMubjgqMik7XG4gICAgICAgIHJldHVybiBbYzAsIGMxLCBjMl07XG4gICAgfVxuXG4gICAgZnJvbVJwckxFTShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMwID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyt0aGlzLm44KTtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvK3RoaXMubjgqMik7XG4gICAgICAgIHJldHVybiBbYzAsIGMxLCBjMl07XG4gICAgfVxuXG4gICAgZnJvbVJwckJFTShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5GLmZyb21ScHJCRU0oYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmZyb21ScHJCRU0oYnVmZiwgbyt0aGlzLm44KTtcbiAgICAgICAgY29uc3QgYzAgPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvK3RoaXMubjgqMik7XG4gICAgICAgIHJldHVybiBbYzAsIGMxLCBjMl07XG4gICAgfVxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMGtpbXMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuXG5mdW5jdGlvbiBpc0dyZWF0ZXN0KEYsIGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBmb3IgKGxldCBpPWEubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCFGLkYuaXNaZXJvKGFbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzR3JlYXRlc3QoRi5GLCBhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuYSA9IEYubmVnKGEpO1xuICAgICAgICByZXR1cm4gZ3QoYSwgbmEpO1xuICAgIH1cbn1cblxuXG5jbGFzcyBFQyB7XG5cbiAgICBjb25zdHJ1Y3RvcihGLCBnKSB7XG4gICAgICAgIHRoaXMuRiA9IEY7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgICAgIGlmICh0aGlzLmcubGVuZ3RoID09IDIpIHRoaXMuZ1syXSA9IHRoaXMuRi5vbmU7XG4gICAgICAgIHRoaXMuemVybyA9IFt0aGlzLkYuemVybywgdGhpcy5GLm9uZSwgdGhpcy5GLnplcm9dO1xuICAgIH1cblxuICAgIGFkZChwMSwgcDIpIHtcblxuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuXG4gICAgICAgIGlmICh0aGlzLmVxKHAxLCB0aGlzLnplcm8pKSByZXR1cm4gcDI7XG4gICAgICAgIGlmICh0aGlzLmVxKHAyLCB0aGlzLnplcm8pKSByZXR1cm4gcDE7XG5cbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEFycmF5KDMpO1xuXG4gICAgICAgIGNvbnN0IFoxWjEgPSBGLnNxdWFyZSggcDFbMl0gKTtcbiAgICAgICAgY29uc3QgWjJaMiA9IEYuc3F1YXJlKCBwMlsyXSApO1xuXG4gICAgICAgIGNvbnN0IFUxID0gRi5tdWwoIHAxWzBdICwgWjJaMiApOyAgICAgLy8gVTEgPSBYMSAgKiBaMloyXG4gICAgICAgIGNvbnN0IFUyID0gRi5tdWwoIHAyWzBdICwgWjFaMSApOyAgICAgLy8gVTIgPSBYMiAgKiBaMVoxXG5cbiAgICAgICAgY29uc3QgWjFfY3ViZWQgPSBGLm11bCggcDFbMl0gLCBaMVoxKTtcbiAgICAgICAgY29uc3QgWjJfY3ViZWQgPSBGLm11bCggcDJbMl0gLCBaMloyKTtcblxuICAgICAgICBjb25zdCBTMSA9IEYubXVsKCBwMVsxXSAsIFoyX2N1YmVkKTsgIC8vIFMxID0gWTEgKiBaMiAqIFoyWjJcbiAgICAgICAgY29uc3QgUzIgPSBGLm11bCggcDJbMV0gLCBaMV9jdWJlZCk7ICAvLyBTMiA9IFkyICogWjEgKiBaMVoxXG5cbiAgICAgICAgaWYgKEYuZXEoVTEsVTIpICYmIEYuZXEoUzEsUzIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb3VibGUocDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgSCA9IEYuc3ViKCBVMiAsIFUxICk7ICAgICAgICAgICAgICAgICAgICAvLyBIID0gVTItVTFcblxuICAgICAgICBjb25zdCBTMl9taW51c19TMSA9IEYuc3ViKCBTMiAsIFMxICk7XG5cbiAgICAgICAgY29uc3QgSSA9IEYuc3F1YXJlKCBGLmFkZChILEgpICk7ICAgICAgICAgLy8gSSA9ICgyICogSCleMlxuICAgICAgICBjb25zdCBKID0gRi5tdWwoIEggLCBJICk7ICAgICAgICAgICAgICAgICAgICAgIC8vIEogPSBIICogSVxuXG4gICAgICAgIGNvbnN0IHIgPSBGLmFkZCggUzJfbWludXNfUzEgLCBTMl9taW51c19TMSApOyAgLy8gciA9IDIgKiAoUzItUzEpXG4gICAgICAgIGNvbnN0IFYgPSBGLm11bCggVTEgLCBJICk7ICAgICAgICAgICAgICAgICAgICAgLy8gViA9IFUxICogSVxuXG4gICAgICAgIHJlc1swXSA9XG4gICAgICAgICAgICBGLnN1YihcbiAgICAgICAgICAgICAgICBGLnN1YiggRi5zcXVhcmUocikgLCBKICksXG4gICAgICAgICAgICAgICAgRi5hZGQoIFYgLCBWICkpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gWDMgPSByXjIgLSBKIC0gMiAqIFZcblxuICAgICAgICBjb25zdCBTMV9KID0gRi5tdWwoIFMxICwgSiApO1xuXG4gICAgICAgIHJlc1sxXSA9XG4gICAgICAgICAgICBGLnN1YihcbiAgICAgICAgICAgICAgICBGLm11bCggciAsIEYuc3ViKFYscmVzWzBdKSksXG4gICAgICAgICAgICAgICAgRi5hZGQoIFMxX0osUzFfSiApKTsgICAgICAgICAgICAgICAgICAgLy8gWTMgPSByICogKFYtWDMpLTIgUzEgSlxuXG4gICAgICAgIHJlc1syXSA9XG4gICAgICAgICAgICBGLm11bChcbiAgICAgICAgICAgICAgICBILFxuICAgICAgICAgICAgICAgIEYuc3ViKFxuICAgICAgICAgICAgICAgICAgICBGLnNxdWFyZSggRi5hZGQocDFbMl0scDJbMl0pICksXG4gICAgICAgICAgICAgICAgICAgIEYuYWRkKCBaMVoxICwgWjJaMiApKSk7ICAgICAgICAgICAgLy8gWjMgPSAoKFoxK1oyKV4yLVoxWjEtWjJaMikgKiBIXG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBuZWcocCkge1xuICAgICAgICByZXR1cm4gW3BbMF0sIHRoaXMuRi5uZWcocFsxXSksIHBbMl1dO1xuICAgIH1cblxuICAgIHN1YihhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhLCB0aGlzLm5lZyhiKSk7XG4gICAgfVxuXG4gICAgZG91YmxlKHApIHtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcblxuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkoMyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZXEocCwgdGhpcy56ZXJvKSkgcmV0dXJuIHA7XG5cbiAgICAgICAgY29uc3QgQSA9IEYuc3F1YXJlKCBwWzBdICk7ICAgICAgICAgICAgICAgICAgICAvLyBBID0gWDFeMlxuICAgICAgICBjb25zdCBCID0gRi5zcXVhcmUoIHBbMV0gKTsgICAgICAgICAgICAgICAgICAgIC8vIEIgPSBZMV4yXG4gICAgICAgIGNvbnN0IEMgPSBGLnNxdWFyZSggQiApOyAgICAgICAgICAgICAgICAgICAgICAgLy8gQyA9IEJeMlxuXG4gICAgICAgIGxldCBEID1cbiAgICAgICAgICAgIEYuc3ViKFxuICAgICAgICAgICAgICAgIEYuc3F1YXJlKCBGLmFkZChwWzBdICwgQiApKSxcbiAgICAgICAgICAgICAgICBGLmFkZCggQSAsIEMpKTtcbiAgICAgICAgRCA9IEYuYWRkKEQsRCk7ICAgICAgICAgICAgICAgICAgICAvLyBEID0gMiAqICgoWDEgKyBCKV4yIC0gQSAtIEMpXG5cbiAgICAgICAgY29uc3QgRSA9IEYuYWRkKCBGLmFkZChBLEEpLCBBKTsgICAgICAgICAgLy8gRSA9IDMgKiBBXG4gICAgICAgIGNvbnN0IEZGID1GLnNxdWFyZSggRSApOyAgICAgICAgICAgICAgICAgICAgICAgLy8gRiA9IEVeMlxuXG4gICAgICAgIHJlc1swXSA9IEYuc3ViKCBGRiAsIEYuYWRkKEQsRCkgKTsgICAgICAgICAvLyBYMyA9IEYgLSAyIERcblxuICAgICAgICBsZXQgZWlnaHRDID0gRi5hZGQoIEMgLCBDICk7XG4gICAgICAgIGVpZ2h0QyA9IEYuYWRkKCBlaWdodEMgLCBlaWdodEMgKTtcbiAgICAgICAgZWlnaHRDID0gRi5hZGQoIGVpZ2h0QyAsIGVpZ2h0QyApO1xuXG4gICAgICAgIHJlc1sxXSA9XG4gICAgICAgICAgICBGLnN1YihcbiAgICAgICAgICAgICAgICBGLm11bChcbiAgICAgICAgICAgICAgICAgICAgRSxcbiAgICAgICAgICAgICAgICAgICAgRi5zdWIoIEQsIHJlc1swXSApKSxcbiAgICAgICAgICAgICAgICBlaWdodEMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFkzID0gRSAqIChEIC0gWDMpIC0gOCAqIENcblxuICAgICAgICBjb25zdCBZMVoxID0gRi5tdWwoIHBbMV0gLCBwWzJdICk7XG4gICAgICAgIHJlc1syXSA9IEYuYWRkKCBZMVoxICwgWTFaMSApOyAgICAgICAgICAgICAgICAgLy8gWjMgPSAyICogWTEgKiBaMVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgdGltZXNTY2FsYXIoYmFzZSwgZSkge1xuICAgICAgICByZXR1cm4gbXVsU2NhbGFyKHRoaXMsIGJhc2UsIGUpO1xuICAgIH1cblxuICAgIG11bFNjYWxhcihiYXNlLCBlKSB7XG4gICAgICAgIHJldHVybiBtdWxTY2FsYXIodGhpcywgYmFzZSwgZSk7XG4gICAgfVxuXG4gICAgYWZmaW5lKHApIHtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKHApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICB9IGVsc2UgaWYgKEYuZXEocFsyXSwgRi5vbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFpfaW52ID0gRi5pbnYocFsyXSk7XG4gICAgICAgICAgICBjb25zdCBaMl9pbnYgPSBGLnNxdWFyZShaX2ludik7XG4gICAgICAgICAgICBjb25zdCBaM19pbnYgPSBGLm11bChaMl9pbnYsIFpfaW52KTtcblxuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IEFycmF5KDMpO1xuICAgICAgICAgICAgcmVzWzBdID0gRi5tdWwocFswXSxaMl9pbnYpO1xuICAgICAgICAgICAgcmVzWzFdID0gRi5tdWwocFsxXSxaM19pbnYpO1xuICAgICAgICAgICAgcmVzWzJdID0gRi5vbmU7XG5cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtdWx0aUFmZmluZShhcnIpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFycik7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG4gICAgICAgIGNvbnN0IGFjY011bCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCsxKTtcbiAgICAgICAgYWNjTXVsWzBdID0gRi5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoRi5lcShhcnJba2V5c1tpXV1bMl0sIEYuemVybykpIHtcbiAgICAgICAgICAgICAgICBhY2NNdWxbaSsxXSA9IGFjY011bFtpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWNjTXVsW2krMV0gPSBGLm11bChhY2NNdWxbaV0sIGFycltrZXlzW2ldXVsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhY2NNdWxba2V5cy5sZW5ndGhdID0gRi5pbnYoYWNjTXVsW2tleXMubGVuZ3RoXSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGtleXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAgICAgaWYgKEYuZXEoYXJyW2tleXNbaV1dWzJdLCBGLnplcm8pKSB7XG4gICAgICAgICAgICAgICAgYWNjTXVsW2ldID0gYWNjTXVsW2krMV07XG4gICAgICAgICAgICAgICAgYXJyW2tleXNbaV1dID0gdGhpcy56ZXJvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBaX2ludiA9IEYubXVsKGFjY011bFtpXSwgYWNjTXVsW2krMV0pO1xuICAgICAgICAgICAgICAgIGFjY011bFtpXSA9IEYubXVsKGFycltrZXlzW2ldXVsyXSwgYWNjTXVsW2krMV0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgWjJfaW52ID0gRi5zcXVhcmUoWl9pbnYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFozX2ludiA9IEYubXVsKFoyX2ludiwgWl9pbnYpO1xuXG4gICAgICAgICAgICAgICAgYXJyW2tleXNbaV1dWzBdID0gRi5tdWwoYXJyW2tleXNbaV1dWzBdLFoyX2ludik7XG4gICAgICAgICAgICAgICAgYXJyW2tleXNbaV1dWzFdID0gRi5tdWwoYXJyW2tleXNbaV1dWzFdLFozX2ludik7XG4gICAgICAgICAgICAgICAgYXJyW2tleXNbaV1dWzJdID0gRi5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGVxKHAxLCBwMikge1xuICAgICAgICBjb25zdCBGID0gdGhpcy5GO1xuXG4gICAgICAgIGlmICh0aGlzLkYuZXEocDFbMl0sIHRoaXMuRi56ZXJvKSkgcmV0dXJuIHRoaXMuRi5lcShwMlsyXSwgdGhpcy5GLnplcm8pO1xuICAgICAgICBpZiAodGhpcy5GLmVxKHAyWzJdLCB0aGlzLkYuemVybykpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjb25zdCBaMVoxID0gRi5zcXVhcmUoIHAxWzJdICk7XG4gICAgICAgIGNvbnN0IFoyWjIgPSBGLnNxdWFyZSggcDJbMl0gKTtcblxuICAgICAgICBjb25zdCBVMSA9IEYubXVsKCBwMVswXSAsIFoyWjIgKTtcbiAgICAgICAgY29uc3QgVTIgPSBGLm11bCggcDJbMF0gLCBaMVoxICk7XG5cbiAgICAgICAgY29uc3QgWjFfY3ViZWQgPSBGLm11bCggcDFbMl0gLCBaMVoxKTtcbiAgICAgICAgY29uc3QgWjJfY3ViZWQgPSBGLm11bCggcDJbMl0gLCBaMloyKTtcblxuICAgICAgICBjb25zdCBTMSA9IEYubXVsKCBwMVsxXSAsIFoyX2N1YmVkKTtcbiAgICAgICAgY29uc3QgUzIgPSBGLm11bCggcDJbMV0gLCBaMV9jdWJlZCk7XG5cbiAgICAgICAgcmV0dXJuIChGLmVxKFUxLFUyKSAmJiBGLmVxKFMxLFMyKSk7XG4gICAgfVxuXG4gICAgaXNaZXJvKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRi5pc1plcm8ocFsyXSk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcocCkge1xuICAgICAgICBjb25zdCBjcCA9IHRoaXMuYWZmaW5lKHApO1xuICAgICAgICByZXR1cm4gYFsgJHt0aGlzLkYudG9TdHJpbmcoY3BbMF0pfSAsICR7dGhpcy5GLnRvU3RyaW5nKGNwWzFdKX0gXWA7XG4gICAgfVxuXG4gICAgZnJvbVJuZyhybmcpIHtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcbiAgICAgICAgbGV0IFAgPSBbXTtcbiAgICAgICAgbGV0IGdyZWF0ZXN0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBQWzBdID0gRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgICAgICBncmVhdGVzdCA9IHJuZy5uZXh0Qm9vbCgpO1xuICAgICAgICAgICAgY29uc3QgeDNiID0gRi5hZGQoRi5tdWwoRi5zcXVhcmUoUFswXSksIFBbMF0pLCB0aGlzLmIpO1xuICAgICAgICAgICAgUFsxXSA9IEYuc3FydCh4M2IpO1xuICAgICAgICB9IHdoaWxlICgoUFsxXSA9PSBudWxsKXx8KEYuaXNaZXJvW1BdKSk7XG5cbiAgICAgICAgY29uc3QgcyA9IGlzR3JlYXRlc3QoRiwgUFsxXSk7XG4gICAgICAgIGlmIChncmVhdGVzdCBeIHMpIFBbMV0gPSBGLm5lZyhQWzFdKTtcbiAgICAgICAgUFsyXSA9IEYub25lO1xuXG4gICAgICAgIGlmICh0aGlzLmNvZmFjdG9yKSB7XG4gICAgICAgICAgICBQID0gdGhpcy5tdWxTY2FsYXIoUCwgdGhpcy5jb2ZhY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBQID0gdGhpcy5hZmZpbmUoUCk7XG5cbiAgICAgICAgcmV0dXJuIFA7XG5cbiAgICB9XG5cbiAgICB0b1JwckxFKGJ1ZmYsIG8sIHApIHtcbiAgICAgICAgcCA9IHRoaXMuYWZmaW5lKHApO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIGNvbnN0IEJ1ZmZWID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiwgbywgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgQnVmZlYuZmlsbCgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkYudG9ScHJMRShidWZmLCBvLCBwWzBdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEUoYnVmZiwgbyt0aGlzLkYubjgsIHBbMV0pO1xuICAgIH1cblxuICAgIHRvUnByQkUoYnVmZiwgbywgcCkge1xuICAgICAgICBwID0gdGhpcy5hZmZpbmUocCk7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhwKSkge1xuICAgICAgICAgICAgY29uc3QgQnVmZlYgPSBuZXcgVWludDhBcnJheShidWZmLCBvLCB0aGlzLkYubjgqMik7XG4gICAgICAgICAgICBCdWZmVi5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRi50b1JwckJFKGJ1ZmYsIG8sIHBbMF0pO1xuICAgICAgICB0aGlzLkYudG9ScHJCRShidWZmLCBvK3RoaXMuRi5uOCwgcFsxXSk7XG4gICAgfVxuXG4gICAgdG9ScHJMRU0oYnVmZiwgbywgcCkge1xuICAgICAgICBwID0gdGhpcy5hZmZpbmUocCk7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhwKSkge1xuICAgICAgICAgICAgY29uc3QgQnVmZlYgPSBuZXcgVWludDhBcnJheShidWZmLCBvLCB0aGlzLkYubjgqMik7XG4gICAgICAgICAgICBCdWZmVi5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRi50b1JwckxFTShidWZmLCBvLCBwWzBdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8rdGhpcy5GLm44LCBwWzFdKTtcbiAgICB9XG5cbiAgICB0b1JwckxFSk0oYnVmZiwgbywgcCkge1xuICAgICAgICBwID0gdGhpcy5hZmZpbmUocCk7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhwKSkge1xuICAgICAgICAgICAgY29uc3QgQnVmZlYgPSBuZXcgVWludDhBcnJheShidWZmLCBvLCB0aGlzLkYubjgqMik7XG4gICAgICAgICAgICBCdWZmVi5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRi50b1JwckxFTShidWZmLCBvLCBwWzBdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8rdGhpcy5GLm44LCBwWzFdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByTEVNKGJ1ZmYsIG8rMip0aGlzLkYubjgsIHBbMl0pO1xuICAgIH1cblxuXG4gICAgdG9ScHJCRU0oYnVmZiwgbywgcCkge1xuICAgICAgICBwID0gdGhpcy5hZmZpbmUocCk7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhwKSkge1xuICAgICAgICAgICAgY29uc3QgQnVmZlYgPSBuZXcgVWludDhBcnJheShidWZmLCBvLCB0aGlzLkYubjgqMik7XG4gICAgICAgICAgICBCdWZmVi5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRi50b1JwckJFTShidWZmLCBvLCBwWzBdKTtcbiAgICAgICAgdGhpcy5GLnRvUnByQkVNKGJ1ZmYsIG8rdGhpcy5GLm44LCBwWzFdKTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEUoYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5GLmZyb21ScHJMRShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuRi5mcm9tUnByTEUoYnVmZiwgbyt0aGlzLkYubjgpO1xuICAgICAgICBpZiAodGhpcy5GLmlzWmVybyh4KSAmJiB0aGlzLkYuaXNaZXJvKHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeSwgdGhpcy5GLm9uZV07XG4gICAgfVxuXG4gICAgZnJvbVJwckJFKGJ1ZmYsIG8pIHtcbiAgICAgICAgbyA9IG8gfHwgMDtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuRi5mcm9tUnByQkUoYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLkYuZnJvbVJwckJFKGJ1ZmYsIG8rdGhpcy5GLm44KTtcbiAgICAgICAgaWYgKHRoaXMuRi5pc1plcm8oeCkgJiYgdGhpcy5GLmlzWmVybyh5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHksIHRoaXMuRi5vbmVdO1xuICAgIH1cblxuICAgIGZyb21ScHJMRU0oYnVmZiwgbykge1xuICAgICAgICBvID0gbyB8fCAwO1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5GLmZyb21ScHJMRU0oYnVmZiwgbyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvK3RoaXMuRi5uOCk7XG4gICAgICAgIGlmICh0aGlzLkYuaXNaZXJvKHgpICYmIHRoaXMuRi5pc1plcm8oeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5LCB0aGlzLkYub25lXTtcbiAgICB9XG5cbiAgICBmcm9tUnByTEVKTShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLkYuZnJvbVJwckxFTShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuRi5mcm9tUnByTEVNKGJ1ZmYsIG8rdGhpcy5GLm44KTtcbiAgICAgICAgY29uc3QgeiA9IHRoaXMuRi5mcm9tUnByTEVNKGJ1ZmYsIG8rdGhpcy5GLm44KjIpO1xuICAgICAgICBpZiAodGhpcy5GLmlzWmVybyh4KSAmJiB0aGlzLkYuaXNaZXJvKHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeSwgel07XG4gICAgfVxuXG4gICAgZnJvbVJwckJFTShidWZmLCBvKSB7XG4gICAgICAgIG8gPSBvIHx8IDA7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLkYuZnJvbVJwckJFTShidWZmLCBvKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuRi5mcm9tUnByQkVNKGJ1ZmYsIG8rdGhpcy5GLm44KTtcbiAgICAgICAgaWYgKHRoaXMuRi5pc1plcm8oeCkgJiYgdGhpcy5GLmlzWmVybyh5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHksIHRoaXMuRi5vbmVdO1xuICAgIH1cblxuICAgIGZyb21ScHJDb21wcmVzc2VkKGJ1ZmYsIG8pIHtcbiAgICAgICAgY29uc3QgRiA9IHRoaXMuRjtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBVaW50OEFycmF5KGJ1ZmYuYnVmZmVyLCBvLCBGLm44KTtcbiAgICAgICAgaWYgKHZbMF0gJiAweDQwKSByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICBjb25zdCBQID0gbmV3IEFycmF5KDMpO1xuXG4gICAgICAgIGNvbnN0IGdyZWF0ZXN0ID0gKCh2WzBdICYgMHg4MCkgIT0gMCk7XG4gICAgICAgIHZbMF0gPSB2WzBdICYgMHg3RjtcbiAgICAgICAgUFswXSA9IEYuZnJvbVJwckJFKGJ1ZmYsIG8pO1xuICAgICAgICBpZiAoZ3JlYXRlc3QpIHZbMF0gPSB2WzBdIHwgMHg4MDsgIC8vIHNldCBiYWNrIGFnYWluIHRoZSBvbGQgdmFsdWVcblxuICAgICAgICBjb25zdCB4M2IgPSBGLmFkZChGLm11bChGLnNxdWFyZShQWzBdKSwgUFswXSksIHRoaXMuYik7XG4gICAgICAgIFBbMV0gPSBGLnNxcnQoeDNiKTtcblxuICAgICAgICBpZiAoUFsxXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQb2ludCFcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzID0gaXNHcmVhdGVzdChGLCBQWzFdKTtcbiAgICAgICAgaWYgKGdyZWF0ZXN0IF4gcykgUFsxXSA9IEYubmVnKFBbMV0pO1xuICAgICAgICBQWzJdID0gRi5vbmU7XG5cbiAgICAgICAgcmV0dXJuIFA7XG4gICAgfVxuXG4gICAgdG9ScHJDb21wcmVzc2VkKGJ1ZmYsIG8sIHApIHtcbiAgICAgICAgcCA9IHRoaXMuYWZmaW5lKHApO1xuICAgICAgICBjb25zdCB2ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZi5idWZmZXIsIG8sIHRoaXMuRi5uOCk7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhwKSkge1xuICAgICAgICAgICAgdi5maWxsKDApO1xuICAgICAgICAgICAgdlswXSA9IDB4NDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5GLnRvUnByQkUoYnVmZiwgbywgcFswXSk7XG5cbiAgICAgICAgaWYgKGlzR3JlYXRlc3QodGhpcy5GLCBwWzFdKSkge1xuICAgICAgICAgICAgdlswXSA9IHZbMF0gfCAweDgwO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmcm9tUnByVW5jb21wcmVzc2VkKGJ1ZmYsIG8pIHtcbiAgICAgICAgaWYgKGJ1ZmZbMF0gJiAweDQwKSByZXR1cm4gdGhpcy56ZXJvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21ScHJCRShidWZmLCBvKTtcbiAgICB9XG5cbiAgICB0b1JwclVuY29tcHJlc3NlZChidWZmLCBvLCBwKSB7XG4gICAgICAgIHRoaXMudG9ScHJCRShidWZmLCBvLCBwKTtcblxuICAgICAgICBpZiAodGhpcy5pc1plcm8ocCkpIHtcbiAgICAgICAgICAgIGJ1ZmZbb10gPSBidWZmW29dIHwgMHg0MDtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5cbnZhciB1dGlscyQ2ID0ge307XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTkgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3YXNtc25hcmsgKFdlYiBBc3NlbWJseSB6a1NuYXJrIFByb3ZlcikuXG5cbiAgICB3YXNtc25hcmsgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3YXNtc25hcmsgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2FzbXNuYXJrLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxudXRpbHMkNi5iaWdJbnQyQnl0ZXNMRSA9IGZ1bmN0aW9uIGJpZ0ludDJCeXRlc0xFKF9hLCBsZW4pIHtcbiAgICBjb25zdCBiID0gQXJyYXkobGVuKTtcbiAgICBsZXQgdiA9IEJpZ0ludChfYSk7XG4gICAgZm9yIChsZXQgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgIGJbaV0gPSBOdW1iZXIodiAmIDB4RkZuKTtcbiAgICAgICAgdiA9IHYgPj4gOG47XG4gICAgfVxuICAgIHJldHVybiBiO1xufTtcblxudXRpbHMkNi5iaWdJbnQyVTMyTEUgPSBmdW5jdGlvbiBiaWdJbnQyQnl0ZXNMRShfYSwgbGVuKSB7XG4gICAgY29uc3QgYiA9IEFycmF5KGxlbik7XG4gICAgbGV0IHYgPSBCaWdJbnQoX2EpO1xuICAgIGZvciAobGV0IGk9MDsgaTxsZW47IGkrKykge1xuICAgICAgICBiW2ldID0gTnVtYmVyKHYgJiAweEZGRkZGRkZGbik7XG4gICAgICAgIHYgPSB2ID4+IDMybjtcbiAgICB9XG4gICAgcmV0dXJuIGI7XG59O1xuXG51dGlscyQ2LmlzT2NhbU51bSA9IGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYS5sZW5ndGggIT0gMykgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgYVswXSAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgYVsxXSAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhWzJdKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21zbmFyayAoV2ViIEFzc2VtYmx5IHprU25hcmsgUHJvdmVyKS5cblxuICAgIHdhc21zbmFyayBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21zbmFyayBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtc25hcmsuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG52YXIgYnVpbGRfaW50ID0gZnVuY3Rpb24gYnVpbGRJbnQobW9kdWxlLCBuNjQsIF9wcmVmaXgpIHtcblxuICAgIGNvbnN0IHByZWZpeCA9IF9wcmVmaXggfHwgXCJpbnRcIjtcbiAgICBpZiAobW9kdWxlLm1vZHVsZXNbcHJlZml4XSkgcmV0dXJuIHByZWZpeDsgIC8vIGFscmVhZHkgYnVpbGRlZFxuICAgIG1vZHVsZS5tb2R1bGVzW3ByZWZpeF0gPSB7fTtcblxuICAgIGNvbnN0IG4zMiA9IG42NCoyO1xuICAgIGNvbnN0IG44ID0gbjY0Kjg7XG5cbiAgICBmdW5jdGlvbiBidWlsZENvcHkoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2NvcHlcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJweFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInByXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG42NDsgaSsrKSB7XG4gICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgYy5pNjRfc3RvcmUoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwclwiKSxcbiAgICAgICAgICAgICAgICAgICAgaSo4LFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9sb2FkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSo4XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRaZXJvKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl96ZXJvXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bjY0OyBpKyspIHtcbiAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICBjLmk2NF9zdG9yZShcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInByXCIpLFxuICAgICAgICAgICAgICAgICAgICBpKjgsXG4gICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkT25lKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9vbmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuaTY0X3N0b3JlKFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwclwiKSxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDEpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGZvciAobGV0IGk9MTsgaTxuNjQ7IGkrKykge1xuICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgIGMuaTY0X3N0b3JlKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHJcIiksXG4gICAgICAgICAgICAgICAgICAgIGkqOCxcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRJc1plcm8oKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2lzWmVyb1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInB4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRDb21wQ29kZShuKSB7XG4gICAgICAgICAgICBpZiAobj09MCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAgYy5yZXQoYy5pNjRfZXF6KFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9sb2FkKGMuZ2V0TG9jYWwoXCJweFwiKSlcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjLmlmKFxuICAgICAgICAgICAgICAgIGMuaTY0X2VxeihcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfbG9hZChjLmdldExvY2FsKFwicHhcIiksIG4qOCApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBnZXRDb21wQ29kZShuLTEpLFxuICAgICAgICAgICAgICAgIGMucmV0KGMuaTMyX2NvbnN0KDApKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGYuYWRkQ29kZShnZXRDb21wQ29kZShuNjQtMSkpO1xuICAgICAgICBmLmFkZENvZGUoYy5yZXQoYy5pMzJfY29uc3QoMCkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEVxKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9lcVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInB4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHlcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbXBDb2RlKG4pIHtcbiAgICAgICAgICAgIGlmIChuPT0wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICBjLnJldChjLmk2NF9lcShcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfbG9hZChjLmdldExvY2FsKFwicHhcIikpLFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9sb2FkKGMuZ2V0TG9jYWwoXCJweVwiKSlcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjLmlmKFxuICAgICAgICAgICAgICAgIGMuaTY0X2VxKFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9sb2FkKGMuZ2V0TG9jYWwoXCJweFwiKSwgbio4ICksXG4gICAgICAgICAgICAgICAgICAgIGMuaTY0X2xvYWQoYy5nZXRMb2NhbChcInB5XCIpLCBuKjggKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZ2V0Q29tcENvZGUobi0xKSxcbiAgICAgICAgICAgICAgICBjLnJldChjLmkzMl9jb25zdCgwKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmLmFkZENvZGUoZ2V0Q29tcENvZGUobjY0LTEpKTtcbiAgICAgICAgZi5hZGRDb2RlKGMucmV0KGMuaTMyX2NvbnN0KDApKSk7XG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkR3RlKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9ndGVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJweFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInB5XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRDb21wQ29kZShuKSB7XG4gICAgICAgICAgICBpZiAobj09MCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAgYy5yZXQoYy5pNjRfZ2VfdShcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfbG9hZChjLmdldExvY2FsKFwicHhcIikpLFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9sb2FkKGMuZ2V0TG9jYWwoXCJweVwiKSlcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjLmlmKFxuICAgICAgICAgICAgICAgIGMuaTY0X2x0X3UoXG4gICAgICAgICAgICAgICAgICAgIGMuaTY0X2xvYWQoYy5nZXRMb2NhbChcInB4XCIpLCBuKjggKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfbG9hZChjLmdldExvY2FsKFwicHlcIiksIG4qOCApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLnJldChjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfZ3RfdShcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2xvYWQoYy5nZXRMb2NhbChcInB4XCIpLCBuKjggKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2xvYWQoYy5nZXRMb2NhbChcInB5XCIpLCBuKjggKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBjLnJldChjLmkzMl9jb25zdCgxKSksXG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBDb2RlKG4tMSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZi5hZGRDb2RlKGdldENvbXBDb2RlKG42NC0xKSk7XG4gICAgICAgIGYuYWRkQ29kZShjLnJldChjLmkzMl9jb25zdCgwKSkpO1xuICAgIH1cblxuXG5cbiAgICBmdW5jdGlvbiBidWlsZEFkZCgpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9hZGRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImNcIiwgXCJpNjRcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5zZXRMb2NhbChcbiAgICAgICAgICAgIFwiY1wiLFxuICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgIGMuaTY0X2xvYWQzMl91KGMuZ2V0TG9jYWwoXCJ4XCIpKSxcbiAgICAgICAgICAgICAgICBjLmk2NF9sb2FkMzJfdShjLmdldExvY2FsKFwieVwiKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuaTY0X3N0b3JlMzIoXG4gICAgICAgICAgICBjLmdldExvY2FsKFwiclwiKSxcbiAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJjXCIpLFxuICAgICAgICApKTtcblxuICAgICAgICBmb3IgKGxldCBpPTE7IGk8bjMyOyBpKyspIHtcbiAgICAgICAgICAgIGYuYWRkQ29kZShjLnNldExvY2FsKCBcImNcIixcbiAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuaTY0X2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2xvYWQzMl91KGMuZ2V0TG9jYWwoXCJ4XCIpLCA0KmkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfbG9hZDMyX3UoYy5nZXRMb2NhbChcInlcIiksIDQqaSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UgKGMuZ2V0TG9jYWwoXCJjXCIpLCBjLmk2NF9jb25zdCgzMikpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIGYuYWRkQ29kZShjLmk2NF9zdG9yZTMyKFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJyXCIpLFxuICAgICAgICAgICAgICAgIGkqNCxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiY1wiKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmLmFkZENvZGUoYy5pMzJfd3JhcF9pNjQoYy5pNjRfc2hyX3UgKGMuZ2V0TG9jYWwoXCJjXCIpLCBjLmk2NF9jb25zdCgzMikpKSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZFN1YigpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9zdWJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImNcIiwgXCJpNjRcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5zZXRMb2NhbChcbiAgICAgICAgICAgIFwiY1wiLFxuICAgICAgICAgICAgYy5pNjRfc3ViKFxuICAgICAgICAgICAgICAgIGMuaTY0X2xvYWQzMl91KGMuZ2V0TG9jYWwoXCJ4XCIpKSxcbiAgICAgICAgICAgICAgICBjLmk2NF9sb2FkMzJfdShjLmdldExvY2FsKFwieVwiKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuaTY0X3N0b3JlMzIoXG4gICAgICAgICAgICBjLmdldExvY2FsKFwiclwiKSxcbiAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiY1wiKSxcbiAgICAgICAgICAgICAgICBjLmk2NF9jb25zdChcIjB4RkZGRkZGRkZcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgKSk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0xOyBpPG4zMjsgaSsrKSB7XG4gICAgICAgICAgICBmLmFkZENvZGUoYy5zZXRMb2NhbCggXCJjXCIsXG4gICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9sb2FkMzJfdShjLmdldExvY2FsKFwieFwiKSwgNCppKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2xvYWQzMl91KGMuZ2V0TG9jYWwoXCJ5XCIpLCA0KmkpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGMuaTY0X3Nocl9zIChjLmdldExvY2FsKFwiY1wiKSwgYy5pNjRfY29uc3QoMzIpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICBmLmFkZENvZGUoYy5pNjRfc3RvcmUzMihcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiclwiKSxcbiAgICAgICAgICAgICAgICBpKjQsXG4gICAgICAgICAgICAgICAgYy5pNjRfYW5kKCBjLmdldExvY2FsKFwiY1wiKSwgYy5pNjRfY29uc3QoXCIweEZGRkZGRkZGXCIpKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmLmFkZENvZGUoYy5pMzJfd3JhcF9pNjQgKCBjLmk2NF9zaHJfcyAoYy5nZXRMb2NhbChcImNcIiksIGMuaTY0X2NvbnN0KDMyKSkpKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTXVsKCkge1xuXG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX211bFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ5XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImMwXCIsIFwiaTY0XCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiYzFcIiwgXCJpNjRcIik7XG5cblxuICAgICAgICBmb3IgKGxldCBpPTA7aTxuMzI7IGkrKykge1xuICAgICAgICAgICAgZi5hZGRMb2NhbChcInhcIitpLCBcImk2NFwiKTtcbiAgICAgICAgICAgIGYuYWRkTG9jYWwoXCJ5XCIraSwgXCJpNjRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IGxvYWRYID0gW107XG4gICAgICAgIGNvbnN0IGxvYWRZID0gW107XG4gICAgICAgIGZ1bmN0aW9uIG11bGlqKGksIGopIHtcbiAgICAgICAgICAgIGxldCBYLFk7XG4gICAgICAgICAgICBpZiAoIWxvYWRYW2ldKSB7XG4gICAgICAgICAgICAgICAgWCA9IGMudGVlTG9jYWwoXCJ4XCIraSwgYy5pNjRfbG9hZDMyX3UoIGMuZ2V0TG9jYWwoXCJ4XCIpLCBpKjQpKTtcbiAgICAgICAgICAgICAgICBsb2FkWFtpXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFggPSBjLmdldExvY2FsKFwieFwiK2kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsb2FkWVtqXSkge1xuICAgICAgICAgICAgICAgIFkgPSBjLnRlZUxvY2FsKFwieVwiK2osIGMuaTY0X2xvYWQzMl91KCBjLmdldExvY2FsKFwieVwiKSwgaio0KSk7XG4gICAgICAgICAgICAgICAgbG9hZFlbal0gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBZID0gYy5nZXRMb2NhbChcInlcIitqKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGMuaTY0X211bCggWCwgWSApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGMwID0gXCJjMFwiO1xuICAgICAgICBsZXQgYzEgPSBcImMxXCI7XG5cbiAgICAgICAgZm9yIChsZXQgaz0wOyBrPG4zMioyLTE7IGsrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaT1NYXRoLm1heCgwLCBrLW4zMisxKTsgKGk8PWspJiYoaTxuMzIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqPSBrLWk7XG5cbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMHhGRkZGRkZGRilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bGlqKGksailcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgzMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICBjLmk2NF9zdG9yZTMyKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiclwiKSxcbiAgICAgICAgICAgICAgICAgICAgayo0LFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBbYzAsIGMxXSA9IFtjMSwgYzBdO1xuICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzEsXG4gICAgICAgICAgICAgICAgICAgIGMuaTY0X3Nocl91KFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgzMilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pNjRfc3RvcmUzMihcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiclwiKSxcbiAgICAgICAgICAgICAgICBuMzIqNCoyLTQsXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgIH1cblxuXG5cbiAgICBmdW5jdGlvbiBidWlsZFNxdWFyZSgpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9zcXVhcmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImMwXCIsIFwiaTY0XCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiYzFcIiwgXCJpNjRcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJjMF9vbGRcIiwgXCJpNjRcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJjMV9vbGRcIiwgXCJpNjRcIik7XG5cblxuICAgICAgICBmb3IgKGxldCBpPTA7aTxuMzI7IGkrKykge1xuICAgICAgICAgICAgZi5hZGRMb2NhbChcInhcIitpLCBcImk2NFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgbG9hZFggPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gbXVsaWooaSwgaikge1xuICAgICAgICAgICAgbGV0IFgsWTtcbiAgICAgICAgICAgIGlmICghbG9hZFhbaV0pIHtcbiAgICAgICAgICAgICAgICBYID0gYy50ZWVMb2NhbChcInhcIitpLCBjLmk2NF9sb2FkMzJfdSggYy5nZXRMb2NhbChcInhcIiksIGkqNCkpO1xuICAgICAgICAgICAgICAgIGxvYWRYW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgWCA9IGMuZ2V0TG9jYWwoXCJ4XCIraSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxvYWRYW2pdKSB7XG4gICAgICAgICAgICAgICAgWSA9IGMudGVlTG9jYWwoXCJ4XCIraiwgYy5pNjRfbG9hZDMyX3UoIGMuZ2V0TG9jYWwoXCJ4XCIpLCBqKjQpKTtcbiAgICAgICAgICAgICAgICBsb2FkWFtqXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFkgPSBjLmdldExvY2FsKFwieFwiK2opO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYy5pNjRfbXVsKCBYLCBZICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYzAgPSBcImMwXCI7XG4gICAgICAgIGxldCBjMSA9IFwiYzFcIjtcbiAgICAgICAgbGV0IGMwX29sZCA9IFwiYzBfb2xkXCI7XG4gICAgICAgIGxldCBjMV9vbGQgPSBcImMxX29sZFwiO1xuXG4gICAgICAgIGZvciAobGV0IGs9MDsgazxuMzIqMi0xOyBrKyspIHtcbiAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKGMwLCBjLmk2NF9jb25zdCgwKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChjMSwgYy5pNjRfY29uc3QoMCkpLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaT1NYXRoLm1heCgwLCBrLW4zMisxKTsgKGk8KChrKzEpPj4xKSApJiYoaTxuMzIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqPSBrLWk7XG5cbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMHhGRkZGRkZGRilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bGlqKGksailcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgzMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNdWx0aXBseSBieSAyXG4gICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChjMCxcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDB4RkZGRkZGRkYpXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKGMxLFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9zaGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9zaHJfdShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgzMilcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChrJTIgPT0gMCkge1xuICAgICAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChjMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgweEZGRkZGRkZGKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsaWooaz4+MSwgaz4+MSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgzMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9sZCBjYXJyeVxuXG4gICAgICAgICAgICBpZiAoaz4wKSB7XG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKGMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDB4RkZGRkZGRkYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzBfb2xkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMHhGRkZGRkZGRilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChjMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9zaHJfdShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzFfb2xkKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgIGMuaTY0X3N0b3JlMzIoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJyXCIpLFxuICAgICAgICAgICAgICAgICAgICBrKjQsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIGMwX29sZCxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIGMxX29sZCxcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwX29sZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgzMilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmk2NF9zdG9yZTMyKFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJyXCIpLFxuICAgICAgICAgICAgICAgIG4zMio0KjItNCxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwX29sZClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRTcXVhcmVPbGQoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX3NxdWFyZU9sZFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl9tdWxcIiwgYy5nZXRMb2NhbChcInhcIiksIGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmdldExvY2FsKFwiclwiKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9idWlsZE11bDEoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX19tdWwxXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ5XCIsIFwiaTY0XCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJjXCIsIFwiaTY0XCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuc2V0TG9jYWwoXG4gICAgICAgICAgICBcImNcIixcbiAgICAgICAgICAgIGMuaTY0X211bChcbiAgICAgICAgICAgICAgICBjLmk2NF9sb2FkMzJfdShjLmdldExvY2FsKFwicHhcIiksIDAsIDApLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJ5XCIpXG4gICAgICAgICAgICApXG4gICAgICAgICkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShjLmk2NF9zdG9yZTMyKFxuICAgICAgICAgICAgYy5nZXRMb2NhbChcInByXCIpLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBjLmdldExvY2FsKFwiY1wiKSxcbiAgICAgICAgKSk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0xOyBpPG4zMjsgaSsrKSB7XG4gICAgICAgICAgICBmLmFkZENvZGUoYy5zZXRMb2NhbCggXCJjXCIsXG4gICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9sb2FkMzJfdShjLmdldExvY2FsKFwicHhcIiksIDQqaSwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwieVwiKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9zaHJfdSAoYy5nZXRMb2NhbChcImNcIiksIGMuaTY0X2NvbnN0KDMyKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgZi5hZGRDb2RlKGMuaTY0X3N0b3JlMzIoXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInByXCIpLFxuICAgICAgICAgICAgICAgIGkqNCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJjXCIpXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9idWlsZEFkZDEoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX19hZGQxXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInlcIiwgXCJpNjRcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJjXCIsIFwiaTY0XCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwicHhcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5zZXRMb2NhbChcInB4XCIsIGMuZ2V0TG9jYWwoXCJ4XCIpKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuc2V0TG9jYWwoXG4gICAgICAgICAgICBcImNcIixcbiAgICAgICAgICAgIGMuaTY0X2FkZChcbiAgICAgICAgICAgICAgICBjLmk2NF9sb2FkMzJfdShjLmdldExvY2FsKFwicHhcIiksIDAsIDApLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJ5XCIpXG4gICAgICAgICAgICApXG4gICAgICAgICkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShjLmk2NF9zdG9yZTMyKFxuICAgICAgICAgICAgYy5nZXRMb2NhbChcInB4XCIpLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBjLmdldExvY2FsKFwiY1wiKSxcbiAgICAgICAgKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuc2V0TG9jYWwoXG4gICAgICAgICAgICBcImNcIixcbiAgICAgICAgICAgIGMuaTY0X3Nocl91KFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJjXCIpLFxuICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDMyKVxuICAgICAgICAgICAgKVxuICAgICAgICApKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICBjLmJyX2lmKFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgYy5pNjRfZXF6KGMuZ2V0TG9jYWwoXCJjXCIpKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgXCJweFwiLFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCg0KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgXCJjXCIsXG4gICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9sb2FkMzJfdShjLmdldExvY2FsKFwicHhcIiksIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiY1wiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGMuaTY0X3N0b3JlMzIoXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInB4XCIpLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiY1wiKSxcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgXCJjXCIsXG4gICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJjXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgzMilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICkpKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRGl2KCkge1xuICAgICAgICBfYnVpbGRNdWwxKCk7XG4gICAgICAgIF9idWlsZEFkZDEoKTtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9kaXZcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcImNcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwicnJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJjY1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImVYXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiZVlcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJzeVwiLCBcImk2NFwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInN4XCIsIFwiaTY0XCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiZWNcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBZID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IENhdXggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgUmF1eCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBDID0gYy5nZXRMb2NhbChcImNjXCIpO1xuICAgICAgICBjb25zdCBSID0gYy5nZXRMb2NhbChcInJyXCIpO1xuICAgICAgICBjb25zdCBwcjEgPSBtb2R1bGUuYWxsb2MobjgqMik7XG4gICAgICAgIGNvbnN0IFIxID0gYy5pMzJfY29uc3QocHIxKTtcbiAgICAgICAgY29uc3QgUjIgPSBjLmkzMl9jb25zdChwcjErbjgpO1xuXG4gICAgICAgIC8vIEljIGMgaXMgMCB0aGVuIHN0b3JlIGl0IGluIGFuIGF1eGlsaWFyeSBidWZmZXJcbiAgICAgICAgZi5hZGRDb2RlKGMuaWYoXG4gICAgICAgICAgICBjLmdldExvY2FsKFwiY1wiKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJjY1wiLCBjLmdldExvY2FsKFwiY1wiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiY2NcIiwgQ2F1eClcbiAgICAgICAgKSk7XG5cbiAgICAgICAgLy8gSWMgciBpcyAwIHRoZW4gc3RvcmUgaXQgaW4gYW4gYXV4aWxpYXJ5IGJ1ZmZlclxuICAgICAgICBmLmFkZENvZGUoYy5pZihcbiAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJyXCIpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInJyXCIsIGMuZ2V0TG9jYWwoXCJyXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJyclwiLCBSYXV4KVxuICAgICAgICApKTtcblxuICAgICAgICAvLyBDb3B5XG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwocHJlZml4ICsgXCJfY29weVwiLCBjLmdldExvY2FsKFwieFwiKSwgUikpO1xuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKHByZWZpeCArIFwiX2NvcHlcIiwgYy5nZXRMb2NhbChcInlcIiksIFkpKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl96ZXJvXCIsIEMpKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl96ZXJvXCIsIFIxKSk7XG5cblxuICAgICAgICBmLmFkZENvZGUoYy5zZXRMb2NhbChcImVYXCIsIGMuaTMyX2NvbnN0KG44LTEpKSk7XG4gICAgICAgIGYuYWRkQ29kZShjLnNldExvY2FsKFwiZVlcIiwgYy5pMzJfY29uc3QobjgtMSkpKTtcblxuICAgICAgICAvLyB3aGlsZSAoZVk+MykmJihZW2VZXT09MCkgZXktLTtcbiAgICAgICAgZi5hZGRDb2RlKGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgYy5icl9pZihcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgIGMuaTMyX29yKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9sb2FkOF91KFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfYWRkKFkgLCBjLmdldExvY2FsKFwiZVlcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfZXEoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiZVlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgzKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJlWVwiLCBjLmkzMl9zdWIoYy5nZXRMb2NhbChcImVZXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgYy5icigwKVxuICAgICAgICApKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICBcInN5XCIsXG4gICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9sb2FkMzJfdShcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX3N1YihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoIFksIGMuZ2V0TG9jYWwoXCJlWVwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMylcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgxKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBGb3JjZSBhIGRpdmlkZSBieSAwIGlmIHF1b3RpZW4gaXMgMFxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuaTY0X2VxKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic3lcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDEpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmRyb3AoYy5pNjRfZGl2X3UoYy5pNjRfY29uc3QoMCksIGMuaTY0X2NvbnN0KDApKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5ibG9jayhjLmxvb3AoXG5cbiAgICAgICAgICAgIC8vIHdoaWxlIChlWD43KSYmKFlbZVhdPT0wKSBleC0tO1xuICAgICAgICAgICAgYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICAgICAgYy5icl9pZihcbiAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9sb2FkOF91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChSICwgYy5nZXRMb2NhbChcImVYXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9lcShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiZVhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoNylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImVYXCIsIGMuaTMyX3N1YihjLmdldExvY2FsKFwiZVhcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSksXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgXCJzeFwiLFxuICAgICAgICAgICAgICAgIGMuaTY0X2xvYWQoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX3N1YihcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZCggUiwgYy5nZXRMb2NhbChcImVYXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDcpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgIFwic3hcIixcbiAgICAgICAgICAgICAgICBjLmk2NF9kaXZfdShcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInN4XCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic3lcIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICBcImVjXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfc3ViKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiZVhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiZVlcIilcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoNClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAvLyBXaGlsZSBncmVhdGVyIHRoYW4gMzIgYml0cyBvciBlYyBpcyBuZWcsIHNociBhbmQgaW5jIGV4cFxuICAgICAgICAgICAgYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICAgICAgYy5icl9pZihcbiAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfYW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfZXF6KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInN4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdChcIjB4RkZGRkZGRkYwMDAwMDAwMFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9nZV9zKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJlY1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwic3hcIixcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic3hcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCg4KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwiZWNcIixcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImVjXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSksXG5cbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5pNjRfZXF6KGMuZ2V0TG9jYWwoXCJzeFwiKSksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAuLi5jLmJyX2lmKFxuICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxeihjLmNhbGwocHJlZml4ICsgXCJfZ3RlXCIsIFIsIFkpKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwic3hcIiwgYy5pNjRfY29uc3QoMSkpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwiZWNcIiwgYy5pMzJfY29uc3QoMCkpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX19tdWwxXCIsIFksIGMuZ2V0TG9jYWwoXCJzeFwiKSwgUjIpLFxuICAgICAgICAgICAgYy5kcm9wKGMuY2FsbChcbiAgICAgICAgICAgICAgICBwcmVmaXggKyBcIl9zdWJcIixcbiAgICAgICAgICAgICAgICBSLFxuICAgICAgICAgICAgICAgIGMuaTMyX3N1YihSMiwgYy5nZXRMb2NhbChcImVjXCIpKSxcbiAgICAgICAgICAgICAgICBSXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICBwcmVmaXggKyBcIl9fYWRkMVwiLFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChDLCBjLmdldExvY2FsKFwiZWNcIikpLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJzeFwiKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkSW52ZXJzZU1vZCgpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9pbnZlcnNlTW9kXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwbVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInByXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwidFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIm5ld3RcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwicXFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJxclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIm5ld3JcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJzd3BcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwic2lnbnRcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJzaWdubmV3dFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInNpZ254XCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgYXV4MSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBhdXgyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IGF1eDMgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgYXV4NCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBhdXg1ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IGF1eDYgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgbXVsQnVmZiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCoyKSk7XG4gICAgICAgIGNvbnN0IGF1eDcgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLnNldExvY2FsKFwidFwiLCBhdXgxKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl96ZXJvXCIsIGF1eDEpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInNpZ250XCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiclwiLCBhdXgyKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9jb3B5XCIsIGMuZ2V0TG9jYWwoXCJwbVwiKSwgYXV4MilcbiAgICAgICAgKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLnNldExvY2FsKFwibmV3dFwiLCBhdXgzKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9vbmVcIiwgYXV4MyksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwic2lnbm5ld3RcIiwgYy5pMzJfY29uc3QoMCkpLFxuICAgICAgICApO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJuZXdyXCIsIGF1eDQpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2NvcHlcIiwgYy5nZXRMb2NhbChcInB4XCIpLCBhdXg0KVxuICAgICAgICApO1xuXG5cblxuXG4gICAgICAgIGYuYWRkQ29kZShjLnNldExvY2FsKFwicXFcIiwgYXV4NSkpO1xuICAgICAgICBmLmFkZENvZGUoYy5zZXRMb2NhbChcInFyXCIsIGF1eDYpKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuc2V0TG9jYWwoXCJ4XCIsIGF1eDcpKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICBjLmJyX2lmKFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2lzWmVyb1wiLCBjLmdldExvY2FsKFwibmV3clwiKSApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2RpdlwiLCBjLmdldExvY2FsKFwiclwiKSwgYy5nZXRMb2NhbChcIm5ld3JcIiksIGMuZ2V0TG9jYWwoXCJxcVwiKSwgYy5nZXRMb2NhbChcInFyXCIpKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX211bFwiLCBjLmdldExvY2FsKFwicXFcIiksIGMuZ2V0TG9jYWwoXCJuZXd0XCIpLCBtdWxCdWZmKSxcblxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic2lnbnRcIiksXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInNpZ25uZXd0XCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9ndGVcIiwgbXVsQnVmZiwgYy5nZXRMb2NhbChcInRcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuZHJvcChjLmNhbGwocHJlZml4ICsgXCJfc3ViXCIsIG11bEJ1ZmYsIGMuZ2V0TG9jYWwoXCJ0XCIpLCBjLmdldExvY2FsKFwieFwiKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuc2V0TG9jYWwoXCJzaWdueFwiLCBjLmkzMl9jb25zdCgwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5kcm9wKGMuY2FsbChwcmVmaXggKyBcIl9zdWJcIiwgYy5nZXRMb2NhbChcInRcIiksIG11bEJ1ZmYsIGMuZ2V0TG9jYWwoXCJ4XCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcInNpZ254XCIsIGMuaTMyX2NvbnN0KDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5kcm9wKGMuY2FsbChwcmVmaXggKyBcIl9hZGRcIiwgbXVsQnVmZiwgYy5nZXRMb2NhbChcInRcIiksIGMuZ2V0TG9jYWwoXCJ4XCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwic2lnbnhcIiwgYy5pMzJfY29uc3QoMSkpXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJzaWdubmV3dFwiKSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5kcm9wKGMuY2FsbChwcmVmaXggKyBcIl9hZGRcIiwgbXVsQnVmZiwgYy5nZXRMb2NhbChcInRcIiksIGMuZ2V0TG9jYWwoXCJ4XCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwic2lnbnhcIiwgYy5pMzJfY29uc3QoMCkpXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGMuaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2d0ZVwiLCBjLmdldExvY2FsKFwidFwiKSwgbXVsQnVmZiksXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5kcm9wKGMuY2FsbChwcmVmaXggKyBcIl9zdWJcIiwgYy5nZXRMb2NhbChcInRcIiksIG11bEJ1ZmYsIGMuZ2V0TG9jYWwoXCJ4XCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcInNpZ254XCIsIGMuaTMyX2NvbnN0KDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jLmRyb3AoYy5jYWxsKHByZWZpeCArIFwiX3N1YlwiLCBtdWxCdWZmLCBjLmdldExvY2FsKFwidFwiKSwgYy5nZXRMb2NhbChcInhcIikpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwic2lnbnhcIiwgYy5pMzJfY29uc3QoMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBjLnNldExvY2FsKFwic3dwXCIsIGMuZ2V0TG9jYWwoXCJ0XCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJ0XCIsIGMuZ2V0TG9jYWwoXCJuZXd0XCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJuZXd0XCIsIGMuZ2V0TG9jYWwoXCJ4XCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJ4XCIsIGMuZ2V0TG9jYWwoXCJzd3BcIikpLFxuXG4gICAgICAgICAgICBjLnNldExvY2FsKFwic2lnbnRcIiwgYy5nZXRMb2NhbChcInNpZ25uZXd0XCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJzaWdubmV3dFwiLCBjLmdldExvY2FsKFwic2lnbnhcIikpLFxuXG4gICAgICAgICAgICBjLnNldExvY2FsKFwic3dwXCIsIGMuZ2V0TG9jYWwoXCJyXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJyXCIsIGMuZ2V0TG9jYWwoXCJuZXdyXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJuZXdyXCIsIGMuZ2V0TG9jYWwoXCJxclwiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwicXJcIiwgYy5nZXRMb2NhbChcInN3cFwiKSksXG5cbiAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgKSkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShjLmlmKFxuICAgICAgICAgICAgYy5nZXRMb2NhbChcInNpZ250XCIpLFxuICAgICAgICAgICAgYy5kcm9wKGMuY2FsbChwcmVmaXggKyBcIl9zdWJcIiwgYy5nZXRMb2NhbChcInBtXCIpLCBjLmdldExvY2FsKFwidFwiKSwgYy5nZXRMb2NhbChcInByXCIpKSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfY29weVwiLCBjLmdldExvY2FsKFwidFwiKSwgYy5nZXRMb2NhbChcInByXCIpKVxuICAgICAgICApKTtcbiAgICB9XG5cblxuICAgIGJ1aWxkQ29weSgpO1xuICAgIGJ1aWxkWmVybygpO1xuICAgIGJ1aWxkSXNaZXJvKCk7XG4gICAgYnVpbGRPbmUoKTtcbiAgICBidWlsZEVxKCk7XG4gICAgYnVpbGRHdGUoKTtcbiAgICBidWlsZEFkZCgpO1xuICAgIGJ1aWxkU3ViKCk7XG4gICAgYnVpbGRNdWwoKTtcbiAgICBidWlsZFNxdWFyZSgpO1xuICAgIGJ1aWxkU3F1YXJlT2xkKCk7XG4gICAgYnVpbGREaXYoKTtcbiAgICBidWlsZEludmVyc2VNb2QoKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4K1wiX2NvcHlcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCtcIl96ZXJvXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXgrXCJfb25lXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXgrXCJfaXNaZXJvXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXgrXCJfZXFcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCtcIl9ndGVcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCtcIl9hZGRcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCtcIl9zdWJcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCtcIl9tdWxcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCtcIl9zcXVhcmVcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCtcIl9zcXVhcmVPbGRcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCtcIl9kaXZcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCtcIl9pbnZlcnNlTW9kXCIpO1xuXG4gICAgcmV0dXJuIHByZWZpeDtcbn07XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTkgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3YXNtc25hcmsgKFdlYiBBc3NlbWJseSB6a1NuYXJrIFByb3ZlcikuXG5cbiAgICB3YXNtc25hcmsgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3YXNtc25hcmsgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2FzbXNuYXJrLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxudmFyIGJ1aWxkX3RpbWVzc2NhbGFyID0gZnVuY3Rpb24gYnVpbGRUaW1lc1NjYWxhcihtb2R1bGUsIGZuTmFtZSwgZWxlbWVudExlbiwgb3BBQiwgb3BBQSwgb3BDb3B5LCBvcEluaXQpIHtcblxuICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24oZm5OYW1lKTtcbiAgICBmLmFkZFBhcmFtKFwiYmFzZVwiLCBcImkzMlwiKTtcbiAgICBmLmFkZFBhcmFtKFwic2NhbGFyXCIsIFwiaTMyXCIpO1xuICAgIGYuYWRkUGFyYW0oXCJzY2FsYXJMZW5ndGhcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcImlcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcImJcIiwgXCJpMzJcIik7XG5cbiAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgY29uc3QgYXV4ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGVsZW1lbnRMZW4pKTtcblxuICAgIGYuYWRkQ29kZShcbiAgICAgICAgYy5pZihcbiAgICAgICAgICAgIGMuaTMyX2VxeihjLmdldExvY2FsKFwic2NhbGFyTGVuZ3RoXCIpKSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAuLi5jLmNhbGwob3BJbml0LCBjLmdldExvY2FsKFwiclwiKSksXG4gICAgICAgICAgICAgICAgLi4uYy5yZXQoW10pXG4gICAgICAgICAgICBdXG4gICAgICAgIClcbiAgICApO1xuICAgIGYuYWRkQ29kZShjLmNhbGwob3BDb3B5LCBjLmdldExvY2FsKFwiYmFzZVwiKSwgYXV4KSk7XG4gICAgZi5hZGRDb2RlKGMuY2FsbChvcEluaXQsIGMuZ2V0TG9jYWwoXCJyXCIpKSk7XG4gICAgZi5hZGRDb2RlKGMuc2V0TG9jYWwoXCJpXCIsIGMuZ2V0TG9jYWwoXCJzY2FsYXJMZW5ndGhcIikpKTtcbiAgICBmLmFkZENvZGUoYy5ibG9jayhjLmxvb3AoXG4gICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX3N1YihjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QoMSkpKSxcblxuICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgXCJiXCIsXG4gICAgICAgICAgICBjLmkzMl9sb2FkOF91KFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInNjYWxhclwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlcIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIC4uLmlubmVyTG9vcCgpLFxuICAgICAgICBjLmJyX2lmKDEsIGMuaTMyX2VxeiAoIGMuZ2V0TG9jYWwoXCJpXCIpICkpLFxuICAgICAgICBjLmJyKDApXG4gICAgKSkpO1xuXG5cbiAgICBmdW5jdGlvbiBpbm5lckxvb3AoKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDg7IGkrKykge1xuICAgICAgICAgICAgY29kZS5wdXNoKFxuICAgICAgICAgICAgICAgIC4uLmMuY2FsbChvcEFBLCBjLmdldExvY2FsKFwiclwiKSwgYy5nZXRMb2NhbChcInJcIikpLFxuICAgICAgICAgICAgICAgIC4uLmMuaWYoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2dlX3UoIGMuZ2V0TG9jYWwoXCJiXCIpLCBjLmkzMl9jb25zdCgweDgwID4+IGkpKSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJiXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgweDgwID4+IGkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChvcEFCLCBjLmdldExvY2FsKFwiclwiKSxhdXgsIGMuZ2V0TG9jYWwoXCJyXCIpKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG5cbn07XG5cbnZhciBidWlsZF9iYXRjaGludmVyc2UgPSBidWlsZEJhdGNoSW52ZXJzZSQzO1xuXG5mdW5jdGlvbiBidWlsZEJhdGNoSW52ZXJzZSQzKG1vZHVsZSwgcHJlZml4KSB7XG5cblxuICAgIGNvbnN0IG44ID0gbW9kdWxlLm1vZHVsZXNbcHJlZml4XS5uNjQqODtcblxuICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2JhdGNoSW52ZXJzZVwiKTtcbiAgICBmLmFkZFBhcmFtKFwicEluXCIsIFwiaTMyXCIpO1xuICAgIGYuYWRkUGFyYW0oXCJpblN0ZXBcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRQYXJhbShcIm5cIiwgXCJpMzJcIik7XG4gICAgZi5hZGRQYXJhbShcInBPdXRcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRQYXJhbShcIm91dFN0ZXBcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcIml0QXV4XCIsIFwiaTMyXCIpO1xuICAgIGYuYWRkTG9jYWwoXCJpdEluXCIsIFwiaTMyXCIpO1xuICAgIGYuYWRkTG9jYWwoXCJpdE91dFwiLFwiaTMyXCIpO1xuICAgIGYuYWRkTG9jYWwoXCJpXCIsXCJpMzJcIik7XG5cbiAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgY29uc3QgQVVYID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG5cblxuICAgIC8vIEFsbG9jIFdvcmtpbmcgc3BhY2UgZm9yIGFjY3VtdWxhdGVkIHVtbHRpcGxpY2F0aW9uc1xuICAgIGYuYWRkQ29kZShcbiAgICAgICAgYy5zZXRMb2NhbChcIml0QXV4XCIsIGMuaTMyX2xvYWQoIGMuaTMyX2NvbnN0KDApICkpLFxuICAgICAgICBjLmkzMl9zdG9yZShcbiAgICAgICAgICAgIGMuaTMyX2NvbnN0KDApLFxuICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdEF1eFwiKSxcbiAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjgpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgKTtcblxuICAgIGYuYWRkQ29kZShcblxuICAgICAgICAvLyBhdXhbMF0gPSBhO1xuICAgICAgICBjLmNhbGwocHJlZml4K1wiX29uZVwiLCBjLmdldExvY2FsKFwiaXRBdXhcIikpLFxuICAgICAgICAvLyBmb3IgKGk9MDtpPG47aSsrKSBhdXhbaV0gPSBhdXhbaS0xXSppbltpXVxuICAgICAgICBjLnNldExvY2FsKFwiaXRJblwiLCBjLmdldExvY2FsKFwicEluXCIpKSxcbiAgICAgICAgYy5zZXRMb2NhbChcIml0QXV4XCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRBdXhcIiksIGMuaTMyX2NvbnN0KG44KSkpLFxuICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9jb25zdCgwKSksXG5cbiAgICAgICAgYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICBjLmJyX2lmKDEsIGMuaTMyX2VxICggYy5nZXRMb2NhbChcImlcIiksIGMuZ2V0TG9jYWwoXCJuXCIpICkpLFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4K1wiX2lzWmVyb1wiLCBjLmdldExvY2FsKFwiaXRJblwiKSksXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggKyBcIl9jb3B5XCIsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX3N1YihjLmdldExvY2FsKFwiaXRBdXhcIiksIGMuaTMyX2NvbnN0KG44KSksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdEF1eFwiKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXgrXCJfbXVsXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdEluXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9zdWIoYy5nZXRMb2NhbChcIml0QXV4XCIpLCBjLmkzMl9jb25zdChuOCkpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXRBdXhcIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0SW5cIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpdEluXCIpLCBjLmdldExvY2FsKFwiaW5TdGVwXCIpKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaXRBdXhcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpdEF1eFwiKSwgYy5pMzJfY29uc3QobjgpKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcImlcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICkpLFxuXG4gICAgICAgIC8vIHBvaW50IHRvIHRoZSBsYXN0XG4gICAgICAgIGMuc2V0TG9jYWwoXCJpdEluXCIsIGMuaTMyX3N1YihjLmdldExvY2FsKFwiaXRJblwiKSwgYy5nZXRMb2NhbChcImluU3RlcFwiKSkpLFxuICAgICAgICBjLnNldExvY2FsKFwiaXRBdXhcIiwgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJpdEF1eFwiKSwgYy5pMzJfY29uc3QobjgpKSksXG4gICAgICAgIC8vIGl0T3V0ID0gcE91dCArIChuLTEpKnN0ZXBPdXQgICAvLyBQb2ludCB0byB0aGUgbGFzdFxuICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgXCJpdE91dFwiLFxuICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwT3V0XCIpLFxuICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJuXCIpLCBjLmkzMl9jb25zdCgxKSksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJvdXRTdGVwXCIpLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKSxcblxuICAgICAgICAvLyBhdXhbbi0xXSA9IDEvYXV4W24tMV1cbiAgICAgICAgYy5jYWxsKHByZWZpeCtcIl9pbnZlcnNlXCIsIGMuZ2V0TG9jYWwoXCJpdEF1eFwiKSwgYy5nZXRMb2NhbChcIml0QXV4XCIpICksXG5cbiAgICAgICAgYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICBjLmJyX2lmKDEsIGMuaTMyX2VxeiggYy5nZXRMb2NhbChcImlcIikpKSxcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCtcIl9pc1plcm9cIiwgYy5nZXRMb2NhbChcIml0SW5cIikpLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ICsgXCJfY29weVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0QXV4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJpdEF1eFwiKSwgYy5pMzJfY29uc3QobjgpKSxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ICsgXCJfemVyb1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0T3V0XCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdLFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX2NvcHlcIiwgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJpdEF1eFwiKSwgYy5pMzJfY29uc3QobjgpKSwgQVVYKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4K1wiX211bFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0QXV4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0SW5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9zdWIoYy5nZXRMb2NhbChcIml0QXV4XCIpLCBjLmkzMl9jb25zdChuOCkpLFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXgrXCJfbXVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXRBdXhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBBVVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXRPdXRcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaXRJblwiLCBjLmkzMl9zdWIoYy5nZXRMb2NhbChcIml0SW5cIiksIGMuZ2V0TG9jYWwoXCJpblN0ZXBcIikpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdE91dFwiLCBjLmkzMl9zdWIoYy5nZXRMb2NhbChcIml0T3V0XCIpLCBjLmdldExvY2FsKFwib3V0U3RlcFwiKSkpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0QXV4XCIsIGMuaTMyX3N1YihjLmdldExvY2FsKFwiaXRBdXhcIiksIGMuaTMyX2NvbnN0KG44KSkpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgYy5icigwKVxuICAgICAgICApKVxuXG4gICAgKTtcblxuXG4gICAgLy8gUmVjb3ZlciBPbGQgbWVtb3J5XG4gICAgZi5hZGRDb2RlKFxuICAgICAgICBjLmkzMl9zdG9yZShcbiAgICAgICAgICAgIGMuaTMyX2NvbnN0KDApLFxuICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0QXV4XCIpXG4gICAgICAgIClcbiAgICApO1xuXG59XG5cbnZhciBidWlsZF9iYXRjaGNvbnZlcnRpb24gPSBidWlsZEJhdGNoQ29udmVydGlvbiQzO1xuXG5mdW5jdGlvbiBidWlsZEJhdGNoQ29udmVydGlvbiQzKG1vZHVsZSwgZm5OYW1lLCBpbnRlcm5hbEZuTmFtZSwgc2l6ZUluLCBzaXplT3V0LCByZXZlcnNlKSB7XG4gICAgaWYgKHR5cGVvZiByZXZlcnNlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIFNldCB0aGUgcmV2ZXJzZSBpbiBhIHdheSB0aGF0IGFsbG93cyB0byB1c2UgdGhlIHNhbWUgYnVmZmVyIGFzIGluL291dC5cbiAgICAgICAgaWYgKHNpemVJbiA8IHNpemVPdXQpIHtcbiAgICAgICAgICAgIHJldmVyc2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihmbk5hbWUpO1xuICAgIGYuYWRkUGFyYW0oXCJwSW5cIiwgXCJpMzJcIik7XG4gICAgZi5hZGRQYXJhbShcIm5cIiwgXCJpMzJcIik7XG4gICAgZi5hZGRQYXJhbShcInBPdXRcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcImlcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcIml0SW5cIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcIml0T3V0XCIsIFwiaTMyXCIpO1xuXG4gICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdEluXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEluXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChzaXplSW4pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0T3V0XCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicE91dFwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDEpXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3Qoc2l6ZU91dClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICBjLmJyX2lmKDEsIGMuaTMyX2VxICggYy5nZXRMb2NhbChcImlcIiksIGMuZ2V0TG9jYWwoXCJuXCIpICkpLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKGludGVybmFsRm5OYW1lLCBjLmdldExvY2FsKFwiaXRJblwiKSwgYy5nZXRMb2NhbChcIml0T3V0XCIpKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdEluXCIsIGMuaTMyX3N1YihjLmdldExvY2FsKFwiaXRJblwiKSwgYy5pMzJfY29uc3Qoc2l6ZUluKSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdE91dFwiLCBjLmkzMl9zdWIoYy5nZXRMb2NhbChcIml0T3V0XCIpLCBjLmkzMl9jb25zdChzaXplT3V0KSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKSxcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaXRJblwiLCBjLmdldExvY2FsKFwicEluXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdE91dFwiLCBjLmdldExvY2FsKFwicE91dFwiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICBjLmJyX2lmKDEsIGMuaTMyX2VxICggYy5nZXRMb2NhbChcImlcIiksIGMuZ2V0TG9jYWwoXCJuXCIpICkpLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKGludGVybmFsRm5OYW1lLCBjLmdldExvY2FsKFwiaXRJblwiKSwgYy5nZXRMb2NhbChcIml0T3V0XCIpKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdEluXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRJblwiKSwgYy5pMzJfY29uc3Qoc2l6ZUluKSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdE91dFwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0T3V0XCIpLCBjLmkzMl9jb25zdChzaXplT3V0KSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKSxcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbnZhciBidWlsZF9iYXRjaG9wID0gYnVpbGRCYXRjaENvbnZlcnRpb24kMjtcblxuZnVuY3Rpb24gYnVpbGRCYXRjaENvbnZlcnRpb24kMihtb2R1bGUsIGZuTmFtZSwgaW50ZXJuYWxGbk5hbWUsIHNpemVJbiwgc2l6ZU91dCwgcmV2ZXJzZSkge1xuICAgIGlmICh0eXBlb2YgcmV2ZXJzZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBTZXQgdGhlIHJldmVyc2UgaW4gYSB3YXkgdGhhdCBhbGxvd3MgdG8gdXNlIHRoZSBzYW1lIGJ1ZmZlciBhcyBpbi9vdXQuXG4gICAgICAgIGlmIChzaXplSW4gPCBzaXplT3V0KSB7XG4gICAgICAgICAgICByZXZlcnNlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24oZm5OYW1lKTtcbiAgICBmLmFkZFBhcmFtKFwicEluMVwiLCBcImkzMlwiKTtcbiAgICBmLmFkZFBhcmFtKFwicEluMlwiLCBcImkzMlwiKTtcbiAgICBmLmFkZFBhcmFtKFwiblwiLCBcImkzMlwiKTtcbiAgICBmLmFkZFBhcmFtKFwicE91dFwiLCBcImkzMlwiKTtcbiAgICBmLmFkZExvY2FsKFwiaVwiLCBcImkzMlwiKTtcbiAgICBmLmFkZExvY2FsKFwiaXRJbjFcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcIml0SW4yXCIsIFwiaTMyXCIpO1xuICAgIGYuYWRkTG9jYWwoXCJpdE91dFwiLCBcImkzMlwiKTtcblxuICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaXRJbjFcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwSW4xXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChzaXplSW4pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0SW4yXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEluMlwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDEpXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3Qoc2l6ZUluKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdE91dFwiLFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBPdXRcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX3N1YihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KHNpemVPdXQpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfY29uc3QoMCkpLFxuICAgICAgICAgICAgYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICAgICAgYy5icl9pZigxLCBjLmkzMl9lcSAoIGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmdldExvY2FsKFwiblwiKSApKSxcblxuICAgICAgICAgICAgICAgIGMuY2FsbChpbnRlcm5hbEZuTmFtZSwgYy5nZXRMb2NhbChcIml0SW4xXCIpLCBjLmdldExvY2FsKFwiaXRJbjJcIiksIGMuZ2V0TG9jYWwoXCJpdE91dFwiKSksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaXRJbjFcIiwgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJpdEluMVwiKSwgYy5pMzJfY29uc3Qoc2l6ZUluKSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdEluMlwiLCBjLmkzMl9zdWIoYy5nZXRMb2NhbChcIml0SW4yXCIpLCBjLmkzMl9jb25zdChzaXplSW4pKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0T3V0XCIsIGMuaTMyX3N1YihjLmdldExvY2FsKFwiaXRPdXRcIiksIGMuaTMyX2NvbnN0KHNpemVPdXQpKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpLFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdEluMVwiLCBjLmdldExvY2FsKFwicEluMVwiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaXRJbjJcIiwgYy5nZXRMb2NhbChcInBJbjJcIikpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0T3V0XCIsIGMuZ2V0TG9jYWwoXCJwT3V0XCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoMSwgYy5pMzJfZXEgKCBjLmdldExvY2FsKFwiaVwiKSwgYy5nZXRMb2NhbChcIm5cIikgKSksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoaW50ZXJuYWxGbk5hbWUsIGMuZ2V0TG9jYWwoXCJpdEluMVwiKSwgYy5nZXRMb2NhbChcIml0SW4yXCIpLCBjLmdldExvY2FsKFwiaXRPdXRcIikpLFxuXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0SW4xXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRJbjFcIiksIGMuaTMyX2NvbnN0KHNpemVJbikpKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaXRJbjJcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpdEluMlwiKSwgYy5pMzJfY29uc3Qoc2l6ZUluKSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdE91dFwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0T3V0XCIpLCBjLmkzMl9jb25zdChzaXplT3V0KSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKSxcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbnZhciBiaWdpbnQgPSB7fTtcblxuLy8gTWFueSBvZiB0aGVzZSB1dGlsaXRpZXMgYXJlIGZyb20gdGhlIGBiaWctaW50ZWdlcmAgbGlicmFyeSxcbi8vIGJ1dCBhZGp1c3RlZCB0byBvbmx5IHdvcmsgd2l0aCBuYXRpdmUgQmlnSW50IHR5cGVcbi8vIFJlZiBodHRwczovL2dpdGh1Yi5jb20vcGV0ZXJvbHNvbi9CaWdJbnRlZ2VyLmpzL2Jsb2IvZTVkMjE1NGQzYzQxNzA2OWM1MWU3MTE2YmFmYzNiOTFkMGI5ZmU0MS9CaWdJbnRlZ2VyLmpzXG4vLyBPcmlnaW5hbGx5IGxpY2Vuc2VkIFRoZSBVbmxpY2Vuc2VcblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG59XG5cbmZ1bmN0aW9uIHNxdWFyZSQxKG4pIHtcbiAgICByZXR1cm4gbiAqIG47XG59XG5cbmZ1bmN0aW9uIGlzT2RkJDQobikge1xuICAgIHJldHVybiBuICUgMm4gIT09IDBuO1xufVxuXG5mdW5jdGlvbiBpc0V2ZW4obikge1xuICAgIHJldHVybiBuICUgMm4gPT09IDBuO1xufVxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlJDMobikge1xuICAgIHJldHVybiBuIDwgMG47XG59XG5cbmZ1bmN0aW9uIGlzUG9zaXRpdmUobikge1xuICAgIHJldHVybiBuID4gMG47XG59XG5cbmZ1bmN0aW9uIGJpdExlbmd0aCQ1KG4pIHtcbiAgICBpZiAoaXNOZWdhdGl2ZSQzKG4pKSB7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKDIpLmxlbmd0aCAtIDE7IC8vIGRpc2NhcmQgdGhlIC0gc2lnblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFicyhuKSB7XG4gICAgcmV0dXJuIG4gPCAwbiA/IC1uIDogbjtcbn1cblxuZnVuY3Rpb24gaXNVbml0KG4pIHtcbiAgICByZXR1cm4gYWJzKG4pID09PSAxbjtcbn1cblxuZnVuY3Rpb24gbW9kSW52JDMoYSwgbikge1xuICAgIHZhciB0ID0gMG4sIG5ld1QgPSAxbiwgciA9IG4sIG5ld1IgPSBhYnMoYSksIHEsIGxhc3RULCBsYXN0UjtcbiAgICB3aGlsZSAobmV3UiAhPT0gMG4pIHtcbiAgICAgICAgcSA9IHIgLyBuZXdSO1xuICAgICAgICBsYXN0VCA9IHQ7XG4gICAgICAgIGxhc3RSID0gcjtcbiAgICAgICAgdCA9IG5ld1Q7XG4gICAgICAgIHIgPSBuZXdSO1xuICAgICAgICBuZXdUID0gbGFzdFQgLSAocSAqIG5ld1QpO1xuICAgICAgICBuZXdSID0gbGFzdFIgLSAocSAqIG5ld1IpO1xuICAgIH1cbiAgICBpZiAoIWlzVW5pdChyKSkgdGhyb3cgbmV3IEVycm9yKGEudG9TdHJpbmcoKSArIFwiIGFuZCBcIiArIG4udG9TdHJpbmcoKSArIFwiIGFyZSBub3QgY28tcHJpbWVcIik7XG4gICAgaWYgKGNvbXBhcmUodCwgMG4pID09PSAtMSkge1xuICAgICAgICB0ID0gdCArIG47XG4gICAgfVxuICAgIGlmIChpc05lZ2F0aXZlJDMoYSkpIHtcbiAgICAgICAgcmV0dXJuIC10O1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbW9kUG93JDIobiwgZXhwLCBtb2QpIHtcbiAgICBpZiAobW9kID09PSAwbikgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRha2UgbW9kUG93IHdpdGggbW9kdWx1cyAwXCIpO1xuICAgIHZhciByID0gMW4sXG4gICAgICAgIGJhc2UgPSBuICUgbW9kO1xuICAgIGlmIChpc05lZ2F0aXZlJDMoZXhwKSkge1xuICAgICAgICBleHAgPSBleHAgKiAtMW47XG4gICAgICAgIGJhc2UgPSBtb2RJbnYkMyhiYXNlLCBtb2QpO1xuICAgIH1cbiAgICB3aGlsZSAoaXNQb3NpdGl2ZShleHApKSB7XG4gICAgICAgIGlmIChiYXNlID09PSAwbikgcmV0dXJuIDBuO1xuICAgICAgICBpZiAoaXNPZGQkNChleHApKSByID0gciAqIGJhc2UgJSBtb2Q7XG4gICAgICAgIGV4cCA9IGV4cCAvIDJuO1xuICAgICAgICBiYXNlID0gc3F1YXJlJDEoYmFzZSkgJSBtb2Q7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlQWJzKGEsIGIpIHtcbiAgICBhID0gYSA+PSAwbiA/IGEgOiAtYTtcbiAgICBiID0gYiA+PSAwbiA/IGIgOiAtYjtcbiAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbn1cblxuZnVuY3Rpb24gaXNEaXZpc2libGVCeShhLCBuKSB7XG4gICAgaWYgKG4gPT09IDBuKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGlzVW5pdChuKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvbXBhcmVBYnMobiwgMm4pID09PSAwKSByZXR1cm4gaXNFdmVuKGEpO1xuICAgIHJldHVybiBhICUgbiA9PT0gMG47XG59XG5cbmZ1bmN0aW9uIGlzQmFzaWNQcmltZSh2KSB7XG4gICAgdmFyIG4gPSBhYnModik7XG4gICAgaWYgKGlzVW5pdChuKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChuID09PSAybiB8fCBuID09PSAzbiB8fCBuID09PSA1bikgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzRXZlbihuKSB8fCBpc0RpdmlzaWJsZUJ5KG4sIDNuKSB8fCBpc0RpdmlzaWJsZUJ5KG4sIDVuKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChuIDwgNDluKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgcHJpbWU6IGxldCB0aGUgb3RoZXIgZnVuY3Rpb25zIGZpZ3VyZSBpdCBvdXRcbn1cblxuZnVuY3Rpb24gcHJldihuKSB7XG4gICAgcmV0dXJuIG4gLSAxbjtcbn1cblxuZnVuY3Rpb24gbWlsbGVyUmFiaW5UZXN0KG4sIGEpIHtcbiAgICB2YXIgblByZXYgPSBwcmV2KG4pLFxuICAgICAgICBiID0gblByZXYsXG4gICAgICAgIHIgPSAwLFxuICAgICAgICBkLCBpLCB4O1xuICAgIHdoaWxlIChpc0V2ZW4oYikpIGIgPSBiIC8gMm4sIHIrKztcbiAgICBuZXh0OiBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobiA8IGFbaV0pIGNvbnRpbnVlO1xuICAgICAgICB4ID0gbW9kUG93JDIoQmlnSW50KGFbaV0pLCBiLCBuKTtcbiAgICAgICAgaWYgKGlzVW5pdCh4KSB8fCB4ID09PSBuUHJldikgY29udGludWU7XG4gICAgICAgIGZvciAoZCA9IHIgLSAxOyBkICE9IDA7IGQtLSkge1xuICAgICAgICAgICAgeCA9IHNxdWFyZSQxKHgpICUgbjtcbiAgICAgICAgICAgIGlmIChpc1VuaXQoeCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh4ID09PSBuUHJldikgY29udGludWUgbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1ByaW1lJDEocCkge1xuICAgIHZhciBpc1ByaW1lID0gaXNCYXNpY1ByaW1lKHApO1xuICAgIGlmIChpc1ByaW1lICE9PSB1bmRlZmluZWQpIHJldHVybiBpc1ByaW1lO1xuICAgIHZhciBuID0gYWJzKHApO1xuICAgIHZhciBiaXRzID0gYml0TGVuZ3RoJDUobik7XG4gICAgaWYgKGJpdHMgPD0gNjQpXG4gICAgICAgIHJldHVybiBtaWxsZXJSYWJpblRlc3QobiwgWzIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjksIDMxLCAzN10pO1xuICAgIHZhciBsb2dOID0gTWF0aC5sb2coMikgKiBOdW1iZXIoYml0cyk7XG4gICAgdmFyIHQgPSBNYXRoLmNlaWwobG9nTik7XG4gICAgZm9yICh2YXIgYSA9IFtdLCBpID0gMDsgaSA8IHQ7IGkrKykge1xuICAgICAgICBhLnB1c2goQmlnSW50KGkgKyAyKSk7XG4gICAgfVxuICAgIHJldHVybiBtaWxsZXJSYWJpblRlc3QobiwgYSk7XG59XG5cbmJpZ2ludC5iaXRMZW5ndGggPSBiaXRMZW5ndGgkNTtcbmJpZ2ludC5pc09kZCA9IGlzT2RkJDQ7XG5iaWdpbnQuaXNOZWdhdGl2ZSA9IGlzTmVnYXRpdmUkMztcbmJpZ2ludC5hYnMgPSBhYnM7XG5iaWdpbnQuaXNVbml0ID0gaXNVbml0O1xuYmlnaW50LmNvbXBhcmUgPSBjb21wYXJlO1xuYmlnaW50Lm1vZEludiA9IG1vZEludiQzO1xuYmlnaW50Lm1vZFBvdyA9IG1vZFBvdyQyO1xuYmlnaW50LmlzUHJpbWUgPSBpc1ByaW1lJDE7XG5iaWdpbnQuc3F1YXJlID0gc3F1YXJlJDE7XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTkgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3YXNtc25hcmsgKFdlYiBBc3NlbWJseSB6a1NuYXJrIFByb3ZlcikuXG5cbiAgICB3YXNtc25hcmsgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3YXNtc25hcmsgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2FzbXNuYXJrLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuY29uc3QgYnVpbGRJbnQgPSBidWlsZF9pbnQ7XG5jb25zdCB1dGlscyQ1ID0gdXRpbHMkNjtcbmNvbnN0IGJ1aWxkRXhwJDIgPSBidWlsZF90aW1lc3NjYWxhcjtcbmNvbnN0IGJ1aWxkQmF0Y2hJbnZlcnNlJDIgPSBidWlsZF9iYXRjaGludmVyc2U7XG5jb25zdCBidWlsZEJhdGNoQ29udmVydGlvbiQxID0gYnVpbGRfYmF0Y2hjb252ZXJ0aW9uO1xuY29uc3QgYnVpbGRCYXRjaE9wID0gYnVpbGRfYmF0Y2hvcDtcbmNvbnN0IHsgYml0TGVuZ3RoOiBiaXRMZW5ndGgkNCwgbW9kSW52OiBtb2RJbnYkMiwgbW9kUG93OiBtb2RQb3ckMSwgaXNQcmltZSwgaXNPZGQ6IGlzT2RkJDMsIHNxdWFyZSB9ID0gYmlnaW50O1xuXG52YXIgYnVpbGRfZjFtID0gZnVuY3Rpb24gYnVpbGRGMW0obW9kdWxlLCBfcSwgX3ByZWZpeCwgX2ludFByZWZpeCkge1xuICAgIGNvbnN0IHEgPSBCaWdJbnQoX3EpO1xuICAgIGNvbnN0IG42NCA9IE1hdGguZmxvb3IoKGJpdExlbmd0aCQ0KHEgLSAxbikgLSAxKS82NCkgKzE7XG4gICAgY29uc3QgbjMyID0gbjY0KjI7XG4gICAgY29uc3QgbjggPSBuNjQqODtcblxuICAgIGNvbnN0IHByZWZpeCA9IF9wcmVmaXggfHwgXCJmMW1cIjtcbiAgICBpZiAobW9kdWxlLm1vZHVsZXNbcHJlZml4XSkgcmV0dXJuIHByZWZpeDsgIC8vIGFscmVhZHkgYnVpbGRlZFxuXG4gICAgY29uc3QgaW50UHJlZml4ID0gYnVpbGRJbnQobW9kdWxlLCBuNjQsIF9pbnRQcmVmaXgpO1xuICAgIGNvbnN0IHBxID0gbW9kdWxlLmFsbG9jKG44LCB1dGlscyQ1LmJpZ0ludDJCeXRlc0xFKHEsIG44KSk7XG5cbiAgICBjb25zdCBwUjIgPSBtb2R1bGUuYWxsb2ModXRpbHMkNS5iaWdJbnQyQnl0ZXNMRShzcXVhcmUoMW4gPDwgQmlnSW50KG42NCo2NCkpICUgcSwgbjgpKTtcbiAgICBjb25zdCBwT25lID0gbW9kdWxlLmFsbG9jKHV0aWxzJDUuYmlnSW50MkJ5dGVzTEUoKDFuIDw8IEJpZ0ludChuNjQqNjQpKSAlIHEsIG44KSk7XG4gICAgY29uc3QgcFplcm8gPSBtb2R1bGUuYWxsb2ModXRpbHMkNS5iaWdJbnQyQnl0ZXNMRSgwbiwgbjgpKTtcbiAgICBjb25zdCBfbWludXNPbmUgPSBxIC0gMW47XG4gICAgY29uc3QgX2UgPSBfbWludXNPbmUgPj4gMW47IC8vIGUgPSAocC0xKS8yXG4gICAgY29uc3QgcGUgPSBtb2R1bGUuYWxsb2MobjgsIHV0aWxzJDUuYmlnSW50MkJ5dGVzTEUoX2UsIG44KSk7XG5cbiAgICBjb25zdCBfZVBsdXNPbmUgPSBfZSArIDFuOyAvLyBlID0gKHAtMSkvMlxuICAgIGNvbnN0IHBlUGx1c09uZSA9IG1vZHVsZS5hbGxvYyhuOCwgdXRpbHMkNS5iaWdJbnQyQnl0ZXNMRShfZVBsdXNPbmUsIG44KSk7XG5cbiAgICBtb2R1bGUubW9kdWxlc1twcmVmaXhdID0ge1xuICAgICAgICBwcTogcHEsXG4gICAgICAgIHBSMjogcFIyLFxuICAgICAgICBuNjQ6IG42NCxcbiAgICAgICAgcTogcSxcbiAgICAgICAgcE9uZTogcE9uZSxcbiAgICAgICAgcFplcm86IHBaZXJvLFxuICAgICAgICBwZVBsdXNPbmU6IHBlUGx1c09uZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBidWlsZE9uZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfb25lXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKGludFByZWZpeCArIFwiX2NvcHlcIiwgYy5pMzJfY29uc3QocE9uZSksIGMuZ2V0TG9jYWwoXCJwclwiKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkQWRkKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9hZGRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuY2FsbChpbnRQcmVmaXgrXCJfYWRkXCIsIGMuZ2V0TG9jYWwoXCJ4XCIpLCAgYy5nZXRMb2NhbChcInlcIiksIGMuZ2V0TG9jYWwoXCJyXCIpKSxcbiAgICAgICAgICAgICAgICBjLmRyb3AoYy5jYWxsKGludFByZWZpeCtcIl9zdWJcIiwgYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KHBxKSwgYy5nZXRMb2NhbChcInJcIikpKSxcbiAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwoaW50UHJlZml4K1wiX2d0ZVwiLCBjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QocHEpICApLFxuICAgICAgICAgICAgICAgICAgICBjLmRyb3AoYy5jYWxsKGludFByZWZpeCtcIl9zdWJcIiwgYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KHBxKSwgYy5nZXRMb2NhbChcInJcIikpKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRTdWIoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX3N1YlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ5XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKGludFByZWZpeCtcIl9zdWJcIiwgYy5nZXRMb2NhbChcInhcIiksICBjLmdldExvY2FsKFwieVwiKSwgYy5nZXRMb2NhbChcInJcIikpLFxuICAgICAgICAgICAgICAgIGMuZHJvcChjLmNhbGwoaW50UHJlZml4K1wiX2FkZFwiLCBjLmdldExvY2FsKFwiclwiKSwgIGMuaTMyX2NvbnN0KHBxKSwgYy5nZXRMb2NhbChcInJcIikpKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTmVnKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9uZWdcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9zdWJcIiwgYy5pMzJfY29uc3QocFplcm8pLCBjLmdldExvY2FsKFwieFwiKSwgYy5nZXRMb2NhbChcInJcIikpXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZElzTmVnYXRpdmUoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2lzTmVnYXRpdmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBBVVggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfZnJvbU1vbnRnb21lcnlcIiwgYy5nZXRMb2NhbChcInhcIiksIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoaW50UHJlZml4ICsgXCJfZ3RlXCIsIEFVWCwgYy5pMzJfY29uc3QocGVQbHVzT25lKSApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRTaWduKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9zaWduXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5zZXRSZXR1cm5UeXBlKFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgQVVYID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pZiAoXG4gICAgICAgICAgICAgICAgYy5jYWxsKGludFByZWZpeCArIFwiX2lzWmVyb1wiLCBjLmdldExvY2FsKFwieFwiKSksXG4gICAgICAgICAgICAgICAgYy5yZXQoYy5pMzJfY29uc3QoMCkpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2Zyb21Nb250Z29tZXJ5XCIsIGMuZ2V0TG9jYWwoXCJ4XCIpLCBBVVgpLFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwoaW50UHJlZml4ICsgXCJfZ3RlXCIsIEFVWCwgYy5pMzJfY29uc3QocGVQbHVzT25lKSksXG4gICAgICAgICAgICAgICAgYy5yZXQoYy5pMzJfY29uc3QoLTEpKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMucmV0KGMuaTMyX2NvbnN0KDEpKVxuICAgICAgICApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRNUmVkdWN0KCkge1xuICAgICAgICBjb25zdCBjYXJyaWVzID0gbW9kdWxlLmFsbG9jKG4zMipuMzIqOCk7XG5cbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfbVJlZHVjdFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInRcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwibnAzMlwiLCBcImk2NFwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImNcIiwgXCJpNjRcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJtXCIsIFwiaTY0XCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgbnAzMiA9IE51bWJlcigweDEwMDAwMDAwMG4gLSBtb2RJbnYkMihxLCAweDEwMDAwMDAwMG4pKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5zZXRMb2NhbChcIm5wMzJcIiwgYy5pNjRfY29uc3QobnAzMikpKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bjMyOyBpKyspIHtcbiAgICAgICAgICAgIGYuYWRkQ29kZShjLnNldExvY2FsKFwiY1wiLCBjLmk2NF9jb25zdCgwKSkpO1xuXG4gICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICAgICAgXCJtXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X211bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9sb2FkMzJfdShjLmdldExvY2FsKFwidFwiKSwgaSo0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwibnAzMlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KFwiMHhGRkZGRkZGRlwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG4zMjsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9sb2FkMzJfdShjLmdldExvY2FsKFwidFwiKSwgKGkraikqNCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X3Nocl91KGMuZ2V0TG9jYWwoXCJjXCIpLCBjLmk2NF9jb25zdCgzMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2xvYWQzMl91KGMuaTMyX2NvbnN0KHBxKSwgaio0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9zdG9yZTMyKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAoaStqKSo0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImNcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICBjLmk2NF9zdG9yZTMyKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChjYXJyaWVzKSxcbiAgICAgICAgICAgICAgICAgICAgaSo0LFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9zaHJfdShjLmdldExvY2FsKFwiY1wiKSwgYy5pNjRfY29uc3QoMzIpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgcHJlZml4K1wiX2FkZFwiLFxuICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KGNhcnJpZXMpLFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInRcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG4zMio0KVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInJcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRNdWwoKSB7XG5cbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfbXVsXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInlcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiYzBcIiwgXCJpNjRcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJjMVwiLCBcImk2NFwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIm5wMzJcIiwgXCJpNjRcIik7XG5cblxuICAgICAgICBmb3IgKGxldCBpPTA7aTxuMzI7IGkrKykge1xuICAgICAgICAgICAgZi5hZGRMb2NhbChcInhcIitpLCBcImk2NFwiKTtcbiAgICAgICAgICAgIGYuYWRkTG9jYWwoXCJ5XCIraSwgXCJpNjRcIik7XG4gICAgICAgICAgICBmLmFkZExvY2FsKFwibVwiK2ksIFwiaTY0XCIpO1xuICAgICAgICAgICAgZi5hZGRMb2NhbChcInFcIitpLCBcImk2NFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgbnAzMiA9IE51bWJlcigweDEwMDAwMDAwMG4gLSBtb2RJbnYkMihxLCAweDEwMDAwMDAwMG4pKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5zZXRMb2NhbChcIm5wMzJcIiwgYy5pNjRfY29uc3QobnAzMikpKTtcblxuXG4gICAgICAgIGNvbnN0IGxvYWRYID0gW107XG4gICAgICAgIGNvbnN0IGxvYWRZID0gW107XG4gICAgICAgIGNvbnN0IGxvYWRRID0gW107XG4gICAgICAgIGZ1bmN0aW9uIG11bGlqKGksIGopIHtcbiAgICAgICAgICAgIGxldCBYLFk7XG4gICAgICAgICAgICBpZiAoIWxvYWRYW2ldKSB7XG4gICAgICAgICAgICAgICAgWCA9IGMudGVlTG9jYWwoXCJ4XCIraSwgYy5pNjRfbG9hZDMyX3UoIGMuZ2V0TG9jYWwoXCJ4XCIpLCBpKjQpKTtcbiAgICAgICAgICAgICAgICBsb2FkWFtpXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFggPSBjLmdldExvY2FsKFwieFwiK2kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsb2FkWVtqXSkge1xuICAgICAgICAgICAgICAgIFkgPSBjLnRlZUxvY2FsKFwieVwiK2osIGMuaTY0X2xvYWQzMl91KCBjLmdldExvY2FsKFwieVwiKSwgaio0KSk7XG4gICAgICAgICAgICAgICAgbG9hZFlbal0gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBZID0gYy5nZXRMb2NhbChcInlcIitqKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGMuaTY0X211bCggWCwgWSApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbXVscW0oaSwgaikge1xuICAgICAgICAgICAgbGV0IFEsTTtcbiAgICAgICAgICAgIGlmICghbG9hZFFbaV0pIHtcbiAgICAgICAgICAgICAgICBRID0gYy50ZWVMb2NhbChcInFcIitpLCBjLmk2NF9sb2FkMzJfdShjLmkzMl9jb25zdCgwKSwgcHEraSo0ICkpO1xuICAgICAgICAgICAgICAgIGxvYWRRW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgUSA9IGMuZ2V0TG9jYWwoXCJxXCIraSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBNID0gYy5nZXRMb2NhbChcIm1cIitqKTtcblxuICAgICAgICAgICAgcmV0dXJuIGMuaTY0X211bCggUSwgTSApO1xuICAgICAgICB9XG5cblxuICAgICAgICBsZXQgYzAgPSBcImMwXCI7XG4gICAgICAgIGxldCBjMSA9IFwiYzFcIjtcblxuICAgICAgICBmb3IgKGxldCBrPTA7IGs8bjMyKjItMTsgaysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpPU1hdGgubWF4KDAsIGstbjMyKzEpOyAoaTw9aykmJihpPG4zMik7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGo9IGstaTtcblxuICAgICAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChjMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgweEZGRkZGRkZGKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsaWooaSxqKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChjMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9zaHJfdShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDMyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgZm9yIChsZXQgaT1NYXRoLm1heCgxLCBrLW4zMisxKTsgKGk8PWspJiYoaTxuMzIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqPSBrLWk7XG5cbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMHhGRkZGRkZGRilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHFtKGksailcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgzMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGs8bjMyKSB7XG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtXCIrayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMHhGRkZGRkZGRilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5wMzJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KFwiMHhGRkZGRkZGRlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcblxuXG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKGMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDB4RkZGRkZGRkYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWxxbSgwLGspXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKGMxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X3Nocl91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAoaz49bjMyKSB7XG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9zdG9yZTMyKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAoay1uMzIpKjQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtjMCwgYzFdID0gW2MxLCBjMF07XG4gICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChjMSxcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDMyKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmk2NF9zdG9yZTMyKFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJyXCIpLFxuICAgICAgICAgICAgICAgIG4zMio0LTQsXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuaTMyX3dyYXBfaTY0KGMuZ2V0TG9jYWwoYzEpKSxcbiAgICAgICAgICAgICAgICBjLmRyb3AoYy5jYWxsKGludFByZWZpeCtcIl9zdWJcIiwgYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KHBxKSwgYy5nZXRMb2NhbChcInJcIikpKSxcbiAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwoaW50UHJlZml4K1wiX2d0ZVwiLCBjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QocHEpICApLFxuICAgICAgICAgICAgICAgICAgICBjLmRyb3AoYy5jYWxsKGludFByZWZpeCtcIl9zdWJcIiwgYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KHBxKSwgYy5nZXRMb2NhbChcInJcIikpKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZFNxdWFyZSgpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9zcXVhcmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImMwXCIsIFwiaTY0XCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiYzFcIiwgXCJpNjRcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJjMF9vbGRcIiwgXCJpNjRcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJjMV9vbGRcIiwgXCJpNjRcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJucDMyXCIsIFwiaTY0XCIpO1xuXG5cbiAgICAgICAgZm9yIChsZXQgaT0wO2k8bjMyOyBpKyspIHtcbiAgICAgICAgICAgIGYuYWRkTG9jYWwoXCJ4XCIraSwgXCJpNjRcIik7XG4gICAgICAgICAgICBmLmFkZExvY2FsKFwibVwiK2ksIFwiaTY0XCIpO1xuICAgICAgICAgICAgZi5hZGRMb2NhbChcInFcIitpLCBcImk2NFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgbnAzMiA9IE51bWJlcigweDEwMDAwMDAwMG4gLSBtb2RJbnYkMihxLCAweDEwMDAwMDAwMG4pKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5zZXRMb2NhbChcIm5wMzJcIiwgYy5pNjRfY29uc3QobnAzMikpKTtcblxuXG4gICAgICAgIGNvbnN0IGxvYWRYID0gW107XG4gICAgICAgIGNvbnN0IGxvYWRRID0gW107XG4gICAgICAgIGZ1bmN0aW9uIG11bGlqKGksIGopIHtcbiAgICAgICAgICAgIGxldCBYLFk7XG4gICAgICAgICAgICBpZiAoIWxvYWRYW2ldKSB7XG4gICAgICAgICAgICAgICAgWCA9IGMudGVlTG9jYWwoXCJ4XCIraSwgYy5pNjRfbG9hZDMyX3UoIGMuZ2V0TG9jYWwoXCJ4XCIpLCBpKjQpKTtcbiAgICAgICAgICAgICAgICBsb2FkWFtpXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFggPSBjLmdldExvY2FsKFwieFwiK2kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsb2FkWFtqXSkge1xuICAgICAgICAgICAgICAgIFkgPSBjLnRlZUxvY2FsKFwieFwiK2osIGMuaTY0X2xvYWQzMl91KCBjLmdldExvY2FsKFwieFwiKSwgaio0KSk7XG4gICAgICAgICAgICAgICAgbG9hZFhbal0gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBZID0gYy5nZXRMb2NhbChcInhcIitqKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGMuaTY0X211bCggWCwgWSApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbXVscW0oaSwgaikge1xuICAgICAgICAgICAgbGV0IFEsTTtcbiAgICAgICAgICAgIGlmICghbG9hZFFbaV0pIHtcbiAgICAgICAgICAgICAgICBRID0gYy50ZWVMb2NhbChcInFcIitpLCBjLmk2NF9sb2FkMzJfdShjLmkzMl9jb25zdCgwKSwgcHEraSo0ICkpO1xuICAgICAgICAgICAgICAgIGxvYWRRW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgUSA9IGMuZ2V0TG9jYWwoXCJxXCIraSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBNID0gYy5nZXRMb2NhbChcIm1cIitqKTtcblxuICAgICAgICAgICAgcmV0dXJuIGMuaTY0X211bCggUSwgTSApO1xuICAgICAgICB9XG5cblxuICAgICAgICBsZXQgYzAgPSBcImMwXCI7XG4gICAgICAgIGxldCBjMSA9IFwiYzFcIjtcbiAgICAgICAgbGV0IGMwX29sZCA9IFwiYzBfb2xkXCI7XG4gICAgICAgIGxldCBjMV9vbGQgPSBcImMxX29sZFwiO1xuXG4gICAgICAgIGZvciAobGV0IGs9MDsgazxuMzIqMi0xOyBrKyspIHtcbiAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKGMwLCBjLmk2NF9jb25zdCgwKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChjMSwgYy5pNjRfY29uc3QoMCkpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9TWF0aC5tYXgoMCwgay1uMzIrMSk7IChpPCgoaysxKT4+MSkgKSYmKGk8bjMyKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgaj0gay1pO1xuXG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKGMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDB4RkZGRkZGRkYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWxpaihpLGopXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKGMxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X3Nocl91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgYnkgMlxuICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzAsXG4gICAgICAgICAgICAgICAgICAgIGMuaTY0X3NobChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgweEZGRkZGRkZGKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDEpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChjMSxcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDEpXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMzIpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoayUyID09IDApIHtcbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMHhGRkZGRkZGRilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bGlqKGs+PjEsIGs+PjEpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKGMxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X3Nocl91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvbGQgY2FycnlcblxuICAgICAgICAgICAgaWYgKGs+MCkge1xuICAgICAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChjMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgweEZGRkZGRkZGKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwX29sZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDB4RkZGRkZGRkYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDMyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMxX29sZClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgZm9yIChsZXQgaT1NYXRoLm1heCgxLCBrLW4zMisxKTsgKGk8PWspJiYoaTxuMzIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqPSBrLWk7XG5cbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMHhGRkZGRkZGRilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHFtKGksailcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoYzEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9jb25zdCgzMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGs8bjMyKSB7XG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtXCIrayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmk2NF9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMHhGRkZGRkZGRilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5wMzJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KFwiMHhGRkZGRkZGRlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcblxuXG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKGMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2FuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDB4RkZGRkZGRkYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWxxbSgwLGspXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKGMxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X3Nocl91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pNjRfY29uc3QoMzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGs+PW4zMikge1xuICAgICAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfc3RvcmUzMihcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKGstbjMyKSo0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICAgICAgYzBfb2xkLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKGMxKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICAgICAgYzFfb2xkLFxuICAgICAgICAgICAgICAgICAgICBjLmk2NF9zaHJfdShcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoYzBfb2xkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTY0X2NvbnN0KDMyKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmk2NF9zdG9yZTMyKFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJyXCIpLFxuICAgICAgICAgICAgICAgIG4zMio0LTQsXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChjMF9vbGQpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmkzMl93cmFwX2k2NChjLmdldExvY2FsKGMxX29sZCkpLFxuICAgICAgICAgICAgICAgIGMuZHJvcChjLmNhbGwoaW50UHJlZml4K1wiX3N1YlwiLCBjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QocHEpLCBjLmdldExvY2FsKFwiclwiKSkpLFxuICAgICAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChpbnRQcmVmaXgrXCJfZ3RlXCIsIGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdChwcSkgICksXG4gICAgICAgICAgICAgICAgICAgIGMuZHJvcChjLmNhbGwoaW50UHJlZml4K1wiX3N1YlwiLCBjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QocHEpLCBjLmdldExvY2FsKFwiclwiKSkpLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkU3F1YXJlT2xkKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9zcXVhcmVPbGRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwocHJlZml4ICsgXCJfbXVsXCIsIGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmdldExvY2FsKFwieFwiKSwgYy5nZXRMb2NhbChcInJcIikpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFRvTW9udGdvbWVyeSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfdG9Nb250Z29tZXJ5XCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXgrXCJfbXVsXCIsIGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChwUjIpLCBjLmdldExvY2FsKFwiclwiKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRnJvbU1vbnRnb21lcnkoKSB7XG5cbiAgICAgICAgY29uc3QgcEF1eDIgPSBtb2R1bGUuYWxsb2MobjgqMik7XG5cbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfZnJvbU1vbnRnb21lcnlcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKGludFByZWZpeCArIFwiX2NvcHlcIiwgYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KHBBdXgyKSApKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChpbnRQcmVmaXggKyBcIl96ZXJvXCIsIGMuaTMyX2NvbnN0KHBBdXgyICsgbjgpICkpO1xuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKHByZWZpeCtcIl9tUmVkdWN0XCIsIGMuaTMyX2NvbnN0KHBBdXgyKSwgYy5nZXRMb2NhbChcInJcIikpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEludmVyc2UoKSB7XG5cbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX2ludmVyc2VcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKHByZWZpeCArIFwiX2Zyb21Nb250Z29tZXJ5XCIsIGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmdldExvY2FsKFwiclwiKSkpO1xuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKGludFByZWZpeCArIFwiX2ludmVyc2VNb2RcIiwgYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KHBxKSwgYy5nZXRMb2NhbChcInJcIikpKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl90b01vbnRnb21lcnlcIiwgYy5nZXRMb2NhbChcInJcIiksIGMuZ2V0TG9jYWwoXCJyXCIpKSk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHZhcmlvdXMgdmFsdXNlIG5lZWRlZCBmb3Igc3FydFxuXG5cbiAgICBsZXQgX25xciA9IDJuO1xuICAgIGlmIChpc1ByaW1lKHEpKSB7XG4gICAgICAgIHdoaWxlIChtb2RQb3ckMShfbnFyLCBfZSwgcSkgIT09IF9taW51c09uZSkgX25xciA9IF9ucXIgKyAxbjtcbiAgICB9XG5cbiAgICBsZXQgczIgPSAwO1xuICAgIGxldCBfdCA9IF9taW51c09uZTtcblxuICAgIHdoaWxlICgoIWlzT2RkJDMoX3QpKSYmKF90ICE9PSAwbikpIHtcbiAgICAgICAgczIrKztcbiAgICAgICAgX3QgPSBfdCA+PiAxbjtcbiAgICB9XG4gICAgY29uc3QgcHQgPSBtb2R1bGUuYWxsb2MobjgsIHV0aWxzJDUuYmlnSW50MkJ5dGVzTEUoX3QsIG44KSk7XG5cbiAgICBjb25zdCBfbnFyVG9UID0gbW9kUG93JDEoX25xciwgX3QsIHEpO1xuICAgIGNvbnN0IHBOcXJUb1QgPSBtb2R1bGUuYWxsb2ModXRpbHMkNS5iaWdJbnQyQnl0ZXNMRSgoX25xclRvVCA8PCBCaWdJbnQobjY0KjY0KSkgJSBxLCBuOCkpO1xuXG4gICAgY29uc3QgX3RQbHVzT25lT3ZlcjIgPSAoX3QgKyAxbikgPj4gMW47XG4gICAgY29uc3QgcHRQbHVzT25lT3ZlcjIgPSBtb2R1bGUuYWxsb2MobjgsIHV0aWxzJDUuYmlnSW50MkJ5dGVzTEUoX3RQbHVzT25lT3ZlcjIsIG44KSk7XG5cbiAgICBmdW5jdGlvbiBidWlsZFNxcnQoKSB7XG5cbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX3NxcnRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJuXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIm1cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwialwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IE9ORSA9IGMuaTMyX2NvbnN0KHBPbmUpO1xuICAgICAgICBjb25zdCBDID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgUiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBTUSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBCID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuXG4gICAgICAgICAgICAvLyBJZiAobj09MCkgcmV0dXJuIDBcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2lzWmVyb1wiLCBjLmdldExvY2FsKFwiblwiKSksXG4gICAgICAgICAgICAgICAgYy5yZXQoXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl96ZXJvXCIsIGMuZ2V0TG9jYWwoXCJyXCIpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJtXCIsIGMuaTMyX2NvbnN0KHMyKSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfY29weVwiLCBjLmkzMl9jb25zdChwTnFyVG9UKSwgQyksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfZXhwXCIsIGMuZ2V0TG9jYWwoXCJuXCIpLCBjLmkzMl9jb25zdChwdCksIGMuaTMyX2NvbnN0KG44KSwgVCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfZXhwXCIsIGMuZ2V0TG9jYWwoXCJuXCIpLCBjLmkzMl9jb25zdChwdFBsdXNPbmVPdmVyMiksIGMuaTMyX2NvbnN0KG44KSwgUiksXG5cbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoMSwgYy5jYWxsKHByZWZpeCArIFwiX2VxXCIsIFQsIE9ORSkpLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX3NxdWFyZVwiLCBULCBTUSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfY29uc3QoMSkpLFxuICAgICAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgICAgICBjLmJyX2lmKDEsIGMuY2FsbChwcmVmaXggKyBcIl9lcVwiLCBTUSwgT05FKSksXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9zcXVhcmVcIiwgU1EsIFNRKSxcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICAgICAgKSksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfY29weVwiLCBDLCBCKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwialwiLCBjLmkzMl9zdWIoYy5pMzJfc3ViKCBjLmdldExvY2FsKFwibVwiKSwgYy5nZXRMb2NhbChcImlcIikpLCBjLmkzMl9jb25zdCgxKSkgKSxcbiAgICAgICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICAgICAgYy5icl9pZigxLCBjLmkzMl9lcXooYy5nZXRMb2NhbChcImpcIikpKSxcbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX3NxdWFyZVwiLCBCLCBCKSxcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImpcIiwgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJqXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICAgICAgKSksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwibVwiLCBjLmdldExvY2FsKFwiaVwiKSksXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX3NxdWFyZVwiLCBCLCBDKSxcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfbXVsXCIsIFQsIEMsIFQpLFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9tdWxcIiwgUiwgQiwgUiksXG5cbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKSxcblxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfaXNOZWdhdGl2ZVwiLCBSKSxcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfbmVnXCIsIFIsIGMuZ2V0TG9jYWwoXCJyXCIpKSxcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfY29weVwiLCBSLCBjLmdldExvY2FsKFwiclwiKSksXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRJc1NxdWFyZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfaXNTcXVhcmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJuXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBPTkUgPSBjLmkzMl9jb25zdChwT25lKTtcbiAgICAgICAgY29uc3QgQVVYID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfaXNaZXJvXCIsIGMuZ2V0TG9jYWwoXCJuXCIpKSxcbiAgICAgICAgICAgICAgICBjLnJldChjLmkzMl9jb25zdCgxKSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfZXhwXCIsIGMuZ2V0TG9jYWwoXCJuXCIpLCBjLmkzMl9jb25zdChwZSksIGMuaTMyX2NvbnN0KG44KSwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9lcVwiLCBBVVgsIE9ORSlcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTG9hZCgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfbG9hZFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInNjYWxhclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInNjYWxhckxlblwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJwXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwibFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImlcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJqXCIsIFwiaTMyXCIpO1xuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IFIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgcEF1eCA9IG1vZHVsZS5hbGxvYyhuOCk7XG4gICAgICAgIGNvbnN0IEFVWCA9IGMuaTMyX2NvbnN0KHBBdXgpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChpbnRQcmVmaXggKyBcIl96ZXJvXCIsIGMuZ2V0TG9jYWwoXCJyXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2NvbnN0KG44KSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwicFwiLCBjLmdldExvY2FsKFwic2NhbGFyXCIpKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoMSwgYy5pMzJfZ3RfdShjLmdldExvY2FsKFwiaVwiKSwgYy5nZXRMb2NhbChcInNjYWxhckxlblwiKSkpLFxuXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfZXEoYy5nZXRMb2NhbChcImlcIiksIGMuaTMyX2NvbnN0KG44KSksXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9vbmVcIiwgUiksXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9tdWxcIiwgUiwgYy5pMzJfY29uc3QocFIyKSwgUilcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9tdWxcIiwgYy5nZXRMb2NhbChcInBcIiksIFIsIEFVWCksXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2FkZFwiLCBjLmdldExvY2FsKFwiclwiKSwgQVVYLCBjLmdldExvY2FsKFwiclwiKSksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwicFwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBcIiksIGMuaTMyX2NvbnN0KG44KSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QobjgpKSksXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSksXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJsXCIsIGMuaTMyX3JlbV91KCBjLmdldExvY2FsKFwic2NhbGFyTGVuXCIpLCBjLmkzMl9jb25zdChuOCkpKSxcbiAgICAgICAgICAgIGMuaWYoYy5pMzJfZXF6KGMuZ2V0TG9jYWwoXCJsXCIpKSwgYy5yZXQoW10pKSxcbiAgICAgICAgICAgIGMuY2FsbChpbnRQcmVmaXggKyBcIl96ZXJvXCIsIEFVWCksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwialwiLCBjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICBjLmJyX2lmKDEsIGMuaTMyX2VxKGMuZ2V0TG9jYWwoXCJqXCIpLCBjLmdldExvY2FsKFwibFwiKSkpLFxuXG4gICAgICAgICAgICAgICAgYy5pMzJfc3RvcmU4KFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwialwiKSxcbiAgICAgICAgICAgICAgICAgICAgcEF1eCxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbG9hZDhfdShjLmdldExvY2FsKFwicFwiKSksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwicFwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImpcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJqXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpLFxuXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuaTMyX2VxKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdChuOCkpLFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9vbmVcIiwgUiksXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX211bFwiLCBSLCBjLmkzMl9jb25zdChwUjIpLCBSKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9tdWxcIiwgQVVYLCBSLCBBVVgpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2FkZFwiLCBjLmdldExvY2FsKFwiclwiKSwgQVVYLCBjLmdldExvY2FsKFwiclwiKSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRUaW1lc1NjYWxhcigpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfdGltZXNTY2FsYXJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwic2NhbGFyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwic2NhbGFyTGVuXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IEFVWCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9sb2FkXCIsIGMuZ2V0TG9jYWwoXCJzY2FsYXJcIiksIGMuZ2V0TG9jYWwoXCJzY2FsYXJMZW5cIiksIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfdG9Nb250Z29tZXJ5XCIsIEFVWCwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9tdWxcIiwgYy5nZXRMb2NhbChcInhcIiksIEFVWCwgYy5nZXRMb2NhbChcInJcIikpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkSXNPbmUoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2lzT25lXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5zZXRSZXR1cm5UeXBlKFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMucmV0KGMuY2FsbChpbnRQcmVmaXggKyBcIl9lcVwiLCBjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QocE9uZSkpKVxuICAgICAgICApO1xuICAgIH1cblxuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKGludFByZWZpeCArIFwiX2NvcHlcIiwgcHJlZml4K1wiX2NvcHlcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKGludFByZWZpeCArIFwiX3plcm9cIiwgcHJlZml4K1wiX3plcm9cIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKGludFByZWZpeCArIFwiX2lzWmVyb1wiLCBwcmVmaXgrXCJfaXNaZXJvXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihpbnRQcmVmaXggKyBcIl9lcVwiLCBwcmVmaXgrXCJfZXFcIik7XG5cbiAgICBidWlsZElzT25lKCk7XG4gICAgYnVpbGRBZGQoKTtcbiAgICBidWlsZFN1YigpO1xuICAgIGJ1aWxkTmVnKCk7XG4gICAgYnVpbGRNUmVkdWN0KCk7XG4gICAgYnVpbGRNdWwoKTtcbiAgICBidWlsZFNxdWFyZSgpO1xuICAgIGJ1aWxkU3F1YXJlT2xkKCk7XG4gICAgYnVpbGRUb01vbnRnb21lcnkoKTtcbiAgICBidWlsZEZyb21Nb250Z29tZXJ5KCk7XG4gICAgYnVpbGRJc05lZ2F0aXZlKCk7XG4gICAgYnVpbGRTaWduKCk7XG4gICAgYnVpbGRJbnZlcnNlKCk7XG4gICAgYnVpbGRPbmUoKTtcbiAgICBidWlsZExvYWQoKTtcbiAgICBidWlsZFRpbWVzU2NhbGFyKCk7XG4gICAgYnVpbGRCYXRjaEludmVyc2UkMihtb2R1bGUsIHByZWZpeCk7XG4gICAgYnVpbGRCYXRjaENvbnZlcnRpb24kMShtb2R1bGUsIHByZWZpeCArIFwiX2JhdGNoVG9Nb250Z29tZXJ5XCIsIHByZWZpeCArIFwiX3RvTW9udGdvbWVyeVwiLCBuOCwgbjgpO1xuICAgIGJ1aWxkQmF0Y2hDb252ZXJ0aW9uJDEobW9kdWxlLCBwcmVmaXggKyBcIl9iYXRjaEZyb21Nb250Z29tZXJ5XCIsIHByZWZpeCArIFwiX2Zyb21Nb250Z29tZXJ5XCIsIG44LCBuOCk7XG4gICAgYnVpbGRCYXRjaENvbnZlcnRpb24kMShtb2R1bGUsIHByZWZpeCArIFwiX2JhdGNoTmVnXCIsIHByZWZpeCArIFwiX25lZ1wiLCBuOCwgbjgpO1xuICAgIGJ1aWxkQmF0Y2hPcChtb2R1bGUsIHByZWZpeCArIFwiX2JhdGNoQWRkXCIsIHByZWZpeCArIFwiX2FkZFwiLCBuOCwgbjgpO1xuICAgIGJ1aWxkQmF0Y2hPcChtb2R1bGUsIHByZWZpeCArIFwiX2JhdGNoU3ViXCIsIHByZWZpeCArIFwiX3N1YlwiLCBuOCwgbjgpO1xuICAgIGJ1aWxkQmF0Y2hPcChtb2R1bGUsIHByZWZpeCArIFwiX2JhdGNoTXVsXCIsIHByZWZpeCArIFwiX211bFwiLCBuOCwgbjgpO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2FkZFwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfc3ViXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9uZWdcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2lzTmVnYXRpdmVcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2lzT25lXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9zaWduXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9tUmVkdWN0XCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9tdWxcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3NxdWFyZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfc3F1YXJlT2xkXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9mcm9tTW9udGdvbWVyeVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfdG9Nb250Z29tZXJ5XCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9pbnZlcnNlXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9vbmVcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2xvYWRcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3RpbWVzU2NhbGFyXCIpO1xuICAgIGJ1aWxkRXhwJDIoXG4gICAgICAgIG1vZHVsZSxcbiAgICAgICAgcHJlZml4ICsgXCJfZXhwXCIsXG4gICAgICAgIG44LFxuICAgICAgICBwcmVmaXggKyBcIl9tdWxcIixcbiAgICAgICAgcHJlZml4ICsgXCJfc3F1YXJlXCIsXG4gICAgICAgIGludFByZWZpeCArIFwiX2NvcHlcIixcbiAgICAgICAgcHJlZml4ICsgXCJfb25lXCIsXG4gICAgKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfZXhwXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9iYXRjaEludmVyc2VcIik7XG4gICAgaWYgKGlzUHJpbWUocSkpIHtcbiAgICAgICAgYnVpbGRTcXJ0KCk7XG4gICAgICAgIGJ1aWxkSXNTcXVhcmUoKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3NxcnRcIik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9pc1NxdWFyZVwiKTtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2JhdGNoVG9Nb250Z29tZXJ5XCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9iYXRjaEZyb21Nb250Z29tZXJ5XCIpO1xuICAgIC8vIGNvbnNvbGUubG9nKG1vZHVsZS5mdW5jdGlvbklkeEJ5TmFtZSk7XG5cbiAgICByZXR1cm4gcHJlZml4O1xufTtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21zbmFyayAoV2ViIEFzc2VtYmx5IHprU25hcmsgUHJvdmVyKS5cblxuICAgIHdhc21zbmFyayBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21zbmFyayBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtc25hcmsuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCBidWlsZEYxbSQyID1idWlsZF9mMW07XG5jb25zdCB7IGJpdExlbmd0aDogYml0TGVuZ3RoJDMgfSA9IGJpZ2ludDtcblxudmFyIGJ1aWxkX2YxID0gZnVuY3Rpb24gYnVpbGRGMShtb2R1bGUsIF9xLCBfcHJlZml4LCBfZjFtUHJlZml4LCBfaW50UHJlZml4KSB7XG5cbiAgICBjb25zdCBxID0gQmlnSW50KF9xKTtcbiAgICBjb25zdCBuNjQgPSBNYXRoLmZsb29yKChiaXRMZW5ndGgkMyhxIC0gMW4pIC0gMSkvNjQpICsxO1xuICAgIGNvbnN0IG44ID0gbjY0Kjg7XG5cbiAgICBjb25zdCBwcmVmaXggPSBfcHJlZml4IHx8IFwiZjFcIjtcbiAgICBpZiAobW9kdWxlLm1vZHVsZXNbcHJlZml4XSkgcmV0dXJuIHByZWZpeDsgIC8vIGFscmVhZHkgYnVpbGRlZFxuICAgIG1vZHVsZS5tb2R1bGVzW3ByZWZpeF0gPSB7XG4gICAgICAgIG42NDogbjY0XG4gICAgfTtcblxuICAgIGNvbnN0IGludFByZWZpeCA9IF9pbnRQcmVmaXggfHwgXCJpbnRcIjtcbiAgICBjb25zdCBmMW1QcmVmaXggPSBidWlsZEYxbSQyKG1vZHVsZSwgcSwgX2YxbVByZWZpeCwgaW50UHJlZml4KTtcblxuXG4gICAgY29uc3QgcFIyID0gICAgIG1vZHVsZS5tb2R1bGVzW2YxbVByZWZpeF0ucFIyO1xuICAgIGNvbnN0IHBxID0gICAgIG1vZHVsZS5tb2R1bGVzW2YxbVByZWZpeF0ucHE7XG4gICAgY29uc3QgcGVQbHVzT25lID0gbW9kdWxlLm1vZHVsZXNbZjFtUHJlZml4XS5wZVBsdXNPbmU7XG5cbiAgICBmdW5jdGlvbiBidWlsZE11bCgpIHtcbiAgICAgICAgY29uc3QgcEF1eDEgPSBtb2R1bGUuYWxsb2MobjgpO1xuXG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4KyBcIl9tdWxcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChmMW1QcmVmaXggKyBcIl9tdWxcIiwgYy5nZXRMb2NhbChcInhcIiksIGMuZ2V0TG9jYWwoXCJ5XCIpLCBjLmkzMl9jb25zdChwQXV4MSkpKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChmMW1QcmVmaXggKyBcIl9tdWxcIiwgYy5pMzJfY29uc3QocEF1eDEpLCBjLmkzMl9jb25zdChwUjIpLCBjLmdldExvY2FsKFwiclwiKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkU3F1YXJlKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9zcXVhcmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwocHJlZml4ICsgXCJfbXVsXCIsIGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmdldExvY2FsKFwieFwiKSwgYy5nZXRMb2NhbChcInJcIikpKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkSW52ZXJzZSgpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfaW52ZXJzZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwoaW50UHJlZml4ICsgXCJfaW52ZXJzZU1vZFwiLCBjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QocHEpLCBjLmdldExvY2FsKFwiclwiKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkSXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfaXNOZWdhdGl2ZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChpbnRQcmVmaXggKyBcIl9ndGVcIiwgYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KHBlUGx1c09uZSkgKVxuICAgICAgICApO1xuICAgIH1cblxuXG4gICAgYnVpbGRNdWwoKTtcbiAgICBidWlsZFNxdWFyZSgpO1xuICAgIGJ1aWxkSW52ZXJzZSgpO1xuICAgIGJ1aWxkSXNOZWdhdGl2ZSgpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihmMW1QcmVmaXggKyBcIl9hZGRcIiwgcHJlZml4ICsgXCJfYWRkXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihmMW1QcmVmaXggKyBcIl9zdWJcIiwgcHJlZml4ICsgXCJfc3ViXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihmMW1QcmVmaXggKyBcIl9uZWdcIiwgcHJlZml4ICsgXCJfbmVnXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9tdWxcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3NxdWFyZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfaW52ZXJzZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfaXNOZWdhdGl2ZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24oZjFtUHJlZml4ICsgXCJfY29weVwiLCBwcmVmaXgrXCJfY29weVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24oZjFtUHJlZml4ICsgXCJfemVyb1wiLCBwcmVmaXgrXCJfemVyb1wiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24oZjFtUHJlZml4ICsgXCJfb25lXCIsIHByZWZpeCtcIl9vbmVcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKGYxbVByZWZpeCArIFwiX2lzWmVyb1wiLCBwcmVmaXgrXCJfaXNaZXJvXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihmMW1QcmVmaXggKyBcIl9lcVwiLCBwcmVmaXgrXCJfZXFcIik7XG5cbiAgICByZXR1cm4gcHJlZml4O1xufTtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21zbmFyayAoV2ViIEFzc2VtYmx5IHprU25hcmsgUHJvdmVyKS5cblxuICAgIHdhc21zbmFyayBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21zbmFyayBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtc25hcmsuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCBidWlsZEV4cCQxID0gYnVpbGRfdGltZXNzY2FsYXI7XG5jb25zdCBidWlsZEJhdGNoSW52ZXJzZSQxID0gYnVpbGRfYmF0Y2hpbnZlcnNlO1xuY29uc3QgdXRpbHMkNCA9IHV0aWxzJDY7XG5cbnZhciBidWlsZF9mMm0gPSBmdW5jdGlvbiBidWlsZEYybShtb2R1bGUsIG11bE5vblJlc2lkdWVGbiwgcHJlZml4LCBmMW1QcmVmaXgpIHtcblxuICAgIGlmIChtb2R1bGUubW9kdWxlc1twcmVmaXhdKSByZXR1cm4gcHJlZml4OyAgLy8gYWxyZWFkeSBidWlsZGVkXG5cbiAgICBjb25zdCBmMW44ID0gbW9kdWxlLm1vZHVsZXNbZjFtUHJlZml4XS5uNjQqODtcbiAgICBjb25zdCBxID0gbW9kdWxlLm1vZHVsZXNbZjFtUHJlZml4XS5xO1xuXG4gICAgbW9kdWxlLm1vZHVsZXNbcHJlZml4XSA9IHtcbiAgICAgICAgbjY0OiBtb2R1bGUubW9kdWxlc1tmMW1QcmVmaXhdLm42NCoyXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkQWRkKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9hZGRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCB5MCA9IGMuZ2V0TG9jYWwoXCJ5XCIpO1xuICAgICAgICBjb25zdCB5MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieVwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCByMCA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCByMSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfYWRkXCIsIHgwLCB5MCwgcjApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9hZGRcIiwgeDEsIHkxLCByMSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRUaW1lc1NjYWxhcigpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfdGltZXNTY2FsYXJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwic2NhbGFyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwic2NhbGFyTGVuXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHgxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHIwID0gYy5nZXRMb2NhbChcInJcIik7XG4gICAgICAgIGNvbnN0IHIxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl90aW1lc1NjYWxhclwiLCB4MCwgYy5nZXRMb2NhbChcInNjYWxhclwiKSwgYy5nZXRMb2NhbChcInNjYWxhckxlblwiKSwgcjApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl90aW1lc1NjYWxhclwiLCB4MSwgYy5nZXRMb2NhbChcInNjYWxhclwiKSwgYy5nZXRMb2NhbChcInNjYWxhckxlblwiKSwgcjEpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkU3ViKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9zdWJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCB5MCA9IGMuZ2V0TG9jYWwoXCJ5XCIpO1xuICAgICAgICBjb25zdCB5MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieVwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCByMCA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCByMSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfc3ViXCIsIHgwLCB5MCwgcjApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9zdWJcIiwgeDEsIHkxLCByMSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGROZWcoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX25lZ1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDAgPSBjLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgeDEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgcjAgPSBjLmdldExvY2FsKFwiclwiKTtcbiAgICAgICAgY29uc3QgcjEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX25lZ1wiLCB4MCwgcjApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9uZWdcIiwgeDEsIHIxKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZENvbmp1Z2F0ZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfY29uanVnYXRlXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCByMCA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCByMSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfY29weVwiLCB4MCwgcjApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9uZWdcIiwgeDEsIHIxKSxcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkSXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfaXNOZWdhdGl2ZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHgxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2lzWmVyb1wiLCB4MSksXG4gICAgICAgICAgICAgICAgYy5yZXQoYy5jYWxsKGYxbVByZWZpeCtcIl9pc05lZ2F0aXZlXCIsIHgwKSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLnJldChjLmNhbGwoZjFtUHJlZml4K1wiX2lzTmVnYXRpdmVcIiwgeDEpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTXVsKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9tdWxcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCB5MCA9IGMuZ2V0TG9jYWwoXCJ5XCIpO1xuICAgICAgICBjb25zdCB5MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieVwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCByMCA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCByMSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuXG4gICAgICAgIGNvbnN0IEEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBCID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcbiAgICAgICAgY29uc3QgQyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KSk7XG4gICAgICAgIGNvbnN0IEQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuXG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCB4MCwgeTAsIEEpLCAgICAgICAgICAgICAvLyBBID0geDAqeTBcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9tdWxcIiwgeDEsIHkxLCBCKSwgICAgICAgICAgICAgLy8gQiA9IHgxKnkxXG5cbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9hZGRcIiwgeDAsIHgxLCBDKSwgICAgICAgICAgICAgLy8gQyA9IHgwICsgeDFcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9hZGRcIiwgeTAsIHkxLCBEKSwgICAgICAgICAgICAgLy8gRCA9IHkwICsgeTFcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9tdWxcIiwgQywgRCwgQyksICAgICAgICAgICAgICAgLy8gQyA9ICh4MCArIHgxKSooeTAgKyB5MSkgPSB4MCp5MCt4MCp5MSt4MSp5MCt4MSp5MVxuXG4gICAgICAgICAgICAvLyAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCBCLCBjLmkzMl9jb25zdChwTm9uUmVzaWR1ZSksIHIwKSwgIC8vIHIwID0gbnIqKHgxKnkxKVxuICAgICAgICAgICAgYy5jYWxsKG11bE5vblJlc2lkdWVGbiwgQiwgcjApLCAgLy8gcjAgPSBuciooeDEqeTEpXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIEEsIHIwLCByMCksICAgICAgICAgICAgIC8vIHIwID0geDAqeTAgKyBuciooeDEqeTEpXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIEEsIEIsIHIxKSwgICAgICAgICAgICAgLy8gcjEgPSB4MCp5MCt4MSp5MVxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX3N1YlwiLCBDLCByMSwgcjEpICAgICAgICAgICAgICAvLyByMSA9IHgwKnkwK3gwKnkxK3gxKnkwK3gxKnkxIC0geDAqeTAreDEqeTEgPSB4MCp5MSt4MSp5MFxuICAgICAgICApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRNdWwxKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9tdWwxXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInlcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDAgPSBjLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgeDEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgeSA9IGMuZ2V0TG9jYWwoXCJ5XCIpO1xuICAgICAgICBjb25zdCByMCA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCByMSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuXG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCB4MCwgeSwgcjApLCAgICAgICAgICAgICAvLyBBID0geDAqeVxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCB4MSwgeSwgcjEpLCAgICAgICAgICAgICAvLyBCID0geDEqeVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkU3F1YXJlKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9zcXVhcmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHgxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHIwID0gYy5nZXRMb2NhbChcInJcIik7XG4gICAgICAgIGNvbnN0IHIxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG5cbiAgICAgICAgY29uc3QgQUIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBBUEIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBBUE5CID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcbiAgICAgICAgY29uc3QgQUJQTkFCID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcblxuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIC8vIEFCID0geDAqeTFcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9tdWxcIiwgeDAsIHgxLCBBQiksXG5cbiAgICAgICAgICAgIC8vIEFQQiA9IHgwK3kxXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIHgwLCB4MSwgQVBCKSxcblxuICAgICAgICAgICAgLy8gQVBCTjAgPSB4MCArIG5yKngxXG4gICAgICAgICAgICBjLmNhbGwobXVsTm9uUmVzaWR1ZUZuLCB4MSwgQVBOQiksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIHgwLCBBUE5CLCBBUE5CKSxcblxuICAgICAgICAgICAgLy8gQUJQTkFCID0gYWIgKyBuciphYlxuICAgICAgICAgICAgYy5jYWxsKG11bE5vblJlc2lkdWVGbiwgQUIsIEFCUE5BQiksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIEFCUE5BQiwgQUIsIEFCUE5BQiksXG5cbiAgICAgICAgICAgIC8vIHIwID0gQVBCICogQVBOQiAtIEFCUE5BQlxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCBBUEIsIEFQTkIsIHIwKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9zdWJcIiwgcjAsIEFCUE5BQiwgcjApLFxuXG4gICAgICAgICAgICAvLyByMSA9IEFCICsgQUJcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9hZGRcIiwgQUIsIEFCLCByMSksXG4gICAgICAgICk7XG5cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkVG9Nb250Z29tZXJ5KCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl90b01vbnRnb21lcnlcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHgxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHIwID0gYy5nZXRMb2NhbChcInJcIik7XG4gICAgICAgIGNvbnN0IHIxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl90b01vbnRnb21lcnlcIiwgeDAsIHIwKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfdG9Nb250Z29tZXJ5XCIsIHgxLCByMSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEZyb21Nb250Z29tZXJ5KCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9mcm9tTW9udGdvbWVyeVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDAgPSBjLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgeDEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgcjAgPSBjLmdldExvY2FsKFwiclwiKTtcbiAgICAgICAgY29uc3QgcjEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2Zyb21Nb250Z29tZXJ5XCIsIHgwLCByMCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2Zyb21Nb250Z29tZXJ5XCIsIHgxLCByMSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZENvcHkoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2NvcHlcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHgxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHIwID0gYy5nZXRMb2NhbChcInJcIik7XG4gICAgICAgIGNvbnN0IHIxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9jb3B5XCIsIHgwLCByMCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2NvcHlcIiwgeDEsIHIxKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkWmVybygpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfemVyb1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfemVyb1wiLCB4MCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX3plcm9cIiwgeDEpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRPbmUoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX29uZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfb25lXCIsIHgwKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfemVyb1wiLCB4MSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEVxKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9lcVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ5XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCB5MCA9IGMuZ2V0TG9jYWwoXCJ5XCIpO1xuICAgICAgICBjb25zdCB5MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieVwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuaTMyX2FuZChcbiAgICAgICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2VxXCIsIHgwLCB5MCksXG4gICAgICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9lcVwiLCB4MSwgeTEpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRJc1plcm8oKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2lzWmVyb1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHgxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pMzJfYW5kKFxuICAgICAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfaXNaZXJvXCIsIHgwKSxcbiAgICAgICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2lzWmVyb1wiLCB4MSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEludmVyc2UoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2ludmVyc2VcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHgxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHIwID0gYy5nZXRMb2NhbChcInJcIik7XG4gICAgICAgIGNvbnN0IHIxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG5cbiAgICAgICAgY29uc3QgdDAgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCB0MSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KSk7XG4gICAgICAgIGNvbnN0IHQyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcbiAgICAgICAgY29uc3QgdDMgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfc3F1YXJlXCIsIHgwLCB0MCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX3NxdWFyZVwiLCB4MSwgdDEpLFxuICAgICAgICAgICAgLy8gYy5jYWxsKGYxbVByZWZpeCtcIl9tdWxcIiwgdDEsIGMuaTMyX2NvbnN0KHBOb25SZXNpZHVlKSwgdDIpLFxuICAgICAgICAgICAgYy5jYWxsKG11bE5vblJlc2lkdWVGbiwgdDEsIHQyKSxcblxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9zdWJcIiwgdDAsIHQyLCB0MiksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2ludmVyc2VcIiwgdDIsIHQzKSxcblxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9tdWxcIiwgeDAsIHQzLCByMCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX211bFwiLCB4MSwgdDMsIHIxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfbmVnXCIsIHIxLCByMSksXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZFNpZ24oKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX3NpZ25cIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwic1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5zZXRSZXR1cm5UeXBlKFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDAgPSBjLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgeDEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLnNldExvY2FsKFwic1wiICwgYy5jYWxsKCBmMW1QcmVmaXggKyBcIl9zaWduXCIsIHgxKSksXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJzXCIpLFxuICAgICAgICAgICAgICAgIGMucmV0KGMuZ2V0TG9jYWwoXCJzXCIpKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMucmV0KGMuY2FsbCggZjFtUHJlZml4ICsgXCJfc2lnblwiLCB4MCkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRJc09uZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfaXNPbmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMucmV0KGMuaTMyX2FuZChcbiAgICAgICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfaXNPbmVcIiwgeDApLFxuICAgICAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9pc1plcm9cIiwgeDEpLFxuICAgICAgICAgICAgKSlcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIC8vIENoZWNrIGhlcmU6IGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZlxuICAgIC8vIEFsZyA5YWRqXG4gICAgZnVuY3Rpb24gYnVpbGRTcXJ0KCkge1xuXG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX3NxcnRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJhXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICAvLyBCaWdJbnQgY2FuJ3QgdGFrZSBgdW5kZWZpbmVkYCBzbyB3ZSB1c2UgYHx8IDBgXG4gICAgICAgIGNvbnN0IGUzNCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyh1dGlscyQ0LmJpZ0ludDJCeXRlc0xFKChCaWdJbnQocSB8fCAwKSAtIDNuKSAvIDRuLCBmMW44ICkpKTtcbiAgICAgICAgLy8gQmlnSW50IGNhbid0IHRha2UgYHVuZGVmaW5lZGAgc28gd2UgdXNlIGB8fCAwYFxuICAgICAgICBjb25zdCBlMTIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2ModXRpbHMkNC5iaWdJbnQyQnl0ZXNMRSgoQmlnSW50KHEgfHwgMCkgLSAxbikgLyAybiwgZjFuOCApKSk7XG5cbiAgICAgICAgY29uc3QgYSA9IGMuZ2V0TG9jYWwoXCJhXCIpO1xuICAgICAgICBjb25zdCBhMSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KjIpKTtcbiAgICAgICAgY29uc3QgYWxwaGEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCoyKSk7XG4gICAgICAgIGNvbnN0IGEwID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgqMikpO1xuICAgICAgICBjb25zdCBwbjEgPSBtb2R1bGUuYWxsb2MoZjFuOCoyKTtcbiAgICAgICAgY29uc3QgbjEgPSBjLmkzMl9jb25zdChwbjEpO1xuICAgICAgICBjb25zdCBuMWEgPSBjLmkzMl9jb25zdChwbjEpO1xuICAgICAgICBjb25zdCBuMWIgPSBjLmkzMl9jb25zdChwbjErZjFuOCk7XG4gICAgICAgIGNvbnN0IHgwID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgqMikpO1xuICAgICAgICBjb25zdCBiID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgqMikpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX29uZVwiLCBuMSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfbmVnXCIsIG4xLCBuMSksXG5cbiAgICAgICAgICAgIC8vIGNvbnN0IGExID0gRi5wb3coYSwgRi5zcXJ0X2UzNCk7XG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfZXhwXCIsIGEsIGUzNCwgYy5pMzJfY29uc3QoZjFuOCksIGExKSxcblxuICAgICAgICAgICAgLy8gY29uc3QgYTEgPSBGLnBvdyhhLCBGLnNxcnRfZTM0KTtcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9zcXVhcmVcIiwgYTEsIGFscGhhKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9tdWxcIiwgYSwgYWxwaGEsIGFscGhhKSxcblxuICAgICAgICAgICAgLy8gY29uc3QgYTAgPSBGLm11bChGLmZyb2Jlbml1cygxLCBhbGZhKSwgYWxmYSk7XG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfY29uanVnYXRlXCIsIGFscGhhLCBhMCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfbXVsXCIsIGEwLCBhbHBoYSwgYTApLFxuXG4gICAgICAgICAgICAvLyBpZiAoRi5lcShhMCwgRi5uZWdvbmUpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGMuaWYoYy5jYWxsKHByZWZpeCArIFwiX2VxXCIsYTAsbjEpLCBjLnVucmVhY2hhYmxlKCkgKSxcblxuICAgICAgICAgICAgLy8gY29uc3QgeDAgPSBGLm11bChhMSwgYSk7XG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfbXVsXCIsIGExLCBhLCB4MCksXG5cbiAgICAgICAgICAgIC8vIGlmIChGLmVxKGFsZmEsIEYubmVnb25lKSkge1xuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfZXFcIiwgYWxwaGEsIG4xKSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIC8vIHggPSBGLm11bCh4MCwgW0YuRi56ZXJvLCBGLkYub25lXSk7XG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChmMW1QcmVmaXggKyBcIl96ZXJvXCIsIG4xYSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChmMW1QcmVmaXggKyBcIl9vbmVcIiwgbjFiKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX211bFwiLCBuMSwgeDAsIGMuZ2V0TG9jYWwoXCJwclwiKSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGIgPSBGLnBvdyhGLmFkZChGLm9uZSwgYWxmYSksIEYuc3FydF9lMTIpO1xuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4ICsgXCJfb25lXCIsIGIpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4ICsgXCJfYWRkXCIsIGIsIGFscGhhLCBiKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX2V4cFwiLCBiLCBlMTIsIGMuaTMyX2NvbnN0KGYxbjgpLCBiKSxcblxuICAgICAgICAgICAgICAgICAgICAvLyB4ID0gRi5tdWwoYiwgeDApO1xuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4ICsgXCJfbXVsXCIsIGIsIHgwLCBjLmdldExvY2FsKFwicHJcIikpLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRJc1NxdWFyZSgpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9pc1NxdWFyZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcImFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIC8vIEJpZ0ludCBjYW4ndCB0YWtlIGB1bmRlZmluZWRgIHNvIHdlIHVzZSBgfHwgMGBcbiAgICAgICAgY29uc3QgZTM0ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKHV0aWxzJDQuYmlnSW50MkJ5dGVzTEUoKEJpZ0ludChxIHx8IDApIC0gM24pIC8gNG4sIGYxbjggKSkpO1xuXG4gICAgICAgIGNvbnN0IGEgPSBjLmdldExvY2FsKFwiYVwiKTtcbiAgICAgICAgY29uc3QgYTEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCoyKSk7XG4gICAgICAgIGNvbnN0IGFscGhhID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgqMikpO1xuICAgICAgICBjb25zdCBhMCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KjIpKTtcbiAgICAgICAgY29uc3QgcG4xID0gbW9kdWxlLmFsbG9jKGYxbjgqMik7XG4gICAgICAgIGNvbnN0IG4xID0gYy5pMzJfY29uc3QocG4xKTtcblxuICAgICAgICBmLmFkZENvZGUoXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9vbmVcIiwgbjEpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX25lZ1wiLCBuMSwgbjEpLFxuXG4gICAgICAgICAgICAvLyBjb25zdCBhMSA9IEYucG93KGEsIEYuc3FydF9lMzQpO1xuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2V4cFwiLCBhLCBlMzQsIGMuaTMyX2NvbnN0KGYxbjgpLCBhMSksXG5cbiAgICAgICAgICAgIC8vIGNvbnN0IGExID0gRi5wb3coYSwgRi5zcXJ0X2UzNCk7XG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfc3F1YXJlXCIsIGExLCBhbHBoYSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfbXVsXCIsIGEsIGFscGhhLCBhbHBoYSksXG5cbiAgICAgICAgICAgIC8vIGNvbnN0IGEwID0gRi5tdWwoRi5mcm9iZW5pdXMoMSwgYWxmYSksIGFsZmEpO1xuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2Nvbmp1Z2F0ZVwiLCBhbHBoYSwgYTApLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX211bFwiLCBhMCwgYWxwaGEsIGEwKSxcblxuICAgICAgICAgICAgLy8gaWYgKEYuZXEoYTAsIEYubmVnb25lKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ICsgXCJfZXFcIixcbiAgICAgICAgICAgICAgICAgICAgYTAsXG4gICAgICAgICAgICAgICAgICAgIG4xXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLnJldChjLmkzMl9jb25zdCgwKSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLnJldChjLmkzMl9jb25zdCgxKSlcbiAgICAgICAgKTtcblxuICAgIH1cblxuXG4gICAgYnVpbGRJc1plcm8oKTtcbiAgICBidWlsZElzT25lKCk7XG4gICAgYnVpbGRaZXJvKCk7XG4gICAgYnVpbGRPbmUoKTtcbiAgICBidWlsZENvcHkoKTtcbiAgICBidWlsZE11bCgpO1xuICAgIGJ1aWxkTXVsMSgpO1xuICAgIGJ1aWxkU3F1YXJlKCk7XG4gICAgYnVpbGRBZGQoKTtcbiAgICBidWlsZFN1YigpO1xuICAgIGJ1aWxkTmVnKCk7XG4gICAgYnVpbGRDb25qdWdhdGUoKTtcbiAgICBidWlsZFRvTW9udGdvbWVyeSgpO1xuICAgIGJ1aWxkRnJvbU1vbnRnb21lcnkoKTtcbiAgICBidWlsZEVxKCk7XG4gICAgYnVpbGRJbnZlcnNlKCk7XG4gICAgYnVpbGRUaW1lc1NjYWxhcigpO1xuICAgIGJ1aWxkU2lnbigpO1xuICAgIGJ1aWxkSXNOZWdhdGl2ZSgpO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2lzWmVyb1wiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfaXNPbmVcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3plcm9cIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX29uZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfY29weVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfbXVsXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9tdWwxXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9zcXVhcmVcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2FkZFwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfc3ViXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9uZWdcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3NpZ25cIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2Nvbmp1Z2F0ZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfZnJvbU1vbnRnb21lcnlcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3RvTW9udGdvbWVyeVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfZXFcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2ludmVyc2VcIik7XG4gICAgYnVpbGRCYXRjaEludmVyc2UkMShtb2R1bGUsIHByZWZpeCk7XG4gICAgYnVpbGRFeHAkMShcbiAgICAgICAgbW9kdWxlLFxuICAgICAgICBwcmVmaXggKyBcIl9leHBcIixcbiAgICAgICAgZjFuOCoyLFxuICAgICAgICBwcmVmaXggKyBcIl9tdWxcIixcbiAgICAgICAgcHJlZml4ICsgXCJfc3F1YXJlXCIsXG4gICAgICAgIHByZWZpeCArIFwiX2NvcHlcIixcbiAgICAgICAgcHJlZml4ICsgXCJfb25lXCIsXG4gICAgKTtcbiAgICBidWlsZFNxcnQoKTtcbiAgICBidWlsZElzU3F1YXJlKCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfZXhwXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl90aW1lc1NjYWxhclwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfYmF0Y2hJbnZlcnNlXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9zcXJ0XCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9pc1NxdWFyZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfaXNOZWdhdGl2ZVwiKTtcblxuXG4gICAgcmV0dXJuIHByZWZpeDtcbn07XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTkgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3YXNtc25hcmsgKFdlYiBBc3NlbWJseSB6a1NuYXJrIFByb3ZlcikuXG5cbiAgICB3YXNtc25hcmsgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3YXNtc25hcmsgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2FzbXNuYXJrLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuY29uc3QgYnVpbGRFeHAgPSBidWlsZF90aW1lc3NjYWxhcjtcbmNvbnN0IGJ1aWxkQmF0Y2hJbnZlcnNlID0gYnVpbGRfYmF0Y2hpbnZlcnNlO1xuXG52YXIgYnVpbGRfZjNtID0gZnVuY3Rpb24gYnVpbGRGM20obW9kdWxlLCBtdWxOb25SZXNpZHVlRm4sIHByZWZpeCwgZjFtUHJlZml4KSB7XG5cbiAgICBpZiAobW9kdWxlLm1vZHVsZXNbcHJlZml4XSkgcmV0dXJuIHByZWZpeDsgIC8vIGFscmVhZHkgYnVpbGRlZFxuXG4gICAgY29uc3QgZjFuOCA9IG1vZHVsZS5tb2R1bGVzW2YxbVByZWZpeF0ubjY0Kjg7XG4gICAgbW9kdWxlLm1vZHVsZXNbcHJlZml4XSA9IHtcbiAgICAgICAgbjY0OiBtb2R1bGUubW9kdWxlc1tmMW1QcmVmaXhdLm42NCozXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkQWRkKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9hZGRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCB4MiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoMipmMW44KSk7XG4gICAgICAgIGNvbnN0IHkwID0gYy5nZXRMb2NhbChcInlcIik7XG4gICAgICAgIGNvbnN0IHkxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ5XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHkyID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ5XCIpLCBjLmkzMl9jb25zdCgyKmYxbjgpKTtcbiAgICAgICAgY29uc3QgcjAgPSBjLmdldExvY2FsKFwiclwiKTtcbiAgICAgICAgY29uc3QgcjEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgcjIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KDIqZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfYWRkXCIsIHgwLCB5MCwgcjApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9hZGRcIiwgeDEsIHkxLCByMSksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2FkZFwiLCB4MiwgeTIsIHIyKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFRpbWVzU2NhbGFyKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl90aW1lc1NjYWxhclwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJzY2FsYXJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJzY2FsYXJMZW5cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDAgPSBjLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgeDEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgeDIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KDIqZjFuOCkpO1xuICAgICAgICBjb25zdCByMCA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCByMSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCByMiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoMipmMW44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl90aW1lc1NjYWxhclwiLCB4MCwgYy5nZXRMb2NhbChcInNjYWxhclwiKSwgYy5nZXRMb2NhbChcInNjYWxhckxlblwiKSwgcjApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl90aW1lc1NjYWxhclwiLCB4MSwgYy5nZXRMb2NhbChcInNjYWxhclwiKSwgYy5nZXRMb2NhbChcInNjYWxhckxlblwiKSwgcjEpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl90aW1lc1NjYWxhclwiLCB4MiwgYy5nZXRMb2NhbChcInNjYWxhclwiKSwgYy5nZXRMb2NhbChcInNjYWxhckxlblwiKSwgcjIpLFxuICAgICAgICApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRTdWIoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX3N1YlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ5XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHgxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHgyID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdCgyKmYxbjgpKTtcbiAgICAgICAgY29uc3QgeTAgPSBjLmdldExvY2FsKFwieVwiKTtcbiAgICAgICAgY29uc3QgeTEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInlcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgeTIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInlcIiksIGMuaTMyX2NvbnN0KDIqZjFuOCkpO1xuICAgICAgICBjb25zdCByMCA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCByMSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCByMiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoMipmMW44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9zdWJcIiwgeDAsIHkwLCByMCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX3N1YlwiLCB4MSwgeTEsIHIxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfc3ViXCIsIHgyLCB5MiwgcjIpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTmVnKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9uZWdcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHgxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHgyID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdCgyKmYxbjgpKTtcbiAgICAgICAgY29uc3QgcjAgPSBjLmdldExvY2FsKFwiclwiKTtcbiAgICAgICAgY29uc3QgcjEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgcjIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KDIqZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfbmVnXCIsIHgwLCByMCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX25lZ1wiLCB4MSwgcjEpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9uZWdcIiwgeDIsIHIyKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZElzTmVnYXRpdmUoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2lzTmVnYXRpdmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCB4MiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoMipmMW44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2lzWmVyb1wiLCB4MiksXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9pc1plcm9cIiwgeDEpLFxuICAgICAgICAgICAgICAgICAgICBjLnJldChjLmNhbGwoZjFtUHJlZml4K1wiX2lzTmVnYXRpdmVcIiwgeDApKSxcbiAgICAgICAgICAgICAgICAgICAgYy5yZXQoYy5jYWxsKGYxbVByZWZpeCtcIl9pc05lZ2F0aXZlXCIsIHgxKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5yZXQoYy5jYWxsKGYxbVByZWZpeCtcIl9pc05lZ2F0aXZlXCIsIHgyKSlcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTXVsKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9tdWxcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgY2QgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgYSA9IGNkLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgYiA9IGNkLmkzMl9hZGQoY2QuZ2V0TG9jYWwoXCJ4XCIpLCBjZC5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCBjID0gY2QuaTMyX2FkZChjZC5nZXRMb2NhbChcInhcIiksIGNkLmkzMl9jb25zdCgyKmYxbjgpKTtcbiAgICAgICAgY29uc3QgQSA9IGNkLmdldExvY2FsKFwieVwiKTtcbiAgICAgICAgY29uc3QgQiA9IGNkLmkzMl9hZGQoY2QuZ2V0TG9jYWwoXCJ5XCIpLCBjZC5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCBDID0gY2QuaTMyX2FkZChjZC5nZXRMb2NhbChcInlcIiksIGNkLmkzMl9jb25zdCgyKmYxbjgpKTtcbiAgICAgICAgY29uc3QgcjAgPSBjZC5nZXRMb2NhbChcInJcIik7XG4gICAgICAgIGNvbnN0IHIxID0gY2QuaTMyX2FkZChjZC5nZXRMb2NhbChcInJcIiksIGNkLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHIyID0gY2QuaTMyX2FkZChjZC5nZXRMb2NhbChcInJcIiksIGNkLmkzMl9jb25zdCgyKmYxbjgpKTtcblxuICAgICAgICBjb25zdCBhQSA9IGNkLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBiQiA9IGNkLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBjQyA9IGNkLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBhX2IgPSBjZC5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcbiAgICAgICAgY29uc3QgQV9CID0gY2QuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KSk7XG4gICAgICAgIGNvbnN0IGFfYyA9IGNkLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBBX0MgPSBjZC5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcbiAgICAgICAgY29uc3QgYl9jID0gY2QuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KSk7XG4gICAgICAgIGNvbnN0IEJfQyA9IGNkLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBhQV9iQiA9IGNkLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBhQV9jQyA9IGNkLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBiQl9jQyA9IGNkLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBBVVggPSBjZC5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcblxuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGNkLmNhbGwoZjFtUHJlZml4ICsgXCJfbXVsXCIsIGEsIEEsIGFBKSxcbiAgICAgICAgICAgIGNkLmNhbGwoZjFtUHJlZml4ICsgXCJfbXVsXCIsIGIsIEIsIGJCKSxcbiAgICAgICAgICAgIGNkLmNhbGwoZjFtUHJlZml4ICsgXCJfbXVsXCIsIGMsIEMsIGNDKSxcblxuICAgICAgICAgICAgY2QuY2FsbChmMW1QcmVmaXggKyBcIl9hZGRcIiwgYSwgYiwgYV9iKSxcbiAgICAgICAgICAgIGNkLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIEEsIEIsIEFfQiksXG4gICAgICAgICAgICBjZC5jYWxsKGYxbVByZWZpeCArIFwiX2FkZFwiLCBhLCBjLCBhX2MpLFxuICAgICAgICAgICAgY2QuY2FsbChmMW1QcmVmaXggKyBcIl9hZGRcIiwgQSwgQywgQV9DKSxcbiAgICAgICAgICAgIGNkLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIGIsIGMsIGJfYyksXG4gICAgICAgICAgICBjZC5jYWxsKGYxbVByZWZpeCArIFwiX2FkZFwiLCBCLCBDLCBCX0MpLFxuXG4gICAgICAgICAgICBjZC5jYWxsKGYxbVByZWZpeCArIFwiX2FkZFwiLCBhQSwgYkIsIGFBX2JCKSxcbiAgICAgICAgICAgIGNkLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIGFBLCBjQywgYUFfY0MpLFxuICAgICAgICAgICAgY2QuY2FsbChmMW1QcmVmaXggKyBcIl9hZGRcIiwgYkIsIGNDLCBiQl9jQyksXG5cbiAgICAgICAgICAgIGNkLmNhbGwoZjFtUHJlZml4ICsgXCJfbXVsXCIsIGJfYywgQl9DLCByMCksXG4gICAgICAgICAgICBjZC5jYWxsKGYxbVByZWZpeCArIFwiX3N1YlwiLCByMCwgYkJfY0MsIHIwKSxcbiAgICAgICAgICAgIGNkLmNhbGwobXVsTm9uUmVzaWR1ZUZuLCByMCwgcjApLFxuICAgICAgICAgICAgY2QuY2FsbChmMW1QcmVmaXggKyBcIl9hZGRcIiwgYUEsIHIwLCByMCksXG5cbiAgICAgICAgICAgIGNkLmNhbGwoZjFtUHJlZml4ICsgXCJfbXVsXCIsIGFfYiwgQV9CLCByMSksXG4gICAgICAgICAgICBjZC5jYWxsKGYxbVByZWZpeCArIFwiX3N1YlwiLCByMSwgYUFfYkIsIHIxKSxcbiAgICAgICAgICAgIGNkLmNhbGwobXVsTm9uUmVzaWR1ZUZuLCBjQywgQVVYKSxcbiAgICAgICAgICAgIGNkLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIHIxLCBBVVgsIHIxKSxcblxuICAgICAgICAgICAgY2QuY2FsbChmMW1QcmVmaXggKyBcIl9tdWxcIiwgYV9jLCBBX0MsIHIyKSxcbiAgICAgICAgICAgIGNkLmNhbGwoZjFtUHJlZml4ICsgXCJfc3ViXCIsIHIyLCBhQV9jQywgcjIpLFxuICAgICAgICAgICAgY2QuY2FsbChmMW1QcmVmaXggKyBcIl9hZGRcIiwgcjIsIGJCLCByMiksXG4gICAgICAgICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFNxdWFyZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfc3F1YXJlXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBBID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IEIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgQyA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoMipmMW44KSk7XG4gICAgICAgIGNvbnN0IHIwID0gYy5nZXRMb2NhbChcInJcIik7XG4gICAgICAgIGNvbnN0IHIxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHIyID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdCgyKmYxbjgpKTtcblxuICAgICAgICBjb25zdCBzMCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KSk7XG4gICAgICAgIGNvbnN0IGFiID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcbiAgICAgICAgY29uc3QgczEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBzMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KSk7XG4gICAgICAgIGNvbnN0IGJjID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcbiAgICAgICAgY29uc3QgczMgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBzNCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KSk7XG5cblxuICAgICAgICBmLmFkZENvZGUoXG5cbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9zcXVhcmVcIiwgQSwgczApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCBBLCBCLCBhYiksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIGFiLCBhYiwgczEpLFxuXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfc3ViXCIsIEEsIEIsIHMyKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9hZGRcIiwgczIsIEMsIHMyKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9zcXVhcmVcIiwgczIsIHMyKSxcblxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCBCLCBDLCBiYyksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIGJjLCBiYywgczMpLFxuXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfc3F1YXJlXCIsIEMsIHM0KSxcblxuICAgICAgICAgICAgYy5jYWxsKG11bE5vblJlc2lkdWVGbiwgczMsIHIwKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9hZGRcIiwgczAsIHIwLCByMCksXG5cbiAgICAgICAgICAgIGMuY2FsbChtdWxOb25SZXNpZHVlRm4sIHM0LCByMSksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIHMxLCByMSwgcjEpLFxuXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIHMwLCBzNCwgcjIpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX3N1YlwiLCBzMywgcjIsIHIyKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9hZGRcIiwgczIsIHIyLCByMiksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIHMxLCByMiwgcjIpLFxuICAgICAgICApO1xuXG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZFRvTW9udGdvbWVyeSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfdG9Nb250Z29tZXJ5XCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCB4MiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoMipmMW44KSk7XG4gICAgICAgIGNvbnN0IHIwID0gYy5nZXRMb2NhbChcInJcIik7XG4gICAgICAgIGNvbnN0IHIxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHIyID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdCgyKmYxbjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX3RvTW9udGdvbWVyeVwiLCB4MCwgcjApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl90b01vbnRnb21lcnlcIiwgeDEsIHIxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfdG9Nb250Z29tZXJ5XCIsIHgyLCByMilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEZyb21Nb250Z29tZXJ5KCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9mcm9tTW9udGdvbWVyeVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDAgPSBjLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgeDEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgeDIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KDIqZjFuOCkpO1xuICAgICAgICBjb25zdCByMCA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCByMSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCByMiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoMipmMW44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9mcm9tTW9udGdvbWVyeVwiLCB4MCwgcjApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9mcm9tTW9udGdvbWVyeVwiLCB4MSwgcjEpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9mcm9tTW9udGdvbWVyeVwiLCB4MiwgcjIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRDb3B5KCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9jb3B5XCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCB4MiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoMipmMW44KSk7XG4gICAgICAgIGNvbnN0IHIwID0gYy5nZXRMb2NhbChcInJcIik7XG4gICAgICAgIGNvbnN0IHIxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHIyID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdCgyKmYxbjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2NvcHlcIiwgeDAsIHIwKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfY29weVwiLCB4MSwgcjEpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9jb3B5XCIsIHgyLCByMiksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRaZXJvKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl96ZXJvXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHgxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHgyID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdCgyKmYxbjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX3plcm9cIiwgeDApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl96ZXJvXCIsIHgxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfemVyb1wiLCB4MiksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRPbmUoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX29uZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCA9IGMuZ2V0TG9jYWwoXCJ4XCIpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCB4MiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoMipmMW44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9vbmVcIiwgeDApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl96ZXJvXCIsIHgxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfemVyb1wiLCB4MiksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRFcSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfZXFcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5zZXRSZXR1cm5UeXBlKFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDAgPSBjLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgeDEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgeDIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KDIqZjFuOCkpO1xuICAgICAgICBjb25zdCB5MCA9IGMuZ2V0TG9jYWwoXCJ5XCIpO1xuICAgICAgICBjb25zdCB5MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieVwiKSwgYy5pMzJfY29uc3QoZjFuOCkpO1xuICAgICAgICBjb25zdCB5MiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieVwiKSwgYy5pMzJfY29uc3QoMipmMW44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pMzJfYW5kKFxuICAgICAgICAgICAgICAgIGMuaTMyX2FuZChcbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9lcVwiLCB4MCwgeTApLFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2VxXCIsIHgxLCB5MSksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2VxXCIsIHgyLCB5MilcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZElzWmVybygpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfaXNaZXJvXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5zZXRSZXR1cm5UeXBlKFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDAgPSBjLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgeDEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgeDIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KDIqZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuaTMyX2FuZChcbiAgICAgICAgICAgICAgICBjLmkzMl9hbmQoXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfaXNaZXJvXCIsIHgwKSxcbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9pc1plcm9cIiwgeDEpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2lzWmVyb1wiLCB4MilcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEludmVyc2UoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2ludmVyc2VcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHgxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMW44KSk7XG4gICAgICAgIGNvbnN0IHgyID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdCgyKmYxbjgpKTtcbiAgICAgICAgY29uc3QgcjAgPSBjLmdldExvY2FsKFwiclwiKTtcbiAgICAgICAgY29uc3QgcjEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgcjIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KDIqZjFuOCkpO1xuXG4gICAgICAgIGNvbnN0IHQwID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcbiAgICAgICAgY29uc3QgdDEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCB0MiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KSk7XG4gICAgICAgIGNvbnN0IHQzID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcbiAgICAgICAgY29uc3QgdDQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCB0NSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KSk7XG4gICAgICAgIGNvbnN0IGMwID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcbiAgICAgICAgY29uc3QgYzEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFuOCkpO1xuICAgICAgICBjb25zdCBjMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMW44KSk7XG4gICAgICAgIGNvbnN0IHQ2ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcbiAgICAgICAgY29uc3QgQVVYID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxbjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX3NxdWFyZVwiLCB4MCwgdDApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9zcXVhcmVcIiwgeDEsIHQxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfc3F1YXJlXCIsIHgyLCB0MiksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX211bFwiLCB4MCwgeDEsIHQzKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfbXVsXCIsIHgwLCB4MiwgdDQpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9tdWxcIiwgeDEsIHgyLCB0NSksXG5cbiAgICAgICAgICAgIGMuY2FsbChtdWxOb25SZXNpZHVlRm4sIHQ1LCBjMCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX3N1YlwiLCB0MCwgYzAsIGMwKSxcblxuICAgICAgICAgICAgYy5jYWxsKG11bE5vblJlc2lkdWVGbiwgdDIsIGMxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfc3ViXCIsIGMxLCB0MywgYzEpLFxuXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX3N1YlwiLCB0MSwgdDQsIGMyKSxcblxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9tdWxcIiwgeDIsIGMxLCB0NiksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX211bFwiLCB4MSwgYzIsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2FkZFwiLCB0NiwgQVVYLCB0NiksXG4gICAgICAgICAgICBjLmNhbGwobXVsTm9uUmVzaWR1ZUZuLCB0NiwgdDYpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9tdWxcIiwgeDAsIGMwLCBBVVgpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9hZGRcIiwgQVVYLCB0NiwgdDYpLFxuXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2ludmVyc2VcIiwgdDYsIHQ2KSxcblxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCtcIl9tdWxcIiwgdDYsIGMwLCByMCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX211bFwiLCB0NiwgYzEsIHIxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfbXVsXCIsIHQ2LCBjMiwgcjIpXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZFNpZ24oKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX3NpZ25cIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwic1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5zZXRSZXR1cm5UeXBlKFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDAgPSBjLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgeDEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgeDIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KDIqZjFuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJzXCIgLCBjLmNhbGwoIGYxbVByZWZpeCArIFwiX3NpZ25cIiwgeDIpKSxcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInNcIiksXG4gICAgICAgICAgICAgICAgYy5yZXQoYy5nZXRMb2NhbChcInNcIikpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInNcIiAsIGMuY2FsbCggZjFtUHJlZml4ICsgXCJfc2lnblwiLCB4MSkpLFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic1wiKSxcbiAgICAgICAgICAgICAgICBjLnJldChjLmdldExvY2FsKFwic1wiKSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLnJldChjLmNhbGwoIGYxbVByZWZpeCArIFwiX3NpZ25cIiwgeDApKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkSXNPbmUoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2lzT25lXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwieFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5zZXRSZXR1cm5UeXBlKFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDAgPSBjLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgeDEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgpKTtcbiAgICAgICAgY29uc3QgeDIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxbjgqMikpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMucmV0KFxuICAgICAgICAgICAgICAgIGMuaTMyX2FuZChcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfYW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX2lzT25lXCIsIHgwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9pc1plcm9cIiwgeDEpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9pc1plcm9cIiwgeDIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGJ1aWxkSXNaZXJvKCk7XG4gICAgYnVpbGRJc09uZSgpO1xuICAgIGJ1aWxkWmVybygpO1xuICAgIGJ1aWxkT25lKCk7XG4gICAgYnVpbGRDb3B5KCk7XG4gICAgYnVpbGRNdWwoKTtcbiAgICBidWlsZFNxdWFyZSgpO1xuICAgIGJ1aWxkQWRkKCk7XG4gICAgYnVpbGRTdWIoKTtcbiAgICBidWlsZE5lZygpO1xuICAgIGJ1aWxkU2lnbigpO1xuICAgIGJ1aWxkVG9Nb250Z29tZXJ5KCk7XG4gICAgYnVpbGRGcm9tTW9udGdvbWVyeSgpO1xuICAgIGJ1aWxkRXEoKTtcbiAgICBidWlsZEludmVyc2UoKTtcbiAgICBidWlsZFRpbWVzU2NhbGFyKCk7XG4gICAgYnVpbGRJc05lZ2F0aXZlKCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfaXNaZXJvXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9pc09uZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfemVyb1wiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfb25lXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9jb3B5XCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9tdWxcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3NxdWFyZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfYWRkXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9zdWJcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX25lZ1wiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfc2lnblwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfZnJvbU1vbnRnb21lcnlcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3RvTW9udGdvbWVyeVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfZXFcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2ludmVyc2VcIik7XG4gICAgYnVpbGRCYXRjaEludmVyc2UobW9kdWxlLCBwcmVmaXgpO1xuICAgIGJ1aWxkRXhwKFxuICAgICAgICBtb2R1bGUsXG4gICAgICAgIHByZWZpeCArIFwiX2V4cFwiLFxuICAgICAgICBmMW44KjMsXG4gICAgICAgIHByZWZpeCArIFwiX211bFwiLFxuICAgICAgICBwcmVmaXggKyBcIl9zcXVhcmVcIixcbiAgICAgICAgcHJlZml4ICsgXCJfY29weVwiLFxuICAgICAgICBwcmVmaXggKyBcIl9vbmVcIlxuICAgICk7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2V4cFwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfdGltZXNTY2FsYXJcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2JhdGNoSW52ZXJzZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfaXNOZWdhdGl2ZVwiKTtcblxuICAgIHJldHVybiBwcmVmaXg7XG59O1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDE5IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2FzbXNuYXJrIChXZWIgQXNzZW1ibHkgemtTbmFyayBQcm92ZXIpLlxuXG4gICAgd2FzbXNuYXJrIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2FzbXNuYXJrIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdhc21zbmFyay4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbnZhciBidWlsZF90aW1lc3NjYWxhcm5hZiA9IGZ1bmN0aW9uIGJ1aWxkVGltZXNTY2FsYXJOQUYobW9kdWxlLCBmbk5hbWUsIGVsZW1lbnRMZW4sIG9wQUIsIG9wQUEsIG9wQW1CLCBvcENvcHksIG9wSW5pdCkge1xuXG4gICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihmbk5hbWUpO1xuICAgIGYuYWRkUGFyYW0oXCJiYXNlXCIsIFwiaTMyXCIpO1xuICAgIGYuYWRkUGFyYW0oXCJzY2FsYXJcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRQYXJhbShcInNjYWxhckxlbmd0aFwiLCBcImkzMlwiKTtcbiAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcbiAgICBmLmFkZExvY2FsKFwib2xkMFwiLCBcImkzMlwiKTtcbiAgICBmLmFkZExvY2FsKFwibmJpdHNcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcImlcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcImxhc3RcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcImN1clwiLCBcImkzMlwiKTtcbiAgICBmLmFkZExvY2FsKFwiY2FycnlcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcInBcIiwgXCJpMzJcIik7XG5cbiAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgY29uc3QgYXV4ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGVsZW1lbnRMZW4pKTtcblxuICAgIGZ1bmN0aW9uIGdldEJpdChJRFgpIHtcbiAgICAgICAgcmV0dXJuIGMuaTMyX2FuZChcbiAgICAgICAgICAgIGMuaTMyX3Nocl91KFxuICAgICAgICAgICAgICAgIGMuaTMyX2xvYWQoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJzY2FsYXJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9hbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElEWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDB4RkZGRkZGRkMpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuaTMyX2FuZChcbiAgICAgICAgICAgICAgICAgICAgSURYLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgweDFGKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmkzMl9jb25zdCgxKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hCaXQoYikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4uYy5pMzJfc3RvcmU4KFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwXCIpLFxuICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KGIpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICBcInBcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBmLmFkZENvZGUoXG4gICAgICAgIGMuaWYoXG4gICAgICAgICAgICBjLmkzMl9lcXooYy5nZXRMb2NhbChcInNjYWxhckxlbmd0aFwiKSksXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLi4uYy5jYWxsKG9wSW5pdCwgYy5nZXRMb2NhbChcInJcIikpLFxuICAgICAgICAgICAgICAgIC4uLmMucmV0KFtdKVxuICAgICAgICAgICAgXVxuICAgICAgICApLFxuICAgICAgICBjLnNldExvY2FsKFwibmJpdHNcIiwgYy5pMzJfc2hsKGMuZ2V0TG9jYWwoXCJzY2FsYXJMZW5ndGhcIiksIGMuaTMyX2NvbnN0KDMpKSksXG4gICAgICAgIGMuc2V0TG9jYWwoXCJvbGQwXCIsIGMuaTMyX2xvYWQoYy5pMzJfY29uc3QoMCkpKSxcbiAgICAgICAgYy5zZXRMb2NhbChcInBcIiwgYy5nZXRMb2NhbChcIm9sZDBcIikpLFxuICAgICAgICBjLmkzMl9zdG9yZShcbiAgICAgICAgICAgIGMuaTMyX2NvbnN0KDApLFxuICAgICAgICAgICAgYy5pMzJfYW5kKFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm9sZDBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgzMilcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5iaXRzXCIpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgweEZGRkZGRkY4KVxuICAgICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9jb25zdCgxKSksXG5cbiAgICAgICAgYy5zZXRMb2NhbChcImxhc3RcIixnZXRCaXQoYy5pMzJfY29uc3QoMCkpKSxcbiAgICAgICAgYy5zZXRMb2NhbChcImNhcnJ5XCIsYy5pMzJfY29uc3QoMCkpLFxuXG4gICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgYy5icl9pZigxLCBjLmkzMl9lcSggYy5nZXRMb2NhbChcImlcIiksIGMuZ2V0TG9jYWwoXCJuYml0c1wiKSkpLFxuXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiY3VyXCIsIGdldEJpdChjLmdldExvY2FsKFwiaVwiKSkpLFxuICAgICAgICAgICAgYy5pZiggYy5nZXRMb2NhbChcImxhc3RcIiksXG4gICAgICAgICAgICAgICAgYy5pZiggYy5nZXRMb2NhbChcImN1clwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pZihjLmdldExvY2FsKFwiY2FycnlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcImxhc3RcIiwgYy5pMzJfY29uc3QoMCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuc2V0TG9jYWwoXCJjYXJyeVwiLCBjLmkzMl9jb25zdCgxKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHVzaEJpdCgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuc2V0TG9jYWwoXCJsYXN0XCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwiY2FycnlcIiwgYy5pMzJfY29uc3QoMSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnB1c2hCaXQoMjU1KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pZihjLmdldExvY2FsKFwiY2FycnlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcImxhc3RcIiwgYy5pMzJfY29uc3QoMCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuc2V0TG9jYWwoXCJjYXJyeVwiLCBjLmkzMl9jb25zdCgxKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHVzaEJpdCgyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcImxhc3RcIiwgYy5pMzJfY29uc3QoMCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuc2V0TG9jYWwoXCJjYXJyeVwiLCBjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHVzaEJpdCgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuaWYoIGMuZ2V0TG9jYWwoXCJjdXJcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuaWYoYy5nZXRMb2NhbChcImNhcnJ5XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuc2V0TG9jYWwoXCJsYXN0XCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwiY2FycnlcIiwgYy5pMzJfY29uc3QoMSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnB1c2hCaXQoMClcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwibGFzdFwiLCBjLmkzMl9jb25zdCgxKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcImNhcnJ5XCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wdXNoQml0KDApXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBjLmlmKGMuZ2V0TG9jYWwoXCJjYXJyeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwibGFzdFwiLCBjLmkzMl9jb25zdCgxKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcImNhcnJ5XCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wdXNoQml0KDApXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcImxhc3RcIiwgYy5pMzJfY29uc3QoMCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuc2V0TG9jYWwoXCJjYXJyeVwiLCBjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHVzaEJpdCgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgYy5icigwKVxuICAgICAgICApKSxcblxuICAgICAgICBjLmlmKCBjLmdldExvY2FsKFwibGFzdFwiKSxcbiAgICAgICAgICAgIGMuaWYoYy5nZXRMb2NhbChcImNhcnJ5XCIpLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4ucHVzaEJpdCgyNTUpLFxuICAgICAgICAgICAgICAgICAgICAuLi5wdXNoQml0KDApLFxuICAgICAgICAgICAgICAgICAgICAuLi5wdXNoQml0KDEpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIC4uLnB1c2hCaXQoMSlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuaWYoYy5nZXRMb2NhbChcImNhcnJ5XCIpLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4ucHVzaEJpdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgLi4ucHVzaEJpdCgxKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICksXG5cbiAgICAgICAgYy5zZXRMb2NhbChcInBcIiwgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJwXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuXG4gICAgICAgIC8vIHAgYWxyZWFkeSBwb2ludHMgdG8gdGhlIGxhc3QgYml0XG5cbiAgICAgICAgYy5jYWxsKG9wQ29weSwgYy5nZXRMb2NhbChcImJhc2VcIiksIGF1eCksXG5cbiAgICAgICAgYy5jYWxsKG9wSW5pdCwgYy5nZXRMb2NhbChcInJcIikpLFxuXG4gICAgICAgIGMuYmxvY2soYy5sb29wKFxuXG5cbiAgICAgICAgICAgIGMuY2FsbChvcEFBLCBjLmdldExvY2FsKFwiclwiKSwgYy5nZXRMb2NhbChcInJcIikpLFxuXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJjdXJcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9sb2FkOF91KFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicFwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImN1clwiKSxcbiAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9lcShjLmdldExvY2FsKFwiY3VyXCIpLCBjLmkzMl9jb25zdCgxKSksXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChvcEFCLCAgYy5nZXRMb2NhbChcInJcIiksIGF1eCwgYy5nZXRMb2NhbChcInJcIikpLFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwob3BBbUIsIGMuZ2V0TG9jYWwoXCJyXCIpLCBhdXgsIGMuZ2V0TG9jYWwoXCJyXCIpKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBjLmJyX2lmKDEsIGMuaTMyX2VxKCBjLmdldExvY2FsKFwib2xkMFwiKSwgYy5nZXRMb2NhbChcInBcIikpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwXCIsIGMuaTMyX3N1YihjLmdldExvY2FsKFwicFwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgIGMuYnIoMClcblxuICAgICAgICApKSxcblxuICAgICAgICBjLmkzMl9zdG9yZSggYy5pMzJfY29uc3QoMCksIGMuZ2V0TG9jYWwoXCJvbGQwXCIpKVxuXG4gICAgKTtcblxufTtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21zbmFyayAoV2ViIEFzc2VtYmx5IHprU25hcmsgUHJvdmVyKS5cblxuICAgIHdhc21zbmFyayBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21zbmFyayBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtc25hcmsuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG52YXIgYnVpbGRfbXVsdGlleHAgPSBmdW5jdGlvbiBidWlsZE11bHRpZXhwKG1vZHVsZSwgcHJlZml4LCBmbk5hbWUsIG9wQWRkLCBuOGIpIHtcblxuICAgIGNvbnN0IG42NGcgPSBtb2R1bGUubW9kdWxlc1twcmVmaXhdLm42NDtcbiAgICBjb25zdCBuOGcgPSBuNjRnKjg7XG5cbiAgICBmdW5jdGlvbiBidWlsZEdldENodW5rKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKGZuTmFtZSArIFwiX2dldENodW5rXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicFNjYWxhclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInNjYWxhclNpemVcIiwgXCJpMzJcIik7ICAvLyBOdW1iZXIgb2YgYnl0ZXMgb2YgdGhlIHNjYWxhclxuICAgICAgICBmLmFkZFBhcmFtKFwic3RhcnRCaXRcIiwgXCJpMzJcIik7ICAvLyBCaXQgdG8gc3RhcnQgZXh0cmFjdFxuICAgICAgICBmLmFkZFBhcmFtKFwiY2h1bmtTaXplXCIsIFwiaTMyXCIpOyAgLy8gQ2h1bmsgc2l6ZSBpbiBiaXRzXG4gICAgICAgIGYuYWRkTG9jYWwoXCJiaXRzVG9FbmRcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJtYXNrXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiYml0c1RvRW5kXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfc3ViKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic2NhbGFyU2l6ZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDgpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJzdGFydEJpdFwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuaTMyX2d0X3MoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJjaHVua1NpemVcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJiaXRzVG9FbmRcIilcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwibWFza1wiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9zaGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImJpdHNUb0VuZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDEpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwibWFza1wiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9zaGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImNodW5rU2l6ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDEpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5pMzJfYW5kKFxuICAgICAgICAgICAgICAgIGMuaTMyX3Nocl91KFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9sb2FkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwU2NhbGFyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX3Nocl91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic3RhcnRCaXRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsICAvLyBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIDAgICAvLyBhbGlnbiB0byBieXRlLlxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic3RhcnRCaXRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgweDcpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJtYXNrXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRNdXRpZXhwQ2h1bmsoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24oZm5OYW1lICsgXCJfY2h1bmtcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQmFzZXNcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwU2NhbGFyc1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInNjYWxhclNpemVcIiwgXCJpMzJcIik7ICAvLyBOdW1iZXIgb2YgcG9pbnRzXG4gICAgICAgIGYuYWRkUGFyYW0oXCJuXCIsIFwiaTMyXCIpOyAgLy8gTnVtYmVyIG9mIHBvaW50c1xuICAgICAgICBmLmFkZFBhcmFtKFwic3RhcnRCaXRcIiwgXCJpMzJcIik7ICAvLyBiaXQgd2hlcmUgaXQgc3RhcnRzIHRoZSBjaHVua1xuICAgICAgICBmLmFkZFBhcmFtKFwiY2h1bmtTaXplXCIsIFwiaTMyXCIpOyAgLy8gYml0IHdoZXJlIGl0IHN0YXJ0cyB0aGUgY2h1bmtcbiAgICAgICAgZi5hZGRQYXJhbShcInByXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwibkNodW5rc1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIml0U2NhbGFyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiZW5kU2NhbGFyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaXRCYXNlXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImpcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJuVGFibGVcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJwVGFibGVcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpZHhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJwSWR4VGFibGVcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuaTMyX2VxeihjLmdldExvY2FsKFwiblwiKSksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4ICsgXCJfemVyb1wiLCBjLmdldExvY2FsKFwicHJcIikpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLnJldChbXSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAvLyBBbGxvY2F0ZSBtZW1vcnlcblxuICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICBcIm5UYWJsZVwiLFxuICAgICAgICAgICAgICAgIGMuaTMyX3NobChcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJjaHVua1NpemVcIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInBUYWJsZVwiLCBjLmkzMl9sb2FkKCBjLmkzMl9jb25zdCgwKSApKSxcbiAgICAgICAgICAgIGMuaTMyX3N0b3JlKFxuICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDApLFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBUYWJsZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5UYWJsZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44ZylcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIC8vIFJlc2V0IFRhYmxlXG4gICAgICAgICAgICBjLnNldExvY2FsKFwialwiLCBjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICBjLmJyX2lmKFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9lcShcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJqXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5UYWJsZVwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ICsgXCJfemVyb1wiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicFRhYmxlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJqXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44ZylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwialwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcImpcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSksXG5cbiAgICAgICAgICAgIC8vIERpc3RyaWJ1dGUgZWxlbWVudHNcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdEJhc2VcIiwgYy5nZXRMb2NhbChcInBCYXNlc1wiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaXRTY2FsYXJcIiwgYy5nZXRMb2NhbChcInBTY2FsYXJzXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJlbmRTY2FsYXJcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwU2NhbGFyc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic2NhbGFyU2l6ZVwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0U2NhbGFyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImVuZFNjYWxhclwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwiaWR4XCIsXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChmbk5hbWUgKyBcIl9nZXRDaHVua1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0U2NhbGFyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInNjYWxhclNpemVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic3RhcnRCaXRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiY2h1bmtTaXplXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeFwiKSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBJZHhUYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBUYWJsZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wQWRkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwSWR4VGFibGVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0QmFzZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicElkeFRhYmxlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdFNjYWxhclwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0U2NhbGFyXCIpLCBjLmdldExvY2FsKFwic2NhbGFyU2l6ZVwiKSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdEJhc2VcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpdEJhc2VcIiksIGMuaTMyX2NvbnN0KG44YikpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKSxcblxuICAgICAgICAgICAgYy5jYWxsKGZuTmFtZSArIFwiX3JlZHVjZVRhYmxlXCIsIGMuZ2V0TG9jYWwoXCJwVGFibGVcIiksIGMuZ2V0TG9jYWwoXCJjaHVua1NpemVcIikpLFxuICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgIHByZWZpeCArIFwiX2NvcHlcIixcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicFRhYmxlXCIpLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwclwiKVxuICAgICAgICAgICAgKSxcblxuXG4gICAgICAgICAgICBjLmkzMl9zdG9yZShcbiAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgwKSxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicFRhYmxlXCIpXG4gICAgICAgICAgICApXG5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZE11bHRpZXhwKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKGZuTmFtZSk7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQmFzZXNcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwU2NhbGFyc1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInNjYWxhclNpemVcIiwgXCJpMzJcIik7ICAvLyBOdW1iZXIgb2YgcG9pbnRzXG4gICAgICAgIGYuYWRkUGFyYW0oXCJuXCIsIFwiaTMyXCIpOyAgLy8gTnVtYmVyIG9mIHBvaW50c1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJjaHVua1NpemVcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJuQ2h1bmtzXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaXRTY2FsYXJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJlbmRTY2FsYXJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpdEJhc2VcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpdEJpdFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImlcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJqXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiblRhYmxlXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwicFRhYmxlXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaWR4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwicElkeFRhYmxlXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgYXV4ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44ZykpO1xuXG4gICAgICAgIGNvbnN0IHBUU2l6ZXMgPSBtb2R1bGUuYWxsb2MoW1xuICAgICAgICAgICAgMTcsIDE3LCAxNywgMTcsICAgMTcsIDE3LCAxNywgMTcsXG4gICAgICAgICAgICAxNywgMTcsIDE2LCAxNiwgICAxNSwgMTQsIDEzLCAxMyxcbiAgICAgICAgICAgIDEyLCAxMSwgMTAsICA5LCAgICA4LCAgNywgIDcsICA2LFxuICAgICAgICAgICAgNSAsICA0LCAgMywgIDIsICAgIDEsICAxLCAgMSwgIDFcbiAgICAgICAgXSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX3plcm9cIiwgYy5nZXRMb2NhbChcInByXCIpKSxcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5pMzJfZXF6KGMuZ2V0TG9jYWwoXCJuXCIpKSxcbiAgICAgICAgICAgICAgICBjLnJldChbXSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiY2h1bmtTaXplXCIsIGMuaTMyX2xvYWQ4X3UoIGMuaTMyX2NseihjLmdldExvY2FsKFwiblwiKSksICBwVFNpemVzICkpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICBcIm5DaHVua3NcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2Rpdl91KFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX3NobChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInNjYWxhclNpemVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJjaHVua1NpemVcIilcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG5cbiAgICAgICAgICAgIC8vIEFsbG9jYXRlIG1lbW9yeVxuXG4gICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgIFwiaXRCaXRcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX3N1YihcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuQ2h1bmtzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImNodW5rU2l6ZVwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICBjLmJyX2lmKFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9sdF9zKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0Qml0XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAvLyBEb3VibGUgbkNodW5rIHRpbWVzXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfZXF6KGMuY2FsbChwcmVmaXggKyBcIl9pc1plcm9cIiwgYy5nZXRMb2NhbChcInByXCIpKSksXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuc2V0TG9jYWwoXCJqXCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImpcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiY2h1bmtTaXplXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2RvdWJsZVwiLCBjLmdldExvY2FsKFwicHJcIiksIGMuZ2V0TG9jYWwoXCJwclwiKSksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwialwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcImpcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIGZuTmFtZSArIFwiX2NodW5rXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwQmFzZXNcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwU2NhbGFyc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInNjYWxhclNpemVcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXRCaXRcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJjaHVua1NpemVcIiksXG4gICAgICAgICAgICAgICAgICAgIGF1eFxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCArIFwiX2FkZFwiLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHJcIiksXG4gICAgICAgICAgICAgICAgICAgIGF1eCxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInByXCIpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaXRCaXRcIiwgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJpdEJpdFwiKSwgYy5nZXRMb2NhbChcImNodW5rU2l6ZVwiKSkpLFxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VUYWJsZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihmbk5hbWUgKyBcIl9yZWR1Y2VUYWJsZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBUYWJsZVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBcIiwgXCJpMzJcIik7ICAvLyBOdW1iZXIgb2YgYml0cyBvZiB0aGUgdGFibGVcbiAgICAgICAgZi5hZGRMb2NhbChcImhhbGZcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpdDFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpdDJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJwQWNjXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmkzMl9lcShjLmdldExvY2FsKFwicFwiKSwgYy5pMzJfY29uc3QoMSkpLFxuICAgICAgICAgICAgICAgIGMucmV0KFtdKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgXCJoYWxmXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfc2hsKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0MVwiLCBjLmdldExvY2FsKFwicFRhYmxlXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgXCJpdDJcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwVGFibGVcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJoYWxmXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjhnKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwQWNjXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfc3ViKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXQyXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGcpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0MVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwQWNjXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ICsgXCJfYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdDFcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdDJcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdDFcIilcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ICsgXCJfYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwQWNjXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXQyXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEFjY1wiKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0MVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0MVwiKSwgYy5pMzJfY29uc3QobjhnKSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdDJcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpdDJcIiksIGMuaTMyX2NvbnN0KG44ZykpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKSxcblxuICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgIGZuTmFtZSArIFwiX3JlZHVjZVRhYmxlXCIsXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBUYWJsZVwiKSxcbiAgICAgICAgICAgICAgICBjLmkzMl9zdWIoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwXCIsIGMuaTMyX3N1YihjLmdldExvY2FsKFwicFwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoMSwgYy5pMzJfZXF6KGMuZ2V0TG9jYWwoXCJwXCIpKSksXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2RvdWJsZVwiLCBjLmdldExvY2FsKFwicEFjY1wiKSwgYy5nZXRMb2NhbChcInBBY2NcIikpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwXCIsIGMuaTMyX3N1YihjLmdldExvY2FsKFwicFwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2FkZFwiLCBjLmdldExvY2FsKFwicFRhYmxlXCIpLCBjLmdldExvY2FsKFwicEFjY1wiKSwgYy5nZXRMb2NhbChcInBUYWJsZVwiKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBidWlsZEdldENodW5rKCk7XG4gICAgYnVpbGRSZWR1Y2VUYWJsZSgpO1xuICAgIGJ1aWxkTXV0aWV4cENodW5rKCk7XG4gICAgYnVpbGRNdWx0aWV4cCgpO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKGZuTmFtZSk7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKGZuTmFtZSArXCJfY2h1bmtcIik7XG5cblxufTtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21zbmFyayAoV2ViIEFzc2VtYmx5IHprU25hcmsgUHJvdmVyKS5cblxuICAgIHdhc21zbmFyayBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21zbmFyayBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtc25hcmsuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5jb25zdCBidWlsZFRpbWVzU2NhbGFyTkFGID0gYnVpbGRfdGltZXNzY2FsYXJuYWY7XG4vL2NvbnN0IGJ1aWxkVGltZXNTY2FsYXIgPSByZXF1aXJlKFwiLi9idWlsZF90aW1lc3NjYWxhclwiKTtcbmNvbnN0IGJ1aWxkQmF0Y2hDb252ZXJ0aW9uID0gYnVpbGRfYmF0Y2hjb252ZXJ0aW9uO1xuY29uc3QgYnVpbGRNdWx0aWV4cCQxID0gYnVpbGRfbXVsdGlleHA7XG5cbnZhciBidWlsZF9jdXJ2ZV9qYWNvYmlhbl9hMCA9IGZ1bmN0aW9uIGJ1aWxkQ3VydmUobW9kdWxlLCBwcmVmaXgsIHByZWZpeEZpZWxkLCBwQikge1xuXG5cbiAgICBjb25zdCBuNjQgPSBtb2R1bGUubW9kdWxlc1twcmVmaXhGaWVsZF0ubjY0O1xuICAgIGNvbnN0IG44ID0gbjY0Kjg7XG5cbiAgICBpZiAobW9kdWxlLm1vZHVsZXNbcHJlZml4XSkgcmV0dXJuIHByZWZpeDsgIC8vIGFscmVhZHkgYnVpbGRlZFxuICAgIG1vZHVsZS5tb2R1bGVzW3ByZWZpeF0gPSB7XG4gICAgICAgIG42NDogbjY0KjNcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYnVpbGRJc1plcm8oKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfaXNaZXJvXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicDFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwoXG4gICAgICAgICAgICBwcmVmaXhGaWVsZCArIFwiX2lzWmVyb1wiLFxuICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwMVwiKSxcbiAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOCoyKVxuICAgICAgICAgICAgKVxuICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRJc1plcm9BZmZpbmUoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfaXNaZXJvQWZmaW5lXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicDFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuaTMyX2FuZChcbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeEZpZWxkICsgXCJfaXNaZXJvXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwMVwiKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXhGaWVsZCArIFwiX2lzWmVyb1wiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicDFcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZENvcHkoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfY29weVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBzXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicGRcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bjY0KjM7IGkrKykge1xuICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgIGMuaTY0X3N0b3JlKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicGRcIiksXG4gICAgICAgICAgICAgICAgICAgIGkqOCxcbiAgICAgICAgICAgICAgICAgICAgYy5pNjRfbG9hZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkqOFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRDb3B5QWZmaW5lKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCArIFwiX2NvcHlBZmZpbmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwc1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBkXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG42NCoyOyBpKyspIHtcbiAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICBjLmk2NF9zdG9yZShcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBkXCIpLFxuICAgICAgICAgICAgICAgICAgICBpKjgsXG4gICAgICAgICAgICAgICAgICAgIGMuaTY0X2xvYWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBpKjhcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRaZXJvKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCArIFwiX3plcm9cIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwoXG4gICAgICAgICAgICBwcmVmaXhGaWVsZCArIFwiX3plcm9cIixcbiAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwclwiKVxuICAgICAgICApKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKFxuICAgICAgICAgICAgcHJlZml4RmllbGQgKyBcIl9vbmVcIixcbiAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHJcIiksXG4gICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjgpXG4gICAgICAgICAgICApXG4gICAgICAgICkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwoXG4gICAgICAgICAgICBwcmVmaXhGaWVsZCArIFwiX3plcm9cIixcbiAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHJcIiksXG4gICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjgqMilcbiAgICAgICAgICAgIClcbiAgICAgICAgKSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZFplcm9BZmZpbmUoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfemVyb0FmZmluZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInByXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChcbiAgICAgICAgICAgIHByZWZpeEZpZWxkICsgXCJfemVyb1wiLFxuICAgICAgICAgICAgYy5nZXRMb2NhbChcInByXCIpXG4gICAgICAgICkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwoXG4gICAgICAgICAgICBwcmVmaXhGaWVsZCArIFwiX3plcm9cIixcbiAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHJcIiksXG4gICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjgpXG4gICAgICAgICAgICApXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRXEoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfZXFcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwMVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJ6MVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInoyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDEgPSBjLmdldExvY2FsKFwicDFcIik7XG4gICAgICAgIGNvbnN0IHkxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwMVwiKSwgYy5pMzJfY29uc3QobjgpKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuc2V0TG9jYWwoXCJ6MVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChuOCoyKSkpKTtcbiAgICAgICAgY29uc3QgejEgPSBjLmdldExvY2FsKFwiejFcIik7XG4gICAgICAgIGNvbnN0IHgyID0gYy5nZXRMb2NhbChcInAyXCIpO1xuICAgICAgICBjb25zdCB5MiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicDJcIiksIGMuaTMyX2NvbnN0KG44KSk7XG4gICAgICAgIGYuYWRkQ29kZShjLnNldExvY2FsKFwiejJcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwMlwiKSwgYy5pMzJfY29uc3QobjgqMikpKSk7XG4gICAgICAgIGNvbnN0IHoyID0gYy5nZXRMb2NhbChcInoyXCIpO1xuXG4gICAgICAgIGNvbnN0IFoxWjEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgWjJaMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBVMSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBVMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBaMV9jdWJlZCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBaMl9jdWJlZCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBTMSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBTMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuXG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfaXNaZXJvXCIsIGMuZ2V0TG9jYWwoXCJwMVwiKSksXG4gICAgICAgICAgICAgICAgYy5yZXQoIGMuY2FsbChwcmVmaXggKyBcIl9pc1plcm9cIiwgYy5nZXRMb2NhbChcInAyXCIpKSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfaXNaZXJvXCIsIGMuZ2V0TG9jYWwoXCJwMlwiKSksXG4gICAgICAgICAgICAgICAgYy5yZXQoYy5pMzJfY29uc3QoMCkpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9pc09uZVwiLCB6MSksXG4gICAgICAgICAgICAgICAgYy5yZXQoYy5jYWxsKHByZWZpeCArIFwiX2VxTWl4ZWRcIiwgYy5nZXRMb2NhbChcInAyXCIpLCBjLmdldExvY2FsKFwicDFcIikpKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfaXNPbmVcIiwgejIpLFxuICAgICAgICAgICAgICAgIGMucmV0KGMuY2FsbChwcmVmaXggKyBcIl9lcU1peGVkXCIsIGMuZ2V0TG9jYWwoXCJwMVwiKSwgYy5nZXRMb2NhbChcInAyXCIpKSlcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCB6MSwgWjFaMSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zcXVhcmVcIiwgejIsIFoyWjIpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIHgxLCBaMloyLCBVMSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgeDIsIFoxWjEsIFUyKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB6MSwgWjFaMSwgWjFfY3ViZWQpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIHoyLCBaMloyLCBaMl9jdWJlZCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgeTEsIFoyX2N1YmVkLCBTMSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgeTIsIFoxX2N1YmVkLCBTMiksXG5cbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfZXFcIiwgVTEsIFUyKSxcbiAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9lcVwiLCBTMSwgUzIpLFxuICAgICAgICAgICAgICAgICAgICBjLnJldChjLmkzMl9jb25zdCgxKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5yZXQoYy5pMzJfY29uc3QoMCkpXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZEVxTWl4ZWQoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfZXFNaXhlZFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicDJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInoxXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDEgPSBjLmdldExvY2FsKFwicDFcIik7XG4gICAgICAgIGNvbnN0IHkxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwMVwiKSwgYy5pMzJfY29uc3QobjgpKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuc2V0TG9jYWwoXCJ6MVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChuOCoyKSkpKTtcbiAgICAgICAgY29uc3QgejEgPSBjLmdldExvY2FsKFwiejFcIik7XG4gICAgICAgIGNvbnN0IHgyID0gYy5nZXRMb2NhbChcInAyXCIpO1xuICAgICAgICBjb25zdCB5MiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicDJcIiksIGMuaTMyX2NvbnN0KG44KSk7XG5cbiAgICAgICAgY29uc3QgWjFaMSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBVMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBaMV9jdWJlZCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBTMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2lzWmVyb1wiLCBjLmdldExvY2FsKFwicDFcIikpLFxuICAgICAgICAgICAgICAgIGMucmV0KCBjLmNhbGwocHJlZml4ICsgXCJfaXNaZXJvQWZmaW5lXCIsIGMuZ2V0TG9jYWwoXCJwMlwiKSkpLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2lzWmVyb0FmZmluZVwiLCBjLmdldExvY2FsKFwicDJcIikpLFxuICAgICAgICAgICAgICAgIGMucmV0KGMuaTMyX2NvbnN0KDApKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfaXNPbmVcIiwgejEpLFxuICAgICAgICAgICAgICAgIGMucmV0KGMuY2FsbChwcmVmaXggKyBcIl9lcUFmZmluZVwiLCBjLmdldExvY2FsKFwicDFcIiksIGMuZ2V0TG9jYWwoXCJwMlwiKSkpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3F1YXJlXCIsIHoxLCBaMVoxKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB4MiwgWjFaMSwgVTIpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIHoxLCBaMVoxLCBaMV9jdWJlZCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgeTIsIFoxX2N1YmVkLCBTMiksXG5cbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfZXFcIiwgeDEsIFUyKSxcbiAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9lcVwiLCB5MSwgUzIpLFxuICAgICAgICAgICAgICAgICAgICBjLnJldChjLmkzMl9jb25zdCgxKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5yZXQoYy5pMzJfY29uc3QoMCkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGREb3VibGUoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfZG91YmxlXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicDFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHggPSBjLmdldExvY2FsKFwicDFcIik7XG4gICAgICAgIGNvbnN0IHkgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChuOCkpO1xuICAgICAgICBjb25zdCB6ID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwMVwiKSwgYy5pMzJfY29uc3QobjgqMikpO1xuICAgICAgICBjb25zdCB4MyA9IGMuZ2V0TG9jYWwoXCJwclwiKTtcbiAgICAgICAgY29uc3QgeTMgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChuOCkpO1xuICAgICAgICBjb25zdCB6MyA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicHJcIiksIGMuaTMyX2NvbnN0KG44KjIpKTtcblxuICAgICAgICBjb25zdCBBID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IEIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgQyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBEID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IEUgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgRiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBHID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IGVpZ2h0QyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2lzWmVyb1wiLCBjLmdldExvY2FsKFwicDFcIikpLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX2NvcHlcIiwgYy5nZXRMb2NhbChcInAxXCIpLCBjLmdldExvY2FsKFwicHJcIikpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLnJldChbXSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9pc09uZVwiLCB6KSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmMucmV0KGMuY2FsbChwcmVmaXggKyBcIl9kb3VibGVBZmZpbmVcIiwgYy5nZXRMb2NhbChcInAxXCIpLCBjLmdldExvY2FsKFwicHJcIikpKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5yZXQoW10pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3F1YXJlXCIsIHgsIEEpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3F1YXJlXCIsIHksIEIpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3F1YXJlXCIsIEIsIEMpLFxuXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgeCwgQiwgRCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zcXVhcmVcIiwgRCwgRCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgRCwgQSwgRCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgRCwgQywgRCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgRCwgRCwgRCksXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCBBLCBBLCBFKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCBFLCBBLCBFKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCBFLCBGKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIHksIHosIEcpLFxuXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgRCwgRCwgeDMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3ViXCIsIEYsIHgzLCB4MyksXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCBDLCBDLCBlaWdodEMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfYWRkXCIsIGVpZ2h0QywgZWlnaHRDLCBlaWdodEMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfYWRkXCIsIGVpZ2h0QywgZWlnaHRDLCBlaWdodEMpLFxuXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgRCwgeDMsIHkzKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB5MywgRSwgeTMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3ViXCIsIHkzLCBlaWdodEMsIHkzKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfYWRkXCIsIEcsIEcsIHozKSxcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRG91YmxlQWZmaW5lKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCArIFwiX2RvdWJsZUFmZmluZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4ID0gYy5nZXRMb2NhbChcInAxXCIpO1xuICAgICAgICBjb25zdCB5ID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwMVwiKSwgYy5pMzJfY29uc3QobjgpKTtcbiAgICAgICAgY29uc3QgeDMgPSBjLmdldExvY2FsKFwicHJcIik7XG4gICAgICAgIGNvbnN0IHkzID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSwgYy5pMzJfY29uc3QobjgpKTtcbiAgICAgICAgY29uc3QgejMgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChuOCoyKSk7XG5cbiAgICAgICAgY29uc3QgWFggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgWVkgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgWVlZWSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBTID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IE0gPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgZWlnaHRZWVlZID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfaXNaZXJvQWZmaW5lXCIsIGMuZ2V0TG9jYWwoXCJwMVwiKSksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4ICsgXCJfdG9KYWNvYmlhblwiLCBjLmdldExvY2FsKFwicDFcIiksIGMuZ2V0TG9jYWwoXCJwclwiKSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMucmV0KFtdKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIC8vIFhYID0gWDFeMlxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3F1YXJlXCIsIHgsIFhYKSxcblxuICAgICAgICAgICAgLy8gWVkgPSBZMV4yXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zcXVhcmVcIiwgeSwgWVkpLFxuXG4gICAgICAgICAgICAvLyBZWVlZID0gWVleMlxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3F1YXJlXCIsIFlZLCBZWVlZKSxcblxuICAgICAgICAgICAgLy8gUyA9IDIqKChYMStZWSleMi1YWC1ZWVlZKVxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfYWRkXCIsIHgsIFlZLCBTKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCBTLCBTKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3N1YlwiLCBTLCBYWCwgUyksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgUywgWVlZWSwgUyksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgUywgUywgUyksXG5cbiAgICAgICAgICAgIC8vIE0gPSAzKlhYK2EgIChIZXJhIGE9MClcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCBYWCwgWFgsIE0pLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfYWRkXCIsIE0sIFhYLCBNKSxcblxuICAgICAgICAgICAgLy8gWjMgPSAyKlkxXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgeSwgeSwgejMpLFxuXG4gICAgICAgICAgICAvLyBUID0gTV4yLTIqU1xuICAgICAgICAgICAgLy8gWDMgPSBUXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zcXVhcmVcIiwgTSwgeDMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3ViXCIsIHgzLCBTLCB4MyksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgeDMsIFMsIHgzKSxcblxuICAgICAgICAgICAgLy8gWTMgPSBNKihTLVQpLTgqWVlZWVxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfYWRkXCIsIFlZWVksIFlZWVksIGVpZ2h0WVlZWSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgZWlnaHRZWVlZLCBlaWdodFlZWVksIGVpZ2h0WVlZWSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgZWlnaHRZWVlZLCBlaWdodFlZWVksIGVpZ2h0WVlZWSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgUywgeDMsIHkzKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB5MywgTSwgeTMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3ViXCIsIHkzLCBlaWdodFlZWVksIHkzKSxcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRXFBZmZpbmUoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfZXFBZmZpbmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwMVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJ6MVwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMucmV0KGMuaTMyX2FuZChcbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeEZpZWxkICsgXCJfZXFcIixcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInAxXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicDJcIilcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4RmllbGQgKyBcIl9lcVwiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChuOCkpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAyXCIpLCBjLmkzMl9jb25zdChuOCkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFRvTW9udGdvbWVyeSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl90b01vbnRnb21lcnlcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwMVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInByXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChcbiAgICAgICAgICAgIHByZWZpeEZpZWxkICsgXCJfdG9Nb250Z29tZXJ5XCIsXG4gICAgICAgICAgICBjLmdldExvY2FsKFwicDFcIiksXG4gICAgICAgICAgICBjLmdldExvY2FsKFwicHJcIilcbiAgICAgICAgKSk7XG4gICAgICAgIGZvciAobGV0IGk9MTsgaTwzOyBpKyspIHtcbiAgICAgICAgICAgIGYuYWRkQ29kZShjLmNhbGwoXG4gICAgICAgICAgICAgICAgcHJlZml4RmllbGQgKyBcIl90b01vbnRnb21lcnlcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChpKm44KSksXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSwgYy5pMzJfY29uc3QoaSpuOCkpXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkVG9Nb250Z29tZXJ5QWZmaW5lKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCArIFwiX3RvTW9udGdvbWVyeUFmZmluZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKFxuICAgICAgICAgICAgcHJlZml4RmllbGQgKyBcIl90b01vbnRnb21lcnlcIixcbiAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwMVwiKSxcbiAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwclwiKVxuICAgICAgICApKTtcbiAgICAgICAgZm9yIChsZXQgaT0xOyBpPDI7IGkrKykge1xuICAgICAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChcbiAgICAgICAgICAgICAgICBwcmVmaXhGaWVsZCArIFwiX3RvTW9udGdvbWVyeVwiLFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChjLmdldExvY2FsKFwicDFcIiksIGMuaTMyX2NvbnN0KGkqbjgpKSxcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChpKm44KSlcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRGcm9tTW9udGdvbWVyeSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl9mcm9tTW9udGdvbWVyeVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKFxuICAgICAgICAgICAgcHJlZml4RmllbGQgKyBcIl9mcm9tTW9udGdvbWVyeVwiLFxuICAgICAgICAgICAgYy5nZXRMb2NhbChcInAxXCIpLFxuICAgICAgICAgICAgYy5nZXRMb2NhbChcInByXCIpXG4gICAgICAgICkpO1xuICAgICAgICBmb3IgKGxldCBpPTE7IGk8MzsgaSsrKSB7XG4gICAgICAgICAgICBmLmFkZENvZGUoYy5jYWxsKFxuICAgICAgICAgICAgICAgIHByZWZpeEZpZWxkICsgXCJfZnJvbU1vbnRnb21lcnlcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChpKm44KSksXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSwgYy5pMzJfY29uc3QoaSpuOCkpXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRGcm9tTW9udGdvbWVyeUFmZmluZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl9mcm9tTW9udGdvbWVyeUFmZmluZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKFxuICAgICAgICAgICAgcHJlZml4RmllbGQgKyBcIl9mcm9tTW9udGdvbWVyeVwiLFxuICAgICAgICAgICAgYy5nZXRMb2NhbChcInAxXCIpLFxuICAgICAgICAgICAgYy5nZXRMb2NhbChcInByXCIpXG4gICAgICAgICkpO1xuICAgICAgICBmb3IgKGxldCBpPTE7IGk8MjsgaSsrKSB7XG4gICAgICAgICAgICBmLmFkZENvZGUoYy5jYWxsKFxuICAgICAgICAgICAgICAgIHByZWZpeEZpZWxkICsgXCJfZnJvbU1vbnRnb21lcnlcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChpKm44KSksXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSwgYy5pMzJfY29uc3QoaSpuOCkpXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkQWRkKCkge1xuXG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfYWRkXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicDFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwMlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInByXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiejFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJ6MlwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgxID0gYy5nZXRMb2NhbChcInAxXCIpO1xuICAgICAgICBjb25zdCB5MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicDFcIiksIGMuaTMyX2NvbnN0KG44KSk7XG4gICAgICAgIGYuYWRkQ29kZShjLnNldExvY2FsKFwiejFcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwMVwiKSwgYy5pMzJfY29uc3QobjgqMikpKSk7XG4gICAgICAgIGNvbnN0IHoxID0gYy5nZXRMb2NhbChcInoxXCIpO1xuICAgICAgICBjb25zdCB4MiA9IGMuZ2V0TG9jYWwoXCJwMlwiKTtcbiAgICAgICAgY29uc3QgeTIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAyXCIpLCBjLmkzMl9jb25zdChuOCkpO1xuICAgICAgICBmLmFkZENvZGUoYy5zZXRMb2NhbChcInoyXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwicDJcIiksIGMuaTMyX2NvbnN0KG44KjIpKSkpO1xuICAgICAgICBjb25zdCB6MiA9IGMuZ2V0TG9jYWwoXCJ6MlwiKTtcbiAgICAgICAgY29uc3QgeDMgPSBjLmdldExvY2FsKFwicHJcIik7XG4gICAgICAgIGNvbnN0IHkzID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSwgYy5pMzJfY29uc3QobjgpKTtcbiAgICAgICAgY29uc3QgejMgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChuOCoyKSk7XG5cbiAgICAgICAgY29uc3QgWjFaMSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBaMloyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFUxID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFUyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFoxX2N1YmVkID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFoyX2N1YmVkID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFMxID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFMyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IEggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgUzJfbWludXNfUzEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgSSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBKID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IHIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgcjIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgViA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBWMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBTMV9KMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2lzWmVyb1wiLCBjLmdldExvY2FsKFwicDFcIikpLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX2NvcHlcIiwgYy5nZXRMb2NhbChcInAyXCIpLCBjLmdldExvY2FsKFwicHJcIikpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLnJldChbXSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfaXNaZXJvXCIsIGMuZ2V0TG9jYWwoXCJwMlwiKSksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4ICsgXCJfY29weVwiLCBjLmdldExvY2FsKFwicDFcIiksIGMuZ2V0TG9jYWwoXCJwclwiKSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMucmV0KFtdKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2lzT25lXCIsIHoxKSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXggKyBcIl9hZGRNaXhlZFwiLCB4MiwgeDEsIHgzKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5yZXQoW10pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfaXNPbmVcIiwgejIpLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX2FkZE1peGVkXCIsIHgxLCB4MiwgeDMpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLnJldChbXSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3F1YXJlXCIsIHoxLCBaMVoxKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCB6MiwgWjJaMiksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgeDEsIFoyWjIsIFUxKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB4MiwgWjFaMSwgVTIpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIHoxLCBaMVoxLCBaMV9jdWJlZCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgejIsIFoyWjIsIFoyX2N1YmVkKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB5MSwgWjJfY3ViZWQsIFMxKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB5MiwgWjFfY3ViZWQsIFMyKSxcblxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9lcVwiLCBVMSwgVTIpLFxuICAgICAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2VxXCIsIFMxLCBTMiksXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXggKyBcIl9kb3VibGVcIiwgYy5nZXRMb2NhbChcInAxXCIpLCBjLmdldExvY2FsKFwicHJcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5yZXQoW10pXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgVTIsIFUxLCBIKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3N1YlwiLCBTMiwgUzEsIFMyX21pbnVzX1MxKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCBILCBILCBJKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCBJLCBJKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCBILCBJLCBKKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCBTMl9taW51c19TMSwgUzJfbWludXNfUzEsIHIpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIFUxLCBJLCBWKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCByLCByMiksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgViwgViwgVjIpLFxuXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgcjIsIEosIHgzKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3N1YlwiLCB4MywgVjIsIHgzKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIFMxLCBKLCBTMV9KMiksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgUzFfSjIsIFMxX0oyLCBTMV9KMiksXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3N1YlwiLCBWLCB4MywgeTMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIHkzLCByLCB5MyksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgeTMsIFMxX0oyLCB5MyksXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCB6MSwgejIsIHozKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCB6MywgejMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3ViXCIsIHozLCBaMVoxLCB6MyksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgejMsIFoyWjIsIHozKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB6MywgSCwgejMpLFxuICAgICAgICApO1xuXG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZEFkZE1peGVkKCkge1xuXG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfYWRkTWl4ZWRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwMVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJ6MVwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgxID0gYy5nZXRMb2NhbChcInAxXCIpO1xuICAgICAgICBjb25zdCB5MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicDFcIiksIGMuaTMyX2NvbnN0KG44KSk7XG4gICAgICAgIGYuYWRkQ29kZShjLnNldExvY2FsKFwiejFcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwMVwiKSwgYy5pMzJfY29uc3QobjgqMikpKSk7XG4gICAgICAgIGNvbnN0IHoxID0gYy5nZXRMb2NhbChcInoxXCIpO1xuICAgICAgICBjb25zdCB4MiA9IGMuZ2V0TG9jYWwoXCJwMlwiKTtcbiAgICAgICAgY29uc3QgeTIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAyXCIpLCBjLmkzMl9jb25zdChuOCkpO1xuICAgICAgICBjb25zdCB4MyA9IGMuZ2V0TG9jYWwoXCJwclwiKTtcbiAgICAgICAgY29uc3QgeTMgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChuOCkpO1xuICAgICAgICBjb25zdCB6MyA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicHJcIiksIGMuaTMyX2NvbnN0KG44KjIpKTtcblxuICAgICAgICBjb25zdCBaMVoxID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFUyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFoxX2N1YmVkID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFMyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IEggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgSEggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgUzJfbWludXNfeTEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgSSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBKID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IHIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgcjIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgViA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBWMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCB5MV9KMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2lzWmVyb1wiLCBjLmdldExvY2FsKFwicDFcIikpLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX2NvcHlBZmZpbmVcIiwgYy5nZXRMb2NhbChcInAyXCIpLCBjLmdldExvY2FsKFwicHJcIikpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4RmllbGQgKyBcIl9vbmVcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSAsIGMuaTMyX2NvbnN0KG44KjIpKSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMucmV0KFtdKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9pc1plcm9BZmZpbmVcIiwgYy5nZXRMb2NhbChcInAyXCIpKSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXggKyBcIl9jb3B5XCIsIGMuZ2V0TG9jYWwoXCJwMVwiKSwgYy5nZXRMb2NhbChcInByXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5yZXQoW10pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfaXNPbmVcIiwgejEpLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX2FkZEFmZmluZVwiLCB4MSwgeDIsIHgzKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5yZXQoW10pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCB6MSwgWjFaMSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgeDIsIFoxWjEsIFUyKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB6MSwgWjFaMSwgWjFfY3ViZWQpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIHkyLCBaMV9jdWJlZCwgUzIpLFxuXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2VxXCIsIHgxLCBVMiksXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfZXFcIiwgeTEsIFMyKSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX2RvdWJsZUFmZmluZVwiLCBjLmdldExvY2FsKFwicDJcIiksIGMuZ2V0TG9jYWwoXCJwclwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnJldChbXSlcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3N1YlwiLCBVMiwgeDEsIEgpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3ViXCIsIFMyLCB5MSwgUzJfbWludXNfeTEpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3F1YXJlXCIsIEgsIEhIKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCBISCAsIEhILCBJKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCBJICwgSSwgSSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgSCwgSSwgSiksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgUzJfbWludXNfeTEsIFMyX21pbnVzX3kxLCByKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB4MSwgSSwgViksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zcXVhcmVcIiwgciwgcjIpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfYWRkXCIsIFYsIFYsIFYyKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3ViXCIsIHIyLCBKLCB4MyksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgeDMsIFYyLCB4MyksXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB5MSwgSiwgeTFfSjIpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfYWRkXCIsIHkxX0oyLCB5MV9KMiwgeTFfSjIpLFxuXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgViwgeDMsIHkzKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB5MywgciwgeTMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3ViXCIsIHkzLCB5MV9KMiwgeTMpLFxuXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgejEsIEgsIHozKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCB6MywgejMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3ViXCIsIHozLCBaMVoxLCB6MyksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgejMsIEhILCB6MyksXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZEFkZEFmZmluZSgpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCArIFwiX2FkZEFmZmluZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicDJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInoxXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeDEgPSBjLmdldExvY2FsKFwicDFcIik7XG4gICAgICAgIGNvbnN0IHkxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwMVwiKSwgYy5pMzJfY29uc3QobjgpKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuc2V0TG9jYWwoXCJ6MVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChuOCoyKSkpKTtcbiAgICAgICAgY29uc3QgeDIgPSBjLmdldExvY2FsKFwicDJcIik7XG4gICAgICAgIGNvbnN0IHkyID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwMlwiKSwgYy5pMzJfY29uc3QobjgpKTtcbiAgICAgICAgY29uc3QgeDMgPSBjLmdldExvY2FsKFwicHJcIik7XG4gICAgICAgIGNvbnN0IHkzID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSwgYy5pMzJfY29uc3QobjgpKTtcbiAgICAgICAgY29uc3QgejMgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChuOCoyKSk7XG5cbiAgICAgICAgY29uc3QgSCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBISCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCB5Ml9taW51c195MSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBJID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IEogPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgciA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCByMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBWID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFYyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IHkxX0oyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfaXNaZXJvQWZmaW5lXCIsIGMuZ2V0TG9jYWwoXCJwMVwiKSksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4ICsgXCJfY29weUFmZmluZVwiLCBjLmdldExvY2FsKFwicDJcIiksIGMuZ2V0TG9jYWwoXCJwclwiKSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXhGaWVsZCArIFwiX29uZVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpICwgYy5pMzJfY29uc3QobjgqMikpKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5yZXQoW10pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2lzWmVyb0FmZmluZVwiLCBjLmdldExvY2FsKFwicDJcIikpLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX2NvcHlBZmZpbmVcIiwgYy5nZXRMb2NhbChcInAxXCIpLCBjLmdldExvY2FsKFwicHJcIikpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4RmllbGQgKyBcIl9vbmVcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSAsIGMuaTMyX2NvbnN0KG44KjIpKSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMucmV0KFtdKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG5cblxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9lcVwiLCB4MSwgeDIpLFxuICAgICAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2VxXCIsIHkxLCB5MiksXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXggKyBcIl9kb3VibGVBZmZpbmVcIiwgYy5nZXRMb2NhbChcInAyXCIpLCBjLmdldExvY2FsKFwicHJcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5yZXQoW10pXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zdWJcIiwgeDIsIHgxLCBIKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3N1YlwiLCB5MiwgeTEsIHkyX21pbnVzX3kxKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCBILCBISCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgSEggLCBISCwgSSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgSSAsIEksIEkpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIEgsIEksIEopLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfYWRkXCIsIHkyX21pbnVzX3kxLCB5Ml9taW51c195MSwgciksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgeDEsIEksIFYpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3F1YXJlXCIsIHIsIHIyKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCBWLCBWLCBWMiksXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3N1YlwiLCByMiwgSiwgeDMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3ViXCIsIHgzLCBWMiwgeDMpLFxuXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgeTEsIEosIHkxX0oyKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCB5MV9KMiwgeTFfSjIsIHkxX0oyKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3ViXCIsIFYsIHgzLCB5MyksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgeTMsIHIsIHkzKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3N1YlwiLCB5MywgeTFfSjIsIHkzKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfYWRkXCIsIEgsIEgsIHozKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZE5lZygpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl9uZWdcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwMVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInByXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeCA9IGMuZ2V0TG9jYWwoXCJwMVwiKTtcbiAgICAgICAgY29uc3QgeSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicDFcIiksIGMuaTMyX2NvbnN0KG44KSk7XG4gICAgICAgIGNvbnN0IHogPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChuOCoyKSk7XG4gICAgICAgIGNvbnN0IHgzID0gYy5nZXRMb2NhbChcInByXCIpO1xuICAgICAgICBjb25zdCB5MyA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicHJcIiksIGMuaTMyX2NvbnN0KG44KSk7XG4gICAgICAgIGNvbnN0IHozID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSwgYy5pMzJfY29uc3QobjgqMikpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2NvcHlcIiwgeCwgeDMpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbmVnXCIsIHksIHkzKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2NvcHlcIiwgeiwgejMpXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZE5lZ0FmZmluZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl9uZWdBZmZpbmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwMVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInByXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeCA9IGMuZ2V0TG9jYWwoXCJwMVwiKTtcbiAgICAgICAgY29uc3QgeSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicDFcIiksIGMuaTMyX2NvbnN0KG44KSk7XG4gICAgICAgIGNvbnN0IHgzID0gYy5nZXRMb2NhbChcInByXCIpO1xuICAgICAgICBjb25zdCB5MyA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicHJcIiksIGMuaTMyX2NvbnN0KG44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfY29weVwiLCB4LCB4MyksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9uZWdcIiwgeSwgeTMpLFxuICAgICAgICApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRTdWIoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfc3ViXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicDFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwMlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInByXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgQVVYID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KjMpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfbmVnXCIsIGMuZ2V0TG9jYWwoXCJwMlwiKSwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9hZGRcIiwgYy5nZXRMb2NhbChcInAxXCIpLCBBVVgsIGMuZ2V0TG9jYWwoXCJwclwiKSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRTdWJNaXhlZCgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl9zdWJNaXhlZFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicDJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IEFVWCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCozKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX25lZ0FmZmluZVwiLCBjLmdldExvY2FsKFwicDJcIiksIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfYWRkTWl4ZWRcIiwgYy5nZXRMb2NhbChcInAxXCIpLCBBVVgsIGMuZ2V0TG9jYWwoXCJwclwiKSksXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZFN1YkFmZmluZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl9zdWJBZmZpbmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwMVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBBVVggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgqMykpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9uZWdBZmZpbmVcIiwgYy5nZXRMb2NhbChcInAyXCIpLCBBVVgpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2FkZEFmZmluZVwiLCBjLmdldExvY2FsKFwicDFcIiksIEFVWCwgYy5nZXRMb2NhbChcInByXCIpKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHNldHMgWiB0byBPbmVcbiAgICBmdW5jdGlvbiBidWlsZE5vcm1hbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl9ub3JtYWxpemVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwMVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInByXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgeCA9IGMuZ2V0TG9jYWwoXCJwMVwiKTtcbiAgICAgICAgY29uc3QgeSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicDFcIiksIGMuaTMyX2NvbnN0KG44KSk7XG4gICAgICAgIGNvbnN0IHogPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChuOCoyKSk7XG4gICAgICAgIGNvbnN0IHgzID0gYy5nZXRMb2NhbChcInByXCIpO1xuICAgICAgICBjb25zdCB5MyA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicHJcIiksIGMuaTMyX2NvbnN0KG44KSk7XG4gICAgICAgIGNvbnN0IHozID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSwgYy5pMzJfY29uc3QobjgqMikpO1xuXG5cbiAgICAgICAgY29uc3QgWl9pbnYgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgWjJfaW52ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFozX2ludiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2lzWmVyb1wiLCBjLmdldExvY2FsKFwicDFcIikpLFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl96ZXJvXCIsIGMuZ2V0TG9jYWwoXCJwclwiKSksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4RmllbGQgKyBcIl9pbnZlcnNlXCIsIHosIFpfaW52KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3F1YXJlXCIsIFpfaW52LCBaMl9pbnYpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgWl9pbnYsIFoyX2ludiwgWjNfaW52KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIHgsIFoyX2ludiwgeDMpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4RmllbGQgKyBcIl9tdWxcIiwgeSwgWjNfaW52LCB5MyksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXhGaWVsZCArIFwiX29uZVwiLCB6MyksXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuXG4gICAgLy8gRG9lcyBub3Qgc2V0IFouXG4gICAgZnVuY3Rpb24gYnVpbGRUb0FmZmluZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl90b0FmZmluZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4ID0gYy5nZXRMb2NhbChcInAxXCIpO1xuICAgICAgICBjb25zdCB5ID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwMVwiKSwgYy5pMzJfY29uc3QobjgpKTtcbiAgICAgICAgY29uc3QgeiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicDFcIiksIGMuaTMyX2NvbnN0KG44KjIpKTtcbiAgICAgICAgY29uc3QgeDMgPSBjLmdldExvY2FsKFwicHJcIik7XG4gICAgICAgIGNvbnN0IHkzID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSwgYy5pMzJfY29uc3QobjgpKTtcblxuXG4gICAgICAgIGNvbnN0IFpfaW52ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG4gICAgICAgIGNvbnN0IFoyX2ludiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuICAgICAgICBjb25zdCBaM19pbnYgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9pc1plcm9cIiwgYy5nZXRMb2NhbChcInAxXCIpKSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3plcm9cIiwgeDMpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4RmllbGQgKyBcIl96ZXJvXCIsIHkzKSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfaW52ZXJzZVwiLCB6LCBaX2ludiksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCBaX2ludiwgWjJfaW52KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIFpfaW52LCBaMl9pbnYsIFozX2ludiksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXhGaWVsZCArIFwiX211bFwiLCB4LCBaMl9pbnYsIHgzKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIHksIFozX2ludiwgeTMpLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkVG9KYWNvYmlhbigpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl90b0phY29iaWFuXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicDFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHggPSBjLmdldExvY2FsKFwicDFcIik7XG4gICAgICAgIGNvbnN0IHkgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChuOCkpO1xuICAgICAgICBjb25zdCB4MyA9IGMuZ2V0TG9jYWwoXCJwclwiKTtcbiAgICAgICAgY29uc3QgeTMgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChuOCkpO1xuICAgICAgICBjb25zdCB6MyA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicHJcIiksIGMuaTMyX2NvbnN0KG44KjIpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9pc1plcm9BZmZpbmVcIiwgYy5nZXRMb2NhbChcInAxXCIpKSxcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfemVyb1wiLCBjLmdldExvY2FsKFwicHJcIikpLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfb25lXCIsIHozKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfY29weVwiLCB5LCB5MyksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2NvcHlcIiwgeCwgeDMpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkQmF0Y2hUb0FmZmluZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl9iYXRjaFRvQWZmaW5lXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicEluXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiblwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBPdXRcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJwQXV4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaXRJblwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIml0QXV4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaXRPdXRcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgdG1wID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInBBdXhcIiwgYy5pMzJfbG9hZCggYy5pMzJfY29uc3QoMCkgKSksXG4gICAgICAgICAgICBjLmkzMl9zdG9yZShcbiAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgwKSxcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwQXV4XCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoYy5nZXRMb2NhbChcIm5cIiksIGMuaTMyX2NvbnN0KG44KSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgcHJlZml4RmllbGQgKyBcIl9iYXRjaEludmVyc2VcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBJblwiKSwgYy5pMzJfY29uc3QobjgqMikpLFxuICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44KjMpLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwQXV4XCIpLFxuICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44KVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0SW5cIiwgYy5nZXRMb2NhbChcInBJblwiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaXRBdXhcIiwgYy5nZXRMb2NhbChcInBBdXhcIikpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0T3V0XCIsIGMuZ2V0TG9jYWwoXCJwT3V0XCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoMSwgYy5pMzJfZXEgKCBjLmdldExvY2FsKFwiaVwiKSwgYy5nZXRMb2NhbChcIm5cIikgKSksXG5cbiAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9pc1plcm9cIiwgYy5nZXRMb2NhbChcIml0QXV4XCIpKSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfemVyb1wiLCBjLmdldExvY2FsKFwiaXRPdXRcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfemVyb1wiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0T3V0XCIpLCBjLmkzMl9jb25zdChuOCkpKVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4RmllbGQrXCJfbXVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0QXV4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRJblwiKSwgYy5pMzJfY29uc3QobjgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAsXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeEZpZWxkK1wiX3NxdWFyZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdEF1eFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXRBdXhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4RmllbGQrXCJfbXVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0QXV4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdEluXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdE91dFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4RmllbGQrXCJfbXVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0QXV4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0T3V0XCIpLCBjLmkzMl9jb25zdChuOCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaXRJblwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0SW5cIiksIGMuaTMyX2NvbnN0KG44KjMpKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0T3V0XCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRPdXRcIiksIGMuaTMyX2NvbnN0KG44KjIpKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0QXV4XCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRBdXhcIiksIGMuaTMyX2NvbnN0KG44KSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIGMuaTMyX3N0b3JlKFxuICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDApLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwQXV4XCIpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHByaXZhdGUgYW5kIGRvZXMgbm90IGFsbG93IHRvIE9WRVJMQVAgYnVmZmVycy5cbiAgICBmdW5jdGlvbiBidWlsZFJldmVyc2VCeXRlcygpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl9fcmV2ZXJzZUJ5dGVzXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicEluXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiblwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBPdXRcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpdE91dFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIml0SW5cIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgIFwiaXRPdXRcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9zdWIoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwT3V0XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5cIilcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICBcIml0SW5cIixcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEluXCIpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICAgICAgYy5icl9pZigxLCBjLmkzMl9sdF9zKCBjLmdldExvY2FsKFwiaXRPdXRcIiksIGMuZ2V0TG9jYWwoXCJwT3V0XCIpICkpLFxuICAgICAgICAgICAgICAgIGMuaTMyX3N0b3JlOChcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0T3V0XCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9sb2FkOF91KGMuZ2V0TG9jYWwoXCJpdEluXCIpKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdE91dFwiLCBjLmkzMl9zdWIoYy5nZXRMb2NhbChcIml0T3V0XCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdEluXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRJblwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKSxcbiAgICAgICAgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTEVNdG9DKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCArIFwiX0xFTXRvQ1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBJblwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBPdXRcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB0bXAgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9pc1plcm9BZmZpbmVcIiwgYy5nZXRMb2NhbChcInBJblwiKSksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4RmllbGQgKyBcIl96ZXJvXCIsIGMuZ2V0TG9jYWwoXCJwT3V0XCIpKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5pMzJfc3RvcmU4KFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBPdXRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgweDQwKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAuLi5jLnJldChbXSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfZnJvbU1vbnRnb21lcnlcIiwgYy5nZXRMb2NhbChcInBJblwiKSwgdG1wKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9fcmV2ZXJzZUJ5dGVzXCIsIHRtcCwgYy5pMzJfY29uc3QobjgpLCBjLmdldExvY2FsKFwicE91dFwiKSksXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zaWduXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwicEluXCIpLCBjLmkzMl9jb25zdChuOCkpKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoLTEpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmkzMl9zdG9yZTgoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwT3V0XCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9vcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2xvYWQ4X3UoYy5nZXRMb2NhbChcInBPdXRcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMHg4MClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRMRU10b1UoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfTEVNdG9VXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicEluXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicE91dFwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHBUbXAgPSBtb2R1bGUuYWxsb2MobjgqMik7XG4gICAgICAgIGNvbnN0IHRtcCA9IGMuaTMyX2NvbnN0KHBUbXApO1xuICAgICAgICBjb25zdCB0bXBYID0gYy5pMzJfY29uc3QocFRtcCk7XG4gICAgICAgIGNvbnN0IHRtcFkgPSBjLmkzMl9jb25zdChwVG1wICsgbjgpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2lzWmVyb0FmZmluZVwiLCBjLmdldExvY2FsKFwicEluXCIpKSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXggKyBcIl96ZXJvQWZmaW5lXCIsIGMuZ2V0TG9jYWwoXCJwT3V0XCIpKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5yZXQoW10pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2Zyb21Nb250Z29tZXJ5QWZmaW5lXCIsIGMuZ2V0TG9jYWwoXCJwSW5cIiksIHRtcCksXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9fcmV2ZXJzZUJ5dGVzXCIsIHRtcFgsIGMuaTMyX2NvbnN0KG44KSwgYy5nZXRMb2NhbChcInBPdXRcIikpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX19yZXZlcnNlQnl0ZXNcIiwgdG1wWSwgYy5pMzJfY29uc3QobjgpLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBPdXRcIiksIGMuaTMyX2NvbnN0KG44KSkpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkVXRvTEVNKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCArIFwiX1V0b0xFTVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBJblwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBPdXRcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBwVG1wID0gbW9kdWxlLmFsbG9jKG44KjIpO1xuICAgICAgICBjb25zdCB0bXAgPSBjLmkzMl9jb25zdChwVG1wKTtcbiAgICAgICAgY29uc3QgdG1wWCA9IGMuaTMyX2NvbnN0KHBUbXApO1xuICAgICAgICBjb25zdCB0bXBZID0gYy5pMzJfY29uc3QocFRtcCArIG44KTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuaTMyX2FuZChjLmkzMl9sb2FkOF91KGMuZ2V0TG9jYWwoXCJwSW5cIikpLCBjLmkzMl9jb25zdCgweDQwKSksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4ICsgXCJfemVyb0FmZmluZVwiLCBjLmdldExvY2FsKFwicE91dFwiKSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMucmV0KFtdKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX3JldmVyc2VCeXRlc1wiLCBjLmdldExvY2FsKFwicEluXCIpLCBjLmkzMl9jb25zdChuOCksIHRtcFgpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX19yZXZlcnNlQnl0ZXNcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwSW5cIiksIGMuaTMyX2NvbnN0KG44KSksIGMuaTMyX2NvbnN0KG44KSwgdG1wWSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfdG9Nb250Z29tZXJ5QWZmaW5lXCIsIHRtcCwgIGMuZ2V0TG9jYWwoXCJwT3V0XCIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkQ3RvTEVNKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCArIFwiX0N0b0xFTVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBJblwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBPdXRcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJmaXJzdEJ5dGVcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJncmVhdGVzdFwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHBUbXAgPSBtb2R1bGUuYWxsb2MobjgqMik7XG4gICAgICAgIGNvbnN0IHRtcFggPSBjLmkzMl9jb25zdChwVG1wKTtcbiAgICAgICAgY29uc3QgdG1wWSA9IGMuaTMyX2NvbnN0KHBUbXAgKyBuOCk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcImZpcnN0Qnl0ZVwiLCBjLmkzMl9sb2FkOF91KGMuZ2V0TG9jYWwoXCJwSW5cIikpKSxcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5pMzJfYW5kKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiZmlyc3RCeXRlXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgweDQwKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwocHJlZml4ICsgXCJfemVyb0FmZmluZVwiLCBjLmdldExvY2FsKFwicE91dFwiKSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMucmV0KFtdKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgIFwiZ3JlYXRlc3RcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hbmQoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJmaXJzdEJ5dGVcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDB4ODApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfY29weVwiLCBjLmdldExvY2FsKFwicEluXCIpLCB0bXBZKSxcbiAgICAgICAgICAgIGMuaTMyX3N0b3JlOCh0bXBZLCBjLmkzMl9hbmQoYy5nZXRMb2NhbChcImZpcnN0Qnl0ZVwiKSwgYy5pMzJfY29uc3QoMHgzRikpKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9fcmV2ZXJzZUJ5dGVzXCIsIHRtcFksIGMuaTMyX2NvbnN0KG44KSwgdG1wWCksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl90b01vbnRnb21lcnlcIiwgdG1wWCwgYy5nZXRMb2NhbChcInBPdXRcIikpLFxuXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9zcXVhcmVcIiwgYy5nZXRMb2NhbChcInBPdXRcIiksIHRtcFkpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIGMuZ2V0TG9jYWwoXCJwT3V0XCIpLCB0bXBZLCAgdG1wWSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9hZGRcIiwgdG1wWSwgYy5pMzJfY29uc3QocEIpLCAgdG1wWSksXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxcnRcIiwgdG1wWSwgdG1wWSksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9uZWdcIiwgdG1wWSwgdG1wWCksXG5cbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5pMzJfZXEoXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NpZ25cIiwgdG1wWSksXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KC0xKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImdyZWF0ZXN0XCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9jb3B5XCIsIHRtcFksIGMuaTMyX2FkZChjLmdldExvY2FsKFwicE91dFwiKSwgYy5pMzJfY29uc3QobjgpKSksXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX25lZ1wiLCB0bXBZLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBPdXRcIiksIGMuaTMyX2NvbnN0KG44KSkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiZ3JlYXRlc3RcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX25lZ1wiLCB0bXBZLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBPdXRcIiksIGMuaTMyX2NvbnN0KG44KSkpLFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4RmllbGQgKyBcIl9jb3B5XCIsIHRtcFksIGMuaTMyX2FkZChjLmdldExvY2FsKFwicE91dFwiKSwgYy5pMzJfY29uc3QobjgpKSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRJbkN1cnZlQWZmaW5lKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCArIFwiX2luQ3VydmVBZmZpbmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwSW5cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHggPSBjLmdldExvY2FsKFwicEluXCIpO1xuICAgICAgICBjb25zdCB5ID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwSW5cIiksIGMuaTMyX2NvbnN0KG44KSk7XG5cbiAgICAgICAgY29uc3QgeTIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcbiAgICAgICAgY29uc3QgeDNiID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfc3F1YXJlXCIsIHksIHkyKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3NxdWFyZVwiLCB4LCB4M2IpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfbXVsXCIsIHgsIHgzYiwgeDNiKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX2FkZFwiLCB4M2IsIGMuaTMyX2NvbnN0KHBCKSwgeDNiKSxcblxuICAgICAgICAgICAgYy5yZXQoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfZXFcIiwgeTIsIHgzYilcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEluQ3VydmUoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4ICsgXCJfaW5DdXJ2ZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBJblwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5zZXRSZXR1cm5UeXBlKFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgYXV4ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44KjIpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfdG9BZmZpbmVcIiwgYy5nZXRMb2NhbChcInBJblwiKSwgYXV4KSxcblxuICAgICAgICAgICAgYy5yZXQoXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2luQ3VydmVBZmZpbmVcIiwgYXV4KSxcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBidWlsZElzWmVyb0FmZmluZSgpO1xuICAgIGJ1aWxkSXNaZXJvKCk7XG4gICAgYnVpbGRaZXJvQWZmaW5lKCk7XG4gICAgYnVpbGRaZXJvKCk7XG4gICAgYnVpbGRDb3B5QWZmaW5lKCk7XG4gICAgYnVpbGRDb3B5KCk7XG4gICAgYnVpbGRUb0phY29iaWFuKCk7XG4gICAgYnVpbGRFcUFmZmluZSgpO1xuICAgIGJ1aWxkRXFNaXhlZCgpO1xuICAgIGJ1aWxkRXEoKTtcbiAgICBidWlsZERvdWJsZUFmZmluZSgpO1xuICAgIGJ1aWxkRG91YmxlKCk7XG4gICAgYnVpbGRBZGRBZmZpbmUoKTtcbiAgICBidWlsZEFkZE1peGVkKCk7XG4gICAgYnVpbGRBZGQoKTtcbiAgICBidWlsZE5lZ0FmZmluZSgpO1xuICAgIGJ1aWxkTmVnKCk7XG4gICAgYnVpbGRTdWJBZmZpbmUoKTtcbiAgICBidWlsZFN1Yk1peGVkKCk7XG4gICAgYnVpbGRTdWIoKTtcbiAgICBidWlsZEZyb21Nb250Z29tZXJ5QWZmaW5lKCk7XG4gICAgYnVpbGRGcm9tTW9udGdvbWVyeSgpO1xuICAgIGJ1aWxkVG9Nb250Z29tZXJ5QWZmaW5lKCk7XG4gICAgYnVpbGRUb01vbnRnb21lcnkoKTtcbiAgICBidWlsZFRvQWZmaW5lKCk7XG4gICAgYnVpbGRJbkN1cnZlQWZmaW5lKCk7XG4gICAgYnVpbGRJbkN1cnZlKCk7XG5cbiAgICBidWlsZEJhdGNoVG9BZmZpbmUoKTtcblxuICAgIGJ1aWxkTm9ybWFsaXplKCk7XG5cblxuICAgIGJ1aWxkUmV2ZXJzZUJ5dGVzKCk7XG5cbiAgICBidWlsZExFTXRvVSgpO1xuICAgIGJ1aWxkTEVNdG9DKCk7XG4gICAgYnVpbGRVdG9MRU0oKTtcbiAgICBidWlsZEN0b0xFTSgpO1xuXG4gICAgYnVpbGRCYXRjaENvbnZlcnRpb24obW9kdWxlLCBwcmVmaXggKyBcIl9iYXRjaExFTXRvVVwiLCBwcmVmaXggKyBcIl9MRU10b1VcIiwgbjgqMiwgbjgqMik7XG4gICAgYnVpbGRCYXRjaENvbnZlcnRpb24obW9kdWxlLCBwcmVmaXggKyBcIl9iYXRjaExFTXRvQ1wiLCBwcmVmaXggKyBcIl9MRU10b0NcIiwgbjgqMiwgbjgpO1xuICAgIGJ1aWxkQmF0Y2hDb252ZXJ0aW9uKG1vZHVsZSwgcHJlZml4ICsgXCJfYmF0Y2hVdG9MRU1cIiwgcHJlZml4ICsgXCJfVXRvTEVNXCIsIG44KjIsIG44KjIpO1xuICAgIGJ1aWxkQmF0Y2hDb252ZXJ0aW9uKG1vZHVsZSwgcHJlZml4ICsgXCJfYmF0Y2hDdG9MRU1cIiwgcHJlZml4ICsgXCJfQ3RvTEVNXCIsIG44LCBuOCoyLCB0cnVlKTtcblxuICAgIGJ1aWxkQmF0Y2hDb252ZXJ0aW9uKG1vZHVsZSwgcHJlZml4ICsgXCJfYmF0Y2hUb0phY29iaWFuXCIsIHByZWZpeCArIFwiX3RvSmFjb2JpYW5cIiwgbjgqMiwgbjgqMywgdHJ1ZSk7XG5cbiAgICBidWlsZE11bHRpZXhwJDEobW9kdWxlLCBwcmVmaXgsIHByZWZpeCArIFwiX211bHRpZXhwXCIsIHByZWZpeCArIFwiX2FkZFwiLCBuOCozKTtcbiAgICBidWlsZE11bHRpZXhwJDEobW9kdWxlLCBwcmVmaXgsIHByZWZpeCArIFwiX211bHRpZXhwQWZmaW5lXCIsIHByZWZpeCArIFwiX2FkZE1peGVkXCIsIG44KjIpO1xuXG4gICAgLypcbiAgICBidWlsZFRpbWVzU2NhbGFyKFxuICAgICAgICBtb2R1bGUsXG4gICAgICAgIHByZWZpeCArIFwiX3RpbWVzU2NhbGFyT2xkXCIsXG4gICAgICAgIG44KjMsXG4gICAgICAgIHByZWZpeCArIFwiX2FkZFwiLFxuICAgICAgICBwcmVmaXggKyBcIl9kb3VibGVcIixcbiAgICAgICAgcHJlZml4ICsgXCJfY29weVwiLFxuICAgICAgICBwcmVmaXggKyBcIl96ZXJvXCIsXG4gICAgKTtcbiAgICAqL1xuICAgIGJ1aWxkVGltZXNTY2FsYXJOQUYoXG4gICAgICAgIG1vZHVsZSxcbiAgICAgICAgcHJlZml4ICsgXCJfdGltZXNTY2FsYXJcIixcbiAgICAgICAgbjgqMyxcbiAgICAgICAgcHJlZml4ICsgXCJfYWRkXCIsXG4gICAgICAgIHByZWZpeCArIFwiX2RvdWJsZVwiLFxuICAgICAgICBwcmVmaXggKyBcIl9zdWJcIixcbiAgICAgICAgcHJlZml4ICsgXCJfY29weVwiLFxuICAgICAgICBwcmVmaXggKyBcIl96ZXJvXCJcbiAgICApO1xuXG4gICAgYnVpbGRUaW1lc1NjYWxhck5BRihcbiAgICAgICAgbW9kdWxlLFxuICAgICAgICBwcmVmaXggKyBcIl90aW1lc1NjYWxhckFmZmluZVwiLFxuICAgICAgICBuOCoyLFxuICAgICAgICBwcmVmaXggKyBcIl9hZGRNaXhlZFwiLFxuICAgICAgICBwcmVmaXggKyBcIl9kb3VibGVcIixcbiAgICAgICAgcHJlZml4ICsgXCJfc3ViTWl4ZWRcIixcbiAgICAgICAgcHJlZml4ICsgXCJfY29weUFmZmluZVwiLFxuICAgICAgICBwcmVmaXggKyBcIl96ZXJvXCJcbiAgICApO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2lzWmVyb1wiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfaXNaZXJvQWZmaW5lXCIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2VxXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9lcU1peGVkXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9lcUFmZmluZVwiKTtcblxuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9jb3B5XCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9jb3B5QWZmaW5lXCIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3plcm9cIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3plcm9BZmZpbmVcIik7XG5cbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfZG91YmxlXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9kb3VibGVBZmZpbmVcIik7XG5cbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfYWRkXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9hZGRNaXhlZFwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfYWRkQWZmaW5lXCIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX25lZ1wiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfbmVnQWZmaW5lXCIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3N1YlwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfc3ViTWl4ZWRcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3N1YkFmZmluZVwiKTtcblxuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9mcm9tTW9udGdvbWVyeVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfZnJvbU1vbnRnb21lcnlBZmZpbmVcIik7XG5cbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfdG9Nb250Z29tZXJ5XCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl90b01vbnRnb21lcnlBZmZpbmVcIik7XG5cbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfdGltZXNTY2FsYXJcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3RpbWVzU2NhbGFyQWZmaW5lXCIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX25vcm1hbGl6ZVwiKTtcblxuICAgIC8vIENvbnZlcnRpb24gZnVuY3Rpb25zXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX0xFTXRvVVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfTEVNdG9DXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9VdG9MRU1cIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX0N0b0xFTVwiKTtcblxuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9iYXRjaExFTXRvVVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfYmF0Y2hMRU10b0NcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2JhdGNoVXRvTEVNXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9iYXRjaEN0b0xFTVwiKTtcblxuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl90b0FmZmluZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfdG9KYWNvYmlhblwiKTtcblxuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9iYXRjaFRvQWZmaW5lXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9iYXRjaFRvSmFjb2JpYW5cIik7XG5cbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfaW5DdXJ2ZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfaW5DdXJ2ZUFmZmluZVwiKTtcblxuICAgIC8qXG4gICAgYnVpbGRHMU11bFNjYWxhcihtb2R1bGUsIHpxKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24oXCJnMU11bFNjYWxhclwiKTtcbiAgICAqL1xuXG4gICAgcmV0dXJuIHByZWZpeDtcbn07XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTkgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3YXNtc25hcmsgKFdlYiBBc3NlbWJseSB6a1NuYXJrIFByb3ZlcikuXG5cbiAgICB3YXNtc25hcmsgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3YXNtc25hcmsgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2FzbXNuYXJrLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuY29uc3QgeyBpc09kZDogaXNPZGQkMiwgbW9kSW52OiBtb2RJbnYkMSwgbW9kUG93IH0gPSBiaWdpbnQ7XG5jb25zdCB1dGlscyQzID0gdXRpbHMkNjtcblxudmFyIGJ1aWxkX2ZmdCA9IGZ1bmN0aW9uIGJ1aWxkRkZUKG1vZHVsZSwgcHJlZml4LCBnUHJlZml4LCBmUHJlZml4LCBvcEd0aW1lc0YpIHtcblxuICAgIGNvbnN0IG42NGYgPSBtb2R1bGUubW9kdWxlc1tmUHJlZml4XS5uNjQ7XG4gICAgY29uc3QgbjhmID0gbjY0Zio4O1xuXG4gICAgY29uc3QgbjY0ZyA9IG1vZHVsZS5tb2R1bGVzW2dQcmVmaXhdLm42NDtcbiAgICBjb25zdCBuOGcgPSBuNjRnKjg7XG5cbiAgICBjb25zdCBxID0gbW9kdWxlLm1vZHVsZXNbZlByZWZpeF0ucTtcblxuICAgIGxldCByZW0gPSBxIC0gMW47XG4gICAgbGV0IG1heEJpdHMgPSAwO1xuICAgIHdoaWxlICghaXNPZGQkMihyZW0pKSB7XG4gICAgICAgIG1heEJpdHMgKys7XG4gICAgICAgIHJlbSA9IHJlbSA+PiAxbjtcbiAgICB9XG5cbiAgICBsZXQgbnIgPSAybjtcblxuICAgIHdoaWxlICggbW9kUG93KG5yLCBxID4+IDFuLCBxKSA9PT0gMW4gKSBuciA9IG5yICsgMW47XG5cbiAgICAvLyBjb25zb2xlLmxvZyhucik7XG5cbiAgICBjb25zdCB3ID0gbmV3IEFycmF5KG1heEJpdHMrMSk7XG4gICAgd1ttYXhCaXRzXSA9IG1vZFBvdyhuciwgcmVtLCBxKTtcblxuICAgIGxldCBuPW1heEJpdHMtMTtcbiAgICB3aGlsZSAobj49MCkge1xuICAgICAgICB3W25dID0gbW9kUG93KHdbbisxXSwgMm4sIHEpO1xuICAgICAgICBuLS07XG4gICAgfVxuXG4gICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICBjb25zdCBSID0gKDFuIDw8IEJpZ0ludChuOGYqOCkpICUgcTtcblxuICAgIGZvciAobGV0IGk9MDsgaTx3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG0gPSB3W2ldICogUiAlIHE7XG4gICAgICAgIGJ5dGVzLnB1c2goLi4udXRpbHMkMy5iaWdJbnQyQnl0ZXNMRShtLCBuOGYpKTtcbiAgICB9XG5cbiAgICBjb25zdCBST09UcyA9IG1vZHVsZS5hbGxvYyhieXRlcyk7XG5cbiAgICBjb25zdCBpMiA9IG5ldyBBcnJheShtYXhCaXRzKzEpO1xuICAgIGkyWzBdID0gMW47XG5cbiAgICBmb3IgKGxldCBpPTE7IGk8PW1heEJpdHM7IGkrKykge1xuICAgICAgICBpMltpXSA9IGkyW2ktMV0gKiAybjtcbiAgICB9XG5cbiAgICBjb25zdCBieXRlc2kyID1bXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8PW1heEJpdHM7IGkrKykge1xuICAgICAgICBjb25zdCBtID0gbW9kSW52JDEoaTJbaV0sIHEpICogUiAlIHE7XG4gICAgICAgIGJ5dGVzaTIucHVzaCguLi51dGlscyQzLmJpZ0ludDJCeXRlc0xFKG0sIG44ZikpO1xuICAgIH1cblxuICAgIGNvbnN0IElOVjIgPSBtb2R1bGUuYWxsb2MoYnl0ZXNpMik7XG5cbiAgICBjb25zdCBzaGlmdCA9IG1vZFBvdyhuciwgMm4sIHEpO1xuICAgIGNvbnN0IGJ5dGVzU2hpZnRUb1NtYWxsTSA9W107XG4gICAgY29uc3QgYnl0ZXNTQ29uc3QgPVtdO1xuICAgIGZvciAobGV0IGk9MDsgaTw9bWF4Qml0czsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0VG9TbWFsbE0gPSBtb2RQb3coc2hpZnQsIDJuICoqIEJpZ0ludChpKSwgcSk7XG4gICAgICAgIGNvbnN0IHNDb25zdCA9IG1vZEludiQxKHEgKyAxbiAtIHNoaWZ0VG9TbWFsbE0sIHEpO1xuICAgICAgICBieXRlc1NoaWZ0VG9TbWFsbE0ucHVzaCguLi51dGlscyQzLmJpZ0ludDJCeXRlc0xFKHNoaWZ0VG9TbWFsbE0gKiBSICUgcSwgbjhmKSk7XG4gICAgICAgIGJ5dGVzU0NvbnN0LnB1c2goLi4udXRpbHMkMy5iaWdJbnQyQnl0ZXNMRShzQ29uc3QgKiBSICUgcSwgbjhmKSk7XG4gICAgfVxuXG4gICAgY29uc3QgU0hJRlRfVE9fTSA9IG1vZHVsZS5hbGxvYyggYnl0ZXNTaGlmdFRvU21hbGxNICApO1xuICAgIGNvbnN0IFNDT05TVCA9IG1vZHVsZS5hbGxvYyggYnl0ZXNTQ29uc3QgICk7XG5cbiAgICBmdW5jdGlvbiByZXYoeCkge1xuICAgICAgICBsZXQgcj0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoeCAmICgxIDw8IGkpKSB7XG4gICAgICAgICAgICAgICAgciA9IHIgfCAoMHg4MCA+PiBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBjb25zdCBydGFibGUgPSBBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGk9MDsgaTwyNTY7IGkrKykge1xuICAgICAgICBydGFibGVbaV0gPSByZXYoaSk7XG4gICAgfVxuXG4gICAgY29uc3QgUkVWVEFCTEUgPSBtb2R1bGUuYWxsb2MocnRhYmxlKTtcblxuXG4gICAgZnVuY3Rpb24gYnVpbGRMb2cyKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9fbG9nMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcIm5cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImJpdHNcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJhdXhcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgIFwiYXV4XCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuc2V0TG9jYWwoXCJiaXRzXCIsIGMuaTMyX2NvbnN0KDApKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgYy5icl9pZihcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgIGMuaTMyX2VxeihjLmdldExvY2FsKFwiYXV4XCIpKVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICBcImF1eFwiLFxuICAgICAgICAgICAgICAgIGMuaTMyX3Nocl91KFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiYXV4XCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgXCJiaXRzXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiYml0c1wiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICkpKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5pZihcbiAgICAgICAgICAgIGMuaTMyX25lKFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpLFxuICAgICAgICAgICAgICAgIGMuaTMyX3NobChcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJiaXRzXCIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMudW5yZWFjaGFibGUoKVxuICAgICAgICApKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5pZihcbiAgICAgICAgICAgIGMuaTMyX2d0X3UoXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImJpdHNcIiksXG4gICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobWF4Qml0cylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLnVucmVhY2hhYmxlKClcbiAgICAgICAgKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuZ2V0TG9jYWwoXCJiaXRzXCIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEZGVCgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfZmZ0XCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJuXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGYuYWRkTG9jYWwoXCJiaXRzXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgT25lID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44ZikpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgXCJiaXRzXCIsXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggKyBcIl9fbG9nMlwiLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiblwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmNhbGwoZlByZWZpeCArIFwiX29uZVwiLCBPbmUpLFxuICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgIHByZWZpeCtcIl9yYXdmZnRcIixcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHhcIiksXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImJpdHNcIiksXG4gICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMCksXG4gICAgICAgICAgICAgICAgT25lXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZElGRlQoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2lmZnRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJweFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcIm5cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJiaXRzXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwicEludjJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgIFwiYml0c1wiLFxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ICsgXCJfX2xvZzJcIixcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5cIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICBcInBJbnYyXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChJTlYyKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImJpdHNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGYpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgcHJlZml4K1wiX3Jhd2ZmdFwiLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJweFwiKSxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiYml0c1wiKSxcbiAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKSxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEludjJcIilcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRSYXdGRlQoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX3Jhd2ZmdFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInB4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiYml0c1wiLCBcImkzMlwiKTsgLy8gMiBwb3dlclxuICAgICAgICBmLmFkZFBhcmFtKFwicmV2ZXJzZVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcIm11bEZhY3RvclwiLCBcImkzMlwiKTtcblxuICAgICAgICBmLmFkZExvY2FsKFwic1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImtcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJqXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwibVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIm1kaXYyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiblwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInB3bVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImlkeDFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpZHgyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgVyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOGYpKTtcbiAgICAgICAgY29uc3QgVCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOGcpKTtcbiAgICAgICAgY29uc3QgVSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOGcpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX3JldmVyc2VQZXJtdXRhdGlvblwiLCBjLmdldExvY2FsKFwicHhcIiksIGMuZ2V0TG9jYWwoXCJiaXRzXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJuXCIsIGMuaTMyX3NobChjLmkzMl9jb25zdCgxKSwgYy5nZXRMb2NhbChcImJpdHNcIikpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJzXCIsIGMuaTMyX2NvbnN0KDEpKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2d0X3UoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJiaXRzXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJtXCIsIGMuaTMyX3NobChjLmkzMl9jb25zdCgxKSwgYy5nZXRMb2NhbChcInNcIikpKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwicHdtXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KFJPT1RzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwic1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGYpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJrXCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICAgICAgYy5icl9pZihcbiAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9nZV91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJrXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKGZQcmVmaXggKyBcIl9vbmVcIiwgVyksXG5cbiAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIm1kaXYyXCIsIGMuaTMyX3Nocl91KGMuZ2V0TG9jYWwoXCJtXCIpLCBjLmkzMl9jb25zdCgxKSkgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImpcIiwgYy5pMzJfY29uc3QoMCkpLFxuICAgICAgICAgICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9nZV91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwialwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm1kaXYyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkeDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJrXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJqXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjhnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkeDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgxXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwibWRpdjJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BHdGltZXNGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdQcmVmaXggKyBcIl9jb3B5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDFcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdQcmVmaXggKyBcIl9hZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDFcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ1ByZWZpeCArIFwiX3N1YlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmUHJlZml4ICsgXCJfbXVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHdtXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFcsXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwialwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcImpcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICAgICAgICAgICkpLFxuXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJrXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwia1wiKSwgYy5nZXRMb2NhbChcIm1cIikpKSxcbiAgICAgICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgICAgICkpLFxuXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcInNcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJzXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgIHByZWZpeCArIFwiX19mZnRGaW5hbFwiLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJweFwiKSxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiYml0c1wiKSxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicmV2ZXJzZVwiKSxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwibXVsRmFjdG9yXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZEZpbmFsSW52ZXJzZSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfX2ZmdEZpbmFsXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJiaXRzXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicmV2ZXJzZVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcIm11bEZhY3RvclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIm5cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJuZGl2MlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInBJbnYyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIm1hc2tcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpZHgxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaWR4MlwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IFQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjhnKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmkzMl9hbmQoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxeihjLmdldExvY2FsKFwicmV2ZXJzZVwiKSksXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChmUHJlZml4ICsgXCJfaXNPbmVcIiwgYy5nZXRMb2NhbChcIm11bEZhY3RvclwiKSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMucmV0KFtdKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJuXCIsIGMuaTMyX3NobCggYy5pMzJfY29uc3QoMSksIGMuZ2V0TG9jYWwoXCJiaXRzXCIpKSksXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJtYXNrXCIsIGMuaTMyX3N1YiggYy5nZXRMb2NhbChcIm5cIikgLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfY29uc3QoMSkpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICBcIm5kaXYyXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICBjLmJyX2lmKFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9nZV91KFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwibmRpdjJcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaWR4MVwiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjhnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpZHgyXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjhnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJyZXZlcnNlXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jYWxsKGZQcmVmaXggKyBcIl9pc09uZVwiLCBjLmdldExvY2FsKFwibXVsRmFjdG9yXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwoZ1ByZWZpeCArIFwiX2NvcHlcIiwgYy5nZXRMb2NhbChcImlkeDFcIiksIFQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChnUHJlZml4ICsgXCJfY29weVwiLCBjLmdldExvY2FsKFwiaWR4MlwiKSAsIGMuZ2V0TG9jYWwoXCJpZHgxXCIpICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKGdQcmVmaXggKyBcIl9jb3B5XCIsIFQgLCBjLmdldExvY2FsKFwiaWR4MlwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChnUHJlZml4ICsgXCJfY29weVwiLCBjLmdldExvY2FsKFwiaWR4MVwiKSwgVCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKG9wR3RpbWVzRiAsIGMuZ2V0TG9jYWwoXCJpZHgyXCIpICwgYy5nZXRMb2NhbChcIm11bEZhY3RvclwiKSwgYy5nZXRMb2NhbChcImlkeDFcIikgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwob3BHdGltZXNGICwgVCAsIGMuZ2V0TG9jYWwoXCJtdWxGYWN0b3JcIiksIGMuZ2V0TG9jYWwoXCJpZHgyXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FsbChmUHJlZml4ICsgXCJfaXNPbmVcIiwgYy5nZXRMb2NhbChcIm11bEZhY3RvclwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZyAoSXQgc2hvdWxkIG5vdCBiZSBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwob3BHdGltZXNGICwgYy5nZXRMb2NhbChcImlkeDFcIikgLCBjLmdldExvY2FsKFwibXVsRmFjdG9yXCIpLCBjLmdldExvY2FsKFwiaWR4MVwiKSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChvcEd0aW1lc0YgLCBjLmdldExvY2FsKFwiaWR4MlwiKSAsIGMuZ2V0TG9jYWwoXCJtdWxGYWN0b3JcIiksIGMuZ2V0TG9jYWwoXCJpZHgyXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSksXG5cbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKGZQcmVmaXggKyBcIl9pc09uZVwiLCBjLmdldExvY2FsKFwibXVsRmFjdG9yXCIpKSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgKEl0IHNob3VsZCBub3QgYmUgaGVyZSlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKG9wR3RpbWVzRiwgYy5nZXRMb2NhbChcInB4XCIpICwgYy5nZXRMb2NhbChcIm11bEZhY3RvclwiKSwgYy5nZXRMb2NhbChcInB4XCIpKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcImlkeDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwibmRpdjJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44ZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChvcEd0aW1lc0YsIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLGMuZ2V0TG9jYWwoXCJtdWxGYWN0b3JcIiksIGMuZ2V0TG9jYWwoXCJpZHgyXCIpKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFJldmVyc2VQZXJtdXRhdGlvbigpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfX3JldmVyc2VQZXJtdXRhdGlvblwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInB4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiYml0c1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIm5cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwicmlcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpZHgxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaWR4MlwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IFQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjhnKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIm5cIiwgYy5pMzJfc2hsKCBjLmkzMl9jb25zdCgxKSwgYy5nZXRMb2NhbChcImJpdHNcIikpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiblwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpZHgxXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGcpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcInJpXCIsIGMuY2FsbChwcmVmaXggKyBcIl9fcmV2XCIsIGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmdldExvY2FsKFwiYml0c1wiKSkpLFxuXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImlkeDJcIixcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInB4XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJyaVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGcpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbHRfdShcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInJpXCIpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChnUHJlZml4ICsgXCJfY29weVwiLCBjLmdldExvY2FsKFwiaWR4MVwiKSwgVCksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwoZ1ByZWZpeCArIFwiX2NvcHlcIiwgYy5nZXRMb2NhbChcImlkeDJcIikgLCBjLmdldExvY2FsKFwiaWR4MVwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwoZ1ByZWZpeCArIFwiX2NvcHlcIiwgVCAsIGMuZ2V0TG9jYWwoXCJpZHgyXCIpKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QoMSkpKSxcblxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRSZXYoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX19yZXZcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiYml0c1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5zZXRSZXR1cm5UeXBlKFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pMzJfcm90bChcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX3NobChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9sb2FkOF91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9hbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwieFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDB4RkYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJFVlRBQkxFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgyNClcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9zaGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbG9hZDhfdShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfYW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoOClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgweEZGKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRVZUQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9zaGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbG9hZDhfdShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfYW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfc2hyX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMHhGRilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUkVWVEFCTEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDgpXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbG9hZDhfdShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9hbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX3Nocl91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgyNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMHhGRilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJFVlRBQkxFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJiaXRzXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZEZGVEpvaW4oKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2ZmdEpvaW5cIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQnVmZjFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQnVmZjJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJuXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiZmlyc3RcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJpbmNcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpZHgxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaWR4MlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImlcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBXID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44ZikpO1xuICAgICAgICBjb25zdCBUID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44ZykpO1xuICAgICAgICBjb25zdCBVID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44ZykpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbCggZlByZWZpeCArIFwiX2NvcHlcIiwgYy5nZXRMb2NhbChcImZpcnN0XCIpLCBXKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiblwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwiaWR4MVwiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEJ1ZmYxXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44ZylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgICAgICBcImlkeDJcIixcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBCdWZmMlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGcpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBvcEd0aW1lc0YsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLFxuICAgICAgICAgICAgICAgICAgICBXLFxuICAgICAgICAgICAgICAgICAgICBUXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgZ1ByZWZpeCArIFwiX2NvcHlcIixcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDFcIiksXG4gICAgICAgICAgICAgICAgICAgIFVcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBnUHJlZml4ICsgXCJfYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIFUsXG4gICAgICAgICAgICAgICAgICAgIFQsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgxXCIpLFxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIGdQcmVmaXggKyBcIl9zdWJcIixcbiAgICAgICAgICAgICAgICAgICAgVSxcbiAgICAgICAgICAgICAgICAgICAgVCxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDJcIiksXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgZlByZWZpeCArIFwiX211bFwiLFxuICAgICAgICAgICAgICAgICAgICBXLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaW5jXCIpLFxuICAgICAgICAgICAgICAgICAgICBXLFxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcImlcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRkZUSm9pbkV4dCgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfZmZ0Sm9pbkV4dFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBCdWZmMVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBCdWZmMlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcIm5cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJmaXJzdFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcImluY1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInRvdGFsQml0c1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImlkeDFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpZHgyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInBTaGlmdFRvTVwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IFcgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjhmKSk7XG4gICAgICAgIGNvbnN0IFUgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjhnKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuXG4gICAgICAgICAgICBjLnNldExvY2FsKFwicFNoaWZ0VG9NXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChTSElGVF9UT19NKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInRvdGFsQml0c1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44ZilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG5cblxuICAgICAgICAgICAgYy5jYWxsKCBmUHJlZml4ICsgXCJfY29weVwiLCBjLmdldExvY2FsKFwiZmlyc3RcIiksIFcpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfY29uc3QoMCkpLFxuICAgICAgICAgICAgYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICAgICAgYy5icl9pZihcbiAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfZXEoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICAgICAgXCJpZHgxXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwQnVmZjFcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjhnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwiaWR4MlwiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEJ1ZmYyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44ZylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIGdQcmVmaXggKyBcIl9hZGRcIixcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDFcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLFxuICAgICAgICAgICAgICAgICAgICBVXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgb3BHdGltZXNGLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MlwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBTaGlmdFRvTVwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDJcIilcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBnUHJlZml4ICsgXCJfYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgxXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MlwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDJcIilcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBvcEd0aW1lc0YsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLFxuICAgICAgICAgICAgICAgICAgICBXLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MlwiKSxcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBnUHJlZml4ICsgXCJfY29weVwiLFxuICAgICAgICAgICAgICAgICAgICBVLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MVwiKVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIGZQcmVmaXggKyBcIl9tdWxcIixcbiAgICAgICAgICAgICAgICAgICAgVyxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImluY1wiKSxcbiAgICAgICAgICAgICAgICAgICAgV1xuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcImlcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEZGVEpvaW5FeHRJbnYoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4K1wiX2ZmdEpvaW5FeHRJbnZcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQnVmZjFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQnVmZjJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJuXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiZmlyc3RcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJpbmNcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ0b3RhbEJpdHNcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpZHgxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaWR4MlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImlcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJwU2hpZnRUb01cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJwU0NvbnN0XCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgVyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOGYpKTtcbiAgICAgICAgY29uc3QgVSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOGcpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwU2hpZnRUb01cIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KFNISUZUX1RPX00pLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwidG90YWxCaXRzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjhmKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwU0NvbnN0XCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChTQ09OU1QpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwidG90YWxCaXRzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjhmKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcblxuXG4gICAgICAgICAgICBjLmNhbGwoIGZQcmVmaXggKyBcIl9jb3B5XCIsIGMuZ2V0TG9jYWwoXCJmaXJzdFwiKSwgVyksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICBjLmJyX2lmKFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9lcShcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5cIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgICAgICBcImlkeDFcIixcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBCdWZmMVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGcpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICAgICAgXCJpZHgyXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwQnVmZjJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjhnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgb3BHdGltZXNGLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MlwiKSxcbiAgICAgICAgICAgICAgICAgICAgVyxcbiAgICAgICAgICAgICAgICAgICAgVVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIGdQcmVmaXggKyBcIl9zdWJcIixcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDFcIiksXG4gICAgICAgICAgICAgICAgICAgIFUsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLFxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIG9wR3RpbWVzRixcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDJcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwU0NvbnN0XCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MlwiKVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIG9wR3RpbWVzRixcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDFcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwU2hpZnRUb01cIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgxXCIpXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgZ1ByZWZpeCArIFwiX3N1YlwiLFxuICAgICAgICAgICAgICAgICAgICBVLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MVwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDFcIilcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBvcEd0aW1lc0YsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgxXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicFNDb25zdFwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDFcIilcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBmUHJlZml4ICsgXCJfbXVsXCIsXG4gICAgICAgICAgICAgICAgICAgIFcsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpbmNcIiksXG4gICAgICAgICAgICAgICAgICAgIFdcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpXG4gICAgICAgICk7XG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkUHJlcGFyZUxhZ3JhbmdlRXZhbHVhdGlvbigpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfcHJlcGFyZUxhZ3JhbmdlRXZhbHVhdGlvblwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBCdWZmMVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBCdWZmMlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcIm5cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJmaXJzdFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcImluY1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInRvdGFsQml0c1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImlkeDFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpZHgyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInBTaGlmdFRvTVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInBTQ29uc3RcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBXID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44ZikpO1xuICAgICAgICBjb25zdCBVID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKG44ZykpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcblxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInBTaGlmdFRvTVwiLFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoU0hJRlRfVE9fTSksXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJ0b3RhbEJpdHNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGYpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInBTQ29uc3RcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KFNDT05TVCksXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJ0b3RhbEJpdHNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGYpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG5cbiAgICAgICAgICAgIGMuY2FsbCggZlByZWZpeCArIFwiX2NvcHlcIiwgYy5nZXRMb2NhbChcImZpcnN0XCIpLCBXKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiblwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwiaWR4MVwiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEJ1ZmYxXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44ZylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgICAgICBcImlkeDJcIixcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBCdWZmMlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGcpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIG9wR3RpbWVzRixcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDFcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwU2hpZnRUb01cIiksXG4gICAgICAgICAgICAgICAgICAgIFVcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBnUHJlZml4ICsgXCJfc3ViXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLFxuICAgICAgICAgICAgICAgICAgICBVLFxuICAgICAgICAgICAgICAgICAgICBVXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgZ1ByZWZpeCArIFwiX3N1YlwiLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MVwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDJcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLFxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIG9wR3RpbWVzRixcbiAgICAgICAgICAgICAgICAgICAgVSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBTQ29uc3RcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgxXCIpLFxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIG9wR3RpbWVzRixcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDJcIiksXG4gICAgICAgICAgICAgICAgICAgIFcsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLFxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIGZQcmVmaXggKyBcIl9tdWxcIixcbiAgICAgICAgICAgICAgICAgICAgVyxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImluY1wiKSxcbiAgICAgICAgICAgICAgICAgICAgV1xuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcImlcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEZGVE1peCgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfZmZ0TWl4XCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicEJ1ZmZcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJuXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiZXhwXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwibkdyb3Vwc1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIm5QZXJHcm91cFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIm5QZXJHcm91cERpdjJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJwYWlyT2Zmc2V0XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaWR4MVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImlkeDJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwialwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInB3bVwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IFcgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjhmKSk7XG4gICAgICAgIGNvbnN0IFQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjhnKSk7XG4gICAgICAgIGNvbnN0IFUgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjhnKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIm5QZXJHcm91cFwiLCBjLmkzMl9zaGwoYy5pMzJfY29uc3QoMSksIGMuZ2V0TG9jYWwoXCJleHBcIikpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJuUGVyR3JvdXBEaXYyXCIsIGMuaTMyX3Nocl91KGMuZ2V0TG9jYWwoXCJuUGVyR3JvdXBcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwibkdyb3Vwc1wiLCBjLmkzMl9zaHJfdShjLmdldExvY2FsKFwiblwiKSwgYy5nZXRMb2NhbChcImV4cFwiKSkpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInBhaXJPZmZzZXRcIiwgYy5pMzJfbXVsKGMuZ2V0TG9jYWwoXCJuUGVyR3JvdXBEaXYyXCIpLCBjLmkzMl9jb25zdChuOGcpKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwicHdtXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChST09UcyksXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJleHBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGYpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfY29uc3QoMCkpLFxuICAgICAgICAgICAgYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICAgICAgYy5icl9pZihcbiAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfZXEoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuR3JvdXBzXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuY2FsbCggZlByZWZpeCArIFwiX29uZVwiLCBXKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwialwiLCBjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICAgICAgYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfZXEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImpcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5QZXJHcm91cERpdjJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJpZHgxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBCdWZmXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuUGVyR3JvdXBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwialwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImlkeDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicGFpck9mZnNldFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wR3RpbWVzRixcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgVyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRcbiAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICBnUHJlZml4ICsgXCJfY29weVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDFcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBVXG4gICAgICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgZ1ByZWZpeCArIFwiX2FkZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgVSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MVwiKSxcbiAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICBnUHJlZml4ICsgXCJfc3ViXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBVLFxuICAgICAgICAgICAgICAgICAgICAgICAgVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLFxuICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgIGZQcmVmaXggKyBcIl9tdWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHdtXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgVyxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImpcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJqXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICAvLyBSZXZlcnNlIGFsbCBhbmQgbXVsdGlwbHkgYnkgZmFjdG9yXG4gICAgZnVuY3Rpb24gYnVpbGRGRlRGaW5hbCgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfZmZ0RmluYWxcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQnVmZlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcIm5cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJmYWN0b3JcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpZHgxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaWR4MlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImlcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJuZGl2MlwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IFQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjhnKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIm5kaXYyXCIsIGMuaTMyX3Nocl91KGMuZ2V0TG9jYWwoXCJuXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmkzMl9hbmQoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBvcEd0aW1lc0YsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwQnVmZlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwibmRpdjJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjhnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiZmFjdG9yXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEJ1ZmZcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5kaXYyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44ZylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2dlX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuZGl2MlwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwiaWR4MVwiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEJ1ZmZcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjhnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwiaWR4MlwiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEJ1ZmZcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfc3ViKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOGcpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBvcEd0aW1lc0YsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpZHgyXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiZmFjdG9yXCIpLFxuICAgICAgICAgICAgICAgICAgICBUXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgb3BHdGltZXNGLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaWR4MVwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImZhY3RvclwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDJcIiksXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgZ1ByZWZpeCArIFwiX2NvcHlcIixcbiAgICAgICAgICAgICAgICAgICAgVCxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlkeDFcIiksXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGJ1aWxkUmV2KCk7XG4gICAgYnVpbGRSZXZlcnNlUGVybXV0YXRpb24oKTtcbiAgICBidWlsZEZpbmFsSW52ZXJzZSgpO1xuICAgIGJ1aWxkUmF3RkZUKCk7XG4gICAgYnVpbGRMb2cyKCk7XG4gICAgYnVpbGRGRlQoKTtcbiAgICBidWlsZElGRlQoKTtcbiAgICBidWlsZEZGVEpvaW4oKTtcbiAgICBidWlsZEZGVEpvaW5FeHQoKTtcbiAgICBidWlsZEZGVEpvaW5FeHRJbnYoKTtcbiAgICBidWlsZEZGVE1peCgpO1xuICAgIGJ1aWxkRkZURmluYWwoKTtcbiAgICBidWlsZFByZXBhcmVMYWdyYW5nZUV2YWx1YXRpb24oKTtcblxuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXgrXCJfZmZ0XCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXgrXCJfaWZmdFwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4K1wiX3Jhd2ZmdFwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4K1wiX2ZmdEpvaW5cIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCtcIl9mZnRKb2luRXh0XCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXgrXCJfZmZ0Sm9pbkV4dEludlwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4K1wiX2ZmdE1peFwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4K1wiX2ZmdEZpbmFsXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXgrXCJfcHJlcGFyZUxhZ3JhbmdlRXZhbHVhdGlvblwiKTtcblxufTtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21zbmFyayAoV2ViIEFzc2VtYmx5IHprU25hcmsgUHJvdmVyKS5cblxuICAgIHdhc21zbmFyayBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21zbmFyayBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtc25hcmsuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG52YXIgYnVpbGRfcG9sID0gZnVuY3Rpb24gYnVpbGRQb2wobW9kdWxlLCBwcmVmaXgsIHByZWZpeEZpZWxkKSB7XG5cbiAgICBjb25zdCBuNjQgPSBtb2R1bGUubW9kdWxlc1twcmVmaXhGaWVsZF0ubjY0O1xuICAgIGNvbnN0IG44ID0gbjY0Kjg7XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkWmVybygpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrXCJfemVyb1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInB4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiblwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImxhc3RwXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwicFwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwXCIsIGMuZ2V0TG9jYWwoXCJweFwiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgIFwibGFzdHBcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJweFwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICBjLmJyX2lmKFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9lcShcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImxhc3RwXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3plcm9cIiwgYy5nZXRMb2NhbChcInBcIikpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwicFwiKSwgYy5pMzJfY29uc3QobjgpKSksXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZENvbnN0cnVjdExDKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9jb25zdHJ1Y3RMQ1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBwb2x5bm9taWFsc1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBzaWduYWxzXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiblNpZ25hbHNcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwcmVzXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImpcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJwcFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInBzXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwicGRcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJuY29lZnNcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBhdXggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwicHBcIiwgYy5nZXRMb2NhbChcInBwb2x5bm9taWFsc1wiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwicHNcIiwgYy5nZXRMb2NhbChcInBzaWduYWxzXCIpKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiblNpZ25hbHNcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwibmNvZWZzXCIsIGMuaTMyX2xvYWQoYy5nZXRMb2NhbChcInBwXCIpKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcInBwXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwicHBcIiksIGMuaTMyX2NvbnN0KDQpKSksXG5cbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwialwiLCBjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICAgICAgYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfZXEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImpcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5jb2Vmc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInByZXNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9sb2FkKGMuZ2V0TG9jYWwoXCJwcFwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwicHBcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwcFwiKSwgYy5pMzJfY29uc3QoNCkpKSxcblxuXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeEZpZWxkICsgXCJfbXVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXhcbiAgICAgICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXhGaWVsZCArIFwiX2FkZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBkXCIpXG4gICAgICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcInBwXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwicHBcIiksIGMuaTMyX2NvbnN0KG44KSkpLFxuICAgICAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwialwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcImpcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICAgICApKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwc1wiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBzXCIpLCBjLmkzMl9jb25zdChuOCkpKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcImlcIiksIGMuaTMyX2NvbnN0KDEpKSksXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKTtcblxuICAgIH1cblxuICAgIGJ1aWxkWmVybygpO1xuICAgIGJ1aWxkQ29uc3RydWN0TEMoKTtcblxuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3plcm9cIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2NvbnN0cnVjdExDXCIpO1xuXG4gICAgcmV0dXJuIHByZWZpeDtcblxuXG5cblxufTtcblxudmFyIGJ1aWxkX3FhcCA9IGZ1bmN0aW9uIGJ1aWxkUUFQKG1vZHVsZSwgcHJlZml4LCBwcmVmaXhGaWVsZCkge1xuXG4gICAgY29uc3QgbjY0ID0gbW9kdWxlLm1vZHVsZXNbcHJlZml4RmllbGRdLm42NDtcbiAgICBjb25zdCBuOCA9IG42NCo4O1xuXG5cbiAgICBmdW5jdGlvbiBidWlsZEJ1aWxkQUJDKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9idWlsZEFCQ1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBDb2Vmc1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcIm5Db2Vmc1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBXaXRuZXNzXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicEFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBDXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwib2Zmc2V0T3V0XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwibk91dFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcIm9mZnNldFdpdG5lc3NcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJuV2l0bmVzc1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIml0XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaXRhXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaXRiXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwibGFzdFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcIm1cIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJjXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwic1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInBPdXRcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBhdXggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG5cbiAgICAgICAgICAgIC8vIFNldCBvdXRwdXQgYSBhbmQgYiB0byAwXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaXRhXCIsIGMuZ2V0TG9jYWwoXCJwQVwiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaXRiXCIsIGMuZ2V0TG9jYWwoXCJwQlwiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgIFwibGFzdFwiLFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBBXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwibk91dFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0YVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJsYXN0XCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXhGaWVsZCArIFwiX3plcm9cIiwgYy5nZXRMb2NhbChcIml0YVwiKSksXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeEZpZWxkICsgXCJfemVyb1wiLCBjLmdldExvY2FsKFwiaXRiXCIpKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaXRhXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRhXCIpLCBjLmkzMl9jb25zdChuOCkpKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaXRiXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRiXCIpLCBjLmkzMl9jb25zdChuOCkpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKSxcblxuXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaXRcIiwgYy5nZXRMb2NhbChcInBDb2Vmc1wiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgIFwibGFzdFwiLFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBDb2Vmc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5Db2Vmc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44KzEyKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoXG4gICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIml0XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImxhc3RcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICAgICAgXCJzXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2xvYWQoYy5nZXRMb2NhbChcIml0XCIpLCA4KVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9sdF91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJvZmZzZXRXaXRuZXNzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2dlX3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwib2Zmc2V0V2l0bmVzc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5XaXRuZXNzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5zZXRMb2NhbChcIml0XCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRcIiksIGMuaTMyX2NvbnN0KG44KzEyKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5icigxKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKSxcblxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwibVwiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9sb2FkKGMuZ2V0TG9jYWwoXCJpdFwiKSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKGMuZ2V0TG9jYWwoXCJtXCIpLCBjLmkzMl9jb25zdCgwKSksXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwT3V0XCIsIGMuZ2V0TG9jYWwoXCJwQVwiKSksXG4gICAgICAgICAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9lcShjLmdldExvY2FsKFwibVwiKSwgYy5pMzJfY29uc3QoMSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcInBPdXRcIiwgYy5nZXRMb2NhbChcInBCXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwiaXRcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpdFwiKSwgYy5pMzJfY29uc3QobjgrMTIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5icigxKVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFxuICAgICAgICAgICAgICAgICAgICBcImNcIixcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbG9hZChjLmdldExvY2FsKFwiaXRcIiksIDQpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9vcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2x0X3UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm9mZnNldE91dFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9nZV91KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJjXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm9mZnNldE91dFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5PdXRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwiaXRcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpdFwiKSwgYy5pMzJfY29uc3QobjgrMTIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLmJyKDEpXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgICAgIFwicE91dFwiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicE91dFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJjXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwib2Zmc2V0T3V0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXhGaWVsZCArIFwiX211bFwiLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicFdpdG5lc3NcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9tdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJzXCIpLCBjLmdldExvY2FsKFwib2Zmc2V0V2l0bmVzc1wiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjgpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2FkZCggYy5nZXRMb2NhbChcIml0XCIpLCBjLmkzMl9jb25zdCgxMikpLFxuICAgICAgICAgICAgICAgICAgICBhdXhcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4RmllbGQgKyBcIl9hZGRcIixcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBPdXRcIiksXG4gICAgICAgICAgICAgICAgICAgIGF1eCxcbiAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBPdXRcIiksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaXRcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJpdFwiKSwgYy5pMzJfY29uc3QobjgrMTIpKSksXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSksXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdGFcIiwgYy5nZXRMb2NhbChcInBBXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdGJcIiwgYy5nZXRMb2NhbChcInBCXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdFwiLCBjLmdldExvY2FsKFwicENcIikpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICBcImxhc3RcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwQVwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5PdXRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICBjLmJyX2lmKFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9lcShcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdGFcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwibGFzdFwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeEZpZWxkICsgXCJfbXVsXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdGFcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdGJcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdFwiKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0YVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0YVwiKSwgYy5pMzJfY29uc3QobjgpKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0YlwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0YlwiKSwgYy5pMzJfY29uc3QobjgpKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0XCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRcIiksIGMuaTMyX2NvbnN0KG44KSkpLFxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpLFxuXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRKb2luQUJDKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9qb2luQUJDXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicEFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBDXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiblwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBQXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaXRhXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaXRiXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaXRjXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaXRwXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwibGFzdFwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IGF1eCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOCkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdGFcIiwgYy5nZXRMb2NhbChcInBBXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdGJcIiwgYy5nZXRMb2NhbChcInBCXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdGNcIiwgYy5nZXRMb2NhbChcInBDXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpdHBcIiwgYy5nZXRMb2NhbChcInBQXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXG4gICAgICAgICAgICAgICAgXCJsYXN0XCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEFcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX211bChcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QobjgpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5ibG9jayhjLmxvb3AoXG4gICAgICAgICAgICAgICAgYy5icl9pZihcbiAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfZXEoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXRhXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImxhc3RcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXhGaWVsZCArIFwiX211bFwiLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXRhXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXRiXCIpLFxuICAgICAgICAgICAgICAgICAgICBhdXhcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4RmllbGQgKyBcIl9zdWJcIixcbiAgICAgICAgICAgICAgICAgICAgYXV4LFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXRjXCIpLFxuICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiaXRwXCIpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0YVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0YVwiKSwgYy5pMzJfY29uc3QobjgpKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0YlwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0YlwiKSwgYy5pMzJfY29uc3QobjgpKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0Y1wiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0Y1wiKSwgYy5pMzJfY29uc3QobjgpKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0cFwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIml0cFwiKSwgYy5pMzJfY29uc3QobjgpKSksXG4gICAgICAgICAgICAgICAgYy5icigwKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEJhdGNoQWRkKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCtcIl9iYXRjaEFkZFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBhXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicGJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJuXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpdGFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpdGJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJpdHJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJsYXN0XCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0YVwiLCBjLmdldExvY2FsKFwicGFcIikpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0YlwiLCBjLmdldExvY2FsKFwicGJcIikpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcIml0clwiLCBjLmdldExvY2FsKFwicHJcIikpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcbiAgICAgICAgICAgICAgICBcImxhc3RcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwYVwiKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbXVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcIm5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdChuOClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICBjLmJyX2lmKFxuICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9lcShcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdGFcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwibGFzdFwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeEZpZWxkICsgXCJfYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdGFcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdGJcIiksXG4gICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJpdHJcIiksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaXRhXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRhXCIpLCBjLmkzMl9jb25zdChuOCkpKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaXRiXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRiXCIpLCBjLmkzMl9jb25zdChuOCkpKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwiaXRyXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaXRyXCIpLCBjLmkzMl9jb25zdChuOCkpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGJ1aWxkQnVpbGRBQkMoKTtcbiAgICBidWlsZEpvaW5BQkMoKTtcbiAgICBidWlsZEJhdGNoQWRkKCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfYnVpbGRBQkNcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2pvaW5BQkNcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2JhdGNoQWRkXCIpO1xuXG4gICAgcmV0dXJuIHByZWZpeDtcblxufTtcblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21zbmFyayAoV2ViIEFzc2VtYmx5IHprU25hcmsgUHJvdmVyKS5cblxuICAgIHdhc21zbmFyayBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21zbmFyayBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtc25hcmsuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG52YXIgYnVpbGRfYXBwbHlrZXkgPSBmdW5jdGlvbiBidWlsZEFwcGx5S2V5KG1vZHVsZSwgZm5OYW1lLCBnUHJlZml4LCBmclByZWZpeCwgc2l6ZUdJbiwgc2l6ZUdPdXQsIHNpemVGLCBvcEd0aW1lc0YpIHtcblxuICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24oZm5OYW1lKTtcbiAgICBmLmFkZFBhcmFtKFwicEluXCIsIFwiaTMyXCIpO1xuICAgIGYuYWRkUGFyYW0oXCJuXCIsIFwiaTMyXCIpO1xuICAgIGYuYWRkUGFyYW0oXCJwRmlyc3RcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRQYXJhbShcInBJbmNcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRQYXJhbShcInBPdXRcIiwgXCJpMzJcIik7XG4gICAgZi5hZGRMb2NhbChcInBPbGRGcmVlXCIsIFwiaTMyXCIpO1xuICAgIGYuYWRkTG9jYWwoXCJpXCIsIFwiaTMyXCIpO1xuICAgIGYuYWRkTG9jYWwoXCJwRnJvbVwiLCBcImkzMlwiKTtcbiAgICBmLmFkZExvY2FsKFwicFRvXCIsIFwiaTMyXCIpO1xuXG4gICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgIGNvbnN0IHQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2Moc2l6ZUYpKTtcblxuICAgIGYuYWRkQ29kZShcbiAgICAgICAgYy5zZXRMb2NhbChcInBGcm9tXCIsIGMuZ2V0TG9jYWwoXCJwSW5cIikpLFxuICAgICAgICBjLnNldExvY2FsKFwicFRvXCIsIGMuZ2V0TG9jYWwoXCJwT3V0XCIpKSxcbiAgICApO1xuXG4gICAgLy8gdCA9IGZpcnN0XG4gICAgZi5hZGRDb2RlKFxuICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICBmclByZWZpeCArIFwiX2NvcHlcIixcbiAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwRmlyc3RcIiksXG4gICAgICAgICAgICB0XG4gICAgICAgIClcbiAgICApO1xuICAgIGYuYWRkQ29kZShcbiAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfY29uc3QoMCkpLFxuICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgIGMuYnJfaWYoMSwgYy5pMzJfZXEgKCBjLmdldExvY2FsKFwiaVwiKSwgYy5nZXRMb2NhbChcIm5cIikgKSksXG5cbiAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICBvcEd0aW1lc0YsXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBGcm9tXCIpLFxuICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBUb1wiKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwRnJvbVwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBGcm9tXCIpLCBjLmkzMl9jb25zdChzaXplR0luKSkpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInBUb1wiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBUb1wiKSwgYy5pMzJfY29uc3Qoc2l6ZUdPdXQpKSksXG5cbiAgICAgICAgICAgIC8vIHQgPSB0KiBpbmNcbiAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICBmclByZWZpeCArIFwiX211bFwiLFxuICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInBJbmNcIiksXG4gICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgKSlcbiAgICApO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKGZuTmFtZSk7XG5cbn07XG5cbmNvbnN0IHV0aWxzJDIgPSB1dGlscyQ2O1xuXG5jb25zdCBidWlsZEYxbSQxID1idWlsZF9mMW07XG5jb25zdCBidWlsZEYxJDEgPWJ1aWxkX2YxO1xuY29uc3QgYnVpbGRGMm0kMSA9YnVpbGRfZjJtO1xuY29uc3QgYnVpbGRGM20kMSA9YnVpbGRfZjNtO1xuY29uc3QgYnVpbGRDdXJ2ZSQxID1idWlsZF9jdXJ2ZV9qYWNvYmlhbl9hMDtcbmNvbnN0IGJ1aWxkRkZUJDIgPSBidWlsZF9mZnQ7XG5jb25zdCBidWlsZFBvbCQxID0gYnVpbGRfcG9sO1xuY29uc3QgYnVpbGRRQVAkMSA9IGJ1aWxkX3FhcDtcbmNvbnN0IGJ1aWxkQXBwbHlLZXkkMSA9IGJ1aWxkX2FwcGx5a2V5O1xuY29uc3QgeyBiaXRMZW5ndGg6IGJpdExlbmd0aCQyLCBtb2RJbnYsIGlzT2RkOiBpc09kZCQxLCBpc05lZ2F0aXZlOiBpc05lZ2F0aXZlJDIgfSA9IGJpZ2ludDtcblxudmFyIGJ1aWxkX2JuMTI4ID0gZnVuY3Rpb24gYnVpbGRCTjEyOChtb2R1bGUsIF9wcmVmaXgpIHtcblxuICAgIGNvbnN0IHByZWZpeCA9IF9wcmVmaXggfHwgXCJibjEyOFwiO1xuXG4gICAgaWYgKG1vZHVsZS5tb2R1bGVzW3ByZWZpeF0pIHJldHVybiBwcmVmaXg7ICAvLyBhbHJlYWR5IGJ1aWxkZWRcblxuICAgIGNvbnN0IHEgPSAyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODY5NjMxMTE1NzI5NzgyMzY2MjY4OTAzNzg5NDY0NTIyNjIwODU4M247XG4gICAgY29uc3QgciA9IDIxODg4MjQyODcxODM5Mjc1MjIyMjQ2NDA1NzQ1MjU3Mjc1MDg4NTQ4MzY0NDAwNDE2MDM0MzQzNjk4MjA0MTg2NTc1ODA4NDk1NjE3bjtcblxuXG4gICAgY29uc3QgbjY0ID0gTWF0aC5mbG9vcigoYml0TGVuZ3RoJDIocSAtIDFuKSAtIDEpLzY0KSArMTtcbiAgICBjb25zdCBuOCA9IG42NCo4O1xuICAgIGNvbnN0IGZyc2l6ZSA9IG44O1xuICAgIGNvbnN0IGYxc2l6ZSA9IG44O1xuICAgIGNvbnN0IGYyc2l6ZSA9IGYxc2l6ZSAqIDI7XG4gICAgY29uc3QgZnRzaXplID0gZjFzaXplICogMTI7XG5cbiAgICBjb25zdCBwciA9IG1vZHVsZS5hbGxvYyh1dGlscyQyLmJpZ0ludDJCeXRlc0xFKCByLCBmcnNpemUgKSk7XG5cbiAgICBjb25zdCBmMW1QcmVmaXggPSBidWlsZEYxbSQxKG1vZHVsZSwgcSwgXCJmMW1cIik7XG4gICAgYnVpbGRGMSQxKG1vZHVsZSwgciwgXCJmclwiLCBcImZybVwiKTtcblxuICAgIGNvbnN0IHBHMWIgPSBtb2R1bGUuYWxsb2ModXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDNuKSwgZjFzaXplICkpO1xuICAgIGNvbnN0IGcxbVByZWZpeCA9IGJ1aWxkQ3VydmUkMShtb2R1bGUsIFwiZzFtXCIsIFwiZjFtXCIsIHBHMWIpO1xuXG4gICAgYnVpbGRGRlQkMihtb2R1bGUsIFwiZnJtXCIsIFwiZnJtXCIsIFwiZnJtXCIsIFwiZnJtX211bFwiKTtcblxuICAgIGJ1aWxkUG9sJDEobW9kdWxlLCBcInBvbFwiLCBcImZybVwiKTtcbiAgICBidWlsZFFBUCQxKG1vZHVsZSwgXCJxYXBcIiwgXCJmcm1cIik7XG5cbiAgICBjb25zdCBmMm1QcmVmaXggPSBidWlsZEYybSQxKG1vZHVsZSwgXCJmMW1fbmVnXCIsIFwiZjJtXCIsIFwiZjFtXCIpO1xuICAgIGNvbnN0IHBHMmIgPSBtb2R1bGUuYWxsb2MoW1xuICAgICAgICAuLi51dGlscyQyLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoMTk0ODU4NzQ3NTE3NTkzNTQ3NzEwMjQyMzkyNjEwMjE3MjA1MDU3OTA2MTg0NjkzMDE3MjEwNjU1NjQ2MzEyOTY0NTI0NTc0NzgzNzNuKSwgZjFzaXplICksXG4gICAgICAgIC4uLnV0aWxzJDIuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeSgyNjY5Mjk3OTExMTk5OTExNjEyNDY5MDczODcxMzcyODM4NDI1NDUwNzY5NjUzMzI5MDAyODg1NjkzNzg1MTA5MTAzMDc2MzY2OTBuKSwgZjFzaXplIClcbiAgICBdKTtcbiAgICBjb25zdCBnMm1QcmVmaXggPSBidWlsZEN1cnZlJDEobW9kdWxlLCBcImcybVwiLCBcImYybVwiLCBwRzJiKTtcblxuXG4gICAgZnVuY3Rpb24gYnVpbGRHVGltZXNGcihmbk5hbWUsIG9wTXVsKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24oZm5OYW1lKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBHXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicEZyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBBVVggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MobjgpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoXCJmcm1fZnJvbU1vbnRnb21lcnlcIiwgYy5nZXRMb2NhbChcInBGclwiKSwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICBvcE11bCxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEdcIiksXG4gICAgICAgICAgICAgICAgQVVYLFxuICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44KSxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicHJcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24oZm5OYW1lKTtcbiAgICB9XG4gICAgYnVpbGRHVGltZXNGcihcImcxbV90aW1lc0ZyXCIsIFwiZzFtX3RpbWVzU2NhbGFyXCIpO1xuICAgIGJ1aWxkRkZUJDIobW9kdWxlLCBcImcxbVwiLCBcImcxbVwiLCBcImZybVwiLCBcImcxbV90aW1lc0ZyXCIpO1xuXG4gICAgYnVpbGRHVGltZXNGcihcImcybV90aW1lc0ZyXCIsIFwiZzJtX3RpbWVzU2NhbGFyXCIpO1xuICAgIGJ1aWxkRkZUJDIobW9kdWxlLCBcImcybVwiLCBcImcybVwiLCBcImZybVwiLCBcImcybV90aW1lc0ZyXCIpO1xuXG4gICAgYnVpbGRHVGltZXNGcihcImcxbV90aW1lc0ZyQWZmaW5lXCIsIFwiZzFtX3RpbWVzU2NhbGFyQWZmaW5lXCIpO1xuICAgIGJ1aWxkR1RpbWVzRnIoXCJnMm1fdGltZXNGckFmZmluZVwiLCBcImcybV90aW1lc1NjYWxhckFmZmluZVwiKTtcblxuICAgIGJ1aWxkQXBwbHlLZXkkMShtb2R1bGUsIFwiZnJtX2JhdGNoQXBwbHlLZXlcIiwgXCJmbXJcIiwgXCJmcm1cIiwgbjgsIG44LCBuOCwgXCJmcm1fbXVsXCIpO1xuICAgIGJ1aWxkQXBwbHlLZXkkMShtb2R1bGUsIFwiZzFtX2JhdGNoQXBwbHlLZXlcIiwgXCJnMW1cIiwgXCJmcm1cIiwgbjgqMywgbjgqMywgbjgsIFwiZzFtX3RpbWVzRnJcIik7XG4gICAgYnVpbGRBcHBseUtleSQxKG1vZHVsZSwgXCJnMW1fYmF0Y2hBcHBseUtleU1peGVkXCIsIFwiZzFtXCIsIFwiZnJtXCIsIG44KjIsIG44KjMsIG44LCBcImcxbV90aW1lc0ZyQWZmaW5lXCIpO1xuICAgIGJ1aWxkQXBwbHlLZXkkMShtb2R1bGUsIFwiZzJtX2JhdGNoQXBwbHlLZXlcIiwgXCJnMm1cIiwgXCJmcm1cIiwgbjgqMiozLCBuOCozKjIsIG44LCBcImcybV90aW1lc0ZyXCIpO1xuICAgIGJ1aWxkQXBwbHlLZXkkMShtb2R1bGUsIFwiZzJtX2JhdGNoQXBwbHlLZXlNaXhlZFwiLCBcImcybVwiLCBcImZybVwiLCBuOCoyKjIsIG44KjMqMiwgbjgsIFwiZzJtX3RpbWVzRnJBZmZpbmVcIik7XG5cbiAgICBmdW5jdGlvbiB0b01vbnRnb21lcnkoYSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KGEpICogKCAxbiA8PCBCaWdJbnQoZjFzaXplKjgpKSAlIHE7XG4gICAgfVxuXG4gICAgY29uc3QgRzFnZW4gPSBbXG4gICAgICAgIDFuLFxuICAgICAgICAybixcbiAgICAgICAgMW5cbiAgICBdO1xuXG4gICAgY29uc3QgcEcxZ2VuID0gbW9kdWxlLmFsbG9jKFxuICAgICAgICBbXG4gICAgICAgICAgICAuLi51dGlscyQyLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoRzFnZW5bMF0pLCBmMXNpemUgKSxcbiAgICAgICAgICAgIC4uLnV0aWxzJDIuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeShHMWdlblsxXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcxZ2VuWzJdKSwgZjFzaXplICksXG4gICAgICAgIF1cbiAgICApO1xuXG4gICAgY29uc3QgRzF6ZXJvID0gW1xuICAgICAgICAwbixcbiAgICAgICAgMW4sXG4gICAgICAgIDBuXG4gICAgXTtcblxuICAgIGNvbnN0IHBHMXplcm8gPSBtb2R1bGUuYWxsb2MoXG4gICAgICAgIFtcbiAgICAgICAgICAgIC4uLnV0aWxzJDIuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeShHMXplcm9bMF0pLCBmMXNpemUgKSxcbiAgICAgICAgICAgIC4uLnV0aWxzJDIuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeShHMXplcm9bMV0pLCBmMXNpemUgKSxcbiAgICAgICAgICAgIC4uLnV0aWxzJDIuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeShHMXplcm9bMl0pLCBmMXNpemUgKVxuICAgICAgICBdXG4gICAgKTtcblxuICAgIGNvbnN0IEcyZ2VuID0gW1xuICAgICAgICBbXG4gICAgICAgICAgICAxMDg1NzA0Njk5OTAyMzA1NzEzNTk0NDU3MDc2MjIzMjgyOTQ4MTM3MDc1NjM1OTU3ODUxODA4Njk5MDUxOTk5MzI4NTY1NTg1Mjc4MW4sXG4gICAgICAgICAgICAxMTU1OTczMjAzMjk4NjM4NzEwNzk5MTAwNDAyMTM5MjI4NTc4MzkyNTgxMjg2MTgyMTE5MjUzMDkxNzQwMzE1MTQ1MjM5MTgwNTYzNG4sXG4gICAgICAgIF0sW1xuICAgICAgICAgICAgODQ5NTY1MzkyMzEyMzQzMTQxNzYwNDk3MzI0NzQ4OTI3MjQzODQxODE5MDU4NzI2MzYwMDE0ODc3MDI4MDY0OTMwNjk1ODEwMTkzMG4sXG4gICAgICAgICAgICA0MDgyMzY3ODc1ODYzNDMzNjgxMzMyMjAzNDAzMTQ1NDM1NTY4MzE2ODUxMzI3NTkzNDAxMjA4MTA1NzQxMDc2MjE0MTIwMDkzNTMxbixcbiAgICAgICAgXSxbXG4gICAgICAgICAgICAxbixcbiAgICAgICAgICAgIDBuLFxuICAgICAgICBdXG4gICAgXTtcblxuICAgIGNvbnN0IHBHMmdlbiA9IG1vZHVsZS5hbGxvYyhcbiAgICAgICAgW1xuICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyZ2VuWzBdWzBdKSwgZjFzaXplICksXG4gICAgICAgICAgICAuLi51dGlscyQyLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoRzJnZW5bMF1bMV0pLCBmMXNpemUgKSxcbiAgICAgICAgICAgIC4uLnV0aWxzJDIuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeShHMmdlblsxXVswXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyZ2VuWzFdWzFdKSwgZjFzaXplICksXG4gICAgICAgICAgICAuLi51dGlscyQyLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoRzJnZW5bMl1bMF0pLCBmMXNpemUgKSxcbiAgICAgICAgICAgIC4uLnV0aWxzJDIuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeShHMmdlblsyXVsxXSksIGYxc2l6ZSApLFxuICAgICAgICBdXG4gICAgKTtcblxuICAgIGNvbnN0IEcyemVybyA9IFtcbiAgICAgICAgW1xuICAgICAgICAgICAgMG4sXG4gICAgICAgICAgICAwbixcbiAgICAgICAgXSxbXG4gICAgICAgICAgICAxbixcbiAgICAgICAgICAgIDBuLFxuICAgICAgICBdLFtcbiAgICAgICAgICAgIDBuLFxuICAgICAgICAgICAgMG4sXG4gICAgICAgIF1cbiAgICBdO1xuXG4gICAgY29uc3QgcEcyemVybyA9IG1vZHVsZS5hbGxvYyhcbiAgICAgICAgW1xuICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1swXVswXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1swXVsxXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1sxXVswXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1sxXVsxXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1syXVswXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1syXVsxXSksIGYxc2l6ZSApLFxuICAgICAgICBdXG4gICAgKTtcblxuICAgIGNvbnN0IHBPbmVUID0gbW9kdWxlLmFsbG9jKFtcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDEpLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDApLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDApLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDApLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDApLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDApLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDApLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDApLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDApLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDApLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDApLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDApLCBmMXNpemUgKSxcbiAgICBdKTtcblxuICAgIGNvbnN0IHBOb25SZXNpZHVlRjYgPSBtb2R1bGUuYWxsb2MoW1xuICAgICAgICAuLi51dGlscyQyLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoOSksIGYxc2l6ZSApLFxuICAgICAgICAuLi51dGlscyQyLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoMSksIGYxc2l6ZSApLFxuICAgIF0pO1xuXG4gICAgY29uc3QgcFR3b0ludiA9IG1vZHVsZS5hbGxvYyhbXG4gICAgICAgIC4uLnV0aWxzJDIuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeSggIG1vZEludigybiwgcSkpLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggMG4sIGYxc2l6ZSApXG4gICAgXSk7XG5cbiAgICBjb25zdCBwQWx0Qm4xMjhUd2lzdCA9IHBOb25SZXNpZHVlRjY7XG5cbiAgICBjb25zdCBwVHdpc3RDb2VmQiA9IG1vZHVsZS5hbGxvYyhbXG4gICAgICAgIC4uLnV0aWxzJDIuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeSgxOTQ4NTg3NDc1MTc1OTM1NDc3MTAyNDIzOTI2MTAyMTcyMDUwNTc5MDYxODQ2OTMwMTcyMTA2NTU2NDYzMTI5NjQ1MjQ1NzQ3ODM3M24pLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDI2NjkyOTc5MTExOTk5MTE2MTI0NjkwNzM4NzEzNzI4Mzg0MjU0NTA3Njk2NTMzMjkwMDI4ODU2OTM3ODUxMDkxMDMwNzYzNjY5MG4pLCBmMXNpemUgKSxcbiAgICBdKTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkX211bE5SNigpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXggKyBcIl9tdWxOUjZcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgZjJtUHJlZml4ICsgXCJfbXVsXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfY29uc3QocE5vblJlc2lkdWVGNiksXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInhcIiksXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInByXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuICAgIGJ1aWxkX211bE5SNigpO1xuXG4gICAgY29uc3QgZjZtUHJlZml4ID0gYnVpbGRGM20kMShtb2R1bGUsIHByZWZpeCtcIl9tdWxOUjZcIiwgXCJmNm1cIiwgXCJmMm1cIik7XG5cbiAgICBmdW5jdGlvbiBidWlsZF9tdWxOUjEyKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCArIFwiX211bE5SMTJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoXG4gICAgICAgICAgICAgICAgZjJtUHJlZml4ICsgXCJfbXVsXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfY29uc3QocE5vblJlc2lkdWVGNiksXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChuOCo0KSksXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInByXCIpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgIGYybVByZWZpeCArIFwiX2NvcHlcIixcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwieFwiKSxcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChuOCoyKSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgIGYybVByZWZpeCArIFwiX2NvcHlcIixcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KG44KjIpKSxcbiAgICAgICAgICAgICAgICBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChuOCo0KSksXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuICAgIGJ1aWxkX211bE5SMTIoKTtcblxuICAgIGNvbnN0IGZ0bVByZWZpeCA9IGJ1aWxkRjJtJDEobW9kdWxlLCBwcmVmaXgrXCJfbXVsTlIxMlwiLCBcImZ0bVwiLCBmNm1QcmVmaXgpO1xuXG5cbiAgICBjb25zdCBhdGVMb29wQ291bnQgPSAyOTc5Mzk2ODIwMzE1NzA5MzI4OG47XG4gICAgY29uc3QgYXRlTG9vcEJpdEJ5dGVzID0gYml0cyhhdGVMb29wQ291bnQpO1xuICAgIGNvbnN0IHBBdGVMb29wQml0Qnl0ZXMgPSBtb2R1bGUuYWxsb2MoYXRlTG9vcEJpdEJ5dGVzKTtcblxuICAgIGNvbnN0IGF0ZUNvZWZTaXplID0gMyAqIGYyc2l6ZTtcbiAgICBjb25zdCBhdGVORGJsQ29lZnMgPSBhdGVMb29wQml0Qnl0ZXMubGVuZ3RoLTE7XG4gICAgY29uc3QgYXRlTkFkZENvZWZzID0gYXRlTG9vcEJpdEJ5dGVzLnJlZHVjZSgoYWNjLCBiKSA9PiAgYWNjICsgKCBiIT0wID8gMSA6IDApICAgLDApO1xuICAgIGNvbnN0IGF0ZU5Db2VmcyA9IGF0ZU5BZGRDb2VmcyArIGF0ZU5EYmxDb2VmcyArIDE7XG4gICAgY29uc3QgcHJlUFNpemUgPSAzKjIqbjg7XG4gICAgY29uc3QgcHJlUVNpemUgPSAzKm44KjIgKyBhdGVOQ29lZnMqYXRlQ29lZlNpemU7XG5cblxuICAgIG1vZHVsZS5tb2R1bGVzW3ByZWZpeF0gPSB7XG4gICAgICAgIG42NDogbjY0LFxuICAgICAgICBwRzFnZW46IHBHMWdlbixcbiAgICAgICAgcEcxemVybzogcEcxemVybyxcbiAgICAgICAgcEcxYjogcEcxYixcbiAgICAgICAgcEcyZ2VuOiBwRzJnZW4sXG4gICAgICAgIHBHMnplcm86IHBHMnplcm8sXG4gICAgICAgIHBHMmI6IHBHMmIsXG4gICAgICAgIHBxOiBtb2R1bGUubW9kdWxlc1tcImYxbVwiXS5wcSxcbiAgICAgICAgcHI6IHByLFxuICAgICAgICBwT25lVDogcE9uZVQsXG4gICAgICAgIHByZVBTaXplOiBwcmVQU2l6ZSxcbiAgICAgICAgcHJlUVNpemU6IHByZVFTaXplLFxuICAgICAgICByOiByLnRvU3RyaW5nKCksXG4gICAgICAgIHE6IHEudG9TdHJpbmcoKVxuICAgIH07XG5cbiAgICAvLyBjb25zb2xlLmxvZyhcIlByZVBTaXplOiBcIiArcHJlUFNpemUpO1xuICAgIC8vIGNvbnNvbGUubG9nKFwiUHJlUVNpemU6IFwiICtwcmVRU2l6ZSk7XG5cbiAgICBjb25zdCBmaW5hbEV4cFogPSA0OTY1NjYxMzY3MTkyODQ4ODgxbjtcblxuICAgIGZ1bmN0aW9uIG5hZihuKSB7XG4gICAgICAgIGxldCBFID0gbjtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIHdoaWxlIChFID4gMG4pIHtcbiAgICAgICAgICAgIGlmIChpc09kZCQxKEUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IDIgLSBOdW1iZXIoRSAlIDRuKTtcbiAgICAgICAgICAgICAgICByZXMucHVzaCggeiApO1xuICAgICAgICAgICAgICAgIEUgPSBFIC0gQmlnSW50KHopO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCggMCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRSA9IEUgPj4gMW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaXRzKG4pIHtcbiAgICAgICAgbGV0IEUgPSBuO1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKEUgPiAwbikge1xuICAgICAgICAgICAgaWYgKGlzT2RkJDEoRSkpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCggMSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCggMCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRSA9IEUgPj4gMW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFByZXBhcmVHMSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX3ByZXBhcmVHMVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBQXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHByZVBcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoZzFtUHJlZml4ICsgXCJfbm9ybWFsaXplXCIsIGMuZ2V0TG9jYWwoXCJwUFwiKSwgYy5nZXRMb2NhbChcInBwcmVQXCIpKSwgIC8vIFRPRE8gUmVtb3ZlIGlmIGFscmVhZHkgaW4gYWZmaW5lXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRQcmVwQWRkU3RlcCgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX3ByZXBBZGRTdGVwXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicFFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwUlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBDb2VmXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgWDIgID0gYy5nZXRMb2NhbChcInBRXCIpO1xuICAgICAgICBjb25zdCBZMiAgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBRXCIpLCBjLmkzMl9jb25zdChmMnNpemUpKTtcblxuICAgICAgICBjb25zdCBYMSAgPSBjLmdldExvY2FsKFwicFJcIik7XG4gICAgICAgIGNvbnN0IFkxICA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicFJcIiksIGMuaTMyX2NvbnN0KGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCBaMSAgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBSXCIpLCBjLmkzMl9jb25zdCgyKmYyc2l6ZSkpO1xuXG4gICAgICAgIGNvbnN0IEVMTF8wICA9IGMuZ2V0TG9jYWwoXCJwQ29lZlwiKTtcbiAgICAgICAgY29uc3QgRUxMX1ZXID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSwgYy5pMzJfY29uc3QoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IEVMTF9WViAgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBDb2VmXCIpLCBjLmkzMl9jb25zdCgyKmYyc2l6ZSkpO1xuXG4gICAgICAgIGNvbnN0IEQgPSBFTExfVlc7XG4gICAgICAgIGNvbnN0IEUgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IEYgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IEcgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IEggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IEkgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IEogPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IEFVWCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAvLyBEID0gWDEgLSBYMipaMVxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBYMiwgWjEsIEQpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCBYMSwgRCwgRCksXG5cbiAgICAgICAgICAgIC8vIEUgPSBZMSAtIFkyKloxXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIFkyLCBaMSwgRSksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIFkxLCBFLCBFKSxcblxuICAgICAgICAgICAgLy8gRiA9IEReMlxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3NxdWFyZVwiLCBELCBGKSxcblxuICAgICAgICAgICAgLy8gRyA9IEVeMlxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3NxdWFyZVwiLCBFLCBHKSxcblxuICAgICAgICAgICAgLy8gSCA9IEQqRlxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBELCBGLCBIKSxcblxuICAgICAgICAgICAgLy8gSSA9IFgxICogRlxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBYMSwgRiwgSSksXG5cbiAgICAgICAgICAgIC8vIEogPSBIICsgWjEqRyAtIChJK0kpXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEksIEksIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIFoxLCBHLCBKKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgSCwgSiwgSiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIEosIEFVWCwgSiksXG5cblxuICAgICAgICAgICAgLy8gWDMgKFgxKSA9IEQqSlxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBELCBKLCBYMSksXG5cbiAgICAgICAgICAgIC8vIFkzIChZMSkgPSBFKihJLUopLShIKlkxKVxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBILCBZMSwgWTEpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCBJLCBKLCBBVVgpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBFLCBBVVgsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIEFVWCwgWTEsIFkxKSxcblxuICAgICAgICAgICAgLy8gWjMgKFoxKSA9IFoxKkhcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgWjEsIEgsIFoxKSxcblxuICAgICAgICAgICAgLy8gZWxsXzAgPSB4aSAqIChFICogWDIgLSBEICogWTIpXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEQsIFkyLCBBVVgpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBFLCBYMiwgRUxMXzApLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCBFTExfMCwgQVVYLCBFTExfMCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEVMTF8wLCBjLmkzMl9jb25zdChwQWx0Qm4xMjhUd2lzdCksIEVMTF8wKSxcblxuXG4gICAgICAgICAgICAvLyBlbGxfVlYgPSAtIEUgKGxhdGVyOiAqIHhQKVxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX25lZ1wiLCBFLCBFTExfVlYpLFxuXG4gICAgICAgICAgICAvLyBlbGxfVlcgPSBEIChsYXRlcjogKiB5UCAgICApXG4gICAgICAgICAgICAvLyBBbHJlYWR5IGFzc2lnbmVkXG5cbiAgICAgICAgKTtcbiAgICB9XG5cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRQcmVwRG91YmxlU3RlcCgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX3ByZXBEYmxTdGVwXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicFJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQ29lZlwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IFgxICA9IGMuZ2V0TG9jYWwoXCJwUlwiKTtcbiAgICAgICAgY29uc3QgWTEgID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwUlwiKSwgYy5pMzJfY29uc3QoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IFoxICA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicFJcIiksIGMuaTMyX2NvbnN0KDIqZjJzaXplKSk7XG5cbiAgICAgICAgY29uc3QgRUxMXzAgID0gYy5nZXRMb2NhbChcInBDb2VmXCIpO1xuICAgICAgICBjb25zdCBFTExfVlcgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBDb2VmXCIpLCBjLmkzMl9jb25zdChmMnNpemUpKTtcbiAgICAgICAgY29uc3QgRUxMX1ZWICA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicENvZWZcIiksIGMuaTMyX2NvbnN0KDIqZjJzaXplKSk7XG5cbiAgICAgICAgY29uc3QgQSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgQiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgQyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgRCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgRSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgRiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgRyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgSCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgSSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgSiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgRTIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IEFVWCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG5cbiAgICAgICAgICAgIC8vIEEgPSBYMSAqIFkxIC8gMlxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBZMSwgYy5pMzJfY29uc3QocFR3b0ludiksIEEpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBYMSwgQSwgQSksXG5cbiAgICAgICAgICAgIC8vIEIgPSBZMV4yXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3F1YXJlXCIsIFkxLCBCKSxcblxuICAgICAgICAgICAgLy8gQyA9IFoxXjJcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zcXVhcmVcIiwgWjEsIEMpLFxuXG4gICAgICAgICAgICAvLyBEID0gMyAqIENcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgQywgQywgRCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEQsIEMsIEQpLFxuXG4gICAgICAgICAgICAvLyBFID0gdHdpc3RfYiAqIERcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgYy5pMzJfY29uc3QocFR3aXN0Q29lZkIpLCBELCBFKSxcblxuICAgICAgICAgICAgLy8gRiA9IDMgKiBFXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEUsIEUsIEYpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBFLCBGLCBGKSxcblxuICAgICAgICAgICAgLy8gRyA9IChCK0YpLzJcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgQiwgRiwgRyksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEcsIGMuaTMyX2NvbnN0KHBUd29JbnYpLCBHKSxcblxuICAgICAgICAgICAgLy8gSCA9IChZMStaMSleMi0oQitDKVxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBCLCBDLCBBVVgpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBZMSwgWjEsIEgpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3NxdWFyZVwiLCBILCBIKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgSCwgQVVYLCBIKSxcblxuICAgICAgICAgICAgLy8gSSA9IEUtQlxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCBFLCBCLCBJKSxcblxuICAgICAgICAgICAgLy8gSiA9IFgxXjJcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zcXVhcmVcIiwgWDEsIEopLFxuXG4gICAgICAgICAgICAvLyBFX3NxdWFyZWQgPSBFXjJcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zcXVhcmVcIiwgRSwgRTIpLFxuXG4gICAgICAgICAgICAvLyBYMyAoWDEpID0gQSAqIChCLUYpXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIEIsIEYsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEEsIEFVWCwgWDEpLFxuXG4gICAgICAgICAgICAvLyBZMyAoWTEpID0gR14yIC0gMypFXjJcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgRTIsIEUyLCBBVVgpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBFMiwgQVVYLCBBVVgpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3NxdWFyZVwiLCBHLCBZMSksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIFkxLCBBVVgsIFkxKSxcblxuICAgICAgICAgICAgLy8gWjMgKFoxKSA9IEIgKiBIXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEIsIEgsIFoxKSxcblxuICAgICAgICAgICAgLy8gZWxsXzAgPSB4aSAqIElcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgYy5pMzJfY29uc3QocEFsdEJuMTI4VHdpc3QpLCBJLCBFTExfMCksXG5cbiAgICAgICAgICAgIC8vIGVsbF9WVyA9IC0gSCAobGF0ZXI6ICogeVApXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbmVnXCIsIEgsIEVMTF9WVyksXG5cbiAgICAgICAgICAgIC8vIGVsbF9WViA9IDMqSiAobGF0ZXI6ICogeFApXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEosIEosIEVMTF9WViksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEosIEVMTF9WViwgRUxMX1ZWKSxcblxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTXVsQnlRKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCArIFwiX211bEJ5UVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInAxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHJcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4ID0gYy5nZXRMb2NhbChcInAxXCIpO1xuICAgICAgICBjb25zdCB5ID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwMVwiKSwgYy5pMzJfY29uc3QoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHogPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInAxXCIpLCBjLmkzMl9jb25zdChmMnNpemUqMikpO1xuICAgICAgICBjb25zdCB4MyA9IGMuZ2V0TG9jYWwoXCJwclwiKTtcbiAgICAgICAgY29uc3QgeTMgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChmMnNpemUpKTtcbiAgICAgICAgY29uc3QgejMgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChmMnNpemUqMikpO1xuXG4gICAgICAgIGNvbnN0IE11bEJ5UVggPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoW1xuICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KFwiMjE1NzU0NjM2MzgyODA4NDMwMTAzOTgzMjQyNjk0MzA4MjYwOTkyNjkwNDQyNzQzNDcyMTY4MjcyMTI2MTM4Njc4MzY0MzUwMjcyNjFcIiksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KFwiMTAzMDc2MDE1OTU4NzM3MDk3MDAxNTIyODQyNzM4MTYxMTIyNjQwNjkyMzAxMzA2MTY0MzY3NTU2MjUxOTQ4NTQ4MTU4NzU3MTM5NTRcIiksIGYxc2l6ZSApLFxuICAgICAgICBdKSk7XG5cbiAgICAgICAgY29uc3QgTXVsQnlRWSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhbXG4gICAgICAgICAgICAuLi51dGlscyQyLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoXCIyODIxNTY1MTgyMTk0NTM2ODQ0NTQ4MTU5NTYxNjkzNTAyNjU5MzU5NjE3MTg1MjQ0MTIwMzY3MDc4MDc5NTU0MTg2NDg0MTI2NTU0XCIpLCBmMXNpemUgKSxcbiAgICAgICAgICAgIC4uLnV0aWxzJDIuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeShcIjM1MDU4NDM3Njc5MTE1NTYzNzg2ODcwMzAzMDk5ODQyNDg4NDU1NDAyNDM1MDk4OTkyNTk2NDEwMTM2NzgwOTMwMzMxMzA5MzA0MDNcIiksIGYxc2l6ZSApLFxuICAgICAgICBdKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgLy8gVGhlIGZyb2Jlbml1c01hcCgxKSBpbiB0aGlzIGZpZWxkLCBpcyB0aGUgY29uanVnYXRlXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfY29uanVnYXRlXCIsIHgsIHgzKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgTXVsQnlRWCwgeDMsIHgzKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9jb25qdWdhdGVcIiwgeSwgeTMpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBNdWxCeVFZLCB5MywgeTMpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2Nvbmp1Z2F0ZVwiLCB6LCB6MyksXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZFByZXBhcmVHMigpIHtcbiAgICAgICAgYnVpbGRNdWxCeVEoKTtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX3ByZXBhcmVHMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBRXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHByZVFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkTG9jYWwoXCJwQ29lZlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImlcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBRWCA9IGMuZ2V0TG9jYWwoXCJwUVwiKTtcblxuICAgICAgICBjb25zdCBwUiA9IG1vZHVsZS5hbGxvYyhmMnNpemUqMyk7XG4gICAgICAgIGNvbnN0IFIgPSBjLmkzMl9jb25zdChwUik7XG4gICAgICAgIGNvbnN0IFJYID0gYy5pMzJfY29uc3QocFIpO1xuICAgICAgICBjb25zdCBSWSA9IGMuaTMyX2NvbnN0KHBSK2Yyc2l6ZSk7XG4gICAgICAgIGNvbnN0IFJaID0gYy5pMzJfY29uc3QocFIrMipmMnNpemUpO1xuXG4gICAgICAgIGNvbnN0IGNRWCA9IGMuaTMyX2FkZCggYy5nZXRMb2NhbChcInBwcmVRXCIpLCBjLmkzMl9jb25zdCgwKSk7XG4gICAgICAgIGNvbnN0IGNRWSA9IGMuaTMyX2FkZCggYy5nZXRMb2NhbChcInBwcmVRXCIpLCBjLmkzMl9jb25zdChmMnNpemUpKTtcblxuICAgICAgICBjb25zdCBwUTEgPSBtb2R1bGUuYWxsb2MoZjJzaXplKjMpO1xuICAgICAgICBjb25zdCBRMSA9IGMuaTMyX2NvbnN0KHBRMSk7XG5cbiAgICAgICAgY29uc3QgcFEyID0gbW9kdWxlLmFsbG9jKGYyc2l6ZSozKTtcbiAgICAgICAgY29uc3QgUTIgPSBjLmkzMl9jb25zdChwUTIpO1xuICAgICAgICBjb25zdCBRMlkgPSBjLmkzMl9jb25zdChwUTIgKyBmMnNpemUpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChnMm1QcmVmaXggKyBcIl9ub3JtYWxpemVcIiwgUVgsIGNRWCksICAvLyBUT0RPIFJlbW92ZSBpZiBhbHJlYWR5IGluIGFmZmluZVxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2NvcHlcIiwgY1FYLCBSWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfY29weVwiLCBjUVksIFJZKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9vbmVcIiwgUlopLFxuICAgICAgICApO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwQ29lZlwiLCBjLmkzMl9hZGQoIGMuZ2V0TG9jYWwoXCJwcHJlUVwiKSwgYy5pMzJfY29uc3QoZjJzaXplKjMpKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9jb25zdChhdGVMb29wQml0Qnl0ZXMubGVuZ3RoLTIpKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX3ByZXBEYmxTdGVwXCIsIFIsIGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcInBDb2VmXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwicENvZWZcIiksIGMuaTMyX2NvbnN0KGF0ZUNvZWZTaXplKSkpLFxuXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbG9hZDhfcyhjLmdldExvY2FsKFwiaVwiKSwgcEF0ZUxvb3BCaXRCeXRlcyksXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXggKyBcIl9wcmVwQWRkU3RlcFwiLCBjUVgsIFIsIGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwicENvZWZcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSwgYy5pMzJfY29uc3QoYXRlQ29lZlNpemUpKSksXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoMSwgYy5pMzJfZXF6ICggYy5nZXRMb2NhbChcImlcIikgKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpXG4gICAgICAgICk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX211bEJ5UVwiLCBjUVgsIFExKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9tdWxCeVFcIiwgUTEsIFEyKVxuICAgICAgICApO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9uZWdcIiwgUTJZLCBRMlkpLFxuXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfcHJlcEFkZFN0ZXBcIiwgUTEsIFIsIGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwicENvZWZcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSwgYy5pMzJfY29uc3QoYXRlQ29lZlNpemUpKSksXG5cbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9wcmVwQWRkU3RlcFwiLCBRMiwgUiwgYy5nZXRMb2NhbChcInBDb2VmXCIpKSxcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJwQ29lZlwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBDb2VmXCIpLCBjLmkzMl9jb25zdChhdGVDb2VmU2l6ZSkpKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZE11bEJ5MDI0T2xkKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfX211bEJ5MDI0T2xkXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicEVsbDBcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwRWxsVldcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwRWxsVlZcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwUlwiLCBcImkzMlwiKTsgICAgICAgICAgICAvLyBSZXN1bHQgaW4gRjEyXG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4MCAgPSBjLmdldExvY2FsKFwicEVsbDBcIik7XG4gICAgICAgIGNvbnN0IHgyICA9IGMuZ2V0TG9jYWwoXCJwRWxsVlZcIik7XG4gICAgICAgIGNvbnN0IHg0ICA9IGMuZ2V0TG9jYWwoXCJwRWxsVldcIik7XG5cbiAgICAgICAgY29uc3QgejAgID0gYy5nZXRMb2NhbChcInBSXCIpO1xuXG4gICAgICAgIGNvbnN0IHBBVVgxMiA9IG1vZHVsZS5hbGxvYyhmdHNpemUpO1xuICAgICAgICBjb25zdCBBVVgxMiA9IGMuaTMyX2NvbnN0KHBBVVgxMik7XG4gICAgICAgIGNvbnN0IEFVWDEyXzAgPSBjLmkzMl9jb25zdChwQVVYMTIpO1xuICAgICAgICBjb25zdCBBVVgxMl8yID0gYy5pMzJfY29uc3QocEFVWDEyK2Yyc2l6ZSk7XG4gICAgICAgIGNvbnN0IEFVWDEyXzQgPSBjLmkzMl9jb25zdChwQVVYMTIrZjJzaXplKjIpO1xuICAgICAgICBjb25zdCBBVVgxMl82ID0gYy5pMzJfY29uc3QocEFVWDEyK2Yyc2l6ZSozKTtcbiAgICAgICAgY29uc3QgQVVYMTJfOCA9IGMuaTMyX2NvbnN0KHBBVVgxMitmMnNpemUqNCk7XG4gICAgICAgIGNvbnN0IEFVWDEyXzEwID0gYy5pMzJfY29uc3QocEFVWDEyK2Yyc2l6ZSo1KTtcblxuICAgICAgICBmLmFkZENvZGUoXG5cbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9jb3B5XCIsIHgwLCBBVVgxMl8wKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl96ZXJvXCIsIEFVWDEyXzIpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2NvcHlcIiwgeDIsIEFVWDEyXzQpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3plcm9cIiwgQVVYMTJfNiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfY29weVwiLCB4NCwgQVVYMTJfOCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfemVyb1wiLCBBVVgxMl8xMCksXG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsXCIsIEFVWDEyLCB6MCwgejApLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTXVsQnkwMjQoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4KyBcIl9fbXVsQnkwMjRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwRWxsMFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBFbGxWV1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBFbGxWVlwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBSXCIsIFwiaTMyXCIpOyAgICAgICAgICAgIC8vIFJlc3VsdCBpbiBGMTJcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwICA9IGMuZ2V0TG9jYWwoXCJwRWxsMFwiKTtcbiAgICAgICAgY29uc3QgeDIgID0gYy5nZXRMb2NhbChcInBFbGxWVlwiKTtcbiAgICAgICAgY29uc3QgeDQgID0gYy5nZXRMb2NhbChcInBFbGxWV1wiKTtcblxuICAgICAgICBjb25zdCB6MCAgPSBjLmdldExvY2FsKFwicFJcIik7XG4gICAgICAgIGNvbnN0IHoxICA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicFJcIiksIGMuaTMyX2NvbnN0KDIqbjgpKTtcbiAgICAgICAgY29uc3QgejIgID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwUlwiKSwgYy5pMzJfY29uc3QoNCpuOCkpO1xuICAgICAgICBjb25zdCB6MyAgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBSXCIpLCBjLmkzMl9jb25zdCg2Km44KSk7XG4gICAgICAgIGNvbnN0IHo0ICA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicFJcIiksIGMuaTMyX2NvbnN0KDgqbjgpKTtcbiAgICAgICAgY29uc3QgejUgID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwUlwiKSwgYy5pMzJfY29uc3QoMTAqbjgpKTtcblxuICAgICAgICBjb25zdCB0MCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgdDEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHQyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCBzMCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgVDMgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IFQ0ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCBEMCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgRDIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IEQ0ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCBTMSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgQVVYID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcblxuICAgICAgICAgICAgLy8gRDAgPSB6MCAqIHgwO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCB6MCwgeDAsIEQwKSxcbiAgICAgICAgICAgIC8vIEQyID0gejIgKiB4MjtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgejIsIHgyLCBEMiksXG4gICAgICAgICAgICAvLyBENCA9IHo0ICogeDQ7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHo0LCB4NCwgRDQpLFxuICAgICAgICAgICAgLy8gdDIgPSB6MCArIHo0O1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB6MCwgejQsIHQyKSxcbiAgICAgICAgICAgIC8vIHQxID0gejAgKyB6MjtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgejAsIHoyLCB0MSksXG4gICAgICAgICAgICAvLyBzMCA9IHoxICsgejMgKyB6NTtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgejEsIHozLCBzMCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHMwLCB6NSwgczApLFxuXG5cbiAgICAgICAgICAgIC8vIEZvciB6LmFfLmFfID0gejAuXG4gICAgICAgICAgICAvLyBTMSA9IHoxICogeDI7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHoxLCB4MiwgUzEpLFxuICAgICAgICAgICAgLy8gVDMgPSBTMSArIEQ0O1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBTMSwgRDQsIFQzKSxcbiAgICAgICAgICAgIC8vIFQ0ID0gbXlfRnA2Ojpub25fcmVzaWR1ZSAqIFQzICsgRDA7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIGMuaTMyX2NvbnN0KHBOb25SZXNpZHVlRjYpLCBUMywgVDQpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBUNCwgRDAsIHowKSxcbiAgICAgICAgICAgIC8vIHowID0gVDQ7XG5cbiAgICAgICAgICAgIC8vIEZvciB6LmFfLmJfID0gejFcbiAgICAgICAgICAgIC8vIFQzID0gejUgKiB4NDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgejUsIHg0LCBUMyksXG4gICAgICAgICAgICAvLyBTMSA9IFMxICsgVDM7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIFMxLCBUMywgUzEpLFxuICAgICAgICAgICAgLy8gVDMgPSBUMyArIEQyO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBUMywgRDIsIFQzKSxcbiAgICAgICAgICAgIC8vIFQ0ID0gbXlfRnA2Ojpub25fcmVzaWR1ZSAqIFQzO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBjLmkzMl9jb25zdChwTm9uUmVzaWR1ZUY2KSwgVDMsIFQ0KSxcbiAgICAgICAgICAgIC8vIFQzID0gejEgKiB4MDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgejEsIHgwLCBUMyksXG4gICAgICAgICAgICAvLyBTMSA9IFMxICsgVDM7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIFMxLCBUMywgUzEpLFxuICAgICAgICAgICAgLy8gVDQgPSBUNCArIFQzO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBUNCwgVDMsIHoxKSxcbiAgICAgICAgICAgIC8vIHoxID0gVDQ7XG5cblxuXG4gICAgICAgICAgICAvLyBGb3Igei5hXy5jXyA9IHoyXG4gICAgICAgICAgICAvLyB0MCA9IHgwICsgeDI7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHgwLCB4MiwgdDApLFxuICAgICAgICAgICAgLy8gVDMgPSB0MSAqIHQwIC0gRDAgLSBEMjtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgdDEsIHQwLCBUMyksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEQwLCBEMiwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgVDMsIEFVWCwgVDMpLFxuICAgICAgICAgICAgLy8gVDQgPSB6MyAqIHg0O1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCB6MywgeDQsIFQ0KSxcbiAgICAgICAgICAgIC8vIFMxID0gUzEgKyBUNDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgUzEsIFQ0LCBTMSksXG5cblxuICAgICAgICAgICAgLy8gRm9yIHouYl8uYV8gPSB6MyAoejMgbmVlZHMgejIpXG4gICAgICAgICAgICAvLyB0MCA9IHoyICsgejQ7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHoyLCB6NCwgdDApLFxuICAgICAgICAgICAgLy8gVDMgPSBUMyArIFQ0O1xuICAgICAgICAgICAgLy8gejIgPSBUMztcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgVDMsIFQ0LCB6MiksXG4gICAgICAgICAgICAvLyB0MSA9IHgyICsgeDQ7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHgyLCB4NCwgdDEpLFxuICAgICAgICAgICAgLy8gVDMgPSB0MCAqIHQxIC0gRDIgLSBENDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgdDEsIHQwLCBUMyksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEQyLCBENCwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgVDMsIEFVWCwgVDMpLFxuICAgICAgICAgICAgLy8gVDQgPSBteV9GcDY6Om5vbl9yZXNpZHVlICogVDM7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIGMuaTMyX2NvbnN0KHBOb25SZXNpZHVlRjYpLCBUMywgVDQpLFxuICAgICAgICAgICAgLy8gVDMgPSB6MyAqIHgwO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCB6MywgeDAsIFQzKSxcbiAgICAgICAgICAgIC8vIFMxID0gUzEgKyBUMztcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgUzEsIFQzLCBTMSksXG4gICAgICAgICAgICAvLyBUNCA9IFQ0ICsgVDM7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIFQ0LCBUMywgejMpLFxuICAgICAgICAgICAgLy8gejMgPSBUNDtcblxuICAgICAgICAgICAgLy8gRm9yIHouYl8uYl8gPSB6NFxuICAgICAgICAgICAgLy8gVDMgPSB6NSAqIHgyO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCB6NSwgeDIsIFQzKSxcbiAgICAgICAgICAgIC8vIFMxID0gUzEgKyBUMztcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgUzEsIFQzLCBTMSksXG4gICAgICAgICAgICAvLyBUNCA9IG15X0ZwNjo6bm9uX3Jlc2lkdWUgKiBUMztcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgYy5pMzJfY29uc3QocE5vblJlc2lkdWVGNiksIFQzLCBUNCksXG4gICAgICAgICAgICAvLyB0MCA9IHgwICsgeDQ7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHgwLCB4NCwgdDApLFxuICAgICAgICAgICAgLy8gVDMgPSB0MiAqIHQwIC0gRDAgLSBENDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgdDIsIHQwLCBUMyksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEQwLCBENCwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgVDMsIEFVWCwgVDMpLFxuICAgICAgICAgICAgLy8gVDQgPSBUNCArIFQzO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBUNCwgVDMsIHo0KSxcbiAgICAgICAgICAgIC8vIHo0ID0gVDQ7XG5cbiAgICAgICAgICAgIC8vIEZvciB6LmJfLmNfID0gejUuXG4gICAgICAgICAgICAvLyB0MCA9IHgwICsgeDIgKyB4NDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgeDAsIHgyLCB0MCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQwLCB4NCwgdDApLFxuICAgICAgICAgICAgLy8gVDMgPSBzMCAqIHQwIC0gUzE7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHMwLCB0MCwgVDMpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCBUMywgUzEsIHo1KSxcbiAgICAgICAgICAgIC8vIHo1ID0gVDM7XG5cbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTWlsbGVyTG9vcCgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX21pbGxlckxvb3BcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwcHJlUFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBwcmVRXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInBDb2VmXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaVwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHByZVBfUFggPSBjLmdldExvY2FsKFwicHByZVBcIik7XG4gICAgICAgIGNvbnN0IHByZVBfUFkgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBwcmVQXCIpLCBjLmkzMl9jb25zdChmMXNpemUpKTtcblxuICAgICAgICBjb25zdCBFTExfMCAgPSBjLmdldExvY2FsKFwicENvZWZcIik7XG4gICAgICAgIGNvbnN0IEVMTF9WVyA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicENvZWZcIiksIGMuaTMyX2NvbnN0KGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCBFTExfVlYgID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSwgYy5pMzJfY29uc3QoMipmMnNpemUpKTtcblxuXG4gICAgICAgIGNvbnN0IHBWVyA9IG1vZHVsZS5hbGxvYyhmMnNpemUpO1xuICAgICAgICBjb25zdCBWVyA9IGMuaTMyX2NvbnN0KHBWVyk7XG4gICAgICAgIGNvbnN0IHBWViA9IG1vZHVsZS5hbGxvYyhmMnNpemUpO1xuICAgICAgICBjb25zdCBWViA9IGMuaTMyX2NvbnN0KHBWVik7XG5cbiAgICAgICAgY29uc3QgRiA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuXG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX29uZVwiLCBGKSxcblxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInBDb2VmXCIsIGMuaTMyX2FkZCggYy5nZXRMb2NhbChcInBwcmVRXCIpLCBjLmkzMl9jb25zdChmMnNpemUqMykpKSxcblxuICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfY29uc3QoYXRlTG9vcEJpdEJ5dGVzLmxlbmd0aC0yKSksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcblxuXG4gICAgICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX3NxdWFyZVwiLCBGLCBGKSxcblxuICAgICAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWwxXCIsIEVMTF9WVyxwcmVQX1BZLCBWVyksXG4gICAgICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bDFcIiwgRUxMX1ZWLCBwcmVQX1BYLCBWViksXG4gICAgICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX19tdWxCeTAyNFwiLCBFTExfMCwgVlcsIFZWLCBGKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwicENvZWZcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSwgYy5pMzJfY29uc3QoYXRlQ29lZlNpemUpKSksXG5cbiAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9sb2FkOF9zKGMuZ2V0TG9jYWwoXCJpXCIpLCBwQXRlTG9vcEJpdEJ5dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKGYybVByZWZpeCArIFwiX211bDFcIiwgRUxMX1ZXLCBwcmVQX1BZLCBWVyksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsMVwiLCBFTExfVlYsIHByZVBfUFgsIFZWKSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX19tdWxCeTAyNFwiLCBFTExfMCwgVlcsIFZWLCBGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuc2V0TG9jYWwoXCJwQ29lZlwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBDb2VmXCIpLCBjLmkzMl9jb25zdChhdGVDb2VmU2l6ZSkpKSxcblxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmJyX2lmKDEsIGMuaTMyX2VxeiAoIGMuZ2V0TG9jYWwoXCJpXCIpICkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX3N1YihjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKVxuXG4gICAgICAgICk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bDFcIiwgRUxMX1ZXLCBwcmVQX1BZLCBWVyksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsMVwiLCBFTExfVlYsIHByZVBfUFgsIFZWKSxcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9fbXVsQnkwMjRcIiwgRUxMXzAsIFZXLCBWViwgRiksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwicENvZWZcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSwgYy5pMzJfY29uc3QoYXRlQ29lZlNpemUpKSksXG5cbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWwxXCIsIEVMTF9WVywgcHJlUF9QWSwgVlcpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bDFcIiwgRUxMX1ZWLCBwcmVQX1BYLCBWViksXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX211bEJ5MDI0XCIsIEVMTF8wLCBWVywgVlYsIEYpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInBDb2VmXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwicENvZWZcIiksIGMuaTMyX2NvbnN0KGF0ZUNvZWZTaXplKSkpLFxuXG4gICAgICAgICk7XG5cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRnJvYmVuaXVzTWFwKG4pIHtcbiAgICAgICAgY29uc3QgRjEyID0gW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbODM3NjExODg2NTc2MzgyMTQ5NjU4Mzk3Mzg2NzYyNjM2NDA5MjU4OTkwNjA2NTg2ODI5ODc3NjkwOTYxNzkxNjAxODc2ODM0MDA4MG4sIDE2NDY5ODIzMzIzMDc3ODA4MjIzODg5MTM3MjQxMTc2NTM2Nzk5MDA5Mjg2NjQ2MTA4MTY5OTM1NjU5MzAxNjEzOTYxNzEyMTk4MzE2bl0sXG4gICAgICAgICAgICAgICAgWzIxODg4MjQyODcxODM5Mjc1MjIwMDQyNDQ1MjYwMTA5MTUzMTY3Mjc3NzA3NDE0NDcyMDYxNjQxNzE0NzU4NjM1NzY1MDIwNTU2NjE3biwgMG5dLFxuICAgICAgICAgICAgICAgIFsxMTY5NzQyMzQ5NjM1ODE1NDMwNDgyNTc4MjkyMjU4NDcyNTMxMjkxMjM4MzQ0MTE1OTUwNTAzODc5NDAyNzEwNTc3ODk1NDE4NDMxOW4sIDMwMzg0NzM4OTEzNTA2NTg4NzQyMjc4MzQ1NDg3NzYwOTk0MTQ1NjM0OTE4ODkxOTcxOTI3MjM0NTA4Mzk1NDQzNzg2MDQwOTYwMW5dLFxuICAgICAgICAgICAgICAgIFsyMTg4ODI0Mjg3MTgzOTI3NTIyMDA0MjQ0NTI2MDEwOTE1MzE2NzI3NzcwNzQxNDQ3MjA2MTY0MTcxNDc1ODYzNTc2NTAyMDU1NjYxNm4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMzMyMTMwNDYzMDU5NDMzMjgwODI0MTgwOTA1NDk1ODM2MTIyMDMyMjQ3NzM3NTI5MTIwNjI2MTg4NDQwOTE4OTc2MDE4NTg0NDIzOW4sIDU3MjIyNjY5Mzc4OTY1MzI4ODU3ODAwNTE5NTg5NTgzNDgyMzExNDMzNzM3MDAxMDkzNzI5OTkzNzQ4MjAyMzUxMjEzNzQ0MTk4NjhuXSxcbiAgICAgICAgICAgICAgICBbMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg2OTYzMTExNTcyOTc4MjM2NjI2ODkwMzc4OTQ2NDUyMjYyMDg1ODJuLCAwbl0sXG4gICAgICAgICAgICAgICAgWzEzNTEyMTI0MDA2MDc1NDUzNzI1NjYyNDMxODc3NjMwOTEwOTk2MTA2NDA1MDkxNDI5NTI0ODg1Nzc5NDE5OTc4NjI2NDU3ODY4NTAzbiwgNTQxODQxOTU0ODc2MTQ2Njk5ODM1NzI2ODUwNDA4MDczODI4OTY4NzAyNDUxMTE4OTY1MzcyNzAyOTczNjI4MDY4MzUxNDAxMDI2N25dLFxuICAgICAgICAgICAgICAgIFsyMjAzOTYwNDg1MTQ4MTIxOTIxNDE4NjAzNzQyODI1NzYyMDIwOTc0Mjc5MjU4ODgwMjA1NjUxOTY2biwgMG5dLFxuICAgICAgICAgICAgICAgIFsxMDE5MDgxOTM3NTQ4MTEyMDkxNzQyMDYyMjgyMjY3MjU0OTc3NTc4MzkyNzcxNjEzODMxODYyMzg5NTAxMDc4ODg2NjI3MjAyNDI2NG4sIDIxNTg0Mzk1NDgyNzA0MjA5MzM0ODIzNjIyMjkwMzc5NjY1MTQ3MjM5OTYxOTY4Mzc4MTA0MzkwMzQzOTUzOTQwMjA3MzY1Nzk4OTgybl0sXG4gICAgICAgICAgICAgICAgWzIyMDM5NjA0ODUxNDgxMjE5MjE0MTg2MDM3NDI4MjU3NjIwMjA5NzQyNzkyNTg4ODAyMDU2NTE5NjduLCAwbl0sXG4gICAgICAgICAgICAgICAgWzE4NTY2OTM4MjQxMjQ0OTQyNDE0MDA0NTk2NjkwMjk4OTEzODY4MzczODMzNzgyMDA2NjE3NDAwODA0NjI4NzA0ODg1MDQwMzY0MzQ0biwgMTYxNjU5NzU5MzM5NDI3NDIzMzY0NjYzNTM3ODYyOTg5MjY4NTc1NTI5Mzc0NTcxODg0NTA2NjMzMTQyMTc2NTk1MjM4NTE3ODg3MTVuXSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBGNiA9IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgWzFuLCAwbl0sXG4gICAgICAgICAgICAgICAgWzIxNTc1NDYzNjM4MjgwODQzMDEwMzk4MzI0MjY5NDMwODI2MDk5MjY5MDQ0Mjc0MzQ3MjE2ODI3MjEyNjEzODY3ODM2NDM1MDI3MjYxbiwgMTAzMDc2MDE1OTU4NzM3MDk3MDAxNTIyODQyNzM4MTYxMTIyNjQwNjkyMzAxMzA2MTY0MzY3NTU2MjUxOTQ4NTQ4MTU4NzU3MTM5NTRuXSxcbiAgICAgICAgICAgICAgICBbMjE4ODgyNDI4NzE4MzkyNzUyMjAwNDI0NDUyNjAxMDkxNTMxNjcyNzc3MDc0MTQ0NzIwNjE2NDE3MTQ3NTg2MzU3NjUwMjA1NTY2MTZuLCAwbl0sXG4gICAgICAgICAgICAgICAgWzM3NzIwMDA4ODE5MTk4NTM3NzY0MzM2OTUxODY3MTM4NTgyMzkwMDkwNzM1OTM4MTcxOTU3NzE3NzMzODE5MTkzMTY0MTkzNDUyNjFuLCAyMjM2NTk1NDk1OTY3MjQ1MTg4MjgxNzAxMjQ4MjAzMTgxNzk1MTIxMDY4OTAyNjA1ODYxMjI3ODU1MjYxMTM3ODIwOTQ0MDA4OTI2bl0sXG4gICAgICAgICAgICAgICAgWzIyMDM5NjA0ODUxNDgxMjE5MjE0MTg2MDM3NDI4MjU3NjIwMjA5NzQyNzkyNTg4ODAyMDU2NTE5NjZuLCAwbl0sXG4gICAgICAgICAgICAgICAgWzE4NDI5MDIxMjIzNDc3ODUzNjU3NjYwNzkyMDM0MzY5ODY1ODM5MTE0NTA0NDQ2NDMxMjM0NzI2MzkyMDgwMDAyMTM3NTk4MDQ0NjQ0biwgOTM0NDA0NTc3OTk5ODMyMDMzMzgxMjQyMDIyMzIzNzk4MTAyOTUwNjAxMjEyNDA3NTUyNTY3OTIwODU4MTkwMjAwODQwNjQ4NTcwM25dLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMjU4MTkxMTM0NDQ2NzAwOTMzNTI2NzMxMTExNTQ2ODgwMzA5OTU1MTY2NTYwNTA3NjE5Njc0MDg2NzgwNTI1ODU2ODIzNDM0NjMzOG4sIDE5OTM3NzU2OTcxNzc1NjQ3OTg3OTk1OTMyMTY5OTI5MzQxOTk0MzE0NjQwNjUyOTY0OTQ5NDQ4MzEzMzc0NDcyNDAwNzE2NjYxMDMwbl0sXG4gICAgICAgICAgICAgICAgWzIyMDM5NjA0ODUxNDgxMjE5MjE0MTg2MDM3NDI4MjU3NjIwMjA5NzQyNzkyNTg4ODAyMDU2NTE5NjZuLCAwbl0sXG4gICAgICAgICAgICAgICAgWzUzMjQ0NzkyMDI0NDk5MDM1NDI3MjY3ODMzOTU1MDYyMTQ0ODE5MjgyNTc3NjI0MDA2NDMyNzk3ODAzNDMzNjg1NTcyOTcxMzU3MThuLCAxNjIwODkwMDM4MDczNzY5MzA4NDkxOTQ5NTEyNzMzNDM4Nzk4MTM5MzcyNjQxOTg1Njg4ODc5OTkxNzkxNDE4MDk4ODg0NDEyMzAzOW5dLFxuICAgICAgICAgICAgICAgIFsyMTg4ODI0Mjg3MTgzOTI3NTIyMDA0MjQ0NTI2MDEwOTE1MzE2NzI3NzcwNzQxNDQ3MjA2MTY0MTcxNDc1ODYzNTc2NTAyMDU1NjYxNm4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMTM5ODE4NTIzMjQ5MjIzNjIzNDQyNTIzMTEyMzQyODIyNTc1MDcyMTYzODc3ODk4MjA5ODM2NDIwNDA4ODkyNjc1MTk2OTQ3MjY1MjduLCA3NjI5ODI4MzkxMTY1MjA5MzcxNTc3Mzg0MTkzMjUwODIwMjAxNjg0MjU1MjQxNzczODA5MDc3MTQ2Nzg3MTM1OTAwODkxNjMzMDk3bl0sXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX19mcm9iZW5pdXNNYXBcIituKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDY7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgWCA9IChpPT0wKSA/IGMuZ2V0TG9jYWwoXCJ4XCIpIDogYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChpKmYyc2l6ZSkpO1xuICAgICAgICAgICAgY29uc3QgWGMwID0gWDtcbiAgICAgICAgICAgIGNvbnN0IFhjMSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoaSpmMnNpemUgKyBmMXNpemUpKTtcbiAgICAgICAgICAgIGNvbnN0IFIgPSAoaT09MCkgPyBjLmdldExvY2FsKFwiclwiKSA6IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoaSpmMnNpemUpKTtcbiAgICAgICAgICAgIGNvbnN0IFJjMCA9IFI7XG4gICAgICAgICAgICBjb25zdCBSYzEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KGkqZjJzaXplICsgZjFzaXplKSk7XG4gICAgICAgICAgICBjb25zdCBjb2VmID0gbXVsMihGMTJbTWF0aC5mbG9vcihpLzMpXVtuJTEyXSAsIEY2W2klM11bbiU2XSk7XG4gICAgICAgICAgICBjb25zdCBwQ29lZiA9IG1vZHVsZS5hbGxvYyhbXG4gICAgICAgICAgICAgICAgLi4udXRpbHMkMi5iaWdJbnQyQnl0ZXNMRSh0b01vbnRnb21lcnkoY29lZlswXSksIDMyKSxcbiAgICAgICAgICAgICAgICAuLi51dGlscyQyLmJpZ0ludDJCeXRlc0xFKHRvTW9udGdvbWVyeShjb2VmWzFdKSwgMzIpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAobiUyID09IDEpIHtcbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9jb3B5XCIsIFhjMCwgUmMwKSxcbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX25lZ1wiLCBYYzEsIFJjMSksXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgUiwgYy5pMzJfY29uc3QocENvZWYpLCBSKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmLmFkZENvZGUoYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBYLCBjLmkzMl9jb25zdChwQ29lZiksIFIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG11bDIoYSwgYikge1xuICAgICAgICAgICAgY29uc3QgYWMwID0gQmlnSW50KGFbMF0pO1xuICAgICAgICAgICAgY29uc3QgYWMxID0gQmlnSW50KGFbMV0pO1xuICAgICAgICAgICAgY29uc3QgYmMwID0gQmlnSW50KGJbMF0pO1xuICAgICAgICAgICAgY29uc3QgYmMxID0gQmlnSW50KGJbMV0pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gW1xuICAgICAgICAgICAgICAgIChhYzAgKiBiYzAgLSAoICBhYzEgKiBiYzEpICApICUgcSxcbiAgICAgICAgICAgICAgICAoYWMwICogYmMxICsgKCAgYWMxICogYmMwKSAgKSAlIHEsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUkMihyZXNbMF0pKSByZXNbMF0gPSByZXNbMF0gKyBxO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRmluYWxFeHBvbmVudGlhdGlvbkZpcnN0Q2h1bmsoKSB7XG5cbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX19maW5hbEV4cG9uZW50aWF0aW9uRmlyc3RDaHVua1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgZWx0ID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IGVsdEMwID0gZWx0O1xuICAgICAgICBjb25zdCBlbHRDMSA9IGMuaTMyX2FkZChlbHQsIGMuaTMyX2NvbnN0KG44KjYpKTtcbiAgICAgICAgY29uc3QgciA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCBwQSA9IG1vZHVsZS5hbGxvYyhmdHNpemUpO1xuICAgICAgICBjb25zdCBBID0gYy5pMzJfY29uc3QocEEpO1xuICAgICAgICBjb25zdCBBYzAgPSBBO1xuICAgICAgICBjb25zdCBBYzEgPSBjLmkzMl9jb25zdChwQSArIG44KjYpO1xuICAgICAgICBjb25zdCBCID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBDID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBEID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIC8vIGNvbnN0IGFsdF9ibjEyOF9GcTEyIEEgPSBhbHRfYm4xMjhfRnExMihlbHQuYzAsLWVsdC5jMSk7XG4gICAgICAgICAgICBjLmNhbGwoZjZtUHJlZml4ICsgXCJfY29weVwiLCBlbHRDMCwgQWMwKSxcbiAgICAgICAgICAgIGMuY2FsbChmNm1QcmVmaXggKyBcIl9uZWdcIiwgZWx0QzEsIEFjMSksXG5cbiAgICAgICAgICAgIC8vIGNvbnN0IGFsdF9ibjEyOF9GcTEyIEIgPSBlbHQuaW52ZXJzZSgpO1xuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX2ludmVyc2VcIiwgZWx0LCBCKSxcblxuICAgICAgICAgICAgLy8gY29uc3QgYWx0X2JuMTI4X0ZxMTIgQyA9IEEgKiBCO1xuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX211bFwiLCBBLCBCLCBDKSxcbiAgICAgICAgICAgIC8vIGNvbnN0IGFsdF9ibjEyOF9GcTEyIEQgPSBDLkZyb2Jlbml1c19tYXAoMik7XG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX2Zyb2Jlbml1c01hcDJcIiwgQywgRCksXG4gICAgICAgICAgICAvLyBjb25zdCBhbHRfYm4xMjhfRnExMiByZXN1bHQgPSBEICogQztcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgQywgRCwgciksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRDeWNsb3RvbWljU3F1YXJlKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfX2N5Y2xvdG9taWNTcXVhcmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHg0ID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMnNpemUpKTtcbiAgICAgICAgY29uc3QgeDMgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KDIqZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHgyID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdCgzKmYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoNCpmMnNpemUpKTtcbiAgICAgICAgY29uc3QgeDUgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KDUqZjJzaXplKSk7XG5cbiAgICAgICAgY29uc3QgcjAgPSBjLmdldExvY2FsKFwiclwiKTtcbiAgICAgICAgY29uc3QgcjQgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCByMyA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoMipmMnNpemUpKTtcbiAgICAgICAgY29uc3QgcjIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KDMqZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHIxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdCg0KmYyc2l6ZSkpO1xuICAgICAgICBjb25zdCByNSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoNSpmMnNpemUpKTtcblxuICAgICAgICBjb25zdCB0MCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgdDEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHQyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB0MyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgdDQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHQ1ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB0bXAgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IEFVWCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcblxuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIC8vICAgIC8vIHQwICsgdDEqeSA9ICh6MCArIHoxKnkpXjIgPSBhXjJcbiAgICAgICAgICAgIC8vICAgIHRtcCA9IHowICogejE7XG4gICAgICAgICAgICAvLyAgICB0MCA9ICh6MCArIHoxKSAqICh6MCArIG15X0ZwNjo6bm9uX3Jlc2lkdWUgKiB6MSkgLSB0bXAgLSBteV9GcDY6Om5vbl9yZXNpZHVlICogdG1wO1xuICAgICAgICAgICAgLy8gICAgdDEgPSB0bXAgKyB0bXA7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHgwLCB4MSwgdG1wKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgeDEsIGMuaTMyX2NvbnN0KHBOb25SZXNpZHVlRjYpLCB0MCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHgwLCB0MCwgdDApLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB4MCwgeDEsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEFVWCwgdDAsIHQwKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgYy5pMzJfY29uc3QocE5vblJlc2lkdWVGNiksIHRtcCwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdG1wLCBBVVgsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQwLCBBVVgsIHQwKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdG1wLCB0bXAsIHQxKSxcblxuICAgICAgICAgICAgLy8gIC8vIHQyICsgdDMqeSA9ICh6MiArIHozKnkpXjIgPSBiXjJcbiAgICAgICAgICAgIC8vICB0bXAgPSB6MiAqIHozO1xuICAgICAgICAgICAgLy8gIHQyID0gKHoyICsgejMpICogKHoyICsgbXlfRnA2Ojpub25fcmVzaWR1ZSAqIHozKSAtIHRtcCAtIG15X0ZwNjo6bm9uX3Jlc2lkdWUgKiB0bXA7XG4gICAgICAgICAgICAvLyAgdDMgPSB0bXAgKyB0bXA7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHgyLCB4MywgdG1wKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgeDMsIGMuaTMyX2NvbnN0KHBOb25SZXNpZHVlRjYpLCB0MiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHgyLCB0MiwgdDIpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB4MiwgeDMsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEFVWCwgdDIsIHQyKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgYy5pMzJfY29uc3QocE5vblJlc2lkdWVGNiksIHRtcCwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdG1wLCBBVVgsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQyLCBBVVgsIHQyKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdG1wLCB0bXAsIHQzKSxcblxuICAgICAgICAgICAgLy8gIC8vIHQ0ICsgdDUqeSA9ICh6NCArIHo1KnkpXjIgPSBjXjJcbiAgICAgICAgICAgIC8vICB0bXAgPSB6NCAqIHo1O1xuICAgICAgICAgICAgLy8gIHQ0ID0gKHo0ICsgejUpICogKHo0ICsgbXlfRnA2Ojpub25fcmVzaWR1ZSAqIHo1KSAtIHRtcCAtIG15X0ZwNjo6bm9uX3Jlc2lkdWUgKiB0bXA7XG4gICAgICAgICAgICAvLyAgdDUgPSB0bXAgKyB0bXA7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHg0LCB4NSwgdG1wKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgeDUsIGMuaTMyX2NvbnN0KHBOb25SZXNpZHVlRjYpLCB0NCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHg0LCB0NCwgdDQpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB4NCwgeDUsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEFVWCwgdDQsIHQ0KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgYy5pMzJfY29uc3QocE5vblJlc2lkdWVGNiksIHRtcCwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdG1wLCBBVVgsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQ0LCBBVVgsIHQ0KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdG1wLCB0bXAsIHQ1KSxcblxuICAgICAgICAgICAgLy8gRm9yIEFcbiAgICAgICAgICAgIC8vIHowID0gMyAqIHQwIC0gMiAqIHowXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQwLCB4MCwgcjApLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCByMCwgcjAsIHIwKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdDAsIHIwLCByMCksXG4gICAgICAgICAgICAvLyB6MSA9IDMgKiB0MSArIDIgKiB6MVxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB0MSwgeDEsIHIxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgcjEsIHIxLCByMSksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQxLCByMSwgcjEpLFxuXG4gICAgICAgICAgICAvLyBGb3IgQlxuICAgICAgICAgICAgLy8gejIgPSAzICogKHhpICogdDUpICsgMiAqIHoyXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHQ1LCBjLmkzMl9jb25zdChwQWx0Qm4xMjhUd2lzdCksIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEFVWCwgeDIsIHIyKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgcjIsIHIyLCByMiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEFVWCwgcjIsIHIyKSxcbiAgICAgICAgICAgIC8vIHozID0gMyAqIHQ0IC0gMiAqIHozXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQ0LCB4MywgcjMpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCByMywgcjMsIHIzKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdDQsIHIzLCByMyksXG5cbiAgICAgICAgICAgIC8vIEZvciBDXG4gICAgICAgICAgICAvLyB6NCA9IDMgKiB0MiAtIDIgKiB6NFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCB0MiwgeDQsIHI0KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgcjQsIHI0LCByNCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQyLCByNCwgcjQpLFxuICAgICAgICAgICAgLy8gejUgPSAzICogdDMgKyAyICogejVcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdDMsIHg1LCByNSksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHI1LCByNSwgcjUpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB0MywgcjUsIHI1KSxcblxuICAgICAgICApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRDeWNsb3RvbWljRXhwKGV4cG9uZW50LCBmbk5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhwb25lbnROYWZCeXRlcyA9IG5hZihleHBvbmVudCkubWFwKCAoYikgPT4gKGI9PS0xID8gMHhGRjogYikgKTtcbiAgICAgICAgY29uc3QgcEV4cG9uZW50TmFmQnl0ZXMgPSBtb2R1bGUuYWxsb2MoZXhwb25lbnROYWZCeXRlcyk7XG5cbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX19jeWNsb3RvbWljRXhwX1wiK2ZuTmFtZSk7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImJpdFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcImlcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCB4ID0gYy5nZXRMb2NhbChcInhcIik7XG5cbiAgICAgICAgY29uc3QgcmVzID0gYy5nZXRMb2NhbChcInJcIik7XG5cbiAgICAgICAgY29uc3QgaW52ZXJzZSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmdHNpemUpKTtcblxuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9jb25qdWdhdGVcIiwgeCwgaW52ZXJzZSksXG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfb25lXCIsIHJlcyksXG5cbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy50ZWVMb2NhbChcImJpdFwiLCBjLmkzMl9sb2FkOF9zKGMuaTMyX2NvbnN0KGV4cG9uZW50TmFmQnl0ZXMubGVuZ3RoLTEpLCBwRXhwb25lbnROYWZCeXRlcykpLFxuICAgICAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImJpdFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KDEpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgcmVzLCB4LCByZXMpLFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsXCIsIHJlcywgaW52ZXJzZSwgcmVzKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9jb25zdChleHBvbmVudE5hZkJ5dGVzLmxlbmd0aC0yKSksXG4gICAgICAgICAgICBjLmJsb2NrKGMubG9vcChcbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX2N5Y2xvdG9taWNTcXVhcmVcIiwgcmVzLCByZXMpLFxuICAgICAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgICAgIGMudGVlTG9jYWwoXCJiaXRcIiwgYy5pMzJfbG9hZDhfcyhjLmdldExvY2FsKFwiaVwiKSwgcEV4cG9uZW50TmFmQnl0ZXMpKSxcbiAgICAgICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJiaXRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsXCIsIHJlcywgeCwgcmVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgcmVzLCBpbnZlcnNlLCByZXMpLFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmJyX2lmKDEsIGMuaTMyX2VxeiAoIGMuZ2V0TG9jYWwoXCJpXCIpICkpLFxuICAgICAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX3N1YihjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QoMSkpKSxcbiAgICAgICAgICAgICAgICBjLmJyKDApXG4gICAgICAgICAgICApKVxuICAgICAgICApO1xuICAgIH1cblxuXG5cbiAgICBmdW5jdGlvbiBidWlsZEZpbmFsRXhwb25lbnRpYXRpb25MYXN0Q2h1bmsoKSB7XG4gICAgICAgIGJ1aWxkQ3ljbG90b21pY1NxdWFyZSgpO1xuICAgICAgICBidWlsZEN5Y2xvdG9taWNFeHAoZmluYWxFeHBaLCBcIncwXCIpO1xuXG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4KyBcIl9fZmluYWxFeHBvbmVudGlhdGlvbkxhc3RDaHVua1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgZWx0ID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCBBID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBCID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBDID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBEID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBFID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBGID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBHID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBIID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBJID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBKID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBLID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBMID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBNID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBOID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBPID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBQID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBRID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBSID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBTID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBUID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCBVID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcblxuXG4gICAgICAgICAgICAvLyBBID0gZXhwX2J5X25lZ196KGVsdCkgIC8vID0gZWx0XigteilcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9fY3ljbG90b21pY0V4cF93MFwiLCBlbHQsIEEpLFxuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX2Nvbmp1Z2F0ZVwiLCBBLCBBKSxcbiAgICAgICAgICAgIC8vIEIgPSBBXjIgICAgICAgICAgICAgICAgLy8gPSBlbHReKC0yKnopXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX2N5Y2xvdG9taWNTcXVhcmVcIiwgQSwgQiksXG4gICAgICAgICAgICAvLyBDID0gQl4yICAgICAgICAgICAgICAgIC8vID0gZWx0XigtNCp6KVxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX19jeWNsb3RvbWljU3F1YXJlXCIsIEIsIEMpLFxuICAgICAgICAgICAgLy8gRCA9IEMgKiBCICAgICAgICAgICAgICAvLyA9IGVsdF4oLTYqeilcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgQywgQiwgRCksXG4gICAgICAgICAgICAvLyBFID0gZXhwX2J5X25lZ196KEQpICAgIC8vID0gZWx0Xig2KnpeMilcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9fY3ljbG90b21pY0V4cF93MFwiLCBELCBFKSxcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9jb25qdWdhdGVcIiwgRSwgRSksXG4gICAgICAgICAgICAvLyBGID0gRV4yICAgICAgICAgICAgICAgIC8vID0gZWx0XigxMip6XjIpXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX2N5Y2xvdG9taWNTcXVhcmVcIiwgRSwgRiksXG4gICAgICAgICAgICAvLyBHID0gZXB4X2J5X25lZ196KEYpICAgIC8vID0gZWx0XigtMTIqel4zKVxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX19jeWNsb3RvbWljRXhwX3cwXCIsIEYsIEcpLFxuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX2Nvbmp1Z2F0ZVwiLCBHLCBHKSxcbiAgICAgICAgICAgIC8vIEggPSBjb25qKEQpICAgICAgICAgICAgLy8gPSBlbHReKDYqeilcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9jb25qdWdhdGVcIiwgRCwgSCksXG4gICAgICAgICAgICAvLyBJID0gY29uaihHKSAgICAgICAgICAgIC8vID0gZWx0XigxMip6XjMpXG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfY29uanVnYXRlXCIsIEcsIEkpLFxuICAgICAgICAgICAgLy8gSiA9IEkgKiBFICAgICAgICAgICAgICAvLyA9IGVsdF4oMTIqel4zICsgNip6XjIpXG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsXCIsIEksIEUsIEopLFxuICAgICAgICAgICAgLy8gSyA9IEogKiBIICAgICAgICAgICAgICAvLyA9IGVsdF4oMTIqel4zICsgNip6XjIgKyA2KnopXG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsXCIsIEosIEgsIEspLFxuICAgICAgICAgICAgLy8gTCA9IEsgKiBCICAgICAgICAgICAgICAvLyA9IGVsdF4oMTIqel4zICsgNip6XjIgKyA0KnopXG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsXCIsIEssIEIsIEwpLFxuICAgICAgICAgICAgLy8gTSA9IEsgKiBFICAgICAgICAgICAgICAvLyA9IGVsdF4oMTIqel4zICsgMTIqel4yICsgNip6KVxuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX211bFwiLCBLLCBFLCBNKSxcblxuICAgICAgICAgICAgLy8gTiA9IE0gKiBlbHQgICAgICAgICAgICAvLyA9IGVsdF4oMTIqel4zICsgMTIqel4yICsgNip6ICsgMSlcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgTSwgZWx0LCBOKSxcblxuICAgICAgICAgICAgLy8gTyA9IEwuRnJvYmVuaXVzX21hcCgxKSAvLyA9IGVsdF4ocSooMTIqel4zICsgNip6XjIgKyA0KnopKVxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX19mcm9iZW5pdXNNYXAxXCIsIEwsIE8pLFxuICAgICAgICAgICAgLy8gUCA9IE8gKiBOICAgICAgICAgICAgICAvLyA9IGVsdF4ocSooMTIqel4zICsgNip6XjIgKyA0KnopICogKDEyKnpeMyArIDEyKnpeMiArIDYqeiArIDEpKVxuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX211bFwiLCBPLCBOLCBQKSxcbiAgICAgICAgICAgIC8vIFEgPSBLLkZyb2Jlbml1c19tYXAoMikgLy8gPSBlbHReKHFeMiAqICgxMip6XjMgKyA2KnpeMiArIDYqeikpXG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX2Zyb2Jlbml1c01hcDJcIiwgSywgUSksXG4gICAgICAgICAgICAvLyBSID0gUSAqIFAgICAgICAgICAgICAgIC8vID0gZWx0XihxXjIgKiAoMTIqel4zICsgNip6XjIgKyA2KnopICsgcSooMTIqel4zICsgNip6XjIgKyA0KnopICogKDEyKnpeMyArIDEyKnpeMiArIDYqeiArIDEpKVxuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX211bFwiLCBRLCBQLCBSKSxcbiAgICAgICAgICAgIC8vIFMgPSBjb25qKGVsdCkgICAgICAgICAgLy8gPSBlbHReKC0xKVxuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX2Nvbmp1Z2F0ZVwiLCBlbHQsIFMpLFxuICAgICAgICAgICAgLy8gVCA9IFMgKiBMICAgICAgICAgICAgICAvLyA9IGVsdF4oMTIqel4zICsgNip6XjIgKyA0KnogLSAxKVxuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX211bFwiLCBTLCBMLCBUKSxcbiAgICAgICAgICAgIC8vIFUgPSBULkZyb2Jlbml1c19tYXAoMykgLy8gPSBlbHReKHFeMygxMip6XjMgKyA2KnpeMiArIDQqeiAtIDEpKVxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX19mcm9iZW5pdXNNYXAzXCIsIFQsIFUpLFxuICAgICAgICAgICAgLy8gViA9IFUgKiBSICAgICAgICAgICAgICAvLyA9IGVsdF4ocV4zKDEyKnpeMyArIDYqel4yICsgNCp6IC0gMSkgKyBxXjIgKiAoMTIqel4zICsgNip6XjIgKyA2KnopICsgcSooMTIqel4zICsgNip6XjIgKyA0KnopICogKDEyKnpeMyArIDEyKnpeMiArIDYqeiArIDEpKVxuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX211bFwiLCBVLCBSLCByZXN1bHQpLFxuICAgICAgICAgICAgLy8gcmVzdWx0ID0gVlxuICAgICAgICApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRGaW5hbEV4cG9uZW50aWF0aW9uKCkge1xuICAgICAgICBidWlsZEZpbmFsRXhwb25lbnRpYXRpb25GaXJzdENodW5rKCk7XG4gICAgICAgIGJ1aWxkRmluYWxFeHBvbmVudGlhdGlvbkxhc3RDaHVuaygpO1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfZmluYWxFeHBvbmVudGlhdGlvblwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgZWx0ID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCBlbHRUb0ZpcnN0Q2h1bmsgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZnRzaXplKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX19maW5hbEV4cG9uZW50aWF0aW9uRmlyc3RDaHVua1wiLCBlbHQsIGVsdFRvRmlyc3RDaHVuayApLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX19maW5hbEV4cG9uZW50aWF0aW9uTGFzdENodW5rXCIsIGVsdFRvRmlyc3RDaHVuaywgcmVzdWx0IClcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRmluYWxFeHBvbmVudGlhdGlvbk9sZCgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX2ZpbmFsRXhwb25lbnRpYXRpb25PbGRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBleHBvbmVudCA9IDU1MjQ4NDIzMzYxMzIyNDA5NjMxMjYxNzEyNjc4MzE3MzE0NzA5NzM4MjEwMzc2Mjk1NzY1NDE4ODg4MjczNDMxNDE5NjkxMDgzOTkwNzU0MTIxMzk3NDUwMjc2MTU0MDYyOTgxNzAwOTYwODU0ODY1NDY4MDM0MzYyNzcwMTE1MzgyOTQ0Njc0NzgxMDkwNzM3MzI1Njg0MTU1MTAwNjIwMTYzOTY3NzcyNjEzOTk0NjAyOTE5OTk2ODQxMjU5ODgwNDg4MjM5MTcwMjI3MzAxOTA4MzY1MzI3MjA0NzU2NjMxNjU4NDM2NTU1OTc3NjQ5MzAyNzQ5NTQ1ODIzODM3MzkwMjg3NTkzNzY1OTk0MzUwNDg3MzIyMDU1NDE2MTU1MDUyNTkyNjMwMjMwMzMzMTc0NzQ2MzUxNTY0NDcxMTg3NjY1MzE3NzEyOTU3ODMwMzE5MTA5NTkwMDkwOTE5MTYyNDgxNzgyNjU2NjY4ODI0MTgwNDQwODA4MTg5Mjc4NTcyNTk2NzkzMTcxNDA5NzcxNjcwOTUyNjA5MjI2MTI3ODA3MTk1MjU2MDE3MTExMTQ0NDA3MjA0OTIyOTEyMzU2NTA1NzQ4Mzc1MDE2MTQ2MDAyNDM1MzM0NjI4NDE2NzI4MjQ1Mjc1NjIxNzY2MjMzNTUyODgxMzUxOTEzOTgwODI5MTE3MDUzOTA3MjEyNTM4MTIzMDgxNTcyOTA3MTU0NDg2MTYwMjc1MDkzNjk2NDgyOTMxMzYwODEzNzMyNTQyNjM4MzczNTEyMjE3NTIyOTU0MTE1NTM3NjM0NjQzNjA5MzkzMDI4NzQwMjA4OTUxNzQyNjk3MzE3ODkxNzU2OTcxMzM4NDc0ODA4MTgyNzI1NTQ3MjU3NjkzNzQ3MTQ5NjE5NTc1MjcyNzE4ODI2MTQzNTYzMzI3MTIzODcxMDEzMTczNjA5NjI5OTc5ODE2ODg1MjkyNTU0MDU0OTM0MjMzMDc3NTI3OTg3NzAwNjc4NDM1NDgwMTQyMjI0OTcyMjU3Mzc4MzU2MTY4NTE3OTYxODgxNjQ4MDAzNzY5NTAwNTUxNTQyNjE2MjM2MjQzMTA3MjI0NTYzODMyNDc0NDQ4MG47XG5cbiAgICAgICAgY29uc3QgcEV4cG9uZW50ID0gbW9kdWxlLmFsbG9jKHV0aWxzJDIuYmlnSW50MkJ5dGVzTEUoIGV4cG9uZW50LCAzNTIgKSk7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfZXhwXCIsIGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChwRXhwb25lbnQpLCBjLmkzMl9jb25zdCgzNTIpLCBjLmdldExvY2FsKFwiclwiKSksXG4gICAgICAgICk7XG4gICAgfVxuXG5cblxuXG4gICAgY29uc3QgcFByZVAgPSBtb2R1bGUuYWxsb2MocHJlUFNpemUpO1xuICAgIGNvbnN0IHBQcmVRID0gbW9kdWxlLmFsbG9jKHByZVFTaXplKTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkUGFpcmluZ0VxdWF0aW9uKG5QYWlyaW5ncykge1xuXG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4KyBcIl9wYWlyaW5nRXFcIituUGFpcmluZ3MpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBhaXJpbmdzOyBpKyspIHtcbiAgICAgICAgICAgIGYuYWRkUGFyYW0oXCJwX1wiK2ksIFwiaTMyXCIpO1xuICAgICAgICAgICAgZi5hZGRQYXJhbShcInFfXCIraSwgXCJpMzJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZi5hZGRQYXJhbShcImNcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcblxuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgcmVzVCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmdHNpemUpKTtcbiAgICAgICAgY29uc3QgYXV4VCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmdHNpemUpKTtcblxuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKGZ0bVByZWZpeCArIFwiX29uZVwiLCByZXNUICkpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuUGFpcmluZ3M7IGkrKykge1xuXG4gICAgICAgICAgICBmLmFkZENvZGUoYy5jYWxsKHByZWZpeCArIFwiX3ByZXBhcmVHMVwiLCBjLmdldExvY2FsKFwicF9cIitpKSwgYy5pMzJfY29uc3QocFByZVApICkpO1xuICAgICAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl9wcmVwYXJlRzJcIiwgYy5nZXRMb2NhbChcInFfXCIraSksIGMuaTMyX2NvbnN0KHBQcmVRKSApKTtcbiAgICAgICAgICAgIGYuYWRkQ29kZShjLmNhbGwocHJlZml4ICsgXCJfbWlsbGVyTG9vcFwiLCBjLmkzMl9jb25zdChwUHJlUCksIGMuaTMyX2NvbnN0KHBQcmVRKSwgYXV4VCApKTtcblxuICAgICAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgcmVzVCwgYXV4VCwgcmVzVCApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwocHJlZml4ICsgXCJfZmluYWxFeHBvbmVudGlhdGlvblwiLCByZXNULCByZXNUICkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwoZnRtUHJlZml4ICsgXCJfZXFcIiwgcmVzVCwgYy5nZXRMb2NhbChcImNcIikpKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkUGFpcmluZygpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfcGFpcmluZ1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHJlc1QgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZnRzaXplKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl9wcmVwYXJlRzFcIiwgYy5nZXRMb2NhbChcInBcIiksIGMuaTMyX2NvbnN0KHBQcmVQKSApKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl9wcmVwYXJlRzJcIiwgYy5nZXRMb2NhbChcInFcIiksIGMuaTMyX2NvbnN0KHBQcmVRKSApKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl9taWxsZXJMb29wXCIsIGMuaTMyX2NvbnN0KHBQcmVQKSwgYy5pMzJfY29uc3QocFByZVEpLCByZXNUICkpO1xuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKHByZWZpeCArIFwiX2ZpbmFsRXhwb25lbnRpYXRpb25cIiwgcmVzVCwgYy5nZXRMb2NhbChcInJcIikgKSk7XG4gICAgfVxuXG5cbiAgICBidWlsZFByZXBBZGRTdGVwKCk7XG4gICAgYnVpbGRQcmVwRG91YmxlU3RlcCgpO1xuXG4gICAgYnVpbGRQcmVwYXJlRzEoKTtcbiAgICBidWlsZFByZXBhcmVHMigpO1xuXG4gICAgYnVpbGRNdWxCeTAyNCgpO1xuICAgIGJ1aWxkTXVsQnkwMjRPbGQoKTtcbiAgICBidWlsZE1pbGxlckxvb3AoKTtcblxuXG4gICAgZm9yIChsZXQgaT0wOyBpPDEwOyBpKyspIHtcbiAgICAgICAgYnVpbGRGcm9iZW5pdXNNYXAoaSk7XG4gICAgICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9fZnJvYmVuaXVzTWFwXCIraSk7XG4gICAgfVxuXG4gICAgYnVpbGRGaW5hbEV4cG9uZW50aWF0aW9uT2xkKCk7XG4gICAgYnVpbGRGaW5hbEV4cG9uZW50aWF0aW9uKCk7XG5cbiAgICBmb3IgKGxldCBpPTE7IGk8PTU7IGkrKykge1xuICAgICAgICBidWlsZFBhaXJpbmdFcXVhdGlvbihpKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3BhaXJpbmdFcVwiK2kpO1xuICAgIH1cblxuICAgIGJ1aWxkUGFpcmluZygpO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3BhaXJpbmdcIik7XG5cbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfcHJlcGFyZUcxXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9wcmVwYXJlRzJcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX21pbGxlckxvb3BcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2ZpbmFsRXhwb25lbnRpYXRpb25cIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX2ZpbmFsRXhwb25lbnRpYXRpb25PbGRcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX19tdWxCeTAyNFwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfX211bEJ5MDI0T2xkXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9fY3ljbG90b21pY1NxdWFyZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfX2N5Y2xvdG9taWNFeHBfdzBcIik7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhtb2R1bGUuZnVuY3Rpb25JZHhCeU5hbWUpO1xuXG59O1xuXG5jb25zdCB1dGlscyQxID0gdXRpbHMkNjtcblxuY29uc3QgYnVpbGRGMW0gPWJ1aWxkX2YxbTtcbmNvbnN0IGJ1aWxkRjEgPWJ1aWxkX2YxO1xuY29uc3QgYnVpbGRGMm0gPWJ1aWxkX2YybTtcbmNvbnN0IGJ1aWxkRjNtID1idWlsZF9mM207XG5jb25zdCBidWlsZEN1cnZlID1idWlsZF9jdXJ2ZV9qYWNvYmlhbl9hMDtcbmNvbnN0IGJ1aWxkRkZUJDEgPSBidWlsZF9mZnQ7XG5jb25zdCBidWlsZFBvbCA9IGJ1aWxkX3BvbDtcbmNvbnN0IGJ1aWxkUUFQID0gYnVpbGRfcWFwO1xuY29uc3QgYnVpbGRBcHBseUtleSA9IGJ1aWxkX2FwcGx5a2V5O1xuY29uc3QgeyBiaXRMZW5ndGg6IGJpdExlbmd0aCQxLCBpc09kZCwgaXNOZWdhdGl2ZTogaXNOZWdhdGl2ZSQxIH0gPSBiaWdpbnQ7XG5cbi8vIERlZmluaXRpb24gaGVyZTogaHR0cHM6Ly9lbGVjdHJpY2NvaW4uY28vYmxvZy9uZXctc25hcmstY3VydmUvXG5cbnZhciBidWlsZF9ibHMxMjM4MSA9IGZ1bmN0aW9uIGJ1aWxkQkxTMTIzODEobW9kdWxlLCBfcHJlZml4KSB7XG5cbiAgICBjb25zdCBwcmVmaXggPSBfcHJlZml4IHx8IFwiYmxzMTIzODFcIjtcblxuICAgIGlmIChtb2R1bGUubW9kdWxlc1twcmVmaXhdKSByZXR1cm4gcHJlZml4OyAgLy8gYWxyZWFkeSBidWlsZGVkXG5cbiAgICBjb25zdCBxID0gMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgIGNvbnN0IHIgPSAweDczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDFuO1xuXG4gICAgY29uc3QgbjY0cSA9IE1hdGguZmxvb3IoKGJpdExlbmd0aCQxKHEgLSAxbikgLSAxKS82NCkgKzE7XG4gICAgY29uc3QgbjhxID0gbjY0cSo4O1xuICAgIGNvbnN0IGYxc2l6ZSA9IG44cTtcbiAgICBjb25zdCBmMnNpemUgPSBmMXNpemUgKiAyO1xuICAgIGNvbnN0IGZ0c2l6ZSA9IGYxc2l6ZSAqIDEyO1xuXG4gICAgY29uc3QgbjY0ciA9IE1hdGguZmxvb3IoKGJpdExlbmd0aCQxKHIgLSAxbikgLSAxKS82NCkgKzE7XG4gICAgY29uc3QgbjhyID0gbjY0cio4O1xuICAgIGNvbnN0IGZyc2l6ZSA9IG44cjtcblxuXG4gICAgY29uc3QgcHIgPSBtb2R1bGUuYWxsb2ModXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggciwgZnJzaXplICkpO1xuXG4gICAgY29uc3QgZjFtUHJlZml4ID0gYnVpbGRGMW0obW9kdWxlLCBxLCBcImYxbVwiLCBcImludHFcIik7XG4gICAgYnVpbGRGMShtb2R1bGUsIHIsIFwiZnJcIiwgXCJmcm1cIiwgXCJpbnRyXCIpO1xuICAgIGNvbnN0IHBHMWIgPSBtb2R1bGUuYWxsb2ModXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDRuKSwgZjFzaXplICkpO1xuICAgIGNvbnN0IGcxbVByZWZpeCA9IGJ1aWxkQ3VydmUobW9kdWxlLCBcImcxbVwiLCBcImYxbVwiLCBwRzFiKTtcblxuICAgIGJ1aWxkRkZUJDEobW9kdWxlLCBcImZybVwiLCBcImZybVwiLCBcImZybVwiLCBcImZybV9tdWxcIik7XG5cbiAgICBidWlsZFBvbChtb2R1bGUsIFwicG9sXCIsIFwiZnJtXCIpO1xuICAgIGJ1aWxkUUFQKG1vZHVsZSwgXCJxYXBcIiwgXCJmcm1cIik7XG5cbiAgICBjb25zdCBmMm1QcmVmaXggPSBidWlsZEYybShtb2R1bGUsIFwiZjFtX25lZ1wiLCBcImYybVwiLCBcImYxbVwiKTtcbiAgICBjb25zdCBwRzJiID0gbW9kdWxlLmFsbG9jKFtcbiAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDRuKSwgZjFzaXplICksXG4gICAgICAgIC4uLnV0aWxzJDEuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeSg0biksIGYxc2l6ZSApXG4gICAgXSk7XG4gICAgY29uc3QgZzJtUHJlZml4ID0gYnVpbGRDdXJ2ZShtb2R1bGUsIFwiZzJtXCIsIFwiZjJtXCIsIHBHMmIpO1xuXG5cbiAgICBmdW5jdGlvbiBidWlsZEdUaW1lc0ZyKGZuTmFtZSwgb3BNdWwpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihmbk5hbWUpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicEdcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwRnJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IEFVWCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhuOHIpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoXCJmcm1fZnJvbU1vbnRnb21lcnlcIiwgYy5nZXRMb2NhbChcInBGclwiKSwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICBvcE11bCxcbiAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwicEdcIiksXG4gICAgICAgICAgICAgICAgQVVYLFxuICAgICAgICAgICAgICAgIGMuaTMyX2NvbnN0KG44ciksXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInByXCIpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKGZuTmFtZSk7XG4gICAgfVxuICAgIGJ1aWxkR1RpbWVzRnIoXCJnMW1fdGltZXNGclwiLCBcImcxbV90aW1lc1NjYWxhclwiKTtcbiAgICBidWlsZEZGVCQxKG1vZHVsZSwgXCJnMW1cIiwgXCJnMW1cIiwgXCJmcm1cIiwgXCJnMW1fdGltZXNGclwiKTtcblxuICAgIGJ1aWxkR1RpbWVzRnIoXCJnMm1fdGltZXNGclwiLCBcImcybV90aW1lc1NjYWxhclwiKTtcbiAgICBidWlsZEZGVCQxKG1vZHVsZSwgXCJnMm1cIiwgXCJnMm1cIiwgXCJmcm1cIiwgXCJnMm1fdGltZXNGclwiKTtcblxuICAgIGJ1aWxkR1RpbWVzRnIoXCJnMW1fdGltZXNGckFmZmluZVwiLCBcImcxbV90aW1lc1NjYWxhckFmZmluZVwiKTtcbiAgICBidWlsZEdUaW1lc0ZyKFwiZzJtX3RpbWVzRnJBZmZpbmVcIiwgXCJnMm1fdGltZXNTY2FsYXJBZmZpbmVcIik7XG5cbiAgICBidWlsZEFwcGx5S2V5KG1vZHVsZSwgXCJmcm1fYmF0Y2hBcHBseUtleVwiLCBcImZtclwiLCBcImZybVwiLCBuOHIsIG44ciwgbjhyLCBcImZybV9tdWxcIik7XG4gICAgYnVpbGRBcHBseUtleShtb2R1bGUsIFwiZzFtX2JhdGNoQXBwbHlLZXlcIiwgXCJnMW1cIiwgXCJmcm1cIiwgbjhxKjMsIG44cSozLCBuOHIsIFwiZzFtX3RpbWVzRnJcIik7XG4gICAgYnVpbGRBcHBseUtleShtb2R1bGUsIFwiZzFtX2JhdGNoQXBwbHlLZXlNaXhlZFwiLCBcImcxbVwiLCBcImZybVwiLCBuOHEqMiwgbjhxKjMsIG44ciwgXCJnMW1fdGltZXNGckFmZmluZVwiKTtcbiAgICBidWlsZEFwcGx5S2V5KG1vZHVsZSwgXCJnMm1fYmF0Y2hBcHBseUtleVwiLCBcImcybVwiLCBcImZybVwiLCBuOHEqMiozLCBuOHEqMyoyLCBuOHIsIFwiZzJtX3RpbWVzRnJcIik7XG4gICAgYnVpbGRBcHBseUtleShtb2R1bGUsIFwiZzJtX2JhdGNoQXBwbHlLZXlNaXhlZFwiLCBcImcybVwiLCBcImZybVwiLCBuOHEqMioyLCBuOHEqMyoyLCBuOHIsIFwiZzJtX3RpbWVzRnJBZmZpbmVcIik7XG5cblxuICAgIGZ1bmN0aW9uIHRvTW9udGdvbWVyeShhKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQoYSkgKiAoMW4gPDwgQmlnSW50KGYxc2l6ZSo4KSkgJSBxO1xuICAgIH1cblxuICAgIGNvbnN0IEcxZ2VuID0gW1xuICAgICAgICAzNjg1NDE2NzUzNzEzMzg3MDE2NzgxMDg4MzE1MTgzMDc3NzU3OTYxNjIwNzk1NzgyNTQ2NDA5ODk0NTc4Mzc4Njg4NjA3NTkyMzc4Mzc2MzE4ODM2MDU0OTQ3Njc2MzQ1ODIxNTQ4MTA0MTg1NDY0NTA3bixcbiAgICAgICAgMTMzOTUwNjU0NDk0NDQ3NjQ3MzAyMDQ3MTM3OTk0MTkyMTIyMTU4NDkzMzg3NTkzODM0OTYyMDQyNjU0MzczNjQxNjUxMTQyMzk1NjMzMzUwNjQ3MjcyNDY1NTM1MzM2NjUzNDk5MjM5MTc1NjQ0MTU2OW4sXG4gICAgICAgIDFuXG4gICAgXTtcblxuICAgIGNvbnN0IHBHMWdlbiA9IG1vZHVsZS5hbGxvYyhcbiAgICAgICAgW1xuICAgICAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcxZ2VuWzBdKSwgZjFzaXplICksXG4gICAgICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoRzFnZW5bMV0pLCBmMXNpemUgKSxcbiAgICAgICAgICAgIC4uLnV0aWxzJDEuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeShHMWdlblsyXSksIGYxc2l6ZSApLFxuICAgICAgICBdXG4gICAgKTtcblxuICAgIGNvbnN0IEcxemVybyA9IFtcbiAgICAgICAgMG4sXG4gICAgICAgIDFuLFxuICAgICAgICAwblxuICAgIF07XG5cbiAgICBjb25zdCBwRzF6ZXJvID0gbW9kdWxlLmFsbG9jKFxuICAgICAgICBbXG4gICAgICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoRzF6ZXJvWzBdKSwgZjFzaXplICksXG4gICAgICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoRzF6ZXJvWzFdKSwgZjFzaXplICksXG4gICAgICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoRzF6ZXJvWzJdKSwgZjFzaXplIClcbiAgICAgICAgXVxuICAgICk7XG5cbiAgICBjb25zdCBHMmdlbiA9IFtcbiAgICAgICAgW1xuICAgICAgICAgICAgMzUyNzAxMDY5NTg3NDY2NjE4MTg3MTM5MTE2MDExMDYwMTQ0ODkwMDI5OTUyNzkyNzc1MjQwMjE5OTA4NjQ0MjM5NzkzNzg1NzM1NzE1MDI2ODczMzQ3NjAwMzQzODY1MTc1OTUyNzYxOTI2MzAzMTYwbixcbiAgICAgICAgICAgIDMwNTkxNDQzNDQyNDQyMTM3MDk5NzEyNTk4MTQ3NTM3ODE2MzY5ODY0NzAzMjU0NzY2NDc1NTg2NTkzNzMyMDYyOTE2MzUzMjQ3Njg5NTg0MzI0MzM1MDk1NjMxMDQzNDcwMTc4Mzc4ODU3NjMzNjU3NThuLFxuICAgICAgICBdLFtcbiAgICAgICAgICAgIDE5ODUxNTA2MDIyODcyOTE5MzU1NjgwNTQ1MjExNzcxNzE2MzgzMDA4Njg5NzgyMTU2NTU3MzA4NTkzNzg2NjUwNjYzNDQ3MjYzNzM4MjM3MTg0MjM4NjkxMDQyNjMzMzM5ODQ2NDE0OTQzNDAzNDc5MDVuLFxuICAgICAgICAgICAgOTI3NTUzNjY1NDkyMzMyNDU1NzQ3MjAxOTY1Nzc2MDM3ODgwNzU3NzQwMTkzNDUzNTkyOTcwMDI1MDI3OTc4NzkzOTc2ODc3MDAyNjc1NTY0OTgwOTQ5Mjg5NzI3OTU3NTY1NTc1NDMzMzQ0MjE5NTgybixcbiAgICAgICAgXSxbXG4gICAgICAgICAgICAxbixcbiAgICAgICAgICAgIDBuLFxuICAgICAgICBdXG4gICAgXTtcblxuICAgIGNvbnN0IHBHMmdlbiA9IG1vZHVsZS5hbGxvYyhcbiAgICAgICAgW1xuICAgICAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyZ2VuWzBdWzBdKSwgZjFzaXplICksXG4gICAgICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoRzJnZW5bMF1bMV0pLCBmMXNpemUgKSxcbiAgICAgICAgICAgIC4uLnV0aWxzJDEuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeShHMmdlblsxXVswXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyZ2VuWzFdWzFdKSwgZjFzaXplICksXG4gICAgICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoRzJnZW5bMl1bMF0pLCBmMXNpemUgKSxcbiAgICAgICAgICAgIC4uLnV0aWxzJDEuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeShHMmdlblsyXVsxXSksIGYxc2l6ZSApLFxuICAgICAgICBdXG4gICAgKTtcblxuICAgIGNvbnN0IEcyemVybyA9IFtcbiAgICAgICAgW1xuICAgICAgICAgICAgMG4sXG4gICAgICAgICAgICAwbixcbiAgICAgICAgXSxbXG4gICAgICAgICAgICAxbixcbiAgICAgICAgICAgIDBuLFxuICAgICAgICBdLFtcbiAgICAgICAgICAgIDBuLFxuICAgICAgICAgICAgMG4sXG4gICAgICAgIF1cbiAgICBdO1xuXG4gICAgY29uc3QgcEcyemVybyA9IG1vZHVsZS5hbGxvYyhcbiAgICAgICAgW1xuICAgICAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1swXVswXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1swXVsxXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1sxXVswXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1sxXVsxXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1syXVswXSksIGYxc2l6ZSApLFxuICAgICAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KEcyemVyb1syXVsxXSksIGYxc2l6ZSApLFxuICAgICAgICBdXG4gICAgKTtcblxuICAgIGNvbnN0IHBPbmVUID0gbW9kdWxlLmFsbG9jKFtcbiAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDFuKSwgZjFzaXplICksXG4gICAgICAgIC4uLnV0aWxzJDEuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeSgwbiksIGYxc2l6ZSApLFxuICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoMG4pLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDBuKSwgZjFzaXplICksXG4gICAgICAgIC4uLnV0aWxzJDEuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeSgwbiksIGYxc2l6ZSApLFxuICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoMG4pLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDBuKSwgZjFzaXplICksXG4gICAgICAgIC4uLnV0aWxzJDEuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeSgwbiksIGYxc2l6ZSApLFxuICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoMG4pLCBmMXNpemUgKSxcbiAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggdG9Nb250Z29tZXJ5KDBuKSwgZjFzaXplICksXG4gICAgICAgIC4uLnV0aWxzJDEuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeSgwbiksIGYxc2l6ZSApLFxuICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoMG4pLCBmMXNpemUgKSxcbiAgICBdKTtcblxuICAgIGNvbnN0IHBCbHMxMjM4MVR3aXN0ID0gIG1vZHVsZS5hbGxvYyhbXG4gICAgICAgIC4uLnV0aWxzJDEuYmlnSW50MkJ5dGVzTEUoIHRvTW9udGdvbWVyeSgxbiksIGYxc2l6ZSApLFxuICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKCB0b01vbnRnb21lcnkoMW4pLCBmMXNpemUgKSxcbiAgICBdKTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkX211bE5SMigpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihmMm1QcmVmaXggKyBcIl9tdWxOUlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwYyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMXNpemUpKTtcbiAgICAgICAgY29uc3QgeDAgPSBjLmdldExvY2FsKFwieFwiKTtcbiAgICAgICAgY29uc3QgeDEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KGYxc2l6ZSkpO1xuICAgICAgICBjb25zdCByMCA9IGMuZ2V0TG9jYWwoXCJwclwiKTtcbiAgICAgICAgY29uc3QgcjEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInByXCIpLCBjLmkzMl9jb25zdChmMXNpemUpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX2NvcHlcIiwgeDAsIHgwYyksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4K1wiX3N1YlwiLCB4MCwgeDEsIHIwKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXgrXCJfYWRkXCIsIHgwYywgeDEsIHIxKSxcbiAgICAgICAgKTtcbiAgICB9XG4gICAgYnVpbGRfbXVsTlIyKCk7XG5cbiAgICBjb25zdCBmNm1QcmVmaXggPSBidWlsZEYzbShtb2R1bGUsIGYybVByZWZpeCtcIl9tdWxOUlwiLCBcImY2bVwiLCBcImYybVwiKTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkX211bE5SNigpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihmNm1QcmVmaXggKyBcIl9tdWxOUlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IGMwY29weSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMXNpemUqMikpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICBmMm1QcmVmaXggKyBcIl9jb3B5XCIsXG4gICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcInhcIiksXG4gICAgICAgICAgICAgICAgYzBjb3B5XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgIGYybVByZWZpeCArIFwiX211bE5SXCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChuOHEqNCkpLFxuICAgICAgICAgICAgICAgIGMuZ2V0TG9jYWwoXCJwclwiKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuY2FsbChcbiAgICAgICAgICAgICAgICBmMm1QcmVmaXggKyBcIl9jb3B5XCIsXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChuOHEqMikpLFxuICAgICAgICAgICAgICAgIGMuaTMyX2FkZChjLmdldExvY2FsKFwicHJcIiksIGMuaTMyX2NvbnN0KG44cSo0KSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5jYWxsKFxuICAgICAgICAgICAgICAgIGYybVByZWZpeCArIFwiX2NvcHlcIixcbiAgICAgICAgICAgICAgICBjMGNvcHksXG4gICAgICAgICAgICAgICAgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwclwiKSwgYy5pMzJfY29uc3QobjhxKjIpKSxcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgfVxuICAgIGJ1aWxkX211bE5SNigpO1xuXG4gICAgY29uc3QgZnRtUHJlZml4ID0gYnVpbGRGMm0obW9kdWxlLCBmNm1QcmVmaXgrXCJfbXVsTlJcIiwgXCJmdG1cIiwgZjZtUHJlZml4KTtcblxuICAgIGNvbnN0IGF0ZUxvb3BDb3VudCA9IDB4ZDIwMTAwMDAwMDAxMDAwMG47XG4gICAgY29uc3QgYXRlTG9vcEJpdEJ5dGVzID0gYml0cyhhdGVMb29wQ291bnQpO1xuICAgIGNvbnN0IHBBdGVMb29wQml0Qnl0ZXMgPSBtb2R1bGUuYWxsb2MoYXRlTG9vcEJpdEJ5dGVzKTtcblxuICAgIGNvbnN0IGF0ZUNvZWZTaXplID0gMyAqIGYyc2l6ZTtcbiAgICBjb25zdCBhdGVORGJsQ29lZnMgPSBhdGVMb29wQml0Qnl0ZXMubGVuZ3RoLTE7XG4gICAgY29uc3QgYXRlTkFkZENvZWZzID0gYXRlTG9vcEJpdEJ5dGVzLnJlZHVjZSgoYWNjLCBiKSA9PiAgYWNjICsgKCBiIT0wID8gMSA6IDApICAgLDApO1xuICAgIGNvbnN0IGF0ZU5Db2VmcyA9IGF0ZU5BZGRDb2VmcyArIGF0ZU5EYmxDb2VmcyArIDE7XG4gICAgY29uc3QgcHJlUFNpemUgPSAzKjIqbjhxO1xuICAgIGNvbnN0IHByZVFTaXplID0gMypuOHEqMiArIGF0ZU5Db2VmcyphdGVDb2VmU2l6ZTtcbiAgICBjb25zdCBmaW5hbEV4cElzTmVnYXRpdmUgPSB0cnVlO1xuXG4gICAgY29uc3QgZmluYWxFeHBaID0gMTUxMzIzNzYyMjI5NDE2NDI3NTJuO1xuXG5cbiAgICBtb2R1bGUubW9kdWxlc1twcmVmaXhdID0ge1xuICAgICAgICBuNjRxOiBuNjRxLFxuICAgICAgICBuNjRyOiBuNjRyLFxuICAgICAgICBuOHE6IG44cSxcbiAgICAgICAgbjhyOiBuOHIsXG4gICAgICAgIHBHMWdlbjogcEcxZ2VuLFxuICAgICAgICBwRzF6ZXJvOiBwRzF6ZXJvLFxuICAgICAgICBwRzFiOiBwRzFiLFxuICAgICAgICBwRzJnZW46IHBHMmdlbixcbiAgICAgICAgcEcyemVybzogcEcyemVybyxcbiAgICAgICAgcEcyYjogcEcyYixcbiAgICAgICAgcHE6IG1vZHVsZS5tb2R1bGVzW1wiZjFtXCJdLnBxLFxuICAgICAgICBwcjogcHIsXG4gICAgICAgIHBPbmVUOiBwT25lVCxcbiAgICAgICAgcjogcixcbiAgICAgICAgcTogcSxcbiAgICAgICAgcHJlUFNpemU6IHByZVBTaXplLFxuICAgICAgICBwcmVRU2l6ZTogcHJlUVNpemVcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBuYWYobikge1xuICAgICAgICBsZXQgRSA9IG47XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoRSA+IDBuKSB7XG4gICAgICAgICAgICBpZiAoaXNPZGQoRSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB6ID0gMiAtIE51bWJlcihFICUgNG4pO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKCB6ICk7XG4gICAgICAgICAgICAgICAgRSA9IEUgLSBCaWdJbnQoeik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKCAwICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBFID0gRSA+PiAxbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpdHMobikge1xuICAgICAgICBsZXQgRSA9IG47XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoRSA+IDBuKSB7XG4gICAgICAgICAgICBpZiAoaXNPZGQoRSkpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCggMSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCggMCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRSA9IEUgPj4gMW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFByZXBhcmVHMSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX3ByZXBhcmVHMVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBQXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicHByZVBcIiwgXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoZzFtUHJlZml4ICsgXCJfbm9ybWFsaXplXCIsIGMuZ2V0TG9jYWwoXCJwUFwiKSwgYy5nZXRMb2NhbChcInBwcmVQXCIpKSwgIC8vIFRPRE8gUmVtb3ZlIGlmIGFscmVhZHkgaW4gYWZmaW5lXG4gICAgICAgICk7XG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkUHJlcERvdWJsZVN0ZXAoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4KyBcIl9wcmVwRGJsU3RlcFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcIlJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgUnggID0gYy5nZXRMb2NhbChcIlJcIik7XG4gICAgICAgIGNvbnN0IFJ5ICA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiUlwiKSwgYy5pMzJfY29uc3QoMipuOHEpKTtcbiAgICAgICAgY29uc3QgUnogID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJSXCIpLCBjLmkzMl9jb25zdCg0Km44cSkpO1xuXG4gICAgICAgIGNvbnN0IHQwICA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCB0MyAgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KDIqbjhxKSk7XG4gICAgICAgIGNvbnN0IHQ2ICA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoNCpuOHEpKTtcblxuXG4gICAgICAgIGNvbnN0IHpzcXVhcmVkID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB0MSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgdDIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHQ0ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB0NSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG5cbiAgICAgICAgICAgIC8vIHRtcDAgPSByLnguc3F1YXJlKCk7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3F1YXJlXCIsIFJ4LCB0MCksXG5cbiAgICAgICAgICAgIC8vIHRtcDEgPSByLnkuc3F1YXJlKCk7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3F1YXJlXCIsIFJ5LCB0MSksXG5cbiAgICAgICAgICAgIC8vIHRtcDIgPSB0bXAxLnNxdWFyZSgpO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3NxdWFyZVwiLCB0MSwgdDIpLFxuXG4gICAgICAgICAgICAvLyB0bXAzID0gKHRtcDEgKyByLngpLnNxdWFyZSgpIC0gdG1wMCAtIHRtcDI7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQxLCBSeCwgdDMpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3NxdWFyZVwiLCB0MywgdDMpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCB0MywgdDAsIHQzKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgdDMsIHQyLCB0MyksXG5cbiAgICAgICAgICAgIC8vIHRtcDMgPSB0bXAzICsgdG1wMztcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdDMsIHQzLCB0MyksXG5cbiAgICAgICAgICAgIC8vIHRtcDQgPSB0bXAwICsgdG1wMCArIHRtcDA7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQwLCB0MCwgdDQpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB0NCwgdDAsIHQ0KSxcblxuICAgICAgICAgICAgLy8gdG1wNiA9IHIueCArIHRtcDQ7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIFJ4LCB0NCwgdDYpLFxuXG4gICAgICAgICAgICAvLyB0bXA1ID0gdG1wNC5zcXVhcmUoKTtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zcXVhcmVcIiwgdDQsIHQ1KSxcblxuICAgICAgICAgICAgLy8genNxdWFyZWQgPSByLnouc3F1YXJlKCk7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3F1YXJlXCIsIFJ6LCB6c3F1YXJlZCksXG5cbiAgICAgICAgICAgIC8vIHIueCA9IHRtcDUgLSB0bXAzIC0gdG1wMztcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgdDUsIHQzLCBSeCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIFJ4LCB0MywgUngpLFxuXG4gICAgICAgICAgICAvLyByLnogPSAoci56ICsgci55KS5zcXVhcmUoKSAtIHRtcDEgLSB6c3F1YXJlZDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgUnosIFJ5LCBSeiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3F1YXJlXCIsIFJ6LCBSeiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIFJ6LCB0MSwgUnopLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCBSeiwgenNxdWFyZWQsIFJ6KSxcblxuICAgICAgICAgICAgLy8gci55ID0gKHRtcDMgLSByLngpICogdG1wNDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgdDMsIFJ4LCBSeSksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIFJ5LCB0NCwgUnkpLFxuXG4gICAgICAgICAgICAvLyB0bXAyID0gdG1wMiArIHRtcDI7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQyLCB0MiwgdDIpLFxuXG4gICAgICAgICAgICAvLyB0bXAyID0gdG1wMiArIHRtcDI7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQyLCB0MiwgdDIpLFxuXG4gICAgICAgICAgICAvLyB0bXAyID0gdG1wMiArIHRtcDI7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQyLCB0MiwgdDIpLFxuXG4gICAgICAgICAgICAvLyByLnkgLT0gdG1wMjtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgUnksIHQyLCBSeSksXG5cbiAgICAgICAgICAgIC8vIHRtcDMgPSB0bXA0ICogenNxdWFyZWQ7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHQ0LCB6c3F1YXJlZCwgdDMpLFxuXG4gICAgICAgICAgICAvLyB0bXAzID0gdG1wMyArIHRtcDM7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQzLCB0MywgdDMpLFxuXG4gICAgICAgICAgICAvLyB0bXAzID0gLXRtcDM7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbmVnXCIsIHQzLCB0MyksXG5cbiAgICAgICAgICAgIC8vIHRtcDYgPSB0bXA2LnNxdWFyZSgpIC0gdG1wMCAtIHRtcDU7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3F1YXJlXCIsIHQ2LCB0NiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQ2LCB0MCwgdDYpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCB0NiwgdDUsIHQ2KSxcblxuICAgICAgICAgICAgLy8gdG1wMSA9IHRtcDEgKyB0bXAxO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB0MSwgdDEsIHQxKSxcblxuICAgICAgICAgICAgLy8gdG1wMSA9IHRtcDEgKyB0bXAxO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB0MSwgdDEsIHQxKSxcblxuICAgICAgICAgICAgLy8gdG1wNiA9IHRtcDYgLSB0bXAxO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCB0NiwgdDEsIHQ2KSxcblxuICAgICAgICAgICAgLy8gdG1wMCA9IHIueiAqIHpzcXVhcmVkO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBSeiwgenNxdWFyZWQsIHQwKSxcblxuICAgICAgICAgICAgLy8gdG1wMCA9IHRtcDAgKyB0bXAwO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB0MCwgdDAsIHQwKSxcblxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkUHJlcEFkZFN0ZXAoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4KyBcIl9wcmVwQWRkU3RlcFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcIlJcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJRXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IFJ4ICA9IGMuZ2V0TG9jYWwoXCJSXCIpO1xuICAgICAgICBjb25zdCBSeSAgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcIlJcIiksIGMuaTMyX2NvbnN0KDIqbjhxKSk7XG4gICAgICAgIGNvbnN0IFJ6ICA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiUlwiKSwgYy5pMzJfY29uc3QoNCpuOHEpKTtcblxuICAgICAgICBjb25zdCBReCAgPSBjLmdldExvY2FsKFwiUVwiKTtcbiAgICAgICAgY29uc3QgUXkgID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJRXCIpLCBjLmkzMl9jb25zdCgyKm44cSkpO1xuXG4gICAgICAgIGNvbnN0IHQxMCAgPSBjLmdldExvY2FsKFwiclwiKTtcbiAgICAgICAgY29uc3QgdDEgID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdCgyKm44cSkpO1xuICAgICAgICBjb25zdCB0OSAgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KDQqbjhxKSk7XG5cbiAgICAgICAgY29uc3QgenNxdWFyZWQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHlzcXVhcmVkID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB6dHNxdWFyZWQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHQwID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB0MiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgdDMgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHQ0ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB0NSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgdDYgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHQ3ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB0OCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG5cbiAgICAgICAgICAgIC8vIHpzcXVhcmVkID0gci56LnNxdWFyZSgpO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3NxdWFyZVwiLCBSeiwgenNxdWFyZWQpLFxuXG4gICAgICAgICAgICAvLyB5c3F1YXJlZCA9IHEueS5zcXVhcmUoKTtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zcXVhcmVcIiwgUXksIHlzcXVhcmVkKSxcblxuICAgICAgICAgICAgLy8gdDAgPSB6c3F1YXJlZCAqIHEueDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgenNxdWFyZWQsIFF4LCB0MCksXG5cbiAgICAgICAgICAgIC8vIHQxID0gKChxLnkgKyByLnopLnNxdWFyZSgpIC0geXNxdWFyZWQgLSB6c3F1YXJlZCkgKiB6c3F1YXJlZDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgUXksIFJ6LCB0MSksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3F1YXJlXCIsIHQxLCB0MSksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQxLCB5c3F1YXJlZCwgdDEpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCB0MSwgenNxdWFyZWQsIHQxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgdDEsIHpzcXVhcmVkLCB0MSksXG5cbiAgICAgICAgICAgIC8vIHQyID0gdDAgLSByLng7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQwLCBSeCwgdDIpLFxuXG4gICAgICAgICAgICAvLyB0MyA9IHQyLnNxdWFyZSgpO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3NxdWFyZVwiLCB0MiwgdDMpLFxuXG4gICAgICAgICAgICAvLyB0NCA9IHQzICsgdDM7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQzLCB0MywgdDQpLFxuXG4gICAgICAgICAgICAvLyB0NCA9IHQ0ICsgdDQ7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQ0LCB0NCwgdDQpLFxuXG4gICAgICAgICAgICAvLyB0NSA9IHQ0ICogdDI7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHQ0LCB0MiwgdDUpLFxuXG4gICAgICAgICAgICAvLyB0NiA9IHQxIC0gci55IC0gci55O1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCB0MSwgUnksIHQ2KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgdDYsIFJ5LCB0NiksXG5cbiAgICAgICAgICAgIC8vIHQ5ID0gdDYgKiBxLng7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHQ2LCBReCwgdDkpLFxuXG4gICAgICAgICAgICAvLyB0NyA9IHQ0ICogci54O1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCB0NCwgUngsIHQ3KSxcblxuICAgICAgICAgICAgLy8gci54ID0gdDYuc3F1YXJlKCkgLSB0NSAtIHQ3IC0gdDc7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3F1YXJlXCIsIHQ2LCBSeCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIFJ4LCB0NSwgUngpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCBSeCwgdDcsIFJ4KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgUngsIHQ3LCBSeCksXG5cbiAgICAgICAgICAgIC8vIHIueiA9IChyLnogKyB0Mikuc3F1YXJlKCkgLSB6c3F1YXJlZCAtIHQzO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBSeiwgdDIsIFJ6KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zcXVhcmVcIiwgUnosIFJ6KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgUnosIHpzcXVhcmVkLCBSeiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIFJ6LCB0MywgUnopLFxuXG4gICAgICAgICAgICAvLyB0MTAgPSBxLnkgKyByLno7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIFF5LCBSeiwgdDEwKSxcblxuICAgICAgICAgICAgLy8gdDggPSAodDcgLSByLngpICogdDY7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQ3LCBSeCwgdDgpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCB0OCwgdDYsIHQ4KSxcblxuICAgICAgICAgICAgLy8gdDAgPSByLnkgKiB0NTtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgUnksIHQ1LCB0MCksXG5cbiAgICAgICAgICAgIC8vIHQwID0gdDAgKyB0MDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdDAsIHQwLCB0MCksXG5cbiAgICAgICAgICAgIC8vIHIueSA9IHQ4IC0gdDA7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQ4LCB0MCwgUnkpLFxuXG4gICAgICAgICAgICAvLyB0MTAgPSB0MTAuc3F1YXJlKCkgLSB5c3F1YXJlZDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zcXVhcmVcIiwgdDEwLCB0MTApLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCB0MTAsIHlzcXVhcmVkLCB0MTApLFxuXG4gICAgICAgICAgICAvLyB6dHNxdWFyZWQgPSByLnouc3F1YXJlKCk7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3F1YXJlXCIsIFJ6LCB6dHNxdWFyZWQpLFxuXG4gICAgICAgICAgICAvLyB0MTAgPSB0MTAgLSB6dHNxdWFyZWQ7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQxMCwgenRzcXVhcmVkLCB0MTApLFxuXG4gICAgICAgICAgICAvLyB0OSA9IHQ5ICsgdDkgLSB0MTA7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQ5LCB0OSwgdDkpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCB0OSwgdDEwLCB0OSksXG5cbiAgICAgICAgICAgIC8vIHQxMCA9IHIueiArIHIuejtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgUnosIFJ6LCB0MTApLFxuXG4gICAgICAgICAgICAvLyB0NiA9IC10NjtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9uZWdcIiwgdDYsIHQ2KSxcblxuICAgICAgICAgICAgLy8gdDEgPSB0NiArIHQ2O1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB0NiwgdDYsIHQxKSxcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkUHJlcGFyZUcyKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfcHJlcGFyZUcyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicFFcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwcHJlUVwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInBDb2VmXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaVwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG5cbiAgICAgICAgY29uc3QgUSA9IGMuZ2V0TG9jYWwoXCJwUVwiKTtcblxuICAgICAgICBjb25zdCBwUiA9IG1vZHVsZS5hbGxvYyhmMnNpemUqMyk7XG4gICAgICAgIGNvbnN0IFIgPSBjLmkzMl9jb25zdChwUik7XG5cbiAgICAgICAgY29uc3QgYmFzZSA9IGMuZ2V0TG9jYWwoXCJwcHJlUVwiKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmNhbGwoZzJtUHJlZml4ICsgXCJfbm9ybWFsaXplXCIsIFEsIGJhc2UpLFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwoZzJtUHJlZml4ICsgXCJfaXNaZXJvXCIsIGJhc2UpLFxuICAgICAgICAgICAgICAgIGMucmV0KFtdKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuY2FsbChnMm1QcmVmaXggKyBcIl9jb3B5XCIsIGJhc2UsIFIpLFxuICAgICAgICAgICAgYy5zZXRMb2NhbChcInBDb2VmXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwicHByZVFcIiksIGMuaTMyX2NvbnN0KGYyc2l6ZSozKSkpLFxuICAgICAgICApO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2NvbnN0KGF0ZUxvb3BCaXRCeXRlcy5sZW5ndGgtMikpLFxuICAgICAgICAgICAgYy5ibG9jayhjLmxvb3AoXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfcHJlcERibFN0ZXBcIiwgUiwgYy5nZXRMb2NhbChcInBDb2VmXCIpKSxcbiAgICAgICAgICAgICAgICBjLnNldExvY2FsKFwicENvZWZcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSwgYy5pMzJfY29uc3QoYXRlQ29lZlNpemUpKSksXG5cbiAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9sb2FkOF9zKGMuZ2V0TG9jYWwoXCJpXCIpLCBwQXRlTG9vcEJpdEJ5dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYy5jYWxsKHByZWZpeCArIFwiX3ByZXBBZGRTdGVwXCIsIFIsIGJhc2UsIGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLnNldExvY2FsKFwicENvZWZcIiwgYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwQ29lZlwiKSwgYy5pMzJfY29uc3QoYXRlQ29lZlNpemUpKSksXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoMSwgYy5pMzJfZXF6ICggYy5nZXRMb2NhbChcImlcIikgKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpXG4gICAgICAgICk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZEY2TXVsMSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihmNm1QcmVmaXgrIFwiX211bDFcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQVwiLCBcImkzMlwiKTsgICAgLy8gRjZcbiAgICAgICAgZi5hZGRQYXJhbShcInBDMVwiLCBcImkzMlwiKTsgICAvLyBGMlxuICAgICAgICBmLmFkZFBhcmFtKFwicFJcIiwgXCJpMzJcIik7ICAgIC8vIEY2XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBBX2MwID0gYy5nZXRMb2NhbChcInBBXCIpO1xuICAgICAgICBjb25zdCBBX2MxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwQVwiKSwgYy5pMzJfY29uc3QoZjFzaXplKjIpKTtcbiAgICAgICAgY29uc3QgQV9jMiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicEFcIiksIGMuaTMyX2NvbnN0KGYxc2l6ZSo0KSk7XG5cbiAgICAgICAgY29uc3QgYzEgID0gYy5nZXRMb2NhbChcInBDMVwiKTtcblxuICAgICAgICBjb25zdCB0MSA9IGMuZ2V0TG9jYWwoXCJwUlwiKTtcbiAgICAgICAgY29uc3QgdDIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBSXCIpLCBjLmkzMl9jb25zdChmMXNpemUqMikpO1xuICAgICAgICBjb25zdCBiX2IgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBSXCIpLCBjLmkzMl9jb25zdChmMXNpemUqNCkpO1xuXG4gICAgICAgIGNvbnN0IEFjMF9BYzEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFzaXplKjIpKTtcbiAgICAgICAgY29uc3QgQWMxX0FjMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMXNpemUqMikpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcblxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBBX2MwLCBBX2MxLCBBYzBfQWMxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgQV9jMSwgQV9jMiwgQWMxX0FjMiksXG5cbiAgICAgICAgICAgIC8vIGxldCBiX2IgPSBzZWxmLmMxICogYzE7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEFfYzEsIGMxLCBiX2IpLFxuXG4gICAgICAgICAgICAvLyBsZXQgdDEgPSAoc2VsZi5jMSArIHNlbGYuYzIpICogYzEgLSBiX2I7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEFjMV9BYzIsIGMxLCB0MSksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQxLCBiX2IsIHQxKSxcblxuICAgICAgICAgICAgLy8gbGV0IHQxID0gdDEubXVsX2J5X25vbnJlc2lkdWUoKTtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxOUlwiLCB0MSwgdDEpLFxuXG4gICAgICAgICAgICAvLyBsZXQgdDIgPSAoc2VsZi5jMCArIHNlbGYuYzEpICogYzEgLSBiX2I7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEFjMF9BYzEsIGMxLCB0MiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQyLCBiX2IsIHQyKSxcbiAgICAgICAgKTtcbiAgICB9XG4gICAgYnVpbGRGNk11bDEoKTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkRjZNdWwwMSgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihmNm1QcmVmaXgrIFwiX211bDAxXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwicEFcIiwgXCJpMzJcIik7ICAgIC8vIEY2XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQzBcIiwgXCJpMzJcIik7ICAgLy8gRjJcbiAgICAgICAgZi5hZGRQYXJhbShcInBDMVwiLCBcImkzMlwiKTsgICAvLyBGMlxuICAgICAgICBmLmFkZFBhcmFtKFwicFJcIiwgXCJpMzJcIik7ICAgIC8vIEY2XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBBX2MwID0gYy5nZXRMb2NhbChcInBBXCIpO1xuICAgICAgICBjb25zdCBBX2MxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwQVwiKSwgYy5pMzJfY29uc3QoZjFzaXplKjIpKTtcbiAgICAgICAgY29uc3QgQV9jMiA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicEFcIiksIGMuaTMyX2NvbnN0KGYxc2l6ZSo0KSk7XG5cbiAgICAgICAgY29uc3QgYzAgID0gYy5nZXRMb2NhbChcInBDMFwiKTtcbiAgICAgICAgY29uc3QgYzEgID0gYy5nZXRMb2NhbChcInBDMVwiKTtcblxuICAgICAgICBjb25zdCB0MSA9IGMuZ2V0TG9jYWwoXCJwUlwiKTtcbiAgICAgICAgY29uc3QgdDIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBSXCIpLCBjLmkzMl9jb25zdChmMXNpemUqMikpO1xuICAgICAgICBjb25zdCB0MyA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicFJcIiksIGMuaTMyX2NvbnN0KGYxc2l6ZSo0KSk7XG5cbiAgICAgICAgY29uc3QgYV9hID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxc2l6ZSoyKSk7XG4gICAgICAgIGNvbnN0IGJfYiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMXNpemUqMikpO1xuICAgICAgICBjb25zdCBBYzBfQWMxID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxc2l6ZSoyKSk7XG4gICAgICAgIGNvbnN0IEFjMF9BYzIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFzaXplKjIpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAvLyBsZXQgYV9hID0gc2VsZi5jMCAqIGMwO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBBX2MwLCBjMCwgYV9hKSxcblxuICAgICAgICAgICAgLy8gbGV0IGJfYiA9IHNlbGYuYzEgKiBjMTtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgQV9jMSwgYzEsIGJfYiksXG5cblxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBBX2MwLCBBX2MxLCBBYzBfQWMxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgQV9jMCwgQV9jMiwgQWMwX0FjMiksXG5cbiAgICAgICAgICAgIC8vIGxldCB0MSA9IChzZWxmLmMxICsgc2VsZi5jMikgKiBjMSAtIGJfYjtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgQV9jMSwgQV9jMiwgdDEpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCB0MSwgYzEsIHQxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgdDEsIGJfYiwgdDEpLFxuXG4gICAgICAgICAgICAvLyBsZXQgdDEgPSB0MS5tdWxfYnlfbm9ucmVzaWR1ZSgpICsgYV9hO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bE5SXCIsIHQxLCB0MSksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQxLCBhX2EsIHQxKSxcblxuICAgICAgICAgICAgLy8gbGV0IHQyID0gKGMwICsgYzEpICogKHNlbGYuYzAgKyBzZWxmLmMxKSAtIGFfYSAtIGJfYjtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgYzAsIGMxLCB0MiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHQyLCBBYzBfQWMxLCB0MiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQyLCBhX2EsIHQyKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgdDIsIGJfYiwgdDIpLFxuXG4gICAgICAgICAgICAvLyBsZXQgdDMgPSAoc2VsZi5jMCArIHNlbGYuYzIpICogYzAgLSBhX2EgKyBiX2I7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEFjMF9BYzIsIGMwLCB0MyksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQzLCBhX2EsIHQzKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdDMsIGJfYiwgdDMpLFxuXG5cbiAgICAgICAgKTtcbiAgICB9XG4gICAgYnVpbGRGNk11bDAxKCk7XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRjEyTXVsMDE0KCkge1xuXG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24oZnRtUHJlZml4KyBcIl9tdWwwMTRcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQVwiLCBcImkzMlwiKTsgICAgLy8gRjEyXG4gICAgICAgIGYuYWRkUGFyYW0oXCJwQzBcIiwgXCJpMzJcIik7ICAgLy8gRjJcbiAgICAgICAgZi5hZGRQYXJhbShcInBDMVwiLCBcImkzMlwiKTsgICAvLyBGMlxuICAgICAgICBmLmFkZFBhcmFtKFwicEM0XCIsIFwiaTMyXCIpOyAgIC8vIEYyXG4gICAgICAgIGYuYWRkUGFyYW0oXCJwUlwiLCBcImkzMlwiKTsgICAgLy8gRjEyXG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuXG4gICAgICAgIGNvbnN0IEFfYzAgPSBjLmdldExvY2FsKFwicEFcIik7XG4gICAgICAgIGNvbnN0IEFfYzEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBBXCIpLCBjLmkzMl9jb25zdChmMXNpemUqNikpO1xuXG4gICAgICAgIGNvbnN0IGMwICA9IGMuZ2V0TG9jYWwoXCJwQzBcIik7XG4gICAgICAgIGNvbnN0IGMxICA9IGMuZ2V0TG9jYWwoXCJwQzFcIik7XG4gICAgICAgIGNvbnN0IGM0ICA9IGMuZ2V0TG9jYWwoXCJwQzRcIik7XG5cbiAgICAgICAgY29uc3QgYWEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFzaXplKjYpKTtcbiAgICAgICAgY29uc3QgYmIgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjFzaXplKjYpKTtcbiAgICAgICAgY29uc3QgbyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMXNpemUqMikpO1xuXG4gICAgICAgIGNvbnN0IFJfYzAgPSBjLmdldExvY2FsKFwicFJcIik7XG4gICAgICAgIGNvbnN0IFJfYzEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBSXCIpLCBjLmkzMl9jb25zdChmMXNpemUqNikpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIC8vIGxldCBhYSA9IHNlbGYuYzAubXVsX2J5XzAxKGMwLCBjMSk7XG4gICAgICAgICAgICBjLmNhbGwoZjZtUHJlZml4ICsgXCJfbXVsMDFcIiwgQV9jMCwgYzAsIGMxLCBhYSksXG5cbiAgICAgICAgICAgIC8vIGxldCBiYiA9IHNlbGYuYzEubXVsX2J5XzEoYzQpO1xuICAgICAgICAgICAgYy5jYWxsKGY2bVByZWZpeCArIFwiX211bDFcIiwgQV9jMSwgYzQsIGJiKSxcblxuICAgICAgICAgICAgLy8gbGV0IG8gPSBjMSArIGM0O1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCBjMSwgYzQsIG8pLFxuXG4gICAgICAgICAgICAvLyBsZXQgYzEgPSBzZWxmLmMxICsgc2VsZi5jMDtcbiAgICAgICAgICAgIGMuY2FsbChmNm1QcmVmaXggKyBcIl9hZGRcIiwgQV9jMSwgQV9jMCwgUl9jMSksXG5cbiAgICAgICAgICAgIC8vIGxldCBjMSA9IGMxLm11bF9ieV8wMShjMCwgJm8pO1xuICAgICAgICAgICAgYy5jYWxsKGY2bVByZWZpeCArIFwiX211bDAxXCIsIFJfYzEsIGMwLCBvLCBSX2MxKSxcblxuICAgICAgICAgICAgLy8gbGV0IGMxID0gYzEgLSBhYSAtIGJiO1xuICAgICAgICAgICAgYy5jYWxsKGY2bVByZWZpeCArIFwiX3N1YlwiLCBSX2MxLCBhYSwgUl9jMSksXG4gICAgICAgICAgICBjLmNhbGwoZjZtUHJlZml4ICsgXCJfc3ViXCIsIFJfYzEsIGJiLCBSX2MxKSxcblxuICAgICAgICAgICAgLy8gbGV0IGMwID0gYmI7XG4gICAgICAgICAgICBjLmNhbGwoZjZtUHJlZml4ICsgXCJfY29weVwiLCBiYiwgUl9jMCksXG5cbiAgICAgICAgICAgIC8vIGxldCBjMCA9IGMwLm11bF9ieV9ub25yZXNpZHVlKCk7XG4gICAgICAgICAgICBjLmNhbGwoZjZtUHJlZml4ICsgXCJfbXVsTlJcIiwgUl9jMCwgUl9jMCksXG5cbiAgICAgICAgICAgIC8vIGxldCBjMCA9IGMwICsgYWE7XG4gICAgICAgICAgICBjLmNhbGwoZjZtUHJlZml4ICsgXCJfYWRkXCIsIFJfYzAsIGFhLCBSX2MwKSxcbiAgICAgICAgKTtcbiAgICB9XG4gICAgYnVpbGRGMTJNdWwwMTQoKTtcblxuXG4gICAgZnVuY3Rpb24gYnVpbGRFTEwoKSB7XG4gICAgICAgIGNvbnN0IGYgPSBtb2R1bGUuYWRkRnVuY3Rpb24ocHJlZml4KyBcIl9lbGxcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwUFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBDb2Vmc1wiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBGXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgUHggID0gYy5nZXRMb2NhbChcInBQXCIpO1xuICAgICAgICBjb25zdCBQeSAgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBQXCIpLCBjLmkzMl9jb25zdChuOHEpKTtcblxuICAgICAgICBjb25zdCBGICA9IGMuZ2V0TG9jYWwoXCJwRlwiKTtcblxuICAgICAgICBjb25zdCBjb2VmMF8wICA9IGMuZ2V0TG9jYWwoXCJwQ29lZnNcIik7XG4gICAgICAgIGNvbnN0IGNvZWYwXzEgID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJwQ29lZnNcIiksIGMuaTMyX2NvbnN0KGYxc2l6ZSkpO1xuICAgICAgICBjb25zdCBjb2VmMV8wICA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicENvZWZzXCIpLCBjLmkzMl9jb25zdChmMXNpemUqMikpO1xuICAgICAgICBjb25zdCBjb2VmMV8xICA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicENvZWZzXCIpLCBjLmkzMl9jb25zdChmMXNpemUqMykpO1xuICAgICAgICBjb25zdCBjb2VmMiAgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBDb2Vmc1wiKSwgYy5pMzJfY29uc3QoZjFzaXplKjQpKTtcblxuICAgICAgICBjb25zdCBwYzAgPSBtb2R1bGUuYWxsb2MoZjFzaXplKjIpO1xuICAgICAgICBjb25zdCBjMCAgPSBjLmkzMl9jb25zdChwYzApO1xuICAgICAgICBjb25zdCBjMF9jMCA9IGMuaTMyX2NvbnN0KHBjMCk7XG4gICAgICAgIGNvbnN0IGMwX2MxID0gYy5pMzJfY29uc3QocGMwK2Yxc2l6ZSk7XG5cbiAgICAgICAgY29uc3QgcGMxID0gbW9kdWxlLmFsbG9jKGYxc2l6ZSoyKTtcbiAgICAgICAgY29uc3QgYzEgID0gYy5pMzJfY29uc3QocGMxKTtcbiAgICAgICAgY29uc3QgYzFfYzAgPSBjLmkzMl9jb25zdChwYzEpO1xuICAgICAgICBjb25zdCBjMV9jMSA9IGMuaTMyX2NvbnN0KHBjMStmMXNpemUpO1xuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAvLyAgICAgbGV0IG11dCBjMCA9IGNvZWZmcy4wO1xuICAgICAgICAgICAgLy8gICAgIGxldCBtdXQgYzEgPSBjb2VmZnMuMTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICBjMC5jMCAqPSBwLnk7XG4gICAgICAgICAgICAvLyAgICBjMC5jMSAqPSBwLnk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgYzEuYzAgKj0gcC54O1xuICAgICAgICAgICAgLy8gICAgYzEuYzEgKj0gcC54O1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICBmLm11bF9ieV8wMTQoJmNvZWZmcy4yLCAmYzEsICZjMClcblxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCBjb2VmMF8wLCBQeSwgYzBfYzApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCBjb2VmMF8xLCBQeSwgYzBfYzEpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCBjb2VmMV8wLCBQeCwgYzFfYzApLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCBjb2VmMV8xLCBQeCwgYzFfYzEpLFxuXG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsMDE0XCIsIEYsIGNvZWYyLCBjMSwgYzAsIEYpLFxuXG4gICAgICAgICk7XG5cbiAgICB9XG4gICAgYnVpbGRFTEwoKTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkTWlsbGVyTG9vcCgpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihwcmVmaXgrIFwiX21pbGxlckxvb3BcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwcHJlUFwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBwcmVRXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcbiAgICAgICAgZi5hZGRMb2NhbChcInBDb2VmXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaVwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHByZVAgPSBjLmdldExvY2FsKFwicHByZVBcIik7XG5cbiAgICAgICAgY29uc3QgY29lZnMgID0gYy5nZXRMb2NhbChcInBDb2VmXCIpO1xuXG4gICAgICAgIGNvbnN0IEYgPSBjLmdldExvY2FsKFwiclwiKTtcblxuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9vbmVcIiwgRiksXG5cbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5jYWxsKGcxbVByZWZpeCArIFwiX2lzWmVyb1wiLCBwcmVQKSxcbiAgICAgICAgICAgICAgICBjLnJldChbXSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuY2FsbChnMW1QcmVmaXggKyBcIl9pc1plcm9cIiwgYy5nZXRMb2NhbChcInBwcmVRXCIpKSxcbiAgICAgICAgICAgICAgICBjLnJldChbXSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjLnNldExvY2FsKFwicENvZWZcIiwgYy5pMzJfYWRkKCBjLmdldExvY2FsKFwicHByZVFcIiksIGMuaTMyX2NvbnN0KGYyc2l6ZSozKSkpLFxuXG4gICAgICAgICAgICBjLnNldExvY2FsKFwiaVwiLCBjLmkzMl9jb25zdChhdGVMb29wQml0Qnl0ZXMubGVuZ3RoLTIpKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuXG5cbiAgICAgICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfZWxsXCIsIHByZVAsIGNvZWZzLCAgRiksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcInBDb2VmXCIsIGMuaTMyX2FkZChjLmdldExvY2FsKFwicENvZWZcIiksIGMuaTMyX2NvbnN0KGF0ZUNvZWZTaXplKSkpLFxuXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfbG9hZDhfcyhjLmdldExvY2FsKFwiaVwiKSwgcEF0ZUxvb3BCaXRCeXRlcyksXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuY2FsbChwcmVmaXggKyBcIl9lbGxcIiwgcHJlUCwgY29lZnMsICBGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMuc2V0TG9jYWwoXCJwQ29lZlwiLCBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBDb2VmXCIpLCBjLmkzMl9jb25zdChhdGVDb2VmU2l6ZSkpKSxcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX3NxdWFyZVwiLCBGLCBGKSxcblxuICAgICAgICAgICAgICAgIGMuYnJfaWYoMSwgYy5pMzJfZXEgKCBjLmdldExvY2FsKFwiaVwiKSwgYy5pMzJfY29uc3QoMSkgKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgYy5jYWxsKHByZWZpeCArIFwiX2VsbFwiLCBwcmVQLCBjb2VmcywgIEYpLFxuXG4gICAgICAgICk7XG5cblxuICAgICAgICB7XG4gICAgICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX2Nvbmp1Z2F0ZVwiLCBGLCBGKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRnJvYmVuaXVzTWFwKG4pIHtcbiAgICAgICAgY29uc3QgRjEyID0gW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgICAgIFsxbiwgMG5dLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMzg1MDc1NDM3MDAzNzE2OTAxMTk1MjE0NzA3NjA1MTM2NDA1NzE1ODgwNzQyMDk3MDY4MjQzODY3NjA1MDUyMjYxMzYyODQyMzIxOTYzNzcyNTA3MjE4MjY5NzExMzA2Mjc3Nzg5MTU4OTUwNjQyNDc2MG4sIDE1MTY1NTE4NTE4NDQ5ODM4MTQ2NTY0Mjc0OTY4NDU0MDA5OTM5ODA3NTM5ODk2ODMyNTQ0NjY1NjAwNzYxMzUxMDQwMzIyNzI3MTIwMDEzOTM3MDUwNDkzMjAxNTk1Mjg4NjE0NjMwNDc2NjEzNTAyN25dLFxuICAgICAgICAgICAgICAgIFs3OTM0NzkzOTA3MjkyMTU1MTI2MjEzNzk3MDE2MzM0MjE0NDcwNjA4ODY3NDAyODEwNjA0OTMwMTA0NTY0ODc0MjcyODE2NDkwNzU0NzYzMDU2MjA3NTg3MzE2MjAzNTFuLCAwbl0sXG4gICAgICAgICAgICAgICAgWzI5NzM2Nzc0MDg5ODY1NjEwNDM0NDI0NjUzNDY1MjAxMDg4NzkxNzIwNDI4ODMwMDkyNDk5ODkxNzY0MTUwMTgwOTE0MjA4MDcxOTIxODI2Mzg1NjcxMTYzMTg1NzY0NzI2NDkzNDcwMTU5MTc2OTA1MzBuLCAxMDI4NzMyMTQ2MjM1MTA2MzQ5OTc1MzI0NDc5MjE1Nzk1Mjc3Mzg0ODM5OTM2OTI5NzU3ODk2MTU1NjQzMTE4MDMyNjEwODQzMjk4NjU1MjI1ODc1NTcxMzEwNTUyNTQzMDE0NjkwODc4MzU0ODY5MjU3bl0sXG4gICAgICAgICAgICAgICAgWzc5MzQ3OTM5MDcyOTIxNTUxMjYyMTM3OTcwMTYzMzQyMTQ0NzA2MDg4Njc0MDI4MTA2MDQ5MzAxMDQ1NjQ4NzQyNzI4MTY0OTA3NTQ3NjMwNTYyMDc1ODczMTYyMDM1MG4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMzEyNTMzMjU5NDE3MTA1OTQyNDkwODEwODA5NjIwNDY0ODk3ODU3MDExODI4MTk3NzU3NTQzNTgzMjQyMjYzMTYwMTgyNDAzNDQ2MzM4Mjc3NzkzNzYyMTI1MDU5MjQyNTUzNTQ5MzMyMDY4MzgyNTU1N24sIDg3NzA3Njk2MTA1MDYwNzk2ODUwOTY4MTcyOTUzMTI1NTE3Nzk4Njc2NDUzNzk2MTQzMjQ0OTQ5OTYzNTUwNDUyMjIwNzYxNjAyNzQ1NTA4NjUwNTA2NjM3ODUzNjU5MDEyODU0NDU3MzU4ODczNDIzMG5dLFxuICAgICAgICAgICAgICAgIFs0MDAyNDA5NTU1MjIxNjY3MzkzNDE3Nzg5ODI1NzM1OTA0MTU2NTU2ODgyODE5OTM5MDA3ODg1MzMyMDU4MTM2MTI0MDMxNjUwNDkwODM3ODY0NDQyNjg3NjI5MTI5MDE1NjY0MDM3ODk0MjcyNTU5Nzg2biwgMG5dLFxuICAgICAgICAgICAgICAgIFsxNTE2NTUxODUxODQ0OTgzODE0NjU2NDI3NDk2ODQ1NDAwOTkzOTgwNzUzOTg5NjgzMjU0NDY2NTYwMDc2MTM1MTA0MDMyMjcyNzEyMDAxMzkzNzA1MDQ5MzIwMTU5NTI4ODYxNDYzMDQ3NjYxMzUwMjduLCAzODUwNzU0MzcwMDM3MTY5MDExOTUyMTQ3MDc2MDUxMzY0MDU3MTU4ODA3NDIwOTcwNjgyNDM4Njc2MDUwNTIyNjEzNjI4NDIzMjE5NjM3NzI1MDcyMTgyNjk3MTEzMDYyNzc3ODkxNTg5NTA2NDI0NzYwbl0sXG4gICAgICAgICAgICAgICAgWzQwMDI0MDk1NTUyMjE2NjczOTI2MjQzMTA0MzUwMDY2ODg2NDM5MzU1MDMxMTgzMDU1ODY0MzgyNzExNzEzOTU4NDI5NzExNTc0ODAzODEzNzcwMTU0MDU5ODAwNTM1MzkzNTg0MTcxMzU1NDA5Mzk0MzZuLCAwbl0sXG4gICAgICAgICAgICAgICAgWzEwMjg3MzIxNDYyMzUxMDYzNDk5NzUzMjQ0NzkyMTU3OTUyNzczODQ4Mzk5MzY5Mjk3NTc4OTYxNTU2NDMxMTgwMzI2MTA4NDMyOTg2NTUyMjU4NzU1NzEzMTA1NTI1NDMwMTQ2OTA4NzgzNTQ4NjkyNTduLCAyOTczNjc3NDA4OTg2NTYxMDQzNDQyNDY1MzQ2NTIwMTA4ODc5MTcyMDQyODgzMDA5MjQ5OTg5MTc2NDE1MDE4MDkxNDIwODA3MTkyMTgyNjM4NTY3MTE2MzE4NTc2NDcyNjQ5MzQ3MDE1OTE3NjkwNTMwbl0sXG4gICAgICAgICAgICAgICAgWzQwMDI0MDk1NTUyMjE2NjczOTI2MjQzMTA0MzUwMDY2ODg2NDM5MzU1MDMxMTgzMDU1ODY0MzgyNzExNzEzOTU4NDI5NzExNTc0ODAzODEzNzcwMTU0MDU5ODAwNTM1MzkzNTg0MTcxMzU1NDA5Mzk0MzduLCAwbl0sXG4gICAgICAgICAgICAgICAgWzg3NzA3Njk2MTA1MDYwNzk2ODUwOTY4MTcyOTUzMTI1NTE3Nzk4Njc2NDUzNzk2MTQzMjQ0OTQ5OTYzNTUwNDUyMjIwNzYxNjAyNzQ1NTA4NjUwNTA2NjM3ODUzNjU5MDEyODU0NDU3MzU4ODczNDIzMG4sIDMxMjUzMzI1OTQxNzEwNTk0MjQ5MDgxMDgwOTYyMDQ2NDg5Nzg1NzAxMTgyODE5Nzc1NzU0MzU4MzI0MjI2MzE2MDE4MjQwMzQ0NjMzODI3Nzc5Mzc2MjEyNTA1OTI0MjU1MzU0OTMzMjA2ODM4MjU1NTduXSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBGNiA9IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgWzFuLCAwbl0sXG4gICAgICAgICAgICAgICAgWzBuLCA0MDAyNDA5NTU1MjIxNjY3MzkyNjI0MzEwNDM1MDA2Njg4NjQzOTM1NTAzMTE4MzA1NTg2NDM4MjcxMTcxMzk1ODQyOTcxMTU3NDgwMzgxMzc3MDE1NDA1OTgwMDUzNTM5MzU4NDE3MTM1NTQwOTM5NDM2bl0sXG4gICAgICAgICAgICAgICAgWzc5MzQ3OTM5MDcyOTIxNTUxMjYyMTM3OTcwMTYzMzQyMTQ0NzA2MDg4Njc0MDI4MTA2MDQ5MzAxMDQ1NjQ4NzQyNzI4MTY0OTA3NTQ3NjMwNTYyMDc1ODczMTYyMDM1MG4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMG4sIDFuXSxcbiAgICAgICAgICAgICAgICBbNDAwMjQwOTU1NTIyMTY2NzM5MjYyNDMxMDQzNTAwNjY4ODY0MzkzNTUwMzExODMwNTU4NjQzODI3MTE3MTM5NTg0Mjk3MTE1NzQ4MDM4MTM3NzAxNTQwNTk4MDA1MzUzOTM1ODQxNzEzNTU0MDkzOTQzNm4sIDBuXSxcbiAgICAgICAgICAgICAgICBbMG4sIDc5MzQ3OTM5MDcyOTIxNTUxMjYyMTM3OTcwMTYzMzQyMTQ0NzA2MDg4Njc0MDI4MTA2MDQ5MzAxMDQ1NjQ4NzQyNzI4MTY0OTA3NTQ3NjMwNTYyMDc1ODczMTYyMDM1MG5dLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbMW4sIDBuXSxcbiAgICAgICAgICAgICAgICBbNDAwMjQwOTU1NTIyMTY2NzM5MjYyNDMxMDQzNTAwNjY4ODY0MzkzNTUwMzExODMwNTU4NjQzODI3MTE3MTM5NTg0Mjk3MTE1NzQ4MDM4MTM3NzAxNTQwNTk4MDA1MzUzOTM1ODQxNzEzNTU0MDkzOTQzN24sIDBuXSxcbiAgICAgICAgICAgICAgICBbNDAwMjQwOTU1NTIyMTY2NzM5MjYyNDMxMDQzNTAwNjY4ODY0MzkzNTUwMzExODMwNTU4NjQzODI3MTE3MTM5NTg0Mjk3MTE1NzQ4MDM4MTM3NzAxNTQwNTk4MDA1MzUzOTM1ODQxNzEzNTU0MDkzOTQzNm4sIDBuXSxcbiAgICAgICAgICAgICAgICBbNDAwMjQwOTU1NTIyMTY2NzM5MzQxNzc4OTgyNTczNTkwNDE1NjU1Njg4MjgxOTkzOTAwNzg4NTMzMjA1ODEzNjEyNDAzMTY1MDQ5MDgzNzg2NDQ0MjY4NzYyOTEyOTAxNTY2NDAzNzg5NDI3MjU1OTc4Nm4sIDBuXSxcbiAgICAgICAgICAgICAgICBbNzkzNDc5MzkwNzI5MjE1NTEyNjIxMzc5NzAxNjMzNDIxNDQ3MDYwODg2NzQwMjgxMDYwNDkzMDEwNDU2NDg3NDI3MjgxNjQ5MDc1NDc2MzA1NjIwNzU4NzMxNjIwMzUwbiwgMG5dLFxuICAgICAgICAgICAgICAgIFs3OTM0NzkzOTA3MjkyMTU1MTI2MjEzNzk3MDE2MzM0MjE0NDcwNjA4ODY3NDAyODEwNjA0OTMwMTA0NTY0ODc0MjcyODE2NDkwNzU0NzYzMDU2MjA3NTg3MzE2MjAzNTFuLCAwbl0sXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihmdG1QcmVmaXggKyBcIl9mcm9iZW5pdXNNYXBcIituKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDY7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgWCA9IChpPT0wKSA/IGMuZ2V0TG9jYWwoXCJ4XCIpIDogYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChpKmYyc2l6ZSkpO1xuICAgICAgICAgICAgY29uc3QgWGMwID0gWDtcbiAgICAgICAgICAgIGNvbnN0IFhjMSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoaSpmMnNpemUgKyBmMXNpemUpKTtcbiAgICAgICAgICAgIGNvbnN0IFIgPSAoaT09MCkgPyBjLmdldExvY2FsKFwiclwiKSA6IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoaSpmMnNpemUpKTtcbiAgICAgICAgICAgIGNvbnN0IFJjMCA9IFI7XG4gICAgICAgICAgICBjb25zdCBSYzEgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KGkqZjJzaXplICsgZjFzaXplKSk7XG4gICAgICAgICAgICBjb25zdCBjb2VmID0gbXVsMihGMTJbTWF0aC5mbG9vcihpLzMpXVtuJTEyXSAsIEY2W2klM11bbiU2XSk7XG4gICAgICAgICAgICBjb25zdCBwQ29lZiA9IG1vZHVsZS5hbGxvYyhbXG4gICAgICAgICAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSh0b01vbnRnb21lcnkoY29lZlswXSksIG44cSksXG4gICAgICAgICAgICAgICAgLi4udXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSh0b01vbnRnb21lcnkoY29lZlsxXSksIG44cSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmIChuJTIgPT0gMSkge1xuICAgICAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX2NvcHlcIiwgWGMwLCBSYzApLFxuICAgICAgICAgICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfbmVnXCIsIFhjMSwgUmMxKSxcbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBSLCBjLmkzMl9jb25zdChwQ29lZiksIFIpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGYuYWRkQ29kZShjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIFgsIGMuaTMyX2NvbnN0KHBDb2VmKSwgUikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbXVsMihhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBhYzAgPSBhWzBdO1xuICAgICAgICAgICAgY29uc3QgYWMxID0gYVsxXTtcbiAgICAgICAgICAgIGNvbnN0IGJjMCA9IGJbMF07XG4gICAgICAgICAgICBjb25zdCBiYzEgPSBiWzFdO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gW1xuICAgICAgICAgICAgICAgIChhYzAgKiBiYzAgLSAoYWMxICogYmMxKSkgJSBxLFxuICAgICAgICAgICAgICAgIChhYzAgKiBiYzEgKyAoYWMxICogYmMwKSkgJSBxLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlJDEocmVzWzBdKSkgcmVzWzBdID0gcmVzWzBdICsgcTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRDeWNsb3RvbWljU3F1YXJlKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfX2N5Y2xvdG9taWNTcXVhcmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJ4XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHgwID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHg0ID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdChmMnNpemUpKTtcbiAgICAgICAgY29uc3QgeDMgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KDIqZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHgyID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJ4XCIpLCBjLmkzMl9jb25zdCgzKmYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB4MSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwieFwiKSwgYy5pMzJfY29uc3QoNCpmMnNpemUpKTtcbiAgICAgICAgY29uc3QgeDUgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KDUqZjJzaXplKSk7XG5cbiAgICAgICAgY29uc3QgcjAgPSBjLmdldExvY2FsKFwiclwiKTtcbiAgICAgICAgY29uc3QgcjQgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCByMyA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoMipmMnNpemUpKTtcbiAgICAgICAgY29uc3QgcjIgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInJcIiksIGMuaTMyX2NvbnN0KDMqZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHIxID0gYy5pMzJfYWRkKGMuZ2V0TG9jYWwoXCJyXCIpLCBjLmkzMl9jb25zdCg0KmYyc2l6ZSkpO1xuICAgICAgICBjb25zdCByNSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwiclwiKSwgYy5pMzJfY29uc3QoNSpmMnNpemUpKTtcblxuICAgICAgICBjb25zdCB0MCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgdDEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHQyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB0MyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgdDQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IHQ1ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCB0bXAgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZjJzaXplKSk7XG4gICAgICAgIGNvbnN0IEFVWCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcblxuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIC8vICAgIC8vIHQwICsgdDEqeSA9ICh6MCArIHoxKnkpXjIgPSBhXjJcbiAgICAgICAgICAgIC8vICAgIHRtcCA9IHowICogejE7XG4gICAgICAgICAgICAvLyAgICB0MCA9ICh6MCArIHoxKSAqICh6MCArIG15X0ZwNjo6bm9uX3Jlc2lkdWUgKiB6MSkgLSB0bXAgLSBteV9GcDY6Om5vbl9yZXNpZHVlICogdG1wO1xuICAgICAgICAgICAgLy8gICAgdDEgPSB0bXAgKyB0bXA7XG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHgwLCB4MSwgdG1wKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxOUlwiLCB4MSwgdDApLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB4MCwgdDAsIHQwKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgeDAsIHgxLCBBVVgpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCBBVVgsIHQwLCB0MCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsTlJcIiwgdG1wLCBBVVgpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB0bXAsIEFVWCwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9zdWJcIiwgdDAsIEFVWCwgdDApLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB0bXAsIHRtcCwgdDEpLFxuXG4gICAgICAgICAgICAvLyAgLy8gdDIgKyB0Myp5ID0gKHoyICsgejMqeSleMiA9IGJeMlxuICAgICAgICAgICAgLy8gIHRtcCA9IHoyICogejM7XG4gICAgICAgICAgICAvLyAgdDIgPSAoejIgKyB6MykgKiAoejIgKyBteV9GcDY6Om5vbl9yZXNpZHVlICogejMpIC0gdG1wIC0gbXlfRnA2Ojpub25fcmVzaWR1ZSAqIHRtcDtcbiAgICAgICAgICAgIC8vICB0MyA9IHRtcCArIHRtcDtcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgeDIsIHgzLCB0bXApLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bE5SXCIsIHgzLCB0MiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHgyLCB0MiwgdDIpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB4MiwgeDMsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIEFVWCwgdDIsIHQyKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxOUlwiLCB0bXAsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHRtcCwgQVVYLCBBVVgpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCB0MiwgQVVYLCB0MiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHRtcCwgdG1wLCB0MyksXG5cbiAgICAgICAgICAgIC8vICAvLyB0NCArIHQ1KnkgPSAoejQgKyB6NSp5KV4yID0gY14yXG4gICAgICAgICAgICAvLyAgdG1wID0gejQgKiB6NTtcbiAgICAgICAgICAgIC8vICB0NCA9ICh6NCArIHo1KSAqICh6NCArIG15X0ZwNjo6bm9uX3Jlc2lkdWUgKiB6NSkgLSB0bXAgLSBteV9GcDY6Om5vbl9yZXNpZHVlICogdG1wO1xuICAgICAgICAgICAgLy8gIHQ1ID0gdG1wICsgdG1wO1xuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bFwiLCB4NCwgeDUsIHRtcCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsTlJcIiwgeDUsIHQ0KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgeDQsIHQ0LCB0NCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHg0LCB4NSwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgQVVYLCB0NCwgdDQpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX211bE5SXCIsIHRtcCwgQVVYKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdG1wLCBBVVgsIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQ0LCBBVVgsIHQ0KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdG1wLCB0bXAsIHQ1KSxcblxuICAgICAgICAgICAgLy8gRm9yIEFcbiAgICAgICAgICAgIC8vIHowID0gMyAqIHQwIC0gMiAqIHowXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQwLCB4MCwgcjApLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCByMCwgcjAsIHIwKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdDAsIHIwLCByMCksXG4gICAgICAgICAgICAvLyB6MSA9IDMgKiB0MSArIDIgKiB6MVxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB0MSwgeDEsIHIxKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgcjEsIHIxLCByMSksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQxLCByMSwgcjEpLFxuXG4gICAgICAgICAgICAvLyBGb3IgQlxuICAgICAgICAgICAgLy8gejIgPSAzICogKHhpICogdDUpICsgMiAqIHoyXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHQ1LCBjLmkzMl9jb25zdChwQmxzMTIzODFUd2lzdCksIEFVWCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEFVWCwgeDIsIHIyKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgcjIsIHIyLCByMiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIEFVWCwgcjIsIHIyKSxcbiAgICAgICAgICAgIC8vIHozID0gMyAqIHQ0IC0gMiAqIHozXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfc3ViXCIsIHQ0LCB4MywgcjMpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCByMywgcjMsIHIzKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdDQsIHIzLCByMyksXG5cbiAgICAgICAgICAgIC8vIEZvciBDXG4gICAgICAgICAgICAvLyB6NCA9IDMgKiB0MiAtIDIgKiB6NFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX3N1YlwiLCB0MiwgeDQsIHI0KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgcjQsIHI0LCByNCksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHQyLCByNCwgcjQpLFxuICAgICAgICAgICAgLy8gejUgPSAzICogdDMgKyAyICogejVcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9hZGRcIiwgdDMsIHg1LCByNSksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfYWRkXCIsIHI1LCByNSwgcjUpLFxuICAgICAgICAgICAgYy5jYWxsKGYybVByZWZpeCArIFwiX2FkZFwiLCB0MywgcjUsIHI1KSxcblxuICAgICAgICApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRDeWNsb3RvbWljRXhwKGV4cG9uZW50LCBpc0V4cE5lZ2F0aXZlLCBmbk5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhwb25lbnROYWZCeXRlcyA9IG5hZihleHBvbmVudCkubWFwKCAoYikgPT4gKGI9PS0xID8gMHhGRjogYikgKTtcbiAgICAgICAgY29uc3QgcEV4cG9uZW50TmFmQnl0ZXMgPSBtb2R1bGUuYWxsb2MoZXhwb25lbnROYWZCeXRlcyk7XG4gICAgICAgIC8vIGNvbnN0IHBFeHBvbmVudCA9IG1vZHVsZS5hbGxvYyh1dGlscy5iaWdJbnQyQnl0ZXNMRShleHBvbmVudCwgbjgpKTtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfX2N5Y2xvdG9taWNFeHBfXCIrZm5OYW1lKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiYml0XCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZExvY2FsKFwiaVwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHggPSBjLmdldExvY2FsKFwieFwiKTtcblxuICAgICAgICBjb25zdCByZXMgPSBjLmdldExvY2FsKFwiclwiKTtcblxuICAgICAgICBjb25zdCBpbnZlcnNlID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuXG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX2Nvbmp1Z2F0ZVwiLCB4LCBpbnZlcnNlKSxcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9vbmVcIiwgcmVzKSxcblxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLnRlZUxvY2FsKFwiYml0XCIsIGMuaTMyX2xvYWQ4X3MoYy5pMzJfY29uc3QoZXhwb25lbnROYWZCeXRlcy5sZW5ndGgtMSksIHBFeHBvbmVudE5hZkJ5dGVzKSksXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy5pMzJfZXEoXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmdldExvY2FsKFwiYml0XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfY29uc3QoMSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX211bFwiLCByZXMsIHgsIHJlcyksXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgcmVzLCBpbnZlcnNlLCByZXMpLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGMuc2V0TG9jYWwoXCJpXCIsIGMuaTMyX2NvbnN0KGV4cG9uZW50TmFmQnl0ZXMubGVuZ3RoLTIpKSxcbiAgICAgICAgICAgIGMuYmxvY2soYy5sb29wKFxuICAgICAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9fY3ljbG90b21pY1NxdWFyZVwiLCByZXMsIHJlcyksXG4gICAgICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICAgICAgYy50ZWVMb2NhbChcImJpdFwiLCBjLmkzMl9sb2FkOF9zKGMuZ2V0TG9jYWwoXCJpXCIpLCBwRXhwb25lbnROYWZCeXRlcykpLFxuICAgICAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5pMzJfZXEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5nZXRMb2NhbChcImJpdFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmkzMl9jb25zdCgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgcmVzLCB4LCByZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX211bFwiLCByZXMsIGludmVyc2UsIHJlcyksXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGMuYnJfaWYoMSwgYy5pMzJfZXF6ICggYy5nZXRMb2NhbChcImlcIikgKSksXG4gICAgICAgICAgICAgICAgYy5zZXRMb2NhbChcImlcIiwgYy5pMzJfc3ViKGMuZ2V0TG9jYWwoXCJpXCIpLCBjLmkzMl9jb25zdCgxKSkpLFxuICAgICAgICAgICAgICAgIGMuYnIoMClcbiAgICAgICAgICAgICkpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzRXhwTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfY29uanVnYXRlXCIsIHJlcywgcmVzKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkRmluYWxFeHBvbmVudGlhdGlvbigpIHtcbiAgICAgICAgYnVpbGRDeWNsb3RvbWljU3F1YXJlKCk7XG4gICAgICAgIGJ1aWxkQ3ljbG90b21pY0V4cChmaW5hbEV4cFosIGZpbmFsRXhwSXNOZWdhdGl2ZSwgXCJ3MFwiKTtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfZmluYWxFeHBvbmVudGlhdGlvblwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMgPSBmLmdldENvZGVCdWlsZGVyKCk7XG5cbiAgICAgICAgY29uc3QgZWx0ID0gYy5nZXRMb2NhbChcInhcIik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGMuZ2V0TG9jYWwoXCJyXCIpO1xuICAgICAgICBjb25zdCB0MCA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmdHNpemUpKTtcbiAgICAgICAgY29uc3QgdDEgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZnRzaXplKSk7XG4gICAgICAgIGNvbnN0IHQyID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCB0MyA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmdHNpemUpKTtcbiAgICAgICAgY29uc3QgdDQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZnRzaXplKSk7XG4gICAgICAgIGNvbnN0IHQ1ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGZ0c2l6ZSkpO1xuICAgICAgICBjb25zdCB0NiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmdHNpemUpKTtcblxuICAgICAgICBmLmFkZENvZGUoXG5cbiAgICAgICAgICAgIC8vIGxldCBtdXQgdDAgPSBmLmZyb2Jlbml1c19tYXAoNilcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9mcm9iZW5pdXNNYXA2XCIsIGVsdCwgdDApLFxuXG4gICAgICAgICAgICAvLyBsZXQgdDEgPSBmLmludmVydCgpXG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfaW52ZXJzZVwiLCBlbHQsIHQxKSxcblxuICAgICAgICAgICAgLy8gbGV0IG11dCB0MiA9IHQwICogdDE7XG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsXCIsIHQwLCB0MSwgdDIpLFxuXG4gICAgICAgICAgICAvLyB0MSA9IHQyLmNsb25lKCk7XG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfY29weVwiLCB0MiwgdDEpLFxuXG4gICAgICAgICAgICAvLyB0MiA9IHQyLmZyb2Jlbml1c19tYXAoKS5mcm9iZW5pdXNfbWFwKCk7XG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfZnJvYmVuaXVzTWFwMlwiLCB0MiwgdDIpLFxuXG4gICAgICAgICAgICAvLyB0MiAqPSB0MTtcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgdDIsIHQxLCB0MiksXG5cblxuICAgICAgICAgICAgLy8gdDEgPSBjeWNsb3RvbWljX3NxdWFyZSh0MikuY29uanVnYXRlKCk7XG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX2N5Y2xvdG9taWNTcXVhcmVcIiwgdDIsIHQxKSxcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9jb25qdWdhdGVcIiwgdDEsIHQxKSxcblxuICAgICAgICAgICAgLy8gbGV0IG11dCB0MyA9IGN5Y29sb3RvbWljX2V4cCh0Mik7XG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX2N5Y2xvdG9taWNFeHBfdzBcIiwgdDIsIHQzKSxcblxuICAgICAgICAgICAgLy8gbGV0IG11dCB0NCA9IGN5Y2xvdG9taWNfc3F1YXJlKHQzKTtcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9fY3ljbG90b21pY1NxdWFyZVwiLCB0MywgdDQpLFxuXG4gICAgICAgICAgICAvLyBsZXQgbXV0IHQ1ID0gdDEgKiB0MztcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgdDEsIHQzLCB0NSksXG5cbiAgICAgICAgICAgIC8vIHQxID0gY3ljb2xvdG9taWNfZXhwKHQ1KTtcbiAgICAgICAgICAgIGMuY2FsbChwcmVmaXggKyBcIl9fY3ljbG90b21pY0V4cF93MFwiLCB0NSwgdDEpLFxuXG4gICAgICAgICAgICAvLyB0MCA9IGN5Y29sb3RvbWljX2V4cCh0MSk7XG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX2N5Y2xvdG9taWNFeHBfdzBcIiwgdDEsIHQwKSxcblxuICAgICAgICAgICAgLy8gbGV0IG11dCB0NiA9IGN5Y29sb3RvbWljX2V4cCh0MCk7XG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX2N5Y2xvdG9taWNFeHBfdzBcIiwgdDAsIHQ2KSxcblxuICAgICAgICAgICAgLy8gdDYgKj0gdDQ7XG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsXCIsIHQ2LCB0NCwgdDYpLFxuXG4gICAgICAgICAgICAvLyB0NCA9IGN5Y29sb3RvbWljX2V4cCh0Nik7XG4gICAgICAgICAgICBjLmNhbGwocHJlZml4ICsgXCJfX2N5Y2xvdG9taWNFeHBfdzBcIiwgdDYsIHQ0KSxcblxuICAgICAgICAgICAgLy8gdDUgPSB0NS5jb25qdWdhdGUoKTtcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9jb25qdWdhdGVcIiwgdDUsIHQ1KSxcblxuICAgICAgICAgICAgLy8gdDQgKj0gdDUgKiB0MjtcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgdDQsIHQ1LCB0NCksXG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsXCIsIHQ0LCB0MiwgdDQpLFxuXG4gICAgICAgICAgICAvLyB0NSA9IHQyLmNvbmp1Z2F0ZSgpO1xuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX2Nvbmp1Z2F0ZVwiLCB0MiwgdDUpLFxuXG4gICAgICAgICAgICAvLyB0MSAqPSB0MjtcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgdDEsIHQyLCB0MSksXG5cbiAgICAgICAgICAgIC8vIHQxID0gdDEuZnJvYmVuaXVzX21hcCgpLmZyb2Jlbml1c19tYXAoKS5mcm9iZW5pdXNfbWFwKCk7XG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfZnJvYmVuaXVzTWFwM1wiLCB0MSwgdDEpLFxuXG4gICAgICAgICAgICAvLyB0NiAqPSB0NTtcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgdDYsIHQ1LCB0NiksXG5cbiAgICAgICAgICAgIC8vIHQ2ID0gdDYuZnJvYmVuaXVzX21hcCgpO1xuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX2Zyb2Jlbml1c01hcDFcIiwgdDYsIHQ2KSxcblxuICAgICAgICAgICAgLy8gdDMgKj0gdDA7XG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsXCIsIHQzLCB0MCwgdDMpLFxuXG4gICAgICAgICAgICAvLyB0MyA9IHQzLmZyb2Jlbml1c19tYXAoKS5mcm9iZW5pdXNfbWFwKCk7XG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfZnJvYmVuaXVzTWFwMlwiLCB0MywgdDMpLFxuXG4gICAgICAgICAgICAvLyB0MyAqPSB0MTtcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgdDMsIHQxLCB0MyksXG5cbiAgICAgICAgICAgIC8vIHQzICo9IHQ2O1xuICAgICAgICAgICAgYy5jYWxsKGZ0bVByZWZpeCArIFwiX211bFwiLCB0MywgdDYsIHQzKSxcblxuICAgICAgICAgICAgLy8gZiA9IHQzICogdDQ7XG4gICAgICAgICAgICBjLmNhbGwoZnRtUHJlZml4ICsgXCJfbXVsXCIsIHQzLCB0NCwgcmVzKSxcblxuICAgICAgICApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYnVpbGRGaW5hbEV4cG9uZW50aWF0aW9uT2xkKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfZmluYWxFeHBvbmVudGlhdGlvbk9sZFwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInhcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJyXCIsIFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGV4cG9uZW50ID0gMzIyMjc3MzYxNTE2OTM0MTQwNDYyODkxNTY0NTg2NTEwMTM5OTA4Mzc5OTY5NTE0ODI4NDk0MjE4MzY2Njg4MDI1Mjg4NjYxMDQxMTA0NjgyNzk0OTk4NjgwNDk3NTgwMDA4ODk5OTczMjQ5ODE0MTA0NDQ3NjkyNzc4OTg4MjA4Mzc2Nzc5NTczODE5NDg1MjYzMDI2MTU5NTg4NTEwNTEzODM0ODc2MzAzMDE0MDE2Nzk4ODA5OTE5MzQzNTMyODk5MTY0ODQ4NzMwMjgwOTQyNjA5OTU2NjcwOTE3NTY1NjE4MTE1ODY3Mjg3Mzk5NjIzMjg2ODEzMjcwMzU3OTAxNzMxNTEwMTg4MTQ5OTM0MzYzMzYwMzgxNjE0NTAxMzM0MDg2ODI1NDQyMjcxOTIwMDc5MzYzMjg5OTU0NTEwNTY1Mzc1Mzc4NDQzNzA0MzcyOTk0ODgxNDA2Nzk3ODgyNjc2OTcxMDgyMjAwNjI2NTQxOTE2NDEzMTg0NjQyNTIwMjY5Njc4ODk3NTU5NTMyMjYwOTQ5MzM0NzYwNjA0OTYyMDg2MzQ4ODk4MTE4OTgyMjQ4ODQyNjM0Mzc5NjM3NTk4NjY1NDY4ODE3NzY5MDc1ODc4NTU1NDkzNzUyMjE0NDkyNzkwMTIyNzg1ODUwMjAyOTU3NTc1MjAwMTc2MDg0MjA0NDIyNzUxNDg1OTU3MzM2NDY1NDcyMzI0ODEwOTgyODMzNjM4NDkwOTA0Mjc5MjgyNjk2MTM0MzIzMDcyNTE1MjIwMDQ0NDUxNTkyNjQ2ODg1NDEwNTcyMjM0NDUxNzMyNzkwNTkwMDEzNDc5MzU4MzQzODQxMjIwMDc0MTc0ODQ4MjIxNzIyMDE3MDgzNTk3ODcyMDE3NjM4NTE0MTAzMTc0MTIyNzg0ODQzOTI1NTc4MzcwNDMwODQzNTIyOTU5NjAwMDk1Njc2Mjg1NzIzNzM3MDQ5NDM4MzQ2NTQ0NzUzMTY4OTEyOTc0OTc2NzkxNTI4NTM1Mjc2MzE3MjU2OTA0MzM2NTIwMTc5MjgxMTQ1Mzk0Njg2NTY1MDUwNDE5MjUwNjE0MTA3ODAzMjMzMzE0NjU4ODI1NDYzMTE3OTAwMjUwNzAxMTk5MTgxNTI5MjA1OTQyMzYzMTU5MzI1NzY1OTkxODE5NDMzOTE0MzAzOTA4ODYwNDYwNzIwNTgxNDA4MjAxMzczMTY0MDQ3NzczNzk0ODI1NDExMDExOTIyMzA1ODIwMDY1NjExMTIxNTQ0NTYxODA4NDE0MDU1MzAyMjEyMDU3NDcxMzk1NzE5NDMyMDcyMjA5MjQ1NjAwMjU4MTM0MzY0NTg0NjM2ODEwMDkzNTIwMjg1NzExMDcyNTc4NzIxNDM1NTE3ODg0MTAzNTI2NDgzODMyNzMzMjg5ODAyNDI2MTU3MzAxNTQyNzQ0NDc2NzQwMDA4NDk0NzgwMzYzMzU0MzA1MTE2OTc4ODA1NjIwNjcxNDY3MDcxNDAwNzExMzU4ODM5NTUzMzc1MzQwNzI0ODk5NzM1NDYwNDgwMTQ0NTk5NzgyMDE0OTA2NTg2NTQzODEzMjkyMTU3OTIyMjIwNjQ1MDg5MTkyMTMwMjA5MzM0OTI2NjYxNTg4NzM3MDA3NzY4NTY1ODM4NTE5NDU2NjAxNTYwODA0OTU3OTg1NjY3ODgwMzk1MjIxMDQ5MjQ5ODAzNzUzNTgyNjM3NzA4NTYwbjtcblxuICAgICAgICBjb25zdCBwRXhwb25lbnQgPSBtb2R1bGUuYWxsb2ModXRpbHMkMS5iaWdJbnQyQnl0ZXNMRSggZXhwb25lbnQsIDU0NCApKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGYuYWRkQ29kZShcbiAgICAgICAgICAgIGMuY2FsbChmdG1QcmVmaXggKyBcIl9leHBcIiwgYy5nZXRMb2NhbChcInhcIiksIGMuaTMyX2NvbnN0KHBFeHBvbmVudCksIGMuaTMyX2NvbnN0KDU0NCksIGMuZ2V0TG9jYWwoXCJyXCIpKSxcbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIGNvbnN0IHBQcmVQID0gbW9kdWxlLmFsbG9jKHByZVBTaXplKTtcbiAgICBjb25zdCBwUHJlUSA9IG1vZHVsZS5hbGxvYyhwcmVRU2l6ZSk7XG5cbiAgICBmdW5jdGlvbiBidWlsZFBhaXJpbmdFcXVhdGlvbihuUGFpcmluZ3MpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfcGFpcmluZ0VxXCIrblBhaXJpbmdzKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5QYWlyaW5nczsgaSsrKSB7XG4gICAgICAgICAgICBmLmFkZFBhcmFtKFwicF9cIitpLCBcImkzMlwiKTtcbiAgICAgICAgICAgIGYuYWRkUGFyYW0oXCJxX1wiK2ksIFwiaTMyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGYuYWRkUGFyYW0oXCJjXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG5cblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHJlc1QgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZnRzaXplKSk7XG4gICAgICAgIGNvbnN0IGF1eFQgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZnRzaXplKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChmdG1QcmVmaXggKyBcIl9vbmVcIiwgcmVzVCApKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBhaXJpbmdzOyBpKyspIHtcblxuICAgICAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl9wcmVwYXJlRzFcIiwgYy5nZXRMb2NhbChcInBfXCIraSksIGMuaTMyX2NvbnN0KHBQcmVQKSApKTtcbiAgICAgICAgICAgIGYuYWRkQ29kZShjLmNhbGwocHJlZml4ICsgXCJfcHJlcGFyZUcyXCIsIGMuZ2V0TG9jYWwoXCJxX1wiK2kpLCBjLmkzMl9jb25zdChwUHJlUSkgKSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrc1xuICAgICAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgICAgIGMuaTMyX2VxeihjLmNhbGwoZzFtUHJlZml4ICsgXCJfaW5Hcm91cEFmZmluZVwiLCBjLmkzMl9jb25zdChwUHJlUCkpKSxcbiAgICAgICAgICAgICAgICAgICAgYy5yZXQoYy5pMzJfY29uc3QoMCkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgICAgICBjLmkzMl9lcXooYy5jYWxsKGcybVByZWZpeCArIFwiX2luR3JvdXBBZmZpbmVcIiwgYy5pMzJfY29uc3QocFByZVEpKSksXG4gICAgICAgICAgICAgICAgICAgIGMucmV0KGMuaTMyX2NvbnN0KDApKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGYuYWRkQ29kZShjLmNhbGwocHJlZml4ICsgXCJfbWlsbGVyTG9vcFwiLCBjLmkzMl9jb25zdChwUHJlUCksIGMuaTMyX2NvbnN0KHBQcmVRKSwgYXV4VCApKTtcblxuICAgICAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChmdG1QcmVmaXggKyBcIl9tdWxcIiwgcmVzVCwgYXV4VCwgcmVzVCApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwocHJlZml4ICsgXCJfZmluYWxFeHBvbmVudGlhdGlvblwiLCByZXNULCByZXNUICkpO1xuXG4gICAgICAgIGYuYWRkQ29kZShjLmNhbGwoZnRtUHJlZml4ICsgXCJfZXFcIiwgcmVzVCwgYy5nZXRMb2NhbChcImNcIikpKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJ1aWxkUGFpcmluZygpIHtcblxuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKHByZWZpeCsgXCJfcGFpcmluZ1wiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJxXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLmFkZFBhcmFtKFwiclwiLCBcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IHJlc1QgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2MoZnRzaXplKSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl9wcmVwYXJlRzFcIiwgYy5nZXRMb2NhbChcInBcIiksIGMuaTMyX2NvbnN0KHBQcmVQKSApKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl9wcmVwYXJlRzJcIiwgYy5nZXRMb2NhbChcInFcIiksIGMuaTMyX2NvbnN0KHBQcmVRKSApKTtcbiAgICAgICAgZi5hZGRDb2RlKGMuY2FsbChwcmVmaXggKyBcIl9taWxsZXJMb29wXCIsIGMuaTMyX2NvbnN0KHBQcmVQKSwgYy5pMzJfY29uc3QocFByZVEpLCByZXNUICkpO1xuICAgICAgICBmLmFkZENvZGUoYy5jYWxsKHByZWZpeCArIFwiX2ZpbmFsRXhwb25lbnRpYXRpb25cIiwgcmVzVCwgYy5nZXRMb2NhbChcInJcIikgKSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZEluR3JvdXBHMigpIHtcbiAgICAgICAgY29uc3QgZiA9IG1vZHVsZS5hZGRGdW5jdGlvbihnMm1QcmVmaXgrIFwiX2luR3JvdXBBZmZpbmVcIik7XG4gICAgICAgIGYuYWRkUGFyYW0oXCJwXCIsIFwiaTMyXCIpO1xuICAgICAgICBmLnNldFJldHVyblR5cGUoXCJpMzJcIik7XG5cbiAgICAgICAgY29uc3QgYyA9IGYuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBXSU5WID0gW1xuICAgICAgICAgICAgMjAwMTIwNDc3NzYxMDgzMzY5NjcwODg5NDkxMjg2Nzk1MjA3ODI3ODQ0MTQwOTk2OTUwMzk0MjY2NjAyOTA2ODA2MjAxNTgyNTI0NTQxODkzMjIyMTM0MzgxNDU2NDUwNzgzMjAxODk0NzEzNjI3OTg5NG4sXG4gICAgICAgICAgICAyMDAxMjA0Nzc3NjEwODMzNjk2NzA4ODk0OTEyODY3OTUyMDc4Mjc4NDQxNDA5OTY5NTAzOTQyNjY2MDI5MDY4MDYyMDE1ODI1MjQ1NDE4OTMyMjIxMzQzODE0NTY0NTA3ODMyMDE4OTQ3MTM2Mjc5ODkzblxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IEZST0IyWCA9IDQwMDI0MDk1NTUyMjE2NjczOTI2MjQzMTA0MzUwMDY2ODg2NDM5MzU1MDMxMTgzMDU1ODY0MzgyNzExNzEzOTU4NDI5NzExNTc0ODAzODEzNzcwMTU0MDU5ODAwNTM1MzkzNTg0MTcxMzU1NDA5Mzk0MzZuO1xuICAgICAgICBjb25zdCBGUk9CM1kgPSBbXG4gICAgICAgICAgICAyOTczNjc3NDA4OTg2NTYxMDQzNDQyNDY1MzQ2NTIwMTA4ODc5MTcyMDQyODgzMDA5MjQ5OTg5MTc2NDE1MDE4MDkxNDIwODA3MTkyMTgyNjM4NTY3MTE2MzE4NTc2NDcyNjQ5MzQ3MDE1OTE3NjkwNTMwbixcbiAgICAgICAgICAgIDI5NzM2Nzc0MDg5ODY1NjEwNDM0NDI0NjUzNDY1MjAxMDg4NzkxNzIwNDI4ODMwMDkyNDk5ODkxNzY0MTUwMTgwOTE0MjA4MDcxOTIxODI2Mzg1NjcxMTYzMTg1NzY0NzI2NDkzNDcwMTU5MTc2OTA1MzBuXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3Qgd0ludiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhbXG4gICAgICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKHRvTW9udGdvbWVyeShXSU5WWzBdKSwgbjhxKSxcbiAgICAgICAgICAgIC4uLnV0aWxzJDEuYmlnSW50MkJ5dGVzTEUodG9Nb250Z29tZXJ5KFdJTlZbMV0pLCBuOHEpLFxuICAgICAgICBdKSk7XG5cbiAgICAgICAgY29uc3QgZnJvYjJYID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKHV0aWxzJDEuYmlnSW50MkJ5dGVzTEUodG9Nb250Z29tZXJ5KEZST0IyWCksIG44cSkpKTtcbiAgICAgICAgY29uc3QgZnJvYjNZID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKFtcbiAgICAgICAgICAgIC4uLnV0aWxzJDEuYmlnSW50MkJ5dGVzTEUodG9Nb250Z29tZXJ5KEZST0IzWVswXSksIG44cSksXG4gICAgICAgICAgICAuLi51dGlscyQxLmJpZ0ludDJCeXRlc0xFKHRvTW9udGdvbWVyeShGUk9CM1lbMV0pLCBuOHEpLFxuICAgICAgICBdKSk7XG5cbiAgICAgICAgY29uc3QgeiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyh1dGlscyQxLmJpZ0ludDJCeXRlc0xFKGZpbmFsRXhwWiwgOCkpKTtcblxuICAgICAgICBjb25zdCBweCA9IGMuZ2V0TG9jYWwoXCJwXCIpO1xuICAgICAgICBjb25zdCBweSA9IGMuaTMyX2FkZChjLmdldExvY2FsKFwicFwiKSwgYy5pMzJfY29uc3QoZjJzaXplKSk7XG5cbiAgICAgICAgY29uc3QgYXV4ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYxc2l6ZSkpO1xuXG4gICAgICAgIGNvbnN0IHhfd2ludiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUpKTtcbiAgICAgICAgY29uc3QgeV93aW52ID0gYy5pMzJfY29uc3QobW9kdWxlLmFsbG9jKGYyc2l6ZSkpO1xuICAgICAgICBjb25zdCBwZjIgPSBtb2R1bGUuYWxsb2MoZjJzaXplKjIpO1xuICAgICAgICBjb25zdCBmMiA9IGMuaTMyX2NvbnN0KHBmMik7XG4gICAgICAgIGNvbnN0IGYyeCA9IGMuaTMyX2NvbnN0KHBmMik7XG4gICAgICAgIGNvbnN0IGYyeF9jMSA9IGMuaTMyX2NvbnN0KHBmMik7XG4gICAgICAgIGNvbnN0IGYyeF9jMiA9IGMuaTMyX2NvbnN0KHBmMitmMXNpemUpO1xuICAgICAgICBjb25zdCBmMnkgPSBjLmkzMl9jb25zdChwZjIrZjJzaXplKTtcbiAgICAgICAgY29uc3QgZjJ5X2MxID0gYy5pMzJfY29uc3QocGYyK2Yyc2l6ZSk7XG4gICAgICAgIGNvbnN0IGYyeV9jMiA9IGMuaTMyX2NvbnN0KHBmMitmMnNpemUrZjFzaXplKTtcbiAgICAgICAgY29uc3QgcGYzID0gbW9kdWxlLmFsbG9jKGYyc2l6ZSozKTtcbiAgICAgICAgY29uc3QgZjMgPSBjLmkzMl9jb25zdChwZjMpO1xuICAgICAgICBjb25zdCBmM3ggPSBjLmkzMl9jb25zdChwZjMpO1xuICAgICAgICBjb25zdCBmM3hfYzEgPSBjLmkzMl9jb25zdChwZjMpO1xuICAgICAgICBjb25zdCBmM3hfYzIgPSBjLmkzMl9jb25zdChwZjMrZjFzaXplKTtcbiAgICAgICAgY29uc3QgZjN5ID0gYy5pMzJfY29uc3QocGYzK2Yyc2l6ZSk7XG4gICAgICAgIGNvbnN0IGYzeV9jMSA9IGMuaTMyX2NvbnN0KHBmMytmMnNpemUpO1xuICAgICAgICBjb25zdCBmM3lfYzIgPSBjLmkzMl9jb25zdChwZjMrZjJzaXplK2Yxc2l6ZSk7XG4gICAgICAgIGNvbnN0IGYzeiA9IGMuaTMyX2NvbnN0KHBmMytmMnNpemUqMik7XG5cblxuICAgICAgICBmLmFkZENvZGUoXG4gICAgICAgICAgICBjLmlmKFxuICAgICAgICAgICAgICAgIGMuY2FsbChnMm1QcmVmaXggKyBcIl9pc1plcm9BZmZpbmVcIiwgYy5nZXRMb2NhbChcInBcIikpLFxuICAgICAgICAgICAgICAgIGMucmV0KCBjLmkzMl9jb25zdCgxKSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmkzMl9lcXooYy5jYWxsKGcybVByZWZpeCArIFwiX2luQ3VydmVBZmZpbmVcIiwgYy5nZXRMb2NhbChcInBcIikpKSxcbiAgICAgICAgICAgICAgICBjLnJldCggYy5pMzJfY29uc3QoMCkpLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgcHgsIHdJbnYsIHhfd2ludiksXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsXCIsIHB5LCB3SW52LCB5X3dpbnYpLFxuXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbXVsMVwiLCB4X3dpbnYsIGZyb2IyWCwgZjJ4KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9uZWdcIiwgeV93aW52LCBmMnkpLFxuXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfbmVnXCIsIHhfd2ludiwgZjN4KSxcbiAgICAgICAgICAgIGMuY2FsbChmMm1QcmVmaXggKyBcIl9tdWxcIiwgeV93aW52LCBmcm9iM1ksIGYzeSksXG5cbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9zdWJcIiwgZjJ4X2MxLCBmMnhfYzIsIGF1eCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIGYyeF9jMSwgZjJ4X2MyLCBmMnhfYzIpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX2NvcHlcIiwgYXV4LCBmMnhfYzEpLFxuXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfc3ViXCIsIGYyeV9jMSwgZjJ5X2MyLCBhdXgpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX2FkZFwiLCBmMnlfYzEsIGYyeV9jMiwgZjJ5X2MyKSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9jb3B5XCIsIGF1eCwgZjJ5X2MxKSxcblxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX2FkZFwiLCBmM3hfYzEsIGYzeF9jMiwgYXV4KSxcbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9zdWJcIiwgZjN4X2MxLCBmM3hfYzIsIGYzeF9jMiksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfY29weVwiLCBhdXgsIGYzeF9jMSksXG5cbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9zdWJcIiwgZjN5X2MyLCBmM3lfYzEsIGF1eCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfYWRkXCIsIGYzeV9jMSwgZjN5X2MyLCBmM3lfYzIpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX2NvcHlcIiwgYXV4LCBmM3lfYzEpLFxuXG4gICAgICAgICAgICBjLmNhbGwoZjJtUHJlZml4ICsgXCJfb25lXCIsIGYzeiksXG5cbiAgICAgICAgICAgIGMuY2FsbChnMm1QcmVmaXggKyBcIl90aW1lc1NjYWxhclwiLCBmMywgeiwgYy5pMzJfY29uc3QoOCksIGYzKSxcbiAgICAgICAgICAgIGMuY2FsbChnMm1QcmVmaXggKyBcIl9hZGRNaXhlZFwiLCBmMywgZjIsIGYzKSxcblxuICAgICAgICAgICAgYy5yZXQoXG4gICAgICAgICAgICAgICAgYy5jYWxsKGcybVByZWZpeCArIFwiX2VxTWl4ZWRcIiwgZjMsIGMuZ2V0TG9jYWwoXCJwXCIpKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGZJbkdyb3VwID0gbW9kdWxlLmFkZEZ1bmN0aW9uKGcybVByZWZpeCArIFwiX2luR3JvdXBcIik7XG4gICAgICAgIGZJbkdyb3VwLmFkZFBhcmFtKFwicEluXCIsIFwiaTMyXCIpO1xuICAgICAgICBmSW5Hcm91cC5zZXRSZXR1cm5UeXBlKFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMyID0gZkluR3JvdXAuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBhdXgyID0gYzIuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMnNpemUqMikpO1xuXG4gICAgICAgIGZJbkdyb3VwLmFkZENvZGUoXG4gICAgICAgICAgICBjMi5jYWxsKGcybVByZWZpeCArIFwiX3RvQWZmaW5lXCIsIGMyLmdldExvY2FsKFwicEluXCIpLCBhdXgyKSxcblxuICAgICAgICAgICAgYzIucmV0KFxuICAgICAgICAgICAgICAgIGMyLmNhbGwoZzJtUHJlZml4ICsgXCJfaW5Hcm91cEFmZmluZVwiLCBhdXgyKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkSW5Hcm91cEcxKCkge1xuICAgICAgICBjb25zdCBmID0gbW9kdWxlLmFkZEZ1bmN0aW9uKGcxbVByZWZpeCsgXCJfaW5Hcm91cEFmZmluZVwiKTtcbiAgICAgICAgZi5hZGRQYXJhbShcInBcIiwgXCJpMzJcIik7XG4gICAgICAgIGYuc2V0UmV0dXJuVHlwZShcImkzMlwiKTtcblxuICAgICAgICBjb25zdCBjID0gZi5nZXRDb2RlQnVpbGRlcigpO1xuXG4gICAgICAgIGNvbnN0IEJFVEEgPSA0MDAyNDA5NTU1MjIxNjY3MzkyNjI0MzEwNDM1MDA2Njg4NjQzOTM1NTAzMTE4MzA1NTg2NDM4MjcxMTcxMzk1ODQyOTcxMTU3NDgwMzgxMzc3MDE1NDA1OTgwMDUzNTM5MzU4NDE3MTM1NTQwOTM5NDM2bjtcbiAgICAgICAgY29uc3QgQkVUQTIgPSA3OTM0NzkzOTA3MjkyMTU1MTI2MjEzNzk3MDE2MzM0MjE0NDcwNjA4ODY3NDAyODEwNjA0OTMwMTA0NTY0ODc0MjcyODE2NDkwNzU0NzYzMDU2MjA3NTg3MzE2MjAzNTBuO1xuICAgICAgICBjb25zdCBaMk0xRDMgPSAoZmluYWxFeHBaICogZmluYWxFeHBaIC0gMW4pIC8gM247XG5cbiAgICAgICAgY29uc3QgYmV0YSA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyh1dGlscyQxLmJpZ0ludDJCeXRlc0xFKHRvTW9udGdvbWVyeShCRVRBKSwgbjhxKSkpO1xuICAgICAgICBjb25zdCBiZXRhMiA9IGMuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyh1dGlscyQxLmJpZ0ludDJCeXRlc0xFKHRvTW9udGdvbWVyeShCRVRBMiksIG44cSkpKTtcblxuICAgICAgICBjb25zdCB6Mm0xZDMgPSBjLmkzMl9jb25zdChtb2R1bGUuYWxsb2ModXRpbHMkMS5iaWdJbnQyQnl0ZXNMRShaMk0xRDMsIDE2KSkpO1xuXG5cbiAgICAgICAgY29uc3QgcHggPSBjLmdldExvY2FsKFwicFwiKTtcbiAgICAgICAgY29uc3QgcHkgPSBjLmkzMl9hZGQoYy5nZXRMb2NhbChcInBcIiksIGMuaTMyX2NvbnN0KGYxc2l6ZSkpO1xuXG4gICAgICAgIGNvbnN0IHBzcCA9IG1vZHVsZS5hbGxvYyhmMXNpemUqMyk7XG4gICAgICAgIGNvbnN0IHNwID0gYy5pMzJfY29uc3QocHNwKTtcbiAgICAgICAgY29uc3Qgc3B4ID0gYy5pMzJfY29uc3QocHNwKTtcbiAgICAgICAgY29uc3Qgc3B5ID0gYy5pMzJfY29uc3QocHNwK2Yxc2l6ZSk7XG5cbiAgICAgICAgY29uc3QgcHMycCA9IG1vZHVsZS5hbGxvYyhmMXNpemUqMik7XG4gICAgICAgIGNvbnN0IHMycCA9IGMuaTMyX2NvbnN0KHBzMnApO1xuICAgICAgICBjb25zdCBzMnB4ID0gYy5pMzJfY29uc3QocHMycCk7XG4gICAgICAgIGNvbnN0IHMycHkgPSBjLmkzMl9jb25zdChwczJwK2Yxc2l6ZSk7XG5cbiAgICAgICAgZi5hZGRDb2RlKFxuICAgICAgICAgICAgYy5pZihcbiAgICAgICAgICAgICAgICBjLmNhbGwoZzFtUHJlZml4ICsgXCJfaXNaZXJvQWZmaW5lXCIsIGMuZ2V0TG9jYWwoXCJwXCIpKSxcbiAgICAgICAgICAgICAgICBjLnJldCggYy5pMzJfY29uc3QoMSkpLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGMuaWYoXG4gICAgICAgICAgICAgICAgYy5pMzJfZXF6KGMuY2FsbChnMW1QcmVmaXggKyBcIl9pbkN1cnZlQWZmaW5lXCIsIGMuZ2V0TG9jYWwoXCJwXCIpKSksXG4gICAgICAgICAgICAgICAgYy5yZXQoIGMuaTMyX2NvbnN0KDApKSxcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIGMuY2FsbChmMW1QcmVmaXggKyBcIl9tdWxcIiwgcHgsIGJldGEsIHNweCksXG4gICAgICAgICAgICBjLmNhbGwoZjFtUHJlZml4ICsgXCJfY29weVwiLCBweSwgc3B5KSxcblxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX211bFwiLCBweCwgYmV0YTIsIHMycHgpLFxuICAgICAgICAgICAgYy5jYWxsKGYxbVByZWZpeCArIFwiX2NvcHlcIiwgcHksIHMycHkpLFxuXG5cbiAgICAgICAgICAgIGMuY2FsbChnMW1QcmVmaXggKyBcIl9kb3VibGVBZmZpbmVcIiwgc3AsIHNwKSxcbiAgICAgICAgICAgIGMuY2FsbChnMW1QcmVmaXggKyBcIl9zdWJNaXhlZFwiLCBzcCwgYy5nZXRMb2NhbChcInBcIiksIHNwKSxcbiAgICAgICAgICAgIGMuY2FsbChnMW1QcmVmaXggKyBcIl9zdWJNaXhlZFwiLCBzcCwgczJwLCBzcCksXG5cbiAgICAgICAgICAgIGMuY2FsbChnMW1QcmVmaXggKyBcIl90aW1lc1NjYWxhclwiLCBzcCwgejJtMWQzLCBjLmkzMl9jb25zdCgxNiksIHNwKSxcblxuICAgICAgICAgICAgYy5yZXQoXG4gICAgICAgICAgICAgICAgYy5jYWxsKGcxbVByZWZpeCArIFwiX2VxTWl4ZWRcIiwgc3AsIHMycClcbiAgICAgICAgICAgIClcblxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGZJbkdyb3VwID0gbW9kdWxlLmFkZEZ1bmN0aW9uKGcxbVByZWZpeCArIFwiX2luR3JvdXBcIik7XG4gICAgICAgIGZJbkdyb3VwLmFkZFBhcmFtKFwicEluXCIsIFwiaTMyXCIpO1xuICAgICAgICBmSW5Hcm91cC5zZXRSZXR1cm5UeXBlKFwiaTMyXCIpO1xuXG4gICAgICAgIGNvbnN0IGMyID0gZkluR3JvdXAuZ2V0Q29kZUJ1aWxkZXIoKTtcblxuICAgICAgICBjb25zdCBhdXgyID0gYzIuaTMyX2NvbnN0KG1vZHVsZS5hbGxvYyhmMXNpemUqMikpO1xuXG4gICAgICAgIGZJbkdyb3VwLmFkZENvZGUoXG4gICAgICAgICAgICBjMi5jYWxsKGcxbVByZWZpeCArIFwiX3RvQWZmaW5lXCIsIGMyLmdldExvY2FsKFwicEluXCIpLCBhdXgyKSxcblxuICAgICAgICAgICAgYzIucmV0KFxuICAgICAgICAgICAgICAgIGMyLmNhbGwoZzFtUHJlZml4ICsgXCJfaW5Hcm91cEFmZmluZVwiLCBhdXgyKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpPTA7IGk8MTA7IGkrKykge1xuICAgICAgICBidWlsZEZyb2Jlbml1c01hcChpKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKGZ0bVByZWZpeCArIFwiX2Zyb2Jlbml1c01hcFwiK2kpO1xuICAgIH1cblxuXG4gICAgYnVpbGRJbkdyb3VwRzEoKTtcbiAgICBidWlsZEluR3JvdXBHMigpO1xuXG4gICAgYnVpbGRQcmVwQWRkU3RlcCgpO1xuICAgIGJ1aWxkUHJlcERvdWJsZVN0ZXAoKTtcblxuICAgIGJ1aWxkUHJlcGFyZUcxKCk7XG4gICAgYnVpbGRQcmVwYXJlRzIoKTtcblxuICAgIGJ1aWxkTWlsbGVyTG9vcCgpO1xuXG4gICAgYnVpbGRGaW5hbEV4cG9uZW50aWF0aW9uT2xkKCk7XG4gICAgYnVpbGRGaW5hbEV4cG9uZW50aWF0aW9uKCk7XG5cbiAgICBmb3IgKGxldCBpPTE7IGk8PTU7IGkrKykge1xuICAgICAgICBidWlsZFBhaXJpbmdFcXVhdGlvbihpKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3BhaXJpbmdFcVwiK2kpO1xuICAgIH1cblxuICAgIGJ1aWxkUGFpcmluZygpO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3BhaXJpbmdcIik7XG5cblxuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihwcmVmaXggKyBcIl9wcmVwYXJlRzFcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX3ByZXBhcmVHMlwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfbWlsbGVyTG9vcFwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfZmluYWxFeHBvbmVudGlhdGlvblwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfZmluYWxFeHBvbmVudGlhdGlvbk9sZFwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24ocHJlZml4ICsgXCJfX2N5Y2xvdG9taWNTcXVhcmVcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKHByZWZpeCArIFwiX19jeWNsb3RvbWljRXhwX3cwXCIpO1xuXG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKGY2bVByZWZpeCArIFwiX211bDFcIik7XG4gICAgbW9kdWxlLmV4cG9ydEZ1bmN0aW9uKGY2bVByZWZpeCArIFwiX211bDAxXCIpO1xuICAgIG1vZHVsZS5leHBvcnRGdW5jdGlvbihmdG1QcmVmaXggKyBcIl9tdWwwMTRcIik7XG5cbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24oZzFtUHJlZml4ICsgXCJfaW5Hcm91cEFmZmluZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24oZzFtUHJlZml4ICsgXCJfaW5Hcm91cFwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24oZzJtUHJlZml4ICsgXCJfaW5Hcm91cEFmZmluZVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0RnVuY3Rpb24oZzJtUHJlZml4ICsgXCJfaW5Hcm91cFwiKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKG1vZHVsZS5mdW5jdGlvbklkeEJ5TmFtZSk7XG59O1xuXG4vKlxuICAgIENvcHlyaWdodCAyMDE5IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2FzbXNuYXJrIChXZWIgQXNzZW1ibHkgemtTbmFyayBQcm92ZXIpLlxuXG4gICAgd2FzbXNuYXJrIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2FzbXNuYXJrIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdhc21zbmFyay4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIG1vZHVsZS5leHBvcnRzLmJuMTI4X3dhc20gPSByZXF1aXJlKFwiLi9idWlsZC9ibjEyOF93YXNtLmpzXCIpO1xuLy8gbW9kdWxlLmV4cG9ydHMuYmxzMTIzODFfd2FzbSA9IHJlcXVpcmUoXCIuL2J1aWxkL2JsczEyMzgxX3dhc20uanNcIik7XG4vLyBtb2R1bGUuZXhwb3J0cy5tbnQ2NzUzX3dhc20gPSByZXF1aXJlKFwiLi9idWlsZC9tbnQ2NzUzX3dhc20uanNcIik7XG5cbnZhciBidWlsZEJuMTI4JDEgPSBidWlsZF9ibjEyODtcbnZhciBidWlsZEJsczEyMzgxJDEgPSBidWlsZF9ibHMxMjM4MTtcblxuLyogZ2xvYmFsIEJpZ0ludCAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlCaWdJbnRzKG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJiaWdpbnRcIiB8fCBvLmVxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG8udG9TdHJpbmcoMTApO1xuICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21ScHJMRShvLCAwKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHN0cmluZ2lmeUJpZ0ludHMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG8pO1xuICAgICAgICBrZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIHJlc1trXSA9IHN0cmluZ2lmeUJpZ0ludHMob1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW5zdHJpbmdpZnlCaWdJbnRzKG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAvXlswLTldKyQvLnRlc3QobykpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChvKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwic3RyaW5nXCIgJiYgL14weFswLTlhLWZBLUZdKyQvLnRlc3QobykpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChvKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHVuc3RyaW5naWZ5QmlnSW50cyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChvID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICByZXNba10gPSB1bnN0cmluZ2lmeUJpZ0ludHMob1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmVCdWZmMmludChidWZmKSB7XG4gICAgbGV0IHJlcyA9IEJpZ0ludCgwKTtcbiAgICBsZXQgaSA9IGJ1ZmYubGVuZ3RoO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgIGlmIChpID49IDQpIHtcbiAgICAgICAgICAgIGkgLT0gNDtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDMyKGkpKSA8PCBCaWdJbnQob2Zmc2V0ICogOCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgfSBlbHNlIGlmIChpID49IDIpIHtcbiAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDE2KGkpKSA8PCBCaWdJbnQob2Zmc2V0ICogOCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDgoaSkpIDw8IEJpZ0ludChvZmZzZXQgKiA4KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGJlSW50MkJ1ZmYobiwgbGVuKSB7XG4gICAgbGV0IHIgPSBuO1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKTtcbiAgICBsZXQgbyA9IGxlbjtcbiAgICB3aGlsZSAobyA+IDApIHtcbiAgICAgICAgaWYgKG8gLSA0ID49IDApIHtcbiAgICAgICAgICAgIG8gLT0gNDtcbiAgICAgICAgICAgIGJ1ZmZWLnNldFVpbnQzMihvLCBOdW1iZXIociAmIEJpZ0ludCgweGZmZmZmZmZmKSkpO1xuICAgICAgICAgICAgciA9IHIgPj4gQmlnSW50KDMyKTtcbiAgICAgICAgfSBlbHNlIGlmIChvIC0gMiA+PSAwKSB7XG4gICAgICAgICAgICBvIC09IDI7XG4gICAgICAgICAgICBidWZmVi5zZXRVaW50MTYobywgTnVtYmVyKHIgJiBCaWdJbnQoMHhmZmZmKSkpO1xuICAgICAgICAgICAgciA9IHIgPj4gQmlnSW50KDE2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG8gLT0gMTtcbiAgICAgICAgICAgIGJ1ZmZWLnNldFVpbnQ4KG8sIE51bWJlcihyICYgQmlnSW50KDB4ZmYpKSk7XG4gICAgICAgICAgICByID0gciA+PiBCaWdJbnQoOCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIGRvZXMgbm90IGZpdCBpbiB0aGlzIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmZ1bmN0aW9uIGxlQnVmZjJpbnQoYnVmZikge1xuICAgIGxldCByZXMgPSBCaWdJbnQoMCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyLCBidWZmLmJ5dGVPZmZzZXQsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgd2hpbGUgKGkgPCBidWZmLmxlbmd0aCkge1xuICAgICAgICBpZiAoaSArIDQgPD0gYnVmZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDMyKGksIHRydWUpKSA8PCBCaWdJbnQoaSAqIDgpO1xuICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICB9IGVsc2UgaWYgKGkgKyAyIDw9IGJ1ZmYubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXMgKz0gQmlnSW50KGJ1ZmZWLmdldFVpbnQxNihpLCB0cnVlKSkgPDwgQmlnSW50KGkgKiA4KTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBCaWdJbnQoYnVmZlYuZ2V0VWludDgoaSwgdHJ1ZSkpIDw8IEJpZ0ludChpICogOCk7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gbGVJbnQyQnVmZihuLCBsZW4pIHtcbiAgICBsZXQgciA9IG47XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbGVuID0gTWF0aC5mbG9vcigoYml0TGVuZ3RoJDYobikgLSAxKSAvIDgpICsgMTtcbiAgICAgICAgaWYgKGxlbiA9PSAwKSBsZW4gPSAxO1xuICAgIH1cbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcik7XG4gICAgbGV0IG8gPSAwO1xuICAgIHdoaWxlIChvIDwgbGVuKSB7XG4gICAgICAgIGlmIChvICsgNCA8PSBsZW4pIHtcbiAgICAgICAgICAgIGJ1ZmZWLnNldFVpbnQzMihvLCBOdW1iZXIociAmIEJpZ0ludCgweGZmZmZmZmZmKSksIHRydWUpO1xuICAgICAgICAgICAgbyArPSA0O1xuICAgICAgICAgICAgciA9IHIgPj4gQmlnSW50KDMyKTtcbiAgICAgICAgfSBlbHNlIGlmIChvICsgMiA8PSBsZW4pIHtcbiAgICAgICAgICAgIGJ1ZmZWLnNldFVpbnQxNihvLCBOdW1iZXIociAmIEJpZ0ludCgweGZmZmYpKSwgdHJ1ZSk7XG4gICAgICAgICAgICBvICs9IDI7XG4gICAgICAgICAgICByID0gciA+PiBCaWdJbnQoMTYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZlYuc2V0VWludDgobywgTnVtYmVyKHIgJiBCaWdJbnQoMHhmZikpLCB0cnVlKTtcbiAgICAgICAgICAgIG8gKz0gMTtcbiAgICAgICAgICAgIHIgPSByID4+IEJpZ0ludCg4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgZG9lcyBub3QgZml0IGluIHRoaXMgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZjtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5RkVsZW1lbnRzKEYsIG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT0gXCJiaWdpbnRcIiB8fCBvLmVxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG8udG9TdHJpbmcoMTApO1xuICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEYudG9TdHJpbmcoRi5lKG8pKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHN0cmluZ2lmeUZFbGVtZW50cy5iaW5kKHRoaXMsIEYpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICByZXNba10gPSBzdHJpbmdpZnlGRWxlbWVudHMoRiwgb1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW5zdHJpbmdpZnlGRWxlbWVudHMoRiwgbykge1xuICAgIGlmICh0eXBlb2YgbyA9PSBcInN0cmluZ1wiICYmIC9eWzAtOV0rJC8udGVzdChvKSkge1xuICAgICAgICByZXR1cm4gRi5lKG8pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAvXjB4WzAtOWEtZkEtRl0rJC8udGVzdChvKSkge1xuICAgICAgICByZXR1cm4gRi5lKG8pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuICAgICAgICByZXR1cm4gby5tYXAodW5zdHJpbmdpZnlGRWxlbWVudHMuYmluZCh0aGlzLCBGKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChvID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICByZXNba10gPSB1bnN0cmluZ2lmeUZFbGVtZW50cyhGLCBvW2tdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxufVxuXG5jb25zdCBfcmV2VGFibGUgPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBfcmV2VGFibGVbaV0gPSBfcmV2U2xvdyhpLCA4KTtcbn1cblxuZnVuY3Rpb24gX3JldlNsb3coaWR4LCBiaXRzKSB7XG4gICAgbGV0IHJlcyA9IDA7XG4gICAgbGV0IGEgPSBpZHg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaXRzOyBpKyspIHtcbiAgICAgICAgcmVzIDw8PSAxO1xuICAgICAgICByZXMgPSByZXMgfCAoYSAmIDEpO1xuICAgICAgICBhID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBiaXRSZXZlcnNlKGlkeCwgYml0cykge1xuICAgIHJldHVybiAoXG4gICAgICAgIChfcmV2VGFibGVbaWR4ID4+PiAyNF0gfFxuICAgICAgICAoX3JldlRhYmxlWyhpZHggPj4+IDE2KSAmIDB4ZmZdIDw8IDgpIHxcbiAgICAgICAgKF9yZXZUYWJsZVsoaWR4ID4+PiA4KSAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgIChfcmV2VGFibGVbaWR4ICYgMHhmZl0gPDwgMjQpKSA+Pj5cbiAgICAgICAgKDMyIC0gYml0cylcbiAgICApO1xufVxuXG5mdW5jdGlvbiBsb2cyKFYpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAoKFYgJiAweGZmZmYwMDAwKSAhPT0gMCA/ICgoViAmPSAweGZmZmYwMDAwKSwgMTYpIDogMCkgfFxuICAgICAgICAoKFYgJiAweGZmMDBmZjAwKSAhPT0gMCA/ICgoViAmPSAweGZmMDBmZjAwKSwgOCkgOiAwKSB8XG4gICAgICAgICgoViAmIDB4ZjBmMGYwZjApICE9PSAwID8gKChWICY9IDB4ZjBmMGYwZjApLCA0KSA6IDApIHxcbiAgICAgICAgKChWICYgMHhjY2NjY2NjYykgIT09IDAgPyAoKFYgJj0gMHhjY2NjY2NjYyksIDIpIDogMCkgfFxuICAgICAgICAoKFYgJiAweGFhYWFhYWFhKSAhPT0gMClcbiAgICApO1xufVxuXG5mdW5jdGlvbiBidWZmUmV2ZXJzZUJpdHMoYnVmZiwgZVNpemUpIHtcbiAgICBjb25zdCBuID0gYnVmZi5ieXRlTGVuZ3RoIC8gZVNpemU7XG4gICAgY29uc3QgYml0cyA9IGxvZzIobik7XG4gICAgaWYgKG4gIT0gMSA8PCBiaXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50ZXJzXCIpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBjb25zdCByID0gYml0UmV2ZXJzZShpLCBiaXRzKTtcbiAgICAgICAgaWYgKGkgPiByKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBidWZmLnNsaWNlKGkgKiBlU2l6ZSwgKGkgKyAxKSAqIGVTaXplKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KGJ1ZmYuc2xpY2UociAqIGVTaXplLCAociArIDEpICogZVNpemUpLCBpICogZVNpemUpO1xuICAgICAgICAgICAgYnVmZi5zZXQodG1wLCByICogZVNpemUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcnJheTJidWZmZXIoYXJyLCBzRykge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRyAqIGFyci5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnVmZi5zZXQoYXJyW2ldLCBpICogc0cpO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmO1xufVxuXG5mdW5jdGlvbiBidWZmZXIyYXJyYXkoYnVmZiwgc0cpIHtcbiAgICBjb25zdCBuID0gYnVmZi5ieXRlTGVuZ3RoIC8gc0c7XG4gICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGJ1ZmYuc2xpY2UoaSAqIHNHLCBpICogc0cgKyBzRyk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5cbnZhciBfdXRpbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGFycmF5MmJ1ZmZlcjogYXJyYXkyYnVmZmVyLFxuICAgIGJlQnVmZjJpbnQ6IGJlQnVmZjJpbnQsXG4gICAgYmVJbnQyQnVmZjogYmVJbnQyQnVmZixcbiAgICBiaXRSZXZlcnNlOiBiaXRSZXZlcnNlLFxuICAgIGJ1ZmZSZXZlcnNlQml0czogYnVmZlJldmVyc2VCaXRzLFxuICAgIGJ1ZmZlcjJhcnJheTogYnVmZmVyMmFycmF5LFxuICAgIGxlQnVmZjJpbnQ6IGxlQnVmZjJpbnQsXG4gICAgbGVJbnQyQnVmZjogbGVJbnQyQnVmZixcbiAgICBsb2cyOiBsb2cyLFxuICAgIHN0cmluZ2lmeUJpZ0ludHM6IHN0cmluZ2lmeUJpZ0ludHMsXG4gICAgc3RyaW5naWZ5RkVsZW1lbnRzOiBzdHJpbmdpZnlGRWxlbWVudHMsXG4gICAgdW5zdHJpbmdpZnlCaWdJbnRzOiB1bnN0cmluZ2lmeUJpZ0ludHMsXG4gICAgdW5zdHJpbmdpZnlGRWxlbWVudHM6IHVuc3RyaW5naWZ5RkVsZW1lbnRzXG59KTtcblxuY29uc3QgUEFHRV9TSVpFID0gMTw8MzA7XG5cbmNsYXNzIEJpZ0J1ZmZlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSBzaXplO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8c2l6ZTsgaSs9IFBBR0VfU0laRSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKHNpemUtaSwgUEFHRV9TSVpFKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KG4pKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgc2xpY2UoZnIsIHRvKSB7XG4gICAgICAgIGlmICggdG8gPT09IHVuZGVmaW5lZCApIHRvID0gdGhpcy5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAoIGZyID09PSB1bmRlZmluZWQgKSBmciA9IDA7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRvLWZyO1xuXG4gICAgICAgIGNvbnN0IGZpcnN0UGFnZSA9IE1hdGguZmxvb3IoZnIgLyBQQUdFX1NJWkUpO1xuICAgICAgICBjb25zdCBsYXN0UGFnZSA9IE1hdGguZmxvb3IoKGZyK2xlbi0xKSAvIFBBR0VfU0laRSk7XG5cbiAgICAgICAgaWYgKChmaXJzdFBhZ2UgPT0gbGFzdFBhZ2UpfHwobGVuPT0wKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbZmlyc3RQYWdlXS5zbGljZShmciVQQUdFX1NJWkUsIGZyJVBBR0VfU0laRSArIGxlbik7XG5cbiAgICAgICAgbGV0IGJ1ZmY7XG5cbiAgICAgICAgbGV0IHAgPSBmaXJzdFBhZ2U7XG4gICAgICAgIGxldCBvID0gZnIgJSBQQUdFX1NJWkU7XG4gICAgICAgIC8vIFJlbWFpbmluZyBieXRlcyB0byByZWFkXG4gICAgICAgIGxldCByID0gbGVuO1xuICAgICAgICB3aGlsZSAocj4wKSB7XG4gICAgICAgICAgICAvLyBieXRlcyB0byBjb3B5IGZyb20gdGhpcyBwYWdlXG4gICAgICAgICAgICBjb25zdCBsID0gKG8rciA+IFBBR0VfU0laRSkgPyAoUEFHRV9TSVpFIC1vKSA6IHI7XG4gICAgICAgICAgICBjb25zdCBzcmNWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXJzW3BdLmJ1ZmZlciwgdGhpcy5idWZmZXJzW3BdLmJ5dGVPZmZzZXQrbywgbCk7XG4gICAgICAgICAgICBpZiAobCA9PSBsZW4pIHJldHVybiBzcmNWaWV3LnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoIWJ1ZmYpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVuIDw9IFBBR0VfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmID0gbmV3IEJpZ0J1ZmZlcihsZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmYuc2V0KHNyY1ZpZXcsIGxlbi1yKTtcbiAgICAgICAgICAgIHIgPSByLWw7XG4gICAgICAgICAgICBwICsrO1xuICAgICAgICAgICAgbyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnVmZjtcbiAgICB9XG5cbiAgICBzZXQoYnVmZiwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkgb2Zmc2V0ID0gMDtcblxuICAgICAgICBjb25zdCBsZW4gPSBidWZmLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbj09MCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGZpcnN0UGFnZSA9IE1hdGguZmxvb3Iob2Zmc2V0IC8gUEFHRV9TSVpFKTtcbiAgICAgICAgY29uc3QgbGFzdFBhZ2UgPSBNYXRoLmZsb29yKChvZmZzZXQrbGVuLTEpIC8gUEFHRV9TSVpFKTtcblxuICAgICAgICBpZiAoZmlyc3RQYWdlID09IGxhc3RQYWdlKSB7XG4gICAgICAgICAgICBpZiAoKGJ1ZmYgaW5zdGFuY2VvZiBCaWdCdWZmZXIpJiYoYnVmZi5idWZmZXJzLmxlbmd0aD09MSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzW2ZpcnN0UGFnZV0uc2V0KGJ1ZmYuYnVmZmVyc1swXSwgb2Zmc2V0ICUgUEFHRV9TSVpFKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyc1tmaXJzdFBhZ2VdLnNldChidWZmLCBvZmZzZXQgJSBQQUdFX1NJWkUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuXG4gICAgICAgIGxldCBwID0gZmlyc3RQYWdlO1xuICAgICAgICBsZXQgbyA9IG9mZnNldCAlIFBBR0VfU0laRTtcbiAgICAgICAgbGV0IHIgPSBsZW47XG4gICAgICAgIHdoaWxlIChyPjApIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSAobytyID4gUEFHRV9TSVpFKSA/IChQQUdFX1NJWkUgLW8pIDogcjtcbiAgICAgICAgICAgIGNvbnN0IHNyY1ZpZXcgPSBidWZmLnNsaWNlKCBsZW4gLXIsIGxlbiAtcitsKTtcbiAgICAgICAgICAgIGNvbnN0IGRzdFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcnNbcF0uYnVmZmVyLCB0aGlzLmJ1ZmZlcnNbcF0uYnl0ZU9mZnNldCArIG8sIGwpO1xuICAgICAgICAgICAgZHN0Vmlldy5zZXQoc3JjVmlldyk7XG4gICAgICAgICAgICByID0gci1sO1xuICAgICAgICAgICAgcCArKztcbiAgICAgICAgICAgIG8gPSAwO1xuICAgICAgICB9XG5cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQmF0Y2hDb252ZXJ0KHRtLCBmbk5hbWUsIHNJbiwgc091dCkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiBiYXRjaENvbnZlcnQoYnVmZkluKSB7XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmZJbi5ieXRlTGVuZ3RoIC8gc0luKTtcbiAgICAgICAgaWYgKCBuUG9pbnRzICogc0luICE9PSBidWZmSW4uYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBidWZmZXIgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludHNQZXJDaHVuayA9IE1hdGguZmxvb3IoblBvaW50cy90bS5jb25jdXJyZW5jeSk7XG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRtLmNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGk8IHRtLmNvbmN1cnJlbmN5LTEpIHtcbiAgICAgICAgICAgICAgICBuID0gcG9pbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzIC0gaSpwb2ludHNQZXJDaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuPT0wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZkNodW5rID0gYnVmZkluLnNsaWNlKGkqcG9pbnRzUGVyQ2h1bmsqc0luLCBpKnBvaW50c1BlckNodW5rKnNJbiArIG4qc0luKTtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXG4gICAgICAgICAgICAgICAge2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6YnVmZkNodW5rfSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkFMTE9DXCIsIHZhcjogMSwgbGVuOnNPdXQgKiBufSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk5hbWUsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhbDogbn0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDF9XG4gICAgICAgICAgICAgICAgXX0sXG4gICAgICAgICAgICAgICAge2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDEsIGxlbjpzT3V0ICogbn0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIHRtLnF1ZXVlQWN0aW9uKHRhc2spXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgbGV0IGZ1bGxCdWZmT3V0O1xuICAgICAgICBpZiAoYnVmZkluIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dCA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzT3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dC5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bGxCdWZmT3V0O1xuICAgIH07XG59XG5cbmNsYXNzIFdhc21GaWVsZDEge1xuXG4gICAgY29uc3RydWN0b3IodG0sIHByZWZpeCwgbjgsIHApIHtcbiAgICAgICAgdGhpcy50bSA9IHRtO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcblxuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLm44ID0gbjg7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiRjFcIjtcbiAgICAgICAgdGhpcy5tID0gMTtcblxuICAgICAgICB0aGlzLmhhbGYgPSBzaGlmdFJpZ2h0KHAsIG9uZSk7XG4gICAgICAgIHRoaXMuYml0TGVuZ3RoID0gYml0TGVuZ3RoJDYocCk7XG4gICAgICAgIHRoaXMubWFzayA9IHN1YihzaGlmdExlZnQob25lLCB0aGlzLmJpdExlbmd0aCksIG9uZSk7XG5cbiAgICAgICAgdGhpcy5wT3AxID0gdG0uYWxsb2MobjgpO1xuICAgICAgICB0aGlzLnBPcDIgPSB0bS5hbGxvYyhuOCk7XG4gICAgICAgIHRoaXMucE9wMyA9IHRtLmFsbG9jKG44KTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3ByZWZpeCArIFwiX3plcm9cIl0odGhpcy5wT3AxKTtcbiAgICAgICAgdGhpcy56ZXJvID0gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgdGhpcy5uOCk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1twcmVmaXggKyBcIl9vbmVcIl0odGhpcy5wT3AxKTtcbiAgICAgICAgdGhpcy5vbmUgPSB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AxLCB0aGlzLm44KTtcblxuICAgICAgICB0aGlzLm5lZ29uZSA9IHRoaXMubmVnKHRoaXMub25lKTtcbiAgICAgICAgdGhpcy50d28gPSB0aGlzLmFkZCh0aGlzLm9uZSwgdGhpcy5vbmUpO1xuXG4gICAgICAgIHRoaXMubjY0ID0gTWF0aC5mbG9vcihuOC84KTtcbiAgICAgICAgdGhpcy5uMzIgPSBNYXRoLmZsb29yKG44LzQpO1xuXG4gICAgICAgIGlmKHRoaXMubjY0KjggIT0gdGhpcy5uOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibjggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDhcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhhbGYgPSBzaGlmdFJpZ2h0KHRoaXMucCwgb25lKTtcbiAgICAgICAgdGhpcy5ucXIgPSB0aGlzLnR3bztcbiAgICAgICAgbGV0IHIgPSB0aGlzLmV4cCh0aGlzLm5xciwgdGhpcy5oYWxmKTtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmVxKHIsIHRoaXMubmVnb25lKSkge1xuICAgICAgICAgICAgdGhpcy5ucXIgPSB0aGlzLmFkZCh0aGlzLm5xciwgdGhpcy5vbmUpO1xuICAgICAgICAgICAgciA9IHRoaXMuZXhwKHRoaXMubnFyLCB0aGlzLmhhbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaGlmdCA9IHRoaXMubXVsKHRoaXMubnFyLCB0aGlzLm5xcik7XG4gICAgICAgIHRoaXMuc2hpZnRJbnYgPSB0aGlzLmludih0aGlzLnNoaWZ0KTtcblxuICAgICAgICB0aGlzLnMgPSAwO1xuICAgICAgICBsZXQgdCA9IHN1Yih0aGlzLnAsIG9uZSk7XG5cbiAgICAgICAgd2hpbGUgKCAhaXNPZGQkNSh0KSApIHtcbiAgICAgICAgICAgIHRoaXMucyA9IHRoaXMucyArIDE7XG4gICAgICAgICAgICB0ID0gc2hpZnRSaWdodCh0LCBvbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53ID0gW107XG4gICAgICAgIHRoaXMud1t0aGlzLnNdID0gdGhpcy5leHAodGhpcy5ucXIsIHQpO1xuXG4gICAgICAgIGZvciAobGV0IGk9IHRoaXMucy0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMud1tpXSA9IHRoaXMuc3F1YXJlKHRoaXMud1tpKzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5lcSh0aGlzLndbMF0sIHRoaXMub25lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY2FsY3VsYXRpbmcgcm9vdHMgb2YgdW5pdHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJhdGNoVG9Nb250Z29tZXJ5ID0gYnVpbGRCYXRjaENvbnZlcnQodG0sIHByZWZpeCArIFwiX2JhdGNoVG9Nb250Z29tZXJ5XCIsIHRoaXMubjgsIHRoaXMubjgpO1xuICAgICAgICB0aGlzLmJhdGNoRnJvbU1vbnRnb21lcnkgPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hGcm9tTW9udGdvbWVyeVwiLCB0aGlzLm44LCB0aGlzLm44KTtcbiAgICB9XG5cblxuICAgIG9wMihvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgb3AyQm9vbChvcE5hbWUsIGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyKTtcbiAgICB9XG5cbiAgICBvcDEob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIG9wMUJvb2wob3BOYW1lLCBhKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICByZXR1cm4gISF0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBvcE5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AzKTtcbiAgICB9XG5cbiAgICBhZGQoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRcIiwgYSwgYik7XG4gICAgfVxuXG5cbiAgICBlcShhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyQm9vbChcIl9lcVwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzWmVyb1wiLCBhKTtcbiAgICB9XG5cbiAgICBzdWIoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9zdWJcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX25lZ1wiLCBhKTtcbiAgICB9XG5cbiAgICBpbnYoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfaW52ZXJzZVwiLCBhKTtcbiAgICB9XG5cbiAgICB0b01vbnRnb21lcnkoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfdG9Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIGZyb21Nb250Z29tZXJ5KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX2Zyb21Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIG11bChhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX211bFwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2ludmVyc2VcIl0odGhpcy5wT3AyLCB0aGlzLnBPcDIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9tdWxcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfc3F1YXJlXCIsIGEpO1xuICAgIH1cblxuICAgIGlzU3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1NxdWFyZVwiLCBhKTtcbiAgICB9XG5cbiAgICBzcXJ0KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3NxcnRcIiwgYSk7XG4gICAgfVxuXG4gICAgZXhwKGEsIGIpIHtcbiAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBiID0gdG9MRUJ1ZmYoZShiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9leHBcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIGIuYnl0ZUxlbmd0aCwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIGlzTmVnYXRpdmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzTmVnYXRpdmVcIiwgYSk7XG4gICAgfVxuXG4gICAgZShhLCBiKSB7XG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkgcmV0dXJuIGE7XG4gICAgICAgIGxldCByYSA9IGUoYSwgYik7XG4gICAgICAgIGlmIChpc05lZ2F0aXZlJDQocmEpKSB7XG4gICAgICAgICAgICByYSA9IG5lZyhyYSk7XG4gICAgICAgICAgICBpZiAoZ3QocmEsIHRoaXMucCkpIHtcbiAgICAgICAgICAgICAgICByYSA9IG1vZChyYSwgdGhpcy5wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhID0gc3ViKHRoaXMucCwgcmEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGd0KHJhLCB0aGlzLnApKSB7XG4gICAgICAgICAgICAgICAgcmEgPSBtb2QocmEsIHRoaXMucCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZiA9IGxlSW50MkJ1ZmYocmEsIHRoaXMubjgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b01vbnRnb21lcnkoYnVmZik7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoYSwgcmFkaXgpIHtcbiAgICAgICAgY29uc3QgYW4gPSB0aGlzLmZyb21Nb250Z29tZXJ5KGEpO1xuICAgICAgICBjb25zdCBzID0gZnJvbVJwckxFKGFuLCAwKTtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHMsIHJhZGl4KTtcbiAgICB9XG5cbiAgICBmcm9tUm5nKHJuZykge1xuICAgICAgICBsZXQgdjtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubjgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2ID0gemVybztcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLm42NDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdiA9IGFkZCh2LCAgc2hpZnRMZWZ0KHJuZy5uZXh0VTY0KCksIDY0KmkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYgPSBiYW5kKHYsIHRoaXMubWFzayk7XG4gICAgICAgIH0gd2hpbGUgKGdlcSh2LCB0aGlzLnApKTtcbiAgICAgICAgdG9ScHJMRShidWZmLCAwLCB2LCB0aGlzLm44KTtcbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfVxuXG4gICAgcmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tUm5nKGdldFRocmVhZFJuZygpKTtcbiAgICB9XG5cbiAgICB0b09iamVjdChhKSB7XG4gICAgICAgIGNvbnN0IGFuID0gdGhpcy5mcm9tTW9udGdvbWVyeShhKTtcbiAgICAgICAgcmV0dXJuIGZyb21ScHJMRShhbiwgMCk7XG4gICAgfVxuXG4gICAgZnJvbU9iamVjdChhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLm44KTtcbiAgICAgICAgdG9ScHJMRShidWZmLCAwLCBhLCB0aGlzLm44KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Nb250Z29tZXJ5KGJ1ZmYpO1xuICAgIH1cblxuICAgIHRvUnByTEUoYnVmZiwgb2Zmc2V0LCBhKSB7XG4gICAgICAgIGJ1ZmYuc2V0KHRoaXMuZnJvbU1vbnRnb21lcnkoYSksIG9mZnNldCk7XG4gICAgfVxuXG4gICAgdG9ScHJCRShidWZmLCBvZmZzZXQsIGEpIHtcbiAgICAgICAgY29uc3QgYnVmZjIgPSB0aGlzLmZyb21Nb250Z29tZXJ5KGEpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5uOC8yOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF1eCA9IGJ1ZmYyW2ldO1xuICAgICAgICAgICAgYnVmZjJbaV0gPSBidWZmMlt0aGlzLm44LTEtaV07XG4gICAgICAgICAgICBidWZmMlt0aGlzLm44LTEtaV0gPSBhdXg7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZi5zZXQoYnVmZjIsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgZnJvbVJwckxFKGJ1ZmYsIG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZi5zbGljZShvZmZzZXQsIG9mZnNldCArIHRoaXMubjgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b01vbnRnb21lcnkocmVzKTtcbiAgICB9XG5cbiAgICBhc3luYyBiYXRjaEludmVyc2UoYnVmZkluKSB7XG4gICAgICAgIGxldCByZXR1cm5BcnJheSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzSW4gPSB0aGlzLm44O1xuICAgICAgICBjb25zdCBzT3V0ID0gdGhpcy5uODtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmSW4pKSB7XG4gICAgICAgICAgICBidWZmSW4gPSBhcnJheTJidWZmZXIoYnVmZkluLCBzSW4gKTtcbiAgICAgICAgICAgIHJldHVybkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZJbiA9IGJ1ZmZJbi5zbGljZSgwLCBidWZmSW4uYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuUG9pbnRzID0gTWF0aC5mbG9vcihidWZmSW4uYnl0ZUxlbmd0aCAvIHNJbik7XG4gICAgICAgIGlmICggblBvaW50cyAqIHNJbiAhPT0gYnVmZkluLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnVmZmVyIHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRzUGVyQ2h1bmsgPSBNYXRoLmZsb29yKG5Qb2ludHMvdGhpcy50bS5jb25jdXJyZW5jeSk7XG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMudG0uY29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgdGhpcy50bS5jb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IHBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqcG9pbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZDaHVuayA9IGJ1ZmZJbi5zbGljZShpKnBvaW50c1BlckNodW5rKnNJbiwgaSpwb2ludHNQZXJDaHVuaypzSW4gKyBuKnNJbik7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW1xuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOmJ1ZmZDaHVua30sXG4gICAgICAgICAgICAgICAge2NtZDogXCJBTExPQ1wiLCB2YXI6IDEsIGxlbjpzT3V0ICogbn0sXG4gICAgICAgICAgICAgICAge2NtZDogXCJDQUxMXCIsIGZuTmFtZTogdGhpcy5wcmVmaXggKyBcIl9iYXRjaEludmVyc2VcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBzSW59LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IHNPdXR9LFxuICAgICAgICAgICAgICAgIF19LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAxLCBsZW46c091dCAqIG59LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0aGlzLnRtLnF1ZXVlQWN0aW9uKHRhc2spXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgbGV0IGZ1bGxCdWZmT3V0O1xuICAgICAgICBpZiAoYnVmZkluIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dCA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzT3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzT3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dC5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVybkFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyMmFycmF5KGZ1bGxCdWZmT3V0LCBzT3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdWxsQnVmZk91dDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbmNsYXNzIFdhc21GaWVsZDIge1xuXG4gICAgY29uc3RydWN0b3IodG0sIHByZWZpeCwgRikge1xuICAgICAgICB0aGlzLnRtID0gdG07XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuXG4gICAgICAgIHRoaXMuRiA9IEY7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiRjJcIjtcbiAgICAgICAgdGhpcy5tID0gRi5tICogMjtcbiAgICAgICAgdGhpcy5uOCA9IHRoaXMuRi5uOCoyO1xuICAgICAgICB0aGlzLm4zMiA9IHRoaXMuRi5uMzIqMjtcbiAgICAgICAgdGhpcy5uNjQgPSB0aGlzLkYubjY0KjI7XG5cbiAgICAgICAgdGhpcy5wT3AxID0gdG0uYWxsb2MoRi5uOCoyKTtcbiAgICAgICAgdGhpcy5wT3AyID0gdG0uYWxsb2MoRi5uOCoyKTtcbiAgICAgICAgdGhpcy5wT3AzID0gdG0uYWxsb2MoRi5uOCoyKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3ByZWZpeCArIFwiX3plcm9cIl0odGhpcy5wT3AxKTtcbiAgICAgICAgdGhpcy56ZXJvID0gdG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMubjgpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfb25lXCJdKHRoaXMucE9wMSk7XG4gICAgICAgIHRoaXMub25lID0gdG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMubjgpO1xuXG4gICAgICAgIHRoaXMubmVnb25lID0gdGhpcy5uZWcodGhpcy5vbmUpO1xuICAgICAgICB0aGlzLnR3byA9IHRoaXMuYWRkKHRoaXMub25lLCB0aGlzLm9uZSk7XG5cbiAgICB9XG5cbiAgICBvcDIob3BOYW1lLCBhLCBiKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIG9wMkJvb2wob3BOYW1lLCBhLCBiKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgcmV0dXJuICEhdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMik7XG4gICAgfVxuXG4gICAgb3AxKG9wTmFtZSwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBvcDFCb29sKG9wTmFtZSwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgcmV0dXJuICEhdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMyk7XG4gICAgfVxuXG4gICAgYWRkKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfYWRkXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIGVxKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDJCb29sKFwiX2VxXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIGlzWmVybyhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMUJvb2woXCJfaXNaZXJvXCIsIGEpO1xuICAgIH1cblxuICAgIHN1YihhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1YlwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBuZWcoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfbmVnXCIsIGEpO1xuICAgIH1cblxuICAgIGludihhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9pbnZlcnNlXCIsIGEpO1xuICAgIH1cblxuICAgIGlzTmVnYXRpdmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzTmVnYXRpdmVcIiwgYSk7XG4gICAgfVxuXG4gICAgdG9Nb250Z29tZXJ5KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3RvTW9udGdvbWVyeVwiLCBhKTtcbiAgICB9XG5cbiAgICBmcm9tTW9udGdvbWVyeShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9mcm9tTW9udGdvbWVyeVwiLCBhKTtcbiAgICB9XG5cbiAgICBtdWwoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9tdWxcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgbXVsMShhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX211bDFcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgZGl2KGEsIGIpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9pbnZlcnNlXCJdKHRoaXMucE9wMiwgdGhpcy5wT3AyKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfbXVsXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5uOCk7XG4gICAgfVxuXG4gICAgc3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3NxdWFyZVwiLCBhKTtcbiAgICB9XG5cbiAgICBpc1NxdWFyZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMUJvb2woXCJfaXNTcXVhcmVcIiwgYSk7XG4gICAgfVxuXG4gICAgc3FydChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9zcXJ0XCIsIGEpO1xuICAgIH1cblxuICAgIGV4cChhLCBiKSB7XG4gICAgICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgYiA9IHRvTEVCdWZmKGUoYikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfZXhwXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCBiLmJ5dGVMZW5ndGgsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBlKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gYTtcbiAgICAgICAgaWYgKChBcnJheS5pc0FycmF5KGEpKSAmJiAoYS5sZW5ndGggPT0gMikpIHtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLmUoYVswXSwgYik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5lKGFbMV0sIGIpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgcmVzLnNldChjMSk7XG4gICAgICAgICAgICByZXMuc2V0KGMyLCB0aGlzLkYubjgqMik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBGMlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvU3RyaW5nKGEsIHJhZGl4KSB7XG4gICAgICAgIGNvbnN0IHMxID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UoMCwgdGhpcy5GLm44KSwgcmFkaXgpO1xuICAgICAgICBjb25zdCBzMiA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKHRoaXMuRi5uOCksIHJhZGl4KTtcbiAgICAgICAgcmV0dXJuIGBbJHtzMX0sICR7czJ9XWA7XG4gICAgfVxuXG4gICAgZnJvbVJuZyhybmcpIHtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCoyKTtcbiAgICAgICAgcmVzLnNldChjMSk7XG4gICAgICAgIHJlcy5zZXQoYzIsIHRoaXMuRi5uOCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgcmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tUm5nKGdldFRocmVhZFJuZygpKTtcbiAgICB9XG5cbiAgICB0b09iamVjdChhKSB7XG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5GLnRvT2JqZWN0KGEuc2xpY2UoMCwgdGhpcy5GLm44KSk7XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy5GLnRvT2JqZWN0KGEuc2xpY2UodGhpcy5GLm44LCB0aGlzLkYubjgqMikpO1xuICAgICAgICByZXR1cm4gW2MxLCBjMl07XG4gICAgfVxuXG4gICAgZnJvbU9iamVjdChhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMik7XG4gICAgICAgIGNvbnN0IGIxID0gdGhpcy5GLmZyb21PYmplY3QoYVswXSk7XG4gICAgICAgIGNvbnN0IGIyID0gdGhpcy5GLmZyb21PYmplY3QoYVsxXSk7XG4gICAgICAgIGJ1ZmYuc2V0KGIxKTtcbiAgICAgICAgYnVmZi5zZXQoYjIsIHRoaXMuRi5uOCk7XG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH1cblxuICAgIGMxKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuc2xpY2UoMCwgdGhpcy5GLm44KTtcbiAgICB9XG5cbiAgICBjMihhKSB7XG4gICAgICAgIHJldHVybiBhLnNsaWNlKHRoaXMuRi5uOCk7XG4gICAgfVxuXG59XG5cbmNsYXNzIFdhc21GaWVsZDMge1xuXG4gICAgY29uc3RydWN0b3IodG0sIHByZWZpeCwgRikge1xuICAgICAgICB0aGlzLnRtID0gdG07XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuXG4gICAgICAgIHRoaXMuRiA9IEY7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiRjNcIjtcbiAgICAgICAgdGhpcy5tID0gRi5tICogMztcbiAgICAgICAgdGhpcy5uOCA9IHRoaXMuRi5uOCozO1xuICAgICAgICB0aGlzLm4zMiA9IHRoaXMuRi5uMzIqMztcbiAgICAgICAgdGhpcy5uNjQgPSB0aGlzLkYubjY0KjM7XG5cbiAgICAgICAgdGhpcy5wT3AxID0gdG0uYWxsb2MoRi5uOCozKTtcbiAgICAgICAgdGhpcy5wT3AyID0gdG0uYWxsb2MoRi5uOCozKTtcbiAgICAgICAgdGhpcy5wT3AzID0gdG0uYWxsb2MoRi5uOCozKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3ByZWZpeCArIFwiX3plcm9cIl0odGhpcy5wT3AxKTtcbiAgICAgICAgdGhpcy56ZXJvID0gdG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMubjgpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbcHJlZml4ICsgXCJfb25lXCJdKHRoaXMucE9wMSk7XG4gICAgICAgIHRoaXMub25lID0gdG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMubjgpO1xuXG4gICAgICAgIHRoaXMubmVnb25lID0gdGhpcy5uZWcodGhpcy5vbmUpO1xuICAgICAgICB0aGlzLnR3byA9IHRoaXMuYWRkKHRoaXMub25lLCB0aGlzLm9uZSk7XG5cbiAgICB9XG5cbiAgICBvcDIob3BOYW1lLCBhLCBiKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIG9wMkJvb2wob3BOYW1lLCBhLCBiKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgcmV0dXJuICEhdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMik7XG4gICAgfVxuXG4gICAgb3AxKG9wTmFtZSwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBvcDFCb29sKG9wTmFtZSwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgcmV0dXJuICEhdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMyk7XG4gICAgfVxuXG5cbiAgICBlcShhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyQm9vbChcIl9lcVwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzWmVyb1wiLCBhKTtcbiAgICB9XG5cbiAgICBhZGQoYSxiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRcIiwgYSwgYik7XG4gICAgfVxuXG4gICAgc3ViKGEsYikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfc3ViXCIsIGEsIGIpO1xuICAgIH1cblxuICAgIG5lZyhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9uZWdcIiwgYSk7XG4gICAgfVxuXG4gICAgaW52KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX2ludmVyc2VcIiwgYSk7XG4gICAgfVxuXG4gICAgaXNOZWdhdGl2ZShhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wMUJvb2woXCJfaXNOZWdhdGl2ZVwiLCBhKTtcbiAgICB9XG5cbiAgICB0b01vbnRnb21lcnkoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfdG9Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIGZyb21Nb250Z29tZXJ5KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX2Zyb21Nb250Z29tZXJ5XCIsIGEpO1xuICAgIH1cblxuICAgIG11bChhLGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX211bFwiLCBhLCBiKTtcbiAgICB9XG5cbiAgICBkaXYoYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX2ludmVyc2VcIl0odGhpcy5wT3AyLCB0aGlzLnBPcDIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9tdWxcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLm44KTtcbiAgICB9XG5cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfc3F1YXJlXCIsIGEpO1xuICAgIH1cblxuICAgIGlzU3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1NxdWFyZVwiLCBhKTtcbiAgICB9XG5cbiAgICBzcXJ0KGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3NxcnRcIiwgYSk7XG4gICAgfVxuXG4gICAgZXhwKGEsIGIpIHtcbiAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBiID0gdG9MRUJ1ZmYoZShiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDIsIGIpO1xuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9leHBcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIGIuYnl0ZUxlbmd0aCwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMubjgpO1xuICAgIH1cblxuICAgIGUoYSwgYikge1xuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHJldHVybiBhO1xuICAgICAgICBpZiAoKEFycmF5LmlzQXJyYXkoYSkpICYmIChhLmxlbmd0aCA9PSAzKSkge1xuICAgICAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZShhWzBdLCBiKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gdGhpcy5GLmUoYVsxXSwgYik7XG4gICAgICAgICAgICBjb25zdCBjMyA9IHRoaXMuRi5lKGFbMl0sIGIpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjMpO1xuICAgICAgICAgICAgcmVzLnNldChjMSk7XG4gICAgICAgICAgICByZXMuc2V0KGMyLCB0aGlzLkYubjgpO1xuICAgICAgICAgICAgcmVzLnNldChjMywgdGhpcy5GLm44KjIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgRjNcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZyhhLCByYWRpeCkge1xuICAgICAgICBjb25zdCBzMSA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKDAsIHRoaXMuRi5uOCksIHJhZGl4KTtcbiAgICAgICAgY29uc3QgczIgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSh0aGlzLkYubjgsIHRoaXMuRi5uOCoyKSwgcmFkaXgpO1xuICAgICAgICBjb25zdCBzMyA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKHRoaXMuRi5uOCoyKSwgcmFkaXgpO1xuICAgICAgICByZXR1cm4gYFske3MxfSwgJHtzMn0sICR7czN9XWA7XG4gICAgfVxuXG4gICAgZnJvbVJuZyhybmcpIHtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLkYuZnJvbVJuZyhybmcpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi5mcm9tUm5nKHJuZyk7XG4gICAgICAgIGNvbnN0IGMzID0gdGhpcy5GLmZyb21Sbmcocm5nKTtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjMpO1xuICAgICAgICByZXMuc2V0KGMxKTtcbiAgICAgICAgcmVzLnNldChjMiwgdGhpcy5GLm44KTtcbiAgICAgICAgcmVzLnNldChjMywgdGhpcy5GLm44KjIpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVJuZyhnZXRUaHJlYWRSbmcoKSk7XG4gICAgfVxuXG4gICAgdG9PYmplY3QoYSkge1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKDAsIHRoaXMuRi5uOCkpO1xuICAgICAgICBjb25zdCBjMiA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpKTtcbiAgICAgICAgY29uc3QgYzMgPSB0aGlzLkYudG9PYmplY3QoYS5zbGljZSh0aGlzLkYubjgqMiwgdGhpcy5GLm44KjMpKTtcbiAgICAgICAgcmV0dXJuIFtjMSwgYzIsIGMzXTtcbiAgICB9XG5cbiAgICBmcm9tT2JqZWN0KGEpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCozKTtcbiAgICAgICAgY29uc3QgYjEgPSB0aGlzLkYuZnJvbU9iamVjdChhWzBdKTtcbiAgICAgICAgY29uc3QgYjIgPSB0aGlzLkYuZnJvbU9iamVjdChhWzFdKTtcbiAgICAgICAgY29uc3QgYjMgPSB0aGlzLkYuZnJvbU9iamVjdChhWzJdKTtcbiAgICAgICAgYnVmZi5zZXQoYjEpO1xuICAgICAgICBidWZmLnNldChiMiwgdGhpcy5GLm44KTtcbiAgICAgICAgYnVmZi5zZXQoYjMsIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfVxuXG4gICAgYzEoYSkge1xuICAgICAgICByZXR1cm4gYS5zbGljZSgwLCB0aGlzLkYubjgpO1xuICAgIH1cblxuICAgIGMyKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuc2xpY2UodGhpcy5GLm44LCB0aGlzLkYubjgqMik7XG4gICAgfVxuXG4gICAgYzMoYSkge1xuICAgICAgICByZXR1cm4gYS5zbGljZSh0aGlzLkYubjgqMik7XG4gICAgfVxuXG59XG5cbmNsYXNzIFdhc21DdXJ2ZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0bSwgcHJlZml4LCBGLCBwR2VuLCBwR2IsIGNvZmFjdG9yKSB7XG4gICAgICAgIHRoaXMudG0gPSB0bTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIHRoaXMuRiA9IEY7XG5cbiAgICAgICAgdGhpcy5wT3AxID0gdG0uYWxsb2MoRi5uOCozKTtcbiAgICAgICAgdGhpcy5wT3AyID0gdG0uYWxsb2MoRi5uOCozKTtcbiAgICAgICAgdGhpcy5wT3AzID0gdG0uYWxsb2MoRi5uOCozKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3ByZWZpeCArIFwiX3plcm9cIl0odGhpcy5wT3AxKTtcbiAgICAgICAgdGhpcy56ZXJvID0gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgRi5uOCozKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3ByZWZpeCArIFwiX3plcm9BZmZpbmVcIl0odGhpcy5wT3AxKTtcbiAgICAgICAgdGhpcy56ZXJvQWZmaW5lID0gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMSwgRi5uOCoyKTtcbiAgICAgICAgdGhpcy5vbmUgPSB0aGlzLnRtLmdldEJ1ZmYocEdlbiwgRi5uOCozKTtcbiAgICAgICAgdGhpcy5nID0gdGhpcy5vbmU7XG4gICAgICAgIHRoaXMub25lQWZmaW5lID0gdGhpcy50bS5nZXRCdWZmKHBHZW4sIEYubjgqMik7XG4gICAgICAgIHRoaXMuZ0FmZmluZSA9IHRoaXMub25lQWZmaW5lO1xuICAgICAgICB0aGlzLmIgPSB0aGlzLnRtLmdldEJ1ZmYocEdiLCBGLm44KTtcblxuICAgICAgICBpZiAoY29mYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29mYWN0b3IgPSB0b0xFQnVmZihjb2ZhY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5lZ29uZSA9IHRoaXMubmVnKHRoaXMub25lKTtcbiAgICAgICAgdGhpcy50d28gPSB0aGlzLmFkZCh0aGlzLm9uZSwgdGhpcy5vbmUpO1xuXG4gICAgICAgIHRoaXMuYmF0Y2hMRU10b0MgPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hMRU10b0NcIiwgRi5uOCoyLCBGLm44KTtcbiAgICAgICAgdGhpcy5iYXRjaExFTXRvVSA9IGJ1aWxkQmF0Y2hDb252ZXJ0KHRtLCBwcmVmaXggKyBcIl9iYXRjaExFTXRvVVwiLCBGLm44KjIsIEYubjgqMik7XG4gICAgICAgIHRoaXMuYmF0Y2hDdG9MRU0gPSBidWlsZEJhdGNoQ29udmVydCh0bSwgcHJlZml4ICsgXCJfYmF0Y2hDdG9MRU1cIiwgRi5uOCwgRi5uOCoyKTtcbiAgICAgICAgdGhpcy5iYXRjaFV0b0xFTSA9IGJ1aWxkQmF0Y2hDb252ZXJ0KHRtLCBwcmVmaXggKyBcIl9iYXRjaFV0b0xFTVwiLCBGLm44KjIsIEYubjgqMik7XG4gICAgICAgIHRoaXMuYmF0Y2hUb0phY29iaWFuID0gYnVpbGRCYXRjaENvbnZlcnQodG0sIHByZWZpeCArIFwiX2JhdGNoVG9KYWNvYmlhblwiLCBGLm44KjIsIEYubjgqMyk7XG4gICAgICAgIHRoaXMuYmF0Y2hUb0FmZmluZSA9IGJ1aWxkQmF0Y2hDb252ZXJ0KHRtLCBwcmVmaXggKyBcIl9iYXRjaFRvQWZmaW5lXCIsIEYubjgqMywgRi5uOCoyKTtcbiAgICB9XG5cbiAgICBvcDIob3BOYW1lLCBhLCBiKSB7XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBiKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMiwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMuRi5uOCozKTtcbiAgICB9XG5cbiAgICBvcDJib29sKG9wTmFtZSwgYSwgYikge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgYik7XG4gICAgICAgIHJldHVybiAhIXRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHRoaXMucE9wMyk7XG4gICAgfVxuXG4gICAgb3AxKG9wTmFtZSwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLkYubjgqMyk7XG4gICAgfVxuXG4gICAgb3AxQWZmaW5lKG9wTmFtZSwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgb3BOYW1lXSh0aGlzLnBPcDEsIHRoaXMucE9wMyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AzLCB0aGlzLkYubjgqMik7XG4gICAgfVxuXG4gICAgb3AxQm9vbChvcE5hbWUsIGEpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIHJldHVybiAhIXRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIG9wTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDMpO1xuICAgIH1cblxuICAgIGFkZChhLGIpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRcIiwgYSwgYik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRNaXhlZFwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgaWYgKGIuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMihcIl9hZGRNaXhlZFwiLCBiLCBhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX2FkZEFmZmluZVwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3ViKGEsYikge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1YlwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1Yk1peGVkXCIsIGEsIGIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyKFwiX3N1Yk1peGVkXCIsIGIsIGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDIoXCJfc3ViQWZmaW5lXCIsIGEsIGIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZWcoYSkge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfbmVnXCIsIGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxQWZmaW5lKFwiX25lZ0FmZmluZVwiLCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRvdWJsZShhKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMShcIl9kb3VibGVcIiwgYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDEoXCJfZG91YmxlQWZmaW5lXCIsIGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNaZXJvKGEpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxQm9vbChcIl9pc1plcm9cIiwgYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcDFCb29sKFwiX2lzWmVyb0FmZmluZVwiLCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVzU2NhbGFyKGEsIHMpIHtcbiAgICAgICAgaWYgKCEocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBzID0gdG9MRUJ1ZmYoZShzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZuTmFtZTtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgZm5OYW1lID0gdGhpcy5wcmVmaXggKyBcIl90aW1lc1NjYWxhclwiO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgZm5OYW1lID0gdGhpcy5wcmVmaXggKyBcIl90aW1lc1NjYWxhckFmZmluZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG0uc2V0QnVmZih0aGlzLnBPcDEsIGEpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AyLCBzKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW2ZuTmFtZV0odGhpcy5wT3AxLCB0aGlzLnBPcDIsIHMuYnl0ZUxlbmd0aCwgdGhpcy5wT3AzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDMsIHRoaXMuRi5uOCozKTtcbiAgICB9XG5cbiAgICB0aW1lc0ZyKGEsIHMpIHtcbiAgICAgICAgbGV0IGZuTmFtZTtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgZm5OYW1lID0gdGhpcy5wcmVmaXggKyBcIl90aW1lc0ZyXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSB0aGlzLnByZWZpeCArIFwiX3RpbWVzRnJBZmZpbmVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMiwgcyk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1tmbk5hbWVdKHRoaXMucE9wMSwgdGhpcy5wT3AyLCB0aGlzLnBPcDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50bS5nZXRCdWZmKHRoaXMucE9wMywgdGhpcy5GLm44KjMpO1xuICAgIH1cblxuICAgIGVxKGEsYikge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyYm9vbChcIl9lcVwiLCBhLCBiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyYm9vbChcIl9lcU1peGVkXCIsIGEsIGIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICBpZiAoYi5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AyYm9vbChcIl9lcU1peGVkXCIsIGIsIGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcDJib29sKFwiX2VxQWZmaW5lXCIsIGEsIGIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b0FmZmluZShhKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wMUFmZmluZShcIl90b0FmZmluZVwiLCBhKTtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9KYWNvYmlhbihhKSB7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AxKFwiX3RvSmFjb2JpYW5cIiwgYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50IHNpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1JwclVuY29tcHJlc3NlZChhcnIsIG9mZnNldCwgYSkge1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfdG9BZmZpbmVcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGEuYnl0ZUxlbmd0aCAhPSB0aGlzLkYubjgqMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX0xFTXRvVVwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgYXJyLnNldChyZXMsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgZnJvbVJwclVuY29tcHJlc3NlZChhcnIsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBidWZmID0gYXJyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5GLm44KjIpO1xuICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBidWZmKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMucHJlZml4ICsgXCJfVXRvTEVNXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMuRi5uOCoyKTtcbiAgICB9XG5cbiAgICB0b1JwckNvbXByZXNzZWQoYXJyLCBvZmZzZXQsIGEpIHtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYSk7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX3RvQWZmaW5lXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AxKTtcbiAgICAgICAgfSBlbHNlIGlmIChhLmJ5dGVMZW5ndGggIT0gdGhpcy5GLm44KjIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRtLmluc3RhbmNlLmV4cG9ydHNbdGhpcy5wcmVmaXggKyBcIl9MRU10b0NcIl0odGhpcy5wT3AxLCB0aGlzLnBPcDEpO1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AxLCB0aGlzLkYubjgpO1xuICAgICAgICBhcnIuc2V0KHJlcywgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICBmcm9tUnByQ29tcHJlc3NlZChhcnIsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBidWZmID0gYXJyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5GLm44KTtcbiAgICAgICAgdGhpcy50bS5zZXRCdWZmKHRoaXMucE9wMSwgYnVmZik7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX0N0b0xFTVwiXSh0aGlzLnBPcDEsIHRoaXMucE9wMik7XG4gICAgICAgIHJldHVybiB0aGlzLnRtLmdldEJ1ZmYodGhpcy5wT3AyLCB0aGlzLkYubjgqMik7XG4gICAgfVxuXG4gICAgdG9VbmNvbXByZXNzZWQoYSkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5GLm44KjIpO1xuICAgICAgICB0aGlzLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDAsIGEpO1xuICAgICAgICByZXR1cm4gYnVmZjtcbiAgICB9XG5cbiAgICB0b1JwckxFTShhcnIsIG9mZnNldCwgYSkge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICBhcnIuc2V0KGEsIG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCozKSB7XG4gICAgICAgICAgICB0aGlzLnRtLnNldEJ1ZmYodGhpcy5wT3AxLCBhKTtcbiAgICAgICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLnByZWZpeCArIFwiX3RvQWZmaW5lXCJdKHRoaXMucE9wMSwgdGhpcy5wT3AxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudG0uZ2V0QnVmZih0aGlzLnBPcDEsIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIGFyci5zZXQocmVzLCBvZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnJvbVJwckxFTShhcnIsIG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgcmV0dXJuIGFyci5zbGljZShvZmZzZXQsIG9mZnNldCt0aGlzLkYubjgqMik7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoYSwgcmFkaXgpIHtcbiAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCA9PSB0aGlzLkYubjgqMykge1xuICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKDAsIHRoaXMuRi5uOCksIHJhZGl4KTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLkYudG9TdHJpbmcoYS5zbGljZSh0aGlzLkYubjgsIHRoaXMuRi5uOCoyKSwgcmFkaXgpO1xuICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKHRoaXMuRi5uOCoyKSwgcmFkaXgpO1xuICAgICAgICAgICAgcmV0dXJuIGBbICR7eH0sICR7eX0sICR7en0gXWA7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5ieXRlTGVuZ3RoID09IHRoaXMuRi5uOCoyKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5GLnRvU3RyaW5nKGEuc2xpY2UoMCwgdGhpcy5GLm44KSwgcmFkaXgpO1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuRi50b1N0cmluZyhhLnNsaWNlKHRoaXMuRi5uOCksIHJhZGl4KTtcbiAgICAgICAgICAgIHJldHVybiBgWyAke3h9LCAke3l9IF1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNWYWxpZChhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybyhhKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG4gICAgICAgIGNvbnN0IGFhID0gdGhpcy50b0FmZmluZShhKTtcbiAgICAgICAgY29uc3QgeCA9IGFhLnNsaWNlKDAsIHRoaXMuRi5uOCk7XG4gICAgICAgIGNvbnN0IHkgPSBhYS5zbGljZSh0aGlzLkYubjgsIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgY29uc3QgeDNiID0gRi5hZGQoRi5tdWwoRi5zcXVhcmUoeCkseCksIHRoaXMuYik7XG4gICAgICAgIGNvbnN0IHkyID0gRi5zcXVhcmUoeSk7XG4gICAgICAgIHJldHVybiBGLmVxKHgzYiwgeTIpO1xuICAgIH1cblxuICAgIGZyb21Sbmcocm5nKSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLkY7XG4gICAgICAgIGxldCBQID0gW107XG4gICAgICAgIGxldCBncmVhdGVzdDtcbiAgICAgICAgbGV0IHgzYjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgUFswXSA9IEYuZnJvbVJuZyhybmcpO1xuICAgICAgICAgICAgZ3JlYXRlc3QgPSBybmcubmV4dEJvb2woKTtcbiAgICAgICAgICAgIHgzYiA9IEYuYWRkKEYubXVsKEYuc3F1YXJlKFBbMF0pLCBQWzBdKSwgdGhpcy5iKTtcbiAgICAgICAgfSB3aGlsZSAoIUYuaXNTcXVhcmUoeDNiKSk7XG5cbiAgICAgICAgUFsxXSA9IEYuc3FydCh4M2IpO1xuXG4gICAgICAgIGNvbnN0IHMgPSBGLmlzTmVnYXRpdmUoUFsxXSk7XG4gICAgICAgIGlmIChncmVhdGVzdCBeIHMpIFBbMV0gPSBGLm5lZyhQWzFdKTtcblxuICAgICAgICBsZXQgUGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLkYubjgqMik7XG4gICAgICAgIFBidWZmLnNldChQWzBdKTtcbiAgICAgICAgUGJ1ZmYuc2V0KFBbMV0sIHRoaXMuRi5uOCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29mYWN0b3IpIHtcbiAgICAgICAgICAgIFBidWZmID0gdGhpcy50aW1lc1NjYWxhcihQYnVmZiwgdGhpcy5jb2ZhY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUGJ1ZmY7XG4gICAgfVxuXG5cblxuICAgIHRvT2JqZWN0KGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXMuRi50b09iamVjdCh0aGlzLkYuemVybyksXG4gICAgICAgICAgICAgICAgdGhpcy5GLnRvT2JqZWN0KHRoaXMuRi5vbmUpLFxuICAgICAgICAgICAgICAgIHRoaXMuRi50b09iamVjdCh0aGlzLkYuemVybyksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLkYudG9PYmplY3QoYS5zbGljZSgwLCB0aGlzLkYubjgpKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuRi50b09iamVjdChhLnNsaWNlKHRoaXMuRi5uOCwgdGhpcy5GLm44KjIpKTtcbiAgICAgICAgbGV0IHo7XG4gICAgICAgIGlmIChhLmJ5dGVMZW5ndGggPT0gdGhpcy5GLm44KjMpIHtcbiAgICAgICAgICAgIHogPSB0aGlzLkYudG9PYmplY3QoYS5zbGljZSh0aGlzLkYubjgqMiwgdGhpcy5GLm44KjMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHogPSB0aGlzLkYudG9PYmplY3QodGhpcy5GLm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICB9XG5cbiAgICBmcm9tT2JqZWN0KGEpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuRi5mcm9tT2JqZWN0KGFbMF0pO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5GLmZyb21PYmplY3QoYVsxXSk7XG4gICAgICAgIGxldCB6O1xuICAgICAgICBpZiAoYS5sZW5ndGg9PTMpIHtcbiAgICAgICAgICAgIHogPSB0aGlzLkYuZnJvbU9iamVjdChhWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHogPSB0aGlzLkYub25lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLkYuaXNaZXJvKHosIHRoaXMuRi5vbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvQWZmaW5lO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuRi5lcSh6LCB0aGlzLkYub25lKSkge1xuICAgICAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KHgpO1xuICAgICAgICAgICAgYnVmZi5zZXQoeSwgdGhpcy5GLm44KTtcbiAgICAgICAgICAgIHJldHVybiBidWZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHRoaXMuRi5uOCozKTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KHgpO1xuICAgICAgICAgICAgYnVmZi5zZXQoeSwgdGhpcy5GLm44KTtcbiAgICAgICAgICAgIGJ1ZmYuc2V0KHosIHRoaXMuRi5uOCoyKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZShhKSB7XG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkgcmV0dXJuIGE7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21PYmplY3QoYSk7XG4gICAgfVxuXG4gICAgeChhKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IHRoaXMudG9BZmZpbmUoYSk7XG4gICAgICAgIHJldHVybiB0bXAuc2xpY2UoMCwgdGhpcy5GLm44KTtcbiAgICB9XG5cbiAgICB5KGEpIHtcbiAgICAgICAgY29uc3QgdG1wID0gdGhpcy50b0FmZmluZShhKTtcbiAgICAgICAgcmV0dXJuIHRtcC5zbGljZSh0aGlzLkYubjgpO1xuICAgIH1cblxufVxuXG4vKiBnbG9iYWwgV2ViQXNzZW1ibHkgKi9cblxuZnVuY3Rpb24gdGhyZWFkKHNlbGYpIHtcbiAgICBjb25zdCBNQVhNRU0gPSAzMjc2NztcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgbGV0IG1lbW9yeTtcblxuICAgIGlmIChzZWxmKSB7XG4gICAgICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBpZiAoZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhWzBdLmNtZCA9PSBcIklOSVRcIikge1xuICAgICAgICAgICAgICAgIGluaXQoZGF0YVswXSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShkYXRhLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFbMF0uY21kID09IFwiVEVSTUlOQVRFXCIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHJ1blRhc2soZGF0YSk7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGluaXQoZGF0YSkge1xuICAgICAgICBjb25zdCBjb2RlID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5jb2RlKTtcbiAgICAgICAgY29uc3Qgd2FzbU1vZHVsZSA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUoY29kZSk7XG4gICAgICAgIG1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6ZGF0YS5pbml0LCBtYXhpbXVtOiBNQVhNRU19KTtcblxuICAgICAgICBpbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21Nb2R1bGUsIHtcbiAgICAgICAgICAgIGVudjoge1xuICAgICAgICAgICAgICAgIFwibWVtb3J5XCI6IG1lbW9yeVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuXG4gICAgZnVuY3Rpb24gYWxsb2MobGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyLCAwLCAxKTtcbiAgICAgICAgd2hpbGUgKHUzMlswXSAmIDMpIHUzMlswXSsrOyAgLy8gUmV0dXJuIGFsd2F5cyBhbGlnbmVkIHBvaW50ZXJzXG4gICAgICAgIGNvbnN0IHJlcyA9IHUzMlswXTtcbiAgICAgICAgdTMyWzBdICs9IGxlbmd0aDtcbiAgICAgICAgaWYgKHUzMlswXSArIGxlbmd0aCA+IG1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFBhZ2VzID0gbWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoIC8gMHgxMDAwMDtcbiAgICAgICAgICAgIGxldCByZXF1aXJlZFBhZ2VzID0gTWF0aC5mbG9vcigodTMyWzBdICsgbGVuZ3RoKSAvIDB4MTAwMDApKzE7XG4gICAgICAgICAgICBpZiAocmVxdWlyZWRQYWdlcz5NQVhNRU0pIHJlcXVpcmVkUGFnZXM9TUFYTUVNO1xuICAgICAgICAgICAgbWVtb3J5Lmdyb3cocmVxdWlyZWRQYWdlcy1jdXJyZW50UGFnZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsb2NCdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHAgPSBhbGxvYyhidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHNldEJ1ZmZlcihwLCBidWZmZXIpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCdWZmZXIocG9pbnRlciwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHU4ID0gbmV3IFVpbnQ4QXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh1OC5idWZmZXIsIHU4LmJ5dGVPZmZzZXQgKyBwb2ludGVyLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEJ1ZmZlcihwb2ludGVyLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgdTggPSBuZXcgVWludDhBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICAgICAgdTguc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIHBvaW50ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1blRhc2sodGFzaykge1xuICAgICAgICBpZiAodGFza1swXS5jbWQgPT0gXCJJTklUXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0KHRhc2tbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIHZhcnM6IFtdLFxuICAgICAgICAgICAgb3V0OiBbXVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1MzJhID0gbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIsIDAsIDEpO1xuICAgICAgICBjb25zdCBvbGRBbGxvYyA9IHUzMmFbMF07XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0YXNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhc2tbaV0uY21kKSB7XG4gICAgICAgICAgICBjYXNlIFwiQUxMT0NTRVRcIjpcbiAgICAgICAgICAgICAgICBjdHgudmFyc1t0YXNrW2ldLnZhcl0gPSBhbGxvY0J1ZmZlcih0YXNrW2ldLmJ1ZmYpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFMTE9DXCI6XG4gICAgICAgICAgICAgICAgY3R4LnZhcnNbdGFza1tpXS52YXJdID0gYWxsb2ModGFza1tpXS5sZW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNFVFwiOlxuICAgICAgICAgICAgICAgIHNldEJ1ZmZlcihjdHgudmFyc1t0YXNrW2ldLnZhcl0sIHRhc2tbaV0uYnVmZik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQ0FMTFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHRhc2tbaV0ucGFyYW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0YXNrW2ldLnBhcmFtc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwLnZhciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goY3R4LnZhcnNbcC52YXJdICsgKHAub2Zmc2V0IHx8IDApKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcC52YWwgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gocC52YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmV4cG9ydHNbdGFza1tpXS5mbk5hbWVdKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiR0VUXCI6XG4gICAgICAgICAgICAgICAgY3R4Lm91dFt0YXNrW2ldLm91dF0gPSBnZXRCdWZmZXIoY3R4LnZhcnNbdGFza1tpXS52YXJdLCB0YXNrW2ldLmxlbikuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjbWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdTMyYiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyLCAwLCAxKTtcbiAgICAgICAgdTMyYlswXSA9IG9sZEFsbG9jO1xuICAgICAgICByZXR1cm4gY3R4Lm91dDtcbiAgICB9XG5cblxuICAgIHJldHVybiBydW5UYXNrO1xufVxuXG4vKlxuICAgIENvcHlyaWdodCAyMDE5IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2FzbXNuYXJrIChXZWIgQXNzZW1ibHkgemtTbmFyayBQcm92ZXIpLlxuXG4gICAgd2FzbXNuYXJrIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2FzbXNuYXJrIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdhc21zbmFyay4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIGNvbnN0IE1FTV9TSVpFID0gMTAwMDsgIC8vIE1lbW9yeSBzaXplIGluIDY0SyBQYWtlcyAoNTEyTWIpXG5jb25zdCBNRU1fU0laRSA9IDI1OyAgLy8gTWVtb3J5IHNpemUgaW4gNjRLIFBha2VzICgxNjAwS2IpXG5cbmNsYXNzIERlZmVycmVkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PiB7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5cbmxldCB3b3JrZXJTb3VyY2U7XG5cbmNvbnN0IHRocmVhZFN0ciA9IGAoJHtcImZ1bmN0aW9uIHRocmVhZChzZWxmKSB7XFxuICAgIGNvbnN0IE1BWE1FTSA9IDMyNzY3O1xcbiAgICBsZXQgaW5zdGFuY2U7XFxuICAgIGxldCBtZW1vcnk7XFxuXFxuICAgIGlmIChzZWxmKSB7XFxuICAgICAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcXG4gICAgICAgICAgICBsZXQgZGF0YTtcXG4gICAgICAgICAgICBpZiAoZS5kYXRhKSB7XFxuICAgICAgICAgICAgICAgIGRhdGEgPSBlLmRhdGE7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZGF0YSA9IGU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChkYXRhWzBdLmNtZCA9PSBcXFwiSU5JVFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgaW5pdChkYXRhWzBdKS50aGVuKGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShkYXRhLnJlc3VsdCk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVswXS5jbWQgPT0gXFxcIlRFUk1JTkFURVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHJ1blRhc2soZGF0YSk7XFxuICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICB9XFxuXFxuICAgIGFzeW5jIGZ1bmN0aW9uIGluaXQoZGF0YSkge1xcbiAgICAgICAgY29uc3QgY29kZSA9IG5ldyBVaW50OEFycmF5KGRhdGEuY29kZSk7XFxuICAgICAgICBjb25zdCB3YXNtTW9kdWxlID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShjb2RlKTtcXG4gICAgICAgIG1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6ZGF0YS5pbml0LCBtYXhpbXVtOiBNQVhNRU19KTtcXG5cXG4gICAgICAgIGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUod2FzbU1vZHVsZSwge1xcbiAgICAgICAgICAgIGVudjoge1xcbiAgICAgICAgICAgICAgICBcXFwibWVtb3J5XFxcIjogbWVtb3J5XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG5cXG5cXG4gICAgZnVuY3Rpb24gYWxsb2MobGVuZ3RoKSB7XFxuICAgICAgICBjb25zdCB1MzIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlciwgMCwgMSk7XFxuICAgICAgICB3aGlsZSAodTMyWzBdICYgMykgdTMyWzBdKys7ICAvLyBSZXR1cm4gYWx3YXlzIGFsaWduZWQgcG9pbnRlcnNcXG4gICAgICAgIGNvbnN0IHJlcyA9IHUzMlswXTtcXG4gICAgICAgIHUzMlswXSArPSBsZW5ndGg7XFxuICAgICAgICBpZiAodTMyWzBdICsgbGVuZ3RoID4gbWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XFxuICAgICAgICAgICAgY29uc3QgY3VycmVudFBhZ2VzID0gbWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoIC8gMHgxMDAwMDtcXG4gICAgICAgICAgICBsZXQgcmVxdWlyZWRQYWdlcyA9IE1hdGguZmxvb3IoKHUzMlswXSArIGxlbmd0aCkgLyAweDEwMDAwKSsxO1xcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZFBhZ2VzPk1BWE1FTSkgcmVxdWlyZWRQYWdlcz1NQVhNRU07XFxuICAgICAgICAgICAgbWVtb3J5Lmdyb3cocmVxdWlyZWRQYWdlcy1jdXJyZW50UGFnZXMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlcztcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBhbGxvY0J1ZmZlcihidWZmZXIpIHtcXG4gICAgICAgIGNvbnN0IHAgPSBhbGxvYyhidWZmZXIuYnl0ZUxlbmd0aCk7XFxuICAgICAgICBzZXRCdWZmZXIocCwgYnVmZmVyKTtcXG4gICAgICAgIHJldHVybiBwO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGdldEJ1ZmZlcihwb2ludGVyLCBsZW5ndGgpIHtcXG4gICAgICAgIGNvbnN0IHU4ID0gbmV3IFVpbnQ4QXJyYXkobWVtb3J5LmJ1ZmZlcik7XFxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodTguYnVmZmVyLCB1OC5ieXRlT2Zmc2V0ICsgcG9pbnRlciwgbGVuZ3RoKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzZXRCdWZmZXIocG9pbnRlciwgYnVmZmVyKSB7XFxuICAgICAgICBjb25zdCB1OCA9IG5ldyBVaW50OEFycmF5KG1lbW9yeS5idWZmZXIpO1xcbiAgICAgICAgdTguc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIHBvaW50ZXIpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHJ1blRhc2sodGFzaykge1xcbiAgICAgICAgaWYgKHRhc2tbMF0uY21kID09IFxcXCJJTklUXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybiBpbml0KHRhc2tbMF0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3QgY3R4ID0ge1xcbiAgICAgICAgICAgIHZhcnM6IFtdLFxcbiAgICAgICAgICAgIG91dDogW11cXG4gICAgICAgIH07XFxuICAgICAgICBjb25zdCB1MzJhID0gbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIsIDAsIDEpO1xcbiAgICAgICAgY29uc3Qgb2xkQWxsb2MgPSB1MzJhWzBdO1xcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRhc2subGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKHRhc2tbaV0uY21kKSB7XFxuICAgICAgICAgICAgY2FzZSBcXFwiQUxMT0NTRVRcXFwiOlxcbiAgICAgICAgICAgICAgICBjdHgudmFyc1t0YXNrW2ldLnZhcl0gPSBhbGxvY0J1ZmZlcih0YXNrW2ldLmJ1ZmYpO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBjYXNlIFxcXCJBTExPQ1xcXCI6XFxuICAgICAgICAgICAgICAgIGN0eC52YXJzW3Rhc2tbaV0udmFyXSA9IGFsbG9jKHRhc2tbaV0ubGVuKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgY2FzZSBcXFwiU0VUXFxcIjpcXG4gICAgICAgICAgICAgICAgc2V0QnVmZmVyKGN0eC52YXJzW3Rhc2tbaV0udmFyXSwgdGFza1tpXS5idWZmKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgY2FzZSBcXFwiQ0FMTFxcXCI6IHtcXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW107XFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajx0YXNrW2ldLnBhcmFtcy5sZW5ndGg7IGorKykge1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHRhc2tbaV0ucGFyYW1zW2pdO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwLnZhciAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChjdHgudmFyc1twLnZhcl0gKyAocC5vZmZzZXQgfHwgMCkpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcC52YWwgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwLnZhbCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3J0c1t0YXNrW2ldLmZuTmFtZV0oLi4ucGFyYW1zKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNhc2UgXFxcIkdFVFxcXCI6XFxuICAgICAgICAgICAgICAgIGN0eC5vdXRbdGFza1tpXS5vdXRdID0gZ2V0QnVmZmVyKGN0eC52YXJzW3Rhc2tbaV0udmFyXSwgdGFza1tpXS5sZW4pLnNsaWNlKCk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiSW52YWxpZCBjbWRcXFwiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCB1MzJiID0gbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIsIDAsIDEpO1xcbiAgICAgICAgdTMyYlswXSA9IG9sZEFsbG9jO1xcbiAgICAgICAgcmV0dXJuIGN0eC5vdXQ7XFxuICAgIH1cXG5cXG5cXG4gICAgcmV0dXJuIHJ1blRhc2s7XFxufVwifSkoc2VsZilgO1xue1xuICAgIGlmKGdsb2JhbFRoaXM/LkJsb2IpIHtcbiAgICAgICAgY29uc3QgdGhyZWFkQnl0ZXM9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0aHJlYWRTdHIpO1xuICAgICAgICBjb25zdCB3b3JrZXJCbG9iID0gbmV3IEJsb2IoW3RocmVhZEJ5dGVzXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiB9KSA7XG4gICAgICAgIHdvcmtlclNvdXJjZSA9IFVSTC5jcmVhdGVPYmplY3RVUkwod29ya2VyQmxvYik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd29ya2VyU291cmNlID0gXCJkYXRhOmFwcGxpY2F0aW9uL2phdmFzY3JpcHQ7YmFzZTY0LFwiICsgZ2xvYmFsVGhpcy5idG9hKHRocmVhZFN0cik7XG4gICAgfVxufVxuXG5cblxuYXN5bmMgZnVuY3Rpb24gYnVpbGRUaHJlYWRNYW5hZ2VyKHdhc20sIHNpbmdsZVRocmVhZCkge1xuICAgIGNvbnN0IHRtID0gbmV3IFRocmVhZE1hbmFnZXIoKTtcblxuICAgIHRtLm1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6TUVNX1NJWkV9KTtcbiAgICB0bS51OCA9IG5ldyBVaW50OEFycmF5KHRtLm1lbW9yeS5idWZmZXIpO1xuICAgIHRtLnUzMiA9IG5ldyBVaW50MzJBcnJheSh0bS5tZW1vcnkuYnVmZmVyKTtcblxuICAgIGNvbnN0IHdhc21Nb2R1bGUgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKHdhc20uY29kZSk7XG5cbiAgICB0bS5pbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21Nb2R1bGUsIHtcbiAgICAgICAgZW52OiB7XG4gICAgICAgICAgICBcIm1lbW9yeVwiOiB0bS5tZW1vcnlcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmKCFnbG9iYWxUaGlzPy5Xb3JrZXIpIHtcbiAgICAgICAgc2luZ2xlVGhyZWFkID0gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgdG0uc2luZ2xlVGhyZWFkID0gc2luZ2xlVGhyZWFkO1xuICAgIHRtLmluaXRhbFBGcmVlID0gdG0udTMyWzBdOyAgIC8vIFNhdmUgdGhlIFBvaW50ZXIgdG8gZnJlZSBzcGFjZS5cbiAgICB0bS5wcSA9IHdhc20ucHE7XG4gICAgdG0ucHIgPSB3YXNtLnByO1xuICAgIHRtLnBHMWdlbiA9IHdhc20ucEcxZ2VuO1xuICAgIHRtLnBHMXplcm8gPSB3YXNtLnBHMXplcm87XG4gICAgdG0ucEcyZ2VuID0gd2FzbS5wRzJnZW47XG4gICAgdG0ucEcyemVybyA9IHdhc20ucEcyemVybztcbiAgICB0bS5wT25lVCA9IHdhc20ucE9uZVQ7XG5cbiAgICAvLyAgICB0bS5wVG1wMCA9IHRtLmFsbG9jKGN1cnZlLkcyLkYubjgqMyk7XG4gICAgLy8gICAgdG0ucFRtcDEgPSB0bS5hbGxvYyhjdXJ2ZS5HMi5GLm44KjMpO1xuXG4gICAgaWYgKHNpbmdsZVRocmVhZCkge1xuICAgICAgICB0bS5jb2RlID0gd2FzbS5jb2RlO1xuICAgICAgICB0bS50YXNrTWFuYWdlciA9IHRocmVhZCgpO1xuICAgICAgICBhd2FpdCB0bS50YXNrTWFuYWdlcihbe1xuICAgICAgICAgICAgY21kOiBcIklOSVRcIixcbiAgICAgICAgICAgIGluaXQ6IE1FTV9TSVpFLFxuICAgICAgICAgICAgY29kZTogdG0uY29kZS5zbGljZSgpXG4gICAgICAgIH1dKTtcbiAgICAgICAgdG0uY29uY3VycmVuY3kgID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0bS53b3JrZXJzID0gW107XG4gICAgICAgIHRtLnBlbmRpbmdEZWZlcnJlZHMgPSBbXTtcbiAgICAgICAgdG0ud29ya2luZyA9IFtdO1xuXG4gICAgICAgIGxldCBjb25jdXJyZW5jeSA9IDI7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcIm9iamVjdFwiICYmIG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgY29uY3VycmVuY3kgPSBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGNvbmN1cnJlbmN5ID09IDApe1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGltaXQgdG8gNjQgdGhyZWFkcyBmb3IgbWVtb3J5IHJlYXNvbnMuXG4gICAgICAgIGlmIChjb25jdXJyZW5jeT42NCkgY29uY3VycmVuY3k9NjQ7XG4gICAgICAgIHRtLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3k7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuXG4gICAgICAgICAgICB0bS53b3JrZXJzW2ldID0gbmV3IFdvcmtlcih3b3JrZXJTb3VyY2UpO1xuXG4gICAgICAgICAgICB0bS53b3JrZXJzW2ldLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGdldE9uTXNnKGkpKTtcblxuICAgICAgICAgICAgdG0ud29ya2luZ1tpXT1mYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGluaXRQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dG0ud29ya2Vycy5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb3B5Q29kZSA9IHdhc20uY29kZS5zbGljZSgpO1xuICAgICAgICAgICAgaW5pdFByb21pc2VzLnB1c2godG0ucG9zdEFjdGlvbihpLCBbe1xuICAgICAgICAgICAgICAgIGNtZDogXCJJTklUXCIsXG4gICAgICAgICAgICAgICAgaW5pdDogTUVNX1NJWkUsXG4gICAgICAgICAgICAgICAgY29kZTogY29weUNvZGVcbiAgICAgICAgICAgIH1dLCBbY29weUNvZGUuYnVmZmVyXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5pdFByb21pc2VzKTtcblxuICAgIH1cbiAgICByZXR1cm4gdG07XG5cbiAgICBmdW5jdGlvbiBnZXRPbk1zZyhpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgIGlmICgoZSkmJihlLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRtLndvcmtpbmdbaV09ZmFsc2U7XG4gICAgICAgICAgICB0bS5wZW5kaW5nRGVmZXJyZWRzW2ldLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB0bS5wcm9jZXNzV29ya3MoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbn1cblxuY2xhc3MgVGhyZWFkTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5vbGRQRnJlZSA9IDA7XG4gICAgfVxuXG4gICAgc3RhcnRTeW5jT3AoKSB7XG4gICAgICAgIGlmICh0aGlzLm9sZFBGcmVlICE9IDApIHRocm93IG5ldyBFcnJvcihcIlN5bmMgb3BlcmF0aW9uIGluIHByb2dyZXNzXCIpO1xuICAgICAgICB0aGlzLm9sZFBGcmVlID0gdGhpcy51MzJbMF07XG4gICAgfVxuXG4gICAgZW5kU3luY09wKCkge1xuICAgICAgICBpZiAodGhpcy5vbGRQRnJlZSA9PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzeW5jIG9wZXJhdGlvbiBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgdGhpcy51MzJbMF0gPSB0aGlzLm9sZFBGcmVlO1xuICAgICAgICB0aGlzLm9sZFBGcmVlID0gMDtcbiAgICB9XG5cbiAgICBwb3N0QWN0aW9uKHdvcmtlcklkLCBlLCB0cmFuc2ZlcnMsIF9kZWZlcnJlZCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nW3dvcmtlcklkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zdGluZyBhIGpvYiB0IGEgd29ya2luZyB3b3JrZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53b3JraW5nW3dvcmtlcklkXSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5wZW5kaW5nRGVmZXJyZWRzW3dvcmtlcklkXSA9IF9kZWZlcnJlZCA/IF9kZWZlcnJlZCA6IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLndvcmtlcnNbd29ya2VySWRdLnBvc3RNZXNzYWdlKGUsIHRyYW5zZmVycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0RlZmVycmVkc1t3b3JrZXJJZF0ucHJvbWlzZTtcbiAgICB9XG5cbiAgICBwcm9jZXNzV29ya3MoKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgKGk8dGhpcy53b3JrZXJzLmxlbmd0aCkmJih0aGlzLmFjdGlvblF1ZXVlLmxlbmd0aCA+IDApOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndvcmtpbmdbaV0gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JrID0gdGhpcy5hY3Rpb25RdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zdEFjdGlvbihpLCB3b3JrLmRhdGEsIHdvcmsudHJhbnNmZXJzLCB3b3JrLmRlZmVycmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXVlQWN0aW9uKGFjdGlvbkRhdGEsIHRyYW5zZmVycykge1xuICAgICAgICBjb25zdCBkID0gbmV3IERlZmVycmVkKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2luZ2xlVGhyZWFkKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLnRhc2tNYW5hZ2VyKGFjdGlvbkRhdGEpO1xuICAgICAgICAgICAgZC5yZXNvbHZlKHJlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIGRhdGE6IGFjdGlvbkRhdGEsXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJzOiB0cmFuc2ZlcnMsXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQ6IGRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzV29ya3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZC5wcm9taXNlO1xuICAgIH1cblxuICAgIHJlc2V0TWVtb3J5KCkge1xuICAgICAgICB0aGlzLnUzMlswXSA9IHRoaXMuaW5pdGFsUEZyZWU7XG4gICAgfVxuXG4gICAgYWxsb2NCdWZmKGJ1ZmYpIHtcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IHRoaXMuYWxsb2MoYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zZXRCdWZmKHBvaW50ZXIsIGJ1ZmYpO1xuICAgICAgICByZXR1cm4gcG9pbnRlcjtcbiAgICB9XG5cbiAgICBnZXRCdWZmKHBvaW50ZXIsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy51OC5zbGljZShwb2ludGVyLCBwb2ludGVyKyBsZW5ndGgpO1xuICAgIH1cblxuICAgIHNldEJ1ZmYocG9pbnRlciwgYnVmZmVyKSB7XG4gICAgICAgIHRoaXMudTguc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIHBvaW50ZXIpO1xuICAgIH1cblxuICAgIGFsbG9jKGxlbmd0aCkge1xuICAgICAgICB3aGlsZSAodGhpcy51MzJbMF0gJiAzKSB0aGlzLnUzMlswXSsrOyAgLy8gUmV0dXJuIGFsd2F5cyBhbGlnbmVkIHBvaW50ZXJzXG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudTMyWzBdO1xuICAgICAgICB0aGlzLnUzMlswXSArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgYXN5bmMgdGVybWluYXRlKCkge1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy53b3JrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtlcnNbaV0ucG9zdE1lc3NhZ2UoW3tjbWQ6IFwiVEVSTUlOQVRFXCJ9XSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgc2xlZXAoMjAwKTtcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gYnVpbGRCYXRjaEFwcGx5S2V5KGN1cnZlLCBncm91cE5hbWUpIHtcbiAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHRtID0gY3VydmUudG07XG5cbiAgICBjdXJ2ZVtncm91cE5hbWVdLmJhdGNoQXBwbHlLZXkgPSBhc3luYyBmdW5jdGlvbihidWZmLCBmaXJzdCwgaW5jLCBpblR5cGUsIG91dFR5cGUpIHtcbiAgICAgICAgaW5UeXBlID0gaW5UeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIG91dFR5cGUgPSBvdXRUeXBlIHx8IFwiYWZmaW5lXCI7XG4gICAgICAgIGxldCBmbk5hbWUsIGZuQWZmaW5lO1xuICAgICAgICBsZXQgc0dpbiwgc0dtaWQsIHNHb3V0O1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImphY29iaWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzR2luID0gRy5GLm44KjM7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMW1fYmF0Y2hBcHBseUtleVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzR2luID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMW1fYmF0Y2hBcHBseUtleU1peGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzR21pZCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgaWYgKG91dFR5cGUgPT0gXCJqYWNvYmlhblwiKSB7XG4gICAgICAgICAgICAgICAgc0dvdXQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm5BZmZpbmUgPSBcImcxbV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICAgICAgc0dvdXQgPSBHLkYubjgqMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiamFjb2JpYW5cIikge1xuICAgICAgICAgICAgICAgIHNHaW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcybV9iYXRjaEFwcGx5S2V5XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNHaW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcybV9iYXRjaEFwcGx5S2V5TWl4ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNHbWlkID0gRy5GLm44KjM7XG4gICAgICAgICAgICBpZiAob3V0VHlwZSA9PSBcImphY29iaWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzR291dCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbkFmZmluZSA9IFwiZzJtX2JhdGNoVG9BZmZpbmVcIjtcbiAgICAgICAgICAgICAgICBzR291dCA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkZyXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZnJtX2JhdGNoQXBwbHlLZXlcIjtcbiAgICAgICAgICAgIHNHaW4gPSBHLm44O1xuICAgICAgICAgICAgc0dtaWQgPSBHLm44O1xuICAgICAgICAgICAgc0dvdXQgPSBHLm44O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cDogXCIgKyBncm91cE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmYuYnl0ZUxlbmd0aCAvIHNHaW4pO1xuICAgICAgICBjb25zdCBwb2ludHNQZXJDaHVuayA9IE1hdGguZmxvb3IoblBvaW50cy90bS5jb25jdXJyZW5jeSk7XG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaW5jID0gRnIuZShpbmMpO1xuICAgICAgICBsZXQgdCA9IEZyLmUoZmlyc3QpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dG0uY29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgdG0uY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBwb2ludHNQZXJDaHVuaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHMgLSBpKnBvaW50c1BlckNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG5cbiAgICAgICAgICAgIHRhc2sucHVzaCh7XG4gICAgICAgICAgICAgICAgY21kOiBcIkFMTE9DU0VUXCIsXG4gICAgICAgICAgICAgICAgdmFyOiAwLFxuICAgICAgICAgICAgICAgIGJ1ZmY6IGJ1ZmYuc2xpY2UoaSpwb2ludHNQZXJDaHVuaypzR2luLCBpKnBvaW50c1BlckNodW5rKnNHaW4gKyBuKnNHaW4pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogdH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAyLCBidWZmOiBpbmN9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMywgbGVuOiBuKk1hdGgubWF4KHNHbWlkLCBzR291dCl9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7XG4gICAgICAgICAgICAgICAgY21kOiBcIkNBTExcIixcbiAgICAgICAgICAgICAgICBmbk5hbWU6IGZuTmFtZSxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6M31cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmbkFmZmluZSkge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogXCJDQUxMXCIsXG4gICAgICAgICAgICAgICAgICAgIGZuTmFtZTogZm5BZmZpbmUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogM30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDMsIGxlbjogbipzR291dH0pO1xuXG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2godG0ucXVldWVBY3Rpb24odGFzaykpO1xuICAgICAgICAgICAgdCA9IEZyLm11bCh0LCBGci5leHAoaW5jLCBuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChvcFByb21pc2VzKTtcblxuICAgICAgICBsZXQgb3V0QnVmZjtcbiAgICAgICAgaWYgKGJ1ZmYgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIG91dEJ1ZmYgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0dvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0QnVmZiA9IG5ldyBVaW50OEFycmF5KG5Qb2ludHMqc0dvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHA9MDtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0QnVmZi5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHAgKz0gcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0QnVmZjtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFBhaXJpbmcoY3VydmUpIHtcbiAgICBjb25zdCB0bSA9IGN1cnZlLnRtO1xuICAgIGN1cnZlLnBhaXJpbmcgPSBmdW5jdGlvbiBwYWlyaW5nKGEsIGIpIHtcblxuICAgICAgICB0bS5zdGFydFN5bmNPcCgpO1xuICAgICAgICBjb25zdCBwQSA9IHRtLmFsbG9jQnVmZihjdXJ2ZS5HMS50b0phY29iaWFuKGEpKTtcbiAgICAgICAgY29uc3QgcEIgPSB0bS5hbGxvY0J1ZmYoY3VydmUuRzIudG9KYWNvYmlhbihiKSk7XG4gICAgICAgIGNvbnN0IHBSZXMgPSB0bS5hbGxvYyhjdXJ2ZS5HdC5uOCk7XG4gICAgICAgIHRtLmluc3RhbmNlLmV4cG9ydHNbY3VydmUubmFtZSArIFwiX3BhaXJpbmdcIl0ocEEsIHBCLCBwUmVzKTtcblxuICAgICAgICBjb25zdCByZXMgPSB0bS5nZXRCdWZmKHBSZXMsIGN1cnZlLkd0Lm44KTtcblxuICAgICAgICB0bS5lbmRTeW5jT3AoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgY3VydmUucGFpcmluZ0VxID0gYXN5bmMgZnVuY3Rpb24gcGFpcmluZ0VxKCkge1xuICAgICAgICBsZXQgIGJ1ZmZDdDtcbiAgICAgICAgbGV0IG5FcXM7XG4gICAgICAgIGlmICgoYXJndW1lbnRzLmxlbmd0aCAlIDIpID09IDEpIHtcbiAgICAgICAgICAgIGJ1ZmZDdCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdO1xuICAgICAgICAgICAgbkVxcyA9IChhcmd1bWVudHMubGVuZ3RoIC0xKSAvMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZDdCA9IGN1cnZlLkd0Lm9uZTtcbiAgICAgICAgICAgIG5FcXMgPSBhcmd1bWVudHMubGVuZ3RoIC8yO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkVxczsgaSsrKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcblxuICAgICAgICAgICAgY29uc3QgZzFCdWZmID0gY3VydmUuRzEudG9KYWNvYmlhbihhcmd1bWVudHNbaSoyXSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGcxQnVmZn0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAxLCBsZW46IGN1cnZlLnByZVBTaXplfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGcyQnVmZiA9IGN1cnZlLkcyLnRvSmFjb2JpYW4oYXJndW1lbnRzW2kqMiArMV0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAyLCBidWZmOiBnMkJ1ZmZ9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMywgbGVuOiBjdXJ2ZS5wcmVRU2l6ZX0pO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDQsIGxlbjogY3VydmUuR3Qubjh9KTtcblxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGN1cnZlLm5hbWUgKyBcIl9wcmVwYXJlRzFcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAge3ZhcjogMX1cbiAgICAgICAgICAgIF19KTtcblxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGN1cnZlLm5hbWUgKyBcIl9wcmVwYXJlRzJcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICAgICAge3ZhcjogM31cbiAgICAgICAgICAgIF19KTtcblxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGN1cnZlLm5hbWUgKyBcIl9taWxsZXJMb29wXCIsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDR9XG4gICAgICAgICAgICBdfSk7XG5cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogNCwgbGVuOiBjdXJ2ZS5HdC5uOH0pO1xuXG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgdG0ucXVldWVBY3Rpb24odGFzaylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIHRtLnN0YXJ0U3luY09wKCk7XG4gICAgICAgIGNvbnN0IHBSZXMgPSB0bS5hbGxvYyhjdXJ2ZS5HdC5uOCk7XG4gICAgICAgIHRtLmluc3RhbmNlLmV4cG9ydHMuZnRtX29uZShwUmVzKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwTVIgPSB0bS5hbGxvY0J1ZmYocmVzdWx0W2ldWzBdKTtcbiAgICAgICAgICAgIHRtLmluc3RhbmNlLmV4cG9ydHMuZnRtX211bChwUmVzLCBwTVIsIHBSZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRtLmluc3RhbmNlLmV4cG9ydHNbY3VydmUubmFtZSArIFwiX2ZpbmFsRXhwb25lbnRpYXRpb25cIl0ocFJlcywgcFJlcyk7XG5cbiAgICAgICAgY29uc3QgcEN0ID0gdG0uYWxsb2NCdWZmKGJ1ZmZDdCk7XG5cbiAgICAgICAgY29uc3QgciA9ICEhdG0uaW5zdGFuY2UuZXhwb3J0cy5mdG1fZXEocFJlcywgcEN0KTtcblxuICAgICAgICB0bS5lbmRTeW5jT3AoKTtcblxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgY3VydmUucHJlcGFyZUcxID0gZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnRtLnN0YXJ0U3luY09wKCk7XG4gICAgICAgIGNvbnN0IHBQID0gdGhpcy50bS5hbGxvY0J1ZmYocCk7XG4gICAgICAgIGNvbnN0IHBQcmVwUCA9IHRoaXMudG0uYWxsb2ModGhpcy5wcmVQU2l6ZSk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLm5hbWUgKyBcIl9wcmVwYXJlRzFcIl0ocFAsIHBQcmVwUCk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudG0uZ2V0QnVmZihwUHJlcFAsIHRoaXMucHJlUFNpemUpO1xuICAgICAgICB0aGlzLnRtLmVuZFN5bmNPcCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICBjdXJ2ZS5wcmVwYXJlRzIgPSBmdW5jdGlvbihxKSB7XG4gICAgICAgIHRoaXMudG0uc3RhcnRTeW5jT3AoKTtcbiAgICAgICAgY29uc3QgcFEgPSB0aGlzLnRtLmFsbG9jQnVmZihxKTtcbiAgICAgICAgY29uc3QgcFByZXBRID0gdGhpcy50bS5hbGxvYyh0aGlzLnByZVFTaXplKTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMubmFtZSArIFwiX3ByZXBhcmVHMlwiXShwUSwgcFByZXBRKTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy50bS5nZXRCdWZmKHBQcmVwUSwgdGhpcy5wcmVRU2l6ZSk7XG4gICAgICAgIHRoaXMudG0uZW5kU3luY09wKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIGN1cnZlLm1pbGxlckxvb3AgPSBmdW5jdGlvbihwcmVQLCBwcmVRKSB7XG4gICAgICAgIHRoaXMudG0uc3RhcnRTeW5jT3AoKTtcbiAgICAgICAgY29uc3QgcFByZVAgPSB0aGlzLnRtLmFsbG9jQnVmZihwcmVQKTtcbiAgICAgICAgY29uc3QgcFByZVEgPSB0aGlzLnRtLmFsbG9jQnVmZihwcmVRKTtcbiAgICAgICAgY29uc3QgcFJlcyA9IHRoaXMudG0uYWxsb2ModGhpcy5HdC5uOCk7XG4gICAgICAgIHRoaXMudG0uaW5zdGFuY2UuZXhwb3J0c1t0aGlzLm5hbWUgKyBcIl9taWxsZXJMb29wXCJdKHBQcmVQLCBwUHJlUSwgcFJlcyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudG0uZ2V0QnVmZihwUmVzLCB0aGlzLkd0Lm44KTtcbiAgICAgICAgdGhpcy50bS5lbmRTeW5jT3AoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgY3VydmUuZmluYWxFeHBvbmVudGlhdGlvbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgdGhpcy50bS5zdGFydFN5bmNPcCgpO1xuICAgICAgICBjb25zdCBwQSA9IHRoaXMudG0uYWxsb2NCdWZmKGEpO1xuICAgICAgICBjb25zdCBwUmVzID0gdGhpcy50bS5hbGxvYyh0aGlzLkd0Lm44KTtcbiAgICAgICAgdGhpcy50bS5pbnN0YW5jZS5leHBvcnRzW3RoaXMubmFtZSArIFwiX2ZpbmFsRXhwb25lbnRpYXRpb25cIl0ocEEsIHBSZXMpO1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLnRtLmdldEJ1ZmYocFJlcywgdGhpcy5HdC5uOCk7XG4gICAgICAgIHRoaXMudG0uZW5kU3luY09wKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxufVxuXG5jb25zdCBwVFNpemVzID0gW1xuICAgIDEgLCAgMSwgIDEsICAxLCAgICAyLCAgMywgIDQsICA1LFxuICAgIDYgLCAgNywgIDcsICA4LCAgICA5LCAxMCwgMTEsIDEyLFxuICAgIDEzLCAxMywgMTQsIDE1LCAgIDE2LCAxNiwgMTcsIDE3LFxuICAgIDE3LCAxNywgMTcsIDE3LCAgIDE3LCAxNywgMTcsIDE3XG5dO1xuXG5mdW5jdGlvbiBidWlsZE11bHRpZXhwKGN1cnZlLCBncm91cE5hbWUpIHtcbiAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICBjb25zdCB0bSA9IEcudG07XG4gICAgYXN5bmMgZnVuY3Rpb24gX211bHRpRXhwQ2h1bmsoYnVmZkJhc2VzLCBidWZmU2NhbGFycywgaW5UeXBlLCBsb2dnZXIsIGxvZ1RleHQpIHtcbiAgICAgICAgaWYgKCAhIChidWZmQmFzZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSApIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihgJHtsb2dUZXh0fSBfbXVsdGlFeHBDaHVuayBidWZmQmFzZXMgaXMgbm90IFVpbnQ4QXJyYXlgKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsb2dUZXh0fSBfbXVsdGlFeHBDaHVuayBidWZmQmFzZXMgaXMgbm90IFVpbnQ4QXJyYXlgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgKGJ1ZmZTY2FsYXJzIGluc3RhbmNlb2YgVWludDhBcnJheSkgKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYCR7bG9nVGV4dH0gX211bHRpRXhwQ2h1bmsgYnVmZlNjYWxhcnMgaXMgbm90IFVpbnQ4QXJyYXlgKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsb2dUZXh0fSBfbXVsdGlFeHBDaHVuayBidWZmU2NhbGFycyBpcyBub3QgVWludDhBcnJheWApO1xuICAgICAgICB9XG4gICAgICAgIGluVHlwZSA9IGluVHlwZSB8fCBcImFmZmluZVwiO1xuXG4gICAgICAgIGxldCBzR0luO1xuICAgICAgICBsZXQgZm5OYW1lO1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gXCJnMW1fbXVsdGlleHBBZmZpbmVfY2h1bmtcIjtcbiAgICAgICAgICAgICAgICBzR0luID0gRy5GLm44KjI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX211bHRpZXhwX2NodW5rXCI7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkcyXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIGZuTmFtZSA9IFwiZzJtX211bHRpZXhwQWZmaW5lX2NodW5rXCI7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbk5hbWUgPSBcImcybV9tdWx0aWV4cF9jaHVua1wiO1xuICAgICAgICAgICAgICAgIHNHSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoYnVmZkJhc2VzLmJ5dGVMZW5ndGggLyBzR0luKTtcblxuICAgICAgICBpZiAoblBvaW50cyA9PSAwKSByZXR1cm4gRy56ZXJvO1xuICAgICAgICBjb25zdCBzU2NhbGFyID0gTWF0aC5mbG9vcihidWZmU2NhbGFycy5ieXRlTGVuZ3RoIC8gblBvaW50cyk7XG4gICAgICAgIGlmKCBzU2NhbGFyICogblBvaW50cyAhPSBidWZmU2NhbGFycy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2FsYXIgc2l6ZSBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJpdENodW5rU2l6ZSA9IHBUU2l6ZXNbbG9nMihuUG9pbnRzKV07XG4gICAgICAgIGNvbnN0IG5DaHVua3MgPSBNYXRoLmZsb29yKChzU2NhbGFyKjggLSAxKSAvIGJpdENodW5rU2l6ZSkgKzE7XG5cbiAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkNodW5rczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW1xuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBidWZmQmFzZXN9LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBidWZmU2NhbGFyc30sXG4gICAgICAgICAgICAgICAge2NtZDogXCJBTExPQ1wiLCB2YXI6IDIsIGxlbjogRy5GLm44KjN9LFxuICAgICAgICAgICAgICAgIHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuTmFtZSwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhbDogc1NjYWxhcn0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IG5Qb2ludHN9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBpKmJpdENodW5rU2l6ZX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YWw6IE1hdGgubWluKHNTY2FsYXIqOCAtIGkqYml0Q2h1bmtTaXplLCBiaXRDaHVua1NpemUpfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMn1cbiAgICAgICAgICAgICAgICBdfSxcbiAgICAgICAgICAgICAgICB7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBHLkYubjgqM31cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgRy50bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCByZXMgPSBHLnplcm87XG4gICAgICAgIGZvciAobGV0IGk9cmVzdWx0Lmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICghRy5pc1plcm8ocmVzKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxiaXRDaHVua1NpemU7IGorKykgcmVzID0gRy5kb3VibGUocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IEcuYWRkKHJlcywgcmVzdWx0W2ldWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX211bHRpRXhwKGJ1ZmZCYXNlcywgYnVmZlNjYWxhcnMsIGluVHlwZSwgbG9nZ2VyLCBsb2dUZXh0KSB7XG4gICAgICAgIGNvbnN0IE1BWF9DSFVOS19TSVpFID0gMSA8PCAyMjtcbiAgICAgICAgY29uc3QgTUlOX0NIVU5LX1NJWkUgPSAxIDw8IDEwO1xuICAgICAgICBsZXQgc0dJbjtcblxuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzR0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0dJbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzR0luID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoYnVmZkJhc2VzLmJ5dGVMZW5ndGggLyBzR0luKTtcbiAgICAgICAgaWYgKG5Qb2ludHMgPT0gMCkgcmV0dXJuIEcuemVybztcbiAgICAgICAgY29uc3Qgc1NjYWxhciA9IE1hdGguZmxvb3IoYnVmZlNjYWxhcnMuYnl0ZUxlbmd0aCAvIG5Qb2ludHMpO1xuICAgICAgICBpZiggc1NjYWxhciAqIG5Qb2ludHMgIT0gYnVmZlNjYWxhcnMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NhbGFyIHNpemUgZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiaXRDaHVua1NpemUgPSBwVFNpemVzW2xvZzIoblBvaW50cyldO1xuICAgICAgICBjb25zdCBuQ2h1bmtzID0gTWF0aC5mbG9vcigoc1NjYWxhcio4IC0gMSkgLyBiaXRDaHVua1NpemUpICsxO1xuXG4gICAgICAgIGxldCBjaHVua1NpemU7XG4gICAgICAgIGNodW5rU2l6ZSA9IE1hdGguZmxvb3IoblBvaW50cyAvICh0bS5jb25jdXJyZW5jeSAvbkNodW5rcykpO1xuICAgICAgICBpZiAoY2h1bmtTaXplPk1BWF9DSFVOS19TSVpFKSBjaHVua1NpemUgPSBNQVhfQ0hVTktfU0laRTtcbiAgICAgICAgaWYgKGNodW5rU2l6ZTxNSU5fQ0hVTktfU0laRSkgY2h1bmtTaXplID0gTUlOX0NIVU5LX1NJWkU7XG5cbiAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSArPSBjaHVua1NpemUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgTXVsdGlleHAgc3RhcnQ6ICR7bG9nVGV4dH06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4oblBvaW50cyAtIGksIGNodW5rU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBidWZmQmFzZXNDaHVuayA9IGJ1ZmZCYXNlcy5zbGljZShpKnNHSW4sIChpK24pKnNHSW4pO1xuICAgICAgICAgICAgY29uc3QgYnVmZlNjYWxhcnNDaHVuayA9IGJ1ZmZTY2FsYXJzLnNsaWNlKGkqc1NjYWxhciwgKGkrbikqc1NjYWxhcik7XG4gICAgICAgICAgICBvcFByb21pc2VzLnB1c2goX211bHRpRXhwQ2h1bmsoYnVmZkJhc2VzQ2h1bmssIGJ1ZmZTY2FsYXJzQ2h1bmssIGluVHlwZSwgbG9nZ2VyLCBsb2dUZXh0KS50aGVuKCAocikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgTXVsdGlleHAgZW5kOiAke2xvZ1RleHR9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCByZXMgPSBHLnplcm87XG4gICAgICAgIGZvciAobGV0IGk9cmVzdWx0Lmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgICAgIHJlcyA9IEcuYWRkKHJlcywgcmVzdWx0W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgRy5tdWx0aUV4cCA9IGFzeW5jIGZ1bmN0aW9uIG11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlcywgYnVmZlNjYWxhcnMsIGxvZ2dlciwgbG9nVGV4dCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgX211bHRpRXhwKGJ1ZmZCYXNlcywgYnVmZlNjYWxhcnMsIFwiamFjb2JpYW5cIiwgbG9nZ2VyLCBsb2dUZXh0KTtcbiAgICB9O1xuICAgIEcubXVsdGlFeHBBZmZpbmUgPSBhc3luYyBmdW5jdGlvbiBtdWx0aUV4cEFmZmluZShidWZmQmFzZXMsIGJ1ZmZTY2FsYXJzLCBsb2dnZXIsIGxvZ1RleHQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9tdWx0aUV4cChidWZmQmFzZXMsIGJ1ZmZTY2FsYXJzLCBcImFmZmluZVwiLCBsb2dnZXIsIGxvZ1RleHQpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRkZUKGN1cnZlLCBncm91cE5hbWUpIHtcbiAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHRtID0gRy50bTtcbiAgICBhc3luYyBmdW5jdGlvbiBfZmZ0KGJ1ZmYsIGludmVyc2UsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpIHtcblxuICAgICAgICBpblR5cGUgPSBpblR5cGUgfHwgXCJhZmZpbmVcIjtcbiAgICAgICAgb3V0VHlwZSA9IG91dFR5cGUgfHwgXCJhZmZpbmVcIjtcbiAgICAgICAgY29uc3QgTUFYX0JJVFNfVEhSRUFEID0gMTQ7XG5cbiAgICAgICAgbGV0IHNJbiwgc01pZCwgc091dCwgZm5JbjJNaWQsIGZuTWlkMk91dCwgZm5GRlRNaXgsIGZuRkZUSm9pbiwgZm5GRlRGaW5hbDtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNJbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgICAgIGZuSW4yTWlkID0gXCJnMW1fYmF0Y2hUb0phY29iaWFuXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNJbiA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc01pZCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICAgICAgICBmbkZGVEZpbmFsID0gXCJnMW1fZmZ0RmluYWxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuRkZUSm9pbiA9IFwiZzFtX2ZmdEpvaW5cIjtcbiAgICAgICAgICAgIGZuRkZUTWl4ID0gXCJnMW1fZmZ0TWl4XCI7XG5cbiAgICAgICAgICAgIGlmIChvdXRUeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjI7XG4gICAgICAgICAgICAgICAgZm5NaWQyT3V0ID0gXCJnMW1fYmF0Y2hUb0FmZmluZVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgICAgICBmbkluMk1pZCA9IFwiZzJtX2JhdGNoVG9KYWNvYmlhblwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNNaWQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICAgICAgZm5GRlRGaW5hbCA9IFwiZzJtX2ZmdEZpbmFsXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbkZGVEpvaW4gPSBcImcybV9mZnRKb2luXCI7XG4gICAgICAgICAgICBmbkZGVE1peCA9IFwiZzJtX2ZmdE1peFwiO1xuICAgICAgICAgICAgaWYgKG91dFR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNPdXQgPSBHLkYubjgqMjtcbiAgICAgICAgICAgICAgICBmbk1pZDJPdXQgPSBcImcybV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNPdXQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJGclwiKSB7XG4gICAgICAgICAgICBzSW4gPSBHLm44O1xuICAgICAgICAgICAgc01pZCA9IEcubjg7XG4gICAgICAgICAgICBzT3V0ID0gRy5uODtcbiAgICAgICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICAgICAgZm5GRlRGaW5hbCA9IFwiZnJtX2ZmdEZpbmFsXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbkZGVE1peCA9IFwiZnJtX2ZmdE1peFwiO1xuICAgICAgICAgICAgZm5GRlRKb2luID0gXCJmcm1fZmZ0Sm9pblwiO1xuICAgICAgICB9XG5cblxuICAgICAgICBsZXQgcmV0dXJuQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZikpIHtcbiAgICAgICAgICAgIGJ1ZmYgPSBhcnJheTJidWZmZXIoYnVmZiwgc0luKTtcbiAgICAgICAgICAgIHJldHVybkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmYgPSBidWZmLnNsaWNlKDAsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuUG9pbnRzID0gYnVmZi5ieXRlTGVuZ3RoIC8gc0luO1xuICAgICAgICBjb25zdCBiaXRzID0gbG9nMihuUG9pbnRzKTtcblxuICAgICAgICBpZiAgKCgxIDw8IGJpdHMpICE9IG5Qb2ludHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZmdCBtdXN0IGJlIG11bHRpcGxlIG9mIDJcIiApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdHMgPT0gRnIucyArMSkge1xuICAgICAgICAgICAgbGV0IGJ1ZmZPdXQ7XG5cbiAgICAgICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICAgICAgYnVmZk91dCA9ICBhd2FpdCBfZmZ0RXh0SW52KGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmT3V0ID0gIGF3YWl0IF9mZnRFeHQoYnVmZiwgaW5UeXBlLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXR1cm5BcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIyYXJyYXkoYnVmZk91dCwgc091dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmT3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGludjtcbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICAgIGludiA9IEZyLmludihGci5lKG5Qb2ludHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBidWZmT3V0O1xuXG4gICAgICAgIGJ1ZmZSZXZlcnNlQml0cyhidWZmLCBzSW4pO1xuXG4gICAgICAgIGxldCBjaHVua3M7XG4gICAgICAgIGxldCBwb2ludHNJbkNodW5rID0gTWF0aC5taW4oMSA8PCBNQVhfQklUU19USFJFQUQsIG5Qb2ludHMpO1xuICAgICAgICBsZXQgbkNodW5rcyA9IG5Qb2ludHMgLyBwb2ludHNJbkNodW5rO1xuXG4gICAgICAgIHdoaWxlICgobkNodW5rcyA8IHRtLmNvbmN1cnJlbmN5KSYmKHBvaW50c0luQ2h1bms+PTE2KSkge1xuICAgICAgICAgICAgbkNodW5rcyAqPSAyO1xuICAgICAgICAgICAgcG9pbnRzSW5DaHVuayAvPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbDJDaHVuayA9IGxvZzIocG9pbnRzSW5DaHVuayk7XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGk8IG5DaHVua3M7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGAke2xvZ2dlclR4dH06IGZmdCAke2JpdHN9IG1peCBzdGFydDogJHtpfS8ke25DaHVua3N9YCk7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDAsIGxlbjogc01pZCpwb2ludHNJbkNodW5rfSk7XG4gICAgICAgICAgICBjb25zdCBidWZmQ2h1bmsgPSBidWZmLnNsaWNlKCAocG9pbnRzSW5DaHVuayAqIGkpKnNJbiwgKHBvaW50c0luQ2h1bmsgKiAoaSsxKSkqc0luKTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIlNFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJ1ZmZDaHVua30pO1xuICAgICAgICAgICAgaWYgKGZuSW4yTWlkKSB7XG4gICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6Zm5JbjJNaWQsIHBhcmFtczogW3t2YXI6MH0sIHt2YWw6IHBvaW50c0luQ2h1bmt9LCB7dmFyOiAwfV19KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGo9MTsgajw9bDJDaHVuaztqKyspIHtcbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTpmbkZGVE1peCwgcGFyYW1zOiBbe3ZhcjowfSwge3ZhbDogcG9pbnRzSW5DaHVua30sIHt2YWw6IGp9XX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobDJDaHVuaz09Yml0cykge1xuICAgICAgICAgICAgICAgIGlmIChmbkZGVEZpbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogaW52fSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkZGVEZpbmFsLCAgcGFyYW1zOltcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogcG9pbnRzSW5DaHVua30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm5NaWQyT3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuTWlkMk91dCwgcGFyYW1zOiBbe3ZhcjowfSwge3ZhbDogcG9pbnRzSW5DaHVua30sIHt2YXI6IDB9XX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDAsIGxlbjogcG9pbnRzSW5DaHVuaypzT3V0fSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6MCwgdmFyOiAwLCBsZW46IHNNaWQqcG9pbnRzSW5DaHVua30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0bS5xdWV1ZUFjdGlvbih0YXNrKS50aGVuKCAocikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgJHtsb2dnZXJUeHR9OiBmZnQgJHtiaXRzfSBtaXggZW5kOiAke2l9LyR7bkNodW5rc31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGk8IG5DaHVua3M7IGkrKykgY2h1bmtzW2ldID0gY2h1bmtzW2ldWzBdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBsMkNodW5rKzE7ICAgaTw9Yml0czsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYCR7bG9nZ2VyVHh0fTogZmZ0ICAke2JpdHN9ICBqb2luOiAke2l9LyR7Yml0c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG5Hcm91cHMgPSAxIDw8IChiaXRzIC0gaSk7XG4gICAgICAgICAgICBjb25zdCBuQ2h1bmtzUGVyR3JvdXAgPSBuQ2h1bmtzIC8gbkdyb3VwcztcbiAgICAgICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxuR3JvdXBzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrPTA7IGsgPG5DaHVua3NQZXJHcm91cC8yOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBGci5leHAoIEZyLndbaV0sIGsqcG9pbnRzSW5DaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluYyA9IEZyLndbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8xID0gaipuQ2h1bmtzUGVyR3JvdXAgKyBrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvMiA9IGoqbkNodW5rc1Blckdyb3VwICsgayArIG5DaHVua3NQZXJHcm91cC8yO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBjaHVua3NbbzFdfSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogY2h1bmtzW28yXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDIsIGJ1ZmY6IGZpcnN0fSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMywgYnVmZjogaW5jfSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkZGVEpvaW4sICBwYXJhbXM6W1xuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAxfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YWw6IHBvaW50c0luQ2h1bmt9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAzfVxuICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpPT1iaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm5GRlRGaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogNCwgYnVmZjogaW52fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuRkZURmluYWwsICBwYXJhbXM6W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogcG9pbnRzSW5DaHVua30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDR9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5GRlRGaW5hbCwgIHBhcmFtczpbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBwb2ludHNJbkNodW5rfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogNH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuTWlkMk91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuTWlkMk91dCwgcGFyYW1zOiBbe3ZhcjowfSwge3ZhbDogcG9pbnRzSW5DaHVua30sIHt2YXI6IDB9XX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuTWlkMk91dCwgcGFyYW1zOiBbe3ZhcjoxfSwge3ZhbDogcG9pbnRzSW5DaHVua30sIHt2YXI6IDF9XX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAwLCBsZW46IHBvaW50c0luQ2h1bmsqc091dH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMSwgdmFyOiAxLCBsZW46IHBvaW50c0luQ2h1bmsqc091dH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAwLCBsZW46IHBvaW50c0luQ2h1bmsqc01pZH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMSwgdmFyOiAxLCBsZW46IHBvaW50c0luQ2h1bmsqc01pZH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaCh0bS5xdWV1ZUFjdGlvbih0YXNrKS50aGVuKCAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGAke2xvZ2dlclR4dH06IGZmdCAke2JpdHN9IGpvaW4gICR7aX0vJHtiaXRzfSAgJHtqKzF9LyR7bkdyb3Vwc30gJHtrfS8ke25DaHVua3NQZXJHcm91cC8yfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5Hcm91cHM7IGorKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGs9MDsgayA8bkNodW5rc1Blckdyb3VwLzI7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvMSA9IGoqbkNodW5rc1Blckdyb3VwICsgaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzIgPSBqKm5DaHVua3NQZXJHcm91cCArIGsgKyBuQ2h1bmtzUGVyR3JvdXAvMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzQ2h1bmsgPSByZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW28xXSA9IHJlc0NodW5rWzBdO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3NbbzJdID0gcmVzQ2h1bmtbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ1ZmYgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc091dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzT3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgYnVmZk91dC5zZXQoY2h1bmtzWzBdLnNsaWNlKChwb2ludHNJbkNodW5rLTEpKnNPdXQpKTtcbiAgICAgICAgICAgIGxldCBwPSBzT3V0O1xuICAgICAgICAgICAgZm9yIChsZXQgaT1uQ2h1bmtzLTE7IGk+MDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYnVmZk91dC5zZXQoY2h1bmtzW2ldLCBwKTtcbiAgICAgICAgICAgICAgICBwICs9IHBvaW50c0luQ2h1bmsqc091dDtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2h1bmtzW2ldOyAgLy8gTGliZXJhdGUgbWVtXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmT3V0LnNldChjaHVua3NbMF0uc2xpY2UoMCwgKHBvaW50c0luQ2h1bmstMSkqc091dCksIHApO1xuICAgICAgICAgICAgZGVsZXRlIGNodW5rc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWZmT3V0LnNldChjaHVua3NbaV0sIHBvaW50c0luQ2h1bmsqc091dCppKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2h1bmtzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVybkFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyMmFycmF5KGJ1ZmZPdXQsIHNPdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZPdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBfZmZ0RXh0KGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpIHtcbiAgICAgICAgbGV0IGIxLCBiMjtcbiAgICAgICAgYjEgPSBidWZmLnNsaWNlKCAwICwgYnVmZi5ieXRlTGVuZ3RoLzIpO1xuICAgICAgICBiMiA9IGJ1ZmYuc2xpY2UoIGJ1ZmYuYnl0ZUxlbmd0aC8yLCBidWZmLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICAgICAgW2IxLCBiMl0gPSBhd2FpdCBfZmZ0Sm9pbkV4dChiMSwgYjIsIFwiZmZ0Sm9pbkV4dFwiLCBGci5vbmUsIEZyLnNoaWZ0LCBpblR5cGUsIFwiamFjb2JpYW5cIiwgbG9nZ2VyLCBsb2dnZXJUeHQpO1xuXG4gICAgICAgIHByb21pc2VzLnB1c2goIF9mZnQoYjEsIGZhbHNlLCBcImphY29iaWFuXCIsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSk7XG4gICAgICAgIHByb21pc2VzLnB1c2goIF9mZnQoYjIsIGZhbHNlLCBcImphY29iaWFuXCIsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSk7XG5cbiAgICAgICAgY29uc3QgcmVzMSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICBsZXQgYnVmZk91dDtcbiAgICAgICAgaWYgKHJlczFbMF0uYnl0ZUxlbmd0aCA+ICgxPDwyOCkpIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQgPSBuZXcgQmlnQnVmZmVyKHJlczFbMF0uYnl0ZUxlbmd0aCoyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQgPSBuZXcgVWludDhBcnJheShyZXMxWzBdLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmT3V0LnNldChyZXMxWzBdKTtcbiAgICAgICAgYnVmZk91dC5zZXQocmVzMVsxXSwgcmVzMVswXS5ieXRlTGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gYnVmZk91dDtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBfZmZ0RXh0SW52KGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpIHtcbiAgICAgICAgbGV0IGIxLCBiMjtcbiAgICAgICAgYjEgPSBidWZmLnNsaWNlKCAwICwgYnVmZi5ieXRlTGVuZ3RoLzIpO1xuICAgICAgICBiMiA9IGJ1ZmYuc2xpY2UoIGJ1ZmYuYnl0ZUxlbmd0aC8yLCBidWZmLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgICAgICAgcHJvbWlzZXMucHVzaCggX2ZmdChiMSwgdHJ1ZSwgaW5UeXBlLCBcImphY29iaWFuXCIsIGxvZ2dlciwgbG9nZ2VyVHh0KSk7XG4gICAgICAgIHByb21pc2VzLnB1c2goIF9mZnQoYjIsIHRydWUsIGluVHlwZSwgXCJqYWNvYmlhblwiLCBsb2dnZXIsIGxvZ2dlclR4dCkpO1xuXG4gICAgICAgIFtiMSwgYjJdID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICAgIGNvbnN0IHJlczEgPSBhd2FpdCBfZmZ0Sm9pbkV4dChiMSwgYjIsIFwiZmZ0Sm9pbkV4dEludlwiLCBGci5vbmUsIEZyLnNoaWZ0SW52LCBcImphY29iaWFuXCIsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KTtcblxuICAgICAgICBsZXQgYnVmZk91dDtcbiAgICAgICAgaWYgKHJlczFbMF0uYnl0ZUxlbmd0aCA+ICgxPDwyOCkpIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQgPSBuZXcgQmlnQnVmZmVyKHJlczFbMF0uYnl0ZUxlbmd0aCoyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQgPSBuZXcgVWludDhBcnJheShyZXMxWzBdLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmT3V0LnNldChyZXMxWzBdKTtcbiAgICAgICAgYnVmZk91dC5zZXQocmVzMVsxXSwgcmVzMVswXS5ieXRlTGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gYnVmZk91dDtcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9mZnRKb2luRXh0KGJ1ZmYxLCBidWZmMiwgZm4sIGZpcnN0LCBpbmMsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpIHtcbiAgICAgICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxPDwxNjtcbiAgICAgICAgY29uc3QgTUlOX0NIVU5LX1NJWkUgPSAxPDw0O1xuXG4gICAgICAgIGxldCBmbk5hbWU7XG4gICAgICAgIGxldCBmbkluMk1pZCwgZm5NaWQyT3V0O1xuICAgICAgICBsZXQgc091dCwgc0luLCBzTWlkO1xuXG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgICAgICBmbkluMk1pZCA9IFwiZzFtX2JhdGNoVG9KYWNvYmlhblwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNNaWQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX1wiK2ZuO1xuICAgICAgICAgICAgaWYgKG91dFR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIGZuTWlkMk91dCA9IFwiZzFtX2JhdGNoVG9BZmZpbmVcIjtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNPdXQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5UeXBlID09IFwiYWZmaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgICAgICBmbkluMk1pZCA9IFwiZzJtX2JhdGNoVG9KYWNvYmlhblwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZzJtX1wiK2ZuO1xuICAgICAgICAgICAgc01pZCA9IEcuRi5uOCozO1xuICAgICAgICAgICAgaWYgKG91dFR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIGZuTWlkMk91dCA9IFwiZzJtX2JhdGNoVG9BZmZpbmVcIjtcbiAgICAgICAgICAgICAgICBzT3V0ID0gRy5GLm44KjI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNPdXQgPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJGclwiKSB7XG4gICAgICAgICAgICBzSW4gPSBGci5uODtcbiAgICAgICAgICAgIHNPdXQgPSBGci5uODtcbiAgICAgICAgICAgIHNNaWQgPSBGci5uODtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZnJtX1wiICsgZm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ1ZmYxLmJ5dGVMZW5ndGggIT0gYnVmZjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBidWZmZXIgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuUG9pbnRzID0gTWF0aC5mbG9vcihidWZmMS5ieXRlTGVuZ3RoIC8gc0luKTtcbiAgICAgICAgaWYgKG5Qb2ludHMgIT0gMSA8PCBsb2cyKG5Qb2ludHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2h1bmtTaXplID0gTWF0aC5mbG9vcihuUG9pbnRzIC90bS5jb25jdXJyZW5jeSk7XG4gICAgICAgIGlmIChjaHVua1NpemUgPCBNSU5fQ0hVTktfU0laRSkgY2h1bmtTaXplID0gTUlOX0NIVU5LX1NJWkU7XG4gICAgICAgIGlmIChjaHVua1NpemUgPiBNQVhfQ0hVTktfU0laRSkgY2h1bmtTaXplID0gTUFYX0NIVU5LX1NJWkU7XG5cbiAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpICs9IGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGAke2xvZ2dlclR4dH06IGZmdEpvaW5FeHQgU3RhcnQ6ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4oblBvaW50cyAtIGksIGNodW5rU2l6ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBGci5tdWwoZmlyc3QsIEZyLmV4cCggaW5jLCBpKSk7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG5cbiAgICAgICAgICAgIGNvbnN0IGIxID0gYnVmZjEuc2xpY2UoaSpzSW4sIChpK24pKnNJbik7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGJ1ZmYyLnNsaWNlKGkqc0luLCAoaStuKSpzSW4pO1xuXG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDAsIGxlbjogc01pZCpufSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJTRVRcIiwgdmFyOiAwLCBidWZmOiBiMX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAxLCBsZW46IHNNaWQqbn0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiU0VUXCIsIHZhcjogMSwgYnVmZjogYjJ9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMiwgYnVmZjogZmlyc3RDaHVua30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAzLCBidWZmOiBpbmN9KTtcbiAgICAgICAgICAgIGlmIChmbkluMk1pZCkge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuSW4yTWlkLCBwYXJhbXM6IFt7dmFyOjB9LCB7dmFsOiBufSwge3ZhcjogMH1dfSk7XG4gICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6Zm5JbjJNaWQsIHBhcmFtczogW3t2YXI6MX0sIHt2YWw6IG59LCB7dmFyOiAxfV19KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk5hbWUsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICAgICAgICAgIHt2YWw6IEZyLnN9LFxuICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgaWYgKGZuTWlkMk91dCkge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuTWlkMk91dCwgcGFyYW1zOiBbe3ZhcjowfSwge3ZhbDogbn0sIHt2YXI6IDB9XX0pO1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOmZuTWlkMk91dCwgcGFyYW1zOiBbe3ZhcjoxfSwge3ZhbDogbn0sIHt2YXI6IDF9XX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAwLCBsZW46IG4qc091dH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMSwgdmFyOiAxLCBsZW46IG4qc091dH0pO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIHRtLnF1ZXVlQWN0aW9uKHRhc2spLnRoZW4oIChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgJHtsb2dnZXJUeHR9OiBmZnRKb2luRXh0IEVuZDogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgbGV0IGZ1bGxCdWZmT3V0MTtcbiAgICAgICAgbGV0IGZ1bGxCdWZmT3V0MjtcbiAgICAgICAgaWYgKG5Qb2ludHMgKiBzT3V0ID4gMTw8MjgpIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0MSA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzT3V0KTtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0MiA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzT3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0MSA9IG5ldyBVaW50OEFycmF5KG5Qb2ludHMqc091dCk7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDIgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNPdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHAgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0MS5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0Mi5zZXQocmVzdWx0W2ldWzFdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtmdWxsQnVmZk91dDEsIGZ1bGxCdWZmT3V0Ml07XG4gICAgfVxuXG5cbiAgICBHLmZmdCA9IGFzeW5jIGZ1bmN0aW9uKGJ1ZmYsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9mZnQoYnVmZiwgZmFsc2UsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpO1xuICAgIH07XG5cbiAgICBHLmlmZnQgPSBhc3luYyBmdW5jdGlvbihidWZmLCBpblR5cGUsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfZmZ0KGJ1ZmYsIHRydWUsIGluVHlwZSwgb3V0VHlwZSwgbG9nZ2VyLCBsb2dnZXJUeHQpO1xuICAgIH07XG5cbiAgICBHLmxhZ3JhbmdlRXZhbHVhdGlvbnMgPSBhc3luYyBmdW5jdGlvbiAoYnVmZiwgaW5UeXBlLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCkge1xuICAgICAgICBpblR5cGUgPSBpblR5cGUgfHwgXCJhZmZpbmVcIjtcbiAgICAgICAgb3V0VHlwZSA9IG91dFR5cGUgfHwgXCJhZmZpbmVcIjtcblxuICAgICAgICBsZXQgc0luO1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgaWYgKGluVHlwZSA9PSBcImFmZmluZVwiKSB7XG4gICAgICAgICAgICAgICAgc0luID0gRy5GLm44KjI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNJbiA9IEcuRi5uOCozO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkcyXCIpIHtcbiAgICAgICAgICAgIGlmIChpblR5cGUgPT0gXCJhZmZpbmVcIikge1xuICAgICAgICAgICAgICAgIHNJbiA9IEcuRi5uOCoyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzSW4gPSBHLkYubjgqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJGclwiKSB7XG4gICAgICAgICAgICBzSW4gPSBGci5uODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuUG9pbnRzID0gYnVmZi5ieXRlTGVuZ3RoIC9zSW47XG4gICAgICAgIGNvbnN0IGJpdHMgPSBsb2cyKG5Qb2ludHMpO1xuXG4gICAgICAgIGlmICgoMiAqKiBiaXRzKSpzSW4gIT0gYnVmZi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJsYWdyYW5nZUV2YWx1YXRpb25zIGlpbnZhbGlkIGlucHV0IHNpemVcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsYWdyYW5nZUV2YWx1YXRpb25zIGludmFsaWQgSW5wdXQgc2l6ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXRzIDw9IEZyLnMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBHLmlmZnQoYnVmZiwgaW5UeXBlLCBvdXRUeXBlLCBsb2dnZXIsIGxvZ2dlclR4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0cyA+IEZyLnMrMSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwibGFncmFuZ2VFdmFsdWF0aW9ucyBpbnB1dCB0b28gYmlnXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGFncmFuZ2VFdmFsdWF0aW9ucyBpbnB1dCB0b28gYmlnXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHQwID0gYnVmZi5zbGljZSgwLCBidWZmLmJ5dGVMZW5ndGgvMik7XG4gICAgICAgIGxldCB0MSA9IGJ1ZmYuc2xpY2UoYnVmZi5ieXRlTGVuZ3RoLzIsIGJ1ZmYuYnl0ZUxlbmd0aCk7XG5cblxuICAgICAgICBjb25zdCBzaGlmdFRvU21hbGxNID0gRnIuZXhwKEZyLnNoaWZ0LCBuUG9pbnRzLzIpO1xuICAgICAgICBjb25zdCBzQ29uc3QgPSBGci5pbnYoIEZyLnN1YihGci5vbmUsIHNoaWZ0VG9TbWFsbE0pKTtcblxuICAgICAgICBbdDAsIHQxXSA9IGF3YWl0IF9mZnRKb2luRXh0KHQwLCB0MSwgXCJwcmVwYXJlTGFncmFuZ2VFdmFsdWF0aW9uXCIsIHNDb25zdCwgRnIuc2hpZnRJbnYsIGluVHlwZSwgXCJqYWNvYmlhblwiLCBsb2dnZXIsIGxvZ2dlclR4dCArIFwiIHByZXBcIik7XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICBwcm9taXNlcy5wdXNoKCBfZmZ0KHQwLCB0cnVlLCBcImphY29iaWFuXCIsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0ICsgXCIgdDBcIikpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKCBfZmZ0KHQxLCB0cnVlLCBcImphY29iaWFuXCIsIG91dFR5cGUsIGxvZ2dlciwgbG9nZ2VyVHh0ICsgXCIgdDFcIikpO1xuXG4gICAgICAgIFt0MCwgdDFdID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCBidWZmT3V0O1xuICAgICAgICBpZiAodDAuYnl0ZUxlbmd0aCA+ICgxPDwyOCkpIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQgPSBuZXcgQmlnQnVmZmVyKHQwLmJ5dGVMZW5ndGgqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkodDAuYnl0ZUxlbmd0aCoyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZPdXQuc2V0KHQwKTtcbiAgICAgICAgYnVmZk91dC5zZXQodDEsIHQwLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBidWZmT3V0O1xuICAgIH07XG5cbiAgICBHLmZmdE1peCA9IGFzeW5jIGZ1bmN0aW9uIGZmdE1peChidWZmKSB7XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjM7XG4gICAgICAgIGxldCBmbk5hbWUsIGZuRkZUSm9pbjtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX2ZmdE1peFwiO1xuICAgICAgICAgICAgZm5GRlRKb2luID0gXCJnMW1fZmZ0Sm9pblwiO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkcyXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZzJtX2ZmdE1peFwiO1xuICAgICAgICAgICAgZm5GRlRKb2luID0gXCJnMm1fZmZ0Sm9pblwiO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwTmFtZSA9PSBcIkZyXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZnJtX2ZmdE1peFwiO1xuICAgICAgICAgICAgZm5GRlRKb2luID0gXCJmcm1fZmZ0Sm9pblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGJ1ZmYuYnl0ZUxlbmd0aCAvIHNHKTtcbiAgICAgICAgY29uc3QgcG93ZXIgPSBsb2cyKG5Qb2ludHMpO1xuXG4gICAgICAgIGxldCBuQ2h1bmtzID0gMSA8PCBsb2cyKHRtLmNvbmN1cnJlbmN5KTtcblxuICAgICAgICBpZiAoblBvaW50cyA8PSBuQ2h1bmtzKjIpIG5DaHVua3MgPSAxO1xuXG4gICAgICAgIGNvbnN0IHBvaW50c1BlckNodW5rID0gblBvaW50cyAvIG5DaHVua3M7XG5cbiAgICAgICAgY29uc3QgcG93ZXJDaHVuayA9IGxvZzIocG9pbnRzUGVyQ2h1bmspO1xuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5DaHVua3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYiA9IGJ1ZmYuc2xpY2UoKGkqIHBvaW50c1BlckNodW5rKSpzRywgKChpKzEpKiBwb2ludHNQZXJDaHVuaykqc0cpO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBifSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqPTE7IGo8PXBvd2VyQ2h1bms7IGorKykge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk5hbWUsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhbDogcG9pbnRzUGVyQ2h1bmt9LFxuICAgICAgICAgICAgICAgICAgICB7dmFsOiBqfVxuICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBwb2ludHNQZXJDaHVuaypzR30pO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIHRtLnF1ZXVlQWN0aW9uKHRhc2spXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIGNodW5rc1tpXSA9IHJlc3VsdFtpXVswXTtcblxuXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3dlckNodW5rKzE7IGk8PXBvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5Hcm91cHMgPSAxIDw8IChwb3dlciAtIGkpO1xuICAgICAgICAgICAgY29uc3QgbkNodW5rc1Blckdyb3VwID0gbkNodW5rcyAvIG5Hcm91cHM7XG4gICAgICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8bkdyb3VwczsgaisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaz0wOyBrIDxuQ2h1bmtzUGVyR3JvdXAvMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gRnIuZXhwKCBGci53W2ldLCBrKnBvaW50c1BlckNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5jID0gRnIud1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzEgPSBqKm5DaHVua3NQZXJHcm91cCArIGs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8yID0gaipuQ2h1bmtzUGVyR3JvdXAgKyBrICsgbkNodW5rc1Blckdyb3VwLzI7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGNodW5rc1tvMV19KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBjaHVua3NbbzJdfSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMiwgYnVmZjogZmlyc3R9KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAzLCBidWZmOiBpbmN9KTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuRkZUSm9pbiwgIHBhcmFtczpbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogcG9pbnRzUGVyQ2h1bmt9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAzfVxuICAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMCwgbGVuOiBwb2ludHNQZXJDaHVuaypzR30pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAxLCB2YXI6IDEsIGxlbjogcG9pbnRzUGVyQ2h1bmsqc0d9KTtcbiAgICAgICAgICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKHRtLnF1ZXVlQWN0aW9uKHRhc2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPG5Hcm91cHM7IGorKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGs9MDsgayA8bkNodW5rc1Blckdyb3VwLzI7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvMSA9IGoqbkNodW5rc1Blckdyb3VwICsgaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzIgPSBqKm5DaHVua3NQZXJHcm91cCArIGsgKyBuQ2h1bmtzUGVyR3JvdXAvMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzQ2h1bmsgPSByZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW28xXSA9IHJlc0NodW5rWzBdO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3NbbzJdID0gcmVzQ2h1bmtbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZ1bGxCdWZmT3V0O1xuICAgICAgICBpZiAoYnVmZiBpbnN0YW5jZW9mIEJpZ0J1ZmZlcikge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNHKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcCA9MDtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5DaHVua3M7IGkrKykge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQuc2V0KGNodW5rc1tpXSwgcCk7XG4gICAgICAgICAgICBwKz1jaHVua3NbaV0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdWxsQnVmZk91dDtcbiAgICB9O1xuXG4gICAgRy5mZnRKb2luID0gYXN5bmMgZnVuY3Rpb24gZmZ0Sm9pbihidWZmMSwgYnVmZjIsIGZpcnN0LCBpbmMpIHtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMztcbiAgICAgICAgbGV0IGZuTmFtZTtcbiAgICAgICAgaWYgKGdyb3VwTmFtZSA9PSBcIkcxXCIpIHtcbiAgICAgICAgICAgIGZuTmFtZSA9IFwiZzFtX2ZmdEpvaW5cIjtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cE5hbWUgPT0gXCJHMlwiKSB7XG4gICAgICAgICAgICBmbk5hbWUgPSBcImcybV9mZnRKb2luXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRnJcIikge1xuICAgICAgICAgICAgZm5OYW1lID0gXCJmcm1fZmZ0Sm9pblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmMS5ieXRlTGVuZ3RoICE9IGJ1ZmYyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnVmZmVyIHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoYnVmZjEuYnl0ZUxlbmd0aCAvIHNHKTtcbiAgICAgICAgaWYgKG5Qb2ludHMgIT0gMSA8PCBsb2cyKG5Qb2ludHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbkNodW5rcyA9IDEgPDwgbG9nMih0bS5jb25jdXJyZW5jeSk7XG4gICAgICAgIGlmIChuUG9pbnRzIDw9IG5DaHVua3MqMikgbkNodW5rcyA9IDE7XG5cbiAgICAgICAgY29uc3QgcG9pbnRzUGVyQ2h1bmsgPSBuUG9pbnRzIC8gbkNodW5rcztcblxuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5DaHVua3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgICAgICBjb25zdCBmaXJzdENodW5rID0gRnIubXVsKGZpcnN0LCBGci5leHAoaW5jLCBpKnBvaW50c1BlckNodW5rKSk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IGJ1ZmYxLnNsaWNlKChpKiBwb2ludHNQZXJDaHVuaykqc0csICgoaSsxKSogcG9pbnRzUGVyQ2h1bmspKnNHKTtcbiAgICAgICAgICAgIGNvbnN0IGIyID0gYnVmZjIuc2xpY2UoKGkqIHBvaW50c1BlckNodW5rKSpzRywgKChpKzEpKiBwb2ludHNQZXJDaHVuaykqc0cpO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBiMX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBiMn0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAyLCBidWZmOiBmaXJzdENodW5rfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDMsIGJ1ZmY6IGluY30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuTmFtZSwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAge3ZhbDogcG9pbnRzUGVyQ2h1bmt9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAgICAgIHt2YXI6IDN9XG4gICAgICAgICAgICBdfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAwLCB2YXI6IDAsIGxlbjogcG9pbnRzUGVyQ2h1bmsqc0d9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDEsIHZhcjogMSwgbGVuOiBwb2ludHNQZXJDaHVuaypzR30pO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgIHRtLnF1ZXVlQWN0aW9uKHRhc2spXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGxldCBmdWxsQnVmZk91dDE7XG4gICAgICAgIGxldCBmdWxsQnVmZk91dDI7XG4gICAgICAgIGlmIChidWZmMSBpbnN0YW5jZW9mIEJpZ0J1ZmZlcikge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQxID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNHKTtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0MiA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzRyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dDEgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNHKTtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0MiA9IG5ldyBVaW50OEFycmF5KG5Qb2ludHMqc0cpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHAgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0MS5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIGZ1bGxCdWZmT3V0Mi5zZXQocmVzdWx0W2ldWzFdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtmdWxsQnVmZk91dDEsIGZ1bGxCdWZmT3V0Ml07XG4gICAgfTtcblxuXG5cbiAgICBHLmZmdEZpbmFsID0gIGFzeW5jIGZ1bmN0aW9uIGZmdEZpbmFsKGJ1ZmYsIGZhY3Rvcikge1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCozO1xuICAgICAgICBjb25zdCBzR291dCA9IEcuRi5uOCoyO1xuICAgICAgICBsZXQgZm5OYW1lLCBmblRvQWZmaW5lO1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgZm5OYW1lID0gXCJnMW1fZmZ0RmluYWxcIjtcbiAgICAgICAgICAgIGZuVG9BZmZpbmUgPSBcImcxbV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgZm5OYW1lID0gXCJnMm1fZmZ0RmluYWxcIjtcbiAgICAgICAgICAgIGZuVG9BZmZpbmUgPSBcImcybV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoYnVmZi5ieXRlTGVuZ3RoIC8gc0cpO1xuICAgICAgICBpZiAoblBvaW50cyAhPSAxIDw8IGxvZzIoblBvaW50cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50c1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvaW50c1BlckNodW5rID0gTWF0aC5mbG9vcihuUG9pbnRzIC8gdG0uY29uY3VycmVuY3kpO1xuXG4gICAgICAgIGNvbnN0IG9wUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHRtLmNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGk8IHRtLmNvbmN1cnJlbmN5LTEpIHtcbiAgICAgICAgICAgICAgICBuID0gcG9pbnRzUGVyQ2h1bms7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzIC0gaSpwb2ludHNQZXJDaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuPT0wKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBidWZmLnNsaWNlKChpKiBwb2ludHNQZXJDaHVuaykqc0csIChpKnBvaW50c1BlckNodW5rK24pKnNHKTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYn0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBmYWN0b3J9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk5hbWUsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAgICAgIHt2YXI6IDF9LFxuICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IGZuVG9BZmZpbmUsIHBhcmFtczogW1xuICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAwLCBsZW46IG4qc0dvdXR9KTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICB0bS5xdWV1ZUFjdGlvbih0YXNrKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgbGV0IGZ1bGxCdWZmT3V0O1xuICAgICAgICBpZiAoYnVmZiBpbnN0YW5jZW9mIEJpZ0J1ZmZlcikge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQgPSBuZXcgQmlnQnVmZmVyKG5Qb2ludHMqc0dvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVsbEJ1ZmZPdXQgPSBuZXcgVWludDhBcnJheShuUG9pbnRzKnNHb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPXJlc3VsdC5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dC5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bGxCdWZmT3V0O1xuICAgIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkRW5naW5lKHBhcmFtcykge1xuXG4gICAgY29uc3QgdG0gPSBhd2FpdCBidWlsZFRocmVhZE1hbmFnZXIocGFyYW1zLndhc20sIHBhcmFtcy5zaW5nbGVUaHJlYWQpO1xuXG5cbiAgICBjb25zdCBjdXJ2ZSA9IHt9O1xuXG4gICAgY3VydmUucSA9IGUocGFyYW1zLndhc20ucS50b1N0cmluZygpKTtcbiAgICBjdXJ2ZS5yID0gZShwYXJhbXMud2FzbS5yLnRvU3RyaW5nKCkpO1xuICAgIGN1cnZlLm5hbWUgPSBwYXJhbXMubmFtZTtcbiAgICBjdXJ2ZS50bSA9IHRtO1xuICAgIGN1cnZlLnByZVBTaXplID0gcGFyYW1zLndhc20ucHJlUFNpemU7XG4gICAgY3VydmUucHJlUVNpemUgPSBwYXJhbXMud2FzbS5wcmVRU2l6ZTtcbiAgICBjdXJ2ZS5GciA9IG5ldyBXYXNtRmllbGQxKHRtLCBcImZybVwiLCBwYXJhbXMubjhyLCBwYXJhbXMucik7XG4gICAgY3VydmUuRjEgPSBuZXcgV2FzbUZpZWxkMSh0bSwgXCJmMW1cIiwgcGFyYW1zLm44cSwgcGFyYW1zLnEpO1xuICAgIGN1cnZlLkYyID0gbmV3IFdhc21GaWVsZDIodG0sIFwiZjJtXCIsIGN1cnZlLkYxKTtcbiAgICBjdXJ2ZS5HMSA9IG5ldyBXYXNtQ3VydmUodG0sIFwiZzFtXCIsIGN1cnZlLkYxLCBwYXJhbXMud2FzbS5wRzFnZW4sIHBhcmFtcy53YXNtLnBHMWIsIHBhcmFtcy5jb2ZhY3RvckcxKTtcbiAgICBjdXJ2ZS5HMiA9IG5ldyBXYXNtQ3VydmUodG0sIFwiZzJtXCIsIGN1cnZlLkYyLCBwYXJhbXMud2FzbS5wRzJnZW4sIHBhcmFtcy53YXNtLnBHMmIsIHBhcmFtcy5jb2ZhY3RvckcyKTtcbiAgICBjdXJ2ZS5GNiA9IG5ldyBXYXNtRmllbGQzKHRtLCBcImY2bVwiLCBjdXJ2ZS5GMik7XG4gICAgY3VydmUuRjEyID0gbmV3IFdhc21GaWVsZDIodG0sIFwiZnRtXCIsIGN1cnZlLkY2KTtcblxuICAgIGN1cnZlLkd0ID0gY3VydmUuRjEyO1xuXG4gICAgYnVpbGRCYXRjaEFwcGx5S2V5KGN1cnZlLCBcIkcxXCIpO1xuICAgIGJ1aWxkQmF0Y2hBcHBseUtleShjdXJ2ZSwgXCJHMlwiKTtcbiAgICBidWlsZEJhdGNoQXBwbHlLZXkoY3VydmUsIFwiRnJcIik7XG5cbiAgICBidWlsZE11bHRpZXhwKGN1cnZlLCBcIkcxXCIpO1xuICAgIGJ1aWxkTXVsdGlleHAoY3VydmUsIFwiRzJcIik7XG5cbiAgICBidWlsZEZGVChjdXJ2ZSwgXCJHMVwiKTtcbiAgICBidWlsZEZGVChjdXJ2ZSwgXCJHMlwiKTtcbiAgICBidWlsZEZGVChjdXJ2ZSwgXCJGclwiKTtcblxuICAgIGJ1aWxkUGFpcmluZyhjdXJ2ZSk7XG5cbiAgICBjdXJ2ZS5hcnJheTJidWZmZXIgPSBmdW5jdGlvbihhcnIsIHNHKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRyphcnIubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBidWZmLnNldChhcnJbaV0sIGkqc0cpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmY7XG4gICAgfTtcblxuICAgIGN1cnZlLmJ1ZmZlcjJhcnJheSA9IGZ1bmN0aW9uKGJ1ZmYgLCBzRykge1xuICAgICAgICBjb25zdCBuPSBidWZmLmJ5dGVMZW5ndGggLyBzRztcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBidWZmLnNsaWNlKGkqc0csIGkqc0crc0cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcblxuICAgIHJldHVybiBjdXJ2ZTtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21idWlsZGVyXG5cbiAgICB3YXNtYnVpbGRlciBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21idWlsZGVyIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdhc21idWlsZGVyLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuZnVuY3Rpb24gdG9OdW1iZXIobikge1xuICAgIHJldHVybiBCaWdJbnQobik7XG59XG5cbmZ1bmN0aW9uIGlzTmVnYXRpdmUobikge1xuICAgIHJldHVybiBuIDwgMG47XG59XG5cbmZ1bmN0aW9uIGlzWmVybyhuKSB7XG4gICAgcmV0dXJuIG4gPT09IDBuO1xufVxuXG5mdW5jdGlvbiBiaXRMZW5ndGgobikge1xuICAgIGlmIChpc05lZ2F0aXZlKG4pKSB7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKDIpLmxlbmd0aCAtIDE7IC8vIGRpc2NhcmQgdGhlIC0gc2lnblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHUzMihuKSB7XG4gICAgY29uc3QgYiA9IFtdO1xuICAgIGNvbnN0IHYgPSB0b051bWJlcihuKTtcbiAgICBiLnB1c2goTnVtYmVyKHYgJiAweEZGbikpO1xuICAgIGIucHVzaChOdW1iZXIodiA+PiA4biAmIDB4RkZuKSk7XG4gICAgYi5wdXNoKE51bWJlcih2ID4+IDE2biAmIDB4RkZuKSk7XG4gICAgYi5wdXNoKE51bWJlcih2ID4+IDI0biAmIDB4RkZuKSk7XG4gICAgcmV0dXJuIGI7XG59XG5cbmZ1bmN0aW9uIHRvVVRGOEFycmF5KHN0cikge1xuICAgIHZhciB1dGY4ID0gW107XG4gICAgZm9yICh2YXIgaT0wOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhcmNvZGUgPCAweDgwKSB1dGY4LnB1c2goY2hhcmNvZGUpO1xuICAgICAgICBlbHNlIGlmIChjaGFyY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICB1dGY4LnB1c2goMHhjMCB8IChjaGFyY29kZSA+PiA2KSxcbiAgICAgICAgICAgICAgICAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKDB4ZTAgfCAoY2hhcmNvZGUgPj4gMTIpLFxuICAgICAgICAgICAgICAgIDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAvLyBVVEYtMTYgZW5jb2RlcyAweDEwMDAwLTB4MTBGRkZGIGJ5XG4gICAgICAgICAgICAvLyBzdWJ0cmFjdGluZyAweDEwMDAwIGFuZCBzcGxpdHRpbmcgdGhlXG4gICAgICAgICAgICAvLyAyMCBiaXRzIG9mIDB4MC0weEZGRkZGIGludG8gdHdvIGhhbHZlc1xuICAgICAgICAgICAgY2hhcmNvZGUgPSAweDEwMDAwICsgKCgoY2hhcmNvZGUgJiAweDNmZik8PDEwKVxuICAgICAgICAgICAgICAgICAgICAgIHwgKHN0ci5jaGFyQ29kZUF0KGkpICYgMHgzZmYpKTtcbiAgICAgICAgICAgIHV0ZjgucHVzaCgweGYwIHwgKGNoYXJjb2RlID4+MTgpLFxuICAgICAgICAgICAgICAgIDB4ODAgfCAoKGNoYXJjb2RlPj4xMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAweDgwIHwgKChjaGFyY29kZT4+NikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1dGY4O1xufVxuXG5mdW5jdGlvbiBzdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgYnl0ZXMgPSB0b1VURjhBcnJheShzdHIpO1xuICAgIHJldHVybiBbIC4uLnZhcnVpbnQzMihieXRlcy5sZW5ndGgpLCAuLi5ieXRlcyBdO1xufVxuXG5mdW5jdGlvbiB2YXJ1aW50KG4pIHtcbiAgICBjb25zdCBjb2RlID0gW107XG4gICAgbGV0IHYgPSB0b051bWJlcihuKTtcbiAgICBpZiAoaXNOZWdhdGl2ZSh2KSkgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIGNhbm5vdCBiZSBuZWdhdGl2ZVwiKTtcbiAgICB3aGlsZSAoIWlzWmVybyh2KSkge1xuICAgICAgICBjb2RlLnB1c2goTnVtYmVyKHYgJiAweDdGbikpO1xuICAgICAgICB2ID0gdiA+PiA3bjtcbiAgICB9XG4gICAgaWYgKGNvZGUubGVuZ3RoPT0wKSBjb2RlLnB1c2goMCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPGNvZGUubGVuZ3RoLTE7IGkrKykge1xuICAgICAgICBjb2RlW2ldID0gY29kZVtpXSB8IDB4ODA7XG4gICAgfVxuICAgIHJldHVybiBjb2RlO1xufVxuXG5mdW5jdGlvbiB2YXJpbnQoX24pIHtcbiAgICBsZXQgbiwgc2lnbjtcbiAgICBjb25zdCBiaXRzID0gYml0TGVuZ3RoKF9uKTtcbiAgICBpZiAoX248MCkge1xuICAgICAgICBzaWduID0gdHJ1ZTtcbiAgICAgICAgbiA9ICgxbiA8PCBCaWdJbnQoYml0cykpICsgX247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbiA9IGZhbHNlO1xuICAgICAgICBuID0gdG9OdW1iZXIoX24pO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nQml0cyA9IDcgLSAoYml0cyAlIDcpO1xuXG4gICAgY29uc3QgcGFkZGluZyA9ICgoMW4gPDwgQmlnSW50KHBhZGRpbmdCaXRzKSkgLSAxbikgPDwgQmlnSW50KGJpdHMpO1xuICAgIGNvbnN0IHBhZGRpbmdNYXNrID0gKCgxIDw8ICg3IC0gcGFkZGluZ0JpdHMpKS0xKSB8IDB4ODA7XG5cbiAgICBjb25zdCBjb2RlID0gdmFydWludChuICsgcGFkZGluZyk7XG5cbiAgICBpZiAoIXNpZ24pIHtcbiAgICAgICAgY29kZVtjb2RlLmxlbmd0aC0xXSA9IGNvZGVbY29kZS5sZW5ndGgtMV0gJiBwYWRkaW5nTWFzaztcbiAgICB9XG5cbiAgICByZXR1cm4gY29kZTtcbn1cblxuZnVuY3Rpb24gdmFyaW50MzIobikge1xuICAgIGxldCB2ID0gdG9OdW1iZXIobik7XG4gICAgaWYgKHYgPiAweEZGRkZGRkZGbikgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWdcIik7XG4gICAgaWYgKHYgPiAweDdGRkZGRkZGbikgdiA9IHYgLSAweDEwMDAwMDAwMG47XG4gICAgLy8gYmlnSW50KFwiLTgwMDAwMDAwXCIsIDE2KSBhcyBiYXNlMTBcbiAgICBpZiAodiA8IC0yMTQ3NDgzNjQ4bikgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbFwiKTtcbiAgICByZXR1cm4gdmFyaW50KHYpO1xufVxuXG5mdW5jdGlvbiB2YXJpbnQ2NChuKSB7XG4gICAgbGV0IHYgPSB0b051bWJlcihuKTtcbiAgICBpZiAodiA+IDB4RkZGRkZGRkZGRkZGRkZGRm4pIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gYmlnXCIpO1xuICAgIGlmICh2ID4gMHg3RkZGRkZGRkZGRkZGRkZGbikgdiA9IHYgLSAweDEwMDAwMDAwMDAwMDAwMDAwbjtcbiAgICAvLyBiaWdJbnQoXCItODAwMDAwMDAwMDAwMDAwMFwiLCAxNikgYXMgYmFzZTEwXG4gICAgaWYgKHYgPCAtOTIyMzM3MjAzNjg1NDc3NTgwOG4pIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gc21hbGxcIik7XG4gICAgcmV0dXJuIHZhcmludCh2KTtcbn1cblxuZnVuY3Rpb24gdmFydWludDMyKG4pIHtcbiAgICBsZXQgdiA9IHRvTnVtYmVyKG4pO1xuICAgIGlmICh2ID4gMHhGRkZGRkZGRm4pIHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gYmlnXCIpO1xuICAgIHJldHVybiB2YXJ1aW50KHYpO1xufVxuXG5mdW5jdGlvbiB0b0hleFN0cmluZyhieXRlQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShieXRlQXJyYXksIGZ1bmN0aW9uKGJ5dGUpIHtcbiAgICAgICAgcmV0dXJuIChcIjBcIiArIChieXRlICYgMHhGRikudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21idWlsZGVyXG5cbiAgICB3YXNtYnVpbGRlciBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21idWlsZGVyIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdhc21idWlsZGVyLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuXG5jbGFzcyBDb2RlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZnVuYykge1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZSA9IGZ1bmMuZnVuY3Rpb25OYW1lO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IGZ1bmMubW9kdWxlO1xuICAgIH1cblxuICAgIHNldExvY2FsKGxvY2FsTmFtZSwgdmFsQ29kZSkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZ1bmMubG9jYWxJZHhCeU5hbWVbbG9jYWxOYW1lXTtcbiAgICAgICAgaWYgKGlkeCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb2NhbCBWYXJpYWJsZSBub3QgZGVmaW5lZDogRnVuY3Rpb246ICR7dGhpcy5mdW5jdGlvbk5hbWV9IGxvY2FsOiAke2xvY2FsTmFtZX0gYCk7XG4gICAgICAgIHJldHVybiBbLi4udmFsQ29kZSwgMHgyMSwgLi4udmFydWludDMyKCBpZHggKV07XG4gICAgfVxuXG4gICAgdGVlTG9jYWwobG9jYWxOYW1lLCB2YWxDb2RlKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZnVuYy5sb2NhbElkeEJ5TmFtZVtsb2NhbE5hbWVdO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExvY2FsIFZhcmlhYmxlIG5vdCBkZWZpbmVkOiBGdW5jdGlvbjogJHt0aGlzLmZ1bmN0aW9uTmFtZX0gbG9jYWw6ICR7bG9jYWxOYW1lfSBgKTtcbiAgICAgICAgcmV0dXJuIFsuLi52YWxDb2RlLCAweDIyLCAuLi52YXJ1aW50MzIoIGlkeCApXTtcbiAgICB9XG5cbiAgICBnZXRMb2NhbChsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5mdW5jLmxvY2FsSWR4QnlOYW1lW2xvY2FsTmFtZV07XG4gICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTG9jYWwgVmFyaWFibGUgbm90IGRlZmluZWQ6IEZ1bmN0aW9uOiAke3RoaXMuZnVuY3Rpb25OYW1lfSBsb2NhbDogJHtsb2NhbE5hbWV9IGApO1xuICAgICAgICByZXR1cm4gWzB4MjAsIC4uLnZhcnVpbnQzMiggaWR4ICldO1xuICAgIH1cblxuICAgIGk2NF9sb2FkOF9zKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBfb2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGFsaWduID0gKF9hbGlnbiA9PT0gdW5kZWZpbmVkKSA/IDAgOiBfYWxpZ247ICAvLyA4IGJpdHMgYWxpZ25tZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAweDMwLCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuICAgIGk2NF9sb2FkOF91KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBfb2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGFsaWduID0gKF9hbGlnbiA9PT0gdW5kZWZpbmVkKSA/IDAgOiBfYWxpZ247ICAvLyA4IGJpdHMgYWxpZ25tZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAweDMxLCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuICAgIGk2NF9sb2FkMTZfcyhpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gX29mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBhbGlnbiA9IChfYWxpZ24gPT09IHVuZGVmaW5lZCkgPyAxIDogX2FsaWduOyAgLy8gMTYgYml0cyBhbGlnbm1lbnQgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIDB4MzIsIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG4gICAgaTY0X2xvYWQxNl91KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBfb2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGFsaWduID0gKF9hbGlnbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiBfYWxpZ247ICAvLyAxNiBiaXRzIGFsaWdubWVudCBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgMHgzMywgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cbiAgICBpNjRfbG9hZDMyX3MoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IF9vZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYWxpZ24gPSAoX2FsaWduID09PSB1bmRlZmluZWQpID8gMiA6IF9hbGlnbjsgIC8vIDMyIGJpdHMgYWxpZ25tZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAweDM0LCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuICAgIGk2NF9sb2FkMzJfdShpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gX29mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBhbGlnbiA9IChfYWxpZ24gPT09IHVuZGVmaW5lZCkgPyAyIDogX2FsaWduOyAgLy8gMzIgYml0cyBhbGlnbm1lbnQgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIDB4MzUsIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG4gICAgaTY0X2xvYWQoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IF9vZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYWxpZ24gPSAoX2FsaWduID09PSB1bmRlZmluZWQpID8gMyA6IF9hbGlnbjsgIC8vIDY0IGJpdHMgYWxpZ25tZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAweDI5LCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuXG4gICAgaTY0X3N0b3JlKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgbGV0IG9mZnNldCwgYWxpZ24sIGNvZGVWYWw7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KF9vZmZzZXQpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgYWxpZ24gPSAzO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9vZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfYWxpZ24pKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSAzO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9hbGlnbjtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9jb2RlVmFsKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gX29mZnNldDtcbiAgICAgICAgICAgIGFsaWduID0gX2FsaWduO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9jb2RlVmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgLi4uY29kZVZhbCwgMHgzNywgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cbiAgICBpNjRfc3RvcmUzMihpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24sIF9jb2RlVmFsKSB7XG4gICAgICAgIGxldCBvZmZzZXQsIGFsaWduLCBjb2RlVmFsO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShfb2Zmc2V0KSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGFsaWduID0gMjtcbiAgICAgICAgICAgIGNvZGVWYWwgPSBfb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoX2FsaWduKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gX29mZnNldDtcbiAgICAgICAgICAgIGFsaWduID0gMjtcbiAgICAgICAgICAgIGNvZGVWYWwgPSBfYWxpZ247XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfY29kZVZhbCkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IF9vZmZzZXQ7XG4gICAgICAgICAgICBhbGlnbiA9IF9hbGlnbjtcbiAgICAgICAgICAgIGNvZGVWYWwgPSBfY29kZVZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIC4uLmNvZGVWYWwsIDB4M2UsIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG5cbiAgICBpNjRfc3RvcmUxNihpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24sIF9jb2RlVmFsKSB7XG4gICAgICAgIGxldCBvZmZzZXQsIGFsaWduLCBjb2RlVmFsO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShfb2Zmc2V0KSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGFsaWduID0gMTtcbiAgICAgICAgICAgIGNvZGVWYWwgPSBfb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoX2FsaWduKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gX29mZnNldDtcbiAgICAgICAgICAgIGFsaWduID0gMTtcbiAgICAgICAgICAgIGNvZGVWYWwgPSBfYWxpZ247XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfY29kZVZhbCkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IF9vZmZzZXQ7XG4gICAgICAgICAgICBhbGlnbiA9IF9hbGlnbjtcbiAgICAgICAgICAgIGNvZGVWYWwgPSBfY29kZVZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIC4uLmNvZGVWYWwsIDB4M2QsIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG5cbiAgICBpNjRfc3RvcmU4KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgbGV0IG9mZnNldCwgYWxpZ24sIGNvZGVWYWw7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KF9vZmZzZXQpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgYWxpZ24gPSAwO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9vZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfYWxpZ24pKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSAwO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9hbGlnbjtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9jb2RlVmFsKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gX29mZnNldDtcbiAgICAgICAgICAgIGFsaWduID0gX2FsaWduO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9jb2RlVmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgLi4uY29kZVZhbCwgMHgzYywgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cbiAgICBpMzJfbG9hZDhfcyhpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gX29mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBhbGlnbiA9IChfYWxpZ24gPT09IHVuZGVmaW5lZCkgPyAwIDogX2FsaWduOyAgLy8gMzIgYml0cyBhbGlnbm1lbnQgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIDB4MmMsIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG4gICAgaTMyX2xvYWQ4X3UoaWR4Q29kZSwgX29mZnNldCwgX2FsaWduKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IF9vZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYWxpZ24gPSAoX2FsaWduID09PSB1bmRlZmluZWQpID8gMCA6IF9hbGlnbjsgIC8vIDMyIGJpdHMgYWxpZ25tZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIFsuLi5pZHhDb2RlLCAweDJkLCBhbGlnbiwgLi4udmFydWludDMyKG9mZnNldCldO1xuICAgIH1cblxuICAgIGkzMl9sb2FkMTZfcyhpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gX29mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBhbGlnbiA9IChfYWxpZ24gPT09IHVuZGVmaW5lZCkgPyAxIDogX2FsaWduOyAgLy8gMzIgYml0cyBhbGlnbm1lbnQgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIDB4MmUsIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG4gICAgaTMyX2xvYWQxNl91KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBfb2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGFsaWduID0gKF9hbGlnbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiBfYWxpZ247ICAvLyAzMiBiaXRzIGFsaWdubWVudCBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgMHgyZiwgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cbiAgICBpMzJfbG9hZChpZHhDb2RlLCBfb2Zmc2V0LCBfYWxpZ24pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gX29mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBhbGlnbiA9IChfYWxpZ24gPT09IHVuZGVmaW5lZCkgPyAyIDogX2FsaWduOyAgLy8gMzIgYml0cyBhbGlnbm1lbnQgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gWy4uLmlkeENvZGUsIDB4MjgsIGFsaWduLCAuLi52YXJ1aW50MzIob2Zmc2V0KV07XG4gICAgfVxuXG4gICAgaTMyX3N0b3JlKGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgbGV0IG9mZnNldCwgYWxpZ24sIGNvZGVWYWw7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KF9vZmZzZXQpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgYWxpZ24gPSAyO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9vZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfYWxpZ24pKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSAyO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9hbGlnbjtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9jb2RlVmFsKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gX29mZnNldDtcbiAgICAgICAgICAgIGFsaWduID0gX2FsaWduO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9jb2RlVmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgLi4uY29kZVZhbCwgMHgzNiwgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cblxuICAgIGkzMl9zdG9yZTE2KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgbGV0IG9mZnNldCwgYWxpZ24sIGNvZGVWYWw7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KF9vZmZzZXQpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgYWxpZ24gPSAxO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9vZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfYWxpZ24pKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSAxO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9hbGlnbjtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9jb2RlVmFsKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gX29mZnNldDtcbiAgICAgICAgICAgIGFsaWduID0gX2FsaWduO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9jb2RlVmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgLi4uY29kZVZhbCwgMHgzYiwgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cbiAgICBpMzJfc3RvcmU4KGlkeENvZGUsIF9vZmZzZXQsIF9hbGlnbiwgX2NvZGVWYWwpIHtcbiAgICAgICAgbGV0IG9mZnNldCwgYWxpZ24sIGNvZGVWYWw7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KF9vZmZzZXQpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgYWxpZ24gPSAwO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9vZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfYWxpZ24pKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgICAgICAgICAgYWxpZ24gPSAwO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9hbGlnbjtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9jb2RlVmFsKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gX29mZnNldDtcbiAgICAgICAgICAgIGFsaWduID0gX2FsaWduO1xuICAgICAgICAgICAgY29kZVZhbCA9IF9jb2RlVmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uaWR4Q29kZSwgLi4uY29kZVZhbCwgMHgzYSwgYWxpZ24sIC4uLnZhcnVpbnQzMihvZmZzZXQpXTtcbiAgICB9XG5cbiAgICBjYWxsKGZuTmFtZSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLm1vZHVsZS5mdW5jdGlvbklkeEJ5TmFtZVtmbk5hbWVdO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZ1bmN0aW9uIG5vdCBkZWZpbmVkOiBGdW5jdGlvbjogJHtmbk5hbWV9YCk7XG4gICAgICAgIHJldHVybiBbLi4uW10uY29uY2F0KC4uLmFyZ3MpLCAweDEwLCAuLi52YXJ1aW50MzIoaWR4KV07XG4gICAgfVxuXG4gICAgY2FsbF9pbmRpcmVjdChmbklkeCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gWy4uLltdLmNvbmNhdCguLi5hcmdzKSwgLi4uZm5JZHgsIDB4MTEsIDAsIDBdO1xuICAgIH1cblxuICAgIGlmKGNvbmRDb2RlLCB0aGVuQ29kZSwgZWxzZUNvZGUpIHtcbiAgICAgICAgaWYgKGVsc2VDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmNvbmRDb2RlLCAweDA0LCAweDQwLCAuLi50aGVuQ29kZSwgMHgwNSwgLi4uZWxzZUNvZGUsIDB4MGJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5jb25kQ29kZSwgMHgwNCwgMHg0MCwgLi4udGhlbkNvZGUsIDB4MGJdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYmxvY2soYkNvZGUpIHsgcmV0dXJuIFsweDAyLCAweDQwLCAuLi5iQ29kZSwgMHgwYl07IH1cbiAgICBsb29wKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIFsweDAzLCAweDQwLCAuLi5bXS5jb25jYXQoLi4uWy4uLmFyZ3NdKSwgMHgwYl07XG4gICAgfVxuICAgIGJyX2lmKHJlbFBhdGgsIGNvbmRDb2RlKSB7IHJldHVybiBbLi4uY29uZENvZGUsIDB4MGQsIC4uLnZhcnVpbnQzMihyZWxQYXRoKV07IH1cbiAgICBicihyZWxQYXRoKSB7IHJldHVybiBbMHgwYywgLi4udmFydWludDMyKHJlbFBhdGgpXTsgfVxuICAgIHJldChyQ29kZSkgeyByZXR1cm4gWy4uLnJDb2RlLCAweDBmXTsgfVxuICAgIGRyb3AoZENvZGUpIHsgcmV0dXJuIFsuLi5kQ29kZSwgIDB4MWFdOyB9XG5cbiAgICBpNjRfY29uc3QobnVtKSB7IHJldHVybiBbMHg0MiwgLi4udmFyaW50NjQobnVtKV07IH1cbiAgICBpMzJfY29uc3QobnVtKSB7IHJldHVybiBbMHg0MSwgLi4udmFyaW50MzIobnVtKV07IH1cblxuXG4gICAgaTY0X2VxeihvcGNvZGUpIHsgcmV0dXJuIFsuLi5vcGNvZGUsIDB4NTBdOyB9XG4gICAgaTY0X2VxKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDUxXTsgfVxuICAgIGk2NF9uZShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg1Ml07IH1cbiAgICBpNjRfbHRfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg1M107IH1cbiAgICBpNjRfbHRfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg1NF07IH1cbiAgICBpNjRfZ3RfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg1NV07IH1cbiAgICBpNjRfZ3RfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg1Nl07IH1cbiAgICBpNjRfbGVfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg1N107IH1cbiAgICBpNjRfbGVfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg1OF07IH1cbiAgICBpNjRfZ2VfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg1OV07IH1cbiAgICBpNjRfZ2VfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg1YV07IH1cbiAgICBpNjRfYWRkKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDdjXTsgfVxuICAgIGk2NF9zdWIob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4N2RdOyB9XG4gICAgaTY0X211bChvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg3ZV07IH1cbiAgICBpNjRfZGl2X3Mob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4N2ZdOyB9XG4gICAgaTY0X2Rpdl91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDgwXTsgfVxuICAgIGk2NF9yZW1fcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg4MV07IH1cbiAgICBpNjRfcmVtX3Uob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4ODJdOyB9XG4gICAgaTY0X2FuZChvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg4M107IH1cbiAgICBpNjRfb3Iob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4ODRdOyB9XG4gICAgaTY0X3hvcihvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg4NV07IH1cbiAgICBpNjRfc2hsKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDg2XTsgfVxuICAgIGk2NF9zaHJfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg4N107IH1cbiAgICBpNjRfc2hyX3Uob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4ODhdOyB9XG4gICAgaTY0X2V4dGVuZF9pMzJfcyhvcDFjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgMHhhY107IH1cbiAgICBpNjRfZXh0ZW5kX2kzMl91KG9wMWNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAweGFkXTsgfVxuICAgIGk2NF9jbHoob3AxY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIDB4NzldOyB9XG4gICAgaTY0X2N0eihvcDFjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgMHg3YV07IH1cblxuICAgIGkzMl9lcXoob3AxY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIDB4NDVdOyB9XG4gICAgaTMyX2VxKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDQ2XTsgfVxuICAgIGkzMl9uZShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg0N107IH1cbiAgICBpMzJfbHRfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg0OF07IH1cbiAgICBpMzJfbHRfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg0OV07IH1cbiAgICBpMzJfZ3RfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg0YV07IH1cbiAgICBpMzJfZ3RfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg0Yl07IH1cbiAgICBpMzJfbGVfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg0Y107IH1cbiAgICBpMzJfbGVfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg0ZF07IH1cbiAgICBpMzJfZ2VfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg0ZV07IH1cbiAgICBpMzJfZ2VfdShvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg0Zl07IH1cbiAgICBpMzJfYWRkKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDZhXTsgfVxuICAgIGkzMl9zdWIob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NmJdOyB9XG4gICAgaTMyX211bChvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg2Y107IH1cbiAgICBpMzJfZGl2X3Mob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NmRdOyB9XG4gICAgaTMyX2Rpdl91KG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDZlXTsgfVxuICAgIGkzMl9yZW1fcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg2Zl07IH1cbiAgICBpMzJfcmVtX3Uob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NzBdOyB9XG4gICAgaTMyX2FuZChvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg3MV07IH1cbiAgICBpMzJfb3Iob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NzJdOyB9XG4gICAgaTMyX3hvcihvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg3M107IH1cbiAgICBpMzJfc2hsKG9wMWNvZGUsIG9wMmNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAuLi5vcDJjb2RlLCAweDc0XTsgfVxuICAgIGkzMl9zaHJfcyhvcDFjb2RlLCBvcDJjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgLi4ub3AyY29kZSwgMHg3NV07IH1cbiAgICBpMzJfc2hyX3Uob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NzZdOyB9XG4gICAgaTMyX3JvdGwob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NzddOyB9XG4gICAgaTMyX3JvdHIob3AxY29kZSwgb3AyY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIC4uLm9wMmNvZGUsIDB4NzhdOyB9XG4gICAgaTMyX3dyYXBfaTY0KG9wMWNvZGUpIHsgcmV0dXJuIFsuLi5vcDFjb2RlLCAweGE3XTsgfVxuICAgIGkzMl9jbHoob3AxY29kZSkgeyByZXR1cm4gWy4uLm9wMWNvZGUsIDB4NjddOyB9XG4gICAgaTMyX2N0eihvcDFjb2RlKSB7IHJldHVybiBbLi4ub3AxY29kZSwgMHg2OF07IH1cblxuICAgIHVucmVhY2hhYmxlKCkgeyByZXR1cm4gWyAweDAgXTsgfVxuXG4gICAgY3VycmVudF9tZW1vcnkoKSB7IHJldHVybiBbIDB4M2YsIDBdOyB9XG5cbiAgICBjb21tZW50KCkgeyByZXR1cm4gW107IH1cbn1cblxuLypcbiAgICBDb3B5cmlnaHQgMjAxOSAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdhc21idWlsZGVyXG5cbiAgICB3YXNtYnVpbGRlciBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdhc21idWlsZGVyIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdhc21idWlsZGVyLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuXG5jb25zdCB0eXBlQ29kZXMgPSB7XG4gICAgXCJpMzJcIjogMHg3ZixcbiAgICBcImk2NFwiOiAweDdlLFxuICAgIFwiZjMyXCI6IDB4N2QsXG4gICAgXCJmNjRcIjogMHg3YyxcbiAgICBcImFueWZ1bmNcIjogMHg3MCxcbiAgICBcImZ1bmNcIjogMHg2MCxcbiAgICBcImVtcHR5YmxvY2tcIjogMHg0MFxufTtcblxuXG5jbGFzcyBGdW5jdGlvbkJ1aWxkZXIge1xuXG4gICAgY29uc3RydWN0b3IgKG1vZHVsZSwgZm5OYW1lLCBmblR5cGUsIG1vZHVsZU5hbWUsIGZpZWxkTmFtZSkge1xuICAgICAgICBpZiAoZm5UeXBlID09IFwiaW1wb3J0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm5UeXBlID0gXCJpbXBvcnRcIjtcbiAgICAgICAgICAgIHRoaXMubW9kdWxlTmFtZSA9IG1vZHVsZU5hbWU7XG4gICAgICAgICAgICB0aGlzLmZpZWxkTmFtZSA9IGZpZWxkTmFtZTtcbiAgICAgICAgfSBlbHNlIGlmIChmblR5cGUgPT0gXCJpbnRlcm5hbFwiKSB7XG4gICAgICAgICAgICB0aGlzLmZuVHlwZSA9IFwiaW50ZXJuYWxcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZnVuY3Rpb24gZm5UeXBlOiBcIiArIGZuVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHRoaXMuZm5OYW1lID0gZm5OYW1lO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICB0aGlzLmxvY2FscyA9IFtdO1xuICAgICAgICB0aGlzLmxvY2FsSWR4QnlOYW1lID0ge307XG4gICAgICAgIHRoaXMuY29kZSA9IFtdO1xuICAgICAgICB0aGlzLnJldHVyblR5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHRMb2NhbCA9MDtcbiAgICB9XG5cbiAgICBhZGRQYXJhbShwYXJhbU5hbWUsIHBhcmFtVHlwZSkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbElkeEJ5TmFtZVtwYXJhbU5hbWVdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJhbSBhbHJlYWR5IGV4aXN0cy4gRnVuY3Rpb246ICR7dGhpcy5mbk5hbWV9LCBQYXJhbTogJHtwYXJhbU5hbWV9IGApO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLm5leHRMb2NhbCsrO1xuICAgICAgICB0aGlzLmxvY2FsSWR4QnlOYW1lW3BhcmFtTmFtZV0gPSBpZHg7XG4gICAgICAgIHRoaXMucGFyYW1zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogcGFyYW1UeXBlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZExvY2FsKGxvY2FsTmFtZSwgbG9jYWxUeXBlLCBfbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IF9sZW5ndGggfHwgMTtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxJZHhCeU5hbWVbbG9jYWxOYW1lXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbG9jYWwgYWxyZWFkeSBleGlzdHMuIEZ1bmN0aW9uOiAke3RoaXMuZm5OYW1lfSwgUGFyYW06ICR7bG9jYWxOYW1lfSBgKTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5uZXh0TG9jYWwrKztcbiAgICAgICAgdGhpcy5sb2NhbElkeEJ5TmFtZVtsb2NhbE5hbWVdID0gaWR4O1xuICAgICAgICB0aGlzLmxvY2Fscy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IGxvY2FsVHlwZSxcbiAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldFJldHVyblR5cGUocmV0dXJuVHlwZSkge1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5UeXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXR1cm5UeXBlIGFscmVhZHkgZGVmaW5lZC4gRnVuY3Rpb246ICR7dGhpcy5mbk5hbWV9YCk7XG4gICAgICAgIHRoaXMucmV0dXJuVHlwZSA9IHJldHVyblR5cGU7XG4gICAgfVxuXG4gICAgZ2V0U2lnbmF0dXJlKCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBbLi4udmFydWludDMyKHRoaXMucGFyYW1zLmxlbmd0aCksIC4uLnRoaXMucGFyYW1zLm1hcCgocCkgPT4gdHlwZUNvZGVzW3AudHlwZV0pXTtcbiAgICAgICAgY29uc3QgcmV0dXJucyA9IHRoaXMucmV0dXJuVHlwZSA/IFsweDAxLCB0eXBlQ29kZXNbdGhpcy5yZXR1cm5UeXBlXV0gOiBbMF07XG4gICAgICAgIHJldHVybiBbMHg2MCwgLi4ucGFyYW1zLCAuLi5yZXR1cm5zXTtcbiAgICB9XG5cbiAgICBnZXRCb2R5KCkge1xuICAgICAgICBjb25zdCBsb2NhbHMgPSB0aGlzLmxvY2Fscy5tYXAoKGwpID0+IFtcbiAgICAgICAgICAgIC4uLnZhcnVpbnQzMihsLmxlbmd0aCksXG4gICAgICAgICAgICB0eXBlQ29kZXNbbC50eXBlXVxuICAgICAgICBdKTtcblxuICAgICAgICBjb25zdCBib2R5ID0gW1xuICAgICAgICAgICAgLi4udmFydWludDMyKHRoaXMubG9jYWxzLmxlbmd0aCksXG4gICAgICAgICAgICAuLi5bXS5jb25jYXQoLi4ubG9jYWxzKSxcbiAgICAgICAgICAgIC4uLnRoaXMuY29kZSxcbiAgICAgICAgICAgIDB4MGJcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnZhcnVpbnQzMihib2R5Lmxlbmd0aCksXG4gICAgICAgICAgICAuLi5ib2R5XG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYWRkQ29kZSguLi5jb2RlKSB7XG4gICAgICAgIHRoaXMuY29kZS5wdXNoKC4uLltdLmNvbmNhdCguLi5bLi4uY29kZV0pKTtcbiAgICB9XG5cbiAgICBnZXRDb2RlQnVpbGRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2RlQnVpbGRlcih0aGlzKTtcbiAgICB9XG59XG5cbi8qXG4gICAgQ29weXJpZ2h0IDIwMTkgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3YXNtYnVpbGRlclxuXG4gICAgd2FzbWJ1aWxkZXIgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3YXNtYnVpbGRlciBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3YXNtYnVpbGRlci4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuY2xhc3MgTW9kdWxlQnVpbGRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbklkeEJ5TmFtZSA9IHt9O1xuICAgICAgICB0aGlzLm5JbXBvcnRGdW5jdGlvbnMgPSAwO1xuICAgICAgICB0aGlzLm5JbnRlcm5hbEZ1bmN0aW9ucyA9MDtcbiAgICAgICAgdGhpcy5tZW1vcnkgPSB7XG4gICAgICAgICAgICBwYWdlc1NpemU6IDEsXG4gICAgICAgICAgICBtb2R1bGVOYW1lOiBcImVudlwiLFxuICAgICAgICAgICAgZmllbGROYW1lOiBcIm1lbW9yeVwiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnJlZSA9IDg7XG4gICAgICAgIHRoaXMuZGF0YXMgPSBbXTtcbiAgICAgICAgdGhpcy5tb2R1bGVzID0ge307XG4gICAgICAgIHRoaXMuZXhwb3J0cyA9IFtdO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uc1RhYmxlID0gW107XG4gICAgfVxuXG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHRoaXMuX3NldFNpZ25hdHVyZXMoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIC4uLnUzMigweDZkNzM2MTAwKSxcbiAgICAgICAgICAgIC4uLnUzMigxKSxcbiAgICAgICAgICAgIC4uLnRoaXMuX2J1aWxkVHlwZSgpLFxuICAgICAgICAgICAgLi4udGhpcy5fYnVpbGRJbXBvcnQoKSxcbiAgICAgICAgICAgIC4uLnRoaXMuX2J1aWxkRnVuY3Rpb25EZWNsYXJhdGlvbnMoKSxcbiAgICAgICAgICAgIC4uLnRoaXMuX2J1aWxkRnVuY3Rpb25zVGFibGUoKSxcbiAgICAgICAgICAgIC4uLnRoaXMuX2J1aWxkRXhwb3J0cygpLFxuICAgICAgICAgICAgLi4udGhpcy5fYnVpbGRFbGVtZW50cygpLFxuICAgICAgICAgICAgLi4udGhpcy5fYnVpbGRDb2RlKCksXG4gICAgICAgICAgICAuLi50aGlzLl9idWlsZERhdGEoKVxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBhZGRGdW5jdGlvbihmbk5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZih0aGlzLmZ1bmN0aW9uSWR4QnlOYW1lW2ZuTmFtZV0pICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGdW5jdGlvbiBhbHJlYWR5IGRlZmluZWQ6ICR7Zm5OYW1lfWApO1xuXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZnVuY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgdGhpcy5mdW5jdGlvbklkeEJ5TmFtZVtmbk5hbWVdID0gaWR4O1xuXG4gICAgICAgIHRoaXMuZnVuY3Rpb25zLnB1c2gobmV3IEZ1bmN0aW9uQnVpbGRlcih0aGlzLCBmbk5hbWUsIFwiaW50ZXJuYWxcIikpO1xuXG4gICAgICAgIHRoaXMubkludGVybmFsRnVuY3Rpb25zKys7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uc1tpZHhdO1xuICAgIH1cblxuICAgIGFkZElpbXBvcnRGdW5jdGlvbihmbk5hbWUsIG1vZHVsZU5hbWUsIF9maWVsZE5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZih0aGlzLmZ1bmN0aW9uSWR4QnlOYW1lW2ZuTmFtZV0pICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGdW5jdGlvbiBhbHJlYWR5IGRlZmluZWQ6ICR7Zm5OYW1lfWApO1xuXG4gICAgICAgIGlmICggICh0aGlzLmZ1bmN0aW9ucy5sZW5ndGg+MClcbiAgICAgICAgICAgICYmKHRoaXMuZnVuY3Rpb25zW3RoaXMuZnVuY3Rpb25zLmxlbmd0aC0xXS50eXBlID09IFwiaW50ZXJuYWxcIikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltcG9ydCBmdW5jdGlvbnMgbXVzdCBiZSBkZWNsYXJlZCBiZWZvcmUgaW50ZXJuYWw6ICR7Zm5OYW1lfWApO1xuXG4gICAgICAgIGxldCBmaWVsZE5hbWUgPSBfZmllbGROYW1lIHx8IGZuTmFtZTtcblxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZ1bmN0aW9ucy5sZW5ndGg7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25JZHhCeU5hbWVbZm5OYW1lXSA9IGlkeDtcblxuICAgICAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKG5ldyBGdW5jdGlvbkJ1aWxkZXIodGhpcywgZm5OYW1lLCBcImltcG9ydFwiLCBtb2R1bGVOYW1lLCBmaWVsZE5hbWUpKTtcblxuICAgICAgICB0aGlzLm5JbXBvcnRGdW5jdGlvbnMgKys7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uc1tpZHhdO1xuICAgIH1cblxuICAgIHNldE1lbW9yeShwYWdlc1NpemUsIG1vZHVsZU5hbWUsIGZpZWxkTmFtZSkge1xuICAgICAgICB0aGlzLm1lbW9yeSA9IHtcbiAgICAgICAgICAgIHBhZ2VzU2l6ZTogcGFnZXNTaXplLFxuICAgICAgICAgICAgbW9kdWxlTmFtZTogbW9kdWxlTmFtZSB8fCBcImVudlwiLFxuICAgICAgICAgICAgZmllbGROYW1lOiBmaWVsZE5hbWUgfHwgXCJtZW1vcnlcIlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGV4cG9ydEZ1bmN0aW9uKGZuTmFtZSwgX2V4cG9ydE5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhwb3J0TmFtZSA9IF9leHBvcnROYW1lIHx8IGZuTmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZih0aGlzLmZ1bmN0aW9uSWR4QnlOYW1lW2ZuTmFtZV0pID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGdW5jdGlvbiBub3QgZGVmaW5lZDogJHtmbk5hbWV9YCk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZnVuY3Rpb25JZHhCeU5hbWVbZm5OYW1lXTtcbiAgICAgICAgaWYgKGV4cG9ydE5hbWUgIT0gZm5OYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9uSWR4QnlOYW1lW2V4cG9ydE5hbWVdID0gaWR4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwb3J0cy5wdXNoKHtcbiAgICAgICAgICAgIGV4cG9ydE5hbWU6IGV4cG9ydE5hbWUsXG4gICAgICAgICAgICBpZHg6IGlkeFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRGdW5jdGlvblRvVGFibGUoZm5OYW1lKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZnVuY3Rpb25JZHhCeU5hbWVbZm5OYW1lXTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbnNUYWJsZS5wdXNoKGlkeCk7XG4gICAgfVxuXG4gICAgYWRkRGF0YShvZmZzZXQsIGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuZGF0YXMucHVzaCh7XG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgIGJ5dGVzOiBieXRlc1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhbGxvYyhhLCBiKSB7XG4gICAgICAgIGxldCBzaXplO1xuICAgICAgICBsZXQgYnl0ZXM7XG4gICAgICAgIGlmICgoQXJyYXkuaXNBcnJheShhKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYSkpICYmICh0eXBlb2YoYikgPT09IFwidW5kZWZpbmVkXCIpKSB7XG4gICAgICAgICAgICBzaXplID0gYS5sZW5ndGg7XG4gICAgICAgICAgICBieXRlcyA9IGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gYTtcbiAgICAgICAgICAgIGJ5dGVzID0gYjtcbiAgICAgICAgfVxuICAgICAgICBzaXplID0gKCgoc2l6ZS0xKT4+MykgKzEpPDwzOyAgICAgICAvLyBBbGlnbiB0byA2NCBiaXRzLlxuICAgICAgICBjb25zdCBwID0gdGhpcy5mcmVlO1xuICAgICAgICB0aGlzLmZyZWUgKz0gc2l6ZTtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEocCwgYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGFsbG9jU3RyaW5nKHMpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBnbG9iYWxUaGlzLlRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IHVpbnQ4YXJyYXkgPSBlbmNvZGVyLmVuY29kZShzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsb2MoWy4uLnVpbnQ4YXJyYXksIDBdKTtcbiAgICB9XG5cbiAgICBfc2V0U2lnbmF0dXJlcygpIHtcbiAgICAgICAgdGhpcy5zaWduYXR1cmVzID0gW107XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZUlkeEJ5TmFtZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5mdW5jdGlvbnNUYWJsZS5sZW5ndGg+MCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5mdW5jdGlvbnNbdGhpcy5mdW5jdGlvbnNUYWJsZVswXV0uZ2V0U2lnbmF0dXJlKCk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmVOYW1lID0gXCJzX1wiK3RvSGV4U3RyaW5nKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICBzaWduYXR1cmVJZHhCeU5hbWVbc2lnbmF0dXJlTmFtZV0gPSAwO1xuICAgICAgICAgICAgdGhpcy5zaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5mdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZnVuY3Rpb25zW2ldLmdldFNpZ25hdHVyZSgpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlTmFtZSA9IFwic19cIit0b0hleFN0cmluZyhzaWduYXR1cmUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihzaWduYXR1cmVJZHhCeU5hbWVbc2lnbmF0dXJlTmFtZV0pID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlSWR4QnlOYW1lW3NpZ25hdHVyZU5hbWVdID0gdGhpcy5zaWduYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9uc1tpXS5zaWduYXR1cmVJZHggPSBzaWduYXR1cmVJZHhCeU5hbWVbc2lnbmF0dXJlTmFtZV07XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIF9idWlsZFNlY3Rpb24oc2VjdGlvblR5cGUsIHNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFtzZWN0aW9uVHlwZSwgLi4udmFydWludDMyKHNlY3Rpb24ubGVuZ3RoKSwgLi4uc2VjdGlvbl07XG4gICAgfVxuXG4gICAgX2J1aWxkVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkU2VjdGlvbihcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLi4udmFydWludDMyKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIC4uLltdLmNvbmNhdCguLi50aGlzLnNpZ25hdHVyZXMpXG4gICAgICAgICAgICBdXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgX2J1aWxkSW1wb3J0KCkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgICAgIGVudHJpZXMucHVzaChbXG4gICAgICAgICAgICAuLi5zdHJpbmcodGhpcy5tZW1vcnkubW9kdWxlTmFtZSksXG4gICAgICAgICAgICAuLi5zdHJpbmcodGhpcy5tZW1vcnkuZmllbGROYW1lKSxcbiAgICAgICAgICAgIDB4MDIsXG4gICAgICAgICAgICAweDAwLCAgIC8vRmxhZ3Mgbm8gaW5pdCB2YWx1YVxuICAgICAgICAgICAgLi4udmFydWludDMyKHRoaXMubWVtb3J5LnBhZ2VzU2l6ZSlcbiAgICAgICAgXSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgdGhpcy5uSW1wb3J0RnVuY3Rpb25zOyBpKyspIHtcbiAgICAgICAgICAgIGVudHJpZXMucHVzaChbXG4gICAgICAgICAgICAgICAgLi4uc3RyaW5nKHRoaXMuZnVuY3Rpb25zW2ldLm1vZHVsZU5hbWUpLFxuICAgICAgICAgICAgICAgIC4uLnN0cmluZyh0aGlzLmZ1bmN0aW9uc1tpXS5maWVsZE5hbWUpLFxuICAgICAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAgICAgLi4udmFydWludDMyKHRoaXMuZnVuY3Rpb25zW2ldLnNpZ25hdHVyZUlkeClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9idWlsZFNlY3Rpb24oXG4gICAgICAgICAgICAweDAyLFxuICAgICAgICAgICAgdmFydWludDMyKGVudHJpZXMubGVuZ3RoKS5jb25jYXQoLi4uZW50cmllcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBfYnVpbGRGdW5jdGlvbkRlY2xhcmF0aW9ucygpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPXRoaXMubkltcG9ydEZ1bmN0aW9uczsgaTwgdGhpcy5uSW1wb3J0RnVuY3Rpb25zICsgdGhpcy5uSW50ZXJuYWxGdW5jdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKC4uLnZhcnVpbnQzMih0aGlzLmZ1bmN0aW9uc1tpXS5zaWduYXR1cmVJZHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRTZWN0aW9uKFxuICAgICAgICAgICAgMHgwMyxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAuLi52YXJ1aW50MzIoZW50cmllcy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIC4uLlsuLi5lbnRyaWVzXVxuICAgICAgICAgICAgXVxuICAgICAgICApO1xuICAgIH1cblxuICAgIF9idWlsZEZ1bmN0aW9uc1RhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5mdW5jdGlvbnNUYWJsZS5sZW5ndGggPT0gMCkgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRTZWN0aW9uKFxuICAgICAgICAgICAgMHgwNCxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAuLi52YXJ1aW50MzIoMSksXG4gICAgICAgICAgICAgICAgMHg3MCwgMCwgLi4udmFydWludDMyKHRoaXMuZnVuY3Rpb25zVGFibGUubGVuZ3RoKVxuICAgICAgICAgICAgXVxuICAgICAgICApO1xuICAgIH1cblxuICAgIF9idWlsZEVsZW1lbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5mdW5jdGlvbnNUYWJsZS5sZW5ndGggPT0gMCkgcmV0dXJuIFtdO1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLmZ1bmN0aW9uc1RhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goLi4udmFydWludDMyKHRoaXMuZnVuY3Rpb25zVGFibGVbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRTZWN0aW9uKFxuICAgICAgICAgICAgMHgwOSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAuLi52YXJ1aW50MzIoMSksICAgICAgLy8gMSBlbnRyeVxuICAgICAgICAgICAgICAgIC4uLnZhcnVpbnQzMigwKSwgICAgICAvLyBUYWJsZSAoMCBpbiBNVlApXG4gICAgICAgICAgICAgICAgMHg0MSwgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldCAwXG4gICAgICAgICAgICAgICAgLi4udmFyaW50MzIoMCksXG4gICAgICAgICAgICAgICAgMHgwYixcbiAgICAgICAgICAgICAgICAuLi52YXJ1aW50MzIodGhpcy5mdW5jdGlvbnNUYWJsZS5sZW5ndGgpLCAvLyBOdW1iZXIgb2YgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAuLi5bLi4uZW50cmllc11cbiAgICAgICAgICAgIF1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBfYnVpbGRFeHBvcnRzKCkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgdGhpcy5leHBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW1xuICAgICAgICAgICAgICAgIC4uLnN0cmluZyh0aGlzLmV4cG9ydHNbaV0uZXhwb3J0TmFtZSksXG4gICAgICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgICAgICAuLi52YXJ1aW50MzIodGhpcy5leHBvcnRzW2ldLmlkeClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9idWlsZFNlY3Rpb24oXG4gICAgICAgICAgICAweDA3LFxuICAgICAgICAgICAgdmFydWludDMyKGVudHJpZXMubGVuZ3RoKS5jb25jYXQoLi4uZW50cmllcylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBfYnVpbGRDb2RlKCkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9dGhpcy5uSW1wb3J0RnVuY3Rpb25zOyBpPCB0aGlzLm5JbXBvcnRGdW5jdGlvbnMgKyB0aGlzLm5JbnRlcm5hbEZ1bmN0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2godGhpcy5mdW5jdGlvbnNbaV0uZ2V0Qm9keSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRTZWN0aW9uKFxuICAgICAgICAgICAgMHgwYSxcbiAgICAgICAgICAgIHZhcnVpbnQzMihlbnRyaWVzLmxlbmd0aCkuY29uY2F0KC4uLmVudHJpZXMpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgX2J1aWxkRGF0YSgpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICBlbnRyaWVzLnB1c2goW1xuICAgICAgICAgICAgMHgwMCxcbiAgICAgICAgICAgIDB4NDEsXG4gICAgICAgICAgICAweDAwLFxuICAgICAgICAgICAgMHgwYixcbiAgICAgICAgICAgIDB4MDQsXG4gICAgICAgICAgICAuLi51MzIodGhpcy5mcmVlKVxuICAgICAgICBdKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPCB0aGlzLmRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW1xuICAgICAgICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgICAgICAgMHg0MSxcbiAgICAgICAgICAgICAgICAuLi52YXJpbnQzMih0aGlzLmRhdGFzW2ldLm9mZnNldCksXG4gICAgICAgICAgICAgICAgMHgwYixcbiAgICAgICAgICAgICAgICAuLi52YXJ1aW50MzIodGhpcy5kYXRhc1tpXS5ieXRlcy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZGF0YXNbaV0uYnl0ZXMsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRTZWN0aW9uKFxuICAgICAgICAgICAgMHgwYixcbiAgICAgICAgICAgIHZhcnVpbnQzMihlbnRyaWVzLmxlbmd0aCkuY29uY2F0KC4uLmVudHJpZXMpXG4gICAgICAgICk7XG4gICAgfVxuXG59XG5cbmdsb2JhbFRoaXMuY3VydmVfYm4xMjggPSBudWxsO1xuXG5hc3luYyBmdW5jdGlvbiBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGlmICgoIXNpbmdsZVRocmVhZCkgJiYgKGdsb2JhbFRoaXMuY3VydmVfYm4xMjgpKSByZXR1cm4gZ2xvYmFsVGhpcy5jdXJ2ZV9ibjEyODtcblxuICAgIGNvbnN0IG1vZHVsZUJ1aWxkZXIgPSBuZXcgTW9kdWxlQnVpbGRlcigpO1xuICAgIG1vZHVsZUJ1aWxkZXIuc2V0TWVtb3J5KDI1KTtcbiAgICBidWlsZEJuMTI4JDEobW9kdWxlQnVpbGRlcik7XG5cbiAgICBpZiAocGx1Z2lucykgcGx1Z2lucyhtb2R1bGVCdWlsZGVyKTtcblxuICAgIGNvbnN0IGJuMTI4d2FzbSA9IHt9O1xuXG4gICAgYm4xMjh3YXNtLmNvZGUgPSBtb2R1bGVCdWlsZGVyLmJ1aWxkKCk7XG4gICAgYm4xMjh3YXNtLnBxID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmYxbS5wcTtcbiAgICBibjEyOHdhc20ucHIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuZnJtLnBxO1xuICAgIGJuMTI4d2FzbS5wRzFnZW4gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucEcxZ2VuO1xuICAgIGJuMTI4d2FzbS5wRzF6ZXJvID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnBHMXplcm87XG4gICAgYm4xMjh3YXNtLnBHMWIgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucEcxYjtcbiAgICBibjEyOHdhc20ucEcyZ2VuID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnBHMmdlbjtcbiAgICBibjEyOHdhc20ucEcyemVybyA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5wRzJ6ZXJvO1xuICAgIGJuMTI4d2FzbS5wRzJiID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnBHMmI7XG4gICAgYm4xMjh3YXNtLnBPbmVUID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnBPbmVUO1xuICAgIGJuMTI4d2FzbS5wcmVQU2l6ZSA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5wcmVQU2l6ZTtcbiAgICBibjEyOHdhc20ucHJlUVNpemUgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYm4xMjgucHJlUVNpemU7XG4gICAgYm4xMjh3YXNtLm44cSA9IDMyO1xuICAgIGJuMTI4d2FzbS5uOHIgPSAzMjtcbiAgICBibjEyOHdhc20ucSA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibjEyOC5xO1xuICAgIGJuMTI4d2FzbS5yID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJuMTI4LnI7XG5cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIG5hbWU6IFwiYm4xMjhcIixcbiAgICAgICAgd2FzbTogYm4xMjh3YXNtLFxuICAgICAgICBxOiBlKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg2OTYzMTExNTcyOTc4MjM2NjI2ODkwMzc4OTQ2NDUyMjYyMDg1ODNcIiksXG4gICAgICAgIHI6IGUoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODU0ODM2NDQwMDQxNjAzNDM0MzY5ODIwNDE4NjU3NTgwODQ5NTYxN1wiKSxcbiAgICAgICAgbjhxOiAzMixcbiAgICAgICAgbjhyOiAzMixcbiAgICAgICAgY29mYWN0b3JHMjogZShcIjMwNjQ0ZTcyZTEzMWEwMjliODUwNDViNjgxODE1ODVlMDZjZWVjZGE1NzJhMjQ4OTM0NWYyMjk5YzBmOWZhOGRcIiwgMTYpLFxuICAgICAgICBzaW5nbGVUaHJlYWQ6IHNpbmdsZVRocmVhZCA/IHRydWUgOiBmYWxzZVxuICAgIH07XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGJ1aWxkRW5naW5lKHBhcmFtcyk7XG4gICAgY3VydmUudGVybWluYXRlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXBhcmFtcy5zaW5nbGVUaHJlYWQpIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuY3VydmVfYm4xMjggPSBudWxsO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50bS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIXNpbmdsZVRocmVhZCkge1xuICAgICAgICBnbG9iYWxUaGlzLmN1cnZlX2JuMTI4ID0gY3VydmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnZlO1xufVxuXG5nbG9iYWxUaGlzLmN1cnZlX2JsczEyMzgxID0gbnVsbDtcblxuYXN5bmMgZnVuY3Rpb24gYnVpbGRCbHMxMjM4MShzaW5nbGVUaHJlYWQsIHBsdWdpbnMpIHtcbiAgICBpZiAoKCFzaW5nbGVUaHJlYWQpICYmIChnbG9iYWxUaGlzLmN1cnZlX2JsczEyMzgxKSkgcmV0dXJuIGdsb2JhbFRoaXMuY3VydmVfYmxzMTIzODE7XG5cbiAgICBjb25zdCBtb2R1bGVCdWlsZGVyID0gbmV3IE1vZHVsZUJ1aWxkZXIoKTtcbiAgICBtb2R1bGVCdWlsZGVyLnNldE1lbW9yeSgyNSk7XG4gICAgYnVpbGRCbHMxMjM4MSQxKG1vZHVsZUJ1aWxkZXIpO1xuXG4gICAgaWYgKHBsdWdpbnMpIHBsdWdpbnMobW9kdWxlQnVpbGRlcik7XG5cbiAgICBjb25zdCBibHMxMjM4MXdhc20gPSB7fTtcblxuICAgIGJsczEyMzgxd2FzbS5jb2RlID0gbW9kdWxlQnVpbGRlci5idWlsZCgpO1xuICAgIGJsczEyMzgxd2FzbS5wcSA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5mMW0ucHE7XG4gICAgYmxzMTIzODF3YXNtLnByID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmZybS5wcTtcbiAgICBibHMxMjM4MXdhc20ucEcxZ2VuID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnBHMWdlbjtcbiAgICBibHMxMjM4MXdhc20ucEcxemVybyA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wRzF6ZXJvO1xuICAgIGJsczEyMzgxd2FzbS5wRzFiID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnBHMWI7XG4gICAgYmxzMTIzODF3YXNtLnBHMmdlbiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wRzJnZW47XG4gICAgYmxzMTIzODF3YXNtLnBHMnplcm8gPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucEcyemVybztcbiAgICBibHMxMjM4MXdhc20ucEcyYiA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wRzJiO1xuICAgIGJsczEyMzgxd2FzbS5wT25lVCA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5wT25lVDtcbiAgICBibHMxMjM4MXdhc20ucHJlUFNpemUgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucHJlUFNpemU7XG4gICAgYmxzMTIzODF3YXNtLnByZVFTaXplID0gbW9kdWxlQnVpbGRlci5tb2R1bGVzLmJsczEyMzgxLnByZVFTaXplO1xuICAgIGJsczEyMzgxd2FzbS5uOHEgPSA0ODtcbiAgICBibHMxMjM4MXdhc20ubjhyID0gMzI7XG4gICAgYmxzMTIzODF3YXNtLnEgPSBtb2R1bGVCdWlsZGVyLm1vZHVsZXMuYmxzMTIzODEucTtcbiAgICBibHMxMjM4MXdhc20uciA9IG1vZHVsZUJ1aWxkZXIubW9kdWxlcy5ibHMxMjM4MS5yO1xuXG5cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIG5hbWU6IFwiYmxzMTIzODFcIixcbiAgICAgICAgd2FzbTogYmxzMTIzODF3YXNtLFxuICAgICAgICBxOiBlKFwiMWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiXCIsIDE2KSxcbiAgICAgICAgcjogZShcIjczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDFcIiwgMTYpLFxuICAgICAgICBuOHE6IDQ4LFxuICAgICAgICBuOHI6IDMyLFxuICAgICAgICBjb2ZhY3RvckcxOiBlKFwiMHgzOTZjOGMwMDU1NTVlMTU2OGMwMGFhYWIwMDAwYWFhYlwiLCAxNiksXG4gICAgICAgIGNvZmFjdG9yRzI6IGUoXCIweDVkNTQzYTk1NDE0ZTdmMTA5MWQ1MDc5Mjg3NmEyMDJjZDkxZGU0NTQ3MDg1YWJhYTY4YTIwNWIyZTVhN2RkZmE2MjhmMWNiNGQ5ZTgyZWYyMTUzN2UyOTNhNjY5MWFlMTYxNmVjNmU3ODZmMGM3MGNmMWMzOGUzMWM3MjM4ZTVcIiwgMTYpLFxuICAgICAgICBzaW5nbGVUaHJlYWQ6IHNpbmdsZVRocmVhZCA/IHRydWUgOiBmYWxzZVxuICAgIH07XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGJ1aWxkRW5naW5lKHBhcmFtcyk7XG4gICAgY3VydmUudGVybWluYXRlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXBhcmFtcy5zaW5nbGVUaHJlYWQpIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuY3VydmVfYmxzMTIzODEgPSBudWxsO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50bS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIXNpbmdsZVRocmVhZCkge1xuICAgICAgICBnbG9iYWxUaGlzLmN1cnZlX2JsczEyMzgxID0gY3VydmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnZlO1xufVxuXG5jb25zdCBibHMxMjM4MXIgPSBlKFwiNzNlZGE3NTMyOTlkN2Q0ODMzMzlkODA4MDlhMWQ4MDU1M2JkYTQwMmZmZmU1YmZlZmZmZmZmZmYwMDAwMDAwMVwiLCAxNik7XG5jb25zdCBibjEyOHIgPSBlKFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIik7XG5cbmNvbnN0IGJsczEyMzgxcSA9IGUoXCIxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJcIiwgMTYpO1xuY29uc3QgYm4xMjhxID0gZShcIjIxODg4MjQyODcxODM5Mjc1MjIyMjQ2NDA1NzQ1MjU3Mjc1MDg4Njk2MzExMTU3Mjk3ODIzNjYyNjg5MDM3ODk0NjQ1MjI2MjA4NTgzXCIpO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRDdXJ2ZUZyb21SKHIsIHNpbmdsZVRocmVhZCwgcGx1Z2lucykge1xuICAgIGxldCBjdXJ2ZTtcbiAgICBpZiAoZXEociwgYm4xMjhyKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQm4xMjgoc2luZ2xlVGhyZWFkLCBwbHVnaW5zKTtcbiAgICB9IGVsc2UgaWYgKGVxKHIsIGJsczEyMzgxcikpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCwgcGx1Z2lucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke3RvU3RyaW5nKHIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEN1cnZlRnJvbVEocSwgc2luZ2xlVGhyZWFkLCBwbHVnaW5zKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIGlmIChlcShxLCBibjEyOHEpKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbjEyOChzaW5nbGVUaHJlYWQsIHBsdWdpbnMpO1xuICAgIH0gZWxzZSBpZiAoZXEocSwgYmxzMTIzODFxKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQmxzMTIzODEoc2luZ2xlVGhyZWFkLCBwbHVnaW5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN1cnZlIG5vdCBzdXBwb3J0ZWQ6ICR7dG9TdHJpbmcocSwgMTYpfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEN1cnZlRnJvbU5hbWUobmFtZSwgc2luZ2xlVGhyZWFkLCBwbHVnaW5zKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIGNvbnN0IG5vcm1OYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICBpZiAoW1wiQk4xMjhcIiwgXCJCTjI1NFwiLCBcIkFMVEJOMTI4XCJdLmluZGV4T2Yobm9ybU5hbWUpID49IDApIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCwgcGx1Z2lucyk7XG4gICAgfSBlbHNlIGlmIChbXCJCTFMxMjM4MVwiXS5pbmRleE9mKG5vcm1OYW1lKSA+PSAwKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbHMxMjM4MShzaW5nbGVUaHJlYWQsIHBsdWdpbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3VydmUgbm90IHN1cHBvcnRlZDogJHtuYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG4pIHtcbiAgICAgICAgcmV0dXJuIG4udG9VcHBlckNhc2UoKS5tYXRjaCgvW0EtWmEtejAtOV0rL2cpLmpvaW4oXCJcIik7XG4gICAgfVxuXG59XG5cbmNvbnN0IFNjYWxhcj1fU2NhbGFyO1xuY29uc3QgdXRpbHMgPSBfdXRpbHM7XG5cbmV4cG9ydCB7IEJpZ0J1ZmZlciwgQ2hhQ2hhLCBFQywgWnFGaWVsZCBhcyBGMUZpZWxkLCBGMkZpZWxkLCBGM0ZpZWxkLCBQb2xGaWVsZCwgU2NhbGFyLCBacUZpZWxkLCBidWlsZEJsczEyMzgxLCBidWlsZEJuMTI4LCBnZXRDdXJ2ZUZyb21OYW1lLCBnZXRDdXJ2ZUZyb21RLCBnZXRDdXJ2ZUZyb21SLCB1dGlscyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/snarkjs/node_modules/ffjavascript/build/browser.esm.js\n"));

/***/ })

}]);