"use strict";exports.id=39,exports.ids=[39],exports.modules={288:a=>{a.exports={rE:"3.1.10"}},551:(a,b)=>{var c=/[|\\{}()[\]^$+*?.]/g,d=Object.prototype.hasOwnProperty,e=function(a,b){return d.apply(a,[b])};b.escapeRegExpChars=function(a){return a?String(a).replace(c,"\\$&"):""};var f={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},g=/[&<>'"]/g;function h(a){return f[a]||a}function i(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'}b.escapeXML=function(a){return void 0==a?"":String(a).replace(g,h)};try{"function"==typeof Object.defineProperty?Object.defineProperty(b.escapeXML,"toString",{value:i}):b.escapeXML.toString=i}catch(a){console.warn("Unable to set escapeXML.toString (is the Function prototype frozen?)")}b.shallowCopy=function(a,b){if(b=b||{},null!=a)for(var c in b)e(b,c)&&"__proto__"!==c&&"constructor"!==c&&(a[c]=b[c]);return a},b.shallowCopyFromList=function(a,b,c){if(c=c||[],b=b||{},null!=a)for(var d=0;d<c.length;d++){var f=c[d];if(void 0!==b[f]){if(!e(b,f)||"__proto__"===f||"constructor"===f)continue;a[f]=b[f]}}return a},b.cache={_data:{},set:function(a,b){this._data[a]=b},get:function(a){return this._data[a]},remove:function(a){delete this._data[a]},reset:function(){this._data={}}},b.hyphenToCamel=function(a){return a.replace(/-[a-z]/g,function(a){return a[1].toUpperCase()})},b.createNullProtoObjWherePossible="function"==typeof Object.create?function(){return Object.create(null)}:function(){return{}},b.hasOwnOnlyObject=function(a){var c=b.createNullProtoObjWherePossible();for(var d in a)e(a,d)&&(c[d]=a[d]);return c}},966:(a,b,c)=>{var d=c(9021),e=c(3873),f=c(551),g=!1,h=c(288).rE,i="locals",j=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],k=j.concat("cache"),l=/^\uFEFF/,m=/^[a-zA-Z_$][0-9a-zA-Z_$]*$/;function n(a,c){var e;if(c.some(function(c){return e=b.resolveInclude(a,c,!0),d.existsSync(e)}))return e}function o(a,c){var d,e=a.filename,f=arguments.length>1;if(a.cache){if(!e)throw Error("cache option requires a filename");if(d=b.cache.get(e))return d;f||(c=p(e).toString().replace(l,""))}else if(!f){if(!e)throw Error("Internal EJS error: no file name or template provided");c=p(e).toString().replace(l,"")}return d=b.compile(c,a),a.cache&&b.cache.set(e,d),d}function p(a){return b.fileLoader(a)}function q(a,b,c,d,e){var f=b.split("\n"),g=Math.max(d-3,0),h=Math.min(f.length,d+3),i=e(c),j=f.slice(g,h).map(function(a,b){var c=b+g+1;return(c==d?" >> ":"    ")+c+"| "+a}).join("\n");throw a.path=i,a.message=(i||"ejs")+":"+d+"\n"+j+"\n\n"+a.message,a}function r(a){return a.replace(/;(\s*$)/,"$1")}function s(a,c){var d=f.hasOwnOnlyObject(c),e=f.createNullProtoObjWherePossible();this.templateText=a,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",e.client=d.client||!1,e.escapeFunction=d.escape||d.escapeFunction||f.escapeXML,e.compileDebug=!1!==d.compileDebug,e.debug=!!d.debug,e.filename=d.filename,e.openDelimiter=d.openDelimiter||b.openDelimiter||"<",e.closeDelimiter=d.closeDelimiter||b.closeDelimiter||">",e.delimiter=d.delimiter||b.delimiter||"%",e.strict=d.strict||!1,e.context=d.context,e.cache=d.cache||!1,e.rmWhitespace=d.rmWhitespace,e.root=d.root,e.includer=d.includer,e.outputFunctionName=d.outputFunctionName,e.localsName=d.localsName||b.localsName||i,e.views=d.views,e.async=d.async,e.destructuredLocals=d.destructuredLocals,e.legacyInclude=void 0===d.legacyInclude||!!d.legacyInclude,e.strict?e._with=!1:e._with=void 0===d._with||d._with,this.opts=e,this.regex=this.createRegex()}b.cache=f.cache,b.fileLoader=d.readFileSync,b.localsName=i,b.promiseImpl=Function("return this;")().Promise,b.resolveInclude=function(a,b,c){var d=e.dirname,f=e.extname,g=(0,e.resolve)(c?b:d(b),a);return f(a)||(g+=".ejs"),g},b.compile=function(a,b){return b&&b.scope&&(g||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),g=!0),b.context||(b.context=b.scope),delete b.scope),new s(a,b).compile()},b.render=function(a,b,c){var d=b||f.createNullProtoObjWherePossible(),e=c||f.createNullProtoObjWherePossible();return 2==arguments.length&&f.shallowCopyFromList(e,d,j),o(e,a)(d)},b.renderFile=function(){var a,c,d,e,g=Array.prototype.slice.call(arguments),h=g.shift(),i={filename:h};"function"==typeof arguments[arguments.length-1]&&(c=g.pop()),g.length?(d=g.shift(),g.length?f.shallowCopy(i,g.pop()):(d.settings&&(d.settings.views&&(i.views=d.settings.views),d.settings["view cache"]&&(i.cache=!0),(e=d.settings["view options"])&&f.shallowCopy(i,e)),f.shallowCopyFromList(i,d,k)),i.filename=h):d=f.createNullProtoObjWherePossible();var j=d,l=c;if(l){try{a=o(i)(j)}catch(a){return l(a)}l(null,a)}else if("function"==typeof b.promiseImpl)return new b.promiseImpl(function(b,c){try{a=o(i)(j),b(a)}catch(a){c(a)}});else throw Error("Please provide a callback function")},b.Template=s,b.clearCache=function(){b.cache.reset()},s.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},s.prototype={createRegex:function(){var a="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",b=f.escapeRegExpChars(this.opts.delimiter),c=f.escapeRegExpChars(this.opts.openDelimiter),d=f.escapeRegExpChars(this.opts.closeDelimiter);return new RegExp(a=a.replace(/%/g,b).replace(/</g,c).replace(/>/g,d))},compile:function(){var a,c,g,h=this.opts,i="",j="",k=h.escapeFunction,l=h.filename?JSON.stringify(h.filename):"undefined";if(!this.source){if(this.generateSource(),i+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',h.outputFunctionName){if(!m.test(h.outputFunctionName))throw Error("outputFunctionName is not a valid JS identifier.");i+="  var "+h.outputFunctionName+" = __append;\n"}if(h.localsName&&!m.test(h.localsName))throw Error("localsName is not a valid JS identifier.");if(h.destructuredLocals&&h.destructuredLocals.length){for(var p="  var __locals = ("+h.localsName+" || {}),\n",r=0;r<h.destructuredLocals.length;r++){var s=h.destructuredLocals[r];if(!m.test(s))throw Error("destructuredLocals["+r+"] is not a valid JS identifier.");r>0&&(p+=",\n  "),p+=s+" = __locals."+s}i+=p+";\n"}!1!==h._with&&(i+="  with ("+h.localsName+" || {}) {\n",j+="  }\n"),j+="  return __output;\n",this.source=i+this.source+j}a=h.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+l+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,h.client&&(a="escapeFn = escapeFn || "+k.toString()+";\n"+a,h.compileDebug&&(a="rethrow = rethrow || "+q.toString()+";\n"+a)),h.strict&&(a='"use strict";\n'+a),h.debug&&console.log(a),h.compileDebug&&h.filename&&(a=a+"\n//# sourceURL="+l+"\n");try{if(h.async)try{g=Function("return (async function(){}).constructor;")()}catch(a){if(a instanceof SyntaxError)throw Error("This environment does not support async/await");throw a}else g=Function;c=new g(h.localsName+", escapeFn, include, rethrow",a)}catch(a){throw a instanceof SyntaxError&&(h.filename&&(a.message+=" in "+h.filename),a.message+=" while compiling ejs\n\n",a.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",a.message+="https://github.com/RyanZim/EJS-Lint",h.async||(a.message+="\n",a.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),a}var t=h.client?c:function(a){return c.apply(h.context,[a||f.createNullProtoObjWherePossible(),k,function(c,e){var g=f.shallowCopy(f.createNullProtoObjWherePossible(),a);return e&&(g=f.shallowCopy(g,e)),(function(a,c){var e=f.shallowCopy(f.createNullProtoObjWherePossible(),c);if(e.filename=function(a,c){var e,f,g=c.views,h=/^[A-Za-z]+:\\|^\//.exec(a);if(h&&h.length)a=a.replace(/^\/*/,""),e=Array.isArray(c.root)?n(a,c.root):b.resolveInclude(a,c.root||"/",!0);else if(c.filename&&(f=b.resolveInclude(a,c.filename),d.existsSync(f)&&(e=f)),!e&&Array.isArray(g)&&(e=n(a,g)),!e&&"function"!=typeof c.includer)throw Error('Could not find the include file "'+c.escapeFunction(a)+'"');return e}(a,e),"function"==typeof c.includer){var g=c.includer(a,e.filename);if(g&&(g.filename&&(e.filename=g.filename),g.template))return o(e,g.template)}return o(e)})(c,h)(g)},q])};if(h.filename&&"function"==typeof Object.defineProperty){var u=h.filename,v=e.basename(u,e.extname(u));try{Object.defineProperty(t,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(a){}}return t},generateSource:function(){this.opts.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var a=this,b=this.parseTemplateText(),c=this.opts.delimiter,d=this.opts.openDelimiter,e=this.opts.closeDelimiter;b&&b.length&&b.forEach(function(f,g){var h;if(0===f.indexOf(d+c)&&0!==f.indexOf(d+c+c)&&(h=b[g+2])!=c+e&&h!="-"+c+e&&h!="_"+c+e)throw Error('Could not find matching close tag for "'+f+'".');a.scanLine(f)})},parseTemplateText:function(){for(var a,b=this.templateText,c=this.regex,d=c.exec(b),e=[];d;)0!==(a=d.index)&&(e.push(b.substring(0,a)),b=b.slice(a)),e.push(d[0]),b=b.slice(d[0].length),d=c.exec(b);return b&&e.push(b),e},_addOutput:function(a){if(this.truncate&&(a=a.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!a)return a;a=(a=(a=(a=a.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+a+'")\n'},scanLine:function(a){var b=this.opts.delimiter,c=this.opts.openDelimiter,d=this.opts.closeDelimiter,e=0;switch(e=a.split("\n").length-1,a){case c+b:case c+b+"_":this.mode=s.modes.EVAL;break;case c+b+"=":this.mode=s.modes.ESCAPED;break;case c+b+"-":this.mode=s.modes.RAW;break;case c+b+"#":this.mode=s.modes.COMMENT;break;case c+b+b:this.mode=s.modes.LITERAL,this.source+='    ; __append("'+a.replace(c+b+b,c+b)+'")\n';break;case b+b+d:this.mode=s.modes.LITERAL,this.source+='    ; __append("'+a.replace(b+b+d,b+d)+'")\n';break;case b+d:case"-"+b+d:case"_"+b+d:this.mode==s.modes.LITERAL&&this._addOutput(a),this.mode=null,this.truncate=0===a.indexOf("-")||0===a.indexOf("_");break;default:if(this.mode){switch(this.mode){case s.modes.EVAL:case s.modes.ESCAPED:case s.modes.RAW:a.lastIndexOf("//")>a.lastIndexOf("\n")&&(a+="\n")}switch(this.mode){case s.modes.EVAL:this.source+="    ; "+a+"\n";break;case s.modes.ESCAPED:this.source+="    ; __append(escapeFn("+r(a)+"))\n";break;case s.modes.RAW:this.source+="    ; __append("+r(a)+")\n";break;case s.modes.COMMENT:break;case s.modes.LITERAL:this._addOutput(a)}}else this._addOutput(a)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},b.escapeXML=f.escapeXML,b.__express=b.renderFile,b.VERSION=h,b.name="ejs","u">typeof window&&(window.ejs=b)},7039:(a,b,c)=>{let d,e,f,g,h;c.r(b),c.d(b,{curves:()=>k,fflonk:()=>r,groth16:()=>l,plonk:()=>q,powersOfTau:()=>m,r1cs:()=>n,wtns:()=>o,zKey:()=>p});var i,j,k={};c.r(k),c.d(k,{getCurveFromName:()=>$,getCurveFromQ:()=>Z,getCurveFromR:()=>Y});var l={};c.r(l),c.d(l,{exportSolidityCallData:()=>br,fullProve:()=>bm,prove:()=>bb,verify:()=>bo});var m={};c.r(m),c.d(m,{beacon:()=>bQ,challengeContribute:()=>bP,contribute:()=>bR,convert:()=>bU,exportChallenge:()=>bJ,exportJson:()=>bV,importResponse:()=>bK,newAccumulator:()=>bI,preparePhase2:()=>bS,truncate:()=>bT,verify:()=>bM});var n={};c.r(n),c.d(n,{exportJson:()=>c3,info:()=>c2,print:()=>bW});var o={};c.r(o),c.d(o,{calculate:()=>bk,check:()=>c8,debug:()=>c6,exportJson:()=>c7});var p={};c.r(p),c.d(p,{beacon:()=>di,bellmanContribute:()=>dk,contribute:()=>dh,exportBellman:()=>dd,exportJson:()=>dj,exportSolidityVerifier:()=>dv,exportVerificationKey:()=>dm,importBellman:()=>de,newZKey:()=>dc,verifyFromInit:()=>df,verifyFromR1cs:()=>dg});var q={};c.r(q),c.d(q,{exportSolidityCallData:()=>d1,fullProve:()=>dV,prove:()=>dT,setup:()=>dw,verify:()=>dX});var r={};c.r(r),c.d(r,{exportSolidityCallData:()=>el,exportSolidityVerifier:()=>du,fullProve:()=>eb,prove:()=>d9,setup:()=>d7,verify:()=>ed});var s=c(5043),t=c(9021);async function u(a,b,c,d){if(c=c||262144,"number"!=typeof b&&0>["w+","wx+","r","ax+","a+"].indexOf(b))throw Error("Invalid open option");let e=await t.promises.open(a,b),f=await e.stat();return new v(e,f,c,d,a)}class v{constructor(a,b,c,d,e){for(this.fileName=e,this.fd=a,this.pos=0,this.pageSize=d||256;this.pageSize<b.blksize;)this.pageSize*=2;this.totalSize=b.size,this.totalPages=Math.floor((b.size-1)/this.pageSize)+1,this.maxPagesLoaded=Math.floor(c/this.pageSize)+1,this.pages={},this.pendingLoads=[],this.writing=!1,this.reading=!1,this.avBuffs=[],this.history={}}_loadPage(a){let b=this,c=new Promise((c,d)=>{b.pendingLoads.push({page:a,resolve:c,reject:d})});return b.__statusPage("After Load request: ",a),c}__statusPage(a,b){let c=[];if(!this.logHistory)return;c.push("=="+a+" "+b);let d="";for(let a=0;a<this.pendingLoads.length;a++)this.pendingLoads[a].page==b&&(d=d+" "+a);if(d&&c.push("Pending loads:"+d),void 0!==this.pages[b]){let a=this.pages[b];c.push("Loaded"),c.push("pendingOps: "+a.pendingOps),a.loading&&c.push("loading: "+a.loading),a.writing&&c.push("writing"),a.dirty&&c.push("dirty")}c.push("=="),this.history[b]||(this.history[b]=[]),this.history[b].push(c)}__printHistory(a){this.history[a]||console.log("Empty History ",a),console.log("History "+a);for(let b=0;b<this.history[a].length;b++)for(let c=0;c<this.history[a][b].length;c++)console.log("-> "+this.history[a][b][c])}_triggerLoad(){let a=this;if(a.reading||0==a.pendingLoads.length)return;let b=Object.keys(a.pages),c=[];for(let d=0;d<b.length;d++){let e=a.pages[parseInt(b[d])];!1!=e.dirty||0!=e.pendingOps||e.writing||e.loading||c.push(parseInt(b[d]))}let d=a.maxPagesLoaded-b.length,e=[];for(;a.pendingLoads.length>0&&(void 0!==a.pages[a.pendingLoads[0].page]||d>0||c.length>0);){let b=a.pendingLoads.shift();if(void 0!==a.pages[b.page]){a.pages[b.page].pendingOps++;let d=c.indexOf(b.page);d>=0&&c.splice(d,1),a.pages[b.page].loading?a.pages[b.page].loading.push(b):b.resolve(),a.__statusPage("After Load (cached): ",b.page)}else{if(d)d--;else{let b=c.shift();a.__statusPage("Before Unload: ",b),a.avBuffs.unshift(a.pages[b]),delete a.pages[b],a.__statusPage("After Unload: ",b)}b.page>=a.totalPages?(a.pages[b.page]=f(),b.resolve(),a.__statusPage("After Load (new): ",b.page)):(a.reading=!0,a.pages[b.page]=f(),a.pages[b.page].loading=[b],e.push(a.fd.read(a.pages[b.page].buff,0,a.pageSize,b.page*a.pageSize).then(c=>{a.pages[b.page].size=c.bytesRead;let d=a.pages[b.page].loading;delete a.pages[b.page].loading;for(let a=0;a<d.length;a++)d[a].resolve();return a.__statusPage("After Load (loaded): ",b.page),c},a=>{b.reject(a)})),a.__statusPage("After Load (loading): ",b.page))}}function f(){if(!(a.avBuffs.length>0))return{dirty:!1,buff:new Uint8Array(a.pageSize),pendingOps:1,size:0};{let b=a.avBuffs.shift();return b.dirty=!1,b.pendingOps=1,b.size=0,b}}Promise.all(e).then(()=>{a.reading=!1,a.pendingLoads.length>0&&setImmediate(a._triggerLoad.bind(a)),a._tryClose()})}_triggerWrite(){let a=this;if(a.writing)return;let b=Object.keys(a.pages),c=[];for(let d=0;d<b.length;d++){let e=a.pages[parseInt(b[d])];e.dirty&&(e.dirty=!1,e.writing=!0,a.writing=!0,c.push(a.fd.write(e.buff,0,e.size,parseInt(b[d])*a.pageSize).then(()=>{e.writing=!1},b=>{console.log("ERROR Writing: "+b),a.error=b,a._tryClose()})))}a.writing&&Promise.all(c).then(()=>{a.writing=!1,setImmediate(a._triggerWrite.bind(a)),a._tryClose(),a.pendingLoads.length>0&&setImmediate(a._triggerLoad.bind(a))})}_getDirtyPage(){for(let a in this.pages)if(this.pages[a].dirty)return a;return -1}async write(a,b){if(0==a.byteLength)return;if(void 0===b&&(b=this.pos),this.pos=b+a.byteLength,this.totalSize<b+a.byteLength&&(this.totalSize=b+a.byteLength),this.pendingClose)throw Error("Writing a closing file");let c=Math.floor(b/this.pageSize),d=Math.floor((b+a.byteLength-1)/this.pageSize),e=[];for(let a=c;a<=d;a++)e.push(this._loadPage(a));this._triggerLoad();let f=c,g=b%this.pageSize,h=a.byteLength;for(;h>0;){await e[f-c];let b=g+h>this.pageSize?this.pageSize-g:h,d=a.slice(a.byteLength-h,a.byteLength-h+b);new Uint8Array(this.pages[f].buff.buffer,g,b).set(d),this.pages[f].dirty=!0,this.pages[f].pendingOps--,this.pages[f].size=Math.max(g+b,this.pages[f].size),f>=this.totalPages&&(this.totalPages=f+1),h-=b,f++,g=0,this.writing||setImmediate(this._triggerWrite.bind(this))}}async read(a,b){let c=new Uint8Array(a);return await this.readToBuffer(c,0,a,b),c}async readToBuffer(a,b,c,d){if(0==c)return;if(c>this.pageSize*this.maxPagesLoaded*.8){let a=Math.floor(1.1*c);this.maxPagesLoaded=Math.floor(a/this.pageSize)+1}if(void 0===d&&(d=this.pos),this.pos=d+c,this.pendingClose)throw Error("Reading a closing file");let e=Math.floor(d/this.pageSize),f=Math.floor((d+c-1)/this.pageSize),g=[];for(let a=e;a<=f;a++)g.push(this._loadPage(a));this._triggerLoad();let h=e,i=d%this.pageSize,j=d+c>this.totalSize?c-(d+c-this.totalSize):c;for(;j>0;){await g[h-e],this.__statusPage("After Await (read): ",h);let d=i+j>this.pageSize?this.pageSize-i:j,f=new Uint8Array(this.pages[h].buff.buffer,this.pages[h].buff.byteOffset+i,d);a.set(f,b+c-j),this.pages[h].pendingOps--,this.__statusPage("After Op done: ",h),j-=d,h++,i=0,this.pendingLoads.length>0&&setImmediate(this._triggerLoad.bind(this))}this.pos=d+c}_tryClose(){!this.pendingClose||(this.error&&this.pendingCloseReject(this.error),this._getDirtyPage()>=0||this.writing||this.reading||this.pendingLoads.length>0||this.pendingClose())}close(){let a=this;if(a.pendingClose)throw Error("Closing the file twice");return new Promise((b,c)=>{a.pendingClose=b,a.pendingCloseReject=c,a._tryClose()}).then(()=>{a.fd.close()},b=>{throw a.fd.close(),b})}async discard(){await this.close(),await t.promises.unlink(this.fileName)}async writeULE32(a,b){let c=new Uint8Array(4);new DataView(c.buffer).setUint32(0,a,!0),await this.write(c,b)}async writeUBE32(a,b){let c=new Uint8Array(4);new DataView(c.buffer).setUint32(0,a,!1),await this.write(c,b)}async writeULE64(a,b){let c=new Uint8Array(8),d=new DataView(c.buffer);d.setUint32(0,0|a,!0),d.setUint32(4,Math.floor(a/0x100000000),!0),await this.write(c,b)}async readULE32(a){return new Uint32Array((await this.read(4,a)).buffer)[0]}async readUBE32(a){return new DataView((await this.read(4,a)).buffer).getUint32(0,!1)}async readULE64(a){let b=new Uint32Array((await this.read(8,a)).buffer);return 0x100000000*b[1]+b[0]}async readString(a){if(this.pendingClose)throw Error("Reading a closing file");let b=void 0===a?this.pos:a,c=Math.floor(b/this.pageSize),d=!1,e="";for(;!d;){let a=this._loadPage(c);this._triggerLoad(),await a,this.__statusPage("After Await (read): ",c);let f=b%this.pageSize,g=new Uint8Array(this.pages[c].buff.buffer,this.pages[c].buff.byteOffset+f,this.pageSize-f),h=g.findIndex(a=>0===a);(d=-1!==h)?(e+=new TextDecoder().decode(g.slice(0,h)),this.pos=c*this.pageSize+f+h+1):(e+=new TextDecoder().decode(g),this.pos=c*this.pageSize+f+g.length),this.pages[c].pendingOps--,this.__statusPage("After Op done: ",c),b=this.pos,c++,this.pendingLoads.length>0&&setImmediate(this._triggerLoad.bind(this))}return e}}let w=new Uint8Array(4),x=new DataView(w.buffer),y=new Uint8Array(8),z=new DataView(y.buffer);class A{constructor(){this.pageSize=16384}_resizeIfNeeded(a){if(a>this.allocSize){let b=Math.max(this.allocSize+1048576,Math.floor(1.1*this.allocSize),a),c=new Uint8Array(b);c.set(this.o.data),this.o.data=c,this.allocSize=b}}async write(a,b){if(void 0===b&&(b=this.pos),this.readOnly)throw Error("Writing a read only file");this._resizeIfNeeded(b+a.byteLength),this.o.data.set(a.slice(),b),b+a.byteLength>this.totalSize&&(this.totalSize=b+a.byteLength),this.pos=b+a.byteLength}async readToBuffer(a,b,c,d){if(void 0===d&&(d=this.pos),this.readOnly&&d+c>this.totalSize)throw Error("Reading out of bounds");this._resizeIfNeeded(d+c);let e=new Uint8Array(this.o.data.buffer,this.o.data.byteOffset+d,c);a.set(e,b),this.pos=d+c}async read(a,b){let c=new Uint8Array(a);return await this.readToBuffer(c,0,a,b),c}close(){this.o.data.byteLength!=this.totalSize&&(this.o.data=this.o.data.slice(0,this.totalSize))}async discard(){}async writeULE32(a,b){x.setUint32(0,a,!0),await this.write(w,b)}async writeUBE32(a,b){x.setUint32(0,a,!1),await this.write(w,b)}async writeULE64(a,b){z.setUint32(0,0|a,!0),z.setUint32(4,Math.floor(a/0x100000000),!0),await this.write(y,b)}async readULE32(a){return new Uint32Array((await this.read(4,a)).buffer)[0]}async readUBE32(a){return new DataView((await this.read(4,a)).buffer).getUint32(0,!1)}async readULE64(a){let b=new Uint32Array((await this.read(8,a)).buffer);return 0x100000000*b[1]+b[0]}async readString(a){let b=void 0===a?this.pos:a;if(b>this.totalSize){if(this.readOnly)throw Error("Reading out of bounds");this._resizeIfNeeded(a)}let c=new Uint8Array(this.o.data.buffer,b,this.totalSize-b),d=c.findIndex(a=>0===a),e="";return -1!==d?(e=new TextDecoder().decode(c.slice(0,d)),this.pos=b+d+1):this.pos=b,e}}let B=new Uint8Array(4),C=new DataView(B.buffer),D=new Uint8Array(8),E=new DataView(D.buffer);class F{constructor(){this.pageSize=16384}_resizeIfNeeded(a){if(a<=this.totalSize)return;if(this.readOnly)throw Error("Reading out of file bounds");let b=Math.floor((a-1)/4194304)+1;for(let c=Math.max(this.o.data.length-1,0);c<b;c++){let d=new Uint8Array(c<b-1?4194304:a-(b-1)*4194304);c==this.o.data.length-1&&d.set(this.o.data[c]),this.o.data[c]=d}this.totalSize=a}async write(a,b){if(void 0===b&&(b=this.pos),this.readOnly)throw Error("Writing a read only file");this._resizeIfNeeded(b+a.byteLength);let c=Math.floor(b/4194304),d=b%4194304,e=a.byteLength;for(;e>0;){let b=d+e>4194304?4194304-d:e,f=a.slice(a.byteLength-e,a.byteLength-e+b);new Uint8Array(this.o.data[c].buffer,d,b).set(f),e-=b,c++,d=0}this.pos=b+a.byteLength}async readToBuffer(a,b,c,d){if(void 0===d&&(d=this.pos),this.readOnly&&d+c>this.totalSize)throw Error("Reading out of bounds");this._resizeIfNeeded(d+c);let e=Math.floor(d/4194304),f=d%4194304,g=c;for(;g>0;){let d=f+g>4194304?4194304-f:g,h=new Uint8Array(this.o.data[e].buffer,f,d);a.set(h,b+c-g),g-=d,e++,f=0}this.pos=d+c}async read(a,b){let c=new Uint8Array(a);return await this.readToBuffer(c,0,a,b),c}close(){}async discard(){}async writeULE32(a,b){C.setUint32(0,a,!0),await this.write(B,b)}async writeUBE32(a,b){C.setUint32(0,a,!1),await this.write(B,b)}async writeULE64(a,b){E.setUint32(0,0|a,!0),E.setUint32(4,Math.floor(a/0x100000000),!0),await this.write(D,b)}async readULE32(a){return new Uint32Array((await this.read(4,a)).buffer)[0]}async readUBE32(a){return new DataView((await this.read(4,a)).buffer).getUint32(0,!1)}async readULE64(a){let b=new Uint32Array((await this.read(8,a)).buffer);return 0x100000000*b[1]+b[0]}async readString(a){let b=void 0===a?this.pos:a;if(b>this.totalSize){if(this.readOnly)throw Error("Reading out of bounds");this._resizeIfNeeded(a)}let c=!1,d="";for(;!c;){let a=Math.floor(b/4194304),e=b%4194304;if(void 0===this.o.data[a])throw Error("ERROR");let f=Math.min(2048,this.o.data[a].length-e),g=new Uint8Array(this.o.data[a].buffer,e,f),h=g.findIndex(a=>0===a);(c=-1!==h)?(d+=new TextDecoder().decode(g.slice(0,h)),this.pos=4194304*a+e+h+1):(d+=new TextDecoder().decode(g),this.pos=4194304*a+e+g.length),b=this.pos}return d}}var G=c(1115);async function H(a,b,c){if("string"==typeof a&&(a={type:"file",fileName:a,cacheSize:b||65536,pageSize:c||8192}),"file"==a.type)return await u(a.fileName,G.O_TRUNC|G.O_CREAT|G.O_RDWR,a.cacheSize,a.pageSize);if("mem"==a.type){var d;let b,c;return b=(d=a).initialSize||1048576,(c=new A).o=d,c.o.data=new Uint8Array(b),c.allocSize=b,c.totalSize=0,c.readOnly=!1,c.pos=0,c}if("bigMem"==a.type){var e=a;let b=e.initialSize||0,c=new F;c.o=e;let d=b?Math.floor((b-1)/4194304)+1:0;c.o.data=[];for(let a=0;a<d-1;a++)c.o.data.push(new Uint8Array(4194304));return d&&c.o.data.push(new Uint8Array(b-4194304*(d-1))),c.totalSize=0,c.readOnly=!1,c.pos=0,c}throw Error("Invalid FastFile type: "+a.type)}async function I(a,b,c){var d,e;if(a instanceof Uint8Array&&(a={type:"mem",data:a}),"string"==typeof a&&(a={type:"file",fileName:a,cacheSize:b||65536,pageSize:c||8192}),"file"==a.type)return await u(a.fileName,G.O_RDONLY,a.cacheSize,a.pageSize);if("mem"==a.type){let b;return await (d=a,(b=new A).o=d,b.allocSize=d.data.byteLength,b.totalSize=d.data.byteLength,b.readOnly=!0,b.pos=0,b)}if("bigMem"==a.type){let b;return await (e=a,(b=new F).o=e,b.totalSize=(e.data.length-1)*4194304+e.data[e.data.length-1].byteLength,b.readOnly=!0,b.pos=0,b)}throw Error("Invalid FastFile type: "+a.type)}async function J(a,b,c,d,e){let f=await I(a,d,e),g=await f.read(4),h="";for(let a=0;a<4;a++)h+=String.fromCharCode(g[a]);if(h!=b)throw Error(a+": Invalid File format");if(await f.readULE32()>c)throw Error("Version not supported");let i=await f.readULE32(),j=[];for(let a=0;a<i;a++){let a=await f.readULE32(),b=await f.readULE64();void 0===j[a]&&(j[a]=[]),j[a].push({p:f.pos,size:b}),f.pos+=b}return{fd:f,sections:j}}async function K(a,b,c,d,e,f){let g=await H(a,e,f),h=new Uint8Array(4);for(let a=0;a<4;a++)h[a]=b.charCodeAt(a);return await g.write(h,0),await g.writeULE32(c),await g.writeULE32(d),g}async function L(a,b){if(void 0!==a.writingSection)throw Error("Already writing a section");await a.writeULE32(b),a.writingSection={pSectionSize:a.pos},await a.writeULE64(0)}async function M(a){if(void 0===a.writingSection)throw Error("Not writing a section");let b=a.pos-a.writingSection.pSectionSize-8,c=a.pos;a.pos=a.writingSection.pSectionSize,await a.writeULE64(b),a.pos=c,delete a.writingSection}async function N(a,b,c){if(void 0!==a.readingSection)throw Error("Already reading a section");if(!b[c])throw Error(a.fileName+": Missing section "+c);if(b[c].length>1)throw Error(a.fileName+": Section Duplicated "+c);a.pos=b[c][0].p,a.readingSection=b[c][0]}async function O(a,b){if(void 0===a.readingSection)throw Error("Not reading a section");if(!b&&a.pos-a.readingSection.p!=a.readingSection.size)throw Error("Invalid section size reading");delete a.readingSection}async function P(a,b,c,d){let e=new Uint8Array(c);s.X5.toRprLE(e,0,b,c),await a.write(e,d)}async function Q(a,b,c){let d=await a.read(b,c);return s.X5.fromRprLE(d,0,b)}async function R(a,b,c,d,e){void 0===e&&(e=b[d][0].size);let f=a.pageSize;await N(a,b,d),await L(c,d);for(let b=0;b<e;b+=f){let d=Math.min(e-b,f),g=await a.read(d);await c.write(g)}await M(c),await O(a,e!=b[d][0].size)}async function S(a,b,c,d,e){let f;if(d=void 0===d?0:d,e=void 0===e?b[c][0].size-d:e,d+e>b[c][0].size)throw Error("Reading out of the range of the section");return f=e<0x40000000?new Uint8Array(e):new s.Zh(e),await a.readToBuffer(f,0,e,b[c][0].p+d),f}async function T(a,b,c,d,e){let f=16*a.pageSize;if(await N(a,b,e),await N(c,d,e),b[e][0].size!=d[e][0].size)return!1;let g=b[e][0].size;for(let b=0;b<g;b+=f){let d=Math.min(g-b,f),e=await a.read(d),h=await c.read(d);for(let a=0;a<d;a++)if(e[a]!=h[a])return!1}return await O(a),await O(c),!0}let U=s.X5.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),V=s.X5.e("21888242871839275222246405745257275088548364400416034343698204186575808495617"),W=s.X5.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),X=s.X5.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function Y(a,b){let c,d=b&&b.singleThread;if(s.X5.eq(a,V))c=await (0,s.k1)(d);else if(s.X5.eq(a,U))c=await (0,s.tK)(d);else throw Error(`Curve not supported: ${s.X5.toString(a)}`);return c}async function Z(a,b){let c,d=b&&b.singleThread;if(s.X5.eq(a,X))c=await (0,s.k1)(d);else if(s.X5.eq(a,W))c=await (0,s.tK)(d);else throw Error(`Curve not supported: ${s.X5.toString(a)}`);return c}async function $(a,b){let c,d=b&&b.singleThread,e=a.toUpperCase().match(/[A-Za-z0-9]+/g).join("");if(["BN128","BN254","ALTBN128"].indexOf(e)>=0)c=await (0,s.k1)(d);else if(["BLS12381"].indexOf(e)>=0)c=await (0,s.tK)(d);else throw Error(`Curve not supported: ${a}`);return c}function _(a){if(!Number.isSafeInteger(a)||a<0)throw Error("positive integer expected, got "+a)}function aa(a,...b){if(!(a instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name))throw Error("Uint8Array expected");if(b.length>0&&!b.includes(a.length))throw Error("Uint8Array expected of length "+b+", got length="+a.length)}function ab(a,b=!0){if(a.destroyed)throw Error("Hash instance has been destroyed");if(b&&a.finished)throw Error("Hash#digest() has already been called")}function ac(a,b){aa(a);let c=b.outputLen;if(a.length<c)throw Error("digestInto() expects output buffer of length at least "+c)}function ad(a){return new Uint32Array(a.buffer,a.byteOffset,Math.floor(a.byteLength/4))}function ae(...a){for(let b=0;b<a.length;b++)a[b].fill(0)}let af=68===new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];function ag(a){return a<<24&0xff000000|a<<8&0xff0000|a>>>8&65280|a>>>24&255}let ah=af?a=>a:a=>ag(a),ai=af?a=>a:function(a){for(let b=0;b<a.length;b++)a[b]=ag(a[b]);return a};function aj(a){return"string"==typeof a&&(a=function(a){if("string"!=typeof a)throw Error("string expected");return new Uint8Array(new TextEncoder().encode(a))}(a)),aa(a),a}class ak{}let al=Uint8Array.from([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9]),am=BigInt(0x100000000-1),an=BigInt(32);function ao(a,b=!1){return b?{h:Number(a&am),l:Number(a>>an&am)}:{h:0|Number(a>>an&am),l:0|Number(a&am)}}let ap=(a,b,c)=>a>>>c|b<<32-c,aq=(a,b,c)=>a<<32-c|b>>>c;function ar(a,b,c,d){let e=(b>>>0)+(d>>>0);return{h:a+c+(e/0x100000000|0)|0,l:0|e}}let as=(a,b,c)=>(a>>>0)+(b>>>0)+(c>>>0),at=(a,b,c,d)=>b+c+d+(a/0x100000000|0)|0,au=Uint32Array.from([0xf3bcc908,0x6a09e667,0x84caa73b,0xbb67ae85,0xfe94f82b,0x3c6ef372,0x5f1d36f1,0xa54ff53a,0xade682d1,0x510e527f,0x2b3e6c1f,0x9b05688c,0xfb41bd6b,0x1f83d9ab,0x137e2179,0x5be0cd19]),av=new Uint32Array(32);function aw(a,b,c,d,e,f){let g=e[f],h=e[f+1],i=av[2*a],j=av[2*a+1],k=av[2*b],l=av[2*b+1],m=av[2*c],n=av[2*c+1],o=av[2*d],p=av[2*d+1],q=as(i,k,g);j=at(q,j,l,h),i=0|q,({Dh:p,Dl:o}={Dh:p^j,Dl:o^i}),({Dh:p,Dl:o}={Dh:o,Dl:p}),({h:n,l:m}=ar(n,m,p,o)),({Bh:l,Bl:k}={Bh:l^n,Bl:k^m}),({Bh:l,Bl:k}={Bh:ap(l,k,24),Bl:aq(l,k,24)}),av[2*a]=i,av[2*a+1]=j,av[2*b]=k,av[2*b+1]=l,av[2*c]=m,av[2*c+1]=n,av[2*d]=o,av[2*d+1]=p}function ax(a,b,c,d,e,f){let g=e[f],h=e[f+1],i=av[2*a],j=av[2*a+1],k=av[2*b],l=av[2*b+1],m=av[2*c],n=av[2*c+1],o=av[2*d],p=av[2*d+1],q=as(i,k,g);j=at(q,j,l,h),i=0|q,({Dh:p,Dl:o}={Dh:p^j,Dl:o^i}),({Dh:p,Dl:o}={Dh:ap(p,o,16),Dl:aq(p,o,16)}),({h:n,l:m}=ar(n,m,p,o)),({Bh:l,Bl:k}={Bh:l^n,Bl:k^m}),({Bh:l,Bl:k}={Bh:l<<1|k>>>31,Bl:l>>>31|k<<1}),av[2*a]=i,av[2*a+1]=j,av[2*b]=k,av[2*b+1]=l,av[2*c]=m,av[2*c+1]=n,av[2*d]=o,av[2*d+1]=p}class ay extends ak{constructor(a,b){super(),this.finished=!1,this.destroyed=!1,this.length=0,this.pos=0,_(a),_(b),this.blockLen=a,this.outputLen=b,this.buffer=new Uint8Array(a),this.buffer32=ad(this.buffer)}update(a){ab(this),aa(a=aj(a));let{blockLen:b,buffer:c,buffer32:d}=this,e=a.length,f=a.byteOffset,g=a.buffer;for(let h=0;h<e;){this.pos===b&&(ai(d),this.compress(d,0,!1),ai(d),this.pos=0);let i=Math.min(b-this.pos,e-h),j=f+h;if(i===b&&!(j%4)&&h+i<e){let a=new Uint32Array(g,j,Math.floor((e-h)/4));ai(a);for(let c=0;h+b<e;c+=d.length,h+=b)this.length+=b,this.compress(a,c,!1);ai(a);continue}c.set(a.subarray(h,h+i),this.pos),this.pos+=i,this.length+=i,h+=i}return this}digestInto(a){ab(this),ac(a,this);let{pos:b,buffer32:c}=this;this.finished=!0,ae(this.buffer.subarray(b)),ai(c),this.compress(c,0,!0),ai(c);let d=ad(a);this.get().forEach((a,b)=>d[b]=ah(a))}digest(){let{buffer:a,outputLen:b}=this;this.digestInto(a);let c=a.slice(0,b);return this.destroy(),c}_cloneInto(a){let{buffer:b,length:c,finished:d,destroyed:e,outputLen:f,pos:g}=this;return a||(a=new this.constructor({dkLen:f})),a.set(...this.get()),a.buffer.set(b),a.destroyed=e,a.finished=d,a.length=c,a.pos=g,a.outputLen=f,a}clone(){return this._cloneInto()}}class az extends ay{constructor(a={}){const b=void 0===a.dkLen?64:a.dkLen;super(128,b),this.v0l=0|au[0],this.v0h=0|au[1],this.v1l=0|au[2],this.v1h=0|au[3],this.v2l=0|au[4],this.v2h=0|au[5],this.v3l=0|au[6],this.v3h=0|au[7],this.v4l=0|au[8],this.v4h=0|au[9],this.v5l=0|au[10],this.v5h=0|au[11],this.v6l=0|au[12],this.v6h=0|au[13],this.v7l=0|au[14],this.v7h=0|au[15],function(a,b={},c,d,e){if(_(64),a<0||a>64)throw Error("outputLen bigger than keyLen");let{key:f,salt:g,personalization:h}=b;if(void 0!==f&&(f.length<1||f.length>64))throw Error("key length must be undefined or 1..64");if(void 0!==g&&16!==g.length)throw Error("salt must be undefined or 16");if(void 0!==h&&16!==h.length)throw Error("personalization must be undefined or 16")}(b,a,0,0,0);let{key:c,personalization:d,salt:e}=a,f=0;if(void 0!==c&&(f=(c=aj(c)).length),this.v0l^=this.outputLen|f<<8|0x1010000,void 0!==e){const a=ad(e=aj(e));this.v4l^=ah(a[0]),this.v4h^=ah(a[1]),this.v5l^=ah(a[2]),this.v5h^=ah(a[3])}if(void 0!==d){const a=ad(d=aj(d));this.v6l^=ah(a[0]),this.v6h^=ah(a[1]),this.v7l^=ah(a[2]),this.v7h^=ah(a[3])}if(void 0!==c){const a=new Uint8Array(this.blockLen);a.set(c),this.update(a)}}get(){let{v0l:a,v0h:b,v1l:c,v1h:d,v2l:e,v2h:f,v3l:g,v3h:h,v4l:i,v4h:j,v5l:k,v5h:l,v6l:m,v6h:n,v7l:o,v7h:p}=this;return[a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p]}set(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){this.v0l=0|a,this.v0h=0|b,this.v1l=0|c,this.v1h=0|d,this.v2l=0|e,this.v2h=0|f,this.v3l=0|g,this.v3h=0|h,this.v4l=0|i,this.v4h=0|j,this.v5l=0|k,this.v5h=0|l,this.v6l=0|m,this.v6h=0|n,this.v7l=0|o,this.v7h=0|p}compress(a,b,c){this.get().forEach((a,b)=>av[b]=a),av.set(au,16);let{h:d,l:e}=ao(BigInt(this.length));av[24]=au[8]^e,av[25]=au[9]^d,c&&(av[28]=~av[28],av[29]=~av[29]);let f=0;for(let c=0;c<12;c++)aw(0,4,8,12,a,b+2*al[f++]),ax(0,4,8,12,a,b+2*al[f++]),aw(1,5,9,13,a,b+2*al[f++]),ax(1,5,9,13,a,b+2*al[f++]),aw(2,6,10,14,a,b+2*al[f++]),ax(2,6,10,14,a,b+2*al[f++]),aw(3,7,11,15,a,b+2*al[f++]),ax(3,7,11,15,a,b+2*al[f++]),aw(0,5,10,15,a,b+2*al[f++]),ax(0,5,10,15,a,b+2*al[f++]),aw(1,6,11,12,a,b+2*al[f++]),ax(1,6,11,12,a,b+2*al[f++]),aw(2,7,8,13,a,b+2*al[f++]),ax(2,7,8,13,a,b+2*al[f++]),aw(3,4,9,14,a,b+2*al[f++]),ax(3,4,9,14,a,b+2*al[f++]);this.v0l^=av[0]^av[16],this.v0h^=av[1]^av[17],this.v1l^=av[2]^av[18],this.v1h^=av[3]^av[19],this.v2l^=av[4]^av[20],this.v2h^=av[5]^av[21],this.v3l^=av[6]^av[22],this.v3h^=av[7]^av[23],this.v4l^=av[8]^av[24],this.v4h^=av[9]^av[25],this.v5l^=av[10]^av[26],this.v5h^=av[11]^av[27],this.v6l^=av[12]^av[28],this.v6h^=av[13]^av[29],this.v7l^=av[14]^av[30],this.v7h^=av[15]^av[31],ae(av)}destroy(){this.destroyed=!0,ae(this.buffer32),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}let aA=(i=a=>new az(a),(e=(a,b)=>i(b).update(aj(a)).digest()).outputLen=(f=i({})).outputLen,e.blockLen=f.blockLen,e.create=a=>i(a),e);var aB=c(4984),aC=c(5511);let aD=[];for(let a=0;a<256;a++)aD[a]=function(a,b){let c=0,d=a;for(let a=0;a<8;a++)c<<=1,c|=1&d,d>>=1;return c}(a,8);function aE(a){return((0xffff0000&a)!=0?(a&=0xffff0000,16):0)|((0xff00ff00&a)!=0?(a&=0xff00ff00,8):0)|((0xf0f0f0f0&a)!=0?(a&=0xf0f0f0f0,4):0)|((0xcccccccc&a)!=0?(a&=0xcccccccc,2):0)|(0xaaaaaaaa&a)!=0}function aF(a,b){let c=new DataView(a.buffer,a.byteOffset,a.byteLength),d="";for(let a=0;a<4;a++){a>0&&(d+="\n"),d+="		";for(let b=0;b<4;b++)b>0&&(d+=" "),d+=c.getUint32(16*a+4*b).toString(16).padStart(8,"0")}return b&&(d=b+"\n"+d),d}function aG(a,b){if(a.byteLength!=b.byteLength)return!1;for(var c=new Int8Array(a),d=new Int8Array(b),e=0;e!=a.byteLength;e++)if(c[e]!=d[e])return!1;return!0}function aH(a){let b=a.subarray(0,128),c=ad(a.subarray(128)),d=aA.create({dkLen:64});d.buffer.set(b),d.v0l=0|c[0],d.v0h=0|c[1],d.v1l=0|c[2],d.v1h=0|c[3],d.v2l=0|c[4],d.v2h=0|c[5],d.v3l=0|c[6],d.v3h=0|c[7],d.v4l=0|c[8],d.v4h=0|c[9],d.v5l=0|c[10],d.v5h=0|c[11],d.v6l=0|c[12],d.v6h=0|c[13],d.v7l=0|c[14],d.v7h=0|c[15];let e=c[16]+0x100000000*c[17],f=c[18]+0x100000000*c[19];return d.length=e+f,d.pos=f,d}function aI(a){let b=new Uint8Array(216),c=ad(b.subarray(128));return b.set(a.buffer),c[0]=a.v0l,c[1]=a.v0h,c[2]=a.v1l,c[3]=a.v1h,c[4]=a.v2l,c[5]=a.v2h,c[6]=a.v3l,c[7]=a.v3h,c[8]=a.v4l,c[9]=a.v4h,c[10]=a.v5l,c[11]=a.v5h,c[12]=a.v6l,c[13]=a.v6h,c[14]=a.v7l,c[15]=a.v7h,c[18]=a.pos,c[16]=a.length-a.pos,b}async function aJ(a,b,c,d,e){return!(a.G1.isZero(b)||a.G1.isZero(c)||a.G2.isZero(d)||a.G2.isZero(e))&&await a.pairingEq(b,e,a.G1.neg(c),d)}function aK(a){let b=new Uint8Array(a);return aC.randomFillSync(b),b}async function aL(a){return aC.createHash("sha256").update(a).digest()}function aM(a,b){return new DataView(a.buffer).getUint32(b,!1)}async function aN(a){for(;!a;)a=await function(){{let a=aB.createInterface({input:process.stdin,output:process.stdout});return new Promise(b=>{a.question("Enter a random text. (Entropy): ",a=>b(a))})}}();let b=aA.create(64);b.update(aK(64));let c=new TextEncoder;b.update(c.encode(a));let d=b.digest(),e=[];for(let a=0;a<8;a++)e[a]=aM(d,4*a);return new s.Bw(e)}async function aO(a,b){let c,d;b<32?(c=1<<b>>>0,d=1):(c=0x100000000,d=1<<b-32>>>0);let e=a;for(let a=0;a<d;a++)for(let a=0;a<c;a++)e=await aL(e);let f=new DataView(e.buffer,e.byteOffset,e.byteLength),g=[];for(let a=0;a<8;a++)g[a]=f.getUint32(4*a,!1);return new s.Bw(g)}function aP(a){return a instanceof Uint8Array?a:("0x"==a.slice(0,2)&&(a=a.slice(2)),new Uint8Array(a.match(/[\da-f]{2}/gi).map(function(a){return parseInt(a,16)})))}function aQ(a){return Array.prototype.map.call(a,function(a){return("0"+(255&a).toString(16)).slice(-2)}).join("")}function aR(a,b){if(b instanceof Uint8Array)return a.toString(b);if(Array.isArray(b))return b.map(aR.bind(null,a));if("object"==typeof b){let c={};return Object.keys(b).forEach(d=>{c[d]=aR(a,b[d])}),c}if("bigint"==typeof b||void 0!==b.eq)return b.toString(10);return b}async function aS(a,b){await L(a,1),await a.writeULE32(1),await M(a);let c=await Z(b.q);await L(a,2);let d=c.q,e=(Math.floor((s.X5.bitLength(d)-1)/64)+1)*8,f=c.r,g=(Math.floor((s.X5.bitLength(f)-1)/64)+1)*8;await a.writeULE32(e),await P(a,d,e),await a.writeULE32(g),await P(a,f,g),await a.writeULE32(b.nVars),await a.writeULE32(b.nPublic),await a.writeULE32(b.domainSize),await aT(a,c,b.vk_alpha_1),await aT(a,c,b.vk_beta_1),await aU(a,c,b.vk_beta_2),await aU(a,c,b.vk_gamma_2),await aT(a,c,b.vk_delta_1),await aU(a,c,b.vk_delta_2),await M(a)}async function aT(a,b,c){let d=new Uint8Array(2*b.G1.F.n8);b.G1.toRprLEM(d,0,c),await a.write(d)}async function aU(a,b,c){let d=new Uint8Array(2*b.G2.F.n8);b.G2.toRprLEM(d,0,c),await a.write(d)}async function aV(a,b,c){let d=await a.read(2*b.G1.F.n8),e=b.G1.fromRprLEM(d,0);return c?b.G1.toObject(e):e}async function aW(a,b,c){let d=await a.read(2*b.G2.F.n8),e=b.G2.fromRprLEM(d,0);return c?b.G2.toObject(e):e}async function aX(a,b,c,d){await N(a,b,1);let e=await a.readULE32();if(await O(a),1===e)return await aY(a,b,c,d);if(2===e)return await aZ(a,b,c,d);if(10===e)return await a$(a,b,c,d);throw Error("Protocol not supported: ")}async function aY(a,b,c,d){let e={};e.protocol="groth16",await N(a,b,2);let f=await a.readULE32();e.n8q=f,e.q=await Q(a,f);let g=await a.readULE32();return e.n8r=g,e.r=await Q(a,g),e.curve=await Z(e.q,d),e.nVars=await a.readULE32(),e.nPublic=await a.readULE32(),e.domainSize=await a.readULE32(),e.power=aE(e.domainSize),e.vk_alpha_1=await aV(a,e.curve,c),e.vk_beta_1=await aV(a,e.curve,c),e.vk_beta_2=await aW(a,e.curve,c),e.vk_gamma_2=await aW(a,e.curve,c),e.vk_delta_1=await aV(a,e.curve,c),e.vk_delta_2=await aW(a,e.curve,c),await O(a),e}async function aZ(a,b,c,d){let e={};e.protocol="plonk",await N(a,b,2);let f=await a.readULE32();e.n8q=f,e.q=await Q(a,f);let g=await a.readULE32();return e.n8r=g,e.r=await Q(a,g),e.curve=await Z(e.q,d),e.nVars=await a.readULE32(),e.nPublic=await a.readULE32(),e.domainSize=await a.readULE32(),e.power=aE(e.domainSize),e.nAdditions=await a.readULE32(),e.nConstraints=await a.readULE32(),e.k1=await a.read(g),e.k2=await a.read(g),e.Qm=await aV(a,e.curve,c),e.Ql=await aV(a,e.curve,c),e.Qr=await aV(a,e.curve,c),e.Qo=await aV(a,e.curve,c),e.Qc=await aV(a,e.curve,c),e.S1=await aV(a,e.curve,c),e.S2=await aV(a,e.curve,c),e.S3=await aV(a,e.curve,c),e.X_2=await aW(a,e.curve,c),await O(a),e}async function a$(a,b,c,d){let e={};e.protocol="fflonk",e.protocolId=10,await N(a,b,2);let f=await a.readULE32();e.n8q=f,e.q=await Q(a,f),e.curve=await Z(e.q,d);let g=await a.readULE32();return e.n8r=g,e.r=await Q(a,g),e.nVars=await a.readULE32(),e.nPublic=await a.readULE32(),e.domainSize=await a.readULE32(),e.power=aE(e.domainSize),e.nAdditions=await a.readULE32(),e.nConstraints=await a.readULE32(),e.k1=await a.read(g),e.k2=await a.read(g),e.w3=await a.read(g),e.w4=await a.read(g),e.w8=await a.read(g),e.wr=await a.read(g),e.X_2=await aW(a,e.curve,c),e.C0=await aV(a,e.curve,c),await O(a),e}async function a_(a,b){let{fd:c,sections:d}=await J(a,"zkey",1),e=await aX(c,d,b),f=new s.mG(e.r),g=s.X5.mod(s.X5.shl(1,8*e.n8r),e.r),h=f.inv(g),i=f.mul(h,h),j=await Z(e.q);await N(c,d,3),e.IC=[];for(let a=0;a<=e.nPublic;a++){let a=await aV(c,j,b);e.IC.push(a)}await O(c),await N(c,d,4);let k=await c.readULE32();e.ccoefs=[];for(let a=0;a<k;a++){let a=await c.readULE32(),d=await c.readULE32(),f=await c.readULE32(),g=await l(b);e.ccoefs.push({matrix:a,constraint:d,signal:f,value:g})}await O(c),await N(c,d,5),e.A=[];for(let a=0;a<e.nVars;a++){let d=await aV(c,j,b);e.A[a]=d}await O(c),await N(c,d,6),e.B1=[];for(let a=0;a<e.nVars;a++){let d=await aV(c,j,b);e.B1[a]=d}await O(c),await N(c,d,7),e.B2=[];for(let a=0;a<e.nVars;a++){let d=await aW(c,j,b);e.B2[a]=d}await O(c),await N(c,d,8),e.C=[];for(let a=e.nPublic+1;a<e.nVars;a++){let d=await aV(c,j,b);e.C[a]=d}await O(c),await N(c,d,9),e.hExps=[];for(let a=0;a<e.domainSize;a++){let a=await aV(c,j,b);e.hExps.push(a)}return await O(c),await c.close(),e;async function l(){let a=await Q(c,e.n8r);return f.mul(a,i)}}async function a0(a,b,c){let d={delta:{}};d.deltaAfter=await aV(a,b,c),d.delta.g1_s=await aV(a,b,c),d.delta.g1_sx=await aV(a,b,c),d.delta.g2_spx=await aW(a,b,c),d.transcript=await a.read(64),d.type=await a.readULE32();let e=await a.readULE32(),f=a.pos,g=0;for(;a.pos-f<e;){let b=await a.read(1);if(b[0]<=g)throw Error("Parameters in the contribution must be sorted");if(g=b[0],1==b[0]){let b=await a.read(1),c=await a.read(b[0]);d.name=new TextDecoder().decode(c)}else if(2==b[0])d.numIterationsExp=(await a.read(1))[0];else if(3==b[0]){let b=await a.read(1);d.beaconHash=await a.read(b[0])}else throw Error("Parameter not recognized")}if(a.pos!=f+e)throw Error("Parameters do not match");return d}async function a1(a,b,c){await N(a,c,10);let d={contributions:[]};d.csHash=await a.read(64);let e=await a.readULE32();for(let c=0;c<e;c++){let c=await a0(a,b);d.contributions.push(c)}return await O(a),d}async function a2(a,b,c){await aT(a,b,c.deltaAfter),await aT(a,b,c.delta.g1_s),await aT(a,b,c.delta.g1_sx),await aU(a,b,c.delta.g2_spx),await a.write(c.transcript),await a.writeULE32(c.type||0);let d=[];if(c.name){d.push(1);let a=new TextEncoder("utf-8").encode(c.name.substring(0,64));d.push(a.byteLength);for(let b=0;b<a.byteLength;b++)d.push(a[b])}if(1==c.type){d.push(2),d.push(c.numIterationsExp),d.push(3),d.push(c.beaconHash.byteLength);for(let a=0;a<c.beaconHash.byteLength;a++)d.push(c.beaconHash[a])}if(d.length>0){let b=new Uint8Array(d);await a.writeULE32(b.byteLength),await a.write(b)}else await a.writeULE32(0)}async function a3(a,b,c){await L(a,10),await a.write(c.csHash),await a.writeULE32(c.contributions.length);for(let d=0;d<c.contributions.length;d++)await a2(a,b,c.contributions[d]);await M(a)}function a4(a,b,c){let d=new Uint8Array(2*b.G1.F.n8);b.G1.toRprUncompressed(d,0,c),a.update(d)}function a5(a,b,c){var d;let e;a4(a,b,c.deltaAfter),a4(a,b,c.delta.g1_s),a4(a,b,c.delta.g1_sx),d=c.delta.g2_spx,e=new Uint8Array(2*b.G2.F.n8),b.G2.toRprUncompressed(e,0,d),a.update(e),a.update(c.transcript)}async function a6(a,b,c){await L(a,1);let d=(Math.floor((s.X5.bitLength(c)-1)/64)+1)*8;await a.writeULE32(d),await P(a,c,d),await a.writeULE32(b.length),await M(a),await L(a,2);for(let c=0;c<b.length;c++)await P(a,b[c],d);await M(a,2)}async function a7(a,b,c){await L(a,1);let d=(Math.floor((s.X5.bitLength(c)-1)/64)+1)*8;if(await a.writeULE32(d),await P(a,c,d),b.byteLength%d!=0)throw Error("Invalid witness length");await a.writeULE32(b.byteLength/d),await M(a),await L(a,2),await a.write(b),await M(a)}async function a8(a,b){await N(a,b,1);let c=await a.readULE32(),d=await Q(a,c),e=await a.readULE32();return await O(a),{n8:c,q:d,nWitness:e}}async function a9(a){let{fd:b,sections:c}=await J(a,"wtns",2),{n8:d,nWitness:e}=await a8(b,c);await N(b,c,2);let f=[];for(let a=0;a<e;a++){let a=await Q(b,d);f.push(a)}return await O(b),await b.close(),f}let{stringifyBigInts:ba}=s.Wp;async function bb(a,b,c,d){let{fd:e,sections:f}=await J(b,"wtns",2,0x2000000,8388608),g=await a8(e,f),{fd:h,sections:i}=await J(a,"zkey",2,0x2000000,8388608),j=await aX(h,i,void 0,d);if("groth16"!=j.protocol)throw Error("zkey file is not groth16");if(!s.X5.eq(j.r,g.q))throw Error("Curve of the witness does not match the curve of the proving key");if(g.nWitness!=j.nVars)throw Error(`Invalid witness length. Circuit: ${j.nVars}, witness: ${g.nWitness}`);let k=j.curve,l=k.Fr,m=k.G1,n=k.G2,o=aE(j.domainSize);c&&c.debug("Reading Wtns");let p=await S(e,f,2);c&&c.debug("Reading Coeffs");let q=await S(h,i,4);c&&c.debug("Building ABC");let[r,t,u]=await bc(k,j,p,q,c),v=o==l.s?k.Fr.shift:k.Fr.w[o+1],w=await l.ifft(r,"","",c,"IFFT_A"),x=await l.batchApplyKey(w,l.e(1),v),y=await l.fft(x,"","",c,"FFT_A"),z=await l.ifft(t,"","",c,"IFFT_B"),A=await l.batchApplyKey(z,l.e(1),v),B=await l.fft(A,"","",c,"FFT_B"),C=await l.ifft(u,"","",c,"IFFT_C"),D=await l.batchApplyKey(C,l.e(1),v),E=await l.fft(D,"","",c,"FFT_C");c&&c.debug("Join ABC");let F=await bd(k,j,y,B,E,c),G={};c&&c.debug("Reading A Points");let H=await S(h,i,5);G.pi_a=await k.G1.multiExpAffine(H,p,c,"multiexp A"),c&&c.debug("Reading B1 Points");let I=await S(h,i,6),K=await k.G1.multiExpAffine(I,p,c,"multiexp B1");c&&c.debug("Reading B2 Points");let L=await S(h,i,7);G.pi_b=await k.G2.multiExpAffine(L,p,c,"multiexp B2"),c&&c.debug("Reading C Points");let M=await S(h,i,8);G.pi_c=await k.G1.multiExpAffine(M,p.slice((j.nPublic+1)*k.Fr.n8),c,"multiexp C"),c&&c.debug("Reading H Points");let N=await S(h,i,9),O=await k.G1.multiExpAffine(N,F,c,"multiexp H"),P=k.Fr.random(),Q=k.Fr.random();G.pi_a=m.add(G.pi_a,j.vk_alpha_1),G.pi_a=m.add(G.pi_a,m.timesFr(j.vk_delta_1,P)),G.pi_b=n.add(G.pi_b,j.vk_beta_2),G.pi_b=n.add(G.pi_b,n.timesFr(j.vk_delta_2,Q)),K=m.add(K,j.vk_beta_1),K=m.add(K,m.timesFr(j.vk_delta_1,Q)),G.pi_c=m.add(G.pi_c,O),G.pi_c=m.add(G.pi_c,m.timesFr(G.pi_a,Q)),G.pi_c=m.add(G.pi_c,m.timesFr(K,P)),G.pi_c=m.add(G.pi_c,m.timesFr(j.vk_delta_1,l.neg(l.mul(P,Q))));let R=[];for(let a=1;a<=j.nPublic;a++){let b=p.slice(a*l.n8,a*l.n8+l.n8);R.push(s.X5.fromRprLE(b))}return G.pi_a=m.toObject(m.toAffine(G.pi_a)),G.pi_b=n.toObject(n.toAffine(G.pi_b)),G.pi_c=m.toObject(m.toAffine(G.pi_c)),G.protocol="groth16",G.curve=k.name,await h.close(),await e.close(),{proof:G=ba(G),publicSignals:R=ba(R)}}async function bc(a,b,c,d,e){let f=a.Fr.n8,g=12+b.n8r,h=(d.byteLength-4)/g,i=new s.Zh(b.domainSize*f),j=new s.Zh(b.domainSize*f),k=new s.Zh(b.domainSize*f),l=[i,j];for(let b=0;b<h;b++){e&&b%1e6==0&&e.debug(`QAP AB: ${b}/${h}`);let i=d.slice(4+b*g,4+b*g+g),j=new DataView(i.buffer),k=j.getUint32(0,!0),m=j.getUint32(4,!0),n=j.getUint32(8,!0),o=i.slice(12,12+f);l[k].set(a.Fr.add(l[k].slice(m*f,m*f+f),a.Fr.mul(o,c.slice(n*f,n*f+f))),m*f)}for(let c=0;c<b.domainSize;c++)e&&c%1e6==0&&e.debug(`QAP C: ${c}/${b.domainSize}`),k.set(a.Fr.mul(i.slice(c*f,c*f+f),j.slice(c*f,c*f+f)),c*f);return[i,j,k]}async function bd(a,b,c,d,e,f){let g,h=a.Fr.n8,i=Math.floor(c.byteLength/a.Fr.n8),j=[];for(let b=0;b<i;b+=4194304){f&&f.debug(`JoinABC: ${b}/${i}`);let g=Math.min(i-b,4194304),k=[],l=c.slice(b*h,(b+g)*h),m=d.slice(b*h,(b+g)*h),n=e.slice(b*h,(b+g)*h);k.push({cmd:"ALLOCSET",var:0,buff:l}),k.push({cmd:"ALLOCSET",var:1,buff:m}),k.push({cmd:"ALLOCSET",var:2,buff:n}),k.push({cmd:"ALLOC",var:3,len:g*h}),k.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:g},{var:3}]}),k.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:g},{var:3}]}),k.push({cmd:"GET",out:0,var:3,len:g*h}),j.push(a.tm.queueAction(k))}let k=await Promise.all(j);g=c instanceof s.Zh?new s.Zh(c.byteLength):new Uint8Array(c.byteLength);let l=0;for(let a=0;a<k.length;a++)g.set(k[a][0],l),l+=k[a][0].byteLength;return g}function be(a){let b=[];return function a(b,c){if(Array.isArray(c))for(let d=0;d<c.length;d++)a(b,c[d]);else b.push(c)}(b,a),b}function bf(a){let b=BigInt(2)**BigInt(64),c=BigInt("0xCBF29CE484222325");for(let d=0;d<a.length;d++)c^=BigInt(a[d].charCodeAt(0)),c*=BigInt(0x100000001b3),c%=b;let d=c.toString(16),e=16-d.length;return"0".repeat(e).concat(d)}async function bg(a,b){let c,d,e;b=b||{};let f=1,g=0,h=0,i=!1;if(a instanceof WebAssembly.Instance)c=a,i=!0;else{let i=32767;if(b.memorySize&&(i=parseInt(b.memorySize))<0)throw Error("Invalid memory size");let j=!1;for(;!j;)try{e=new WebAssembly.Memory({initial:i}),j=!0}catch(a){if(i<=1)throw a;console.warn("Could not allocate "+1024*i*64+" bytes. This may cause severe instability. Trying with "+1024*i*64/2+" bytes"),i=Math.floor(i/2)}let m=await WebAssembly.compile(a),n="",o="";c=await WebAssembly.instantiate(m,{env:{memory:e},runtime:{printDebug:function(a){console.log("printDebug:",a)},exceptionHandler:function(a){let b;throw b=1===a?"Signal not found. ":2===a?"Too many signals set. ":3===a?"Signal already set. ":4===a?"Assert Failed. ":5===a?"Not enough memory. ":6===a?"Input signal array access exceeds the size. ":"Unknown error. ",console.error("ERROR: ",a,n),Error(b+n)},printErrorMessage:function(){n+=k()+"\n"},writeBufferMessage:function(){let a=k();"\n"===a?(console.log(o),o=""):(""!==o&&(o+=" "),o+=a)},showSharedRWMemory:function(){let a=c.exports.getFieldNumLen32(),b=new Uint32Array(a);for(let d=0;d<a;d++)b[a-1-d]=c.exports.readSharedRWMemory(d);if(f>=2&&(g>=1||h>=7)){""!==o&&(o+=" ");let a=s.X5.fromArray(b,0x100000000).toString();o+=a}else console.log(s.X5.fromArray(b,0x100000000))},error:function(a,c,e,f,g,h){let i;throw i=7===a?l(c)+" "+d.getFr(f).toString()+" != "+d.getFr(g).toString()+" "+l(h):9===a?l(c)+" "+d.getFr(f).toString()+" "+l(g):5===a&&b.sym?l(c)+" "+b.sym.labelIdx2Name[g]:l(c)+" "+e+" "+f+" "+g+" "+h,console.log("ERROR: ",a,i),Error(i)},log:function(a){console.log(d.getFr(a).toString())},logGetSignal:function(a,c){b.logGetSignal&&b.logGetSignal(a,d.getFr(c))},logSetSignal:function(a,c){b.logSetSignal&&b.logSetSignal(a,d.getFr(c))},logStartComponent:function(a){b.logStartComponent&&b.logStartComponent(a)},logFinishComponent:function(a){b.logFinishComponent&&b.logFinishComponent(a)}}})}"function"==typeof c.exports.getVersion&&(f=c.exports.getVersion()),"function"==typeof c.exports.getMinorVersion&&(g=c.exports.getMinorVersion()),"function"==typeof c.exports.getPatchVersion&&(h=c.exports.getPatchVersion());let j=b&&(b.sanityCheck||b.logGetSignal||b.logSetSignal||b.logStartComponent||b.logFinishComponent);if(2===f)d=new bi(c,j);else if(1===f){if(i)throw Error("Loading code from WebAssembly instance is not supported for circom version 1");d=new bh(e,c,j)}else throw Error(`Unsupported circom version: ${f}`);return d;function k(){let a="",b=c.exports.getMessageChar();for(;0!==b;)a+=String.fromCharCode(b),b=c.exports.getMessageChar();return a}function l(a){let b=new Uint8Array(e.buffer),c=[];for(let d=0;b[a+d]>0;d++)c.push(b[a+d]);return String.fromCharCode.apply(null,c)}}class bh{constructor(a,b,c){this.memory=a,this.i32=new Uint32Array(a.buffer),this.instance=b,this.n32=(this.instance.exports.getFrLen()>>2)-2;const d=this.instance.exports.getPRawPrime(),e=Array(this.n32);for(let a=0;a<this.n32;a++)e[this.n32-1-a]=this.i32[(d>>2)+a];this.prime=s.X5.fromArray(e,0x100000000),this.Fr=new s.mG(this.prime),this.mask32=s.X5.fromString("FFFFFFFF",16),this.NVars=this.instance.exports.getNVars(),this.n64=Math.floor((this.Fr.bitLength-1)/64)+1,this.R=this.Fr.e(s.X5.shiftLeft(1,64*this.n64)),this.RInv=this.Fr.inv(this.R),this.sanityCheck=c}circom_version(){return 1}async _doCalculateWitness(a,b){this.instance.exports.init(this.sanityCheck||b?1:0);let c=this.allocInt(),d=this.allocFr();Object.keys(a).forEach(b=>{let e=bf(b),f=parseInt(e.slice(0,8),16),g=parseInt(e.slice(8,16),16);try{this.instance.exports.getSignalOffset32(c,0,f,g)}catch(a){throw Error(`Signal ${b} is not an input of the circuit.`)}let h=this.getInt(c),i=be(a[b]);for(let a=0;a<i.length;a++)this.setFr(d,i[a]),this.instance.exports.setSignal(0,0,h+a,d)})}async calculateWitness(a,b){let c=this.i32[0],d=[];await this._doCalculateWitness(a,b);for(let a=0;a<this.NVars;a++){let b=this.instance.exports.getPWitness(a);d.push(this.getFr(b))}return this.i32[0]=c,d}async calculateBinWitness(a,b){let c=this.i32[0];await this._doCalculateWitness(a,b);let d=this.instance.exports.getWitnessBuffer();return this.i32[0]=c,new Uint8Array(this.memory.buffer.slice(d,d+this.NVars*this.n64*8))}allocInt(){let a=this.i32[0];return this.i32[0]=a+8,a}allocFr(){let a=this.i32[0];return this.i32[0]=a+4*this.n32+8,a}getInt(a){return this.i32[a>>2]}setInt(a,b){this.i32[a>>2]=b}getFr(a){let b=this,c=a>>2;if(0x80000000&b.i32[c+1]){var d;let a=Array(b.n32);for(let d=0;d<b.n32;d++)a[b.n32-1-d]=b.i32[c+2+d];let e=b.Fr.e(s.X5.fromArray(a,0x100000000));return 0x40000000&b.i32[c+1]?(d=e,b.Fr.mul(b.RInv,d)):e}return 0x80000000&b.i32[c]?b.Fr.e(b.i32[c]-0x100000000):b.Fr.e(b.i32[c])}setFr(a,b){b=this.Fr.e(b);let c=this.Fr.neg(this.Fr.e("80000000",16)),d=this.Fr.e("7FFFFFFF",16);if(this.Fr.geq(b,c)&&this.Fr.leq(b,d)){let d;d=this.Fr.geq(b,this.Fr.zero)?s.X5.toNumber(b):0x100000000+(d=s.X5.toNumber(this.Fr.sub(b,c))-0x80000000),this.i32[a>>2]=d,this.i32[(a>>2)+1]=0;return}this.i32[a>>2]=0,this.i32[(a>>2)+1]=0x80000000;let e=s.X5.toArray(b,0x100000000);for(let b=0;b<this.n32;b++){let c=e.length-1-b;c>=0?this.i32[(a>>2)+2+b]=e[c]:this.i32[(a>>2)+2+b]=0}}}class bi{constructor(a,b){this.instance=a,this.version=this.instance.exports.getVersion(),this.n32=this.instance.exports.getFieldNumLen32(),this.instance.exports.getRawPrime();const c=new Uint32Array(this.n32);for(let a=0;a<this.n32;a++)c[this.n32-1-a]=this.instance.exports.readSharedRWMemory(a);this.prime=s.X5.fromArray(c,0x100000000),this.witnessSize=this.instance.exports.getWitnessSize(),this.sanityCheck=b}circom_version(){return this.instance.exports.getVersion()}async _doCalculateWitness(a,b){this.instance.exports.init(this.sanityCheck||b?1:0);let c=Object.keys(a),d=0;if(c.forEach(b=>{let c=bf(b),e=parseInt(c.slice(0,8),16),f=parseInt(c.slice(8,16),16),g=be(a[b]);if("function"==typeof this.instance.exports.getInputSignalSize){let a=this.instance.exports.getInputSignalSize(e,f);if(a<0)throw Error(`Signal ${b} not found
`);if(g.length<a)throw Error(`Not enough values for input signal ${b}
`);if(g.length>a)throw Error(`Too many values for input signal ${b}
`)}for(let a=0;a<g.length;a++){let b=function(a,b){let c=[],d=BigInt(a),e=BigInt(0x100000000);for(;d;)c.unshift(Number(d%e)),d/=e;if(b){let a=b-c.length;for(;a>0;)c.unshift(0),a--}return c}(function(a,b){let c=BigInt(a)%b;return c<0&&(c+=b),c}(g[a],this.prime),this.n32);for(let a=0;a<this.n32;a++)this.instance.exports.writeSharedRWMemory(a,b[this.n32-1-a]);try{this.instance.exports.setInputSignal(e,f,a),d++}catch(a){throw Error(a)}}}),d<this.instance.exports.getInputSize())throw Error(`Not all inputs have been set. Only ${d} out of ${this.instance.exports.getInputSize()}`)}async calculateWitness(a,b){let c=[];await this._doCalculateWitness(a,b);for(let a=0;a<this.witnessSize;a++){this.instance.exports.getWitness(a);let b=new Uint32Array(this.n32);for(let a=0;a<this.n32;a++)b[this.n32-1-a]=this.instance.exports.readSharedRWMemory(a);c.push(s.X5.fromArray(b,0x100000000))}return c}async calculateWTNSBin(a,b){let c=new Uint32Array(this.witnessSize*this.n32+this.n32+11),d=new Uint8Array(c.buffer);await this._doCalculateWitness(a,b),d[0]=119,d[1]=116,d[2]=110,d[3]=115,c[1]=2,c[2]=2,c[3]=1;let e=4*this.n32,f=(8+e).toString(16);c[4]=parseInt(f.slice(0,8),16),c[5]=parseInt(f.slice(8,16),16),c[6]=e,this.instance.exports.getRawPrime();let g=7;for(let a=0;a<this.n32;a++)c[g+a]=this.instance.exports.readSharedRWMemory(a);c[g+=this.n32]=this.witnessSize,c[++g]=2,g++;let h=(e*this.witnessSize).toString(16);c[g]=parseInt(h.slice(0,8),16),c[g+1]=parseInt(h.slice(8,16),16),g+=2;for(let a=0;a<this.witnessSize;a++){this.instance.exports.getWitness(a);for(let a=0;a<this.n32;a++)c[g+a]=this.instance.exports.readSharedRWMemory(a);g+=this.n32}return d}}let{unstringifyBigInts:bj}=s.Wp;async function bk(a,b,c,d){let e=bj(a),f=await I(b),g=await f.read(f.totalSize);await f.close();let h=await bg(g,d);if(1===h.circom_version()){let a=await h.calculateBinWitness(e),b=await K(c,"wtns",2,2);await a7(b,a,h.prime),await b.close()}else{let a=await H(c),b=await h.calculateWTNSBin(e);await a.write(b),await a.close()}}let{unstringifyBigInts:bl}=s.Wp;async function bm(a,b,c,d,e,f){let g=bl(a),h={type:"mem"};return await bk(g,b,h,e),await bb(c,h,d,f)}let{unstringifyBigInts:bn}=s.Wp;async function bo(a,b,c,d){var e,f;let g,h,i=bn(a),j=bn(c),k=bn(b),l=await $(i.curve),m=l.G1.fromObject(i.IC[0]),n=new Uint8Array(2*l.G1.F.n8*k.length),o=new Uint8Array(l.Fr.n8*k.length);if(!function(a,b){for(let d=0;d<b.length;d++){var c;if(c=b[d],!(s.X5.geq(c,0)&&s.X5.lt(c,a.r)))return!1}return!0}(l,k))return d&&d.error("Public inputs are not valid."),!1;for(let a=0;a<k.length;a++){let b=l.G1.fromObject(i.IC[a+1]);n.set(b,a*l.G1.F.n8*2),s.X5.toRprLE(o,l.Fr.n8*a,k[a],l.Fr.n8)}let p=await l.G1.multiExpAffine(n,o);p=l.G1.add(p,m);let q=l.G1.fromObject(j.pi_a),r=l.G2.fromObject(j.pi_b),t=l.G1.fromObject(j.pi_c);if(e=l,f={pi_a:q,pi_b:r,pi_c:t},g=e.G1,h=e.G2,!(g.isValid(f.pi_a)&&h.isValid(f.pi_b)&&g.isValid(f.pi_c)))return d&&d.error("Proof commitments are not valid."),!1;let u=l.G2.fromObject(i.vk_gamma_2),v=l.G2.fromObject(i.vk_delta_2),w=l.G1.fromObject(i.vk_alpha_1),x=l.G2.fromObject(i.vk_beta_2);return await l.pairingEq(l.G1.neg(q),r,p,u,t,v,w,x)?(d&&d.info("OK!"),!0):(d&&d.error("Invalid proof"),!1)}let{unstringifyBigInts:bp}=s.Wp;function bq(a){let b=a.toString(16);for(;b.length<64;)b="0"+b;return`"0x${b}"`}async function br(a,b){let c=bp(a),d=bp(b),e="";for(let a=0;a<d.length;a++)""!=e&&(e+=","),e+=bq(d[a]);return`[${bq(c.pi_a[0])}, ${bq(c.pi_a[1])}],[[${bq(c.pi_b[0][1])}, ${bq(c.pi_b[0][0])}],[${bq(c.pi_b[1][1])}, ${bq(c.pi_b[1][0])}]],[${bq(c.pi_c[0])}, ${bq(c.pi_c[1])}],[${e}]`}function bs(a,b){let c=new DataView(b.buffer,b.byteOffset,b.byteLength),d=[];for(let a=0;a<8;a++)d[a]=c.getUint32(4*a);let e=new s.Bw(d);return a.G2.fromRng(e)}function bt(a,b,c,d,e){let f=aA.create({dkLen:64}),g=new Uint8Array([b]);f.update(g),f.update(c);let h=a.G1.toUncompressed(d);f.update(h);let i=a.G1.toUncompressed(e);return f.update(i),bs(a,f.digest())}function bu(a,b,c,d,e){return a.g1_s=b.G1.toAffine(b.G1.fromRng(e)),a.g1_sx=b.G1.toAffine(b.G1.timesFr(a.g1_s,a.prvKey)),a.g2_sp=b.G2.toAffine(bt(b,c,d,a.g1_s,a.g1_sx)),a.g2_spx=b.G2.toAffine(b.G2.timesFr(a.g2_sp,a.prvKey)),a}function bv(a,b,c){let d={tau:{},alpha:{},beta:{}};return d.tau.prvKey=a.Fr.fromRng(c),d.alpha.prvKey=a.Fr.fromRng(c),d.beta.prvKey=a.Fr.fromRng(c),bu(d.tau,a,0,b,c),bu(d.alpha,a,1,b,c),bu(d.beta,a,2,b,c),d}async function bw(a,b,c,d){d||(d=c),await a.writeULE32(1);let e=a.pos;await a.writeULE64(0),await a.writeULE32(8*b.F1.n64);let f=new Uint8Array(b.F1.n8);s.X5.toRprLE(f,0,b.q,b.F1.n8),await a.write(f),await a.writeULE32(c),await a.writeULE32(d);let g=a.pos-e-8,h=a.pos;await a.writeULE64(g,e),a.pos=h}async function bx(a,b){if(!b[1])throw Error(a.fileName+": File has no  header");if(b[1].length>1)throw Error(a.fileName+": File has more than one header");a.pos=b[1][0].p;let c=await a.readULE32(),d=await a.read(c),e=s.X5.fromRprLE(d),f=await Z(e);if(8*f.F1.n64!=c)throw Error(a.fileName+": Invalid size");let g=await a.readULE32(),h=await a.readULE32();if(a.pos-b[1][0].p!=b[1][0].size)throw Error("Invalid PTau header size");return{curve:f,power:g,ceremonyPower:h}}async function by(a,b,c){return bz(await a.read(2*b.F1.n8*6+2*b.F2.n8*3),0,b,c)}function bz(a,b,c,d){let e={tau:{},alpha:{},beta:{}};return e.tau.g1_s=f(),e.tau.g1_sx=f(),e.alpha.g1_s=f(),e.alpha.g1_sx=f(),e.beta.g1_s=f(),e.beta.g1_sx=f(),e.tau.g2_spx=g(),e.alpha.g2_spx=g(),e.beta.g2_spx=g(),e;function f(){let e;return e=d?c.G1.fromRprLEM(a,b):c.G1.fromRprUncompressed(a,b),b+=2*c.G1.F.n8,e}function g(){let e;return e=d?c.G2.fromRprLEM(a,b):c.G2.fromRprUncompressed(a,b),b+=2*c.G2.F.n8,e}}function bA(a,b,c,d,e){async function f(d){e?c.G1.toRprLEM(a,b,d):c.G1.toRprUncompressed(a,b,d),b+=2*c.F1.n8}async function g(d){e?c.G2.toRprLEM(a,b,d):c.G2.toRprUncompressed(a,b,d),b+=2*c.F2.n8}return f(d.tau.g1_s),f(d.tau.g1_sx),f(d.alpha.g1_s),f(d.alpha.g1_sx),f(d.beta.g1_s),f(d.beta.g1_sx),g(d.tau.g2_spx),g(d.alpha.g2_spx),g(d.beta.g2_spx),a}async function bB(a,b,c,d){let e=new Uint8Array(2*b.F1.n8*6+2*b.F2.n8*3);bA(e,0,b,c,d),await a.write(e)}async function bC(a,b){let c={};c.tauG1=await i(),c.tauG2=await j(),c.alphaG1=await i(),c.betaG1=await i(),c.betaG2=await j(),c.key=await by(a,b,!0),c.partialHash=await a.read(216),c.nextChallenge=await a.read(64),c.type=await a.readULE32();let d=new Uint8Array(2*b.G1.F.n8*6+2*b.G2.F.n8*3);bA(d,0,b,c.key,!1);let e=aH(c.partialHash);e.update(d),c.responseHash=e.digest();let f=await a.readULE32(),g=a.pos,h=0;for(;a.pos-g<f;){let a=await k(1);if(a[0]<=h)throw Error("Parameters in the contribution must be sorted");if(h=a[0],1==a[0]){let a=await k(1),b=await k(a[0]);c.name=new TextDecoder().decode(b)}else if(2==a[0])c.numIterationsExp=(await k(1))[0];else if(3==a[0]){let a=await k(1);c.beaconHash=await k(a[0])}else throw Error("Parameter not recognized")}if(a.pos!=g+f)throw Error("Parameters do not match");return c;async function i(){let c=await a.read(2*b.G1.F.n8);return b.G1.fromRprLEM(c)}async function j(){let c=await a.read(2*b.G2.F.n8);return b.G2.fromRprLEM(c)}async function k(b){return new Uint8Array(await a.read(b))}}async function bD(a,b,c){if(!c[7])throw Error(a.fileName+": File has no  contributions");if(c[7][0].length>1)throw Error(a.fileName+": File has more than one contributions section");a.pos=c[7][0].p;let d=await a.readULE32(),e=[];for(let c=0;c<d;c++){let d=await bC(a,b);d.id=c+1,e.push(d)}if(a.pos-c[7][0].p!=c[7][0].size)throw Error("Invalid contribution section size");return e}async function bE(a,b,c){let d=new Uint8Array(2*b.F1.n8),e=new Uint8Array(2*b.F2.n8);await g(c.tauG1),await h(c.tauG2),await g(c.alphaG1),await g(c.betaG1),await h(c.betaG2),await bB(a,b,c.key,!0),await a.write(c.partialHash),await a.write(c.nextChallenge),await a.writeULE32(c.type||0);let f=[];if(c.name){f.push(1);let a=new TextEncoder("utf-8").encode(c.name.substring(0,64));f.push(a.byteLength);for(let b=0;b<a.byteLength;b++)f.push(a[b])}if(1==c.type){f.push(2),f.push(c.numIterationsExp),f.push(3),f.push(c.beaconHash.byteLength);for(let a=0;a<c.beaconHash.byteLength;a++)f.push(c.beaconHash[a])}if(f.length>0){let b=new Uint8Array(f);await a.writeULE32(b.byteLength),await a.write(b)}else await a.writeULE32(0);async function g(c){b.G1.toRprLEM(d,0,c),await a.write(d)}async function h(c){b.G2.toRprLEM(e,0,c),await a.write(e)}}async function bF(a,b,c){await a.writeULE32(7);let d=a.pos;await a.writeULE64(0),await a.writeULE32(c.length);for(let d=0;d<c.length;d++)await bE(a,b,c[d]);let e=a.pos-d-8,f=a.pos;await a.writeULE64(e,d),a.pos=f}function bG(a,b,c){let d;c&&c.debug("Calculating First Challenge Hash");let e=aA.create({dkLen:64}),f=new Uint8Array(2*a.G1.F.n8),g=new Uint8Array(2*a.G2.F.n8);return a.G1.toRprUncompressed(f,0,a.G1.g),a.G2.toRprUncompressed(g,0,a.G2.g),e.update(aA.create({dkLen:64}).digest()),d=2**b*2-1,c&&c.debug("Calculate Initial Hash: tauG1"),h(f,d),d=2**b,c&&c.debug("Calculate Initial Hash: tauG2"),h(g,d),c&&c.debug("Calculate Initial Hash: alphaTauG1"),h(f,d),c&&c.debug("Calculate Initial Hash: betaTauG1"),h(f,d),e.update(g),e.digest();function h(a,b){let d=Math.floor(b/341e3),f=b%341e3,g=new Uint8Array(341e3*a.byteLength);for(let b=0;b<341e3;b++)g.set(a,b*a.byteLength);for(let a=0;a<d;a++)e.update(g),c&&c.debug("Initial hash: "+341e3*a);for(let b=0;b<f;b++)e.update(a)}}async function bH(a,b,c,d){return bv(a,b,await aO(c,d))}async function bI(a,b,c,d){let e=await K(c,"ptau",1,7);await bw(e,a,b,0);let f=a.G1.oneAffine,g=a.G2.oneAffine;await L(e,2);let h=2**b*2-1;for(let a=0;a<h;a++)await e.write(f),d&&a%1e5==0&&a&&d.log("tauG1: "+a);await M(e),await L(e,3);let i=2**b;for(let a=0;a<i;a++)await e.write(g),d&&a%1e5==0&&a&&d.log("tauG2: "+a);await M(e),await L(e,4);let j=2**b;for(let a=0;a<j;a++)await e.write(f),d&&a%1e5==0&&a&&d.log("alphaTauG1: "+a);await M(e),await L(e,5);let k=2**b;for(let a=0;a<k;a++)await e.write(f),d&&a%1e5==0&&a&&d.log("betaTauG1: "+a);await M(e),await L(e,6),await e.write(g),await M(e),await L(e,7),await e.writeULE32(0),await M(e),await e.close();let l=bG(a,b,d);return d&&d.debug(aF(aA.create({dkLen:64}).digest(),"Blank Contribution Hash:")),d&&d.info(aF(l,"First Contribution Hash:")),l}async function bJ(a,b,c){let d,e,{fd:f,sections:g}=await J(a,"ptau",1),{curve:h,power:i}=await bx(f,g),j=await bD(f,h,g);0==j.length?(d=aA.create({dkLen:64}).digest(),e=bG(h,i)):(d=j[j.length-1].responseHash,e=j[j.length-1].nextChallenge),c&&c.info(aF(d,"Last Response Hash: ")),c&&c.info(aF(e,"New Challenge Hash: "));let k=await H(b),l=aA.create({dkLen:64});await k.write(d),l.update(d),await n(2,"G1",2**i*2-1,"tauG1"),await n(3,"G2",2**i,"tauG2"),await n(4,"G1",2**i,"alphaTauG1"),await n(5,"G1",2**i,"betaTauG1"),await n(6,"G2",1,"betaG2"),await f.close(),await k.close();let m=l.digest();if(!aG(e,m))throw c&&c.info(aF(m,"Calc Curret Challenge Hash: ")),c&&c.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one"),Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");return e;async function n(a,b,d,e){let i=h[b],j=2*i.F.n8,m=Math.floor(0x1000000/j);await N(f,g,a);for(let a=0;a<d;a+=m){let b;c&&c.debug(`Exporting ${e}: ${a}/${d}`);let g=Math.min(d-a,m);b=await f.read(g*j),b=await i.batchLEMtoU(b),await k.write(b),l.update(b)}await O(f)}}async function bK(a,b,c,d,e,f){let g,h=new Uint8Array(64);for(let a=0;a<64;a++)h[a]=255;let{fd:i,sections:j}=await J(a,"ptau",1),{curve:k,power:l}=await bx(i,j),m=await bD(i,k,j),n={};d&&(n.name=d);let o=2*k.F1.n8,p=k.F1.n8,q=2*k.F2.n8,r=k.F2.n8,s=await I(b);if(s.totalSize!=64+(2**l*2-1)*p+2**l*r+2**l*p+2**l*p+r+6*o+3*q)throw Error("Size of the contribution is invalid");g=m.length>0?m[m.length-1].nextChallenge:bG(k,l,f);let t=await K(c,"ptau",1,e?7:2);await bw(t,k,l);let u=await s.read(64);if(aG(h,g)&&(g=u,m[m.length-1].nextChallenge=g),!aG(u,g))throw Error("Wrong contribution. This contribution is not based on the previous hash");let v=aA.create({dkLen:64});v.update(u);let w=[];n.tauG1=(await z(s,t,"G1",2,2**l*2-1,[1],"tauG1"))[0],n.tauG2=(await z(s,t,"G2",3,2**l,[1],"tauG2"))[0],n.alphaG1=(await z(s,t,"G1",4,2**l,[0],"alphaG1"))[0],n.betaG1=(await z(s,t,"G1",5,2**l,[0],"betaG1"))[0],n.betaG2=(await z(s,t,"G2",6,1,[0],"betaG2"))[0],n.partialHash=aI(v);let x=await s.read(2*k.F1.n8*6+2*k.F2.n8*3);n.key=bz(x,0,k,!1),v.update(new Uint8Array(x));let y=v.digest();if(f&&f.info(aF(y,"Contribution Response Hash imported: ")),e){let a=aA.create({dkLen:64});a.update(y),await C(a,t,"G1",2,2**l*2-1,"tauG1",f),await C(a,t,"G2",3,2**l,"tauG2",f),await C(a,t,"G1",4,2**l,"alphaTauG1",f),await C(a,t,"G1",5,2**l,"betaTauG1",f),await C(a,t,"G2",6,1,"betaG2",f),n.nextChallenge=a.digest(),f&&f.info(aF(n.nextChallenge,"Next Challenge Hash: "))}else n.nextChallenge=h;return m.push(n),await bF(t,k,m),await s.close(),await t.close(),await i.close(),n.nextChallenge;async function z(a,b,c,d,f,g,h){return e?await A(a,b,c,d,f,g,h):await B(a,b,c,d,f,g,h)}async function A(a,b,c,d,e,g,h){let i=k[c],j=i.F.n8,l=2*i.F.n8,m=[];await L(b,d);let n=Math.floor(0x1000000/l);w[d]=b.pos;for(let c=0;c<e;c+=n){f&&f.debug(`Importing ${h}: ${c}/${e}`);let d=Math.min(e-c,n),k=await a.read(d*j);v.update(k);let o=await i.batchCtoLEM(k);await b.write(o);for(let a=0;a<g.length;a++){let b=g[a];if(b>=c&&b<c+d){let a=i.fromRprLEM(o,(b-c)*l);m.push(a)}}}return await M(b),m}async function B(a,b,c,d,e,g,h){let i=k[c],j=i.F.n8,l=[],m=Math.floor(0x1000000/j);for(let b=0;b<e;b+=m){f&&f.debug(`Importing ${h}: ${b}/${e}`);let c=Math.min(e-b,m),d=await a.read(c*j);v.update(d);for(let a=0;a<g.length;a++){let e=g[a];if(e>=b&&e<b+c){let a=i.fromRprCompressed(d,(e-b)*j);l.push(a)}}}return l}async function C(a,b,c,d,e,f,g){let h=k[c],i=2*h.F.n8,j=Math.floor(0x1000000/i),l=b.pos;b.pos=w[d];for(let c=0;c<e;c+=j){g&&g.debug(`Hashing ${f}: ${c}/${e}`);let d=Math.min(e-c,j),k=await b.read(d*i),l=await h.batchLEMtoU(k);a.update(l)}b.pos=l}}async function bL(a,b,c,d){if(1==b.type){let e=await bH(a,c.nextChallenge,b.beaconHash,b.numIterationsExp);if(!a.G1.eq(b.key.tau.g1_s,e.tau.g1_s))return d&&d.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G1.eq(b.key.tau.g1_sx,e.tau.g1_sx))return d&&d.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G2.eq(b.key.tau.g2_spx,e.tau.g2_spx))return d&&d.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G1.eq(b.key.alpha.g1_s,e.alpha.g1_s))return d&&d.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G1.eq(b.key.alpha.g1_sx,e.alpha.g1_sx))return d&&d.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G2.eq(b.key.alpha.g2_spx,e.alpha.g2_spx))return d&&d.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G1.eq(b.key.beta.g1_s,e.beta.g1_s))return d&&d.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G1.eq(b.key.beta.g1_sx,e.beta.g1_sx))return d&&d.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G2.eq(b.key.beta.g2_spx,e.beta.g2_spx))return d&&d.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1}return(b.key.tau.g2_sp=a.G2.toAffine(bt(a,0,c.nextChallenge,b.key.tau.g1_s,b.key.tau.g1_sx)),b.key.alpha.g2_sp=a.G2.toAffine(bt(a,1,c.nextChallenge,b.key.alpha.g1_s,b.key.alpha.g1_sx)),b.key.beta.g2_sp=a.G2.toAffine(bt(a,2,c.nextChallenge,b.key.beta.g1_s,b.key.beta.g1_sx)),!0!==await aJ(a,b.key.tau.g1_s,b.key.tau.g1_sx,b.key.tau.g2_sp,b.key.tau.g2_spx))?(d&&d.error("INVALID key (tau) in challenge #"+b.id),!1):!0!==await aJ(a,b.key.alpha.g1_s,b.key.alpha.g1_sx,b.key.alpha.g2_sp,b.key.alpha.g2_spx)?(d&&d.error("INVALID key (alpha) in challenge #"+b.id),!1):!0!==await aJ(a,b.key.beta.g1_s,b.key.beta.g1_sx,b.key.beta.g2_sp,b.key.beta.g2_spx)?(d&&d.error("INVALID key (beta) in challenge #"+b.id),!1):!0!==await aJ(a,c.tauG1,b.tauG1,b.key.tau.g2_sp,b.key.tau.g2_spx)?(d&&d.error("INVALID tau*G1. challenge #"+b.id+" It does not follow the previous contribution"),!1):!0!==await aJ(a,b.key.tau.g1_s,b.key.tau.g1_sx,c.tauG2,b.tauG2)?(d&&d.error("INVALID tau*G2. challenge #"+b.id+" It does not follow the previous contribution"),!1):!0!==await aJ(a,c.alphaG1,b.alphaG1,b.key.alpha.g2_sp,b.key.alpha.g2_spx)?(d&&d.error("INVALID alpha*G1. challenge #"+b.id+" It does not follow the previous contribution"),!1):!0!==await aJ(a,c.betaG1,b.betaG1,b.key.beta.g2_sp,b.key.beta.g2_spx)?(d&&d.error("INVALID beta*G1. challenge #"+b.id+" It does not follow the previous contribution"),!1):!0!==await aJ(a,b.key.beta.g1_s,b.key.beta.g1_sx,c.betaG2,b.betaG2)?(d&&d.error("INVALID beta*G2. challenge #"+b.id+"It does not follow the previous contribution"),!1):(d&&d.info("Powers Of tau file OK!"),!0)}async function bM(a,b){let c,{fd:d,sections:e}=await J(a,"ptau",1),{curve:f,power:g,ceremonyPower:h}=await bx(d,e),i=await bD(d,f,e);b&&b.debug("power: 2**"+g),b&&b.debug("Computing initial contribution hash");let j={tauG1:f.G1.g,tauG2:f.G2.g,alphaG1:f.G1.g,betaG1:f.G1.g,betaG2:f.G2.g,nextChallenge:bG(f,h,b),responseHash:aA.create({dkLen:64}).digest()};if(0==i.length)return b&&b.error("This file has no contribution! It cannot be used in production"),!1;c=i.length>1?i[i.length-2]:j;let k=i[i.length-1];if(b&&b.debug("Validating contribution #"+i[i.length-1].id),!await bL(f,k,c,b))return!1;let l=aA.create({dkLen:64});l.update(k.responseHash),b&&b.debug("Verifying powers in tau*G1 section");let m=await v(2,"G1","tauG1",2**g*2-1,[0,1],b);if(!0!==await aJ(f,m.R1,m.R2,f.G2.g,k.tauG2))return b&&b.error("tauG1 section. Powers do not match"),!1;if(!f.G1.eq(f.G1.g,m.singularPoints[0]))return b&&b.error("First element of tau*G1 section must be the generator"),!1;if(!f.G1.eq(k.tauG1,m.singularPoints[1]))return b&&b.error("Second element of tau*G1 section does not match the one in the contribution section"),!1;b&&b.debug("Verifying powers in tau*G2 section");let n=await v(3,"G2","tauG2",2**g,[0,1],b);if(!0!==await aJ(f,f.G1.g,k.tauG1,n.R1,n.R2))return b&&b.error("tauG2 section. Powers do not match"),!1;if(!f.G2.eq(f.G2.g,n.singularPoints[0]))return b&&b.error("First element of tau*G2 section must be the generator"),!1;if(!f.G2.eq(k.tauG2,n.singularPoints[1]))return b&&b.error("Second element of tau*G2 section does not match the one in the contribution section"),!1;b&&b.debug("Verifying powers in alpha*tau*G1 section");let o=await v(4,"G1","alphatauG1",2**g,[0],b);if(!0!==await aJ(f,o.R1,o.R2,f.G2.g,k.tauG2))return b&&b.error("alphaTauG1 section. Powers do not match"),!1;if(!f.G1.eq(k.alphaG1,o.singularPoints[0]))return b&&b.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section"),!1;b&&b.debug("Verifying powers in beta*tau*G1 section");let p=await v(5,"G1","betatauG1",2**g,[0],b);if(!0!==await aJ(f,p.R1,p.R2,f.G2.g,k.tauG2))return b&&b.error("betaTauG1 section. Powers do not match"),!1;if(!f.G1.eq(k.betaG1,p.singularPoints[0]))return b&&b.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section"),!1;let q=await u(b);if(!f.G2.eq(k.betaG2,q))return b&&b.error("betaG2 element in betaG2 section does not match the one in the contribution section"),!1;let r=l.digest();if(g==h&&!aG(r,k.nextChallenge))return b&&b.error("Hash of the values does not match the next challenge of the last contributor in the contributions section"),!1;b&&b.info(aF(r,"Next challenge hash: ")),t(k,c);for(let a=i.length-2;a>=0;a--){let c=i[a],d=a>0?i[a-1]:j;if(!await bL(f,c,d,b))return!1;t(c,d,b)}if(b&&b.info("-----------------------------------------------------"),e[12]&&e[13]&&e[14]&&e[15]){if(!await w("G1",2,12,"tauG1",b)||!await w("G2",3,13,"tauG2",b)||!await w("G1",4,14,"alphaTauG1",b)||!await w("G1",5,15,"betaTauG1",b))return!1}else b&&b.warn('this file does not contain phase2 precalculated values. Please run: \n   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.');return await d.close(),b&&b.info("Powers of Tau Ok!"),!0;function t(a,c){if(!b)return;b.info("-----------------------------------------------------"),b.info(`Contribution #${a.id}: ${a.name||""}`),b.info(aF(a.nextChallenge,"Next Challenge: "));let d=new Uint8Array(2*f.G1.F.n8*6+2*f.G2.F.n8*3);bA(d,0,f,a.key,!1);let e=aH(a.partialHash);e.update(d);let g=e.digest();b.info(aF(g,"Response Hash:")),b.info(aF(c.nextChallenge,"Response Hash:")),1==a.type&&(b.info(`Beacon generator: ${aQ(a.beaconHash)}`),b.info(`Beacon iterations Exp: ${a.numIterationsExp}`))}async function u(a){let b=f.G2,c=2*b.F.n8,g=new Uint8Array(c);if(!e[6])throw a.error("File has no BetaG2 section"),Error("File has no BetaG2 section");if(e[6].length>1)throw a.error("File has no BetaG2 section"),Error("File has more than one GetaG2 section");d.pos=e[6][0].p;let h=await d.read(c),i=b.fromRprLEM(h);return b.toRprUncompressed(g,0,i),l.update(g),i}async function v(a,b,c,g,h,i){let j=f[b],k=2*j.F.n8;await N(d,e,a);let m=[],n=j.zero,o=j.zero,p=j.zero;for(let a=0;a<g;a+=65536){i&&i.debug(`points relations: ${c}: ${a}/${g} `);let b=Math.min(g-a,65536),e=await d.read(b*k),f=await j.batchLEMtoU(e);l.update(f);let q=aK(4*(b-1));if(a>0){let a=j.fromRprLEM(e,0),b=aM(aK(4),0);n=j.add(n,j.timesScalar(p,b)),o=j.add(o,j.timesScalar(a,b))}let r=await j.multiExpAffine(e.slice(0,(b-1)*k),q),s=await j.multiExpAffine(e.slice(k),q);n=j.add(n,r),o=j.add(o,s),p=j.fromRprLEM(e,(b-1)*k);for(let c=0;c<h.length;c++){let d=h[c];if(d>=a&&d<a+b){let b=j.fromRprLEM(e,(d-a)*k);m.push(b)}}}return await O(d),{R1:n,R2:o,singularPoints:m}}async function w(a,b,c,h,i){i&&i.debug(`Verifying phase2 calculated values ${h}...`);let j=f[a],k=2*j.F.n8,l=Array(8);for(let a=0;a<8;a++)l[a]=aM(aK(4),0);for(let a=0;a<=g;a++)if(!await m(a))return!1;if(2==b&&!await m(g+1))return!1;return!0;async function m(a){let m;i&&i.debug(`Power ${a}...`);let n=f.Fr.n8,o=2**a,p=new Uint32Array(o),q=new s.Bw(l);i&&i.debug(`Creating random numbers Powers${a}...`);for(let b=0;b<o;b++)a==g+1&&b==o-1?p[b]=0:p[b]=q.nextU32();p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength),i&&i.debug(`reading points Powers${a}...`),await N(d,e,b),m=new s.Zh(o*k),a==g+1?(await d.readToBuffer(m,0,(o-1)*k),m.set(f.G1.zeroAffine,(o-1)*k)):await d.readToBuffer(m,0,o*k),await O(d,!0);let r=await j.multiExpAffine(m,p,i,h+"_"+a);p=new s.Zh(o*n),q=new s.Bw(l);let t=new Uint8Array(4),u=new DataView(t.buffer);i&&i.debug(`Creating random numbers Powers${a}...`);for(let b=0;b<o;b++)(b!=o-1||a!=g+1)&&(u.setUint32(0,q.nextU32(),!0),p.set(t,b*n));i&&i.debug(`batchToMontgomery ${a}...`),p=await f.Fr.batchToMontgomery(p),i&&i.debug(`fft ${a}...`),p=await f.Fr.fft(p),i&&i.debug(`batchFromMontgomery ${a}...`),p=await f.Fr.batchFromMontgomery(p),i&&i.debug(`reading points Lagrange${a}...`),await N(d,e,c),d.pos+=k*(2**a-1),await d.readToBuffer(m,0,o*k),await O(d,!0);let v=await j.multiExpAffine(m,p,i,h+"_"+a+"_transformed");return!!j.eq(r,v)||(i&&i.error("Phase2 caclutation does not match with powers of tau"),!1)}}}async function bN(a,b,c,d,e,f,g,h,i,j){let k=e[f],l=2*k.F.n8,m=b[d][0].size/l;await N(a,b,d),await L(c,d);let n=g;for(let b=0;b<m;b+=65536){let d;j&&j.debug(`Applying key: ${i}: ${b}/${m}`);let f=Math.min(m-b,65536);d=await a.read(f*l),d=await k.batchApplyKey(d,n,h),await c.write(d),n=e.Fr.mul(n,e.Fr.exp(h,f))}await M(c),await O(a)}async function bO(a,b,c,d,e,f,g,h,i,j,k){let l=d[e],m=2*l.F.n8,n=Math.floor(1048576/m),o=g;for(let e=0;e<f;e+=n){let g;k&&k.debug(`Applying key ${j}: ${e}/${f}`);let p=Math.min(f-e,n),q=await a.read(p*m),r=await l.batchUtoLEM(q),s=await l.batchApplyKey(r,o,h);g="COMPRESSED"==i?await l.batchLEMtoC(s):await l.batchLEMtoU(s),c&&c.update(g),await b.write(g),o=d.Fr.mul(o,d.Fr.exp(h,p))}}async function bP(a,b,c,d,e){let f=await I(b),g=8*a.F1.n64*2,h=8*a.F2.n64*2,i=(f.totalSize+g-64-h)/(4*g+h),j=i,k=0;for(;j>1;)j/=2,k+=1;if(2**k!=i)throw Error("Invalid file size");e&&e.debug("Power to tau size: "+k);let l=await aN(d),m=await H(c),n=aA.create({dkLen:64});for(let a=0;a<f.totalSize;a+=f.pageSize){e&&e.debug(`Hashing challenge ${a}/${f.totalSize}`);let b=Math.min(f.totalSize-a,f.pageSize),c=await f.read(b);n.update(c)}let o=await f.read(64,0);e&&e.info(aF(o,"Claimed Previous Response Hash: "));let p=n.digest();e&&e.info(aF(p,"Current Challenge Hash: "));let q=bv(a,p,l);e&&["tau","alpha","beta"].forEach(b=>{e.debug(b+".g1_s: "+a.G1.toString(q[b].g1_s,16)),e.debug(b+".g1_sx: "+a.G1.toString(q[b].g1_sx,16)),e.debug(b+".g2_sp: "+a.G2.toString(q[b].g2_sp,16)),e.debug(b+".g2_spx: "+a.G2.toString(q[b].g2_spx,16)),e.debug("")});let r=aA.create({dkLen:64});await m.write(p),r.update(p),await bO(f,m,r,a,"G1",2**k*2-1,a.Fr.one,q.tau.prvKey,"COMPRESSED","tauG1",e),await bO(f,m,r,a,"G2",2**k,a.Fr.one,q.tau.prvKey,"COMPRESSED","tauG2",e),await bO(f,m,r,a,"G1",2**k,q.alpha.prvKey,q.tau.prvKey,"COMPRESSED","alphaTauG1",e),await bO(f,m,r,a,"G1",2**k,q.beta.prvKey,q.tau.prvKey,"COMPRESSED","betaTauG1",e),await bO(f,m,r,a,"G2",1,q.beta.prvKey,q.tau.prvKey,"COMPRESSED","betaTauG2",e);let s=new Uint8Array(2*a.F1.n8*6+2*a.F2.n8*3);bA(s,0,a,q,!1),await m.write(s),r.update(s);let t=r.digest();e&&e.info(aF(t,"Contribution Response Hash: ")),await m.close(),await f.close()}async function bQ(a,b,c,d,e,f){let g,h,i=aP(d);if(0==i.byteLength||2*i.byteLength!=d.length)return f&&f.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(i.length>=256)return f&&f.error("Maximum length of beacon hash is 255 bytes"),!1;if((e=parseInt(e))<10||e>63)return f&&f.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;let{fd:j,sections:k}=await J(a,"ptau",1),{curve:l,power:m,ceremonyPower:n}=await bx(j,k);if(m!=n)return f&&f.error("This file has been reduced. You cannot contribute into a reduced file."),!1;k[12]&&f&&f.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");let o=await bD(j,l,k),p={name:c,type:1,numIterationsExp:e,beaconHash:i};g=o.length>0?o[o.length-1].nextChallenge:bG(l,m,f),p.key=await bH(l,g,i,e);let q=aA.create({dkLen:64});q.update(g);let r=await K(b,"ptau",1,7);await bw(r,l,m);let s=[];h=await w(2,"G1",2**m*2-1,l.Fr.e(1),p.key.tau.prvKey,"tauG1",f),p.tauG1=h[1],h=await w(3,"G2",2**m,l.Fr.e(1),p.key.tau.prvKey,"tauG2",f),p.tauG2=h[1],h=await w(4,"G1",2**m,p.key.alpha.prvKey,p.key.tau.prvKey,"alphaTauG1",f),p.alphaG1=h[0],h=await w(5,"G1",2**m,p.key.beta.prvKey,p.key.tau.prvKey,"betaTauG1",f),p.betaG1=h[0],h=await w(6,"G2",1,p.key.beta.prvKey,p.key.tau.prvKey,"betaTauG2",f),p.betaG2=h[0],p.partialHash=aI(q);let t=new Uint8Array(2*l.F1.n8*6+2*l.F2.n8*3);bA(t,0,l,p.key,!1),q.update(new Uint8Array(t));let u=q.digest();f&&f.info(aF(u,"Contribution Response Hash imported: "));let v=aA.create({dkLen:64});return v.update(u),await x(r,"G1",2,2**m*2-1,"tauG1",f),await x(r,"G2",3,2**m,"tauG2",f),await x(r,"G1",4,2**m,"alphaTauG1",f),await x(r,"G1",5,2**m,"betaTauG1",f),await x(r,"G2",6,1,"betaG2",f),p.nextChallenge=v.digest(),f&&f.info(aF(p.nextChallenge,"Next Challenge Hash: ")),o.push(p),await bF(r,l,o),await j.close(),await r.close(),u;async function w(a,b,c,d,e,f,g){let h=[];j.pos=k[a][0].p,await L(r,a),s[a]=r.pos;let i=l[b],m=2*i.F.n8,n=Math.floor(1048576/m),o=d;for(let a=0;a<c;a+=n){g&&g.debug(`applying key${f}: ${a}/${c}`);let b=Math.min(c-a,n),d=await j.read(b*m),k=await i.batchApplyKey(d,o,e),p=r.write(k),s=await i.batchLEMtoC(k);if(q.update(s),await p,0==a)for(let a=0;a<Math.min(2,c);a++)h.push(i.fromRprLEM(k,a*m));o=l.Fr.mul(o,l.Fr.exp(e,b))}return await M(r),h}async function x(a,b,c,d,e,f){let g=l[b],h=2*g.F.n8,i=Math.floor(0x1000000/h),j=a.pos;a.pos=s[c];for(let b=0;b<d;b+=i){f&&f.debug(`Hashing ${e}: ${b}/${d}`);let c=Math.min(d-b,i),j=await a.read(c*h),k=await g.batchLEMtoU(j);v.update(k)}a.pos=j}}async function bR(a,b,c,d,e){let f,g,{fd:h,sections:i}=await J(a,"ptau",1),{curve:j,power:k,ceremonyPower:l}=await bx(h,i);if(k!=l)throw e&&e.error("This file has been reduced. You cannot contribute into a reduced file."),Error("This file has been reduced. You cannot contribute into a reduced file.");i[12]&&e&&e.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");let m=await bD(h,j,i),n={name:c,type:0},o=await aN(d);f=m.length>0?m[m.length-1].nextChallenge:bG(j,k,e),n.key=bv(j,f,o);let p=aA.create({dkLen:64});p.update(f);let q=await K(b,"ptau",1,7);await bw(q,j,k);let r=[];g=await v(2,"G1",2**k*2-1,j.Fr.e(1),n.key.tau.prvKey,"tauG1"),n.tauG1=g[1],g=await v(3,"G2",2**k,j.Fr.e(1),n.key.tau.prvKey,"tauG2"),n.tauG2=g[1],g=await v(4,"G1",2**k,n.key.alpha.prvKey,n.key.tau.prvKey,"alphaTauG1"),n.alphaG1=g[0],g=await v(5,"G1",2**k,n.key.beta.prvKey,n.key.tau.prvKey,"betaTauG1"),n.betaG1=g[0],g=await v(6,"G2",1,n.key.beta.prvKey,n.key.tau.prvKey,"betaTauG2"),n.betaG2=g[0],n.partialHash=aI(p);let s=new Uint8Array(2*j.F1.n8*6+2*j.F2.n8*3);bA(s,0,j,n.key,!1),p.update(new Uint8Array(s));let t=p.digest();e&&e.info(aF(t,"Contribution Response Hash imported: "));let u=aA.create({dkLen:64});return u.update(t),await w(q,"G1",2,2**k*2-1,"tauG1"),await w(q,"G2",3,2**k,"tauG2"),await w(q,"G1",4,2**k,"alphaTauG1"),await w(q,"G1",5,2**k,"betaTauG1"),await w(q,"G2",6,1,"betaG2"),n.nextChallenge=u.digest(),e&&e.info(aF(n.nextChallenge,"Next Challenge Hash: ")),m.push(n),await bF(q,j,m),await h.close(),await q.close(),t;async function v(a,b,c,d,f,g){let k=[];h.pos=i[a][0].p,await L(q,a),r[a]=q.pos;let l=j[b],m=2*l.F.n8,n=Math.floor(1048576/m),o=d;for(let a=0;a<c;a+=n){e&&e.debug(`processing: ${g}: ${a}/${c}`);let b=Math.min(c-a,n),d=await h.read(b*m),i=await l.batchApplyKey(d,o,f),r=q.write(i),s=await l.batchLEMtoC(i);if(p.update(s),await r,0==a)for(let a=0;a<Math.min(2,c);a++)k.push(l.fromRprLEM(i,a*m));o=j.Fr.mul(o,j.Fr.exp(f,b))}return await M(q),k}async function w(a,b,c,d,f){let g=j[b],h=2*g.F.n8,i=Math.floor(0x1000000/h),k=a.pos;a.pos=r[c];for(let b=0;b<d;b+=i){e&&b&&e.debug(`Hashing ${f}: `+b);let c=Math.min(d-b,i),j=await a.read(c*h),k=await g.batchLEMtoU(j);u.update(k)}a.pos=k}}async function bS(a,b,c){let{fd:d,sections:e}=await J(a,"ptau",1),{curve:f,power:g}=await bx(d,e),h=await K(b,"ptau",1,11);async function i(a,b,i,j){c&&c.debug("Starting section: "+j),await L(h,b);for(let a=0;a<=g;a++)await k(a);async function k(b){let k,l=2**b,m=f[i];f.Fr;let n=2*m.F.n8;m.F.n8,k=new s.Zh(l*n),await N(d,e,a),2==a&&b==g+1?(await d.readToBuffer(k,0,(l-1)*n),k.set(f.G1.zeroAffine,(l-1)*n)):await d.readToBuffer(k,0,l*n),await O(d,!0),k=await m.lagrangeEvaluations(k,"affine","affine",c,j),await h.write(k)}2==a&&await k(g+1),await M(h)}await bw(h,f,g),await R(d,e,h,2),await R(d,e,h,3),await R(d,e,h,4),await R(d,e,h,5),await R(d,e,h,6),await R(d,e,h,7),await i(2,12,"G1","tauG1"),await i(3,13,"G2","tauG2"),await i(4,14,"G1","alphaTauG1"),await i(5,15,"G1","betaTauG1"),await d.close(),await h.close()}async function bT(a,b,c){let{fd:d,sections:e}=await J(a,"ptau",1),{curve:f,power:g,ceremonyPower:h}=await bx(d,e),i=2*f.G1.F.n8,j=2*f.G2.F.n8;for(let a=1;a<g;a++)await k(a);return await d.close(),!0;async function k(a){let g=a.toString();for(;g.length<2;)g="0"+g;c&&c.debug("Writing Power: "+g);let k=await K(b+g+".ptau","ptau",1,11);await bw(k,f,a,h),await R(d,e,k,2,(2**a*2-1)*i),await R(d,e,k,3,2**a*j),await R(d,e,k,4,2**a*i),await R(d,e,k,5,2**a*i),await R(d,e,k,6,j),await R(d,e,k,7),await R(d,e,k,12,(2**(a+1)*2-1)*i),await R(d,e,k,13,(2**a*2-1)*j),await R(d,e,k,14,(2**a*2-1)*i),await R(d,e,k,15,(2**a*2-1)*i),await k.close()}}async function bU(a,b,c){let{fd:d,sections:e}=await J(a,"ptau",1),{curve:f,power:g}=await bx(d,e),h=await K(b,"ptau",1,11);async function i(a,b,i,j){c&&c.debug("Starting section: "+j),await L(h,b);let k=e[b][0].size,l=d.pageSize;await N(d,e,b);for(let a=0;a<k;a+=l){let b=Math.min(k-a,l),c=await d.read(b);await h.write(c)}async function m(b){let k,l=2**b,m=f[i],n=2*m.F.n8;k=new s.Zh(l*n),await N(d,e,a),2==a&&b==g+1?(await d.readToBuffer(k,0,(l-1)*n),k.set(f.G1.zeroAffine,(l-1)*n)):await d.readToBuffer(k,0,l*n),await O(d,!0),k=await m.lagrangeEvaluations(k,"affine","affine",c,j),await h.write(k)}await O(d),2==a&&await m(g+1),await M(h)}await bw(h,f,g),await R(d,e,h,2),await R(d,e,h,3),await R(d,e,h,4),await R(d,e,h,5),await R(d,e,h,6),await R(d,e,h,7),await i(2,12,"G1","tauG1"),await R(d,e,h,13),await R(d,e,h,14),await R(d,e,h,15),await d.close(),await h.close()}async function bV(a,b){let{fd:c,sections:d}=await J(a,"ptau",1),{curve:e,power:f}=await bx(c,d),g={};return g.q=e.q,g.power=f,g.contributions=await bD(c,e,d),g.tauG1=await h(2,"G1",2**f*2-1,"tauG1"),g.tauG2=await h(3,"G2",2**f,"tauG2"),g.alphaTauG1=await h(4,"G1",2**f,"alphaTauG1"),g.betaTauG1=await h(5,"G1",2**f,"betaTauG1"),g.betaG2=await h(6,"G2",1,"betaG2"),g.lTauG1=await i(12,"G1","lTauG1"),g.lTauG2=await i(13,"G2","lTauG2"),g.lAlphaTauG1=await i(14,"G1","lAlphaTauG2"),g.lBetaTauG1=await i(15,"G1","lBetaTauG2"),await c.close(),aR(e.Fr,g);async function h(a,f,g,h){let i=e[f],j=2*i.F.n8,k=[];await N(c,d,a);for(let a=0;a<g;a++){b&&a&&a%1e4==0&&console.log(`${h}: `+a);let d=await c.read(j);k.push(i.fromRprLEM(d,0))}return await O(c),k}async function i(a,g,h){let i=e[g],j=2*i.F.n8,k=[];await N(c,d,a);for(let a=0;a<=f;a++){b&&console.log(`${h}: Power: ${a}`),k[a]=[];let d=2**a;for(let e=0;e<d;e++){b&&e&&e%1e4==0&&console.log(`${h}: ${e}/${d}`);let f=await c.read(j);k[a].push(i.fromRprLEM(f,0))}}return await O(c,!0),k}}function bW(a,b,c){for(let d=0;d<a.constraints.length;d++)!function(d){let e=c=>{let d="";return Object.keys(c).forEach(e=>{let f=b.varIdx2Name[e];"one"==f&&(f="1");let g=a.curve.Fr.toString(c[e]);"1"==g&&(g=""),"-1"==g&&(g="-"),""!=d&&"-"!=g[0]&&(g="+"+g),""!=d&&(g=" "+g),d=d+g+f}),d},f=`[ ${e(d[0])} ] * [ ${e(d[1])} ] - [ ${e(d[2])} ] = 0`;c&&c.info(f)}(a.constraints[d])}let bX=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];function bY(a,b){if(!b||10==b)return BigInt(a);if(16==b)if("0x"==a.slice(0,2))return BigInt(a);else return BigInt("0x"+a)}function bZ(a){let b=a.toString(16);return(b.length-1)*4+bX[parseInt(b[0],16)]}function b$(a,b){return BigInt(a)<<BigInt(b)}function b_(a,b){return BigInt(a)>>BigInt(b)}function b0(a){return(BigInt(a)&BigInt(1))==BigInt(1)}function b1(a,b){return BigInt(a)+BigInt(b)}function b2(a,b){return BigInt(a)-BigInt(b)}function b3(a,b){return BigInt(a)**BigInt(b)}function b4(a,b){return BigInt(a)/BigInt(b)}function b5(a,b){return BigInt(a)%BigInt(b)}function b6(a,b){return BigInt(a)==BigInt(b)}function b7(a,b){return BigInt(a)>BigInt(b)}function b8(a,b){return BigInt(a)&BigInt(b)}function b9(a,b,c,d){let e="0000000"+c.toString(16),f=new Uint32Array(a.buffer,a.byteOffset+b,d/4),g=((e.length-7)*4-1>>5)+1;for(let a=0;a<g;a++)f[a]=parseInt(e.substring(e.length-8*a-8,e.length-8*a),16);for(let a=g;a<f.length;a++)f[a]=0;for(let b=4*f.length;b<d;b++)a[b]=function(a){if(a>BigInt(Number.MAX_SAFE_INTEGER))throw Error("Number too big");return Number(a)}(b8(b_(c,8*b),255))}function ca(a,b,c){c=c||a.byteLength,b=b||0;let d=new Uint32Array(a.buffer,a.byteOffset+b,c/4),e=Array(c/4);return d.forEach((a,b)=>e[e.length-b-1]=a.toString(16).padStart(8,"0")),bY(e.join(""),16)}function cb(a){let b=new Uint8Array(Math.floor((bZ(a)-1)/8)+1);return b9(b,0,a,b.byteLength),b}let cc=bY(0),cd=bY(1),ce=[];for(let a=0;a<256;a++)ce[a]=function(a,b){let c=0,d=a;for(let a=0;a<8;a++)c<<=1,c|=1&d,d>>=1;return c}(a,8);function cf(a,b,c){if(!c)return a.one;let d=function(a){let b=BigInt(a),c=[];for(;b;)b&BigInt(1)?c.push(1):c.push(0),b>>=BigInt(1);return c}(c);if(0==d.length)return a.one;let e=b;for(let c=d.length-2;c>=0;c--)e=a.square(e),d[c]&&(e=a.mul(e,b));return e}function cg(a,b,c,d,e){a[b]=a[b]+a[c]>>>0,a[e]=(a[e]^a[b])>>>0,a[e]=(a[e]<<16|a[e]>>>16&65535)>>>0,a[d]=a[d]+a[e]>>>0,a[c]=(a[c]^a[d])>>>0,a[c]=(a[c]<<12|a[c]>>>20&4095)>>>0,a[b]=a[b]+a[c]>>>0,a[e]=(a[e]^a[b])>>>0,a[e]=(a[e]<<8|a[e]>>>24&255)>>>0,a[d]=a[d]+a[e]>>>0,a[c]=(a[c]^a[d])>>>0,a[c]=(a[c]<<7|a[c]>>>25&127)>>>0}class ch{constructor(a){a=a||[0,0,0,0,0,0,0,0],this.state=[0x61707865,0x3320646e,0x79622d32,0x6b206574,a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],0,0,0,0],this.idx=16,this.buff=Array(16)}nextU32(){return 16==this.idx&&this.update(),this.buff[this.idx++]}nextU64(){return b1(BigInt(this.nextU32())*BigInt(0x100000000),this.nextU32())}nextBool(){return(1&this.nextU32())==1}update(){for(let a=0;a<16;a++)this.buff[a]=this.state[a];for(let b=0;b<10;b++){var a;cg(a=this.buff,0,4,8,12),cg(a,1,5,9,13),cg(a,2,6,10,14),cg(a,3,7,11,15),cg(a,0,5,10,15),cg(a,1,6,11,12),cg(a,2,7,8,13),cg(a,3,4,9,14)}for(let a=0;a<16;a++)this.buff[a]=this.buff[a]+this.state[a]>>>0;this.idx=0,this.state[12]=this.state[12]+1>>>0,0!=this.state[12]||(this.state[13]=this.state[13]+1>>>0,0!=this.state[13]||(this.state[14]=this.state[14]+1>>>0,0==this.state[14]&&(this.state[15]=this.state[15]+1>>>0)))}}function ci(a){let b=new Uint8Array(a);return aC.randomFillSync(b),b}let cj=null;function ck(){return cj||(cj=new ch(function(){let a=new Uint32Array(ci(32).buffer),b=[];for(let c=0;c<8;c++)b.push(a[c]);return b}()))}class cl{constructor(a,b,c){this.F=b,this.G=a,this.opMulGF=c;let d=b.sqrt_t||b.t,e=b.sqrt_s||b.s,f=b.one;for(;b.eq(b.pow(f,b.half),b.one);)f=b.add(f,b.one);this.w=Array(e+1),this.wi=Array(e+1),this.w[e]=this.F.pow(f,d),this.wi[e]=this.F.inv(this.w[e]);let g=e-1;for(;g>=0;)this.w[g]=this.F.square(this.w[g+1]),this.wi[g]=this.F.square(this.wi[g+1]),g--;this.roots=[],this._setRoots(Math.min(e,15))}_setRoots(a){for(let b=a;b>=0&&!this.roots[b];b--){let a=this.F.one,c=1<<b,d=Array(c);for(let e=0;e<c;e++)d[e]=a,a=this.F.mul(a,this.w[b]);this.roots[b]=d}}fft(a){if(a.length<=1)return a;let b=cm(a.length-1)+1;this._setRoots(b);let c=1<<b;if(a.length!=c)throw Error("Size must be multiple of 2");return cn(this,a,b,0,1)}ifft(a){if(a.length<=1)return a;let b=cm(a.length-1)+1;this._setRoots(b);let c=1<<b;if(a.length!=c)throw Error("Size must be multiple of 2");let d=cn(this,a,b,0,1),e=this.F.inv(this.F.mulScalar(this.F.one,c)),f=Array(c);for(let a=0;a<c;a++)f[a]=this.opMulGF(d[(c-a)%c],e);return f}}function cm(a){return((0xffff0000&a)!=0?(a&=0xffff0000,16):0)|((0xff00ff00&a)!=0?(a&=0xff00ff00,8):0)|((0xf0f0f0f0&a)!=0?(a&=0xf0f0f0f0,4):0)|((0xcccccccc&a)!=0?(a&=0xcccccccc,2):0)|(0xaaaaaaaa&a)!=0}function cn(a,b,c,d,e){let f=1<<c;if(1==f)return[b[d]];if(2==f)return[a.G.add(b[d],b[d+e]),a.G.sub(b[d],b[d+e])];let g=f>>1,h=cn(a,b,c-1,d,2*e),i=cn(a,b,c-1,d+e,2*e),j=Array(f);for(let b=0;b<g;b++)j[b]=a.G.add(h[b],a.opMulGF(i[b],a.roots[c][b])),j[b+g]=a.G.sub(h[b],a.opMulGF(i[b],a.roots[c][b]));return j}class co{constructor(a){this.type="F1",this.one=BigInt(1),this.zero=BigInt(0),this.p=BigInt(a),this.m=1,this.negone=this.p-this.one,this.two=BigInt(2),this.half=this.p>>this.one,this.bitLength=bZ(this.p),this.mask=(this.one<<BigInt(this.bitLength))-this.one,this.n64=Math.floor((this.bitLength-1)/64)+1,this.n32=2*this.n64,this.n8=8*this.n64,this.R=this.e(this.one<<BigInt(64*this.n64)),this.Ri=this.inv(this.R);const b=this.negone>>this.one;this.nqr=this.two;let c=this.pow(this.nqr,b);for(;!this.eq(c,this.negone);)this.nqr=this.nqr+this.one,c=this.pow(this.nqr,b);for(this.s=0,this.t=this.negone;(this.t&this.one)==this.zero;)this.s=this.s+1,this.t=this.t>>this.one;this.nqr_to_t=this.pow(this.nqr,this.t),function(a){if(a.m%2==1)if(b6(b5(a.p,4),1))if(b6(b5(a.p,8),1))if(b6(b5(a.p,16),1)){var b,c,d=a;for(d.sqrt_q=b3(d.p,d.m),d.sqrt_s=0,d.sqrt_t=b2(d.sqrt_q,1);!b0(d.sqrt_t);)d.sqrt_s=d.sqrt_s+1,d.sqrt_t=b4(d.sqrt_t,2);let e=d.one;for(;d.eq(e,d.one);){let a=d.random();d.sqrt_z=d.pow(a,d.sqrt_t),e=d.pow(d.sqrt_z,2**(d.sqrt_s-1))}d.sqrt_tm1d2=b4(b2(d.sqrt_t,1),2),d.sqrt=function(a){if(this.isZero(a))return this.zero;let b=this.pow(a,this.sqrt_tm1d2),c=this.pow(this.mul(this.square(b),a),2**(this.sqrt_s-1));if(this.eq(c,this.negone))return null;let d=this.sqrt_s,e=this.mul(a,b),f=this.mul(e,b),g=this.sqrt_z;for(;!this.eq(f,this.one);){let a=this.square(f),c=1;for(;!this.eq(a,this.one);)a=this.square(a),c++;b=g;for(let a=0;a<d-c-1;a++)b=this.square(b);g=this.square(b),f=this.mul(f,g),e=this.mul(e,b),d=c}return this.geq(e,this.zero)?e:this.neg(e)}}else if(b6(b5(a.p,16),9))a.sqrt=function(){throw Error("Sqrt alg 4 not implemented")};else throw Error("Field withot sqrt");else if(b6(b5(a.p,8),5))a.sqrt=function(){throw Error("Sqrt alg 3 not implemented")};else throw Error("Field withot sqrt");else{b6(b5(a.p,4),3)&&((b=a).sqrt_q=b3(b.p,b.m),b.sqrt_e1=b4(b2(b.sqrt_q,3),4),b.sqrt=function(a){if(this.isZero(a))return this.zero;let c=this.pow(a,this.sqrt_e1),d=this.mul(this.square(c),a);if(this.eq(d,this.negone))return null;let e=this.mul(c,a);return b.geq(e,b.zero)?e:b.neg(e)})}else{let b=b5(b3(a.p,a.m/2),4);1==b?a.sqrt=function(){throw Error("Sqrt alg 10 not implemented")}:3==b?((c=a).sqrt_q=b3(c.p,c.m/2),c.sqrt_e34=b4(b2(c.sqrt_q,3),4),c.sqrt_e12=b4(b2(c.sqrt_q,1),2),c.frobenius=function(a,b){return a%2==1?c.conjugate(b):b},c.sqrt=function(a){let b,c=this.pow(a,this.sqrt_e34),d=this.mul(this.square(c),a),e=this.mul(this.frobenius(1,d),d);if(this.eq(e,this.negone))return null;let f=this.mul(c,a);if(this.eq(d,this.negone))b=this.mul(f,[this.F.zero,this.F.one]);else{let a=this.pow(this.add(this.one,d),this.sqrt_e12);b=this.mul(a,f)}return this.geq(b,this.zero)?b:this.neg(b)}):a.sqrt=function(){throw Error("Sqrt alg 8 not implemented")}}}(this),this.FFT=new cl(this,this,this.mul.bind(this)),this.fft=this.FFT.fft.bind(this.FFT),this.ifft=this.FFT.ifft.bind(this.FFT),this.w=this.FFT.w,this.wi=this.FFT.wi,this.shift=this.square(this.nqr),this.k=this.exp(this.nqr,2**this.s)}e(a,b){let c;if(b?16==b&&(c=BigInt("0x"+a)):c=BigInt(a),!(c<0))return c>=this.p?c%this.p:c;{let a=-c;return a>=this.p&&(a%=this.p),this.p-a}}add(a,b){let c=a+b;return c>=this.p?c-this.p:c}sub(a,b){return a>=b?a-b:this.p-b+a}neg(a){return a?this.p-a:a}mul(a,b){return a*b%this.p}mulScalar(a,b){return a*this.e(b)%this.p}square(a){return a*a%this.p}eq(a,b){return a==b}neq(a,b){return a!=b}lt(a,b){return(a>this.half?a-this.p:a)<(b>this.half?b-this.p:b)}gt(a,b){return(a>this.half?a-this.p:a)>(b>this.half?b-this.p:b)}leq(a,b){return(a>this.half?a-this.p:a)<=(b>this.half?b-this.p:b)}geq(a,b){return(a>this.half?a-this.p:a)>=(b>this.half?b-this.p:b)}div(a,b){return this.mul(a,this.inv(b))}idiv(a,b){if(!b)throw Error("Division by zero");return a/b}inv(a){if(!a)throw Error("Division by zero");let b=this.zero,c=this.p,d=this.one,e=a%this.p;for(;e;){let a=c/e;[b,d]=[d,b-a*d],[c,e]=[e,c-a*e]}return b<this.zero&&(b+=this.p),b}mod(a,b){return a%b}pow(a,b){return cf(this,a,b)}exp(a,b){return cf(this,a,b)}band(a,b){let c=a&b&this.mask;return c>=this.p?c-this.p:c}bor(a,b){let c=(a|b)&this.mask;return c>=this.p?c-this.p:c}bxor(a,b){let c=(a^b)&this.mask;return c>=this.p?c-this.p:c}bnot(a){let b=a^this.mask;return b>=this.p?b-this.p:b}shl(a,b){if(Number(b)<this.bitLength){let c=a<<b&this.mask;return c>=this.p?c-this.p:c}{let c=this.p-b;return Number(c)<this.bitLength?a>>c:this.zero}}shr(a,b){if(Number(b)<this.bitLength)return a>>b;{let c=this.p-b;if(!(Number(c)<this.bitLength))return 0;{let b=a<<c&this.mask;return b>=this.p?b-this.p:b}}}land(a,b){return a&&b?this.one:this.zero}lor(a,b){return a||b?this.one:this.zero}lnot(a){return a?this.zero:this.one}sqrt_old(a){if(a==this.zero)return this.zero;if(this.pow(a,this.negone>>this.one)!=this.one)return null;let b=this.s,c=this.nqr_to_t,d=this.pow(a,this.t),e=this.pow(a,this.add(this.t,this.one)>>this.one);for(;d!=this.one;){let a=this.square(d),f=1;for(;a!=this.one;)f++,a=this.square(a);let g=c;for(let a=0;a<b-f-1;a++)g=this.square(g);b=f,c=this.square(g),d=this.mul(d,c),e=this.mul(e,g)}return e>this.p>>this.one&&(e=this.neg(e)),e}normalize(a,b){if(!((a=BigInt(a,b))<0))return a>=this.p?a%this.p:a;{let b=-a;return b>=this.p&&(b%=this.p),this.p-b}}random(){let a=2*this.bitLength/8,b=this.zero;for(let c=0;c<a;c++)b=(b<<BigInt(8))+BigInt(ci(1)[0]);return b%this.p}toString(a,b){return b=b||10,a>this.half&&10==b?"-"+(this.p-a).toString(b):a.toString(b)}isZero(a){return a==this.zero}fromRng(a){let b;do{b=this.zero;for(let c=0;c<this.n64;c++)b+=a.nextU64()<<BigInt(64*c);b&=this.mask}while(b>=this.p);return b*this.Ri%this.p}fft(a){return this.FFT.fft(a)}ifft(a){return this.FFT.ifft(a)}toRprLE(a,b,c){b9(a,b,c,8*this.n64)}toRprBE(a,b,c){!function(a,b,c,d){let e="0000000"+c.toString(16),f=new DataView(a.buffer,a.byteOffset+b,d),g=((e.length-7)*4-1>>5)+1;for(let a=0;a<g;a++)f.setUint32(d-4*a-4,parseInt(e.substring(e.length-8*a-8,e.length-8*a),16),!1);for(let a=0;a<d/4-g;a++)f[a]=0}(a,b,c,8*this.n64)}toRprBEM(a,b,c){return this.toRprBE(a,b,this.mul(this.R,c))}toRprLEM(a,b,c){return this.toRprLE(a,b,this.mul(this.R,c))}fromRprLE(a,b){return ca(a,b,this.n8)}fromRprBE(a,b){return function(a,b,c){c=c||a.byteLength,b=b||0;let d=new DataView(a.buffer,a.byteOffset+b,c),e=Array(c/4);for(let a=0;a<c/4;a++)e[a]=d.getUint32(4*a,!1).toString(16).padStart(8,"0");return bY(e.join(""),16)}(a,b,this.n8)}fromRprLEM(a,b){return this.mul(this.fromRprLE(a,b),this.Ri)}fromRprBEM(a,b){return this.mul(this.fromRprBE(a,b),this.Ri)}toObject(a){return a}}var cp=c(9426);let cq=[];for(let a=0;a<256;a++)cq[a]=function(a,b){let c=0,d=a;for(let a=0;a<8;a++)c<<=1,c|=1&d,d>>=1;return c}(a,8);function cr(a){return((0xffff0000&a)!=0?(a&=0xffff0000,16):0)|((0xff00ff00&a)!=0?(a&=0xff00ff00,8):0)|((0xf0f0f0f0&a)!=0?(a&=0xf0f0f0f0,4):0)|((0xcccccccc&a)!=0?(a&=0xcccccccc,2):0)|(0xaaaaaaaa&a)!=0}function cs(a,b){let c=new Uint8Array(b*a.length);for(let d=0;d<a.length;d++)c.set(a[d],d*b);return c}function ct(a,b){let c=a.byteLength/b,d=Array(c);for(let e=0;e<c;e++)d[e]=a.slice(e*b,e*b+b);return d}class cu{constructor(a){this.buffers=[],this.byteLength=a;for(let b=0;b<a;b+=0x40000000){const c=Math.min(a-b,0x40000000);this.buffers.push(new Uint8Array(c))}}slice(a,b){let c;void 0===b&&(b=this.byteLength),void 0===a&&(a=0);let d=b-a,e=Math.floor(a/0x40000000);if(e==Math.floor((a+d-1)/0x40000000)||0==d)return this.buffers[e].slice(a%0x40000000,a%0x40000000+d);let f=e,g=a%0x40000000,h=d;for(;h>0;){let a=g+h>0x40000000?0x40000000-g:h,b=new Uint8Array(this.buffers[f].buffer,this.buffers[f].byteOffset+g,a);if(a==d)return b.slice();c||(c=d<=0x40000000?new Uint8Array(d):new cu(d)),c.set(b,d-h),h-=a,f++,g=0}return c}set(a,b){void 0===b&&(b=0);let c=a.byteLength;if(0==c)return;let d=Math.floor(b/0x40000000);if(d==Math.floor((b+c-1)/0x40000000))if(a instanceof cu&&1==a.buffers.length)return this.buffers[d].set(a.buffers[0],b%0x40000000);else return this.buffers[d].set(a,b%0x40000000);let e=d,f=b%0x40000000,g=c;for(;g>0;){let b=f+g>0x40000000?0x40000000-f:g,d=a.slice(c-g,c-g+b);new Uint8Array(this.buffers[e].buffer,this.buffers[e].byteOffset+f,b).set(d),g-=b,e++,f=0}}}function cv(a,b,c,d){return async function(e){let f,g=Math.floor(e.byteLength/c);if(g*c!==e.byteLength)throw Error("Invalid buffer size");let h=Math.floor(g/a.concurrency),i=[];for(let f=0;f<a.concurrency;f++){let j;if(0==(j=f<a.concurrency-1?h:g-f*h))continue;let k=[{cmd:"ALLOCSET",var:0,buff:e.slice(f*h*c,f*h*c+j*c)},{cmd:"ALLOC",var:1,len:d*j},{cmd:"CALL",fnName:b,params:[{var:0},{val:j},{var:1}]},{cmd:"GET",out:0,var:1,len:d*j}];i.push(a.queueAction(k))}let j=await Promise.all(i);f=e instanceof cu?new cu(g*d):new Uint8Array(g*d);let k=0;for(let a=0;a<j.length;a++)f.set(j[a][0],k),k+=j[a][0].byteLength;return f}}class cw{constructor(a,b,c,d){if(this.tm=a,this.prefix=b,this.p=d,this.n8=c,this.type="F1",this.m=1,this.half=b_(d,cd),this.bitLength=bZ(d),this.mask=b2(b$(cd,this.bitLength),cd),this.pOp1=a.alloc(c),this.pOp2=a.alloc(c),this.pOp3=a.alloc(c),this.tm.instance.exports[b+"_zero"](this.pOp1),this.zero=this.tm.getBuff(this.pOp1,this.n8),this.tm.instance.exports[b+"_one"](this.pOp1),this.one=this.tm.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one),this.n64=Math.floor(c/8),this.n32=Math.floor(c/4),8*this.n64!=this.n8)throw Error("n8 must be a multiple of 8");this.half=b_(this.p,cd),this.nqr=this.two;let e=this.exp(this.nqr,this.half);for(;!this.eq(e,this.negone);)this.nqr=this.add(this.nqr,this.one),e=this.exp(this.nqr,this.half);this.shift=this.mul(this.nqr,this.nqr),this.shiftInv=this.inv(this.shift),this.s=0;let f=b2(this.p,cd);for(;!b0(f);)this.s=this.s+1,f=b_(f,cd);this.w=[],this.w[this.s]=this.exp(this.nqr,f);for(let a=this.s-1;a>=0;a--)this.w[a]=this.square(this.w[a+1]);if(!this.eq(this.w[0],this.one))throw Error("Error calculating roots of unity");this.batchToMontgomery=cv(a,b+"_batchToMontgomery",this.n8,this.n8),this.batchFromMontgomery=cv(a,b+"_batchFromMontgomery",this.n8,this.n8)}op2(a,b,c){return this.tm.setBuff(this.pOp1,b),this.tm.setBuff(this.pOp2,c),this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(a,b,c){return this.tm.setBuff(this.pOp1,b),this.tm.setBuff(this.pOp2,c),!!this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp2)}op1(a,b){return this.tm.setBuff(this.pOp1,b),this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(a,b){return this.tm.setBuff(this.pOp1,b),!!this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp3)}add(a,b){return this.op2("_add",a,b)}eq(a,b){return this.op2Bool("_eq",a,b)}isZero(a){return this.op1Bool("_isZero",a)}sub(a,b){return this.op2("_sub",a,b)}neg(a){return this.op1("_neg",a)}inv(a){return this.op1("_inverse",a)}toMontgomery(a){return this.op1("_toMontgomery",a)}fromMontgomery(a){return this.op1("_fromMontgomery",a)}mul(a,b){return this.op2("_mul",a,b)}div(a,b){return this.tm.setBuff(this.pOp1,a),this.tm.setBuff(this.pOp2,b),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(a){return this.op1("_square",a)}isSquare(a){return this.op1Bool("_isSquare",a)}sqrt(a){return this.op1("_sqrt",a)}exp(a,b){return b instanceof Uint8Array||(b=cb(bY(b))),this.tm.setBuff(this.pOp1,a),this.tm.setBuff(this.pOp2,b),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,b.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}isNegative(a){return this.op1Bool("_isNegative",a)}e(a,b){if(a instanceof Uint8Array)return a;let c=bY(a,b);BigInt(c)<BigInt(0)?(b7(c=-BigInt(c),this.p)&&(c=b5(c,this.p)),c=b2(this.p,c)):b7(c,this.p)&&(c=b5(c,this.p));let d=function(a,b){let c=a;void 0===b&&0==(b=Math.floor((bZ(a)-1)/8)+1)&&(b=1);let d=new Uint8Array(b),e=new DataView(d.buffer),f=0;for(;f<b;)f+4<=b?(e.setUint32(f,Number(c&BigInt(0xffffffff)),!0),f+=4,c>>=BigInt(32)):f+2<=b?(e.setUint16(f,Number(c&BigInt(65535)),!0),f+=2,c>>=BigInt(16)):(e.setUint8(f,Number(c&BigInt(255)),!0),f+=1,c>>=BigInt(8));if(c)throw Error("Number does not fit in this length");return d}(c,this.n8);return this.toMontgomery(d)}toString(a,b){var c;return c=ca(this.fromMontgomery(a),0),c.toString(b)}fromRng(a){var b,c;let d,e=new Uint8Array(this.n8);do{d=cc;for(let b=0;b<this.n64;b++)d=b1(d,b$(a.nextU64(),64*b));d=b8(d,this.mask)}while(b=d,c=this.p,BigInt(b)>=BigInt(c));return b9(e,0,d,this.n8),e}random(){return this.fromRng(ck())}toObject(a){return ca(this.fromMontgomery(a),0)}fromObject(a){let b=new Uint8Array(this.n8);return b9(b,0,a,this.n8),this.toMontgomery(b)}toRprLE(a,b,c){a.set(this.fromMontgomery(c),b)}toRprBE(a,b,c){let d=this.fromMontgomery(c);for(let a=0;a<this.n8/2;a++){let b=d[a];d[a]=d[this.n8-1-a],d[this.n8-1-a]=b}a.set(d,b)}fromRprLE(a,b){b=b||0;let c=a.slice(b,b+this.n8);return this.toMontgomery(c)}async batchInverse(a){let b,c=!1,d=this.n8,e=this.n8;Array.isArray(a)?(a=cs(a,d),c=!0):a=a.slice(0,a.byteLength);let f=Math.floor(a.byteLength/d);if(f*d!==a.byteLength)throw Error("Invalid buffer size");let g=Math.floor(f/this.tm.concurrency),h=[];for(let b=0;b<this.tm.concurrency;b++){let c;if(0==(c=b<this.tm.concurrency-1?g:f-b*g))continue;let i=[{cmd:"ALLOCSET",var:0,buff:a.slice(b*g*d,b*g*d+c*d)},{cmd:"ALLOC",var:1,len:e*c},{cmd:"CALL",fnName:this.prefix+"_batchInverse",params:[{var:0},{val:d},{val:c},{var:1},{val:e}]},{cmd:"GET",out:0,var:1,len:e*c}];h.push(this.tm.queueAction(i))}let i=await Promise.all(h);b=a instanceof cu?new cu(f*e):new Uint8Array(f*e);let j=0;for(let a=0;a<i.length;a++)b.set(i[a][0],j),j+=i[a][0].byteLength;return c?ct(b,e):b}}class cx{constructor(a,b,c){this.tm=a,this.prefix=b,this.F=c,this.type="F2",this.m=2*c.m,this.n8=2*this.F.n8,this.n32=2*this.F.n32,this.n64=2*this.F.n64,this.pOp1=a.alloc(2*c.n8),this.pOp2=a.alloc(2*c.n8),this.pOp3=a.alloc(2*c.n8),this.tm.instance.exports[b+"_zero"](this.pOp1),this.zero=a.getBuff(this.pOp1,this.n8),this.tm.instance.exports[b+"_one"](this.pOp1),this.one=a.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one)}op2(a,b,c){return this.tm.setBuff(this.pOp1,b),this.tm.setBuff(this.pOp2,c),this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(a,b,c){return this.tm.setBuff(this.pOp1,b),this.tm.setBuff(this.pOp2,c),!!this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp2)}op1(a,b){return this.tm.setBuff(this.pOp1,b),this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(a,b){return this.tm.setBuff(this.pOp1,b),!!this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp3)}add(a,b){return this.op2("_add",a,b)}eq(a,b){return this.op2Bool("_eq",a,b)}isZero(a){return this.op1Bool("_isZero",a)}sub(a,b){return this.op2("_sub",a,b)}neg(a){return this.op1("_neg",a)}inv(a){return this.op1("_inverse",a)}isNegative(a){return this.op1Bool("_isNegative",a)}toMontgomery(a){return this.op1("_toMontgomery",a)}fromMontgomery(a){return this.op1("_fromMontgomery",a)}mul(a,b){return this.op2("_mul",a,b)}mul1(a,b){return this.op2("_mul1",a,b)}div(a,b){return this.tm.setBuff(this.pOp1,a),this.tm.setBuff(this.pOp2,b),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(a){return this.op1("_square",a)}isSquare(a){return this.op1Bool("_isSquare",a)}sqrt(a){return this.op1("_sqrt",a)}exp(a,b){return b instanceof Uint8Array||(b=cb(bY(b))),this.tm.setBuff(this.pOp1,a),this.tm.setBuff(this.pOp2,b),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,b.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}e(a,b){if(a instanceof Uint8Array)return a;if(Array.isArray(a)&&2==a.length){let c=this.F.e(a[0],b),d=this.F.e(a[1],b),e=new Uint8Array(2*this.F.n8);return e.set(c),e.set(d,2*this.F.n8),e}throw Error("invalid F2")}toString(a,b){let c=this.F.toString(a.slice(0,this.F.n8),b),d=this.F.toString(a.slice(this.F.n8),b);return`[${c}, ${d}]`}fromRng(a){let b=this.F.fromRng(a),c=this.F.fromRng(a),d=new Uint8Array(2*this.F.n8);return d.set(b),d.set(c,this.F.n8),d}random(){return this.fromRng(ck())}toObject(a){return[this.F.toObject(a.slice(0,this.F.n8)),this.F.toObject(a.slice(this.F.n8,2*this.F.n8))]}fromObject(a){let b=new Uint8Array(2*this.F.n8),c=this.F.fromObject(a[0]),d=this.F.fromObject(a[1]);return b.set(c),b.set(d,this.F.n8),b}c1(a){return a.slice(0,this.F.n8)}c2(a){return a.slice(this.F.n8)}}class cy{constructor(a,b,c){this.tm=a,this.prefix=b,this.F=c,this.type="F3",this.m=3*c.m,this.n8=3*this.F.n8,this.n32=3*this.F.n32,this.n64=3*this.F.n64,this.pOp1=a.alloc(3*c.n8),this.pOp2=a.alloc(3*c.n8),this.pOp3=a.alloc(3*c.n8),this.tm.instance.exports[b+"_zero"](this.pOp1),this.zero=a.getBuff(this.pOp1,this.n8),this.tm.instance.exports[b+"_one"](this.pOp1),this.one=a.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one)}op2(a,b,c){return this.tm.setBuff(this.pOp1,b),this.tm.setBuff(this.pOp2,c),this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(a,b,c){return this.tm.setBuff(this.pOp1,b),this.tm.setBuff(this.pOp2,c),!!this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp2)}op1(a,b){return this.tm.setBuff(this.pOp1,b),this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(a,b){return this.tm.setBuff(this.pOp1,b),!!this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp3)}eq(a,b){return this.op2Bool("_eq",a,b)}isZero(a){return this.op1Bool("_isZero",a)}add(a,b){return this.op2("_add",a,b)}sub(a,b){return this.op2("_sub",a,b)}neg(a){return this.op1("_neg",a)}inv(a){return this.op1("_inverse",a)}isNegative(a){return this.op1Bool("_isNegative",a)}toMontgomery(a){return this.op1("_toMontgomery",a)}fromMontgomery(a){return this.op1("_fromMontgomery",a)}mul(a,b){return this.op2("_mul",a,b)}div(a,b){return this.tm.setBuff(this.pOp1,a),this.tm.setBuff(this.pOp2,b),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(a){return this.op1("_square",a)}isSquare(a){return this.op1Bool("_isSquare",a)}sqrt(a){return this.op1("_sqrt",a)}exp(a,b){return b instanceof Uint8Array||(b=cb(bY(b))),this.tm.setBuff(this.pOp1,a),this.tm.setBuff(this.pOp2,b),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,b.byteLength,this.pOp3),this.getBuff(this.pOp3,this.n8)}e(a,b){if(a instanceof Uint8Array)return a;if(Array.isArray(a)&&3==a.length){let c=this.F.e(a[0],b),d=this.F.e(a[1],b),e=this.F.e(a[2],b),f=new Uint8Array(3*this.F.n8);return f.set(c),f.set(d,this.F.n8),f.set(e,2*this.F.n8),f}throw Error("invalid F3")}toString(a,b){let c=this.F.toString(a.slice(0,this.F.n8),b),d=this.F.toString(a.slice(this.F.n8,2*this.F.n8),b),e=this.F.toString(a.slice(2*this.F.n8),b);return`[${c}, ${d}, ${e}]`}fromRng(a){let b=this.F.fromRng(a),c=this.F.fromRng(a),d=this.F.fromRng(a),e=new Uint8Array(3*this.F.n8);return e.set(b),e.set(c,this.F.n8),e.set(d,2*this.F.n8),e}random(){return this.fromRng(ck())}toObject(a){return[this.F.toObject(a.slice(0,this.F.n8)),this.F.toObject(a.slice(this.F.n8,2*this.F.n8)),this.F.toObject(a.slice(2*this.F.n8,3*this.F.n8))]}fromObject(a){let b=new Uint8Array(3*this.F.n8),c=this.F.fromObject(a[0]),d=this.F.fromObject(a[1]),e=this.F.fromObject(a[2]);return b.set(c),b.set(d,this.F.n8),b.set(e,2*this.F.n8),b}c1(a){return a.slice(0,this.F.n8)}c2(a){return a.slice(this.F.n8,2*this.F.n8)}c3(a){return a.slice(2*this.F.n8)}}class cz{constructor(a,b,c,d,e,f){this.tm=a,this.prefix=b,this.F=c,this.pOp1=a.alloc(3*c.n8),this.pOp2=a.alloc(3*c.n8),this.pOp3=a.alloc(3*c.n8),this.tm.instance.exports[b+"_zero"](this.pOp1),this.zero=this.tm.getBuff(this.pOp1,3*c.n8),this.tm.instance.exports[b+"_zeroAffine"](this.pOp1),this.zeroAffine=this.tm.getBuff(this.pOp1,2*c.n8),this.one=this.tm.getBuff(d,3*c.n8),this.g=this.one,this.oneAffine=this.tm.getBuff(d,2*c.n8),this.gAffine=this.oneAffine,this.b=this.tm.getBuff(e,c.n8),f&&(this.cofactor=cb(f)),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one),this.batchLEMtoC=cv(a,b+"_batchLEMtoC",2*c.n8,c.n8),this.batchLEMtoU=cv(a,b+"_batchLEMtoU",2*c.n8,2*c.n8),this.batchCtoLEM=cv(a,b+"_batchCtoLEM",c.n8,2*c.n8),this.batchUtoLEM=cv(a,b+"_batchUtoLEM",2*c.n8,2*c.n8),this.batchToJacobian=cv(a,b+"_batchToJacobian",2*c.n8,3*c.n8),this.batchToAffine=cv(a,b+"_batchToAffine",3*c.n8,2*c.n8)}op2(a,b,c){return this.tm.setBuff(this.pOp1,b),this.tm.setBuff(this.pOp2,c),this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}op2bool(a,b,c){return this.tm.setBuff(this.pOp1,b),this.tm.setBuff(this.pOp2,c),!!this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp2,this.pOp3)}op1(a,b){return this.tm.setBuff(this.pOp1,b),this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}op1Affine(a,b){return this.tm.setBuff(this.pOp1,b),this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,2*this.F.n8)}op1Bool(a,b){return this.tm.setBuff(this.pOp1,b),!!this.tm.instance.exports[this.prefix+a](this.pOp1,this.pOp3)}add(a,b){if(a.byteLength==3*this.F.n8)if(b.byteLength==3*this.F.n8)return this.op2("_add",a,b);else if(b.byteLength==2*this.F.n8)return this.op2("_addMixed",a,b);else throw Error("invalid point size");if(a.byteLength==2*this.F.n8){if(b.byteLength==3*this.F.n8)return this.op2("_addMixed",b,a);else if(b.byteLength==2*this.F.n8)return this.op2("_addAffine",a,b)}throw Error("invalid point size")}sub(a,b){if(a.byteLength==3*this.F.n8)if(b.byteLength==3*this.F.n8)return this.op2("_sub",a,b);else if(b.byteLength==2*this.F.n8)return this.op2("_subMixed",a,b);else throw Error("invalid point size");if(a.byteLength==2*this.F.n8){if(b.byteLength==3*this.F.n8)return this.op2("_subMixed",b,a);else if(b.byteLength==2*this.F.n8)return this.op2("_subAffine",a,b)}throw Error("invalid point size")}neg(a){if(a.byteLength==3*this.F.n8)return this.op1("_neg",a);if(a.byteLength==2*this.F.n8)return this.op1Affine("_negAffine",a);throw Error("invalid point size")}double(a){if(a.byteLength==3*this.F.n8)return this.op1("_double",a);if(a.byteLength==2*this.F.n8)return this.op1("_doubleAffine",a);throw Error("invalid point size")}isZero(a){if(a.byteLength==3*this.F.n8)return this.op1Bool("_isZero",a);if(a.byteLength==2*this.F.n8)return this.op1Bool("_isZeroAffine",a);throw Error("invalid point size")}timesScalar(a,b){let c;if(b instanceof Uint8Array||(b=cb(bY(b))),a.byteLength==3*this.F.n8)c=this.prefix+"_timesScalar";else if(a.byteLength==2*this.F.n8)c=this.prefix+"_timesScalarAffine";else throw Error("invalid point size");return this.tm.setBuff(this.pOp1,a),this.tm.setBuff(this.pOp2,b),this.tm.instance.exports[c](this.pOp1,this.pOp2,b.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}timesFr(a,b){let c;if(a.byteLength==3*this.F.n8)c=this.prefix+"_timesFr";else if(a.byteLength==2*this.F.n8)c=this.prefix+"_timesFrAffine";else throw Error("invalid point size");return this.tm.setBuff(this.pOp1,a),this.tm.setBuff(this.pOp2,b),this.tm.instance.exports[c](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,3*this.F.n8)}eq(a,b){if(a.byteLength==3*this.F.n8)if(b.byteLength==3*this.F.n8)return this.op2bool("_eq",a,b);else if(b.byteLength==2*this.F.n8)return this.op2bool("_eqMixed",a,b);else throw Error("invalid point size");if(a.byteLength==2*this.F.n8){if(b.byteLength==3*this.F.n8)return this.op2bool("_eqMixed",b,a);else if(b.byteLength==2*this.F.n8)return this.op2bool("_eqAffine",a,b)}throw Error("invalid point size")}toAffine(a){if(a.byteLength==3*this.F.n8)return this.op1Affine("_toAffine",a);if(a.byteLength==2*this.F.n8)return a;throw Error("invalid point size")}toJacobian(a){if(a.byteLength==3*this.F.n8)return a;if(a.byteLength==2*this.F.n8)return this.op1("_toJacobian",a);throw Error("invalid point size")}toRprUncompressed(a,b,c){if(this.tm.setBuff(this.pOp1,c),c.byteLength==3*this.F.n8)this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);else if(c.byteLength!=2*this.F.n8)throw Error("invalid point size");this.tm.instance.exports[this.prefix+"_LEMtoU"](this.pOp1,this.pOp1);let d=this.tm.getBuff(this.pOp1,2*this.F.n8);a.set(d,b)}fromRprUncompressed(a,b){let c=a.slice(b,b+2*this.F.n8);return this.tm.setBuff(this.pOp1,c),this.tm.instance.exports[this.prefix+"_UtoLEM"](this.pOp1,this.pOp1),this.tm.getBuff(this.pOp1,2*this.F.n8)}toRprCompressed(a,b,c){if(this.tm.setBuff(this.pOp1,c),c.byteLength==3*this.F.n8)this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);else if(c.byteLength!=2*this.F.n8)throw Error("invalid point size");this.tm.instance.exports[this.prefix+"_LEMtoC"](this.pOp1,this.pOp1);let d=this.tm.getBuff(this.pOp1,this.F.n8);a.set(d,b)}fromRprCompressed(a,b){let c=a.slice(b,b+this.F.n8);return this.tm.setBuff(this.pOp1,c),this.tm.instance.exports[this.prefix+"_CtoLEM"](this.pOp1,this.pOp2),this.tm.getBuff(this.pOp2,2*this.F.n8)}toUncompressed(a){let b=new Uint8Array(2*this.F.n8);return this.toRprUncompressed(b,0,a),b}toRprLEM(a,b,c){if(c.byteLength==2*this.F.n8)return void a.set(c,b);if(c.byteLength==3*this.F.n8){this.tm.setBuff(this.pOp1,c),this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);let d=this.tm.getBuff(this.pOp1,2*this.F.n8);a.set(d,b)}else throw Error("invalid point size")}fromRprLEM(a,b){return b=b||0,a.slice(b,b+2*this.F.n8)}toString(a,b){if(a.byteLength==3*this.F.n8){let c=this.F.toString(a.slice(0,this.F.n8),b),d=this.F.toString(a.slice(this.F.n8,2*this.F.n8),b),e=this.F.toString(a.slice(2*this.F.n8),b);return`[ ${c}, ${d}, ${e} ]`}if(a.byteLength==2*this.F.n8){let c=this.F.toString(a.slice(0,this.F.n8),b),d=this.F.toString(a.slice(this.F.n8),b);return`[ ${c}, ${d} ]`}throw Error("invalid point size")}isValid(a){if(this.isZero(a))return!0;let b=this.F,c=this.toAffine(a),d=c.slice(0,this.F.n8),e=c.slice(this.F.n8,2*this.F.n8),f=b.add(b.mul(b.square(d),d),this.b),g=b.square(e);return b.eq(f,g)}fromRng(a){let b,c,d=this.F,e=[];do e[0]=d.fromRng(a),b=a.nextBool(),c=d.add(d.mul(d.square(e[0]),e[0]),this.b);while(!d.isSquare(c));e[1]=d.sqrt(c),b^d.isNegative(e[1])&&(e[1]=d.neg(e[1]));let f=new Uint8Array(2*this.F.n8);return f.set(e[0]),f.set(e[1],this.F.n8),this.cofactor&&(f=this.timesScalar(f,this.cofactor)),f}toObject(a){return this.isZero(a)?[this.F.toObject(this.F.zero),this.F.toObject(this.F.one),this.F.toObject(this.F.zero)]:[this.F.toObject(a.slice(0,this.F.n8)),this.F.toObject(a.slice(this.F.n8,2*this.F.n8)),a.byteLength==3*this.F.n8?this.F.toObject(a.slice(2*this.F.n8,3*this.F.n8)):this.F.toObject(this.F.one)]}fromObject(a){let b,c=this.F.fromObject(a[0]),d=this.F.fromObject(a[1]);if(b=3==a.length?this.F.fromObject(a[2]):this.F.one,this.F.isZero(b,this.F.one))return this.zeroAffine;if(this.F.eq(b,this.F.one)){let a=new Uint8Array(2*this.F.n8);return a.set(c),a.set(d,this.F.n8),a}{let a=new Uint8Array(3*this.F.n8);return a.set(c),a.set(d,this.F.n8),a.set(b,2*this.F.n8),a}}e(a){return a instanceof Uint8Array?a:this.fromObject(a)}x(a){return this.toAffine(a).slice(0,this.F.n8)}y(a){return this.toAffine(a).slice(this.F.n8)}}function cA(a){let b,c;async function d(a){let d=new Uint8Array(a.code),e=await WebAssembly.compile(d);c=new WebAssembly.Memory({initial:a.init,maximum:32767}),b=await WebAssembly.instantiate(e,{env:{memory:c}})}function e(a){let b=new Uint32Array(c.buffer,0,1);for(;3&b[0];)b[0]++;let d=b[0];if(b[0]+=a,b[0]+a>c.buffer.byteLength){let d=c.buffer.byteLength/65536,e=Math.floor((b[0]+a)/65536)+1;e>32767&&(e=32767),c.grow(e-d)}return d}function f(a,b){new Uint8Array(c.buffer).set(new Uint8Array(b),a)}function g(a){if("INIT"==a[0].cmd)return d(a[0]);let g=[],h=[],i=new Uint32Array(c.buffer,0,1)[0];for(let d=0;d<a.length;d++)switch(a[d].cmd){case"ALLOCSET":g[a[d].var]=function(a){let b=e(a.byteLength);return f(b,a),b}(a[d].buff);break;case"ALLOC":g[a[d].var]=e(a[d].len);break;case"SET":f(g[a[d].var],a[d].buff);break;case"CALL":{let c=[];for(let b=0;b<a[d].params.length;b++){let e=a[d].params[b];void 0!==e.var?c.push(g[e.var]+(e.offset||0)):void 0!==e.val&&c.push(e.val)}b.exports[a[d].fnName](...c);break}case"GET":h[a[d].out]=(function(a,b){let d=new Uint8Array(c.buffer);return new Uint8Array(d.buffer,d.byteOffset+a,b)})(g[a[d].var],a[d].len).slice();break;default:throw Error("Invalid cmd")}return new Uint32Array(c.buffer,0,1)[0]=i,h}return a&&(a.onmessage=function(b){let c;if("INIT"==(c=b.data?b.data:b)[0].cmd)d(c[0]).then(function(){a.postMessage(c.result)});else if("TERMINATE"==c[0].cmd)a.close();else{let b=g(c);a.postMessage(b)}}),g}var cB=c(1820),cC=c(2650);class cD{constructor(){this.promise=new Promise((a,b)=>{this.reject=b,this.resolve=a})}}let cE=`(${cA.toString()})(self)`;async function cF(a,b){let c=new cG;c.memory=new WebAssembly.Memory({initial:25}),c.u8=new Uint8Array(c.memory.buffer),c.u32=new Uint32Array(c.memory.buffer);let e=await WebAssembly.compile(a.code);if(c.instance=await WebAssembly.instantiate(e,{env:{memory:c.memory}}),c.singleThread=b,c.initalPFree=c.u32[0],c.pq=a.pq,c.pr=a.pr,c.pG1gen=a.pG1gen,c.pG1zero=a.pG1zero,c.pG2gen=a.pG2gen,c.pG2zero=a.pG2zero,c.pOneT=a.pOneT,b)c.code=a.code,c.taskManager=cA(),await c.taskManager([{cmd:"INIT",init:25,code:c.code.slice()}]),c.concurrency=1;else{c.workers=[],c.pendingDeferreds=[],c.working=[];let b=2;0==(b=cB.cpus().length)&&(b=2),b>64&&(b=64),c.concurrency=b;for(let a=0;a<b;a++)c.workers[a]=new cC(d),c.workers[a].addEventListener("message",function(a){return function(b){let d;d=b&&b.data?b.data:b,c.working[a]=!1,c.pendingDeferreds[a].resolve(d),c.processWorks()}}(a)),c.working[a]=!1;let e=[];for(let b=0;b<c.workers.length;b++){let d=a.code.slice();e.push(c.postAction(b,[{cmd:"INIT",init:25,code:d}],[d.buffer]))}await Promise.all(e)}return c}d="data:application/javascript;base64,"+Buffer.from(cE).toString("base64");class cG{constructor(){this.actionQueue=[],this.oldPFree=0}startSyncOp(){if(0!=this.oldPFree)throw Error("Sync operation in progress");this.oldPFree=this.u32[0]}endSyncOp(){if(0==this.oldPFree)throw Error("No sync operation in progress");this.u32[0]=this.oldPFree,this.oldPFree=0}postAction(a,b,c,d){if(this.working[a])throw Error("Posting a job t a working worker");return this.working[a]=!0,this.pendingDeferreds[a]=d||new cD,this.workers[a].postMessage(b,c),this.pendingDeferreds[a].promise}processWorks(){for(let a=0;a<this.workers.length&&this.actionQueue.length>0;a++)if(!1==this.working[a]){let b=this.actionQueue.shift();this.postAction(a,b.data,b.transfers,b.deferred)}}queueAction(a,b){let c=new cD;if(this.singleThread){let b=this.taskManager(a);c.resolve(b)}else this.actionQueue.push({data:a,transfers:b,deferred:c}),this.processWorks();return c.promise}resetMemory(){this.u32[0]=this.initalPFree}allocBuff(a){let b=this.alloc(a.byteLength);return this.setBuff(b,a),b}getBuff(a,b){return this.u8.slice(a,a+b)}setBuff(a,b){this.u8.set(new Uint8Array(b),a)}alloc(a){for(;3&this.u32[0];)this.u32[0]++;let b=this.u32[0];return this.u32[0]+=a,b}async terminate(){for(let a=0;a<this.workers.length;a++)this.workers[a].postMessage([{cmd:"TERMINATE"}]);await new Promise(a=>setTimeout(a,200))}}function cH(a,b){let c=a[b],d=a.Fr,e=a.tm;a[b].batchApplyKey=async function(a,f,g,h,i){let j,k,l,m,n,o;if(h=h||"affine",i=i||"affine","G1"==b)"jacobian"==h?(l=3*c.F.n8,j="g1m_batchApplyKey"):(l=2*c.F.n8,j="g1m_batchApplyKeyMixed"),m=3*c.F.n8,"jacobian"==i?n=3*c.F.n8:(k="g1m_batchToAffine",n=2*c.F.n8);else if("G2"==b)"jacobian"==h?(l=3*c.F.n8,j="g2m_batchApplyKey"):(l=2*c.F.n8,j="g2m_batchApplyKeyMixed"),m=3*c.F.n8,"jacobian"==i?n=3*c.F.n8:(k="g2m_batchToAffine",n=2*c.F.n8);else if("Fr"==b)j="frm_batchApplyKey",l=c.n8,m=c.n8,n=c.n8;else throw Error("Invalid group: "+b);let p=Math.floor(a.byteLength/l),q=Math.floor(p/e.concurrency),r=[];g=d.e(g);let s=d.e(f);for(let b=0;b<e.concurrency;b++){let c;if(0==(c=b<e.concurrency-1?q:p-b*q))continue;let f=[];f.push({cmd:"ALLOCSET",var:0,buff:a.slice(b*q*l,b*q*l+c*l)}),f.push({cmd:"ALLOCSET",var:1,buff:s}),f.push({cmd:"ALLOCSET",var:2,buff:g}),f.push({cmd:"ALLOC",var:3,len:c*Math.max(m,n)}),f.push({cmd:"CALL",fnName:j,params:[{var:0},{val:c},{var:1},{var:2},{var:3}]}),k&&f.push({cmd:"CALL",fnName:k,params:[{var:3},{val:c},{var:3}]}),f.push({cmd:"GET",out:0,var:3,len:c*n}),r.push(e.queueAction(f)),s=d.mul(s,d.exp(g,c))}let t=await Promise.all(r);o=a instanceof cu?new cu(p*n):new Uint8Array(p*n);let u=0;for(let a=0;a<t.length;a++)o.set(t[a][0],u),u+=t[a][0].byteLength;return o}}let cI=[1,1,1,1,2,3,4,5,6,7,7,8,9,10,11,12,13,13,14,15,16,16,17,17,17,17,17,17,17,17,17,17];function cJ(a,b){let c=a[b],d=c.tm;async function e(a,d,e,f,g){let h,i;if(!(a instanceof Uint8Array))throw f&&f.error(`${g} _multiExpChunk buffBases is not Uint8Array`),Error(`${g} _multiExpChunk buffBases is not Uint8Array`);if(!(d instanceof Uint8Array))throw f&&f.error(`${g} _multiExpChunk buffScalars is not Uint8Array`),Error(`${g} _multiExpChunk buffScalars is not Uint8Array`);if(e=e||"affine","G1"==b)"affine"==e?(i="g1m_multiexpAffine_chunk",h=2*c.F.n8):(i="g1m_multiexp_chunk",h=3*c.F.n8);else if("G2"==b)"affine"==e?(i="g2m_multiexpAffine_chunk",h=2*c.F.n8):(i="g2m_multiexp_chunk",h=3*c.F.n8);else throw Error("Invalid group");let j=Math.floor(a.byteLength/h);if(0==j)return c.zero;let k=Math.floor(d.byteLength/j);if(k*j!=d.byteLength)throw Error("Scalar size does not match");let l=cI[cr(j)],m=Math.floor((8*k-1)/l)+1,n=[];for(let b=0;b<m;b++){let e=[{cmd:"ALLOCSET",var:0,buff:a},{cmd:"ALLOCSET",var:1,buff:d},{cmd:"ALLOC",var:2,len:3*c.F.n8},{cmd:"CALL",fnName:i,params:[{var:0},{var:1},{val:k},{val:j},{val:b*l},{val:Math.min(8*k-b*l,l)},{var:2}]},{cmd:"GET",out:0,var:2,len:3*c.F.n8}];n.push(c.tm.queueAction(e))}let o=await Promise.all(n),p=c.zero;for(let a=o.length-1;a>=0;a--){if(!c.isZero(p))for(let a=0;a<l;a++)p=c.double(p);p=c.add(p,o[a][0])}return p}async function f(a,f,g,h,i){let j,k;if("G1"==b)j="affine"==g?2*c.F.n8:3*c.F.n8;else if("G2"==b)j="affine"==g?2*c.F.n8:3*c.F.n8;else throw Error("Invalid group");let l=Math.floor(a.byteLength/j),m=Math.floor(f.byteLength/l);if(m*l!=f.byteLength)throw Error("Scalar size does not match");let n=Math.floor((8*m-1)/cI[cr(l)])+1;(k=Math.floor(l/(d.concurrency/n)))>4194304&&(k=4194304),k<1024&&(k=1024);let o=[];for(let b=0;b<l;b+=k){h&&h.debug(`Multiexp start: ${i}: ${b}/${l}`);let c=Math.min(l-b,k),d=a.slice(b*j,(b+c)*j),n=f.slice(b*m,(b+c)*m);o.push(e(d,n,g,h,i).then(a=>(h&&h.debug(`Multiexp end: ${i}: ${b}/${l}`),a)))}let p=await Promise.all(o),q=c.zero;for(let a=p.length-1;a>=0;a--)q=c.add(q,p[a]);return q}c.multiExp=async function(a,b,c,d){return await f(a,b,"jacobian",c,d)},c.multiExpAffine=async function(a,b,c,d){return await f(a,b,"affine",c,d)}}function cK(a,b){let c=a[b],d=a.Fr,e=c.tm;async function f(a,f,i,j,k,l){let m,n,o,p,q,r,s,t,u,v,w;i=i||"affine",j=j||"affine","G1"==b?("affine"==i?(m=2*c.F.n8,p="g1m_batchToJacobian"):m=3*c.F.n8,n=3*c.F.n8,f&&(t="g1m_fftFinal"),s="g1m_fftJoin",r="g1m_fftMix","affine"==j?(o=2*c.F.n8,q="g1m_batchToAffine"):o=3*c.F.n8):"G2"==b?("affine"==i?(m=2*c.F.n8,p="g2m_batchToJacobian"):m=3*c.F.n8,n=3*c.F.n8,f&&(t="g2m_fftFinal"),s="g2m_fftJoin",r="g2m_fftMix","affine"==j?(o=2*c.F.n8,q="g2m_batchToAffine"):o=3*c.F.n8):"Fr"==b&&(m=c.n8,n=c.n8,o=c.n8,f&&(t="frm_fftFinal"),r="frm_fftMix",s="frm_fftJoin");let x=!1;Array.isArray(a)?(a=cs(a,m),x=!0):a=a.slice(0,a.byteLength);let y=a.byteLength/m,z=cr(y);if(1<<z!=y)throw Error("fft must be multiple of 2");if(z==d.s+1){let b;return(b=f?await h(a,i,j,k,l):await g(a,i,j,k,l),x)?ct(b,o):b}f&&(u=d.inv(d.e(y))),function(a,b){let c=a.byteLength/b,d=cr(c);if(c!=1<<d)throw Error("Invalid number of pointers");for(let f=0;f<c;f++){var e;let c=(cq[(e=f)>>>24]|cq[e>>>16&255]<<8|cq[e>>>8&255]<<16|cq[255&e]<<24)>>>32-d;if(f>c){let d=a.slice(f*b,(f+1)*b);a.set(a.slice(c*b,(c+1)*b),f*b),a.set(d,c*b)}}}(a,m);let A=Math.min(16384,y),B=y/A;for(;B<e.concurrency&&A>=16;)B*=2,A/=2;let C=cr(A),D=[];for(let b=0;b<B;b++){k&&k.debug(`${l}: fft ${z} mix start: ${b}/${B}`);let c=[];c.push({cmd:"ALLOC",var:0,len:n*A});let d=a.slice(A*b*m,A*(b+1)*m);c.push({cmd:"SET",var:0,buff:d}),p&&c.push({cmd:"CALL",fnName:p,params:[{var:0},{val:A},{var:0}]});for(let a=1;a<=C;a++)c.push({cmd:"CALL",fnName:r,params:[{var:0},{val:A},{val:a}]});C==z?(t&&(c.push({cmd:"ALLOCSET",var:1,buff:u}),c.push({cmd:"CALL",fnName:t,params:[{var:0},{val:A},{var:1}]})),q&&c.push({cmd:"CALL",fnName:q,params:[{var:0},{val:A},{var:0}]}),c.push({cmd:"GET",out:0,var:0,len:A*o})):c.push({cmd:"GET",out:0,var:0,len:n*A}),D.push(e.queueAction(c).then(a=>(k&&k.debug(`${l}: fft ${z} mix end: ${b}/${B}`),a)))}w=await Promise.all(D);for(let a=0;a<B;a++)w[a]=w[a][0];for(let a=C+1;a<=z;a++){k&&k.debug(`${l}: fft  ${z}  join: ${a}/${z}`);let b=1<<z-a,c=B/b,f=[];for(let g=0;g<b;g++)for(let h=0;h<c/2;h++){let i=d.exp(d.w[a],h*A),j=d.w[a],m=g*c+h,p=g*c+h+c/2,r=[];r.push({cmd:"ALLOCSET",var:0,buff:w[m]}),r.push({cmd:"ALLOCSET",var:1,buff:w[p]}),r.push({cmd:"ALLOCSET",var:2,buff:i}),r.push({cmd:"ALLOCSET",var:3,buff:j}),r.push({cmd:"CALL",fnName:s,params:[{var:0},{var:1},{val:A},{var:2},{var:3}]}),a==z?(t&&(r.push({cmd:"ALLOCSET",var:4,buff:u}),r.push({cmd:"CALL",fnName:t,params:[{var:0},{val:A},{var:4}]}),r.push({cmd:"CALL",fnName:t,params:[{var:1},{val:A},{var:4}]})),q&&(r.push({cmd:"CALL",fnName:q,params:[{var:0},{val:A},{var:0}]}),r.push({cmd:"CALL",fnName:q,params:[{var:1},{val:A},{var:1}]})),r.push({cmd:"GET",out:0,var:0,len:A*o}),r.push({cmd:"GET",out:1,var:1,len:A*o})):(r.push({cmd:"GET",out:0,var:0,len:A*n}),r.push({cmd:"GET",out:1,var:1,len:A*n})),f.push(e.queueAction(r).then(d=>(k&&k.debug(`${l}: fft ${z} join  ${a}/${z}  ${g+1}/${b} ${h}/${c/2}`),d)))}let g=await Promise.all(f);for(let a=0;a<b;a++)for(let b=0;b<c/2;b++){let d=a*c+b,e=a*c+b+c/2,f=g.shift();w[d]=f[0],w[e]=f[1]}}if(v=a instanceof cu?new cu(y*o):new Uint8Array(y*o),f){v.set(w[0].slice((A-1)*o));let a=o;for(let b=B-1;b>0;b--)v.set(w[b],a),a+=A*o,delete w[b];v.set(w[0].slice(0,(A-1)*o),a),delete w[0]}else for(let a=0;a<B;a++)v.set(w[a],A*o*a),delete w[a];return x?ct(v,o):v}async function g(a,b,c,e,g){let h,j,k;h=a.slice(0,a.byteLength/2),j=a.slice(a.byteLength/2,a.byteLength);let l=[];[h,j]=await i(h,j,"fftJoinExt",d.one,d.shift,b,"jacobian",e,g),l.push(f(h,!1,"jacobian",c,e,g)),l.push(f(j,!1,"jacobian",c,e,g));let m=await Promise.all(l);return(k=m[0].byteLength>0x10000000?new cu(2*m[0].byteLength):new Uint8Array(2*m[0].byteLength)).set(m[0]),k.set(m[1],m[0].byteLength),k}async function h(a,b,c,e,g){let h,j,k;h=a.slice(0,a.byteLength/2),j=a.slice(a.byteLength/2,a.byteLength);let l=[];l.push(f(h,!0,b,"jacobian",e,g)),l.push(f(j,!0,b,"jacobian",e,g)),[h,j]=await Promise.all(l);let m=await i(h,j,"fftJoinExtInv",d.one,d.shiftInv,"jacobian",c,e,g);return(k=m[0].byteLength>0x10000000?new cu(2*m[0].byteLength):new Uint8Array(2*m[0].byteLength)).set(m[0]),k.set(m[1],m[0].byteLength),k}async function i(a,f,g,h,i,j,k,l,m){let n,o,p,q,r,s,t,u;if("G1"==b)"affine"==j?(r=2*c.F.n8,o="g1m_batchToJacobian"):r=3*c.F.n8,s=3*c.F.n8,n="g1m_"+g,"affine"==k?(p="g1m_batchToAffine",q=2*c.F.n8):q=3*c.F.n8;else if("G2"==b)"affine"==j?(r=2*c.F.n8,o="g2m_batchToJacobian"):r=3*c.F.n8,n="g2m_"+g,s=3*c.F.n8,"affine"==k?(p="g2m_batchToAffine",q=2*c.F.n8):q=3*c.F.n8;else if("Fr"==b)r=d.n8,q=d.n8,s=d.n8,n="frm_"+g;else throw Error("Invalid group");if(a.byteLength!=f.byteLength)throw Error("Invalid buffer size");let v=Math.floor(a.byteLength/r);if(v!=1<<cr(v))throw Error("Invalid number of points");let w=Math.floor(v/e.concurrency);w<16&&(w=16),w>65536&&(w=65536);let x=[];for(let b=0;b<v;b+=w){l&&l.debug(`${m}: fftJoinExt Start: ${b}/${v}`);let c=Math.min(v-b,w),g=d.mul(h,d.exp(i,b)),j=[],k=a.slice(b*r,(b+c)*r),t=f.slice(b*r,(b+c)*r);j.push({cmd:"ALLOC",var:0,len:s*c}),j.push({cmd:"SET",var:0,buff:k}),j.push({cmd:"ALLOC",var:1,len:s*c}),j.push({cmd:"SET",var:1,buff:t}),j.push({cmd:"ALLOCSET",var:2,buff:g}),j.push({cmd:"ALLOCSET",var:3,buff:i}),o&&(j.push({cmd:"CALL",fnName:o,params:[{var:0},{val:c},{var:0}]}),j.push({cmd:"CALL",fnName:o,params:[{var:1},{val:c},{var:1}]})),j.push({cmd:"CALL",fnName:n,params:[{var:0},{var:1},{val:c},{var:2},{var:3},{val:d.s}]}),p&&(j.push({cmd:"CALL",fnName:p,params:[{var:0},{val:c},{var:0}]}),j.push({cmd:"CALL",fnName:p,params:[{var:1},{val:c},{var:1}]})),j.push({cmd:"GET",out:0,var:0,len:c*q}),j.push({cmd:"GET",out:1,var:1,len:c*q}),x.push(e.queueAction(j).then(a=>(l&&l.debug(`${m}: fftJoinExt End: ${b}/${v}`),a)))}let y=await Promise.all(x);v*q>0x10000000?(t=new cu(v*q),u=new cu(v*q)):(t=new Uint8Array(v*q),u=new Uint8Array(v*q));let z=0;for(let a=0;a<y.length;a++)t.set(y[a][0],z),u.set(y[a][1],z),z+=y[a][0].byteLength;return[t,u]}c.fft=async function(a,b,c,d,e){return await f(a,!1,b,c,d,e)},c.ifft=async function(a,b,c,d,e){return await f(a,!0,b,c,d,e)},c.lagrangeEvaluations=async function(a,e,g,h,j){let k,l;if(e=e||"affine",g=g||"affine","G1"==b)k="affine"==e?2*c.F.n8:3*c.F.n8;else if("G2"==b)k="affine"==e?2*c.F.n8:3*c.F.n8;else if("Fr"==b)k=d.n8;else throw Error("Invalid group");let m=a.byteLength/k,n=cr(m);if(2**n*k!=a.byteLength)throw h&&h.error("lagrangeEvaluations iinvalid input size"),Error("lagrangeEvaluations invalid Input size");if(n<=d.s)return await c.ifft(a,e,g,h,j);if(n>d.s+1)throw h&&h.error("lagrangeEvaluations input too big"),Error("lagrangeEvaluations input too big");let o=a.slice(0,a.byteLength/2),p=a.slice(a.byteLength/2,a.byteLength),q=d.exp(d.shift,m/2),r=d.inv(d.sub(d.one,q));[o,p]=await i(o,p,"prepareLagrangeEvaluation",r,d.shiftInv,e,"jacobian",h,j+" prep");let s=[];return s.push(f(o,!0,"jacobian",g,h,j+" t0")),s.push(f(p,!0,"jacobian",g,h,j+" t1")),[o,p]=await Promise.all(s),(l=o.byteLength>0x10000000?new cu(2*o.byteLength):new Uint8Array(2*o.byteLength)).set(o),l.set(p,o.byteLength),l},c.fftMix=async function(a){let f,g,h,i=3*c.F.n8;if("G1"==b)f="g1m_fftMix",g="g1m_fftJoin";else if("G2"==b)f="g2m_fftMix",g="g2m_fftJoin";else if("Fr"==b)f="frm_fftMix",g="frm_fftJoin";else throw Error("Invalid group");let j=Math.floor(a.byteLength/i),k=cr(j),l=1<<cr(e.concurrency);j<=2*l&&(l=1);let m=j/l,n=cr(m),o=[];for(let b=0;b<l;b++){let c=[],d=a.slice(b*m*i,(b+1)*m*i);c.push({cmd:"ALLOCSET",var:0,buff:d});for(let a=1;a<=n;a++)c.push({cmd:"CALL",fnName:f,params:[{var:0},{val:m},{val:a}]});c.push({cmd:"GET",out:0,var:0,len:m*i}),o.push(e.queueAction(c))}let p=await Promise.all(o),q=[];for(let a=0;a<p.length;a++)q[a]=p[a][0];for(let a=n+1;a<=k;a++){let b=1<<k-a,c=l/b,f=[];for(let h=0;h<b;h++)for(let b=0;b<c/2;b++){let j=d.exp(d.w[a],b*m),k=d.w[a],l=h*c+b,n=h*c+b+c/2,o=[];o.push({cmd:"ALLOCSET",var:0,buff:q[l]}),o.push({cmd:"ALLOCSET",var:1,buff:q[n]}),o.push({cmd:"ALLOCSET",var:2,buff:j}),o.push({cmd:"ALLOCSET",var:3,buff:k}),o.push({cmd:"CALL",fnName:g,params:[{var:0},{var:1},{val:m},{var:2},{var:3}]}),o.push({cmd:"GET",out:0,var:0,len:m*i}),o.push({cmd:"GET",out:1,var:1,len:m*i}),f.push(e.queueAction(o))}let h=await Promise.all(f);for(let a=0;a<b;a++)for(let b=0;b<c/2;b++){let d=a*c+b,e=a*c+b+c/2,f=h.shift();q[d]=f[0],q[e]=f[1]}}h=a instanceof cu?new cu(j*i):new Uint8Array(j*i);let r=0;for(let a=0;a<l;a++)h.set(q[a],r),r+=q[a].byteLength;return h},c.fftJoin=async function(a,f,g,h){let i,j,k,l=3*c.F.n8;if("G1"==b)i="g1m_fftJoin";else if("G2"==b)i="g2m_fftJoin";else if("Fr"==b)i="frm_fftJoin";else throw Error("Invalid group");if(a.byteLength!=f.byteLength)throw Error("Invalid buffer size");let m=Math.floor(a.byteLength/l);if(m!=1<<cr(m))throw Error("Invalid number of points");let n=1<<cr(e.concurrency);m<=2*n&&(n=1);let o=m/n,p=[];for(let b=0;b<n;b++){let c=[],j=d.mul(g,d.exp(h,b*o)),k=a.slice(b*o*l,(b+1)*o*l),m=f.slice(b*o*l,(b+1)*o*l);c.push({cmd:"ALLOCSET",var:0,buff:k}),c.push({cmd:"ALLOCSET",var:1,buff:m}),c.push({cmd:"ALLOCSET",var:2,buff:j}),c.push({cmd:"ALLOCSET",var:3,buff:h}),c.push({cmd:"CALL",fnName:i,params:[{var:0},{var:1},{val:o},{var:2},{var:3}]}),c.push({cmd:"GET",out:0,var:0,len:o*l}),c.push({cmd:"GET",out:1,var:1,len:o*l}),p.push(e.queueAction(c))}let q=await Promise.all(p);a instanceof cu?(j=new cu(m*l),k=new cu(m*l)):(j=new Uint8Array(m*l),k=new Uint8Array(m*l));let r=0;for(let a=0;a<q.length;a++)j.set(q[a][0],r),k.set(q[a][1],r),r+=q[a][0].byteLength;return[j,k]},c.fftFinal=async function(a,d){let f,g,h,i=3*c.F.n8,j=2*c.F.n8;if("G1"==b)f="g1m_fftFinal",g="g1m_batchToAffine";else if("G2"==b)f="g2m_fftFinal",g="g2m_batchToAffine";else throw Error("Invalid group");let k=Math.floor(a.byteLength/i);if(k!=1<<cr(k))throw Error("Invalid number of points");let l=Math.floor(k/e.concurrency),m=[];for(let b=0;b<e.concurrency;b++){let c;if(0==(c=b<e.concurrency-1?l:k-b*l))continue;let h=[],n=a.slice(b*l*i,(b*l+c)*i);h.push({cmd:"ALLOCSET",var:0,buff:n}),h.push({cmd:"ALLOCSET",var:1,buff:d}),h.push({cmd:"CALL",fnName:f,params:[{var:0},{val:c},{var:1}]}),h.push({cmd:"CALL",fnName:g,params:[{var:0},{val:c},{var:0}]}),h.push({cmd:"GET",out:0,var:0,len:c*j}),m.push(e.queueAction(h))}let n=await Promise.all(m);h=a instanceof cu?new cu(k*j):new Uint8Array(k*j);let o=0;for(let a=n.length-1;a>=0;a--)h.set(n[a][0],o),o+=n[a][0].byteLength;return h}}async function cL(a){let b,c=await cF(a.wasm,a.singleThread),d={};return d.q=bY(a.wasm.q.toString()),d.r=bY(a.wasm.r.toString()),d.name=a.name,d.tm=c,d.prePSize=a.wasm.prePSize,d.preQSize=a.wasm.preQSize,d.Fr=new cw(c,"frm",a.n8r,a.r),d.F1=new cw(c,"f1m",a.n8q,a.q),d.F2=new cx(c,"f2m",d.F1),d.G1=new cz(c,"g1m",d.F1,a.wasm.pG1gen,a.wasm.pG1b,a.cofactorG1),d.G2=new cz(c,"g2m",d.F2,a.wasm.pG2gen,a.wasm.pG2b,a.cofactorG2),d.F6=new cy(c,"f6m",d.F2),d.F12=new cx(c,"ftm",d.F6),d.Gt=d.F12,cH(d,"G1"),cH(d,"G2"),cH(d,"Fr"),cJ(d,"G1"),cJ(d,"G2"),cK(d,"G1"),cK(d,"G2"),cK(d,"Fr"),b=d.tm,d.pairing=function(a,c){b.startSyncOp();let e=b.allocBuff(d.G1.toJacobian(a)),f=b.allocBuff(d.G2.toJacobian(c)),g=b.alloc(d.Gt.n8);b.instance.exports[d.name+"_pairing"](e,f,g);let h=b.getBuff(g,d.Gt.n8);return b.endSyncOp(),h},d.pairingEq=async function(){let a,c;arguments.length%2==1?(a=arguments[arguments.length-1],c=(arguments.length-1)/2):(a=d.Gt.one,c=arguments.length/2);let e=[];for(let a=0;a<c;a++){let c=[],f=d.G1.toJacobian(arguments[2*a]);c.push({cmd:"ALLOCSET",var:0,buff:f}),c.push({cmd:"ALLOC",var:1,len:d.prePSize});let g=d.G2.toJacobian(arguments[2*a+1]);c.push({cmd:"ALLOCSET",var:2,buff:g}),c.push({cmd:"ALLOC",var:3,len:d.preQSize}),c.push({cmd:"ALLOC",var:4,len:d.Gt.n8}),c.push({cmd:"CALL",fnName:d.name+"_prepareG1",params:[{var:0},{var:1}]}),c.push({cmd:"CALL",fnName:d.name+"_prepareG2",params:[{var:2},{var:3}]}),c.push({cmd:"CALL",fnName:d.name+"_millerLoop",params:[{var:1},{var:3},{var:4}]}),c.push({cmd:"GET",out:0,var:4,len:d.Gt.n8}),e.push(b.queueAction(c))}let f=await Promise.all(e);b.startSyncOp();let g=b.alloc(d.Gt.n8);b.instance.exports.ftm_one(g);for(let a=0;a<f.length;a++){let c=b.allocBuff(f[a][0]);b.instance.exports.ftm_mul(g,c,g)}b.instance.exports[d.name+"_finalExponentiation"](g,g);let h=b.allocBuff(a),i=!!b.instance.exports.ftm_eq(g,h);return b.endSyncOp(),i},d.prepareG1=function(a){this.tm.startSyncOp();let b=this.tm.allocBuff(a),c=this.tm.alloc(this.prePSize);this.tm.instance.exports[this.name+"_prepareG1"](b,c);let d=this.tm.getBuff(c,this.prePSize);return this.tm.endSyncOp(),d},d.prepareG2=function(a){this.tm.startSyncOp();let b=this.tm.allocBuff(a),c=this.tm.alloc(this.preQSize);this.tm.instance.exports[this.name+"_prepareG2"](b,c);let d=this.tm.getBuff(c,this.preQSize);return this.tm.endSyncOp(),d},d.millerLoop=function(a,b){this.tm.startSyncOp();let c=this.tm.allocBuff(a),d=this.tm.allocBuff(b),e=this.tm.alloc(this.Gt.n8);this.tm.instance.exports[this.name+"_millerLoop"](c,d,e);let f=this.tm.getBuff(e,this.Gt.n8);return this.tm.endSyncOp(),f},d.finalExponentiation=function(a){this.tm.startSyncOp();let b=this.tm.allocBuff(a),c=this.tm.alloc(this.Gt.n8);this.tm.instance.exports[this.name+"_finalExponentiation"](b,c);let d=this.tm.getBuff(c,this.Gt.n8);return this.tm.endSyncOp(),d},d.array2buffer=function(a,b){let c=new Uint8Array(b*a.length);for(let d=0;d<a.length;d++)c.set(a[d],d*b);return c},d.buffer2array=function(a,b){let c=a.byteLength/b,d=Array(c);for(let e=0;e<c;e++)d[e]=a.slice(e*b,e*b+b);return d},d}var cM=c(507);async function cN(a,b){if(!a&&globalThis.curve_bn128)return globalThis.curve_bn128;let c=new cM._o;c.setMemory(25),(0,cp.buildBn128)(c),b&&b(c);let d={};d.code=c.build(),d.pq=c.modules.f1m.pq,d.pr=c.modules.frm.pq,d.pG1gen=c.modules.bn128.pG1gen,d.pG1zero=c.modules.bn128.pG1zero,d.pG1b=c.modules.bn128.pG1b,d.pG2gen=c.modules.bn128.pG2gen,d.pG2zero=c.modules.bn128.pG2zero,d.pG2b=c.modules.bn128.pG2b,d.pOneT=c.modules.bn128.pOneT,d.prePSize=c.modules.bn128.prePSize,d.preQSize=c.modules.bn128.preQSize,d.n8q=32,d.n8r=32,d.q=c.modules.bn128.q,d.r=c.modules.bn128.r;let e={name:"bn128",wasm:d,q:bY("21888242871839275222246405745257275088696311157297823662689037894645226208583"),r:bY("21888242871839275222246405745257275088548364400416034343698204186575808495617"),n8q:32,n8r:32,cofactorG2:bY("30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d",16),singleThread:!!a},f=await cL(e);return f.terminate=async function(){e.singleThread||(globalThis.curve_bn128=null,await this.tm.terminate())},a||(globalThis.curve_bn128=f),f}async function cO(a,b){if(!a&&globalThis.curve_bls12381)return globalThis.curve_bls12381;let c=new cM._o;c.setMemory(25),(0,cp.buildBls12381)(c),b&&b(c);let d={};d.code=c.build(),d.pq=c.modules.f1m.pq,d.pr=c.modules.frm.pq,d.pG1gen=c.modules.bls12381.pG1gen,d.pG1zero=c.modules.bls12381.pG1zero,d.pG1b=c.modules.bls12381.pG1b,d.pG2gen=c.modules.bls12381.pG2gen,d.pG2zero=c.modules.bls12381.pG2zero,d.pG2b=c.modules.bls12381.pG2b,d.pOneT=c.modules.bls12381.pOneT,d.prePSize=c.modules.bls12381.prePSize,d.preQSize=c.modules.bls12381.preQSize,d.n8q=48,d.n8r=32,d.q=c.modules.bls12381.q,d.r=c.modules.bls12381.r;let e={name:"bls12381",wasm:d,q:bY("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),r:bY("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),n8q:48,n8r:32,cofactorG1:bY("0x396c8c005555e1568c00aaab0000aaab",16),cofactorG2:bY("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5",16),singleThread:!!a},f=await cL(e);return f.terminate=async function(){e.singleThread||(globalThis.curve_bls12381=null,await this.tm.terminate())},a||(globalThis.curve_bls12381=f),f}globalThis.curve_bn128=null,globalThis.curve_bls12381=null;let cP=bY("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),cQ=bY("21888242871839275222246405745257275088548364400416034343698204186575808495617");async function cR(a,b,c){let d;if(b6(a,cQ))d=await cN(b,c);else if(b6(a,cP))d=await cO(b,c);else throw Error(`Curve not supported: ${a.toString(void 0)}`);return d}bY("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),bY("21888242871839275222246405745257275088696311157297823662689037894645226208583");let cS={get:function(a,b){return isNaN(b)?a[b]:a.getElement(b)},set:function(a,b,c){return isNaN(b)?(a[b]=c,!0):a.setElement(b,c)}};class cT{constructor(a){this.length=a||0,this.arr=Array(262144);for(let b=0;b<a;b+=262144)this.arr[b/262144]=Array(Math.min(262144,a-b));return this}push(){for(let a=0;a<arguments.length;a++)this.setElement(this.length,arguments[a])}slice(a,b){let c=Array(b-a);for(let d=a;d<b;d++)c[d-a]=this.getElement(d);return c}getElement(a){let b=Math.floor((a=parseInt(a))/262144),c=a%262144;return this.arr[b]?this.arr[b][c]:void 0}setElement(a,b){let c=Math.floor((a=parseInt(a))/262144);this.arr[c]||(this.arr[c]=Array(262144));let d=a%262144;return this.arr[c][d]=b,a>=this.length&&(this.length=a+1),!0}getKeys(){let a=new cU;for(let b=0;b<this.arr.length;b++)if(this.arr[b])for(let c=0;c<this.arr[b].length;c++)void 0!==this.arr[b][c]&&a.push(262144*b+c);return a}}class cU{constructor(a){return new Proxy(new cT(a),cS)}}async function cV(a,b,c){let d;d="object"==typeof c?c:void 0===c?{singleThread:!1}:{singleThread:c};let e={};if(await N(a,b,1),e.n8=await a.readULE32(),e.prime=await Q(a,e.n8),d.F){if(d.F.p!=e.prime)throw Error("Different Prime");e.F=d.F}else if(d.getFieldFromPrime)e.F=await d.getFieldFromPrime(e.prime,d.singleThread);else if(d.getCurveFromPrime)e.curve=await d.getCurveFromPrime(e.prime,d.singleThread),e.F=e.curve.Fr;else try{e.curve=await cR(e.prime,d.singleThread),e.F=e.curve.Fr}catch(a){e.F=new co(e.prime)}return e.nVars=await a.readULE32(),e.nOutputs=await a.readULE32(),e.nPubInputs=await a.readULE32(),e.nPrvInputs=await a.readULE32(),e.nLabels=await a.readULE64(),e.nConstraints=await a.readULE32(),e.useCustomGates=void 0!==b[4]&&null!==b[4]&&void 0!==b[5]&&null!==b[5],await O(a),e}async function cW(a,b,c,d,e){let f,g;f="object"==typeof d?d:void 0===d?{}:{logger:d,loggerCtx:e};let h=await S(a,b,2),i=0;g=c.nConstraints>1048576?new cU:[];for(let a=0;a<c.nConstraints;a++){f.logger&&a%1e5==0&&f.logger.info(`${f.loggerCtx}: Loading constraints: ${a}/${c.nConstraints}`);let b=function(){let a=[];return a[0]=j(),a[1]=j(),a[2]=j(),a}();g.push(b)}return g;function j(){let a={},b=h.slice(i,i+4);i+=4;let d=new DataView(b.buffer).getUint32(0,!0),e=h.slice(i,i+(4+c.n8)*d);i+=(4+c.n8)*d;let f=new DataView(e.buffer);for(let b=0;b<d;b++){let d=f.getUint32(b*(4+c.n8),!0),g=c.F.fromRprLE(e,b*(4+c.n8)+4);a[d]=g}return a}}async function cX(a,b,c,d,e){let f,g;f="object"==typeof d?d:void 0===d?{}:{logger:d,loggerCtx:e};let h=await S(a,b,3),i=0;g=c.nVars>1048576?new cU:[];for(let a=0;a<c.nVars;a++){f.logger&&a%1e4==0&&f.logger.info(`${f.loggerCtx}: Loading map: ${a}/${c.nVars}`);let b=function(){let a=h.slice(i,i+8);i+=8;let b=new DataView(a.buffer),c=b.getUint32(0,!0);return 0x100000000*b.getUint32(4,!0)+c}();g.push(b)}return g}async function cY(a,b,c){if("object"!=typeof c)throw Error("readR1csFd: options must be an object");c.loadConstraints=!("loadConstraints"in c)||c.loadConstraints,c.loadMap="loadMap"in c&&c.loadMap,c.loadCustomGates=!("loadCustomGates"in c)||c.loadCustomGates;let d=await cV(a,b,c);return c.loadConstraints&&(d.constraints=await cW(a,b,d,c)),c.loadMap&&(d.map=await cX(a,b,d,c)),c.loadCustomGates&&(d.useCustomGates?(d.customGates=await c$(a,b,d),d.customGatesUses=await c_(a,b,c)):(d.customGates=[],d.customGatesUses=[])),d}async function cZ(a,b,c,d,e,f){let{fd:g,sections:h}=await J(a,"r1cs",1,0x2000000,4194304),i=await cY(g,h,"object"==typeof b?b:void 0===b?{loadConstraints:!0,loadMap:!1,loadCustomGates:!0}:{loadConstraints:b,loadMap:c,singleThread:d,logger:e,loggerCtx:f});return await g.close(),i}async function c$(a,b,c){await N(a,b,4);let d=await a.readULE32(),e=[];for(let b=0;b<d;b++){let b={};b.templateName=await a.readString();let d=await a.readULE32();b.parameters=Array(d);let f=await a.read(c.n8*d);for(let a=0;a<d;a++)b.parameters[a]=c.F.fromRprLE(f,a*c.n8,c.n8);e.push(b)}return await O(a),e}async function c_(a,b,c){let d,e=await S(a,b,5),f=new Uint32Array(e.buffer,e.byteOffset,e.byteLength/4),g=f[0],h=1;d=g>1048576?new cU:[];for(let a=0;a<g;a++){c.logger&&a%1e5==0&&c.logger.info(`${c.loggerCtx}: Loading custom gate uses: ${a}/${g}`);let b={};b.id=f[h++];let e=f[h++];b.signals=[];for(let a=0;a<e;a++){let a=f[h++],c=f[h++];b.signals.push(0x100000000*c+a)}d.push(b)}return d}let c0=s.X5.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),c1=s.X5.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");async function c2(a,b){let c=await cZ(a);return s.X5.eq(c.prime,c1)?b&&b.info("Curve: bn-128"):s.X5.eq(c.prime,c0)?b&&b.info("Curve: bls12-381"):b&&b.info(`Unknown Curve. Prime: ${s.X5.toString(c.prime)}`),b&&b.info(`# of Wires: ${c.nVars}`),b&&b.info(`# of Constraints: ${c.nConstraints}`),b&&b.info(`# of Private Inputs: ${c.nPrvInputs}`),b&&b.info(`# of Public Inputs: ${c.nPubInputs}`),b&&b.info(`# of Labels: ${c.nLabels}`),b&&b.info(`# of Outputs: ${c.nOutputs}`),c}async function c3(a,b){let c=await cZ(a,!0,!0,!0,b),d=c.curve.Fr;return delete c.curve,delete c.F,aR(d,c)}async function c4(a){let b={labelIdx2Name:["one"],varIdx2Name:["one"],componentIdx2Name:[]},c=await I(a),d=await c.read(c.totalSize),e=new TextDecoder("utf-8").decode(d).split("\n");for(let a=0;a<e.length;a++){let c=e[a].split(",");4==c.length&&(b.varIdx2Name[c[1]]?b.varIdx2Name[c[1]]+="|"+c[3]:b.varIdx2Name[c[1]]=c[3],b.labelIdx2Name[c[0]]=c[3],b.componentIdx2Name[c[2]]||(b.componentIdx2Name[c[2]]=function(a){let b=a.split(".");return b.pop(),b.join(".")}(c[3])))}return await c.close(),b}let{unstringifyBigInts:c5}=s.Wp;async function c6(a,b,c,d,e,f){let g=c5(a),h=await I(b),i=await h.read(h.totalSize);await h.close();let j={...e,sanityCheck:!0},k=await c4(d);e.set&&(k||(k=await c4(d)),j.logSetSignal=function(a,b){f&&f.info("SET "+k.labelIdx2Name[a]+" <-- "+b.toString())}),e.get&&(k||(k=await c4(d)),j.logGetSignal=function(a,b){f&&f.info("GET "+k.labelIdx2Name[a]+" --\x3e "+b.toString())}),e.trigger&&(k||(k=await c4(d)),j.logStartComponent=function(a){f&&f.info("START: "+k.componentIdx2Name[a])},j.logFinishComponent=function(a){f&&f.info("FINISH: "+k.componentIdx2Name[a])}),j.sym=k;let l=await bg(i,j),m=await l.calculateWitness(g,!0),n=await K(c,"wtns",2,2);await a6(n,m,l.prime),await n.close()}async function c7(a){return await a9(a)}async function c8(a,b,c){c&&c.info("WITNESS CHECKING STARTED"),c&&c.info("> Reading r1cs file");let{fd:d,sections:e}=await J(a,"r1cs",1,4194304,0x1000000),f=await cY(d,e,{loadConstraints:!1,loadCustomGates:!1});c&&c.info("> Reading witness file");let{fd:g,sections:h}=await J(b,"wtns",2,4194304,0x1000000),i=await a8(g,h);if(!s.X5.eq(f.prime,i.q))throw Error("Curve of the witness does not match the curve of the proving key");let j=await S(g,h,2);await g.close();let k=(await Y(f.prime)).Fr,l=k.n8,m=await S(d,e,2);c&&(c.info("----------------------------"),c.info("  WITNESS CHECK"),c.info(`  Curve:          ${f.curve.name}`),c.info(`  Vars (wires):   ${f.nVars}`),c.info(`  Outputs:        ${f.nOutputs}`),c.info(`  Public Inputs:  ${f.nPubInputs}`),c.info(`  Private Inputs: ${f.nPrvInputs}`),c.info(`  Labels:         ${f.nLabels}`),c.info(`  Constraints:    ${f.nConstraints}`),c.info(`  Custom Gates:   ${f.useCustomGates}`),c.info("----------------------------")),c&&c.info("> Checking witness correctness");let n=0,o=!0;for(let a=0;a<f.nConstraints;a++){c&&0!==a&&a%5e5==0&&c.info(`\xb7\xb7\xb7 processing r1cs constraints ${a}/${f.nConstraints}`);let b=q(),d=q(),e=q(),g=p(b),h=p(d),i=p(e);if(!k.eq(k.sub(k.mul(g,h),i),k.zero)){c.warn("\xb7\xb7\xb7 aborting checking process at constraint "+a),o=!1;break}}return d.close(),c&&(o?(c.info("WITNESS IS CORRECT"),c.info("WITNESS CHECKING FINISHED SUCCESSFULLY")):(c.warn("WITNESS IS NOT CORRECT"),c.warn("WITNESS CHECKING FINISHED UNSUCCESSFULLY"))),o;function p(a){let b=k.zero;return Object.keys(a).forEach(c=>{var d;let e=(d=c,k.fromRprLE(j.slice(d*l,d*l+l))),f=a[c];b=k.add(b,k.mul(e,f))}),b}function q(){let a={},b=m.slice(n,n+4);n+=4;let c=new DataView(b.buffer).getUint32(0,!0),d=m.slice(n,n+(4+f.n8)*c);n+=(4+f.n8)*c;let e=new DataView(d.buffer);for(let b=0;b<c;b++){let c=e.getUint32(b*(4+f.n8),!0),g=f.F.fromRprLE(d,b*(4+f.n8)+4);a[c]=g}return a}}let c9={get:function(a,b){return isNaN(b)?a[b]:a.getElement(b)},set:function(a,b,c){return isNaN(b)?(a[b]=c,!0):a.setElement(b,c)}};class da{constructor(a){this.length=a||0,this.arr=Array(262144);for(let b=0;b<a;b+=262144)this.arr[b/262144]=Array(Math.min(262144,a-b));return this}push(){for(let a=0;a<arguments.length;a++)this.setElement(this.length,arguments[a])}slice(a,b){let c=Array(b-a);for(let d=a;d<b;d++)c[d-a]=this.getElement(d);return c}getElement(a){let b=Math.floor((a=parseInt(a))/262144),c=a%262144;return this.arr[b]?this.arr[b][c]:void 0}setElement(a,b){let c=Math.floor((a=parseInt(a))/262144);this.arr[c]||(this.arr[c]=Array(262144));let d=a%262144;return this.arr[c][d]=b,a>=this.length&&(this.length=a+1),!0}getKeys(){let a=new db;for(let b=0;b<this.arr.length;b++)if(this.arr[b])for(let c=0;c<this.arr[b].length;c++)void 0!==this.arr[b][c]&&a.push(262144*b+c);return a}}class db{constructor(a){return new Proxy(new da(a),c9)}}async function dc(a,b,c,d){let e,f,g,h=aA.create({dkLen:64}),{fd:i,sections:j}=await J(b,"ptau",1,4194304,0x1000000),{curve:k,power:l}=await bx(i,j),{fd:m,sections:n}=await J(a,"r1cs",1,4194304,0x1000000),o=await cV(m,n,!1),p=await K(c,"zkey",1,10,4194304,0x1000000),q=2*k.G1.F.n8,r=2*k.G2.F.n8;if(o.prime!=k.r)return d&&d.error("r1cs curve does not match powers of tau ceremony curve"),-1;let t=aE(o.nConstraints+o.nPubInputs+o.nOutputs+1-1)+1;if(t>l)return d&&d.error(`circuit too big for this power of tau ceremony. ${o.nConstraints}*2 > 2**${l}`),-1;if(!j[12])return d&&d.error("Powers of tau is not prepared."),-1;let u=o.nOutputs+o.nPubInputs,v=2**t;await L(p,1),await p.writeULE32(1),await M(p),await L(p,2);let w=k.q,x=(Math.floor((s.X5.bitLength(w)-1)/64)+1)*8,y=k.r,z=(Math.floor((s.X5.bitLength(y)-1)/64)+1)*8,A=s.X5.mod(s.X5.shl(1,8*z),y),B=k.Fr.e(s.X5.mod(s.X5.mul(A,A),y));await p.writeULE32(x),await P(p,w,x),await p.writeULE32(z),await P(p,y,z),await p.writeULE32(o.nVars),await p.writeULE32(u),await p.writeULE32(v),e=await i.read(q,j[4][0].p),await p.write(e),e=await k.G1.batchLEMtoU(e),h.update(e),f=await i.read(q,j[5][0].p),await p.write(f),f=await k.G1.batchLEMtoU(f),h.update(f),g=await i.read(r,j[6][0].p),await p.write(g),g=await k.G2.batchLEMtoU(g),h.update(g);let C=new Uint8Array(q);k.G1.toRprLEM(C,0,k.G1.g);let D=new Uint8Array(r);k.G2.toRprLEM(D,0,k.G2.g);let E=new Uint8Array(q);k.G1.toRprUncompressed(E,0,k.G1.g);let F=new Uint8Array(r);k.G2.toRprUncompressed(F,0,k.G2.g),await p.write(D),await p.write(C),await p.write(D),h.update(F),h.update(E),h.update(F),await M(p),d&&d.info("Reading r1cs");let G=await S(m,n,2),H=new db(o.nVars),I=new db(o.nVars),N=new db(o.nVars),O=new db(o.nVars-u-1),Q=Array(u+1);d&&d.info("Reading tauG1");let R=await S(i,j,12,(v-1)*q,v*q);d&&d.info("Reading tauG2");let T=await S(i,j,13,(v-1)*r,v*r);d&&d.info("Reading alphatauG1");let U=await S(i,j,14,(v-1)*q,v*q);d&&d.info("Reading betatauG1");let V=await S(i,j,15,(v-1)*q,v*q);await Y(),await Z(3,"G1",Q,"IC"),await X(),await _(),await Z(8,"G1",O,"C"),await Z(5,"G1",H,"A"),await Z(6,"G1",I,"B1"),await Z(7,"G2",N,"B2");let W=h.digest();return await L(p,10),await p.write(W),await p.writeULE32(0),await M(p),d&&d.info(aF(W,"Circuit hash: ")),await p.close(),await m.close(),await i.close(),W;async function X(){await L(p,9);let a=new s.Zh(v*q);if(t<k.Fr.s){let b=await S(i,j,12,(2*v-1)*q,2*v*q);for(let c=0;c<v;c++){d&&c%1e4==0&&d.debug(`splitting buffer: ${c}/${v}`);let e=b.slice((2*c+1)*q,(2*c+1)*q+q);a.set(e,c*q)}}else if(t==k.Fr.s){let b=j[12][0].p+(2**(t+1)-1)*q;await i.readToBuffer(a,0,v*q,b+v*q)}else throw d&&d.error("Circuit too big"),Error("Circuit too big for this curve");await p.write(a),await M(p)}async function Y(){let a=new Uint8Array(12+k.Fr.n8),b=new DataView(a.buffer),c=new Uint8Array(k.Fr.n8);k.Fr.toRprLE(c,0,k.Fr.e(1));let e=0;function f(){let a=G.slice(e,e+4);return e+=4,new DataView(a.buffer).getUint32(0,!0)}let g=new db;for(let a=0;a<o.nConstraints;a++){d&&a%1e4==0&&d.debug(`processing constraints: ${a}/${o.nConstraints}`);let b=f();for(let c=0;c<b;c++){let b=f(),c=e;e+=k.Fr.n8;let d=q*a,h=q*a;void 0===H[b]&&(H[b]=[]),H[b].push([0,d,c]),b<=u?(void 0===Q[b]&&(Q[b]=[]),Q[b].push([3,h,c])):(void 0===O[b-u-1]&&(O[b-u-1]=[]),O[b-u-1].push([3,h,c])),g.push([0,a,b,c])}let c=f();for(let b=0;b<c;b++){let b=f(),c=e;e+=k.Fr.n8;let d=q*a,h=r*a,i=q*a;void 0===I[b]&&(I[b]=[]),I[b].push([0,d,c]),void 0===N[b]&&(N[b]=[]),N[b].push([1,h,c]),b<=u?(void 0===Q[b]&&(Q[b]=[]),Q[b].push([2,i,c])):(void 0===O[b-u-1]&&(O[b-u-1]=[]),O[b-u-1].push([2,i,c])),g.push([1,a,b,c])}let h=f();for(let b=0;b<h;b++){let b=f(),c=e;e+=k.Fr.n8;let d=q*a;b<=u?(void 0===Q[b]&&(Q[b]=[]),Q[b].push([0,d,c])):(void 0===O[b-u-1]&&(O[b-u-1]=[]),O[b-u-1].push([0,d,c]))}}for(let a=0;a<=u;a++){let b=q*(o.nConstraints+a),c=q*(o.nConstraints+a);void 0===H[a]&&(H[a]=[]),H[a].push([0,b,-1]),void 0===Q[a]&&(Q[a]=[]),Q[a].push([3,c,-1]),g.push([0,o.nConstraints+a,a,-1])}await L(p,4);let h=new s.Zh(g.length*(12+k.Fr.n8)+4),i=new Uint8Array(4);new DataView(i.buffer).setUint32(0,g.length,!0),h.set(i);let j=4;for(let e=0;e<g.length;e++)d&&e%1e5==0&&d.debug(`writing coeffs: ${e}/${g.length}`),function(d){let e;b.setUint32(0,d[0],!0),b.setUint32(4,d[1],!0),b.setUint32(8,d[2],!0),e=d[3]>=0?k.Fr.fromRprLE(G.slice(d[3],d[3]+k.Fr.n8),0):k.Fr.fromRprLE(c,0);let f=k.Fr.mul(e,B);k.Fr.toRprLE(a,12,f),h.set(a,j),j+=a.length}(g[e]);await p.write(h),await M(p)}async function Z(a,b,c,e){let f=k[b];ac(c.length),await L(p,a);let g=[],i=0;for(;i<c.length;){let a=0;for(;i<c.length&&a<k.tm.concurrency;){d&&d.debug(`Writing points start ${e}: ${i}/${c.length}`);let f=1,h=c[i]?c[i].length:0;for(;i+f<c.length&&h+(c[i+f]?c[i+f].length:0)<32768&&f<32768;)h+=c[i+f]?c[i+f].length:0,f++;let j=c.slice(i,i+f),k=i;g.push($(b,j,d,e).then(a=>(d&&d.debug(`Writing points end ${e}: ${k}/${c.length}`),a))),i+=f,a++}let j=await Promise.all(g);for(let a=0;a<j.length;a++){await p.write(j[a][0]);let b=await f.batchLEMtoU(j[a][0]);h.update(b)}g=[]}await M(p)}async function $(a,b,c,d){let e,f,g,h,i,j,l=k[a],m=2*l.F.n8,n=3*l.F.n8,o=2*l.F.n8;if("G1"==a)e="g1m_timesScalarAffine",f="g1m_multiexpAffine",g="g1m_batchToAffine",h="g1m_zero";else if("G2"==a)e="g2m_timesScalarAffine",f="g2m_multiexpAffine",g="g2m_batchToAffine",h="g2m_zero";else throw Error("Invalid group");let p=0;for(let a=0;a<b.length;a++)p+=b[a]?b[a].length:0;p>32768?(i=new s.Zh(p*m),j=new s.Zh(p*k.Fr.n8)):(i=new Uint8Array(p*m),j=new Uint8Array(p*k.Fr.n8));let q=0,r=0,t=[R,T,U,V],u=new Uint8Array(k.Fr.n8);k.Fr.toRprLE(u,0,k.Fr.e(1));let v=0;for(let a=0;a<b.length;a++)if(b[a])for(let e=0;e<b[a].length;e++)c&&e&&e%1e4==0&&c.debug(`Configuring big array ${d}: ${e}/${b[a].length}`),i.set(t[b[a][e][0]].slice(b[a][e][1],b[a][e][1]+m),v*m),b[a][e][2]>=0?j.set(G.slice(b[a][e][2],b[a][e][2]+k.Fr.n8),v*k.Fr.n8):j.set(u,v*k.Fr.n8),v++;if(b.length>1){let a=[];a.push({cmd:"ALLOCSET",var:0,buff:i}),a.push({cmd:"ALLOCSET",var:1,buff:j}),a.push({cmd:"ALLOC",var:2,len:b.length*n}),q=0,r=0;let c=0;for(let d=0;d<b.length;d++){if(!b[d]){a.push({cmd:"CALL",fnName:h,params:[{var:2,offset:c}]}),c+=n;continue}1==b[d].length?a.push({cmd:"CALL",fnName:e,params:[{var:0,offset:q},{var:1,offset:r},{val:k.Fr.n8},{var:2,offset:c}]}):a.push({cmd:"CALL",fnName:f,params:[{var:0,offset:q},{var:1,offset:r},{val:k.Fr.n8},{val:b[d].length},{var:2,offset:c}]}),q+=m*b[d].length,r+=k.Fr.n8*b[d].length,c+=n}return a.push({cmd:"CALL",fnName:g,params:[{var:2},{val:b.length},{var:2}]}),a.push({cmd:"GET",out:0,var:2,len:b.length*o}),await k.tm.queueAction(a)}{let a=await l.multiExpAffine(i,j,c,d);return[l.toAffine(a)]}}async function _(){ac(v-1);for(let a=0;a<v-1;a+=16384){d&&d.debug(`HashingHPoints: ${a}/${v}`);let b=Math.min(v-1,16384);await aa(a,b)}}async function aa(a,b){let c=await i.read(b*q,j[2][0].p+(a+v)*q),d=await i.read(b*q,j[2][0].p+a*q),e=k.tm.concurrency,f=Math.floor(b/e),g=[];for(let a=0;a<e;a++){let h;if(0==(h=a<e-1?f:b-a*f))continue;let i=c.slice(a*f*q,(a*f+h)*q),j=d.slice(a*f*q,(a*f+h)*q);g.push(ab(i,j))}let l=await Promise.all(g);for(let a=0;a<l.length;a++)h.update(l[a][0])}async function ab(a,b){let c=a.byteLength/q,d=3*k.G1.F.n8,e=[];e.push({cmd:"ALLOCSET",var:0,buff:a}),e.push({cmd:"ALLOCSET",var:1,buff:b}),e.push({cmd:"ALLOC",var:2,len:c*d});for(let a=0;a<c;a++)e.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:a*q},{var:1,offset:a*q},{var:2,offset:a*d}]});return e.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:c},{var:2}]}),e.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:c},{var:2}]}),e.push({cmd:"GET",out:0,var:2,len:c*q}),await k.tm.queueAction(e)}function ac(a){let b=new Uint8Array(4);new DataView(b.buffer,b.byteOffset,b.byteLength).setUint32(0,a,!1),h.update(b)}}async function dd(a,b,c){let d,e,f,g,h,i,{fd:j,sections:k}=await J(a,"zkey",2),l=await aX(j,k);if("groth16"!=l.protocol)throw Error("zkey file is not groth16");let m=await Z(l.q),n=2*m.G1.F.n8,o=2*m.G2.F.n8,p=await a1(j,m,k),q=await H(b);await s(l.vk_alpha_1),await s(l.vk_beta_1),await t(l.vk_beta_2),await t(l.vk_gamma_2),await s(l.vk_delta_1),await t(l.vk_delta_2),d=await S(j,k,3),d=await m.G1.batchLEMtoU(d),await u("G1",d);let r=await S(j,k,9);e=await m.G1.fft(r,"affine","jacobian",c),e=(e=await m.G1.batchApplyKey(e,m.Fr.neg(m.Fr.e(2)),m.Fr.w[l.power+1],"jacobian","affine",c)).slice(0,e.byteLength-n),e=await m.G1.batchLEMtoU(e),await u("G1",e),f=await S(j,k,8),f=await m.G1.batchLEMtoU(f),await u("G1",f),g=await S(j,k,5),g=await m.G1.batchLEMtoU(g),await u("G1",g),h=await S(j,k,6),h=await m.G1.batchLEMtoU(h),await u("G1",h),i=await S(j,k,7),i=await m.G2.batchLEMtoU(i),await u("G2",i),await q.write(p.csHash),await v(p.contributions.length);for(let a=0;a<p.contributions.length;a++){let b=p.contributions[a];await s(b.deltaAfter),await s(b.delta.g1_s),await s(b.delta.g1_sx),await t(b.delta.g2_spx),await q.write(b.transcript)}async function s(a){let b=new Uint8Array(n);m.G1.toRprUncompressed(b,0,a),await q.write(b)}async function t(a){let b=new Uint8Array(o);m.G2.toRprUncompressed(b,0,a),await q.write(b)}async function u(a,b){let c;c="G1"==a?n:o;let d=new Uint8Array(4);new DataView(d.buffer,d.byteOffset,d.byteLength).setUint32(0,b.byteLength/c,!1),await q.write(d),await q.write(b)}async function v(a){let b=new Uint8Array(4);new DataView(b.buffer,b.byteOffset,b.byteLength).setUint32(0,a,!1),await q.write(b)}await j.close(),await q.close()}async function de(a,b,c,d,e){let f,g,{fd:h,sections:i}=await J(a,"zkey",2),j=await aX(h,i,!1);if("groth16"!=j.protocol)throw Error("zkey file is not groth16");let k=await Z(j.q),l=2*k.G1.F.n8,m=2*k.G2.F.n8,n=await a1(h,k,i),o={},p=await I(b);p.pos=3*l+3*m+8+l*j.nVars+4+l*(j.domainSize-1)+4+l*j.nVars+4+l*j.nVars+4+m*j.nVars,o.csHash=await p.read(64);let q=await p.readUBE32();o.contributions=[];for(let a=0;a<q;a++){let b={delta:{}};b.deltaAfter=await y(p),b.delta.g1_s=await y(p),b.delta.g1_sx=await y(p),b.delta.g2_spx=await z(p),b.transcript=await p.read(64),a<n.contributions.length&&(b.type=n.contributions[a].type,1==b.type&&(b.beaconHash=n.contributions[a].beaconHash,b.numIterationsExp=n.contributions[a].numIterationsExp),n.contributions[a].name&&(b.name=n.contributions[a].name)),o.contributions.push(b)}if(!aG(o.csHash,n.csHash))return e&&e.error("Hash of the original circuit does not match with the MPC one"),!1;if(n.contributions.length>o.contributions.length)return e&&e.error("The impoerted file does not include new contributions"),!1;for(let a=0;a<n.contributions.length;a++){var r,s;if(r=n.contributions[a],s=o.contributions[a],!(k.G1.eq(r.deltaAfter,s.deltaAfter)&&k.G1.eq(r.delta.g1_s,s.delta.g1_s)&&k.G1.eq(r.delta.g1_sx,s.delta.g1_sx)&&k.G2.eq(r.delta.g2_spx,s.delta.g2_spx)&&aG(r.transcript,s.transcript)))return e&&e.error(`Previous contribution ${a} does not match`),!1}if(d)for(let a=n.contributions.length;a<o.contributions.length;a++)o.contributions[a].name=d;let t=await K(c,"zkey",1,10);if(p.pos=0,p.pos+=l,p.pos+=l,p.pos+=m,p.pos+=m,j.vk_delta_1=await y(p),j.vk_delta_2=await z(p),await aS(t,j),await p.readUBE32()!=j.nPublic+1)return e&&e.error("Invalid number of points in IC"),await t.discard(),!1;if(p.pos+=l*(j.nPublic+1),await R(h,i,t,3),await R(h,i,t,4),await p.readUBE32()!=j.domainSize-1)return e&&e.error("Invalid number of points in H"),await t.discard(),!1;let u=await p.read(l*(j.domainSize-1)),v=await k.G1.batchUtoLEM(u);(f=new Uint8Array(j.domainSize*l)).set(v),k.G1.toRprLEM(f,l*(j.domainSize-1),k.G1.zeroAffine);let w=k.Fr.neg(k.Fr.inv(k.Fr.e(2))),x=k.Fr.inv(k.Fr.w[j.power+1]);if(f=await k.G1.batchApplyKey(f,w,x,"affine","jacobian",e),f=await k.G1.ifft(f,"jacobian","affine",e),await L(t,9),await t.write(f),await M(t),await p.readUBE32()!=j.nVars-j.nPublic-1)return e&&e.error("Invalid number of points in L"),await t.discard(),!1;if(g=await p.read(l*(j.nVars-j.nPublic-1)),g=await k.G1.batchUtoLEM(g),await L(t,8),await t.write(g),await M(t),await p.readUBE32()!=j.nVars)return e&&e.error("Invalid number of points in A"),await t.discard(),!1;if(p.pos+=l*j.nVars,await R(h,i,t,5),await p.readUBE32()!=j.nVars)return e&&e.error("Invalid number of points in B1"),await t.discard(),!1;if(p.pos+=l*j.nVars,await R(h,i,t,6),await p.readUBE32()!=j.nVars)return e&&e.error("Invalid number of points in B2"),await t.discard(),!1;return p.pos+=m*j.nVars,await R(h,i,t,7),await a3(t,k,o),await p.close(),await t.close(),await h.close(),!0;async function y(a){let b=await a.read(2*k.G1.F.n8);return k.G1.fromRprUncompressed(b,0)}async function z(a){let b=await a.read(2*k.G2.F.n8);return k.G2.fromRprUncompressed(b,0)}}async function df(a,b,c,d){let{fd:e,sections:f}=await J(c,"zkey",2),g=await aX(e,f,!1);if("groth16"!=g.protocol)throw Error("zkey file is not groth16");let h=await Z(g.q),i=2*h.G1.F.n8,j=await a1(e,h,f),k=aA.create({dkLen:64});k.update(j.csHash);let l=h.G1.g;for(let a=0;a<j.contributions.length;a++){let b=j.contributions[a],c=k.clone();if(a4(c,h,b.delta.g1_s),a4(c,h,b.delta.g1_sx),!aG(c.digest(),b.transcript))return console.log(`INVALID(${a}): Inconsistent transcript `),!1;let d=bs(h,b.transcript);if(!0!==await aJ(h,b.delta.g1_s,b.delta.g1_sx,d,b.delta.g2_spx))return console.log(`INVALID(${a}): public key G1 and G2 do not have the same ration `),!1;if(!0!==await aJ(h,l,b.deltaAfter,d,b.delta.g2_spx))return console.log(`INVALID(${a}): deltaAfter does not fillow the public key `),!1;if(1==b.type){let c=await aO(b.beaconHash,b.numIterationsExp),d=h.Fr.fromRng(c),e=h.G1.toAffine(h.G1.fromRng(c)),f=h.G1.toAffine(h.G1.timesFr(e,d));if(!0!==h.G1.eq(e,b.delta.g1_s))return console.log(`INVALID(${a}): Key of the beacon does not match. g1_s `),!1;if(!0!==h.G1.eq(f,b.delta.g1_sx))return console.log(`INVALID(${a}): Key of the beacon does not match. g1_sx `),!1}a5(k,h,b);let e=aA.create({dkLen:64});a5(e,h,b),b.contributionHash=e.digest(),l=b.deltaAfter}let{fd:m,sections:n}=await J(a,"zkey",2),o=await aX(m,n,!1);if("groth16"!=o.protocol)throw Error("zkeyinit file is not groth16");if(!s.X5.eq(o.q,g.q)||!s.X5.eq(o.r,g.r)||o.n8q!=g.n8q||o.n8r!=g.n8r)return d&&d.error("INVALID:  Different curves"),!1;if(o.nVars!=g.nVars||o.nPublic!=g.nPublic||o.domainSize!=g.domainSize)return d&&d.error("INVALID:  Different circuit parameters"),!1;if(!h.G1.eq(g.vk_alpha_1,o.vk_alpha_1))return d&&d.error("INVALID:  Invalid alpha1"),!1;if(!h.G1.eq(g.vk_beta_1,o.vk_beta_1))return d&&d.error("INVALID:  Invalid beta1"),!1;if(!h.G2.eq(g.vk_beta_2,o.vk_beta_2))return d&&d.error("INVALID:  Invalid beta2"),!1;if(!h.G2.eq(g.vk_gamma_2,o.vk_gamma_2))return d&&d.error("INVALID:  Invalid gamma2"),!1;if(!h.G1.eq(g.vk_delta_1,l))return d&&d.error("INVALID:  Invalid delta1"),!1;if(!0!==await aJ(h,h.G1.g,l,h.G2.g,g.vk_delta_2))return d&&d.error("INVALID:  Invalid delta2"),!1;let p=await a1(m,h,n);if(!aG(j.csHash,p.csHash))return d&&d.error("INVALID:  Circuit does not match"),!1;if(f[8][0].size!=i*(g.nVars-g.nPublic-1))return d&&d.error("INVALID:  Invalid L section size"),!1;if(f[9][0].size!=i*g.domainSize)return d&&d.error("INVALID:  Invalid H section size"),!1;if(!await T(e,f,m,n,3))return d&&d.error("INVALID:  IC section is not identical"),!1;if(!await T(e,f,m,n,4))return d&&d.error("Coeffs section is not identical"),!1;if(!await T(e,f,m,n,5))return d&&d.error("A section is not identical"),!1;if(!await T(e,f,m,n,6))return d&&d.error("B1 section is not identical"),!1;if(!await T(e,f,m,n,7))return d&&d.error("B2 section is not identical"),!1;if(!0!==await q("G1",m,n,e,f,8,g.vk_delta_2,o.vk_delta_2,"L section"))return d&&d.error("L section does not match"),!1;if(!0!==await r())return d&&d.error("H section does not match"),!1;d&&d.info(aF(j.csHash,"Circuit Hash: ")),await e.close(),await m.close();for(let a=j.contributions.length-1;a>=0;a--){let b=j.contributions[a];d&&d.info("-------------------------"),d&&d.info(aF(b.contributionHash,`contribution #${a+1} ${b.name?b.name:""}:`)),1==b.type&&(d&&d.info(`Beacon generator: ${aQ(b.beaconHash)}`),d&&d.info(`Beacon iterations Exp: ${b.numIterationsExp}`))}return d&&d.info("-------------------------"),d&&d.info("ZKey Ok!"),!0;async function q(a,b,c,e,f,g,i,j,k){let l=h[a],m=2*l.F.n8;await N(b,c,g),await N(e,f,g);let n=l.zero,o=l.zero,p=c[g][0].size/m;for(let a=0;a<p;a+=1048576){d&&d.debug(`Same ratio check ${k}:  ${a}/${p}`);let c=Math.min(p-a,1048576),f=await b.read(c*m),g=await e.read(c*m),h=aK(4*c),i=await l.multiExpAffine(f,h),j=await l.multiExpAffine(g,h);n=l.add(n,i),o=l.add(o,j)}return await O(b),await O(e),0==p||!0===await aJ(h,n,o,i,j)}async function r(){let a,c=h.G1,i=h.Fr,j=2*c.F.n8,{fd:k,sections:l}=await J(b,"ptau",1),m=new s.Zh(g.domainSize*g.n8r),n=Array(8);for(let a=0;a<8;a++)n[a]=aM(aK(4),0);let p=new s.Bw(n);for(let a=0;a<g.domainSize-1;a++){let b=i.fromRng(p);i.toRprLE(m,a*g.n8r,b)}i.toRprLE(m,(g.domainSize-1)*g.n8r,i.zero);let q=c.zero;for(let a=0;a<g.domainSize;a+=1048576){d&&d.debug(`H Verification(tau):  ${a}/${g.domainSize}`);let b=Math.min(g.domainSize-a,1048576),e=await k.read(j*b,l[2][0].p+g.domainSize*j+a*j),f=await k.read(j*b,l[2][0].p+a*j),h=await t(e,f),i=m.slice(a*g.n8r,(a+b)*g.n8r),n=await c.multiExpAffine(h,i);q=c.add(q,n)}if(m=await i.batchToMontgomery(m),g.power<i.s)a=i.neg(i.e(2));else{let b=2**i.s,c=i.exp(i.shift,b);a=i.sub(c,i.one)}let r=g.power<i.s?i.w[g.power+1]:i.shift;m=await i.batchApplyKey(m,a,r),m=await i.fft(m),m=await i.batchFromMontgomery(m),await N(e,f,9);let u=c.zero;for(let a=0;a<g.domainSize;a+=1048576){d&&d.debug(`H Verification(lagrange):  ${a}/${g.domainSize}`);let b=Math.min(g.domainSize-a,1048576),f=await e.read(j*b),h=m.slice(a*g.n8r,(a+b)*g.n8r),i=await c.multiExpAffine(f,h);u=c.add(u,i)}return await O(e),!0===await aJ(h,q,u,g.vk_delta_2,o.vk_delta_2)}async function t(a,b){let c=2*h.G1.F.n8,d=a.byteLength/c,e=h.tm.concurrency,f=Math.floor(d/e),g=[];for(let c=0;c<e;c++){let h;if(0==(h=c<e-1?f:d-c*f))continue;let j=a.slice(c*f*i,(c*f+h)*i),k=b.slice(c*f*i,(c*f+h)*i);g.push(u(j,k))}let j=await Promise.all(g),k=new Uint8Array(d*c),l=0;for(let a=0;a<j.length;a++)k.set(j[a][0],l),l+=j[a][0].byteLength;return k}async function u(a,b){let c=2*h.G1.F.n8,d=3*h.G1.F.n8,e=a.byteLength/c,f=[];f.push({cmd:"ALLOCSET",var:0,buff:a}),f.push({cmd:"ALLOCSET",var:1,buff:b}),f.push({cmd:"ALLOC",var:2,len:e*d});for(let a=0;a<e;a++)f.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:a*c},{var:1,offset:a*c},{var:2,offset:a*d}]});return f.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:e},{var:2}]}),f.push({cmd:"GET",out:0,var:2,len:e*c}),await h.tm.queueAction(f)}}async function dg(a,b,c,d){let e={type:"bigMem"};return await dc(a,b,e,d),await df(e,b,c,d)}async function dh(a,b,c,d,e){let{fd:f,sections:g}=await J(a,"zkey",2),h=await aX(f,g);if("groth16"!=h.protocol)throw Error("zkey file is not groth16");let i=await Z(h.q),j=await a1(f,i,g),k=await K(b,"zkey",1,10),l=await aN(d),m=aA.create({dkLen:64});m.update(j.csHash);for(let a=0;a<j.contributions.length;a++)a5(m,i,j.contributions[a]);let n={};n.delta={},n.delta.prvKey=i.Fr.fromRng(l),n.delta.g1_s=i.G1.toAffine(i.G1.fromRng(l)),n.delta.g1_sx=i.G1.toAffine(i.G1.timesFr(n.delta.g1_s,n.delta.prvKey)),a4(m,i,n.delta.g1_s),a4(m,i,n.delta.g1_sx),n.transcript=m.digest(),n.delta.g2_sp=bs(i,n.transcript),n.delta.g2_spx=i.G2.toAffine(i.G2.timesFr(n.delta.g2_sp,n.delta.prvKey)),h.vk_delta_1=i.G1.timesFr(h.vk_delta_1,n.delta.prvKey),h.vk_delta_2=i.G2.timesFr(h.vk_delta_2,n.delta.prvKey),n.deltaAfter=h.vk_delta_1,n.type=0,c&&(n.name=c),j.contributions.push(n),await aS(k,h),await R(f,g,k,3),await R(f,g,k,4),await R(f,g,k,5),await R(f,g,k,6),await R(f,g,k,7);let o=i.Fr.inv(n.delta.prvKey);await bN(f,g,k,8,i,"G1",o,i.Fr.e(1),"L Section",e),await bN(f,g,k,9,i,"G1",o,i.Fr.e(1),"H Section",e),await a3(k,i,j),await f.close(),await k.close();let p=aA.create({dkLen:64});a5(p,i,n);let q=p.digest();return e&&e.info(aF(j.csHash,"Circuit Hash: ")),e&&e.info(aF(q,"Contribution Hash: ")),q}async function di(a,b,c,d,e,f){let g=aP(d);if(0==g.byteLength||2*g.byteLength!=d.length)return f&&f.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(g.length>=256)return f&&f.error("Maximum length of beacon hash is 255 bytes"),!1;if((e=parseInt(e))<10||e>63)return f&&f.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;let{fd:h,sections:i}=await J(a,"zkey",2),j=await aX(h,i);if("groth16"!=j.protocol)throw Error("zkey file is not groth16");let k=await Z(j.q),l=await a1(h,k,i),m=await K(b,"zkey",1,10),n=await aO(g,e),o=aA.create({dkLen:64});o.update(l.csHash);for(let a=0;a<l.contributions.length;a++)a5(o,k,l.contributions[a]);let p={};p.delta={},p.delta.prvKey=k.Fr.fromRng(n),p.delta.g1_s=k.G1.toAffine(k.G1.fromRng(n)),p.delta.g1_sx=k.G1.toAffine(k.G1.timesFr(p.delta.g1_s,p.delta.prvKey)),a4(o,k,p.delta.g1_s),a4(o,k,p.delta.g1_sx),p.transcript=o.digest(),p.delta.g2_sp=bs(k,p.transcript),p.delta.g2_spx=k.G2.toAffine(k.G2.timesFr(p.delta.g2_sp,p.delta.prvKey)),j.vk_delta_1=k.G1.timesFr(j.vk_delta_1,p.delta.prvKey),j.vk_delta_2=k.G2.timesFr(j.vk_delta_2,p.delta.prvKey),p.deltaAfter=j.vk_delta_1,p.type=1,p.numIterationsExp=e,p.beaconHash=g,c&&(p.name=c),l.contributions.push(p),await aS(m,j),await R(h,i,m,3),await R(h,i,m,4),await R(h,i,m,5),await R(h,i,m,6),await R(h,i,m,7);let q=k.Fr.inv(p.delta.prvKey);await bN(h,i,m,8,k,"G1",q,k.Fr.e(1),"L Section",f),await bN(h,i,m,9,k,"G1",q,k.Fr.e(1),"H Section",f),await a3(m,k,l),await h.close(),await m.close();let r=aA.create({dkLen:64});a5(r,k,p);let s=r.digest();return f&&f.info(aF(s,"Contribution Hash: ")),s}async function dj(a){let b=await a_(a,!0);return delete b.curve,delete b.F,s.Wp.stringifyBigInts(b)}async function dk(a,b,c,d,e){let f=await aN(d),g=a.Fr.fromRng(f),h=a.Fr.inv(g),i=2*a.G1.F.n8,j=2*a.G2.F.n8,k=await I(b),l=await H(c);await C(i),await C(i),await C(j),await C(j);let m=await D(),n=a.G1.timesFr(m,g);await F(n);let o=await E(),p=a.G2.timesFr(o,g);await G(p);let q=await k.readUBE32();await l.writeUBE32(q),await C(q*i);let r=await k.readUBE32();await l.writeUBE32(r),await bO(k,l,null,a,"G1",r,h,a.Fr.e(1),"UNCOMPRESSED","H",e);let s=await k.readUBE32();await l.writeUBE32(s),await bO(k,l,null,a,"G1",s,h,a.Fr.e(1),"UNCOMPRESSED","L",e);let t=await k.readUBE32();await l.writeUBE32(t),await C(t*i);let u=await k.readUBE32();await l.writeUBE32(u),await C(u*i);let v=await k.readUBE32();await l.writeUBE32(v),await C(v*j);let w=aA.create({dkLen:64}),x={};x.csHash=await k.read(64),w.update(x.csHash);let y=await k.readUBE32();x.contributions=[];for(let b=0;b<y;b++){let b={delta:{}};b.deltaAfter=await D(),b.delta.g1_s=await D(),b.delta.g1_sx=await D(),b.delta.g2_spx=await E(),b.transcript=await k.read(64),x.contributions.push(b),a5(w,a,b)}let z={};z.delta={},z.delta.prvKey=g,z.delta.g1_s=a.G1.toAffine(a.G1.fromRng(f)),z.delta.g1_sx=a.G1.toAffine(a.G1.timesFr(z.delta.g1_s,g)),a4(w,a,z.delta.g1_s),a4(w,a,z.delta.g1_sx),z.transcript=w.digest(),z.delta.g2_sp=bs(a,z.transcript),z.delta.g2_spx=a.G2.toAffine(a.G2.timesFr(z.delta.g2_sp,g)),z.deltaAfter=n,z.type=0,x.contributions.push(z),await l.write(x.csHash),await l.writeUBE32(x.contributions.length);for(let a=0;a<x.contributions.length;a++){let b=x.contributions[a];await F(b.deltaAfter),await F(b.delta.g1_s),await F(b.delta.g1_sx),await G(b.delta.g2_spx),await l.write(b.transcript)}let A=aA.create({dkLen:64});a5(A,a,z);let B=A.digest();return e&&e.info(aF(B,"Contribution Hash: ")),await l.close(),await k.close(),B;async function C(a){let b=2*k.pageSize;for(let c=0;c<a;c+=b){let d=Math.min(a-c,b),e=await k.read(d);await l.write(e)}}async function D(){let b=await k.read(2*a.G1.F.n8);return a.G1.fromRprUncompressed(b,0)}async function E(){let b=await k.read(2*a.G2.F.n8);return a.G2.fromRprUncompressed(b,0)}async function F(b){let c=new Uint8Array(i);a.G1.toRprUncompressed(c,0,b),await l.write(c)}async function G(b){let c=new Uint8Array(j);a.G2.toRprUncompressed(c,0,b),await l.write(c)}}let{stringifyBigInts:dl}=s.Wp;async function dm(a,b){let c;b&&b.info("EXPORT VERIFICATION KEY STARTED");let{fd:d,sections:e}=await J(a,"zkey",2),f=await aX(d,e);if(b&&b.info("> Detected protocol: "+f.protocol),"groth16"===f.protocol)c=await dn(f,d,e);else if("plonk"===f.protocol)c=await dp(f);else if(f.protocolId&&10===f.protocolId)c=await dq(f,b);else throw Error("zkey file protocol unrecognized");return await d.close(),b&&b.info("EXPORT VERIFICATION KEY FINISHED"),c}async function dn(a,b,c){let d=await Z(a.q),e=2*d.G1.F.n8,f=await d.pairing(a.vk_alpha_1,a.vk_beta_2),g={protocol:a.protocol,curve:d.name,nPublic:a.nPublic,vk_alpha_1:d.G1.toObject(a.vk_alpha_1),vk_beta_2:d.G2.toObject(a.vk_beta_2),vk_gamma_2:d.G2.toObject(a.vk_gamma_2),vk_delta_2:d.G2.toObject(a.vk_delta_2),vk_alphabeta_12:d.Gt.toObject(f)};await N(b,c,3),g.IC=[];for(let c=0;c<=a.nPublic;c++){let a=await b.read(e),c=d.G1.toObject(a);g.IC.push(c)}return await O(b),g=dl(g)}async function dp(a){let b=await Z(a.q),c={protocol:a.protocol,curve:b.name,nPublic:a.nPublic,power:a.power,k1:b.Fr.toObject(a.k1),k2:b.Fr.toObject(a.k2),Qm:b.G1.toObject(a.Qm),Ql:b.G1.toObject(a.Ql),Qr:b.G1.toObject(a.Qr),Qo:b.G1.toObject(a.Qo),Qc:b.G1.toObject(a.Qc),S1:b.G1.toObject(a.S1),S2:b.G1.toObject(a.S2),S3:b.G1.toObject(a.S3),X_2:b.G2.toObject(a.X_2),w:b.Fr.toObject(b.Fr.w[a.power])};return dl(c)}async function dq(a,b){let c=await Z(a.q);return dl({protocol:a.protocol,curve:c.name,nPublic:a.nPublic,power:a.power,k1:c.Fr.toObject(a.k1),k2:c.Fr.toObject(a.k2),w:c.Fr.toObject(c.Fr.w[a.power]),w3:c.Fr.toObject(a.w3),w4:c.Fr.toObject(a.w4),w8:c.Fr.toObject(a.w8),wr:c.Fr.toObject(a.wr),X_2:c.G2.toObject(a.X_2),C0:c.G1.toObject(a.C0)})}var dr=c(966);let{unstringifyBigInts:ds,stringifyBigInts:dt}=s.Wp;async function du(a,b,c){c&&c.info("FFLONK EXPORT SOLIDITY VERIFIER STARTED");let d=await $(a.curve),e=j(a.w3);a.w3_2=k(d.Fr.square(e));let f=j(a.w4);a.w4_2=k(d.Fr.square(f)),a.w4_3=k(d.Fr.mul(d.Fr.square(f),f));let g=j(a.w8),h=d.Fr.one;for(let b=1;b<8;b++)h=d.Fr.mul(h,g),a["w8_"+b]=k(h);let i=b[a.protocol];return c&&c.info("FFLONK EXPORT SOLIDITY VERIFIER FINISHED"),dr.render(i,a);function j(a){let b=ds(a);return d.Fr.fromObject(b)}function k(a){return dt(d.Fr.toObject(a))}}async function dv(a,b,c){let d=await dm(a,c);if("fflonk"===d.protocol)return du(d,b,c);let e=b[d.protocol];return dr.render(e,d)}async function dw(a,b,c,d){globalThis.gc&&globalThis.gc();let{fd:e,sections:f}=await J(b,"ptau",1,4194304,0x1000000),{curve:g,power:h}=await bx(e,f),{fd:i,sections:j}=await J(a,"r1cs",1,4194304,0x1000000),k=await cY(i,j,{loadConstraints:!0,loadCustomGates:!0}),l=2*g.G1.F.n8,m=g.G1,n=2*g.G2.F.n8,o=g.Fr,p=g.Fr.n8;d&&d.info("Reading r1cs"),await S(i,j,2);let q=new db,r=new db,t=k.nVars,u=k.nOutputs+k.nPubInputs;await E(g.Fr,k,d),globalThis.gc&&globalThis.gc();let v=await K(c,"zkey",1,14,4194304,0x1000000);if(k.prime!=g.r)return d&&d.error("r1cs curve does not match powers of tau ceremony curve"),-1;let w=aE(q.length-1)+1;w<3&&(w=3);let x=2**w;if(d&&d.info("Plonk constraints: "+q.length),w>h)return d&&d.error(`circuit too big for this power of tau ceremony. ${q.length} > 2**${h}`),-1;if(!f[12])return d&&d.error("Powers of tau is not prepared."),-1;let y=new s.Zh(x*l),z=f[12][0].p+(2**w-1)*l;await e.readToBuffer(y,0,x*l,z);let[A,B]=function(){let a=o.two;for(;c(a,[],w);)o.add(a,o.one);let b=o.add(a,o.one);for(;c(b,[a],w);)o.add(b,o.one);return[a,b];function c(a,b,c){let d=2**c,e=o.one;for(let f=0;f<d;f++){if(o.eq(a,e))return!0;for(let c=0;c<b.length;c++)if(o.eq(a,o.mul(b[c],e)))return!0;e=o.mul(e,o.w[c])}return!1}}(),C={};await I(3,"Additions"),globalThis.gc&&globalThis.gc(),await F(4,0,"Amap"),globalThis.gc&&globalThis.gc(),await F(5,1,"Bmap"),globalThis.gc&&globalThis.gc(),await F(6,2,"Cmap"),globalThis.gc&&globalThis.gc(),await G(7,3,"Qm"),globalThis.gc&&globalThis.gc(),await G(8,4,"Ql"),globalThis.gc&&globalThis.gc(),await G(9,5,"Qr"),globalThis.gc&&globalThis.gc(),await G(10,6,"Qo"),globalThis.gc&&globalThis.gc(),await G(11,7,"Qc"),globalThis.gc&&globalThis.gc(),await N(12,"sigma"),globalThis.gc&&globalThis.gc(),await O(13,"lagrange polynomials"),globalThis.gc&&globalThis.gc(),await L(v,14);let D=new s.Zh((x+6)*l);async function E(a,b,c){function d(a){let b=Object.keys(a);for(let c=0;c<b.length;c++)0n==a[b[c]]&&delete a[b[c]]}function e(b,c,e){let f={};for(let d in b)void 0===f[d]?f[d]=a.mul(c,b[d]):f[d]=a.add(f[d],a.mul(c,b[d]));for(let b in e){let c=a.neg(e[b]);void 0===f[b]?f[b]=c:f[b]=a.add(f[b],c)}return d(f),f}function f(b,c){let d={k:a.zero,s:[],coefs:[]},e=[];for(let c in b)0==c?d.k=a.add(d.k,b[c]):0n!=b[c]&&e.push([Number(c),b[c]]);for(;e.length>c;){let b=e.shift(),c=e.shift(),d=b[0],f=c[0],g=t++,h=a.zero,i=a.neg(b[1]),j=a.neg(c[1]),k=a.one,l=a.zero;q.push([d,f,g,h,i,j,k,l]),r.push([d,f,b[1],c[1]]),e.push([g,a.one])}for(let a=0;a<e.length;a++)d.s[a]=e[a][0],d.coefs[a]=e[a][1];for(;d.coefs.length<c;)d.s.push(0),d.coefs.push(a.zero);return d}function g(b){let c=f(b,3),d=c.s[0],e=c.s[1],g=c.s[2],h=a.zero,i=c.coefs[0],j=c.coefs[1],k=c.coefs[2],l=c.k;q.push([d,e,g,h,i,j,k,l])}function h(b){let c=a.zero,d=0,e=Object.keys(b);for(let f=0;f<e.length;f++)0n==b[e[f]]?delete b[e[f]]:0==e[f]?c=a.add(c,b[e[f]]):d++;return d>0?d.toString():c!=a.zero?"k":"0"}for(let b=1;b<=u;b++){let c=b,d=a.zero,e=a.one,f=a.zero,g=a.zero,h=a.zero;q.push([c,0,0,d,e,f,g,h])}for(let i=0;i<b.constraints.length;i++)c&&i%1e4==0&&c.debug(`processing constraints: ${i}/${b.nConstraints}`),function(b,c,i){let j=h(b),k=h(c);if("0"===j||"0"===k)d(i),g(i);else if("k"===j)g(e(c,b[0],i));else if("k"===k)g(e(b,c[0],i));else{let d,e,g,h,j,k,l,m,n,o,p;d=f(b,1),e=f(c,1),g=f(i,1),h=d.s[0],j=e.s[0],k=g.s[0],l=a.mul(d.coefs[0],e.coefs[0]),m=a.mul(d.coefs[0],e.k),n=a.mul(d.k,e.coefs[0]),o=a.neg(g.coefs[0]),p=a.sub(a.mul(d.k,e.k),g.k),q.push([h,j,k,l,m,n,o,p])}}(...b.constraints[i])}async function F(a,b,c){await L(v,a);for(let a=0;a<q.length;a++)await v.writeULE32(q[a][b]),d&&a%1e6==0&&d.debug(`writing ${c}: ${a}/${q.length}`);await M(v)}async function G(a,b,c){let e=new s.Zh(x*p);for(let a=0;a<q.length;a++)e.set(q[a][b],a*p),d&&a%1e6==0&&d.debug(`writing ${c}: ${a}/${q.length}`);await L(v,a),await H(e),await M(v),e=await o.batchFromMontgomery(e),C[c]=await g.G1.multiExpAffine(y,e,d,"multiexp "+c)}async function H(a){let b=await o.ifft(a),c=new s.Zh(x*p*4);c.set(b,0);let d=await o.fft(c);await v.write(b),await v.write(d)}async function I(a,b){await L(v,a);let c=new Uint8Array(8+2*p),e=new DataView(c.buffer);for(let a=0;a<r.length;a++){let f=r[a],g=0;e.setUint32(g,f[0],!0),g+=4,e.setUint32(g,f[1],!0),g+=4,c.set(f[2],g),g+=p,c.set(f[3],g),g+=p,await v.write(c),d&&a%1e6==0&&d.debug(`writing ${b}: ${a}/${r.length}`)}await M(v)}async function N(a,b){let c=new s.Zh(p*x*3),e=new db(t),f=new db(t),h=o.one;for(let a=0;a<x;a++)a<q.length?(l(q[a][0],a),l(q[a][1],x+a),l(q[a][2],2*x+a)):(l(0,a),l(0,x+a),l(0,2*x+a)),h=o.mul(h,o.w[w]),d&&a%1e6==0&&d.debug(`writing ${b} phase1: ${a}/${q.length}`);for(let a=0;a<t;a++)void 0!==f[a]?c.set(e[a],f[a]*p):console.log("Variable not used"),d&&a%1e6==0&&d.debug(`writing ${b} phase2: ${a}/${t}`);globalThis.gc&&globalThis.gc(),await L(v,a);let i=c.slice(0,x*p);await H(i),globalThis.gc&&globalThis.gc();let j=c.slice(x*p,x*p*2);await H(j),globalThis.gc&&globalThis.gc();let k=c.slice(x*p*2,x*p*3);function l(a,b){let d;void 0===e[a]?f[a]=b:c.set(e[a],b*p),d=b<x?h:b<2*x?o.mul(h,A):o.mul(h,B),e[a]=d}await H(k),globalThis.gc&&globalThis.gc(),await M(v),i=await o.batchFromMontgomery(i),j=await o.batchFromMontgomery(j),k=await o.batchFromMontgomery(k),C.S1=await g.G1.multiExpAffine(y,i,d,"multiexp S1"),globalThis.gc&&globalThis.gc(),C.S2=await g.G1.multiExpAffine(y,j,d,"multiexp S2"),globalThis.gc&&globalThis.gc(),C.S3=await g.G1.multiExpAffine(y,k,d,"multiexp S3"),globalThis.gc&&globalThis.gc()}async function O(a,b){await L(v,a);let c=Math.max(u,1);for(let a=0;a<c;a++){let e=new s.Zh(x*p);e.set(o.one,a*p),await H(e),d&&d.debug(`writing ${b} ${a}/${c}`)}await M(v)}async function Q(){let a;await L(v,1),await v.writeULE32(2),await M(v),await L(v,2);let b=g.q,c=(Math.floor((s.X5.bitLength(b)-1)/64)+1)*8,d=g.r,h=(Math.floor((s.X5.bitLength(d)-1)/64)+1)*8;await v.writeULE32(c),await P(v,b,c),await v.writeULE32(h),await P(v,d,h),await v.writeULE32(t),await v.writeULE32(u),await v.writeULE32(x),await v.writeULE32(r.length),await v.writeULE32(q.length),await v.write(A),await v.write(B),await v.write(m.toAffine(C.Qm)),await v.write(m.toAffine(C.Ql)),await v.write(m.toAffine(C.Qr)),await v.write(m.toAffine(C.Qo)),await v.write(m.toAffine(C.Qc)),await v.write(m.toAffine(C.S1)),await v.write(m.toAffine(C.S2)),await v.write(m.toAffine(C.S3)),a=await e.read(n,f[3][0].p+n),await v.write(a),await M(v)}await e.readToBuffer(D,0,(x+6)*l,f[2][0].p),await v.write(D),await M(v),globalThis.gc&&globalThis.gc(),await Q(),await v.close(),await i.close(),await e.close(),d&&d.info("Setup Finished")}class dx{constructor(a,b){this.curve=a,this.logger=b,this.resetProof()}resetProof(){this.polynomials={},this.evaluations={}}addPolynomial(a,b){a in this.polynomials&&this.logger.warn(`proof: polynomial.${a} already exist in proof`),this.polynomials[a]=b}getPolynomial(a){return a in this.polynomials||this.logger.warn(`proof: polynomial ${a} does not exist in proof`),this.polynomials[a]}addEvaluation(a,b){a in this.evaluations&&this.logger.warn(`proof: evaluations.${a} already exist in proof`),this.evaluations[a]=b}getEvaluation(a){return a in this.evaluations||this.logger.warn(`proof: evaluation ${a} does not exist in proof`),this.evaluations[a]}toObjectProof(a=!0){let b=a?{polynomials:{},evaluations:{}}:{};return Object.keys(this.polynomials).forEach(c=>{let d=this.curve.G1.toObject(this.polynomials[c]);a?b.polynomials[c]=d:b[c]=d}),Object.keys(this.evaluations).forEach(c=>{let d=this.curve.Fr.toObject(this.evaluations[c]);a?b.evaluations[c]=d:b[c]=d}),b}fromObjectProof(a){this.resetProof(),Object.keys(a.polynomials).forEach(b=>{this.polynomials[b]=this.curve.G1.fromObject(a.polynomials[b])}),Object.keys(a.evaluations).forEach(b=>{this.evaluations[b]=this.curve.Fr.fromObject(a.evaluations[b])})}}let dy=BigInt(0),dz=BigInt(1),dA=BigInt(2),dB=BigInt(7),dC=BigInt(256),dD=BigInt(113),dE=[],dF=[],dG=[];for(let a=0,b=dz,c=1,d=0;a<24;a++){[c,d]=[d,(2*c+3*d)%5],dE.push(2*(5*d+c)),dF.push((a+1)*(a+2)/2%64);let e=dy;for(let a=0;a<7;a++)(b=(b<<dz^(b>>dB)*dD)%dC)&dA&&(e^=dz<<(dz<<BigInt(a))-dz);dG.push(e)}let dH=function(a,b=!1){let c=a.length,d=new Uint32Array(c),e=new Uint32Array(c);for(let f=0;f<c;f++){let{h:c,l:g}=ao(a[f],b);[d[f],e[f]]=[c,g]}return[d,e]}(dG,!0),dI=dH[0],dJ=dH[1],dK=(a,b,c)=>c>32?b<<c-32|a>>>64-c:a<<c|b>>>32-c,dL=(a,b,c)=>c>32?a<<c-32|b>>>64-c:b<<c|a>>>32-c;class dM extends ak{constructor(a,b,c,d=!1,e=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=a,this.suffix=b,this.outputLen=c,this.enableXOF=d,this.rounds=e,_(c),!(0<a&&a<200))throw Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=ad(this.state)}clone(){return this._cloneInto()}keccak(){ai(this.state32),function(a,b=24){let c=new Uint32Array(10);for(let d=24-b;d<24;d++){for(let b=0;b<10;b++)c[b]=a[b]^a[b+10]^a[b+20]^a[b+30]^a[b+40];for(let b=0;b<10;b+=2){let d=(b+8)%10,e=(b+2)%10,f=c[e],g=c[e+1],h=dK(f,g,1)^c[d],i=dL(f,g,1)^c[d+1];for(let c=0;c<50;c+=10)a[b+c]^=h,a[b+c+1]^=i}let b=a[2],e=a[3];for(let c=0;c<24;c++){let d=dF[c],f=dK(b,e,d),g=dL(b,e,d),h=dE[c];b=a[h],e=a[h+1],a[h]=f,a[h+1]=g}for(let b=0;b<50;b+=10){for(let d=0;d<10;d++)c[d]=a[b+d];for(let d=0;d<10;d++)a[b+d]^=~c[(d+2)%10]&c[(d+4)%10]}a[0]^=dI[d],a[1]^=dJ[d]}ae(c)}(this.state32,this.rounds),ai(this.state32),this.posOut=0,this.pos=0}update(a){ab(this),aa(a=aj(a));let{blockLen:b,state:c}=this,d=a.length;for(let e=0;e<d;){let f=Math.min(b-this.pos,d-e);for(let b=0;b<f;b++)c[this.pos++]^=a[e++];this.pos===b&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:a,suffix:b,pos:c,blockLen:d}=this;a[c]^=b,(128&b)!=0&&c===d-1&&this.keccak(),a[d-1]^=128,this.keccak()}writeInto(a){ab(this,!1),aa(a),this.finish();let b=this.state,{blockLen:c}=this;for(let d=0,e=a.length;d<e;){this.posOut>=c&&this.keccak();let f=Math.min(c-this.posOut,e-d);a.set(b.subarray(this.posOut,this.posOut+f),d),this.posOut+=f,d+=f}return a}xofInto(a){if(!this.enableXOF)throw Error("XOF is not possible for this instance");return this.writeInto(a)}xof(a){return _(a),this.xofInto(new Uint8Array(a))}digestInto(a){if(ac(a,this),this.finished)throw Error("digest() was already called");return this.writeInto(a),this.destroy(),a}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,ae(this.state)}_cloneInto(a){let{blockLen:b,suffix:c,outputLen:d,rounds:e,enableXOF:f}=this;return a||(a=new dM(b,c,d,f,e)),a.state32.set(this.state32),a.pos=this.pos,a.posOut=this.posOut,a.finished=this.finished,a.rounds=e,a.suffix=c,a.outputLen=d,a.enableXOF=f,a.destroyed=this.destroyed,a}}let dN=(j=()=>new dM(136,1,32),(g=a=>j().update(aj(a)).digest()).outputLen=(h=j()).outputLen,g.blockLen=h.blockLen,g.create=()=>j(),g);class dO{constructor(a){this.G1=a.G1,this.Fr=a.Fr,this.reset()}reset(){this.data=[]}addPolCommitment(a){this.data.push({type:0,data:a})}addScalar(a){this.data.push({type:1,data:a})}getChallenge(){if(0===this.data.length)throw Error("Keccak256Transcript: No data to generate a transcript");let a=0,b=0;this.data.forEach(c=>0===c.type?a++:b++);let c=new Uint8Array(b*this.Fr.n8+a*this.G1.F.n8*2),d=0;for(let a=0;a<this.data.length;a++)0===this.data[a].type?(this.G1.toRprUncompressed(c,d,this.data[a].data),d+=2*this.G1.F.n8):(this.Fr.toRprBE(c,d,this.data[a].data),d+=this.Fr.n8);let e=s.X5.fromRprBE(dN(c));return this.Fr.e(e)}}class dP{static getZ1(a){return[a.zero,a.add(a.e(-1),a.w[2]),a.e(-2),a.sub(a.e(-1),a.w[2])]}static getZ2(a){return[a.zero,a.add(a.zero,a.mul(a.e(-2),a.w[2])),a.e(4),a.sub(a.zero,a.mul(a.e(-2),a.w[2]))]}static getZ3(a){return[a.zero,a.add(a.e(2),a.mul(a.e(2),a.w[2])),a.e(-8),a.sub(a.e(2),a.mul(a.e(2),a.w[2]))]}static mul2(a,b,c,d,e,f){let g,h=this.getZ1(f),i=f.mul(a,b),j=f.mul(a,d),k=f.mul(c,b),l=f.mul(c,d);return g=f.add(j,k),e&&(g=f.add(g,f.mul(h[e],l))),[i,g]}static mul3(a,b,c,d,e,f,g,h){let i,j,k=this.getZ1(h),l=this.getZ2(h),m=h.mul(a,b),n=h.mul(a,e),o=h.mul(d,b),p=h.mul(d,e);i=h.mul(m,c);let q=h.mul(o,c);q=h.add(q,h.mul(n,c)),q=h.add(q,h.mul(m,f));let r=h.mul(p,c);if(r=h.add(r,h.mul(n,f)),r=h.add(r,h.mul(o,f)),j=q,g){let a=h.mul(p,f);j=h.add(j,h.mul(k[g],r)),j=h.add(j,h.mul(l[g],a))}return[i,j]}static mul4(a,b,c,d,e,f,g,h,i,j){let k,l,m=this.getZ1(j),n=this.getZ2(j),o=this.getZ3(j),p=j.mul(a,b),q=j.mul(a,f),r=j.mul(e,b),s=j.mul(e,f),t=j.mul(c,d),u=j.mul(c,h),v=j.mul(g,d),w=j.mul(g,h);k=j.mul(p,t);let x=j.mul(r,t);x=j.add(x,j.mul(q,t)),x=j.add(x,j.mul(p,v)),x=j.add(x,j.mul(p,u));let y=j.mul(s,t);y=j.add(y,j.mul(r,v)),y=j.add(y,j.mul(r,u)),y=j.add(y,j.mul(q,v)),y=j.add(y,j.mul(q,u)),y=j.add(y,j.mul(p,w));let z=j.mul(q,w);z=j.add(z,j.mul(r,w)),z=j.add(z,j.mul(s,u)),z=j.add(z,j.mul(s,v));let A=j.mul(s,w);return l=x,i&&(l=j.add(l,j.mul(m[i],y)),l=j.add(l,j.mul(n[i],z)),l=j.add(l,j.mul(o[i],A))),[k,l]}}class dQ{constructor(a,b,c){this.coef=a,this.curve=b,this.Fr=b.Fr,this.G1=b.G1,this.logger=c}static async fromEvaluations(a,b,c){return new dQ(await b.Fr.ifft(a),b,c)}static fromCoefficientsArray(a,b,c){let d=b.Fr,e=a.length>32768?new s.Zh(a.length*d.n8):new Uint8Array(a.length*d.n8);for(let b=0;b<a.length;b++)e.set(a[b],b*d.n8);return new dQ(e,b,c)}static fromPolynomial(a,b,c){let d=a.length(),e=b.Fr,f=d>32768?new s.Zh(d*e.n8):new Uint8Array(d*e.n8);return f.set(a.coef.slice(),0),new dQ(f,b,c)}isEqual(a){let b=this.degree();if(b!==a.degree())return!1;for(let c=0;c<b+1;c++)if(!this.Fr.eq(this.getCoef(c),a.getCoef(c)))return!1;return!0}blindCoefficients(a){a=a||[];let b=this.length()+a.length>32768?new s.Zh((this.length()+a.length)*this.Fr.n8):new Uint8Array((this.length()+a.length)*this.Fr.n8);b.set(this.coef,0);for(let c=0;c<a.length;c++)b.set(this.Fr.add(b.slice((this.length()+c)*this.Fr.n8,(this.length()+c+1)*this.Fr.n8),a[c]),(this.length()+c)*this.Fr.n8),b.set(this.Fr.sub(b.slice(c*this.Fr.n8,(c+1)*this.Fr.n8),a[c]),c*this.Fr.n8);this.coef=b}getCoef(a){let b=a*this.Fr.n8;return b+this.Fr.n8>this.coef.byteLength?this.Fr.zero:this.coef.slice(b,b+this.Fr.n8)}setCoef(a,b){if(a>this.length()-1)throw Error("Coef index is not available");this.coef.set(b,a*this.Fr.n8)}static async to4T(a,b,c,d){c=c||[];let e=await d.ifft(a),f=4*b>32768?new s.Zh(4*b*d.n8):new Uint8Array(4*b*d.n8);f.set(e,0);let g=await d.fft(f);if(0===c.length)return[e,g];let h=b+c.length>32768?new s.Zh((b+c.length)*d.n8):new Uint8Array((b+c.length)*d.n8);h.set(e,0);for(let a=0;a<c.length;a++)h.set(d.add(h.slice((b+a)*d.n8,(b+a+1)*d.n8),c[a]),(b+a)*d.n8),h.set(d.sub(h.slice(a*d.n8,(a+1)*d.n8),c[a]),a*d.n8);return[h,g]}length(){let a=this.coef.byteLength/this.Fr.n8;if(a!==Math.floor(this.coef.byteLength/this.Fr.n8))throw Error("Polynomial coefficients buffer has incorrect size");return 0===a&&this.logger&&this.logger.warn("Polynomial has length zero"),a}degree(){for(let a=this.length()-1;a>0;a--){let b=a*this.Fr.n8;if(!this.Fr.eq(this.Fr.zero,this.coef.slice(b,b+this.Fr.n8)))return a}return 0}evaluate(a){let b=this.Fr.zero;for(let c=this.degree()+1;c>0;c--){let d=c*this.Fr.n8,e=this.coef.slice(d-this.Fr.n8,d);b=this.Fr.add(e,this.Fr.mul(b,a))}return b}fastEvaluate(a){let b=this.Fr,c=this.degree()+1,d=parseInt(c/3),e=c-3*d,f=[],g=[];g[0]=b.one;for(let c=0;c<3;c++){f[c]=b.zero;let h=2===c?d+e:d;for(let e=h;e>0;e--)f[c]=b.add(this.getCoef(c*d+e-1),b.mul(f[c],a)),0===c&&(g[0]=b.mul(g[0],a))}for(let a=1;a<3;a++)f[0]=b.add(f[0],b.mul(g[a-1],f[a])),g[a]=b.mul(g[a-1],g[0]);return f[0]}add(a,b){let c=!1;a.length()>this.length()&&(c=!0);let d=this.length(),e=a.length();for(let f=0;f<Math.max(d,e);f++){let g=f*this.Fr.n8,h=f<d?this.coef.slice(g,g+this.Fr.n8):this.Fr.zero,i=f<e?a.coef.slice(g,g+this.Fr.n8):this.Fr.zero;void 0!==b&&(i=this.Fr.mul(i,b)),c?a.coef.set(this.Fr.add(h,i),g):this.coef.set(this.Fr.add(h,i),g)}c&&(delete this.coef,this.coef=a.coef)}sub(a,b){let c=!1;a.length()>this.length()&&(c=!0);let d=this.length(),e=a.length();for(let f=0;f<Math.max(d,e);f++){let g=f*this.Fr.n8,h=f<d?this.coef.slice(g,g+this.Fr.n8):this.Fr.zero,i=f<e?a.coef.slice(g,g+this.Fr.n8):this.Fr.zero;void 0!==b&&(i=this.Fr.mul(i,b)),c?a.coef.set(this.Fr.sub(h,i),g):this.coef.set(this.Fr.sub(h,i),g)}c&&(delete this.coef,this.coef=a.coef)}mulScalar(a){for(let b=0;b<this.length();b++){let c=b*this.Fr.n8;this.coef.set(this.Fr.mul(this.coef.slice(c,c+this.Fr.n8),a),c)}}addScalar(a){let b=0===this.length()?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.add(b,a),0)}subScalar(a){let b=0===this.length()?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.sub(b,a),0)}byXSubValue(a){let b=this.Fr,c=b.eq(b.zero,this.getCoef(this.length()-1))?this.length():this.length()+1,d=new dQ(c>32768?new s.Zh(c*b.n8):new Uint8Array(c*b.n8),this.curve,this.logger);d.coef.set(this.coef.slice(0,(c-1)*b.n8),32),this.mulScalar(b.neg(a)),d.add(this),this.coef=d.coef}byXNSubValue(a,b){let c=this.Fr,d=this.length()-a-1>=this.degree()?this.length():this.length()+a,e=new dQ(d>32768?new s.Zh(d*c.n8):new Uint8Array(d*c.n8),this.curve,this.logger);e.coef.set(this.coef.slice(0,(this.degree()+1)*32),32*a),this.mulScalar(b),e.add(this),this.coef=e.coef}divBy(a){let b=this.Fr,c=this.degree(),d=a.degree(),e=new dQ(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new s.Zh(this.length()*b.n8):new Uint8Array(this.length()*b.n8);for(let f=c-d;f>=0;f--){this.setCoef(f,b.div(e.getCoef(f+d),a.getCoef(d)));for(let c=0;c<=d;c++)e.setCoef(f+c,b.sub(e.getCoef(f+c),b.mul(this.getCoef(f),a.getCoef(c))))}return e}divByMonic(a,b){let c=this.Fr,d=this.degree(),e=new dQ(this.length()>32768?new s.Zh(this.length()*c.n8):new Uint8Array(this.length()*c.n8),this.curve,this.logger),f=[];for(let b=0;b<a;b++)e.setCoef(d-b-a,this.getCoef(d-b)),f[b]=this.getCoef(d-b);let g=0;for(let h=0;h<a;h++)for(let i=d-2*a-h;i>=0&&!(i<0);i-=a){let d=h;f[d]=c.add(this.getCoef(i+a),c.mul(f[d],b)),e.setCoef(i,f[d]),g=(g+1)%a}this.coef=e.coef}divByVanishing(a,b){if(this.degree()<a)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let c=this.Fr,d=new dQ(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new s.Zh(this.length()*c.n8):new Uint8Array(this.length()*c.n8);for(let e=this.length()-1;e>=a;e--){let f=d.getCoef(e);c.eq(c.zero,f)||(d.setCoef(e,c.zero),d.setCoef(e-a,c.add(d.getCoef(e-a),c.mul(b,f))),this.setCoef(e-a,c.add(this.getCoef(e-a),f)))}return d}divByVanishing2(a,b){if(this.degree()<a)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let c=this.Fr,d=new dQ(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new s.Zh(this.length()*c.n8):new Uint8Array(this.length()*c.n8);let e=this.length()-a,f=Math.floor(e/3),g=e-2*f;console.log(e),console.log(f+"  "+g);for(let e=0;e<3;e++){console.log("> Thread "+e);for(let h=0===e?g:f;h>0;h--){let i=h-1;0!==e&&(i+=(e-1)*f+g);let j=i+a,k=d.getCoef(j);c.eq(c.zero,k)||(d.setCoef(j,c.zero),d.setCoef(i,c.add(d.getCoef(i),c.mul(b,k))),this.setCoef(i,c.add(this.getCoef(i),k)),console.log(i+" <-- "+j))}}return this.print(),d}fastDivByVanishing(a){let b=this.Fr;for(let c=0;c<a.length;c++){let d=a[c][0],e=a[c][1];if(this.degree()<d)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let f=this.length()-d,g=Math.floor(f/5/d),h=g*d,i=f-5*h,j=new dQ(this.length()>32768?new s.Zh(this.length()*b.n8):new Uint8Array(this.length()*b.n8),this.curve,this.logger),k=this.coef;this.coef=j.coef,j.coef=k;for(let a=0;a<5;a++){let c=(a+1)*h+i;for(let a=0;a<d;a++)this.setCoef(c+a-d,j.getCoef(c+a));for(let a=0;a<h-d;a++){let f=c-a-1,g=b.add(j.getCoef(f),b.mul(e,this.getCoef(f)));this.setCoef(f-d,g)}}let l=i;for(let a=0;a<d&&l;a++)this.setCoef(i-a-1,j.getCoef(i+d-a-1)),l--;for(let a=0;a<l;a++){let c=i-a-1,f=b.add(j.getCoef(c),b.mul(e,this.getCoef(c)));this.setCoef(c-d,f)}let m=[],n=b.one;for(let a=0;a<g;a++)n=b.mul(n,e);let o=b.one;for(let a=5;a>0;a--){let c=a-1,e=c*h+i;m[c]=[];for(let f=0;f<d;f++)m[c][f]=this.getCoef(e+f),5!==a&&(m[c][f]=b.add(m[c][f],b.mul(n,m[c+1][f])));o=b.mul(o,n)}for(let a=0;a<5;a++){let c=a*h+i,f=e,g=d-1,j=0===a?i:h;for(let h=0;h<j;h++){let i=c-h-1,j=b.add(this.getCoef(i),b.mul(f,m[a][g]));this.setCoef(i,j),0===g?(g=d-1,f=b.mul(f,e)):g--}}}}divByXSubValue(a){let b=this.length()>32768?new s.Zh(this.length()*this.Fr.n8):new Uint8Array(this.length()*this.Fr.n8);b.set(this.Fr.zero,(this.length()-1)*this.Fr.n8),b.set(this.coef.slice((this.length()-1)*this.Fr.n8,this.length()*this.Fr.n8),(this.length()-2)*this.Fr.n8);for(let c=this.length()-3;c>=0;c--){let d=c*this.Fr.n8;b.set(this.Fr.add(this.coef.slice(d+this.Fr.n8,d+2*this.Fr.n8),this.Fr.mul(a,b.slice(d+this.Fr.n8,d+2*this.Fr.n8))),c*this.Fr.n8)}if(!this.Fr.eq(this.coef.slice(0,this.Fr.n8),this.Fr.mul(this.Fr.neg(a),b.slice(0,this.Fr.n8))))throw Error("Polynomial does not divide");this.coef=b}divZh(a,b=4){for(let b=0;b<a;b++){let a=b*this.Fr.n8;this.coef.set(this.Fr.neg(this.coef.slice(a,a+this.Fr.n8)),a)}let c=this.coef.byteLength/this.Fr.n8;for(let d=a;d<c;d++){let c=d*this.Fr.n8,e=this.Fr.sub(this.coef.slice((d-a)*this.Fr.n8,(d-a)*this.Fr.n8+this.Fr.n8),this.coef.slice(c,c+this.Fr.n8));if(this.coef.set(e,c),d>a*(b-1)-b&&!this.Fr.isZero(e))throw Error("Polynomial is not divisible")}return this}divByZerofier(a,b){let c=this.Fr,d=c.inv(b),e=c.neg(d),f=c.eq(c.one,e),g=c.eq(c.negone,e);if(!f)for(let b=0;b<a;b++){let a,d=b*this.Fr.n8;a=g?c.neg(this.coef.slice(d,d+this.Fr.n8)):c.mul(e,this.coef.slice(d,d+this.Fr.n8)),this.coef.set(a,d)}f=c.eq(c.one,d),g=c.eq(c.negone,d);for(let b=a;b<this.length();b++){let e=b*this.Fr.n8,h=(b-a)*this.Fr.n8,i=this.Fr.sub(this.coef.slice(h,h+this.Fr.n8),this.coef.slice(e,e+this.Fr.n8));if(f||(i=g?c.neg(i):c.mul(d,i)),this.coef.set(i,e),b>this.length()-a-1&&!this.Fr.isZero(i))throw Error("Polynomial is not divisible")}return this}byX(){let a=this.length()+1>32768?new s.Zh(this.coef.byteLength+this.Fr.n8):new Uint8Array(this.coef.byteLength+this.Fr.n8);a.set(this.Fr.zero,0),a.set(this.coef,this.Fr.n8),this.coef=a}static async expX(a,b,c=!1){let d=a.Fr;if(b<1)throw Error("Compute a new polynomial to a zero or negative number is not allowed");if(1===b)return await dQ.fromEvaluations(a.coef,curve,a.logger);let e=c?a.degree():a.length()-1,f=e*b+1>32768?new s.Zh((e*b+1)*d.n8):new Uint8Array((e*b+1)*d.n8);f.set(a.getCoef(0),0);for(let c=1;c<=e;c++){let e=c*d.n8,g=a.getCoef(c);f.set(g,e*b)}return new dQ(f,a.curve,a.logger)}split(a,b,c){if(a<1)throw Error(`Polynomials can't be split in ${a} parts`);if(1===a)return[this];if(0!==c.length&&c.length<a-1)throw Error(`Blinding factors length must be ${a-1}`);let d=(b+1)*this.Fr.n8,e=[],f=Math.ceil((this.degree()+1)*this.Fr.n8/d);if(f<a)for(let b=f;b<a;b++)e[b]=new dQ(new Uint8Array(this.Fr.n8),this.curve,this.logger);a=Math.min(a,f);for(let b=0;b<a;b++){let f=a-1===b,g=f?this.coef.byteLength-(a-1)*d:d+this.Fr.n8,h=g/this.Fr.n8>32768?new s.Zh(g):new Uint8Array(g);e[b]=new dQ(h,this.curve,this.logger);let i=b*d,j=f?this.coef.byteLength:(b+1)*d;if(e[b].coef.set(this.coef.slice(i,j),0),f||e[b].coef.set(c[b],d),0!==b){let a=this.Fr.sub(e[b].coef.slice(0,this.Fr.n8),c[b-1]);e[b].coef.set(a,0)}f&&e[b].truncate()}return e}truncate(){let a=this.degree();if(a+1<this.coef.byteLength/this.Fr.n8){let b=a+1>32768?new s.Zh((a+1)*this.Fr.n8):new Uint8Array((a+1)*this.Fr.n8);b.set(this.coef.slice(0,(a+1)*this.Fr.n8),0),this.coef=b}}static lagrangePolynomialInterpolation(a,b,c){let d=c.Fr,e=f(0);for(let b=1;b<a.length;b++)e.add(f(b));return e;function f(e){let f;for(let b=0;b<a.length;b++)b!==e&&(void 0===f?((f=new dQ(a.length>32768?new s.Zh(a.length*d.n8):new Uint8Array(a.length*d.n8),c)).setCoef(0,d.neg(a[b])),f.setCoef(1,d.one)):f.byXSubValue(a[b]));let g=f.evaluate(a[e]);g=d.inv(g);let h=d.mul(b[e],g);return f.mulScalar(h),f}}static zerofierPolynomial(a,b){let c=b.Fr,d=new dQ(a.length+1>32768?new s.Zh((a.length+1)*c.n8):new Uint8Array((a.length+1)*c.n8),b);d.setCoef(0,c.neg(a[0])),d.setCoef(1,c.one);for(let b=1;b<a.length;b++)d.byXSubValue(a[b]);return d}print(){let a=this.Fr,b="";for(let c=this.degree();c>=0;c--){let d=this.getCoef(c);!a.eq(a.zero,d)&&(a.isNegative(d)?b+=" - ":c!==this.degree()&&(b+=" + "),b+=a.toString(d),c>0&&(b+=c>1?"x^"+c:"x"))}console.log(b)}async multiExponentiation(a,b){let c=this.coef.byteLength/this.Fr.n8,d=a.slice(0,c*this.G1.F.n8*2),e=await this.Fr.batchFromMontgomery(this.coef),f=await this.G1.multiExpAffine(d,e,this.logger,b);return this.G1.toAffine(f)}}class dR{constructor(a,b,c){this.eval=a,this.curve=b,this.Fr=b.Fr,this.logger=c}static async fromPolynomial(a,b,c,d){let e=new s.Zh(a.length()*b*c.Fr.n8);return e.set(a.coef,0),new dR(await c.Fr.fft(e),c,d)}getEvaluation(a){let b=a*this.Fr.n8;if(b+this.Fr.n8>this.eval.byteLength)throw Error("Evaluations.getEvaluation() out of bounds");return this.eval.slice(b,b+this.Fr.n8)}length(){let a=this.eval.byteLength/this.Fr.n8;if(a!==Math.floor(this.eval.byteLength/this.Fr.n8))throw Error("Polynomial evaluations buffer has incorrect size");return 0===a&&this.logger.warn("Polynomial has length zero"),a}}let{stringifyBigInts:dS}=s.Wp;async function dT(a,b,c,d){let{fd:e,sections:f}=await J(b,"wtns",2,0x2000000,8388608);c&&c.debug("> Reading witness file");let g=await a8(e,f);c&&c.debug("> Reading zkey file");let{fd:h,sections:i}=await J(a,"zkey",2,0x2000000,8388608),j=await aX(h,i,void 0,d);if("plonk"!=j.protocol)throw Error("zkey file is not plonk");if(!s.X5.eq(j.r,g.q))throw Error("Curve of the witness does not match the curve of the proving key");if(g.nWitness!=j.nVars-j.nAdditions)throw Error(`Invalid witness length. Circuit: ${j.nVars}, witness: ${g.nWitness}, ${j.nAdditions}`);let k=j.curve,l=k.Fr,m=k.Fr.n8,n=j.domainSize*m;c&&(c.debug("----------------------------"),c.debug("  PLONK PROVE SETTINGS"),c.debug(`  Curve:         ${k.name}`),c.debug(`  Circuit power: ${j.power}`),c.debug(`  Domain size:   ${j.domainSize}`),c.debug(`  Vars:          ${j.nVars}`),c.debug(`  Public vars:   ${j.nPublic}`),c.debug(`  Constraints:   ${j.nConstraints}`),c.debug(`  Additions:     ${j.nAdditions}`),c.debug("----------------------------")),c&&c.debug("> Reading witness file data");let o=await S(e,f,2);o.set(l.zero,0);let p=new s.Zh(m*j.nAdditions),q={},r={},t={},u={},v=new dx(k,c),w=new dO(k);c&&c.debug("> Reading Section 3. Additions"),await A(),c&&c.debug("> Reading Section 12. Sigma1, Sigma2 & Sigma 3"),c&&c.debug("\xb7\xb7\xb7 Reading Sigma polynomials "),r.Sigma1=new dQ(new s.Zh(n),k,c),r.Sigma2=new dQ(new s.Zh(n),k,c),r.Sigma3=new dQ(new s.Zh(n),k,c),await h.readToBuffer(r.Sigma1.coef,0,n,i[12][0].p),await h.readToBuffer(r.Sigma2.coef,0,n,i[12][0].p+5*n),await h.readToBuffer(r.Sigma3.coef,0,n,i[12][0].p+10*n),c&&c.debug("\xb7\xb7\xb7 Reading Sigma evaluations"),t.Sigma1=new dR(new s.Zh(4*n),k,c),t.Sigma2=new dR(new s.Zh(4*n),k,c),t.Sigma3=new dR(new s.Zh(4*n),k,c),await h.readToBuffer(t.Sigma1.eval,0,4*n,i[12][0].p+n),await h.readToBuffer(t.Sigma2.eval,0,4*n,i[12][0].p+6*n),await h.readToBuffer(t.Sigma3.eval,0,4*n,i[12][0].p+11*n),c&&c.debug("> Reading Section 14. Powers of Tau");let x=await S(h,i,14),y=[];for(let a=1;a<=j.nPublic;a++){let b=o.slice(a*l.n8,a*l.n8+l.n8);y.push(s.X5.fromRprLE(b))}c&&c.debug(""),c&&c.debug("> ROUND 1"),await D(),c&&c.debug("> ROUND 2"),await F(),c&&c.debug("> ROUND 3"),await H(),c&&c.debug("> ROUND 4"),await K(),c&&c.debug("> ROUND 5"),await L(),await h.close(),await e.close();let z=v.toObjectProof(!1);return z.protocol="plonk",z.curve=k.name,c&&c.debug("PLONK PROVER FINISHED"),{proof:dS(z),publicSignals:dS(y)};async function A(){c&&c.debug("\xb7\xb7\xb7 Computing additions");let a=await S(h,i,3),b=8+2*m;for(let d=0;d<j.nAdditions;d++){c&&0!==d&&d%1e5==0&&c.debug(`    addition ${d}/${j.nAdditions}`);let e=d*b,f=B(a,e),g=B(a,e+=4);e+=4;let h=a.slice(e,e+m);e+=m;let i=a.slice(e,e+m),k=C(f),n=C(g),o=l.add(l.mul(h,k),l.mul(i,n));p.set(o,m*d)}}function B(a,b){let c=a.slice(b,b+4);return new DataView(c.buffer,c.byteOffset,c.byteLength).getUint32(0,!0)}function C(a){return a<j.nVars-j.nAdditions?o.slice(a*m,a*m+m):a<j.nVars?p.slice((a-(j.nVars-j.nAdditions))*m,(a-(j.nVars-j.nAdditions))*m+m):k.Fr.zero}async function D(){u.b=[];for(let a=1;a<=11;a++)u.b[a]=k.Fr.random();c&&c.debug("> Computing A, B, C wire polynomials"),await E(),c&&c.debug("> Computing A, B, C MSM");let a=await r.A.multiExponentiation(x,"A"),b=await r.B.multiExponentiation(x,"B"),d=await r.C.multiExponentiation(x,"C");return v.addPolynomial("A",a),v.addPolynomial("B",b),v.addPolynomial("C",d),0}async function E(){c&&c.debug("\xb7\xb7\xb7 Reading data from zkey file"),q.A=new s.Zh(n),q.B=new s.Zh(n),q.C=new s.Zh(n);let a=await S(h,i,4),b=await S(h,i,5),d=await S(h,i,6);for(let c=0;c<j.nConstraints;c++){let e=c*m,f=4*c,g=B(a,f);q.A.set(C(g),e);let h=B(b,f);q.B.set(C(h),e);let i=B(d,f);q.C.set(C(i),e)}if(q.A=await l.batchToMontgomery(q.A),q.B=await l.batchToMontgomery(q.B),q.C=await l.batchToMontgomery(q.C),c&&c.debug("\xb7\xb7\xb7 Computing A ifft"),r.A=await dQ.fromEvaluations(q.A,k,c),c&&c.debug("\xb7\xb7\xb7 Computing B ifft"),r.B=await dQ.fromEvaluations(q.B,k,c),c&&c.debug("\xb7\xb7\xb7 Computing C ifft"),r.C=await dQ.fromEvaluations(q.C,k,c),c&&c.debug("\xb7\xb7\xb7 Computing A fft"),t.A=await dR.fromPolynomial(r.A,4,k,c),c&&c.debug("\xb7\xb7\xb7 Computing B fft"),t.B=await dR.fromPolynomial(r.B,4,k,c),c&&c.debug("\xb7\xb7\xb7 Computing C fft"),t.C=await dR.fromPolynomial(r.C,4,k,c),r.A.blindCoefficients([u.b[2],u.b[1]]),r.B.blindCoefficients([u.b[4],u.b[3]]),r.C.blindCoefficients([u.b[6],u.b[5]]),r.A.degree()>=j.domainSize+2)throw Error("A Polynomial is not well calculated");if(r.B.degree()>=j.domainSize+2)throw Error("B Polynomial is not well calculated");if(r.C.degree()>=j.domainSize+2)throw Error("C Polynomial is not well calculated")}async function F(){c&&c.debug("> Computing challenges beta and gamma"),w.reset(),w.addPolCommitment(j.Qm),w.addPolCommitment(j.Ql),w.addPolCommitment(j.Qr),w.addPolCommitment(j.Qo),w.addPolCommitment(j.Qc),w.addPolCommitment(j.S1),w.addPolCommitment(j.S2),w.addPolCommitment(j.S3);for(let a=0;a<j.nPublic;a++)w.addScalar(q.A.slice(a*m,a*m+m));w.addPolCommitment(v.getPolynomial("A")),w.addPolCommitment(v.getPolynomial("B")),w.addPolCommitment(v.getPolynomial("C")),u.beta=w.getChallenge(),c&&c.debug("\xb7\xb7\xb7 challenges.beta: "+l.toString(u.beta,16)),w.reset(),w.addScalar(u.beta),u.gamma=w.getChallenge(),c&&c.debug("\xb7\xb7\xb7 challenges.gamma: "+l.toString(u.gamma,16)),c&&c.debug("> Computing Z polynomial"),await G(),c&&c.debug("> Computing Z MSM");let a=await r.Z.multiExponentiation(x,"Z");v.addPolynomial("Z",a)}async function G(){c&&c.debug("\xb7\xb7\xb7 Computing Z evaluations");let a=new s.Zh(n),b=new s.Zh(n);a.set(l.one,0),b.set(l.one,0);let d=l.one;for(let c=0;c<j.domainSize;c++){let e=c*m,f=q.A.slice(e,e+m),g=q.B.slice(e,e+m),h=q.C.slice(e,e+m),i=l.mul(u.beta,d),k=l.add(f,i);k=l.add(k,u.gamma);let n=l.add(g,l.mul(j.k1,i));n=l.add(n,u.gamma);let o=l.add(h,l.mul(j.k2,i));o=l.add(o,u.gamma);let p=l.mul(k,l.mul(n,o)),r=l.add(f,l.mul(t.Sigma1.getEvaluation(4*c),u.beta));r=l.add(r,u.gamma);let s=l.add(g,l.mul(t.Sigma2.getEvaluation(4*c),u.beta));s=l.add(s,u.gamma);let v=l.add(h,l.mul(t.Sigma3.getEvaluation(4*c),u.beta));v=l.add(v,u.gamma);let w=l.mul(r,l.mul(s,v));p=l.mul(a.slice(e,e+m),p),a.set(p,(c+1)%j.domainSize*m),w=l.mul(b.slice(e,e+m),w),b.set(w,(c+1)%j.domainSize*m),d=l.mul(d,l.w[j.power])}b=await l.batchInverse(b);for(let c=0;c<j.domainSize;c++){let d=c*m,e=l.mul(a.slice(d,d+m),b.slice(d,d+m));a.set(e,d)}if(q.Z=a,!l.eq(a.slice(0,m),l.one))throw Error("Copy constraints does not match");if(c&&c.debug("\xb7\xb7\xb7 Computing Z ifft"),r.Z=await dQ.fromEvaluations(q.Z,k,c),c&&c.debug("\xb7\xb7\xb7 Computing Z fft"),t.Z=await dR.fromPolynomial(r.Z,4,k,c),r.Z.blindCoefficients([u.b[9],u.b[8],u.b[7]]),r.Z.degree()>=j.domainSize+3)throw Error("Z Polynomial is not well calculated");delete q.Z}async function H(){c&&c.debug("> Computing challenge alpha"),w.reset(),w.addScalar(u.beta),w.addScalar(u.gamma),w.addPolCommitment(v.getPolynomial("Z")),u.alpha=w.getChallenge(),u.alpha2=l.square(u.alpha),c&&c.debug("\xb7\xb7\xb7 challenges.alpha: "+l.toString(u.alpha,16)),c&&c.debug("> Computing T polynomial"),await I(),c&&c.debug("> Computing T MSM");let a=await r.T1.multiExponentiation(x,"T1"),b=await r.T2.multiExponentiation(x,"T2"),d=await r.T3.multiExponentiation(x,"T3");v.addPolynomial("T1",a),v.addPolynomial("T2",b),v.addPolynomial("T3",d)}async function I(){c&&c.debug(`\xb7\xb7\xb7 Reading sections 8, 9, 7, 10, 11. Q selectors`),t.QL=new dR(new s.Zh(4*n),k,c),t.QR=new dR(new s.Zh(4*n),k,c),t.QM=new dR(new s.Zh(4*n),k,c),t.QO=new dR(new s.Zh(4*n),k,c),t.QC=new dR(new s.Zh(4*n),k,c),await h.readToBuffer(t.QL.eval,0,4*n,i[8][0].p+n),await h.readToBuffer(t.QR.eval,0,4*n,i[9][0].p+n),await h.readToBuffer(t.QM.eval,0,4*n,i[7][0].p+n),await h.readToBuffer(t.QO.eval,0,4*n,i[10][0].p+n),await h.readToBuffer(t.QC.eval,0,4*n,i[11][0].p+n),t.Lagrange=new dR(new s.Zh(4*n*j.nPublic),k,c);for(let a=0;a<j.nPublic;a++)await h.readToBuffer(t.Lagrange.eval,a*n*4,4*n,i[13][0].p+5*a*n+n);q.T=new s.Zh(4*n),q.Tz=new s.Zh(4*n),c&&c.debug("\xb7\xb7\xb7 Computing T evaluations");let a=l.one;for(let b=0;b<4*j.domainSize;b++){c&&0!==b&&b%1e5==0&&c.debug(`      T evaluation ${b}/${4*j.domainSize}`);let d=t.A.getEvaluation(b),e=t.B.getEvaluation(b),f=t.C.getEvaluation(b),g=t.Z.getEvaluation(b),h=t.Z.getEvaluation((4*j.domainSize+4+b)%(4*j.domainSize)),i=t.QM.getEvaluation(b),k=t.QL.getEvaluation(b),n=t.QR.getEvaluation(b),o=t.QO.getEvaluation(b),p=t.QC.getEvaluation(b),r=t.Sigma1.getEvaluation(b),s=t.Sigma2.getEvaluation(b),v=t.Sigma3.getEvaluation(b),w=l.add(u.b[2],l.mul(u.b[1],a)),x=l.add(u.b[4],l.mul(u.b[3],a)),y=l.add(u.b[6],l.mul(u.b[5],a)),z=l.square(a),A=l.add(l.add(l.mul(u.b[7],z),l.mul(u.b[8],a)),u.b[9]),B=l.mul(a,l.w[j.power]),C=l.square(B),D=l.add(l.add(l.mul(u.b[7],C),l.mul(u.b[8],B)),u.b[9]),E=l.zero;for(let a=0;a<j.nPublic;a++){let c=4*a*j.domainSize+b,d=t.Lagrange.getEvaluation(c),e=q.A.slice(a*m,(a+1)*m);E=l.sub(E,l.mul(d,e))}let[F,G]=dP.mul2(d,e,w,x,b%4,l);F=l.mul(F,i),G=l.mul(G,i),F=l.add(F,l.mul(d,k)),G=l.add(G,l.mul(w,k)),F=l.add(F,l.mul(e,n)),G=l.add(G,l.mul(x,n)),F=l.add(F,l.mul(f,o)),G=l.add(G,l.mul(y,o)),F=l.add(F,E),F=l.add(F,p);let H=l.mul(u.beta,a),I=d;I=l.add(I,H),I=l.add(I,u.gamma);let J=e;J=l.add(J,l.mul(H,j.k1)),J=l.add(J,u.gamma);let K=f;K=l.add(K,l.mul(H,j.k2)),K=l.add(K,u.gamma);let[L,M]=dP.mul4(I,J,K,g,w,x,y,A,b%4,l);L=l.mul(L,u.alpha),M=l.mul(M,u.alpha);let N=d;N=l.add(N,l.mul(u.beta,r)),N=l.add(N,u.gamma);let O=e;O=l.add(O,l.mul(u.beta,s)),O=l.add(O,u.gamma);let P=f;P=l.add(P,l.mul(u.beta,v)),P=l.add(P,u.gamma);let[Q,R]=dP.mul4(N,O,P,h,w,x,y,D,b%4,l);Q=l.mul(Q,u.alpha),R=l.mul(R,u.alpha);let S=l.sub(g,l.one);S=l.mul(S,t.Lagrange.getEvaluation(b)),S=l.mul(S,u.alpha2);let T=l.mul(A,t.Lagrange.getEvaluation(b));T=l.mul(T,u.alpha2);let U=l.add(l.sub(l.add(F,L),Q),S),V=l.add(l.sub(l.add(G,M),R),T);q.T.set(U,b*m),q.Tz.set(V,b*m),a=l.mul(a,l.w[j.power+2])}if(c&&c.debug("\xb7\xb7\xb7 Computing T ifft"),r.T=await dQ.fromEvaluations(q.T,k,c),c&&c.debug("\xb7\xb7\xb7 Computing T / ZH"),r.T.divZh(j.domainSize,4),c&&c.debug("\xb7\xb7\xb7 Computing Tz ifft"),r.Tz=await dQ.fromEvaluations(q.Tz,k,c),r.T.add(r.Tz),r.T.degree()>=3*j.domainSize+6)throw Error("T Polynomial is not well calculated");c&&c.debug("\xb7\xb7\xb7 Computing T1, T2, T3 polynomials"),r.T1=new dQ(new s.Zh((j.domainSize+1)*m),k,c),r.T2=new dQ(new s.Zh((j.domainSize+1)*m),k,c),r.T3=new dQ(new s.Zh((j.domainSize+6)*m),k,c),r.T1.coef.set(r.T.coef.slice(0,n),0),r.T2.coef.set(r.T.coef.slice(n,2*n),0),r.T3.coef.set(r.T.coef.slice(2*n,3*n+6*m),0),r.T1.setCoef(j.domainSize,u.b[10]);let b=l.sub(r.T2.getCoef(0),u.b[10]);r.T2.setCoef(0,b),r.T2.setCoef(j.domainSize,u.b[11]);let d=l.sub(r.T3.getCoef(0),u.b[11]);r.T3.setCoef(0,d)}async function K(){c&&c.debug("> Computing challenge xi"),w.reset(),w.addScalar(u.alpha),w.addPolCommitment(v.getPolynomial("T1")),w.addPolCommitment(v.getPolynomial("T2")),w.addPolCommitment(v.getPolynomial("T3")),u.xi=w.getChallenge(),u.xiw=l.mul(u.xi,l.w[j.power]),c&&c.debug("\xb7\xb7\xb7 challenges.xi: "+l.toString(u.xi,16)),v.addEvaluation("eval_a",r.A.evaluate(u.xi)),v.addEvaluation("eval_b",r.B.evaluate(u.xi)),v.addEvaluation("eval_c",r.C.evaluate(u.xi)),v.addEvaluation("eval_s1",r.Sigma1.evaluate(u.xi)),v.addEvaluation("eval_s2",r.Sigma2.evaluate(u.xi)),v.addEvaluation("eval_zw",r.Z.evaluate(u.xiw))}async function L(){c&&c.debug("> Computing challenge v"),w.reset(),w.addScalar(u.xi),w.addScalar(v.getEvaluation("eval_a")),w.addScalar(v.getEvaluation("eval_b")),w.addScalar(v.getEvaluation("eval_c")),w.addScalar(v.getEvaluation("eval_s1")),w.addScalar(v.getEvaluation("eval_s2")),w.addScalar(v.getEvaluation("eval_zw")),u.v=[],u.v[1]=w.getChallenge(),c&&c.debug("\xb7\xb7\xb7 challenges.v: "+l.toString(u.v[1],16));for(let a=2;a<6;a++)u.v[a]=l.mul(u.v[a-1],u.v[1]);c&&c.debug("> Computing linearisation polynomial R(X)"),await M(),c&&c.debug("> Computing opening proof polynomial Wxi(X) polynomial"),r.Wxi=new dQ(new s.Zh(n+6*m),k,c),r.Wxi.add(r.R),r.Wxi.add(r.A,u.v[1]),r.Wxi.add(r.B,u.v[2]),r.Wxi.add(r.C,u.v[3]),r.Wxi.add(r.Sigma1,u.v[4]),r.Wxi.add(r.Sigma2,u.v[5]),r.Wxi.subScalar(l.mul(u.v[1],v.evaluations.eval_a)),r.Wxi.subScalar(l.mul(u.v[2],v.evaluations.eval_b)),r.Wxi.subScalar(l.mul(u.v[3],v.evaluations.eval_c)),r.Wxi.subScalar(l.mul(u.v[4],v.evaluations.eval_s1)),r.Wxi.subScalar(l.mul(u.v[5],v.evaluations.eval_s2)),r.Wxi.divByZerofier(1,u.xi),c&&c.debug("> Computing opening proof polynomial Wxiw(X) polynomial"),N(),c&&c.debug("> Computing Wxi, Wxiw MSM");let a=await r.Wxi.multiExponentiation(x,"Wxi"),b=await r.Wxiw.multiExponentiation(x,"Wxiw");v.addPolynomial("Wxi",a),v.addPolynomial("Wxiw",b)}async function M(){let a=k.Fr;r.QL=new dQ(new s.Zh(n),k,c),r.QR=new dQ(new s.Zh(n),k,c),r.QM=new dQ(new s.Zh(n),k,c),r.QO=new dQ(new s.Zh(n),k,c),r.QC=new dQ(new s.Zh(n),k,c),await h.readToBuffer(r.QL.coef,0,n,i[8][0].p),await h.readToBuffer(r.QR.coef,0,n,i[9][0].p),await h.readToBuffer(r.QM.coef,0,n,i[7][0].p),await h.readToBuffer(r.QO.coef,0,n,i[10][0].p),await h.readToBuffer(r.QC.coef,0,n,i[11][0].p),u.xin=u.xi;for(let b=0;b<j.power;b++)u.xin=a.square(u.xin);u.zh=a.sub(u.xin,a.one);let b=[],d=a.e(j.domainSize),e=a.one;for(let c=1;c<=Math.max(1,j.nPublic);c++)b[c]=a.div(a.mul(e,u.zh),a.mul(d,a.sub(u.xi,e))),e=a.mul(e,a.w[j.power]);let f=a.div(a.sub(u.xin,a.one),a.mul(d,a.sub(u.xi,a.one)));if(c){c.debug("Lagrange Evaluations: ");for(let d=1;d<b.length;d++)c.debug(`L${d}(xi)=`+a.toString(b[d],16))}let g=a.zero;for(let c=0;c<y.length;c++){let d=a.e(y[c]);g=a.sub(g,a.mul(d,b[c+1]))}c&&c.debug("PI: "+a.toString(g,16));let l=a.mul(v.evaluations.eval_a,v.evaluations.eval_b),o=v.evaluations.eval_a,p=a.mul(u.beta,u.xi);o=a.add(o,p),o=a.add(o,u.gamma);let q=v.evaluations.eval_b;q=a.add(q,a.mul(p,j.k1)),q=a.add(q,u.gamma);let t=v.evaluations.eval_c;t=a.add(t,a.mul(p,j.k2)),t=a.add(t,u.gamma);let w=a.mul(a.mul(a.mul(o,q),t),u.alpha),x=v.evaluations.eval_a;x=a.add(x,a.mul(u.beta,v.evaluations.eval_s1)),x=a.add(x,u.gamma);let z=v.evaluations.eval_b;z=a.add(z,a.mul(u.beta,v.evaluations.eval_s2)),z=a.add(z,u.gamma);let A=a.mul(x,z);A=a.mul(A,v.evaluations.eval_zw),A=a.mul(A,u.alpha);let B=a.mul(f,u.alpha2);r.R=new dQ(new s.Zh((j.domainSize+6)*m),k,c),r.R.add(r.QM,l),r.R.add(r.QL,v.evaluations.eval_a),r.R.add(r.QR,v.evaluations.eval_b),r.R.add(r.QO,v.evaluations.eval_c),r.R.add(r.QC),r.R.add(r.Z,w),r.R.sub(r.Sigma3,a.mul(A,u.beta)),r.R.add(r.Z,B);let C=dQ.fromPolynomial(r.T3,k,c);C.mulScalar(a.square(u.xin)),C.add(r.T2,u.xin),C.add(r.T1),C.mulScalar(u.zh),r.R.sub(C);let D=a.sub(g,a.mul(A,a.add(v.evaluations.eval_c,u.gamma)));D=a.sub(D,B),c&&c.debug("r0: "+a.toString(D,16)),r.R.addScalar(D)}async function N(){r.Wxiw=dQ.fromPolynomial(r.Z,k,c),r.Wxiw.subScalar(v.evaluations.eval_zw),r.Wxiw.divByZerofier(1,u.xiw)}}let{unstringifyBigInts:dU}=s.Wp;async function dV(a,b,c,d,e,f){let g=dU(a),h={type:"mem"};return await bk(g,b,h,e),await dT(c,h,d,f)}let{unstringifyBigInts:dW}=s.Wp;async function dX(a,b,c,d){var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E;let F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao=dW(a);c=dW(c);let ap=dW(b),aq=await $(ao.curve),ar=aq.Fr,as=aq.G1;d&&d.info("PLONK VERIFIER STARTED");let at=(e=aq,f=c,F=e.G1,G=e.Fr,(H={}).A=F.fromObject(f.A),H.B=F.fromObject(f.B),H.C=F.fromObject(f.C),H.Z=F.fromObject(f.Z),H.T1=F.fromObject(f.T1),H.T2=F.fromObject(f.T2),H.T3=F.fromObject(f.T3),H.eval_a=G.fromObject(f.eval_a),H.eval_b=G.fromObject(f.eval_b),H.eval_c=G.fromObject(f.eval_c),H.eval_zw=G.fromObject(f.eval_zw),H.eval_s1=G.fromObject(f.eval_s1),H.eval_s2=G.fromObject(f.eval_s2),H.Wxi=F.fromObject(f.Wxi),H.Wxiw=F.fromObject(f.Wxiw),H);if(g=aq,h=ao,I=g.G1,J=g.G2,K=g.Fr,h.Qm=I.fromObject(h.Qm),h.Ql=I.fromObject(h.Ql),h.Qr=I.fromObject(h.Qr),h.Qo=I.fromObject(h.Qo),h.Qc=I.fromObject(h.Qc),h.S1=I.fromObject(h.S1),h.S2=I.fromObject(h.S2),h.S3=I.fromObject(h.S3),h.k1=K.fromObject(h.k1),h.k2=K.fromObject(h.k2),h.X_2=J.fromObject(h.X_2),ao=h,i=aq,j=at,!((L=i.G1).isValid(j.A)&&L.isValid(j.B)&&L.isValid(j.C)&&L.isValid(j.Z)&&L.isValid(j.T1)&&L.isValid(j.T2)&&L.isValid(j.T3)&&L.isValid(j.Wxi)&&L.isValid(j.Wxiw))||0)return d.error("Proof commitments are not valid."),!1;if(ap.length!=ao.nPublic)return d&&d.error("Invalid number of public inputs"),!1;if(!(dZ(k=aq,(l=at).eval_a)&&dZ(k,l.eval_b)&&dZ(k,l.eval_c)&&dZ(k,l.eval_s1)&&dZ(k,l.eval_s2)&&dZ(k,l.eval_zw)))return d&&d.error("Proof evaluations are not valid"),!1;if(!function(a,b){for(let c=0;c<b.length;c++)if(!dY(a,b[c]))return!1;return!0}(aq,ap))return d&&d.error("Public inputs are not valid."),!1;let au=function(a,b,c,d){let e=a.Fr,f={},g=new dO(a);g.addPolCommitment(d.Qm),g.addPolCommitment(d.Ql),g.addPolCommitment(d.Qr),g.addPolCommitment(d.Qo),g.addPolCommitment(d.Qc),g.addPolCommitment(d.S1),g.addPolCommitment(d.S2),g.addPolCommitment(d.S3);for(let a=0;a<c.length;a++)g.addScalar(e.e(c[a]));g.addPolCommitment(b.A),g.addPolCommitment(b.B),g.addPolCommitment(b.C),f.beta=g.getChallenge(),g.reset(),g.addScalar(f.beta),f.gamma=g.getChallenge(),g.reset(),g.addScalar(f.beta),g.addScalar(f.gamma),g.addPolCommitment(b.Z),f.alpha=g.getChallenge(),g.reset(),g.addScalar(f.alpha),g.addPolCommitment(b.T1),g.addPolCommitment(b.T2),g.addPolCommitment(b.T3),f.xi=g.getChallenge(),g.reset(),g.addScalar(f.xi),g.addScalar(b.eval_a),g.addScalar(b.eval_b),g.addScalar(b.eval_c),g.addScalar(b.eval_s1),g.addScalar(b.eval_s2),g.addScalar(b.eval_zw),f.v=[],f.v[1]=g.getChallenge();for(let a=2;a<6;a++)f.v[a]=e.mul(f.v[a-1],f.v[1]);return g.reset(),g.addPolCommitment(b.Wxi),g.addPolCommitment(b.Wxiw),f.u=g.getChallenge(),f}(aq,at,ap,ao);if(d){d.debug("beta: "+ar.toString(au.beta,16)),d.debug("gamma: "+ar.toString(au.gamma,16)),d.debug("alpha: "+ar.toString(au.alpha,16)),d.debug("xi: "+ar.toString(au.xi,16));for(let a=1;a<6;a++)d&&d.debug("v: "+ar.toString(au.v[a],16));d.debug("u: "+ar.toString(au.u,16))}let av=function(a,b,c){let d=a.Fr,e=b.xi,f=1;for(let a=0;a<c.power;a++)e=d.square(e),f*=2;b.xin=e,b.zh=d.sub(e,d.one);let g=[],h=d.e(f),i=d.one;for(let a=1;a<=Math.max(1,c.nPublic);a++)g[a]=d.div(d.mul(i,b.zh),d.mul(h,d.sub(b.xi,i))),i=d.mul(i,d.w[c.power]);return g}(aq,au,ao);if(d)for(let a=1;a<av.length;a++)d.debug(`L${a}(xi)=`+ar.toString(av[a],16));if(ap.length!=ao.nPublic)return d.error("Number of public signals does not match with vk"),!1;let aw=function(a,b,c){let d=a.Fr,e=d.zero;for(let a=0;a<b.length;a++){let f=d.e(b[a]);e=d.sub(e,d.mul(f,c[a+1]))}return e}(aq,ap,av);d&&d.debug("PI(xi): "+ar.toString(aw,16));let ax=(m=aq,n=at,o=au,p=aw,q=av[1],N=(M=m.Fr).mul(q,M.square(o.alpha)),O=M.add(n.eval_a,M.mul(o.beta,n.eval_s1)),O=M.add(O,o.gamma),P=M.add(n.eval_b,M.mul(o.beta,n.eval_s2)),P=M.add(P,o.gamma),Q=M.add(n.eval_c,o.gamma),R=M.mul(M.mul(O,P),Q),R=M.mul(R,n.eval_zw),R=M.mul(R,o.alpha),M.sub(M.sub(p,N),R));d&&d.debug("r0: "+ar.toString(ax,16));let ay=(r=aq,s=at,t=au,u=ao,v=av[1],S=r.G1,T=r.Fr,U=S.timesFr(u.Qm,T.mul(s.eval_a,s.eval_b)),U=S.add(U,S.timesFr(u.Ql,s.eval_a)),U=S.add(U,S.timesFr(u.Qr,s.eval_b)),U=S.add(U,S.timesFr(u.Qo,s.eval_c)),U=S.add(U,u.Qc),V=T.mul(t.beta,t.xi),W=T.add(T.add(s.eval_a,V),t.gamma),X=T.add(T.add(s.eval_b,T.mul(V,u.k1)),t.gamma),Y=T.add(T.add(s.eval_c,T.mul(V,u.k2)),t.gamma),Z=T.mul(T.mul(T.mul(W,X),Y),t.alpha),_=T.mul(v,T.square(t.alpha)),aa=S.timesFr(s.Z,T.add(T.add(Z,_),t.u)),ab=T.add(T.add(s.eval_a,T.mul(t.beta,s.eval_s1)),t.gamma),ac=T.add(T.add(s.eval_b,T.mul(t.beta,s.eval_s2)),t.gamma),ad=T.mul(T.mul(t.alpha,t.beta),s.eval_zw),ae=S.timesFr(u.S3,T.mul(T.mul(ab,ac),ad)),af=s.T1,ag=S.timesFr(s.T2,t.xin),ah=S.timesFr(s.T3,T.square(t.xin)),ai=S.add(af,S.add(ag,ah)),ai=S.timesFr(ai,t.zh),S.sub(S.sub(S.add(U,aa),ae),ai));d&&d.debug("D: "+as.toString(as.toAffine(ay),16));let az=(w=aq,x=at,y=au,z=ao,A=ay,ak=(aj=w.G1).add(A,aj.timesFr(x.A,y.v[1])),ak=aj.add(ak,aj.timesFr(x.B,y.v[2])),ak=aj.add(ak,aj.timesFr(x.C,y.v[3])),ak=aj.add(ak,aj.timesFr(z.S1,y.v[4])),ak=aj.add(ak,aj.timesFr(z.S2,y.v[5])));d&&d.debug("F: "+as.toString(as.toAffine(az),16));let aA=(B=aq,C=at,D=au,E=ax,al=B.G1,an=(am=B.Fr).add(am.neg(E),am.mul(D.v[1],C.eval_a)),an=am.add(an,am.mul(D.v[2],C.eval_b)),an=am.add(an,am.mul(D.v[3],C.eval_c)),an=am.add(an,am.mul(D.v[4],C.eval_s1)),an=am.add(an,am.mul(D.v[5],C.eval_s2)),an=am.add(an,am.mul(D.u,C.eval_zw)),al.timesFr(al.one,an));d&&d.debug("E: "+as.toString(as.toAffine(aA),16));let aB=await d$(aq,at,au,ao,aA,az);return d&&(aB?d.info("OK!"):d.warn("Invalid Proof")),aB}function dY(a,b){return s.X5.geq(b,0)&&s.X5.lt(b,a.r)}function dZ(a,b){return dY(a,s.X5.fromRprLE(b))}async function d$(a,b,c,d,e,f){let g=a.G1,h=a.Fr,i=b.Wxi;i=g.add(i,g.timesFr(b.Wxiw,c.u));let j=g.timesFr(b.Wxi,c.xi),k=h.mul(h.mul(c.u,c.xi),h.w[d.power]);return j=g.add(j,g.timesFr(b.Wxiw,k)),j=g.add(j,f),j=g.sub(j,e),await a.pairingEq(g.neg(i),d.X_2,j,a.G2.one)}let{unstringifyBigInts:d_}=s.Wp;function d0(a){let b=a.toString(16);for(;b.length<64;)b="0"+b;return`"0x${b}"`}async function d1(a,b){let c=d_(a),d=d_(b),e=await $(c.curve);e.G1,e.Fr;let f="";for(let a=0;a<d.length;a++)""!=f&&(f+=","),f+=d0(d[a]);return`[${d0(c.A[0])}, ${d0(c.A[1])},${d0(c.B[0])},${d0(c.B[1])},${d0(c.C[0])},${d0(c.C[1])},${d0(c.Z[0])},${d0(c.Z[1])},${d0(c.T1[0])},${d0(c.T1[1])},${d0(c.T2[0])},${d0(c.T2[1])},${d0(c.T3[0])},${d0(c.T3[1])},${d0(c.Wxi[0])},${d0(c.Wxi[1])},${d0(c.Wxiw[0])},${d0(c.Wxiw[1])},${d0(c.eval_a)},${d0(c.eval_b)},${d0(c.eval_c)},${d0(c.eval_s1)},${d0(c.eval_s2)},${d0(c.eval_zw)}][${f}]`}function d2(a,b){return[a,0,0,b.one,b.zero,b.zero,b.zero,b.zero]}function d3(a,b,c,d,e,f,g,h){return[a,b,c,d,e,f,g,h]}function d4(a,b,c,d,e,f,g,h,i){return[a,b,c,d,e,f,g,h]}class d5{constructor(a,b,c,d,e){this.Fr=a,this.logger=e,this.fnGetAdditionConstraint=c,this.fnGetMultiplicationConstraint=d}processR1csConstraint(a,b,c,d){this.normalizeLinearCombination(b),this.normalizeLinearCombination(c),this.normalizeLinearCombination(d);let e=this.getLinearCombinationType(b),f=this.getLinearCombinationType(c);if(0===e||0===f)return this.processR1csAdditionConstraint(a,d);if(1===e){let e=this.joinLinearCombinations(c,d,b[0]);return this.processR1csAdditionConstraint(a,e)}if(1!==f)return this.processR1csMultiplicationConstraint(a,b,c,d);{let e=this.joinLinearCombinations(b,d,c[0]);return this.processR1csAdditionConstraint(a,e)}}getLinearCombinationType(a){let b=this.Fr.zero,c=0,d=Object.keys(a);for(let e=0;e<d.length;e++)0n==a[d[e]]?delete a[d[e]]:0==d[e]?b=this.Fr.add(b,a[d[e]]):c++;return c>0?2:+!this.Fr.isZero(b)}normalizeLinearCombination(a){let b=Object.keys(a);for(let c=0;c<b.length;c++)this.Fr.isZero(a[b[c]])&&delete a[b[c]];return a}joinLinearCombinations(a,b,c){let d={};for(let b in a)void 0===d[b]?d[b]=this.Fr.mul(c,a[b]):d[b]=this.Fr.add(d[b],this.Fr.mul(c,a[b]));for(let a in b){let c=this.Fr.neg(b[a]);void 0===d[a]?d[a]=c:d[a]=this.Fr.add(d[a],c)}return this.normalizeLinearCombination(d)}reduceCoefs(a,b,c,d,e){let f={k:this.Fr.zero,signals:[],coefs:[]},g=[];for(let a in d)0==a?f.k=this.Fr.add(f.k,d[a]):0n!=d[a]&&g.push([Number(a),d[a]]);for(;g.length>e;){let d=g.shift(),e=g.shift(),f=a.nVars++,h=this.fnGetAdditionConstraint(d[0],e[0],f,this.Fr.neg(d[1]),this.Fr.neg(e[1]),this.Fr.zero,this.Fr.one,this.Fr.zero);b.push(h),c.push([d[0],e[0],d[1],e[1]]),g.push([f,this.Fr.one])}for(let a=0;a<g.length;a++)f.signals[a]=g[a][0],f.coefs[a]=g[a][1];for(;f.coefs.length<e;)f.signals.push(0),f.coefs.push(this.Fr.zero);return f}processR1csAdditionConstraint(a,b){let c=[],d=[],e=this.reduceCoefs(a,c,d,b,3),f=this.fnGetAdditionConstraint(e.signals[0],e.signals[1],e.signals[2],e.coefs[0],e.coefs[1],this.Fr.zero,e.coefs[2],e.k);return c.push(f),[c,d]}processR1csMultiplicationConstraint(a,b,c,d){let e=[],f=[],g=this.reduceCoefs(a,e,f,b,1),h=this.reduceCoefs(a,e,f,c,1),i=this.reduceCoefs(a,e,f,d,1),j=this.fnGetMultiplicationConstraint(g.signals[0],h.signals[0],i.signals[0],this.Fr.mul(g.coefs[0],h.k),this.Fr.mul(g.k,h.coefs[0]),this.Fr.mul(g.coefs[0],h.coefs[0]),this.Fr.neg(i.coefs[0]),this.Fr.sub(this.Fr.mul(g.k,h.k),i.k));return e.push(j),[e,f]}}class d6{constructor(a,b,c){this.n=a,this.polynomials=Array(a).fill(void 0),this.curve=b,this.Fr=b.Fr,this.G1=b.G1,this.logger=c}addPolynomial(a,b){if(a>this.n-1)throw Error("CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1");this.polynomials[a]=b}degree(){return Math.max(...this.polynomials.map((a,b)=>void 0===a?0:a.degree()*this.n+b))}getPolynomial(){let a=this.polynomials.map(a=>void 0===a?0:a.degree()),b=this.degree(),c=2**(aE(b-1)+1),d=this.Fr.n8,e=new dQ(new s.Zh(c*d),this.curve,this.logger);for(let c=0;c<b;c++){let b=c*d,f=b*this.n;for(let g=0;g<this.n;g++)void 0!==this.polynomials[g]&&c<=a[g]&&e.coef.set(this.polynomials[g].coef.slice(b,b+d),f+g*d)}return e}async multiExponentiation(a,b){let c=this.getPolynomial(),d=c.coef.byteLength/this.Fr.n8,e=a.slice(0,d*this.G1.F.n8*2),f=await this.Fr.batchFromMontgomery(c.coef),g=await this.G1.multiExpAffine(e,f,this.logger,b);return this.G1.toAffine(g)}}async function d7(a,b,c,d){var e,f;let g,h,i,j;d&&d.info("FFLONK SETUP STARTED"),globalThis.gc&&globalThis.gc(),d&&d.info("> Reading PTau file");let{fd:k,sections:l}=await J(b,"ptau",1,4194304,0x1000000);if(!l[12])throw Error("Powers of Tau is not well prepared. Section 12 missing.");d&&d.info("> Getting curve from PTau settings");let{curve:m}=await bx(k,l);d&&d.info("> Reading r1cs file");let{fd:n,sections:o}=await J(a,"r1cs",1,4194304,0x1000000),p=await cY(n,o,{loadConstraints:!1,loadCustomGates:!0});if(p.prime!==m.r)throw Error("r1cs curve does not match powers of tau ceremony curve");let q=m.Fr,r=m.Fr.n8,t=2*m.G1.F.n8,u=2*m.G2.F.n8,v={},w={},x={nVars:p.nVars,nPublic:p.nOutputs+p.nPubInputs},y=new db,z=new db;if(d&&d.info("> Processing FFlonk constraints"),await G(m.Fr,p,d),globalThis.gc&&globalThis.gc(),x.cirPower=Math.max(3,aE(y.length+2-1)+1),x.domainSize=2**x.cirPower,l[2][0].size<(9*x.domainSize+18)*t)throw Error("Powers of Tau is not big enough for this circuit size. Section 2 too small.");if(l[3][0].size<u)throw Error("Powers of Tau is not well prepared. Section 3 too small.");d&&(d.info("----------------------------"),d.info("  FFLONK SETUP SETTINGS"),d.info(`  Curve:         ${m.name}`),d.info(`  Circuit power: ${x.cirPower}`),d.info(`  Domain size:   ${x.domainSize}`),d.info(`  Vars:          ${x.nVars}`),d.info(`  Public vars:   ${x.nPublic}`),d.info(`  Constraints:   ${y.length}`),d.info(`  Additions:     ${z.length}`),d.info("----------------------------")),d&&d.info("> computing k1 and k2");let[A,B]=function(){let a=q.two;for(;c(a,[],x.cirPower);)q.add(a,q.one);let b=q.add(a,q.one);for(;c(b,[a],x.cirPower);)q.add(b,q.one);return[a,b];function c(a,b,c){let d=2**c,e=q.one;for(let f=0;f<d;f++){if(q.eq(a,e))return!0;for(let c=0;c<b.length;c++)if(q.eq(a,q.mul(b[c],e)))return!0;e=q.mul(e,q.w[c])}return!1}}();d&&d.info("> computing w3");let C=(h=q.e(31624),i=s.X5.div(0x810b7bdd032f006f40d60f3c0403964dc08a6b6bef43d6d8b505398a8000000n,s.X5.e(3)),q.exp(h,i));d&&d.info("> computing w4");let D=q.w[2];d&&d.info("> computing w8");let E=q.w[3];d&&d.info("> computing wr");let F=(e=x.cirPower,j=(f=m.Fr).e(0x108c3d36f14c2facdf4d615f022a01cfcf001cc24e3db9d89373caf21d767f0n),f.exp(j,2**(28-e)));return await H(),await n.close(),await k.close(),d&&d.info("FFLONK SETUP FINISHED"),0;async function G(a,b,c){for(let b=0;b<x.nPublic;b++)y.push(d2(b+1,a));let d=new d5(a,d2,d3,d4,c),e=await S(n,o,2),f=0;for(let a=0;a<b.nConstraints;a++){c&&0!==a&&a%5e5==0&&c.info(`    processing r1cs constraints ${a}/${b.nConstraints}`);let[e,f]=d.processR1csConstraint(x,...function(){let a=[];return a[0]=g(),a[1]=g(),a[2]=g(),a}());y.push(...e),z.push(...f)}function g(){let a={},c=e.slice(f,f+4);f+=4;let d=new DataView(c.buffer).getUint32(0,!0),g=e.slice(f,f+(4+b.n8)*d);f+=(4+b.n8)*d;let h=new DataView(g.buffer);for(let c=0;c<d;c++){let d=h.getUint32(c*(4+b.n8),!0),e=b.F.fromRprLE(g,c*(4+b.n8)+4);a[d]=e}return a}return 0}async function H(){d&&d.info("> Writing the zkey file");let a=await K(c,"zkey",1,17,4194304,0x1000000);d&&d.info(`\xb7\xb7\xb7 Writing Section 1. Zkey Header`),await I(a),d&&d.info(`\xb7\xb7\xb7 Writing Section 3. Additions`),await N(a),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 4. A Map`),await O(a,4,0,"A map"),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 5. B Map`),await O(a,5,1,"B map"),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 6. C Map`),await O(a,6,2,"C map"),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 7. QL`),await Q(a,7,3,"QL"),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 8. QR`),await Q(a,8,4,"QR"),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 9. QM`),await Q(a,9,5,"QM"),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 10. QO`),await Q(a,10,6,"QO"),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 11. QC`),await Q(a,11,7,"QC"),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Sections 12,13,14. Sigma1, Sigma2 & Sigma 3`),await R(a),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 15. Lagrange Polynomials`),await T(a),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 16. Powers of Tau`),await U(a),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 17. C0`),await V(a),globalThis.gc&&globalThis.gc(),d&&d.info(`\xb7\xb7\xb7 Writing Section 2. FFlonk Header`),await W(a),globalThis.gc&&globalThis.gc(),d&&d.info("> Writing the zkey file finished"),await a.close()}async function I(a){await L(a,1),await a.writeULE32(10),await M(a)}async function N(a){await L(a,3);let b=new Uint8Array(8+2*r),c=new DataView(b.buffer);for(let e=0;e<z.length;e++){d&&0!==e&&e%5e5==0&&d.info(`      writing Additions: ${e}/${z.length}`);let f=z[e];c.setUint32(0,f[0],!0),c.setUint32(4,f[1],!0),b.set(f[2],8),b.set(f[3],8+r),await a.write(b)}await M(a)}async function O(a,b,c,e){await L(a,b);for(let b=0;b<y.length;b++)d&&0!==b&&b%5e5==0&&d.info(`      writing witness ${e}: ${b}/${y.length}`),await a.writeULE32(y[b][c]);await M(a)}async function Q(a,b,c,e){let f=new s.Zh(x.domainSize*r);for(let a=0;a<y.length;a++)f.set(y[a][c],a*r),d&&0!==a&&a%5e5==0&&d.info(`      writing ${e}: ${a}/${y.length}`);v[e]=await dQ.fromEvaluations(f,m,d),w[e]=await dR.fromPolynomial(v[e],4,m,d),await L(a,b),await a.write(v[e].coef),await a.write(w[e].eval),await M(a)}async function R(a){let b=new s.Zh(r*x.domainSize*3),c=new db(x.nVars),e=new db(x.nVars),f=q.one;for(let a=0;a<x.domainSize;a++)a<y.length?(g(y[a][0],a),g(y[a][1],x.domainSize+a),g(y[a][2],2*x.domainSize+a)):a<x.domainSize-2?(g(0,a),g(0,x.domainSize+a),g(0,2*x.domainSize+a)):(b.set(f,a*r),b.set(q.mul(f,A),(x.domainSize+a)*r),b.set(q.mul(f,B),(2*x.domainSize+a)*r)),f=q.mul(f,q.w[x.cirPower]),d&&0!==a&&a%5e5==0&&d.info(`      writing sigma phase1: ${a}/${y.length}`);for(let a=0;a<x.nVars;a++)void 0!==e[a]?b.set(c[a],e[a]*r):console.log("Variable not used"),d&&0!==a&&a%5e5==0&&d.info(`      writing sigma phase2: ${a}/${x.nVars}`);globalThis.gc&&globalThis.gc();for(let c=0;c<3;c++){let e=0===c?12:1===c?13:14,f="S"+(c+1);v[f]=await dQ.fromEvaluations(b.slice(x.domainSize*r*c,x.domainSize*r*(c+1)),m,d),w[f]=await dR.fromPolynomial(v[f],4,m,d),await L(a,e),await a.write(v[f].coef),await a.write(w[f].eval),await M(a),globalThis.gc&&globalThis.gc()}return 0;function g(a,d){let g;void 0===c[a]?e[a]=d:b.set(c[a],d*r),g=d<x.domainSize?f:d<2*x.domainSize?q.mul(f,A):q.mul(f,B),c[a]=g}}async function T(a){await L(a,15);let b=Math.max(x.nPublic,1);for(let c=0;c<b;c++){let b=new s.Zh(x.domainSize*r);b.set(q.one,c*r),await X(a,b)}await M(a)}async function U(a){await L(a,16),g=new s.Zh((9*x.domainSize+18)*t),await k.readToBuffer(g,0,(9*x.domainSize+18)*t,l[2][0].p),await a.write(g),await M(a)}async function V(a){let b=new d6(8,m,d);if(b.addPolynomial(0,v.QL),b.addPolynomial(1,v.QR),b.addPolynomial(2,v.QO),b.addPolynomial(3,v.QM),b.addPolynomial(4,v.QC),b.addPolynomial(5,v.S1),b.addPolynomial(6,v.S2),b.addPolynomial(7,v.S3),v.C0=b.getPolynomial(),v.C0.degree()>=8*x.domainSize)throw Error("C0 Polynomial is not well calculated");await L(a,17),await a.write(v.C0.coef),await M(a)}async function W(a){let b;await L(a,2);let c=m.q,d=(Math.floor((s.X5.bitLength(c)-1)/64)+1)*8;await a.writeULE32(d),await P(a,c,d);let e=m.r,f=(Math.floor((s.X5.bitLength(e)-1)/64)+1)*8;await a.writeULE32(f),await P(a,e,f),await a.writeULE32(x.nVars),await a.writeULE32(x.nPublic),await a.writeULE32(x.domainSize),await a.writeULE32(z.length),await a.writeULE32(y.length),await a.write(A),await a.write(B),await a.write(C),await a.write(D),await a.write(E),await a.write(F),b=await k.read(u,l[3][0].p+u),await a.write(b);let h=await v.C0.multiExponentiation(g,"C0");await a.write(h),await M(a)}async function X(a,b){let[c,d]=await dQ.to4T(b,x.domainSize,[],q);return await a.write(c),await a.write(d),[c,d]}}let{stringifyBigInts:d8}=s.Wp;async function d9(a,b,c,d){c&&c.info("FFLONK PROVER STARTED"),c&&c.info("> Reading witness file");let{fd:e,sections:f}=await J(b,"wtns",2,0x2000000,8388608),g=await a8(e,f);c&&c.info("> Reading zkey file");let{fd:h,sections:i}=await J(a,"zkey",2,0x2000000,8388608),j=await aX(h,i,void 0,d);if(10!==j.protocolId)throw Error("zkey file is not fflonk");if(!s.X5.eq(j.r,g.q))throw Error("Curve of the witness does not match the curve of the proving key");if(g.nWitness!==j.nVars-j.nAdditions)throw Error(`Invalid witness length. Circuit: ${j.nVars}, witness: ${g.nWitness}, ${j.nAdditions}`);let k=j.curve,l=k.Fr,m=k.Fr.n8,n=2*k.G1.F.n8,o=j.domainSize*m;c&&(c.info("----------------------------"),c.info("  FFLONK PROVE SETTINGS"),c.info(`  Curve:         ${k.name}`),c.info(`  Circuit power: ${j.power}`),c.info(`  Domain size:   ${j.domainSize}`),c.info(`  Vars:          ${j.nVars}`),c.info(`  Public vars:   ${j.nPublic}`),c.info(`  Constraints:   ${j.nConstraints}`),c.info(`  Additions:     ${j.nAdditions}`),c.info("----------------------------")),c&&c.info("> Reading witness file data");let p=await S(e,f,2);await e.close(),p.set(l.zero,0);let q=new s.Zh(j.nAdditions*m),r={},t={},u={},v={},w={},x={},y=new dx(k,c);c&&c.info("> Reading Section 3. Additions"),await C(),c&&c.info("> Reading Sections 12,13,14. Sigma1, Sigma2 & Sigma 3"),c&&c.info("\xb7\xb7\xb7 Reading Sigma polynomials "),t.Sigma1=new dQ(new s.Zh(o),k,c),t.Sigma2=new dQ(new s.Zh(o),k,c),t.Sigma3=new dQ(new s.Zh(o),k,c),await h.readToBuffer(t.Sigma1.coef,0,o,i[12][0].p),await h.readToBuffer(t.Sigma2.coef,0,o,i[13][0].p),await h.readToBuffer(t.Sigma3.coef,0,o,i[14][0].p),c&&c.info("\xb7\xb7\xb7 Reading Sigma evaluations"),u.Sigma1=new dR(new s.Zh(4*o),k,c),u.Sigma2=new dR(new s.Zh(4*o),k,c),u.Sigma3=new dR(new s.Zh(4*o),k,c),await h.readToBuffer(u.Sigma1.eval,0,4*o,i[12][0].p+o),await h.readToBuffer(u.Sigma2.eval,0,4*o,i[13][0].p+o),await h.readToBuffer(u.Sigma3.eval,0,4*o,i[14][0].p+o),c&&c.info("> Reading Section 16. Powers of Tau");let z=new s.Zh(16*j.domainSize*n);await h.readToBuffer(z,0,(9*j.domainSize+18)*n,i[16][0].p),globalThis.gc&&globalThis.gc(),c&&c.info(""),c&&c.info("> ROUND 1"),await F(),delete t.T0,delete u.QL,delete u.QR,delete u.QM,delete u.QO,delete u.QC,globalThis.gc&&globalThis.gc(),c&&c.info("> ROUND 2"),await G(),delete r.A,delete r.B,delete r.C,delete u.A,delete u.B,delete u.C,delete u.Sigma1,delete u.Sigma2,delete u.Sigma3,delete u.lagrange1,delete u.Z,globalThis.gc&&globalThis.gc(),c&&c.info("> ROUND 3"),await H(),delete t.A,delete t.B,delete t.C,delete t.Z,delete t.T1,delete t.T2,delete t.Sigma1,delete t.Sigma2,delete t.Sigma3,delete t.QL,delete t.QR,delete t.QM,delete t.QC,delete t.QO,globalThis.gc&&globalThis.gc(),c&&c.info("> ROUND 4"),await I(),globalThis.gc&&globalThis.gc(),c&&c.info("> ROUND 5"),await K(),delete t.C0,delete t.C1,delete t.C2,delete t.R1,delete t.R2,delete t.F,delete t.L,delete t.ZT,delete t.ZTS2,await h.close(),globalThis.gc&&globalThis.gc(),y.addEvaluation("inv",function(){let a=w.xi;for(let b=0;b<j.power;b++)a=l.square(a);v.zh=l.sub(a,l.one),function(a,b,c,d){let e=d.Fr,f=b.length,g=e.mul(e.e(f),e.exp(b[0],f-2));for(let d=0;d<f;d++){let h=b[(f-1)*d%f],i=e.sub(c,b[d]);a[["LiS0_"+(d+1)]]=e.mul(e.mul(g,h),i)}}(v,x.S0.h0w8,w.y,k),function(a,b,c,d){let e=d.Fr,f=b.length,g=e.mul(e.e(f),e.exp(b[0],f-2));for(let d=0;d<f;d++){let h=b[(f-1)*d%f],i=e.sub(c,b[d]);a[["LiS1_"+(d+1)]]=e.mul(e.mul(g,h),i)}}(v,x.S1.h1w4,w.y,k),function(a,b,c,d,e,f,g){let h=g.Fr,i=h.mul(h.e(3),b[0]),j=h.sub(e,f),k=h.mul(i,j);for(let c=0;c<3;c++){let e=b[2*c%3],f=h.sub(d,b[c]);a[["LiS2_"+(c+1)]]=h.mul(k,h.mul(e,f))}let l=h.mul(h.e(3),c[0]),m=h.sub(f,e);k=h.mul(l,m);for(let b=0;b<3;b++){let e=c[2*b%3],f=h.sub(d,c[b]);a[["LiS2_"+(b+1+3)]]=h.mul(k,h.mul(e,f))}}(v,x.S2.h2w3,x.S2.h3w3,w.y,w.xi,w.xiw,k);let b=Math.max(1,j.nPublic),c=l.one;for(let a=0;a<b;a++)v["Li_"+(a+1)]=l.mul(l.e(j.domainSize),l.sub(w.xi,c)),c=l.mul(c,l.w[j.power]);let d=l.one;for(let a of Object.values(v))if(Array.isArray(a))for(let b of a)d=l.mul(d,b);else d=l.mul(d,a);return l.inv(d)}());let A=y.toObjectProof();A.protocol="fflonk",A.curve=k.name;let B=[];for(let a=1;a<=j.nPublic;a++){let b=a*m,c=p.slice(b,b+m);B.push(s.X5.fromRprLE(c))}return c&&c.info("FFLONK PROVER FINISHED"),{proof:d8(A),publicSignals:d8(B)};async function C(){c&&c.info("\xb7\xb7\xb7 Computing additions");let a=await S(h,i,3),b=8+2*m;for(let d=0;d<j.nAdditions;d++){c&&0!==d&&d%1e5==0&&c.info(`    addition ${d}/${j.nAdditions}`);let e=d*b,f=D(a,e),g=D(a,e+=4);e+=4;let h=a.slice(e,e+m);e+=m;let i=a.slice(e,e+m),k=E(f),n=E(g),o=l.add(l.mul(h,k),l.mul(i,n));q.set(o,m*d)}}function D(a,b){let c=a.slice(b,b+4);return new DataView(c.buffer,c.byteOffset,c.byteLength).getUint32(0,!0)}function E(a){let b=j.nVars-j.nAdditions;if(a<b)return p.slice(a*m,a*m+m);if(a<j.nVars){let c=(a-b)*m;return q.slice(c,c+m)}return l.zero}async function F(){w.b=[];for(let a=1;a<=9;a++)w.b[a]=l.random();c&&c.info("> Computing A, B, C wire polynomials"),await b(),c&&c.info("> Computing T0 polynomial"),await d(),c&&c.info("> Computing C1 polynomial"),await e(),c&&c.info("> Computing C1 multi exponentiation");let a=await t.C1.multiExponentiation(z,"C1");return y.addPolynomial("C1",a),0;async function b(){c&&c.info("\xb7\xb7\xb7 Reading data from zkey file"),r.A=new s.Zh(o),r.B=new s.Zh(o),r.C=new s.Zh(o);let a=await S(h,i,4),b=await S(h,i,5),d=await S(h,i,6);for(let c=0;c<j.nConstraints;c++){let e=c*m,f=4*c,g=D(a,f);r.A.set(E(g),e);let h=D(b,f);r.B.set(E(h),e);let i=D(d,f);r.C.set(E(i),e)}if(r.A.set(w.b[1],o-64),r.A.set(w.b[2],o-32),r.B.set(w.b[3],o-64),r.B.set(w.b[4],o-32),r.C.set(w.b[5],o-64),r.C.set(w.b[6],o-32),r.A=await l.batchToMontgomery(r.A),r.B=await l.batchToMontgomery(r.B),r.C=await l.batchToMontgomery(r.C),c&&c.info("\xb7\xb7\xb7 Computing A ifft"),t.A=await dQ.fromEvaluations(r.A,k,c),c&&c.info("\xb7\xb7\xb7 Computing B ifft"),t.B=await dQ.fromEvaluations(r.B,k,c),c&&c.info("\xb7\xb7\xb7 Computing C ifft"),t.C=await dQ.fromEvaluations(r.C,k,c),c&&c.info("\xb7\xb7\xb7 Computing A fft"),u.A=await dR.fromPolynomial(t.A,4,k,c),c&&c.info("\xb7\xb7\xb7 Computing B fft"),u.B=await dR.fromPolynomial(t.B,4,k,c),c&&c.info("\xb7\xb7\xb7 Computing C fft"),u.C=await dR.fromPolynomial(t.C,4,k,c),t.A.degree()>=j.domainSize)throw Error("A Polynomial is not well calculated");if(t.B.degree()>=j.domainSize)throw Error("B Polynomial is not well calculated");if(t.C.degree()>=j.domainSize)throw Error("C Polynomial is not well calculated")}async function d(){c&&c.info(`\xb7\xb7\xb7 Reading sections 7, 8, 9, 10, 11. Q selectors`),u.QL=new dR(new s.Zh(4*o),k,c),u.QR=new dR(new s.Zh(4*o),k,c),u.QM=new dR(new s.Zh(4*o),k,c),u.QO=new dR(new s.Zh(4*o),k,c),u.QC=new dR(new s.Zh(4*o),k,c),await h.readToBuffer(u.QL.eval,0,4*o,i[7][0].p+o),await h.readToBuffer(u.QR.eval,0,4*o,i[8][0].p+o),await h.readToBuffer(u.QM.eval,0,4*o,i[9][0].p+o),await h.readToBuffer(u.QO.eval,0,4*o,i[10][0].p+o),await h.readToBuffer(u.QC.eval,0,4*o,i[11][0].p+o),u.lagrange1=new dR(await S(h,i,15),k,c),r.T0=new s.Zh(4*o),c&&c.info("\xb7\xb7\xb7 Computing T0 evaluations");for(let a=0;a<4*j.domainSize;a++){c&&0!==a&&a%1e5==0&&c.info(`      T0 evaluation ${a}/${4*j.domainSize}`);let b=u.A.getEvaluation(a),d=u.B.getEvaluation(a),e=u.C.getEvaluation(a),f=u.QL.getEvaluation(a),g=u.QR.getEvaluation(a),h=u.QM.getEvaluation(a),i=u.QO.getEvaluation(a),k=u.QC.getEvaluation(a),n=l.zero;for(let b=0;b<j.nPublic;b++){let c=5*b*j.domainSize+j.domainSize+a,d=u.lagrange1.getEvaluation(c),e=r.A.slice(b*m,(b+1)*m);n=l.sub(n,l.mul(d,e))}let o=l.mul(b,f),p=l.mul(d,g),q=l.mul(l.mul(b,d),h),s=l.mul(e,i),t=l.add(o,l.add(p,l.add(q,l.add(s,l.add(k,n)))));r.T0.set(t,a*m)}if(c&&c.info("buffer T0: "+r.T0.byteLength/m),c&&c.info("\xb7\xb7\xb7 Computing T0 ifft"),t.T0=await dQ.fromEvaluations(r.T0,k,c),c&&c.info("T0 length: "+t.T0.length()),c&&c.info("T0 degree: "+t.T0.degree()),c&&c.info("\xb7\xb7\xb7 Computing T0 / ZH"),t.T0.divByZerofier(j.domainSize,l.one),t.T0.degree()>=2*j.domainSize-2)throw Error(`T0 Polynomial is not well calculated (degree is ${t.T0.degree()} and must be less than ${2*j.domainSize+2}`);delete r.T0}async function e(){let a=new d6(4,k,c);if(a.addPolynomial(0,t.A),a.addPolynomial(1,t.B),a.addPolynomial(2,t.C),a.addPolynomial(3,t.T0),t.C1=a.getPolynomial(),t.C1.degree()>=8*j.domainSize-8)throw Error("C1 Polynomial is not well calculated")}}async function G(){c&&c.info("> Computing challenges beta and gamma");let a=new dO(k);a.addPolCommitment(j.C0);for(let b=0;b<j.nPublic;b++)a.addScalar(r.A.slice(b*m,b*m+m));a.addPolCommitment(y.getPolynomial("C1")),w.beta=a.getChallenge(),c&&c.info("\xb7\xb7\xb7 challenges.beta: "+l.toString(w.beta)),a.reset(),a.addScalar(w.beta),w.gamma=a.getChallenge(),c&&c.info("\xb7\xb7\xb7 challenges.gamma: "+l.toString(w.gamma)),c&&c.info("> Computing Z polynomial"),await d(),c&&c.info("> Computing T1 polynomial"),await e(),c&&c.info("> Computing T2 polynomial"),await f(),c&&c.info("> Computing C2 polynomial"),await g(),c&&c.info("> Computing C2 multi exponentiation");let b=await t.C2.multiExponentiation(z,"C2");return y.addPolynomial("C2",b),0;async function d(){c&&c.info("\xb7\xb7\xb7 Computing Z evaluations");let a=new s.Zh(o),b=new s.Zh(o);a.set(l.one,0),b.set(l.one,0);let d=l.one;for(let e=0;e<j.domainSize;e++){c&&0!==e&&e%1e5==0&&c.info(`    Z evaluation ${e}/${j.domainSize}`);let f=e*m,g=l.mul(w.beta,d),h=r.A.slice(f,f+m);h=l.add(h,g),h=l.add(h,w.gamma);let i=r.B.slice(f,f+m);i=l.add(i,l.mul(j.k1,g)),i=l.add(i,w.gamma);let k=r.C.slice(f,f+m);k=l.add(k,l.mul(j.k2,g)),k=l.add(k,w.gamma);let n=l.mul(h,l.mul(i,k)),o=r.A.slice(f,f+m);o=l.add(o,l.mul(w.beta,u.Sigma1.getEvaluation(4*e))),o=l.add(o,w.gamma);let p=r.B.slice(f,f+m);p=l.add(p,l.mul(w.beta,u.Sigma2.getEvaluation(4*e))),p=l.add(p,w.gamma);let q=r.C.slice(f,f+m);q=l.add(q,l.mul(w.beta,u.Sigma3.getEvaluation(4*e))),q=l.add(q,w.gamma);let s=l.mul(o,l.mul(p,q));n=l.mul(a.slice(f,f+m),n),a.set(n,(e+1)%j.domainSize*m),s=l.mul(b.slice(f,f+m),s),b.set(s,(e+1)%j.domainSize*m),d=l.mul(d,l.w[j.power])}b=await l.batchInverse(b);for(let c=0;c<j.domainSize;c++){let d=c*m,e=l.mul(a.slice(d,d+m),b.slice(d,d+m));a.set(e,d)}if(r.Z=a,!l.eq(a.slice(0,m),l.one))throw Error("Copy constraints does not match");if(c&&c.info("\xb7\xb7\xb7 Computing Z ifft"),t.Z=await dQ.fromEvaluations(r.Z,k,c),c&&c.info("\xb7\xb7\xb7 Computing Z fft"),u.Z=await dR.fromPolynomial(t.Z,4,k,c),t.Z.blindCoefficients([w.b[9],w.b[8],w.b[7]]),t.Z.degree()>=j.domainSize+3)throw Error("Z Polynomial is not well calculated");delete r.Z}async function e(){c&&c.info("\xb7\xb7\xb7 Computing T1 evaluations"),r.T1=new s.Zh(2*o),r.T1z=new s.Zh(2*o);let a=l.one;for(let b=0;b<2*j.domainSize;b++){c&&0!==b&&b%1e5==0&&c.info(`    T1 evaluation ${b}/${4*j.domainSize}`);let d=l.square(a),e=u.Z.getEvaluation(2*b),f=l.add(l.add(l.mul(w.b[7],d),l.mul(w.b[8],a)),w.b[9]),g=u.lagrange1.getEvaluation(j.domainSize+2*b),h=l.mul(l.sub(e,l.one),g),i=l.mul(f,g);r.T1.set(h,b*m),r.T1z.set(i,b*m),a=l.mul(a,l.w[j.power+1])}if(c&&c.info("\xb7\xb7\xb7 Computing T1 ifft"),t.T1=await dQ.fromEvaluations(r.T1,k,c),t.T1.divByZerofier(j.domainSize,l.one),c&&c.info("\xb7\xb7\xb7 Computing T1z ifft"),t.T1z=await dQ.fromEvaluations(r.T1z,k,c),t.T1.add(t.T1z),t.T1.degree()>=j.domainSize+2)throw Error("T1 Polynomial is not well calculated");delete r.T1,delete r.T1z,delete t.T1z}async function f(){c&&c.info("\xb7\xb7\xb7 Computing T2 evaluations"),r.T2=new s.Zh(4*o),r.T2z=new s.Zh(4*o);let a=l.one;for(let b=0;b<4*j.domainSize;b++){c&&0!==b&&b%1e5==0&&c.info(`    T2 evaluation ${b}/${4*j.domainSize}`);let d=l.square(a),e=l.mul(a,l.w[j.power]),f=l.square(e),g=u.A.getEvaluation(b),h=u.B.getEvaluation(b),i=u.C.getEvaluation(b),k=u.Z.getEvaluation(b),n=u.Z.getEvaluation((4*j.domainSize+4+b)%(4*j.domainSize)),o=l.add(l.add(l.mul(w.b[7],d),l.mul(w.b[8],a)),w.b[9]),p=l.add(l.add(l.mul(w.b[7],f),l.mul(w.b[8],e)),w.b[9]),q=u.Sigma1.getEvaluation(b),s=u.Sigma2.getEvaluation(b),t=u.Sigma3.getEvaluation(b),v=l.mul(w.beta,a),x=l.add(g,v);x=l.add(x,w.gamma);let y=l.add(h,l.mul(v,j.k1));y=l.add(y,w.gamma);let z=l.add(i,l.mul(v,j.k2));z=l.add(z,w.gamma);let A=l.mul(l.mul(l.mul(x,y),z),k),B=l.mul(l.mul(l.mul(x,y),z),o),C=l.add(g,l.mul(w.beta,q));C=l.add(C,w.gamma);let D=l.add(h,l.mul(w.beta,s));D=l.add(D,w.gamma);let E=l.add(i,l.mul(w.beta,t));E=l.add(E,w.gamma);let F=l.mul(l.mul(l.mul(C,D),E),n),G=l.mul(l.mul(l.mul(C,D),E),p),H=l.sub(A,F),I=l.sub(B,G);r.T2.set(H,b*m),r.T2z.set(I,b*m),a=l.mul(a,l.w[j.power+2])}if(c&&c.info("\xb7\xb7\xb7 Computing T2 ifft"),t.T2=await dQ.fromEvaluations(r.T2,k,c),c&&c.info("\xb7\xb7\xb7 Computing T2 / ZH"),t.T2.divByZerofier(j.domainSize,l.one),c&&c.info("\xb7\xb7\xb7 Computing T2z ifft"),t.T2z=await dQ.fromEvaluations(r.T2z,k,c),t.T2.add(t.T2z),t.T2.degree()>=3*j.domainSize)throw Error("T2 Polynomial is not well calculated");delete r.T2,delete r.T2z,delete t.T2z}async function g(){let a=new d6(3,k,c);if(a.addPolynomial(0,t.Z),a.addPolynomial(1,t.T1),a.addPolynomial(2,t.T2),t.C2=a.getPolynomial(),t.C2.degree()>=9*j.domainSize)throw Error("C2 Polynomial is not well calculated")}}async function H(){c&&c.info("> Computing challenge xi");let a=new dO(k);a.addScalar(w.gamma),a.addPolCommitment(y.getPolynomial("C2")),w.xiSeed=a.getChallenge();let b=l.square(w.xiSeed);x.w8=[],x.w8[0]=l.one;for(let a=1;a<8;a++)x.w8[a]=l.mul(x.w8[a-1],j.w8);x.w4=[],x.w4[0]=l.one;for(let a=1;a<4;a++)x.w4[a]=l.mul(x.w4[a-1],j.w4);x.w3=[],x.w3[0]=l.one,x.w3[1]=j.w3,x.w3[2]=l.square(j.w3),x.S0={},x.S0.h0w8=[],x.S0.h0w8[0]=l.mul(b,w.xiSeed);for(let a=1;a<8;a++)x.S0.h0w8[a]=l.mul(x.S0.h0w8[0],x.w8[a]);x.S1={},x.S1.h1w4=[],x.S1.h1w4[0]=l.square(x.S0.h0w8[0]);for(let a=1;a<4;a++)x.S1.h1w4[a]=l.mul(x.S1.h1w4[0],x.w4[a]);x.S2={},x.S2.h2w3=[],x.S2.h2w3[0]=l.mul(x.S1.h1w4[0],b),x.S2.h2w3[1]=l.mul(x.S2.h2w3[0],x.w3[1]),x.S2.h2w3[2]=l.mul(x.S2.h2w3[0],x.w3[2]),x.S2.h3w3=[],x.S2.h3w3[0]=l.mul(x.S2.h2w3[0],j.wr),x.S2.h3w3[1]=l.mul(x.S2.h3w3[0],x.w3[1]),x.S2.h3w3[2]=l.mul(x.S2.h3w3[0],x.w3[2]),w.xi=l.mul(l.square(x.S2.h2w3[0]),x.S2.h2w3[0]),c&&c.info("\xb7\xb7\xb7 challenges.xi: "+l.toString(w.xi)),t.QL=new dQ(new s.Zh(o),k,c),t.QR=new dQ(new s.Zh(o),k,c),t.QM=new dQ(new s.Zh(o),k,c),t.QO=new dQ(new s.Zh(o),k,c),t.QC=new dQ(new s.Zh(o),k,c),await h.readToBuffer(t.QL.coef,0,o,i[7][0].p),await h.readToBuffer(t.QR.coef,0,o,i[8][0].p),await h.readToBuffer(t.QM.coef,0,o,i[9][0].p),await h.readToBuffer(t.QO.coef,0,o,i[10][0].p),await h.readToBuffer(t.QC.coef,0,o,i[11][0].p),c&&c.info("\xb7\xb7\xb7 Computing evaluations"),y.addEvaluation("ql",t.QL.evaluate(w.xi)),y.addEvaluation("qr",t.QR.evaluate(w.xi)),y.addEvaluation("qm",t.QM.evaluate(w.xi)),y.addEvaluation("qo",t.QO.evaluate(w.xi)),y.addEvaluation("qc",t.QC.evaluate(w.xi)),y.addEvaluation("s1",t.Sigma1.evaluate(w.xi)),y.addEvaluation("s2",t.Sigma2.evaluate(w.xi)),y.addEvaluation("s3",t.Sigma3.evaluate(w.xi)),y.addEvaluation("a",t.A.evaluate(w.xi)),y.addEvaluation("b",t.B.evaluate(w.xi)),y.addEvaluation("c",t.C.evaluate(w.xi)),y.addEvaluation("z",t.Z.evaluate(w.xi)),w.xiw=l.mul(w.xi,l.w[j.power]),y.addEvaluation("zw",t.Z.evaluate(w.xiw)),y.addEvaluation("t1w",t.T1.evaluate(w.xiw)),y.addEvaluation("t2w",t.T2.evaluate(w.xiw))}async function I(){c&&c.info("> Computing challenge alpha");let a=new dO(k);a.addScalar(w.xiSeed),a.addScalar(y.getEvaluation("ql")),a.addScalar(y.getEvaluation("qr")),a.addScalar(y.getEvaluation("qm")),a.addScalar(y.getEvaluation("qo")),a.addScalar(y.getEvaluation("qc")),a.addScalar(y.getEvaluation("s1")),a.addScalar(y.getEvaluation("s2")),a.addScalar(y.getEvaluation("s3")),a.addScalar(y.getEvaluation("a")),a.addScalar(y.getEvaluation("b")),a.addScalar(y.getEvaluation("c")),a.addScalar(y.getEvaluation("z")),a.addScalar(y.getEvaluation("zw")),a.addScalar(y.getEvaluation("t1w")),a.addScalar(y.getEvaluation("t2w")),w.alpha=a.getChallenge(),c&&c.info("\xb7\xb7\xb7 challenges.alpha: "+l.toString(w.alpha)),c&&c.info("> Reading C0 polynomial"),t.C0=new dQ(new s.Zh(8*o),k,c),await h.readToBuffer(t.C0.coef,0,8*o,i[17][0].p),c&&c.info("> Computing R0 polynomial"),function(){if(t.R0=dQ.lagrangePolynomialInterpolation([x.S0.h0w8[0],x.S0.h0w8[1],x.S0.h0w8[2],x.S0.h0w8[3],x.S0.h0w8[4],x.S0.h0w8[5],x.S0.h0w8[6],x.S0.h0w8[7]],[t.C0.evaluate(x.S0.h0w8[0]),t.C0.evaluate(x.S0.h0w8[1]),t.C0.evaluate(x.S0.h0w8[2]),t.C0.evaluate(x.S0.h0w8[3]),t.C0.evaluate(x.S0.h0w8[4]),t.C0.evaluate(x.S0.h0w8[5]),t.C0.evaluate(x.S0.h0w8[6]),t.C0.evaluate(x.S0.h0w8[7])],k),t.R0.degree()>7)throw Error("R0 Polynomial is not well calculated")}(),c&&c.info("> Computing R1 polynomial"),function(){if(t.R1=dQ.lagrangePolynomialInterpolation([x.S1.h1w4[0],x.S1.h1w4[1],x.S1.h1w4[2],x.S1.h1w4[3]],[t.C1.evaluate(x.S1.h1w4[0]),t.C1.evaluate(x.S1.h1w4[1]),t.C1.evaluate(x.S1.h1w4[2]),t.C1.evaluate(x.S1.h1w4[3])],k),t.R1.degree()>3)throw Error("R1 Polynomial is not well calculated")}(),c&&c.info("> Computing R2 polynomial"),function(){if(t.R2=dQ.lagrangePolynomialInterpolation([x.S2.h2w3[0],x.S2.h2w3[1],x.S2.h2w3[2],x.S2.h3w3[0],x.S2.h3w3[1],x.S2.h3w3[2]],[t.C2.evaluate(x.S2.h2w3[0]),t.C2.evaluate(x.S2.h2w3[1]),t.C2.evaluate(x.S2.h2w3[2]),t.C2.evaluate(x.S2.h3w3[0]),t.C2.evaluate(x.S2.h3w3[1]),t.C2.evaluate(x.S2.h3w3[2])],k),t.R2.degree()>5)throw Error("R2 Polynomial is not well calculated")}(),c&&c.info("> Computing F polynomial"),await d(),c&&c.info("> Computing W1 multi exponentiation");let b=await t.F.multiExponentiation(z,"W1");return y.addPolynomial("W1",b),0;async function d(){c&&c.info("\xb7\xb7\xb7 Computing F polynomial"),t.F=dQ.fromPolynomial(t.C0,k,c),t.F.sub(t.R0),t.F.divByZerofier(8,w.xi);let a=dQ.fromPolynomial(t.C1,k,c);a.sub(t.R1),a.mulScalar(w.alpha),a.divByZerofier(4,w.xi);let b=dQ.fromPolynomial(t.C2,k,c);if(b.sub(t.R2),b.mulScalar(l.square(w.alpha)),b.divByZerofier(3,w.xi),b.divByZerofier(3,w.xiw),t.F.add(a),t.F.add(b),t.F.degree()>=9*j.domainSize-6)throw Error("F Polynomial is not well calculated")}}async function K(){c&&c.info("> Computing challenge y");let a=new dO(k);a.addScalar(w.alpha),a.addPolCommitment(y.getPolynomial("W1")),w.y=a.getChallenge(),c&&c.info("\xb7\xb7\xb7 challenges.y: "+l.toString(w.y)),c&&c.info("> Computing L polynomial"),await g(),c&&c.info("> Computing ZTS2 polynomial"),await i();let b=t.ZTS2.evaluate(w.y);b=l.inv(b),t.L.mulScalar(b);let d=dQ.fromCoefficientsArray([l.neg(w.y),l.one],k);c&&c.info("> Computing W' = L / ZTS2 polynomial");let e=t.L.divBy(d);if(e.degree()>0)throw Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${e.degree()} and should be 0`);if(t.L.degree()>=9*j.domainSize-1)throw Error("Degree of L(X)/(ZTS2(y)(X-y)) is not correct");c&&c.info("> Computing W' multi exponentiation");let f=await t.L.multiExponentiation(z,"W2");return y.addPolynomial("W2",f),0;async function g(){c&&c.info("\xb7\xb7\xb7 Computing L polynomial");let a=t.R0.evaluate(w.y),b=t.R1.evaluate(w.y),d=t.R2.evaluate(w.y),e=l.sub(w.y,x.S0.h0w8[0]);for(let a=1;a<8;a++)e=l.mul(e,l.sub(w.y,x.S0.h0w8[a]));let f=l.sub(w.y,x.S1.h1w4[0]);for(let a=1;a<4;a++)f=l.mul(f,l.sub(w.y,x.S1.h1w4[a]));let g=l.sub(w.y,x.S2.h2w3[0]);for(let a=1;a<3;a++)g=l.mul(g,l.sub(w.y,x.S2.h2w3[a]));for(let a=0;a<3;a++)g=l.mul(g,l.sub(w.y,x.S2.h3w3[a]));let i=l.mul(f,g),m=l.mul(w.alpha,l.mul(e,g)),n=l.mul(l.square(w.alpha),l.mul(e,f));v.denH1=f,v.denH2=g,t.L=dQ.fromPolynomial(t.C0,k,c),t.L.subScalar(a),t.L.mulScalar(i);let o=dQ.fromPolynomial(t.C1,k,c);o.subScalar(b),o.mulScalar(m);let p=dQ.fromPolynomial(t.C2,k,c);p.subScalar(d),p.mulScalar(n),t.L.add(o),t.L.add(p),c&&c.info("> Computing ZT polynomial"),await h();let q=t.ZT.evaluate(w.y);if(t.F.mulScalar(q),t.L.sub(t.F),t.L.degree()>=9*j.domainSize)throw Error("L Polynomial is not well calculated");delete r.L}async function h(){t.ZT=dQ.zerofierPolynomial([x.S0.h0w8[0],x.S0.h0w8[1],x.S0.h0w8[2],x.S0.h0w8[3],x.S0.h0w8[4],x.S0.h0w8[5],x.S0.h0w8[6],x.S0.h0w8[7],x.S1.h1w4[0],x.S1.h1w4[1],x.S1.h1w4[2],x.S1.h1w4[3],x.S2.h2w3[0],x.S2.h2w3[1],x.S2.h2w3[2],x.S2.h3w3[0],x.S2.h3w3[1],x.S2.h3w3[2]],k)}async function i(){t.ZTS2=dQ.zerofierPolynomial([x.S1.h1w4[0],x.S1.h1w4[1],x.S1.h1w4[2],x.S1.h1w4[3],x.S2.h2w3[0],x.S2.h2w3[1],x.S2.h2w3[2],x.S2.h3w3[0],x.S2.h3w3[1],x.S2.h3w3[2]],k)}}}let{unstringifyBigInts:ea}=s.Wp;async function eb(a,b,c,d,e,f){let g=ea(a),h={type:"mem"};return await bk(g,b,h,e),await d9(c,h,d,f)}let{unstringifyBigInts:ec}=s.Wp;async function ed(a,b,c,d){var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s;let t,u,v,w,x;d&&d.info("FFLONK VERIFIER STARTED"),a=ec(a),c=ec(c);let y=await $(a.curve),z=(e=y,(f=a).k1=e.Fr.fromObject(f.k1),f.k2=e.Fr.fromObject(f.k2),f.w=e.Fr.fromObject(f.w),f.w3=e.Fr.fromObject(f.w3),f.w4=e.Fr.fromObject(f.w4),f.w8=e.Fr.fromObject(f.w8),f.wr=e.Fr.fromObject(f.wr),f.X_2=e.G2.fromObject(f.X_2),f.C0=e.G1.fromObject(f.C0),f),A=new dx(y,d);A.fromObjectProof(c);let B=ec(b);if(B.length!==z.nPublic)return d.error("Number of public signals does not match with vk"),!1;let C=y.Fr;if(d&&(d.info("----------------------------"),d.info("  FFLONK VERIFY SETTINGS"),d.info(`  Curve:         ${y.name}`),d.info(`  Circuit power: ${z.power}`),d.info(`  Domain size:   ${2**z.power}`),d.info(`  Public vars:   ${z.nPublic}`),d.info("----------------------------")),d&&d.info("> Checking commitments belong to G1"),g=y,h=A,i=z,!((t=g.G1).isValid(h.polynomials.C1)&&t.isValid(h.polynomials.C2)&&t.isValid(h.polynomials.W1)&&t.isValid(h.polynomials.W2)&&t.isValid(i.C0)))return d&&d.error("Proof commitments are not valid"),!1;if(d&&d.info("> Checking evaluations belong to F"),!(ef(j=y,(k=A).evaluations.ql)&&ef(j,k.evaluations.qr)&&ef(j,k.evaluations.qm)&&ef(j,k.evaluations.qo)&&ef(j,k.evaluations.qc)&&ef(j,k.evaluations.s1)&&ef(j,k.evaluations.s2)&&ef(j,k.evaluations.s3)&&ef(j,k.evaluations.a)&&ef(j,k.evaluations.b)&&ef(j,k.evaluations.c)&&ef(j,k.evaluations.z)&&ef(j,k.evaluations.zw)&&ef(j,k.evaluations.t1w)&&ef(j,k.evaluations.t2w)))return d&&d.error("Proof evaluations are not valid."),!1;if(d&&d.info("> Checking public inputs belong to F"),!function(a,b){for(let c=0;c<b.length;c++)if(!ee(a,b[c]))return!1;return!0}(y,B))return d&&d.error("Public inputs are not valid."),!1;d&&d.info("> Computing challenges");let{challenges:D,roots:E}=function(a,b,c,d,e){let f=a.Fr,g={},h={},i=new dO(a);i.addPolCommitment(c.C0);for(let a=0;a<d.length;a++)i.addScalar(f.e(d[a]));i.addPolCommitment(b.polynomials.C1),g.beta=i.getChallenge(),i.reset(),i.addScalar(g.beta),g.gamma=i.getChallenge(),i.reset(),i.addScalar(g.gamma),i.addPolCommitment(b.polynomials.C2);let j=i.getChallenge(),k=f.square(j),l=[];l[1]=c.w8,l[2]=f.square(c.w8),l[3]=f.mul(l[2],c.w8),l[4]=f.mul(l[3],c.w8),l[5]=f.mul(l[4],c.w8),l[6]=f.mul(l[5],c.w8),l[7]=f.mul(l[6],c.w8);let m=[];m[1]=c.w4,m[2]=f.square(c.w4),m[3]=f.mul(m[2],c.w4);let n=[];n[1]=c.w3,n[2]=f.square(c.w3),h.S0={},h.S0.h0w8=[],h.S0.h0w8[0]=f.mul(k,j);for(let a=1;a<8;a++)h.S0.h0w8[a]=f.mul(h.S0.h0w8[0],l[a]);h.S1={},h.S1.h1w4=[],h.S1.h1w4[0]=f.square(h.S0.h0w8[0]);for(let a=1;a<4;a++)h.S1.h1w4[a]=f.mul(h.S1.h1w4[0],m[a]);h.S2={},h.S2.h2w3=[],h.S2.h2w3[0]=f.mul(h.S1.h1w4[0],k),h.S2.h2w3[1]=f.mul(h.S2.h2w3[0],n[1]),h.S2.h2w3[2]=f.mul(h.S2.h2w3[0],n[2]),h.S2.h3w3=[],h.S2.h3w3[0]=f.mul(h.S2.h2w3[0],c.wr),h.S2.h3w3[1]=f.mul(h.S2.h3w3[0],n[1]),h.S2.h3w3[2]=f.mul(h.S2.h3w3[0],n[2]),g.xi=f.mul(f.square(h.S2.h2w3[0]),h.S2.h2w3[0]),g.xiw=f.mul(g.xi,f.w[c.power]),g.xiN=g.xi,c.domainSize=1;for(let a=0;a<c.power;a++)g.xiN=f.square(g.xiN),c.domainSize*=2;return i.reset(),i.addScalar(j),i.addScalar(b.evaluations.ql),i.addScalar(b.evaluations.qr),i.addScalar(b.evaluations.qm),i.addScalar(b.evaluations.qo),i.addScalar(b.evaluations.qc),i.addScalar(b.evaluations.s1),i.addScalar(b.evaluations.s2),i.addScalar(b.evaluations.s3),i.addScalar(b.evaluations.a),i.addScalar(b.evaluations.b),i.addScalar(b.evaluations.c),i.addScalar(b.evaluations.z),i.addScalar(b.evaluations.zw),i.addScalar(b.evaluations.t1w),i.addScalar(b.evaluations.t2w),g.alpha=i.getChallenge(),i.reset(),i.addScalar(g.alpha),i.addPolCommitment(b.polynomials.W1),g.y=i.getChallenge(),e&&(e.info("\xb7\xb7\xb7 challenges.beta:  "+f.toString(g.beta)),e.info("\xb7\xb7\xb7 challenges.gamma: "+f.toString(g.gamma)),e.info("\xb7\xb7\xb7 challenges.xi:    "+f.toString(g.xi)),e.info("\xb7\xb7\xb7 challenges.alpha: "+f.toString(g.alpha)),e.info("\xb7\xb7\xb7 challenges.y:     "+f.toString(g.y))),{challenges:g,roots:h}}(y,A,z,B,d);d&&d.info("> Computing Zero polynomial evaluation Z_H(xi)"),D.zh=C.sub(D.xiN,C.one),D.invzh=C.inv(D.zh),d&&d.info("> Computing Lagrange evaluations");let F=await eg(y,D,z);d&&d.info("> Computing polynomial identities PI(X)");let G=function(a,b,c){let d=a.Fr,e=d.zero;for(let a=0;a<b.length;a++){let f=d.e(b[a]);e=d.sub(e,d.mul(f,c[a+1]))}return e}(y,B,F);d&&d.info("> Computing r0(y)");let H=function(a,b,c,d,e){let f=d.Fr,g=ei(c.S0.h0w8,b.y,b.xi,d);e&&e.info("\xb7\xb7\xb7 Computing r0(y)");let h=f.zero;for(let b=0;b<8;b++){let d=[];d[1]=c.S0.h0w8[b];for(let a=2;a<8;a++)d[a]=f.mul(d[a-1],c.S0.h0w8[b]);let e=f.add(a.evaluations.ql,f.mul(a.evaluations.qr,d[1]));e=f.add(e,f.mul(a.evaluations.qo,d[2])),e=f.add(e,f.mul(a.evaluations.qm,d[3])),e=f.add(e,f.mul(a.evaluations.qc,d[4])),e=f.add(e,f.mul(a.evaluations.s1,d[5])),e=f.add(e,f.mul(a.evaluations.s2,d[6])),e=f.add(e,f.mul(a.evaluations.s3,d[7])),h=f.add(h,f.mul(e,g[b]))}return h}(A,D,E,y,d);d&&d.info("> Computing r1(y)");let I=function(a,b,c,d,e,f){let g=e.Fr,h=ei(c.S1.h1w4,b.y,b.xi,e);f&&f.info("\xb7\xb7\xb7 Computing T0(xi)");let i=g.mul(a.evaluations.ql,a.evaluations.a);i=g.add(i,g.mul(a.evaluations.qr,a.evaluations.b)),i=g.add(i,g.mul(a.evaluations.qm,g.mul(a.evaluations.a,a.evaluations.b))),i=g.add(i,g.mul(a.evaluations.qo,a.evaluations.c)),i=g.add(i,a.evaluations.qc),i=g.add(i,d),i=g.mul(i,b.invzh),f&&f.info("\xb7\xb7\xb7 Computing C1(h_1_4^i) values");let j=g.zero;for(let b=0;b<4;b++){let d=a.evaluations.a;d=g.add(d,g.mul(c.S1.h1w4[b],a.evaluations.b));let e=g.square(c.S1.h1w4[b]);d=g.add(d,g.mul(e,a.evaluations.c)),d=g.add(d,g.mul(g.mul(e,c.S1.h1w4[b]),i)),j=g.add(j,g.mul(d,h[b]))}return j}(A,D,E,G,y,d);d&&d.info("> Computing r2(y)");let J=function(a,b,c,d,e,f,g){let h=f.Fr,i=function(a,b,c,d,e){let f=e.Fr,g=[],h=a[0].length,i=h*a.length,j=f.exp(b,i),k=f.mul(f.add(c,d),f.exp(b,h)),l=f.mul(c,d),m=f.add(f.sub(j,k),l),n=f.mul(f.mul(f.e(h),a[0][0]),f.sub(c,d));for(let c=0;c<h;c++){let d=a[0][(h-1)*c%h],e=f.sub(b,a[0][c]),i=f.mul(n,f.mul(d,e));g[c]=f.div(m,i)}n=f.mul(f.mul(f.e(h),a[1][0]),f.sub(d,c));for(let c=0;c<h;c++){let d=a[1][(h-1)*c%h],e=f.sub(b,a[1][c]),i=f.mul(n,f.mul(d,e));g[c+h]=f.div(m,i)}return g}([c.S2.h2w3,c.S2.h3w3],b.y,b.xi,b.xiw,f);g&&g.info("\xb7\xb7\xb7 Computing T1(xi)");let j=h.sub(a.evaluations.z,h.one);j=h.mul(j,d),j=h.mul(j,b.invzh),g&&g.info("\xb7\xb7\xb7 Computing T2(xi)");let k=h.mul(b.beta,b.xi),l=h.add(a.evaluations.a,h.add(k,b.gamma)),m=h.add(a.evaluations.b,h.add(h.mul(k,e.k1),b.gamma)),n=h.add(a.evaluations.c,h.add(h.mul(k,e.k2),b.gamma)),o=h.mul(l,h.mul(m,h.mul(n,a.evaluations.z))),p=h.add(a.evaluations.a,h.add(h.mul(b.beta,a.evaluations.s1),b.gamma)),q=h.add(a.evaluations.b,h.add(h.mul(b.beta,a.evaluations.s2),b.gamma)),r=h.add(a.evaluations.c,h.add(h.mul(b.beta,a.evaluations.s3),b.gamma)),s=h.mul(p,h.mul(q,h.mul(r,a.evaluations.zw))),t=h.sub(o,s);t=h.mul(t,b.invzh),g&&g.info("\xb7\xb7\xb7 Computing C2(h_2_3^i) values");let u=h.zero;for(let b=0;b<3;b++){let d=h.add(a.evaluations.z,h.mul(c.S2.h2w3[b],j));d=h.add(d,h.mul(h.square(c.S2.h2w3[b]),t)),u=h.add(u,h.mul(d,i[b]))}g&&g.info("\xb7\xb7\xb7 Computing C2(h_3_3^i) values");for(let b=0;b<3;b++){let d=h.add(a.evaluations.zw,h.mul(c.S2.h3w3[b],a.evaluations.t1w));d=h.add(d,h.mul(h.square(c.S2.h3w3[b]),a.evaluations.t2w)),u=h.add(u,h.mul(d,i[b+3]))}return u}(A,D,E,F[1],z,y,d);d&&d.info("> Computing F");let K=function(a,b,c,d,e){let f=a.G1,g=a.Fr,h=g.sub(d.y,e.S0.h0w8[0]);for(let a=1;a<8;a++)h=g.mul(h,g.sub(d.y,e.S0.h0w8[a]));d.temp=h;let i=g.sub(d.y,e.S1.h1w4[0]);for(let a=1;a<4;a++)i=g.mul(i,g.sub(d.y,e.S1.h1w4[a]));let j=g.sub(d.y,e.S2.h2w3[0]);for(let a=1;a<3;a++)j=g.mul(j,g.sub(d.y,e.S2.h2w3[a]));for(let a=0;a<3;a++)j=g.mul(j,g.sub(d.y,e.S2.h3w3[a]));d.quotient1=g.mul(d.alpha,g.div(h,i)),d.quotient2=g.mul(g.square(d.alpha),g.div(h,j));let k=f.timesFr(b.polynomials.C1,d.quotient1),l=f.timesFr(b.polynomials.C2,d.quotient2);return f.add(c.C0,f.add(k,l))}(y,A,z,D,E);d&&d.info("> Computing E");let L=(l=y,m=D,n=H,o=I,p=J,u=l.G1,w=(v=l.Fr).mul(o,m.quotient1),x=v.mul(p,m.quotient2),u.timesFr(u.one,v.add(n,v.add(w,x))));d&&d.info("> Computing J");let M=(q=y,r=A,s=D,q.G1.timesFr(r.polynomials.W1,s.temp));d&&d.info("> Validate all evaluations with a pairing");let N=await eh(y,A,D,z,K,L,M);return d&&(N?d.info("PROOF VERIFIED SUCCESSFULLY"):d.warn("Invalid Proof")),d&&d.info("FFLONK VERIFIER FINISHED"),N}function ee(a,b){return s.X5.geq(b,0)&&s.X5.lt(b,a.r)}function ef(a,b){return ee(a,s.X5.fromRprLE(b))}async function eg(a,b,c){let d=a.Fr,e=Math.max(1,c.nPublic),f=new s.Zh(e*d.n8),g=new s.Zh(e*d.n8),h=d.one;for(let a=0;a<e;a++){let e=a*d.n8;f.set(d.mul(h,b.zh),e),g.set(d.mul(d.e(c.domainSize),d.sub(b.xi,h)),e),h=d.mul(h,c.w)}g=await d.batchInverse(g);let i=[];for(let a=0;a<e;a++){let b=a*d.n8;i[a+1]=d.mul(f.slice(b,b+d.n8),g.slice(b,b+d.n8))}return i}async function eh(a,b,c,d,e,f,g){let h=a.G1,i=h.timesFr(b.polynomials.W2,c.y);i=h.add(h.sub(h.sub(e,f),g),i);let j=a.G2.one,k=b.polynomials.W2,l=d.X_2;return await a.pairingEq(h.neg(i),j,k,l)}function ei(a,b,c,d){let e=d.Fr,f=a.length,g=e.sub(e.exp(b,f),c),h=e.mul(e.e(f),e.exp(a[0],f-2)),i=[];for(let c=0;c<f;c++){let d=a[(f-1)*c%f],j=e.sub(b,a[c]);i[c]=e.div(g,e.mul(e.mul(h,d),j))}return i}let{unstringifyBigInts:ej}=s.Wp;function ek(a){let b=a.toString(16);for(;b.length<64;)b="0"+b;return`0x${b}`}async function el(a,b){let c=ej(b),d=ej(a),e=await $(c.curve);e.G1,e.Fr;let f="";for(let a=0;a<d.length;a++)""!==f&&(f+=","),f+=ek(d[a]);return`[${ek(c.polynomials.C1[0])}, ${ek(c.polynomials.C1[1])},${ek(c.polynomials.C2[0])},${ek(c.polynomials.C2[1])},${ek(c.polynomials.W1[0])},${ek(c.polynomials.W1[1])},${ek(c.polynomials.W2[0])},${ek(c.polynomials.W2[1])},${ek(c.evaluations.ql)},${ek(c.evaluations.qr)},${ek(c.evaluations.qm)},${ek(c.evaluations.qo)},${ek(c.evaluations.qc)},${ek(c.evaluations.s1)},${ek(c.evaluations.s2)},${ek(c.evaluations.s3)},${ek(c.evaluations.a)},${ek(c.evaluations.b)},${ek(c.evaluations.c)},${ek(c.evaluations.z)},${ek(c.evaluations.zw)},${ek(c.evaluations.t1w)},${ek(c.evaluations.t2w)},${ek(c.evaluations.inv)}],[${f}]`}}};